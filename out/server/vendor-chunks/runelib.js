"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/runelib";
exports.ids = ["vendor-chunks/runelib"];
exports.modules = {

/***/ "(ssr)/./node_modules/runelib/dist/base26.js":
/*!*********************************************!*\
  !*** ./node_modules/runelib/dist/base26.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.base26Decode = exports.base26Encode = void 0;\nfunction base26Encode(input) {\n    let result = 0n;\n    for (let i = 0; i < input.length; i++) {\n        const charCode = BigInt(input.charCodeAt(i) - 'A'.charCodeAt(0));\n        const iInv = BigInt(input.length) - 1n - BigInt(i);\n        if (iInv == 0n) {\n            result += charCode;\n        }\n        else {\n            const base = 26n ** iInv;\n            result += base * (charCode + 1n);\n        }\n    }\n    return result;\n}\nexports.base26Encode = base26Encode;\nfunction base26Decode(s) {\n    if (s === 340282366920938463463374607431768211455n) {\n        return \"BCGDENLQRQWDSLRUGSNLBTMFIJAV\";\n    }\n    s += 1n;\n    let symbol = [];\n    while (s > 0) {\n        const i = (s - 1n) % 26n;\n        symbol.push(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".charAt(Number(i)));\n        s = (s - 1n) / 26n;\n    }\n    return symbol.reverse().join('');\n}\nexports.base26Decode = base26Decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2Jhc2UyNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0M7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2Jhc2UyNi5qcz9hNTE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXNlMjZEZWNvZGUgPSBleHBvcnRzLmJhc2UyNkVuY29kZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJhc2UyNkVuY29kZShpbnB1dCkge1xuICAgIGxldCByZXN1bHQgPSAwbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gQmlnSW50KGlucHV0LmNoYXJDb2RlQXQoaSkgLSAnQScuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIGNvbnN0IGlJbnYgPSBCaWdJbnQoaW5wdXQubGVuZ3RoKSAtIDFuIC0gQmlnSW50KGkpO1xuICAgICAgICBpZiAoaUludiA9PSAwbikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXJDb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYmFzZSA9IDI2biAqKiBpSW52O1xuICAgICAgICAgICAgcmVzdWx0ICs9IGJhc2UgKiAoY2hhckNvZGUgKyAxbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYmFzZTI2RW5jb2RlID0gYmFzZTI2RW5jb2RlO1xuZnVuY3Rpb24gYmFzZTI2RGVjb2RlKHMpIHtcbiAgICBpZiAocyA9PT0gMzQwMjgyMzY2OTIwOTM4NDYzNDYzMzc0NjA3NDMxNzY4MjExNDU1bikge1xuICAgICAgICByZXR1cm4gXCJCQ0dERU5MUVJRV0RTTFJVR1NOTEJUTUZJSkFWXCI7XG4gICAgfVxuICAgIHMgKz0gMW47XG4gICAgbGV0IHN5bWJvbCA9IFtdO1xuICAgIHdoaWxlIChzID4gMCkge1xuICAgICAgICBjb25zdCBpID0gKHMgLSAxbikgJSAyNm47XG4gICAgICAgIHN5bWJvbC5wdXNoKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIi5jaGFyQXQoTnVtYmVyKGkpKSk7XG4gICAgICAgIHMgPSAocyAtIDFuKSAvIDI2bjtcbiAgICB9XG4gICAgcmV0dXJuIHN5bWJvbC5yZXZlcnNlKCkuam9pbignJyk7XG59XG5leHBvcnRzLmJhc2UyNkRlY29kZSA9IGJhc2UyNkRlY29kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/runelib/dist/base26.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/runelib/dist/fts.js":
/*!******************************************!*\
  !*** ./node_modules/runelib/dist/fts.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.none = exports.some = void 0;\nclass None {\n    constructor() { }\n    isSome() {\n        return false;\n    }\n    map(f) {\n        return new None();\n    }\n    value() {\n        return null;\n    }\n}\nclass Some {\n    constructor(value) {\n        this._value = value;\n    }\n    isSome() {\n        return true;\n    }\n    map(f) {\n        return new Some(f(this.value()));\n    }\n    value() {\n        return this._value;\n    }\n}\nfunction some(t) {\n    return new Some(t);\n}\nexports.some = some;\nfunction none() {\n    return new None();\n}\nexports.none = none;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2Z0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9ydW5lbGliL2Rpc3QvZnRzLmpzPzczNDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vbmUgPSBleHBvcnRzLnNvbWUgPSB2b2lkIDA7XG5jbGFzcyBOb25lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIGlzU29tZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXAoZikge1xuICAgICAgICByZXR1cm4gbmV3IE5vbmUoKTtcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNsYXNzIFNvbWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlzU29tZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29tZShmKHRoaXMudmFsdWUoKSkpO1xuICAgIH1cbiAgICB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNvbWUodCkge1xuICAgIHJldHVybiBuZXcgU29tZSh0KTtcbn1cbmV4cG9ydHMuc29tZSA9IHNvbWU7XG5mdW5jdGlvbiBub25lKCkge1xuICAgIHJldHVybiBuZXcgTm9uZSgpO1xufVxuZXhwb3J0cy5ub25lID0gbm9uZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/runelib/dist/fts.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/runelib/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/runelib/dist/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.removeSpacers = exports.getSpacersVal = exports.applySpacers = exports.some = exports.none = void 0;\n__exportStar(__webpack_require__(/*! ./runestones */ \"(ssr)/./node_modules/runelib/dist/runestones.js\"), exports);\nvar fts_1 = __webpack_require__(/*! ./fts */ \"(ssr)/./node_modules/runelib/dist/fts.js\");\nObject.defineProperty(exports, \"none\", ({ enumerable: true, get: function () { return fts_1.none; } }));\nObject.defineProperty(exports, \"some\", ({ enumerable: true, get: function () { return fts_1.some; } }));\nvar spacers_1 = __webpack_require__(/*! ./spacers */ \"(ssr)/./node_modules/runelib/dist/spacers.js\");\nObject.defineProperty(exports, \"applySpacers\", ({ enumerable: true, get: function () { return spacers_1.applySpacers; } }));\nObject.defineProperty(exports, \"getSpacersVal\", ({ enumerable: true, get: function () { return spacers_1.getSpacersVal; } }));\nObject.defineProperty(exports, \"removeSpacers\", ({ enumerable: true, get: function () { return spacers_1.removeSpacers; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLFlBQVksR0FBRyxZQUFZO0FBQ2xHLGFBQWEsbUJBQU8sQ0FBQyxxRUFBYztBQUNuQyxZQUFZLG1CQUFPLENBQUMsdURBQU87QUFDM0Isd0NBQXVDLEVBQUUscUNBQXFDLHNCQUFzQixFQUFDO0FBQ3JHLHdDQUF1QyxFQUFFLHFDQUFxQyxzQkFBc0IsRUFBQztBQUNyRyxnQkFBZ0IsbUJBQU8sQ0FBQywrREFBVztBQUNuQyxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgsaURBQWdELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzNILGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3J1bmVsaWIvZGlzdC9pbmRleC5qcz83ZTQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbW92ZVNwYWNlcnMgPSBleHBvcnRzLmdldFNwYWNlcnNWYWwgPSBleHBvcnRzLmFwcGx5U3BhY2VycyA9IGV4cG9ydHMuc29tZSA9IGV4cG9ydHMubm9uZSA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ydW5lc3RvbmVzXCIpLCBleHBvcnRzKTtcbnZhciBmdHNfMSA9IHJlcXVpcmUoXCIuL2Z0c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vbmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ0c18xLm5vbmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb21lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdHNfMS5zb21lOyB9IH0pO1xudmFyIHNwYWNlcnNfMSA9IHJlcXVpcmUoXCIuL3NwYWNlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcHBseVNwYWNlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwYWNlcnNfMS5hcHBseVNwYWNlcnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRTcGFjZXJzVmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzcGFjZXJzXzEuZ2V0U3BhY2Vyc1ZhbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZVNwYWNlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwYWNlcnNfMS5yZW1vdmVTcGFjZXJzOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/runelib/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/runelib/dist/leb128.js":
/*!*********************************************!*\
  !*** ./node_modules/runelib/dist/leb128.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeLEB128 = exports.encodeLEB128 = void 0;\nfunction encodeLEB128(value) {\n    const bytes = [];\n    let more = true;\n    while (more) {\n        let byte = Number(value & BigInt(0x7F)); // Get the lowest 7 bits\n        value >>= BigInt(7);\n        if (value === BigInt(0)) { // No more data to encode\n            more = false;\n        }\n        else { // More bytes to come\n            byte |= 0x80; // Set the continuation bit\n        }\n        bytes.push(byte);\n    }\n    // Convert array to Buffer\n    return bytes;\n}\nexports.encodeLEB128 = encodeLEB128;\nfunction decodeLEB128(buf) {\n    let n = BigInt(0);\n    for (let i = 0; i < buf.length; i++) {\n        const byte = BigInt(buf[i]);\n        if (i > 18) {\n            throw new Error(\"Overlong\");\n        }\n        let value = byte & BigInt(127);\n        if ((i == 18) && ((value & BigInt(124)) != BigInt(0))) {\n            throw new Error(\"Overflow\");\n        }\n        n |= value << (BigInt(7) * BigInt(i));\n        if ((byte & BigInt(128)) == BigInt(0)) {\n            return {\n                n,\n                len: i + 1\n            };\n        }\n    }\n    throw new Error(\"Unterminated\");\n}\nexports.decodeLEB128 = decodeLEB128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2xlYjEyOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLGVBQWU7QUFDZiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3J1bmVsaWIvZGlzdC9sZWIxMjguanM/ODQwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlTEVCMTI4ID0gZXhwb3J0cy5lbmNvZGVMRUIxMjggPSB2b2lkIDA7XG5mdW5jdGlvbiBlbmNvZGVMRUIxMjgodmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGxldCBtb3JlID0gdHJ1ZTtcbiAgICB3aGlsZSAobW9yZSkge1xuICAgICAgICBsZXQgYnl0ZSA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweDdGKSk7IC8vIEdldCB0aGUgbG93ZXN0IDcgYml0c1xuICAgICAgICB2YWx1ZSA+Pj0gQmlnSW50KDcpO1xuICAgICAgICBpZiAodmFsdWUgPT09IEJpZ0ludCgwKSkgeyAvLyBObyBtb3JlIGRhdGEgdG8gZW5jb2RlXG4gICAgICAgICAgICBtb3JlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1vcmUgYnl0ZXMgdG8gY29tZVxuICAgICAgICAgICAgYnl0ZSB8PSAweDgwOyAvLyBTZXQgdGhlIGNvbnRpbnVhdGlvbiBiaXRcbiAgICAgICAgfVxuICAgICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IGFycmF5IHRvIEJ1ZmZlclxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMuZW5jb2RlTEVCMTI4ID0gZW5jb2RlTEVCMTI4O1xuZnVuY3Rpb24gZGVjb2RlTEVCMTI4KGJ1Zikge1xuICAgIGxldCBuID0gQmlnSW50KDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBCaWdJbnQoYnVmW2ldKTtcbiAgICAgICAgaWYgKGkgPiAxOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3ZlcmxvbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlID0gYnl0ZSAmIEJpZ0ludCgxMjcpO1xuICAgICAgICBpZiAoKGkgPT0gMTgpICYmICgodmFsdWUgJiBCaWdJbnQoMTI0KSkgIT0gQmlnSW50KDApKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3ZlcmZsb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgbiB8PSB2YWx1ZSA8PCAoQmlnSW50KDcpICogQmlnSW50KGkpKTtcbiAgICAgICAgaWYgKChieXRlICYgQmlnSW50KDEyOCkpID09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgIGxlbjogaSArIDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW50ZXJtaW5hdGVkXCIpO1xufVxuZXhwb3J0cy5kZWNvZGVMRUIxMjggPSBkZWNvZGVMRUIxMjg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/runelib/dist/leb128.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/runelib/dist/runestones.js":
/*!*************************************************!*\
  !*** ./node_modules/runelib/dist/runestones.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EtchInscription = exports.Message = exports.Runestone = exports.Etching = exports.Rune = exports.Terms = exports.Range = exports.Flaw = exports.Tag = exports.Flag = exports.Edict = exports.RuneId = void 0;\nconst bitcoinjs_lib_1 = __webpack_require__(/*! bitcoinjs-lib */ \"(ssr)/./node_modules/bitcoinjs-lib/src/index.js\");\nconst base26_1 = __webpack_require__(/*! ./base26 */ \"(ssr)/./node_modules/runelib/dist/base26.js\");\nconst fts_1 = __webpack_require__(/*! ./fts */ \"(ssr)/./node_modules/runelib/dist/fts.js\");\nconst leb128_1 = __webpack_require__(/*! ./leb128 */ \"(ssr)/./node_modules/runelib/dist/leb128.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/runelib/dist/utils.js\");\nconst spacers_1 = __webpack_require__(/*! ./spacers */ \"(ssr)/./node_modules/runelib/dist/spacers.js\");\n/**\n * Rune IDs are represented in text as BLOCK:TX.\n */\nclass RuneId {\n    constructor(block, idx) {\n        this.block = block;\n        this.idx = idx;\n    }\n    next(block, idx) {\n        if (block > BigInt(Number.MAX_SAFE_INTEGER)) {\n            return (0, fts_1.none)();\n        }\n        if (idx > BigInt(Number.MAX_SAFE_INTEGER)) {\n            return (0, fts_1.none)();\n        }\n        let b = BigInt(this.block) + block;\n        if (b > BigInt(Number.MAX_SAFE_INTEGER)) {\n            return (0, fts_1.none)();\n        }\n        let i = block === 0n ? BigInt(this.idx) + idx : idx;\n        if (i > BigInt(Number.MAX_SAFE_INTEGER)) {\n            return (0, fts_1.none)();\n        }\n        return (0, fts_1.some)(new RuneId(Number(b), Number(i)));\n    }\n}\nexports.RuneId = RuneId;\n/**\n * Rune ID block heights and transaction indices in edicts are delta encoded.\n * Edict rune ID decoding starts with a base block height and transaction index of zero.\n * When decoding each rune ID, first the encoded block height delta is added to the base block height.\n * If the block height delta is zero, the next integer is a transaction index delta.\n * If the block height delta is greater than zero, the next integer is instead an absolute transaction index.\n */\nclass Edict {\n    constructor(id, amount, output) {\n        this.id = id;\n        this.amount = amount;\n        this.output = output;\n    }\n    static from_integers(tx, id, amount, output) {\n        if (output > 4294967295n || output < 0n) {\n            return (0, fts_1.none)();\n        }\n        if (Number(output) > tx.outs.length) {\n            return (0, fts_1.none)();\n        }\n        return (0, fts_1.some)(new Edict(id, amount, Number(output)));\n    }\n}\nexports.Edict = Edict;\nvar Flag;\n(function (Flag) {\n    /** The Etching flag marks this transaction as containing an etching. */\n    Flag[Flag[\"Etching\"] = 0] = \"Etching\";\n    /** The Terms flag marks this transaction's etching as having open mint terms. */\n    Flag[Flag[\"Terms\"] = 1] = \"Terms\";\n    /** The Turbo flag marks this transaction's etching as opting into future protocol changes. These protocol changes may increase light client validation costs, or just be highly degenerate. */\n    Flag[Flag[\"Turbo\"] = 2] = \"Turbo\";\n    /** The Cenotaph flag is unrecognized. */\n    Flag[Flag[\"Cenotaph\"] = 127] = \"Cenotaph\";\n})(Flag || (exports.Flag = Flag = {}));\nvar Tag;\n(function (Tag) {\n    /** The Body tag marks the end of the runestone's fields, causing all following integers to be interpreted as edicts. */\n    Tag[Tag[\"Body\"] = 0] = \"Body\";\n    /** The Flag field contains a bitmap of flags, whose position is 1 << FLAG_VALUE: */\n    Tag[Tag[\"Flags\"] = 2] = \"Flags\";\n    /** The Rune field contains the name of the rune being etched. If the Etching flag is set but the Rune field is omitted, a reserved rune name is allocated. */\n    Tag[Tag[\"Rune\"] = 4] = \"Rune\";\n    /** The Premine field contains the amount of premined runes. */\n    Tag[Tag[\"Premine\"] = 6] = \"Premine\";\n    /** The Cap field contains the allowed number of mints. */\n    Tag[Tag[\"Cap\"] = 8] = \"Cap\";\n    /** The Amount field contains the amount of runes each mint transaction receives. */\n    Tag[Tag[\"Amount\"] = 10] = \"Amount\";\n    /** The HeightStart and HeightEnd fields contain the mint's starting and ending absolute block heights, respectively. The mint is open starting in the block with height HeightStart, and closes in the block with height HeightEnd. */\n    Tag[Tag[\"HeightStart\"] = 12] = \"HeightStart\";\n    Tag[Tag[\"HeightEnd\"] = 14] = \"HeightEnd\";\n    /** The OffsetStart and OffsetEnd fields contain the mint's starting and ending block heights, relative to the block in which the etching is mined. The mint is open starting in the block with height OffsetStart + ETCHING_HEIGHT, and closes in the block with height OffsetEnd + ETCHING_HEIGHT. */\n    Tag[Tag[\"OffsetStart\"] = 16] = \"OffsetStart\";\n    Tag[Tag[\"OffsetEnd\"] = 18] = \"OffsetEnd\";\n    /** The Mint field contains the Rune ID of the rune to be minted in this transaction. */\n    Tag[Tag[\"Mint\"] = 20] = \"Mint\";\n    /** The Pointer field contains the index of the output to which runes unallocated by edicts should be transferred. If the Pointer field is absent, unallocated runes are transferred to the first non-OP_RETURN output. */\n    Tag[Tag[\"Pointer\"] = 22] = \"Pointer\";\n    /** The Cenotaph field is unrecognized. */\n    Tag[Tag[\"Cenotaph\"] = 126] = \"Cenotaph\";\n    /** The Divisibility field, raised to the power of ten, is the number of subunits in a super unit of runes. */\n    Tag[Tag[\"Divisibility\"] = 1] = \"Divisibility\";\n    /** The Spacers field is a bitfield of • spacers that should be displayed between the letters of the rune's name. Trailing spacers are ignored. */\n    Tag[Tag[\"Spacers\"] = 3] = \"Spacers\";\n    /** The Symbol field is the Unicode codepoint of the Rune's currency symbol,\n     * which should be displayed after amounts of that rune. If a rune does not have a currency symbol,\n     * the generic currency character ¤ should be used.\n     * For example, if the Symbol is # and the divisibility is 2,\n     * the amount of 1234 units should be displayed as 12.34 #.\n     */\n    Tag[Tag[\"Symbol\"] = 5] = \"Symbol\";\n    /** The Nop field is unrecognized. */\n    Tag[Tag[\"Nop\"] = 127] = \"Nop\";\n})(Tag || (exports.Tag = Tag = {}));\nvar Flaw;\n(function (Flaw) {\n    Flaw[Flaw[\"EdictOutput\"] = 0] = \"EdictOutput\";\n    Flaw[Flaw[\"EdictRuneId\"] = 1] = \"EdictRuneId\";\n    Flaw[Flaw[\"InvalidScript\"] = 2] = \"InvalidScript\";\n    Flaw[Flaw[\"Opcode\"] = 3] = \"Opcode\";\n    Flaw[Flaw[\"SupplyOverflow\"] = 4] = \"SupplyOverflow\";\n    Flaw[Flaw[\"TrailingIntegers\"] = 5] = \"TrailingIntegers\";\n    Flaw[Flaw[\"TruncatedField\"] = 6] = \"TruncatedField\";\n    Flaw[Flaw[\"UnrecognizedEvenTag\"] = 7] = \"UnrecognizedEvenTag\";\n    Flaw[Flaw[\"UnrecognizedFlag\"] = 8] = \"UnrecognizedFlag\";\n    Flaw[Flaw[\"Varint\"] = 9] = \"Varint\";\n})(Flaw || (exports.Flaw = Flaw = {}));\nclass Range {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n}\nexports.Range = Range;\nclass Terms {\n    constructor(amount, cap, height, offset) {\n        this.amount = amount;\n        this.cap = cap;\n        this.height = height;\n        this.offset = offset;\n    }\n}\nexports.Terms = Terms;\nclass Rune {\n    constructor(value) {\n        this.value = value;\n    }\n    get name() {\n        return Rune.toName(this.value);\n    }\n    static toName(s) {\n        return (0, base26_1.base26Decode)(s);\n    }\n    static fromName(name) {\n        return new Rune((0, base26_1.base26Encode)((0, spacers_1.removeSpacers)(name)));\n    }\n    toString() {\n        return this.name;\n    }\n}\nexports.Rune = Rune;\nclass Etching {\n    constructor(divisibility, premine, rune, spacers, symbol, terms, turbo) {\n        this.divisibility = divisibility;\n        this.premine = premine;\n        this.rune = rune;\n        this.spacers = spacers;\n        this.symbol = symbol;\n        this.terms = terms;\n        this.turbo = turbo;\n    }\n}\nexports.Etching = Etching;\nEtching.MAX_DIVISIBILITY = 38;\nEtching.MAX_SPACERS = 134217727;\nclass Runestone {\n    constructor(edicts = [], etching, mint, pointer) {\n        this.edicts = edicts;\n        this.etching = etching;\n        this.mint = mint;\n        this.pointer = pointer;\n    }\n    static create(json, type = 'etch') {\n        if (type === 'etch') {\n            json = json;\n            const runename = Rune.fromName(json.name);\n            const terms = new Terms(json.amount, json.cap, new Range(json.startHeight ? (0, fts_1.some)(json.startHeight) : (0, fts_1.none)(), json.endHeight ? (0, fts_1.some)(json.endHeight) : (0, fts_1.none)()), new Range(json.startOffset ? (0, fts_1.some)(json.startOffset) : (0, fts_1.none)(), json.endOffset ? (0, fts_1.some)(json.endOffset) : (0, fts_1.none)()));\n            const divisibility = json.divisibility ? (0, fts_1.some)(json.divisibility) : (0, fts_1.none)();\n            const premine = json.premine ? (0, fts_1.some)(json.premine) : (0, fts_1.none)();\n            const spacers = json.name.indexOf('•') > -1 ? (0, fts_1.some)((0, spacers_1.getSpacersVal)(json.name)) : (0, fts_1.none)();\n            const symbol = json.symbol ? (0, fts_1.some)(json.symbol) : (0, fts_1.none)();\n            const pointer = typeof json.pointer === 'number' ? (0, fts_1.some)(json.pointer) : (0, fts_1.none)();\n            const etching = new Etching(divisibility, premine, (0, fts_1.some)(runename), spacers, symbol, (0, fts_1.some)(terms), true);\n            return new Runestone([], (0, fts_1.some)(etching), (0, fts_1.none)(), pointer);\n        }\n        else if (type === 'mint') {\n            json = json;\n            const pointer = typeof json.pointer === 'number' ? (0, fts_1.some)(json.pointer) : (0, fts_1.none)();\n            return new Runestone([], (0, fts_1.none)(), (0, fts_1.some)(new RuneId(json.block, json.txIdx)), pointer);\n        }\n        else {\n            throw new Error(`not ${type} support now`);\n        }\n    }\n    static decipher(rawTx) {\n        const tx = bitcoinjs_lib_1.Transaction.fromHex(rawTx);\n        const payload = Runestone.payload(tx);\n        if (payload.isSome()) {\n            const integers = Runestone.integers(payload.value());\n            const message = Message.from_integers(tx, integers.value());\n            const etching = message.getEtching();\n            const mint = message.getMint();\n            const pointer = message.getPointer();\n            return (0, fts_1.some)(new Runestone(message.edicts, etching, mint, pointer));\n        }\n        return (0, fts_1.none)();\n    }\n    encipher() {\n        const msg = this.toMessage();\n        const msgBuff = msg.toBuffer();\n        const prefix = Buffer.from('6a5d', 'hex'); // OP_RETURN OP_13\n        let pushNum;\n        if (msgBuff.length < 0x4c) {\n            pushNum = Buffer.alloc(1);\n            pushNum.writeUint8(msgBuff.length);\n        }\n        else if (msgBuff.length < 0x100) {\n            pushNum = Buffer.alloc(2);\n            pushNum.writeUint8(0x4c);\n            pushNum.writeUint8(msgBuff.length);\n        }\n        else if (msgBuff.length < 0x10000) {\n            pushNum = Buffer.alloc(3);\n            pushNum.writeUint8(0x4d);\n            pushNum.writeUint16LE(msgBuff.length);\n        }\n        else if (msgBuff.length < 0x100000000) {\n            pushNum = Buffer.alloc(5);\n            pushNum.writeUint8(0x4e);\n            pushNum.writeUint32LE(msgBuff.length);\n        }\n        else {\n            throw new Error(\"runestone too big!\");\n        }\n        return Buffer.concat([prefix, pushNum, msgBuff]);\n    }\n    static payload(tx) {\n        for (const output of tx.outs) {\n            //script.fromASM\n            const ls = bitcoinjs_lib_1.script.decompile(output.script);\n            if (ls[0] !== bitcoinjs_lib_1.script.OPS.OP_RETURN) {\n                continue;\n            }\n            if (ls[1] !== Runestone.MAGIC_NUMBER) {\n                continue;\n            }\n            for (let i = 2; i < ls.length; i++) {\n                const element = ls[i];\n                if (element instanceof Uint8Array) {\n                    return (0, fts_1.some)(Array.from(element));\n                }\n                return (0, fts_1.none)();\n            }\n            return (0, fts_1.none)();\n        }\n        return (0, fts_1.none)();\n    }\n    static integers(payload) {\n        let integers = [];\n        let i = 0;\n        while (i < payload.length) {\n            let { n, len } = (0, leb128_1.decodeLEB128)(payload.slice(i));\n            integers.push(n);\n            i += len;\n        }\n        return (0, fts_1.some)(integers);\n    }\n    toMessage() {\n        let fields = new Map();\n        const etching = this.etching.value();\n        if (etching) {\n            let flags = 1;\n            if (etching.terms.isSome()) {\n                let mask = 1 << Flag.Terms;\n                flags |= mask;\n            }\n            if (etching.turbo) {\n                let mask = 1 << Flag.Turbo;\n                flags |= mask;\n            }\n            fields.set(Tag.Flags, [BigInt(flags)]);\n            const rune = etching.rune.value();\n            if (rune !== null) {\n                fields.set(Tag.Rune, [BigInt(rune.value)]);\n            }\n            const divisibility = etching.divisibility.value();\n            if (divisibility !== null) {\n                fields.set(Tag.Divisibility, [BigInt(divisibility)]);\n            }\n            const spacers = etching.spacers.value();\n            if (spacers !== null) {\n                fields.set(Tag.Spacers, [BigInt(spacers)]);\n            }\n            const symbol = etching.symbol.value();\n            if (symbol !== null) {\n                fields.set(Tag.Symbol, [BigInt(symbol.charCodeAt(0))]);\n            }\n            const premine = etching.premine.value();\n            if (premine !== null) {\n                fields.set(Tag.Premine, [BigInt(premine)]);\n            }\n            const terms = etching.terms.value();\n            if (terms !== null) {\n                fields.set(Tag.Amount, [BigInt(terms.amount)]);\n                fields.set(Tag.Cap, [BigInt(terms.cap)]);\n                const heightStart = terms.height.start.value();\n                if (heightStart) {\n                    fields.set(Tag.HeightStart, [BigInt(heightStart)]);\n                }\n                const heightEnd = terms.height.end.value();\n                if (heightEnd) {\n                    fields.set(Tag.HeightEnd, [BigInt(heightEnd)]);\n                }\n                const offsetStart = terms.offset.start.value();\n                if (offsetStart) {\n                    fields.set(Tag.OffsetStart, [BigInt(offsetStart)]);\n                }\n                const offsetEnd = terms.offset.end.value();\n                if (offsetEnd) {\n                    fields.set(Tag.OffsetEnd, [BigInt(offsetEnd)]);\n                }\n            }\n        }\n        const mint = this.mint.value();\n        if (mint !== null) {\n            fields.set(Tag.Mint, [BigInt(mint.block), BigInt(mint.idx)]);\n        }\n        const pointer = this.pointer.value();\n        if (pointer !== null) {\n            fields.set(Tag.Pointer, [BigInt(pointer)]);\n        }\n        return new Message(fields, this.edicts, 0);\n    }\n}\nexports.Runestone = Runestone;\nRunestone.MAGIC_NUMBER = 93;\nclass Message {\n    constructor(fields = new Map(), edicts = [], flaws = 0) {\n        this.fields = fields;\n        this.edicts = edicts;\n        this.flaws = flaws;\n    }\n    static from_integers(tx, integers) {\n        let fields = new Map();\n        let edicts = [];\n        let flaws = 0;\n        let isBody = false;\n        for (let i = 0; i < integers.length;) {\n            let tag = integers[i];\n            if (Number(tag) === Tag.Body) {\n                isBody = true;\n                i += 1;\n                continue;\n            }\n            if (!isBody) {\n                // Fields:\n                let val = integers[i + 1];\n                const vals = fields.get(Number(tag)) || [];\n                vals.push(val);\n                fields.set(Number(tag), vals);\n                i += 2;\n            }\n            else {\n                // Edicts:\n                let id = new RuneId(0, 0);\n                for (const chunk of (0, utils_1.chunks)(integers.slice(i), 4)) {\n                    if (chunk.length != 4) {\n                        flaws |= Flaw.TrailingIntegers;\n                        break;\n                    }\n                    let next = id.next(chunk[0], chunk[1]);\n                    if (!next.isSome()) {\n                        flaws |= Flaw.EdictRuneId;\n                        break;\n                    }\n                    const edict = Edict.from_integers(tx, next.value(), chunk[2], chunk[3]);\n                    if (!edict.isSome()) {\n                        flaws |= Flaw.EdictOutput;\n                        break;\n                    }\n                    id = next.value();\n                    edicts.push(edict.value());\n                }\n                i += 4;\n            }\n        }\n        return new Message(fields, edicts, flaws);\n    }\n    addFieldVal(tag, val) {\n        const vals = this.fields.get(Number(tag)) || [];\n        vals.push(val);\n        this.fields.set(Number(tag), vals);\n    }\n    addEdict(edict) {\n        this.edicts.push(edict);\n    }\n    toBuffer() {\n        const buffArr = [];\n        // Serialize fields.\n        for (const [tag, vals] of this.fields) {\n            for (const val of vals) {\n                const tagBuff = Buffer.alloc(1);\n                tagBuff.writeUInt8(tag);\n                buffArr.push(tagBuff);\n                buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(val)));\n            }\n        }\n        // Serialize edicts.\n        if (this.edicts.length > 0) {\n            buffArr.push(Buffer.from('00', 'hex'));\n            // 1) Sort by block height\n            // 2) Sort by tx idx\n            this.edicts.sort((a, b) => {\n                if (a.id.block == b.id.block) {\n                    return a.id.idx - b.id.idx;\n                }\n                return a.id.block - b.id.block;\n            });\n            // 3) Delta encode\n            let lastBlockHeight = 0n;\n            let lastTxIdx = 0n;\n            for (let i = 0; i < this.edicts.length; i++) {\n                const edict = this.edicts[i];\n                if (i == 0) {\n                    lastBlockHeight = BigInt(edict.id.block);\n                    lastTxIdx = BigInt(edict.id.idx);\n                    buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(lastBlockHeight)));\n                    buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(lastTxIdx)));\n                }\n                else {\n                    const currBlockHeight = BigInt(edict.id.block);\n                    const currTxIdx = BigInt(edict.id.idx);\n                    if (currBlockHeight == lastBlockHeight) {\n                        const deltaTxIdx = currTxIdx - lastTxIdx;\n                        lastTxIdx = currTxIdx;\n                        buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(0n)));\n                        buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(deltaTxIdx)));\n                    }\n                    else {\n                        const deltaBlockHeight = currBlockHeight - lastBlockHeight;\n                        lastBlockHeight = currBlockHeight;\n                        lastTxIdx = currTxIdx;\n                        buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(deltaBlockHeight)));\n                        buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(currTxIdx)));\n                    }\n                }\n                buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(BigInt(edict.amount))));\n                buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(BigInt(edict.output))));\n            }\n        }\n        return Buffer.concat(buffArr);\n    }\n    getFlags() {\n        return Number(this.fields.get(Tag.Flags));\n    }\n    hasFlags(flag) {\n        const flags = this.getFlags();\n        const mask = 1 << flag;\n        return (flags & mask) != 0;\n    }\n    getMint() {\n        if (!this.fields.has(Tag.Mint)) {\n            return (0, fts_1.none)();\n        }\n        const [block, tx] = this.fields.get(Tag.Mint);\n        return (0, fts_1.some)(new RuneId(Number(block), Number(tx)));\n    }\n    getEtching() {\n        if (!this.hasFlags(Flag.Etching)) {\n            return (0, fts_1.none)();\n        }\n        const divisibility = this.getDivisibility();\n        const premine = this.getPremine();\n        const rune = this.getRune();\n        const spacers = this.getSpacers();\n        const symbol = this.getSymbol();\n        const terms = this.getTerms();\n        const turbo = this.hasFlags(Flag.Turbo);\n        return (0, fts_1.some)(new Etching(divisibility, premine, rune, spacers, symbol, terms, turbo));\n    }\n    getDivisibility() {\n        if (!this.fields.has(Tag.Divisibility)) {\n            return (0, fts_1.none)();\n        }\n        const [divisibility] = this.fields.get(Tag.Divisibility);\n        if (divisibility > Etching.MAX_DIVISIBILITY) {\n            throw new Error(\"invalid divisibility\");\n        }\n        return (0, fts_1.some)(Number(divisibility));\n    }\n    getPremine() {\n        if (!this.fields.has(Tag.Premine)) {\n            return (0, fts_1.none)();\n        }\n        const [premine] = this.fields.get(Tag.Premine);\n        return (0, fts_1.some)(Number(premine));\n    }\n    getRune() {\n        if (!this.fields.has(Tag.Rune)) {\n            return (0, fts_1.none)();\n        }\n        const [rune] = this.fields.get(Tag.Rune);\n        return (0, fts_1.some)(new Rune(rune));\n    }\n    getSpacers() {\n        if (!this.fields.has(Tag.Spacers)) {\n            return (0, fts_1.none)();\n        }\n        const [spacers] = this.fields.get(Tag.Spacers);\n        if (spacers > Etching.MAX_SPACERS) {\n            throw new Error(\"invalid spacers\");\n        }\n        return (0, fts_1.some)(Number(spacers));\n    }\n    getHeightStart() {\n        if (!this.fields.has(Tag.HeightStart)) {\n            return (0, fts_1.none)();\n        }\n        const [heightStart] = this.fields.get(Tag.HeightStart);\n        return (0, fts_1.some)(Number(heightStart));\n    }\n    getHeightEnd() {\n        if (!this.fields.has(Tag.HeightEnd)) {\n            return (0, fts_1.none)();\n        }\n        const [heightEnd] = this.fields.get(Tag.HeightEnd);\n        return (0, fts_1.some)(Number(heightEnd));\n    }\n    getOffsetStart() {\n        if (!this.fields.has(Tag.OffsetStart)) {\n            return (0, fts_1.none)();\n        }\n        const [offsetStart] = this.fields.get(Tag.OffsetStart);\n        return (0, fts_1.some)(Number(offsetStart));\n    }\n    getOffsetEnd() {\n        if (!this.fields.has(Tag.OffsetEnd)) {\n            return (0, fts_1.none)();\n        }\n        const [offsetEnd] = this.fields.get(Tag.OffsetEnd);\n        return (0, fts_1.some)(Number(offsetEnd));\n    }\n    getCap() {\n        if (!this.fields.has(Tag.Cap)) {\n            return (0, fts_1.none)();\n        }\n        const [cap] = this.fields.get(Tag.Cap);\n        return (0, fts_1.some)(Number(cap));\n    }\n    getAmount() {\n        if (!this.fields.has(Tag.Amount)) {\n            return (0, fts_1.none)();\n        }\n        const [amount] = this.fields.get(Tag.Amount);\n        return (0, fts_1.some)(Number(amount));\n    }\n    getSymbol() {\n        if (!this.fields.has(Tag.Symbol)) {\n            return (0, fts_1.none)();\n        }\n        const [symbol] = this.fields.get(Tag.Symbol);\n        return (0, fts_1.some)(String.fromCharCode(Number(symbol)));\n    }\n    getTerms() {\n        if (!this.hasFlags(Flag.Terms)) {\n            return (0, fts_1.none)();\n        }\n        const cap = this.getCap();\n        if (!cap.isSome()) {\n            throw new Error(\"no cap field\");\n        }\n        const amount = this.getAmount();\n        if (!amount.isSome()) {\n            throw new Error(\"no amount field\");\n        }\n        const heightStart = this.getHeightStart();\n        const heightEnd = this.getHeightEnd();\n        const offsetStart = this.getOffsetStart();\n        const offsetEnd = this.getOffsetEnd();\n        const height = new Range(heightStart, heightEnd);\n        const offset = new Range(offsetStart, offsetEnd);\n        return (0, fts_1.some)(new Terms(amount.value(), cap.value(), height, offset));\n    }\n    getPointer() {\n        if (!this.fields.has(Tag.Pointer)) {\n            return (0, fts_1.none)();\n        }\n        const [pointer] = this.fields.get(Tag.Pointer);\n        return (0, fts_1.some)(Number(pointer));\n    }\n}\nexports.Message = Message;\nclass EtchInscription {\n    constructor(fields = new Map(), data = Buffer.alloc(0)) {\n        this.fields = fields;\n        this.data = data;\n    }\n    setContent(contentType, data) {\n        this.fields.set(1, Buffer.from(contentType, 'utf8'));\n        this.data = data;\n    }\n    setRune(rune) {\n        const n = (0, base26_1.base26Encode)((0, spacers_1.removeSpacers)(rune));\n        let nstr = n.toString(16);\n        if (nstr.length % 2 === 1) {\n            nstr = '0' + nstr;\n        }\n        this.setField(EtchInscription.Tag.RUNE, Buffer.from(nstr, 'hex').reverse());\n    }\n    setField(field, val) {\n        this.fields.set(field, val);\n    }\n    static decipher(rawTx, inputIdx) {\n        const tx = bitcoinjs_lib_1.Transaction.fromHex(rawTx);\n        const witness = tx.ins[inputIdx].witness;\n        const tapscript = witness[1];\n        const ls = bitcoinjs_lib_1.script.decompile(tapscript);\n        const fields = new Map();\n        const dataChunks = [];\n        let isData = false;\n        for (let i = 5; i < ls.length - 1;) {\n            const chunk = ls[i];\n            if (chunk === 0) {\n                isData = true;\n                i++;\n                continue;\n            }\n            else if (isData) {\n                // Data\n                dataChunks.push(chunk);\n                i++;\n            }\n            else {\n                // Fields\n                const tag = chunk - 80;\n                const val = ls[i + 1];\n                if (typeof val == 'number') {\n                    const buff = Buffer.alloc(1);\n                    buff.writeUint8(val);\n                    fields.set(tag, buff);\n                }\n                else {\n                    fields.set(tag, val);\n                }\n                i += 2;\n            }\n        }\n        return new EtchInscription(fields, Buffer.concat(dataChunks));\n    }\n    encipher() {\n        const res = [];\n        if (this.data && this.data.length > 0) {\n            res.push(Buffer.from('0063036f7264', 'hex') // 0 OP_IF \"ord\"\n            );\n            Array.from(this.fields.entries())\n                .sort((a, b) => a[0] - b[0]) // Sorting by tag in ascending order\n                .forEach(([tag, val]) => {\n                const tagBuff = Buffer.alloc(1);\n                tagBuff.writeUInt8(tag);\n                res.push(Buffer.from('01', 'hex'));\n                res.push(tagBuff);\n                if (val.length != 1 || val[0] != 0x00) {\n                    res.push((0, utils_1.toPushData)(val));\n                }\n                else {\n                    res.push(val);\n                }\n            });\n            res.push(Buffer.from('00', 'hex'));\n            const dataChunks = (0, utils_1.chunks)(Array.from(this.data), 520);\n            for (const chunk of dataChunks) {\n                res.push((0, utils_1.toPushData)(Buffer.from(chunk)));\n            }\n        }\n        else {\n            res.push(Buffer.from('0063', 'hex') // 0 OP_IF\n            );\n            const rune = this.fields.get(EtchInscription.Tag.RUNE);\n            if (!rune) {\n                throw new Error(`No rune found!`);\n            }\n            res.push((0, utils_1.toPushData)(rune));\n        }\n        res.push(Buffer.from('68', 'hex')); // OP_ENDIF\n        return Buffer.concat(res);\n    }\n}\nexports.EtchInscription = EtchInscription;\nEtchInscription.Tag = {\n    CONTENT_TYPE: 1,\n    POINTER: 2,\n    PARENT: 3,\n    METADATA: 5,\n    METAPROTOCOL: 7,\n    CONTENT_ENCODING: 9,\n    DELEGATE: 11,\n    RUNE: 13\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L3J1bmVzdG9uZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsV0FBVyxHQUFHLFlBQVksR0FBRyxhQUFhLEdBQUcsY0FBYztBQUMzTSx3QkFBd0IsbUJBQU8sQ0FBQyxzRUFBZTtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyw2REFBVTtBQUNuQyxjQUFjLG1CQUFPLENBQUMsdURBQU87QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsK0RBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxXQUFXLFlBQVksWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVUsV0FBVyxXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsV0FBVyxZQUFZLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9ydW5lbGliL2Rpc3QvcnVuZXN0b25lcy5qcz84NDQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdGNoSW5zY3JpcHRpb24gPSBleHBvcnRzLk1lc3NhZ2UgPSBleHBvcnRzLlJ1bmVzdG9uZSA9IGV4cG9ydHMuRXRjaGluZyA9IGV4cG9ydHMuUnVuZSA9IGV4cG9ydHMuVGVybXMgPSBleHBvcnRzLlJhbmdlID0gZXhwb3J0cy5GbGF3ID0gZXhwb3J0cy5UYWcgPSBleHBvcnRzLkZsYWcgPSBleHBvcnRzLkVkaWN0ID0gZXhwb3J0cy5SdW5lSWQgPSB2b2lkIDA7XG5jb25zdCBiaXRjb2luanNfbGliXzEgPSByZXF1aXJlKFwiYml0Y29pbmpzLWxpYlwiKTtcbmNvbnN0IGJhc2UyNl8xID0gcmVxdWlyZShcIi4vYmFzZTI2XCIpO1xuY29uc3QgZnRzXzEgPSByZXF1aXJlKFwiLi9mdHNcIik7XG5jb25zdCBsZWIxMjhfMSA9IHJlcXVpcmUoXCIuL2xlYjEyOFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHNwYWNlcnNfMSA9IHJlcXVpcmUoXCIuL3NwYWNlcnNcIik7XG4vKipcbiAqIFJ1bmUgSURzIGFyZSByZXByZXNlbnRlZCBpbiB0ZXh0IGFzIEJMT0NLOlRYLlxuICovXG5jbGFzcyBSdW5lSWQge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrLCBpZHgpIHtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICB9XG4gICAgbmV4dChibG9jaywgaWR4KSB7XG4gICAgICAgIGlmIChibG9jayA+IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWR4ID4gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiID0gQmlnSW50KHRoaXMuYmxvY2spICsgYmxvY2s7XG4gICAgICAgIGlmIChiID4gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gYmxvY2sgPT09IDBuID8gQmlnSW50KHRoaXMuaWR4KSArIGlkeCA6IGlkeDtcbiAgICAgICAgaWYgKGkgPiBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShuZXcgUnVuZUlkKE51bWJlcihiKSwgTnVtYmVyKGkpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5lSWQgPSBSdW5lSWQ7XG4vKipcbiAqIFJ1bmUgSUQgYmxvY2sgaGVpZ2h0cyBhbmQgdHJhbnNhY3Rpb24gaW5kaWNlcyBpbiBlZGljdHMgYXJlIGRlbHRhIGVuY29kZWQuXG4gKiBFZGljdCBydW5lIElEIGRlY29kaW5nIHN0YXJ0cyB3aXRoIGEgYmFzZSBibG9jayBoZWlnaHQgYW5kIHRyYW5zYWN0aW9uIGluZGV4IG9mIHplcm8uXG4gKiBXaGVuIGRlY29kaW5nIGVhY2ggcnVuZSBJRCwgZmlyc3QgdGhlIGVuY29kZWQgYmxvY2sgaGVpZ2h0IGRlbHRhIGlzIGFkZGVkIHRvIHRoZSBiYXNlIGJsb2NrIGhlaWdodC5cbiAqIElmIHRoZSBibG9jayBoZWlnaHQgZGVsdGEgaXMgemVybywgdGhlIG5leHQgaW50ZWdlciBpcyBhIHRyYW5zYWN0aW9uIGluZGV4IGRlbHRhLlxuICogSWYgdGhlIGJsb2NrIGhlaWdodCBkZWx0YSBpcyBncmVhdGVyIHRoYW4gemVybywgdGhlIG5leHQgaW50ZWdlciBpcyBpbnN0ZWFkIGFuIGFic29sdXRlIHRyYW5zYWN0aW9uIGluZGV4LlxuICovXG5jbGFzcyBFZGljdCB7XG4gICAgY29uc3RydWN0b3IoaWQsIGFtb3VudCwgb3V0cHV0KSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbV9pbnRlZ2Vycyh0eCwgaWQsIGFtb3VudCwgb3V0cHV0KSB7XG4gICAgICAgIGlmIChvdXRwdXQgPiA0Mjk0OTY3Mjk1biB8fCBvdXRwdXQgPCAwbikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIob3V0cHV0KSA+IHR4Lm91dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShuZXcgRWRpY3QoaWQsIGFtb3VudCwgTnVtYmVyKG91dHB1dCkpKTtcbiAgICB9XG59XG5leHBvcnRzLkVkaWN0ID0gRWRpY3Q7XG52YXIgRmxhZztcbihmdW5jdGlvbiAoRmxhZykge1xuICAgIC8qKiBUaGUgRXRjaGluZyBmbGFnIG1hcmtzIHRoaXMgdHJhbnNhY3Rpb24gYXMgY29udGFpbmluZyBhbiBldGNoaW5nLiAqL1xuICAgIEZsYWdbRmxhZ1tcIkV0Y2hpbmdcIl0gPSAwXSA9IFwiRXRjaGluZ1wiO1xuICAgIC8qKiBUaGUgVGVybXMgZmxhZyBtYXJrcyB0aGlzIHRyYW5zYWN0aW9uJ3MgZXRjaGluZyBhcyBoYXZpbmcgb3BlbiBtaW50IHRlcm1zLiAqL1xuICAgIEZsYWdbRmxhZ1tcIlRlcm1zXCJdID0gMV0gPSBcIlRlcm1zXCI7XG4gICAgLyoqIFRoZSBUdXJibyBmbGFnIG1hcmtzIHRoaXMgdHJhbnNhY3Rpb24ncyBldGNoaW5nIGFzIG9wdGluZyBpbnRvIGZ1dHVyZSBwcm90b2NvbCBjaGFuZ2VzLiBUaGVzZSBwcm90b2NvbCBjaGFuZ2VzIG1heSBpbmNyZWFzZSBsaWdodCBjbGllbnQgdmFsaWRhdGlvbiBjb3N0cywgb3IganVzdCBiZSBoaWdobHkgZGVnZW5lcmF0ZS4gKi9cbiAgICBGbGFnW0ZsYWdbXCJUdXJib1wiXSA9IDJdID0gXCJUdXJib1wiO1xuICAgIC8qKiBUaGUgQ2Vub3RhcGggZmxhZyBpcyB1bnJlY29nbml6ZWQuICovXG4gICAgRmxhZ1tGbGFnW1wiQ2Vub3RhcGhcIl0gPSAxMjddID0gXCJDZW5vdGFwaFwiO1xufSkoRmxhZyB8fCAoZXhwb3J0cy5GbGFnID0gRmxhZyA9IHt9KSk7XG52YXIgVGFnO1xuKGZ1bmN0aW9uIChUYWcpIHtcbiAgICAvKiogVGhlIEJvZHkgdGFnIG1hcmtzIHRoZSBlbmQgb2YgdGhlIHJ1bmVzdG9uZSdzIGZpZWxkcywgY2F1c2luZyBhbGwgZm9sbG93aW5nIGludGVnZXJzIHRvIGJlIGludGVycHJldGVkIGFzIGVkaWN0cy4gKi9cbiAgICBUYWdbVGFnW1wiQm9keVwiXSA9IDBdID0gXCJCb2R5XCI7XG4gICAgLyoqIFRoZSBGbGFnIGZpZWxkIGNvbnRhaW5zIGEgYml0bWFwIG9mIGZsYWdzLCB3aG9zZSBwb3NpdGlvbiBpcyAxIDw8IEZMQUdfVkFMVUU6ICovXG4gICAgVGFnW1RhZ1tcIkZsYWdzXCJdID0gMl0gPSBcIkZsYWdzXCI7XG4gICAgLyoqIFRoZSBSdW5lIGZpZWxkIGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSBydW5lIGJlaW5nIGV0Y2hlZC4gSWYgdGhlIEV0Y2hpbmcgZmxhZyBpcyBzZXQgYnV0IHRoZSBSdW5lIGZpZWxkIGlzIG9taXR0ZWQsIGEgcmVzZXJ2ZWQgcnVuZSBuYW1lIGlzIGFsbG9jYXRlZC4gKi9cbiAgICBUYWdbVGFnW1wiUnVuZVwiXSA9IDRdID0gXCJSdW5lXCI7XG4gICAgLyoqIFRoZSBQcmVtaW5lIGZpZWxkIGNvbnRhaW5zIHRoZSBhbW91bnQgb2YgcHJlbWluZWQgcnVuZXMuICovXG4gICAgVGFnW1RhZ1tcIlByZW1pbmVcIl0gPSA2XSA9IFwiUHJlbWluZVwiO1xuICAgIC8qKiBUaGUgQ2FwIGZpZWxkIGNvbnRhaW5zIHRoZSBhbGxvd2VkIG51bWJlciBvZiBtaW50cy4gKi9cbiAgICBUYWdbVGFnW1wiQ2FwXCJdID0gOF0gPSBcIkNhcFwiO1xuICAgIC8qKiBUaGUgQW1vdW50IGZpZWxkIGNvbnRhaW5zIHRoZSBhbW91bnQgb2YgcnVuZXMgZWFjaCBtaW50IHRyYW5zYWN0aW9uIHJlY2VpdmVzLiAqL1xuICAgIFRhZ1tUYWdbXCJBbW91bnRcIl0gPSAxMF0gPSBcIkFtb3VudFwiO1xuICAgIC8qKiBUaGUgSGVpZ2h0U3RhcnQgYW5kIEhlaWdodEVuZCBmaWVsZHMgY29udGFpbiB0aGUgbWludCdzIHN0YXJ0aW5nIGFuZCBlbmRpbmcgYWJzb2x1dGUgYmxvY2sgaGVpZ2h0cywgcmVzcGVjdGl2ZWx5LiBUaGUgbWludCBpcyBvcGVuIHN0YXJ0aW5nIGluIHRoZSBibG9jayB3aXRoIGhlaWdodCBIZWlnaHRTdGFydCwgYW5kIGNsb3NlcyBpbiB0aGUgYmxvY2sgd2l0aCBoZWlnaHQgSGVpZ2h0RW5kLiAqL1xuICAgIFRhZ1tUYWdbXCJIZWlnaHRTdGFydFwiXSA9IDEyXSA9IFwiSGVpZ2h0U3RhcnRcIjtcbiAgICBUYWdbVGFnW1wiSGVpZ2h0RW5kXCJdID0gMTRdID0gXCJIZWlnaHRFbmRcIjtcbiAgICAvKiogVGhlIE9mZnNldFN0YXJ0IGFuZCBPZmZzZXRFbmQgZmllbGRzIGNvbnRhaW4gdGhlIG1pbnQncyBzdGFydGluZyBhbmQgZW5kaW5nIGJsb2NrIGhlaWdodHMsIHJlbGF0aXZlIHRvIHRoZSBibG9jayBpbiB3aGljaCB0aGUgZXRjaGluZyBpcyBtaW5lZC4gVGhlIG1pbnQgaXMgb3BlbiBzdGFydGluZyBpbiB0aGUgYmxvY2sgd2l0aCBoZWlnaHQgT2Zmc2V0U3RhcnQgKyBFVENISU5HX0hFSUdIVCwgYW5kIGNsb3NlcyBpbiB0aGUgYmxvY2sgd2l0aCBoZWlnaHQgT2Zmc2V0RW5kICsgRVRDSElOR19IRUlHSFQuICovXG4gICAgVGFnW1RhZ1tcIk9mZnNldFN0YXJ0XCJdID0gMTZdID0gXCJPZmZzZXRTdGFydFwiO1xuICAgIFRhZ1tUYWdbXCJPZmZzZXRFbmRcIl0gPSAxOF0gPSBcIk9mZnNldEVuZFwiO1xuICAgIC8qKiBUaGUgTWludCBmaWVsZCBjb250YWlucyB0aGUgUnVuZSBJRCBvZiB0aGUgcnVuZSB0byBiZSBtaW50ZWQgaW4gdGhpcyB0cmFuc2FjdGlvbi4gKi9cbiAgICBUYWdbVGFnW1wiTWludFwiXSA9IDIwXSA9IFwiTWludFwiO1xuICAgIC8qKiBUaGUgUG9pbnRlciBmaWVsZCBjb250YWlucyB0aGUgaW5kZXggb2YgdGhlIG91dHB1dCB0byB3aGljaCBydW5lcyB1bmFsbG9jYXRlZCBieSBlZGljdHMgc2hvdWxkIGJlIHRyYW5zZmVycmVkLiBJZiB0aGUgUG9pbnRlciBmaWVsZCBpcyBhYnNlbnQsIHVuYWxsb2NhdGVkIHJ1bmVzIGFyZSB0cmFuc2ZlcnJlZCB0byB0aGUgZmlyc3Qgbm9uLU9QX1JFVFVSTiBvdXRwdXQuICovXG4gICAgVGFnW1RhZ1tcIlBvaW50ZXJcIl0gPSAyMl0gPSBcIlBvaW50ZXJcIjtcbiAgICAvKiogVGhlIENlbm90YXBoIGZpZWxkIGlzIHVucmVjb2duaXplZC4gKi9cbiAgICBUYWdbVGFnW1wiQ2Vub3RhcGhcIl0gPSAxMjZdID0gXCJDZW5vdGFwaFwiO1xuICAgIC8qKiBUaGUgRGl2aXNpYmlsaXR5IGZpZWxkLCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mIHRlbiwgaXMgdGhlIG51bWJlciBvZiBzdWJ1bml0cyBpbiBhIHN1cGVyIHVuaXQgb2YgcnVuZXMuICovXG4gICAgVGFnW1RhZ1tcIkRpdmlzaWJpbGl0eVwiXSA9IDFdID0gXCJEaXZpc2liaWxpdHlcIjtcbiAgICAvKiogVGhlIFNwYWNlcnMgZmllbGQgaXMgYSBiaXRmaWVsZCBvZiDigKIgc3BhY2VycyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgYmV0d2VlbiB0aGUgbGV0dGVycyBvZiB0aGUgcnVuZSdzIG5hbWUuIFRyYWlsaW5nIHNwYWNlcnMgYXJlIGlnbm9yZWQuICovXG4gICAgVGFnW1RhZ1tcIlNwYWNlcnNcIl0gPSAzXSA9IFwiU3BhY2Vyc1wiO1xuICAgIC8qKiBUaGUgU3ltYm9sIGZpZWxkIGlzIHRoZSBVbmljb2RlIGNvZGVwb2ludCBvZiB0aGUgUnVuZSdzIGN1cnJlbmN5IHN5bWJvbCxcbiAgICAgKiB3aGljaCBzaG91bGQgYmUgZGlzcGxheWVkIGFmdGVyIGFtb3VudHMgb2YgdGhhdCBydW5lLiBJZiBhIHJ1bmUgZG9lcyBub3QgaGF2ZSBhIGN1cnJlbmN5IHN5bWJvbCxcbiAgICAgKiB0aGUgZ2VuZXJpYyBjdXJyZW5jeSBjaGFyYWN0ZXIgwqQgc2hvdWxkIGJlIHVzZWQuXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBTeW1ib2wgaXMgIyBhbmQgdGhlIGRpdmlzaWJpbGl0eSBpcyAyLFxuICAgICAqIHRoZSBhbW91bnQgb2YgMTIzNCB1bml0cyBzaG91bGQgYmUgZGlzcGxheWVkIGFzIDEyLjM0ICMuXG4gICAgICovXG4gICAgVGFnW1RhZ1tcIlN5bWJvbFwiXSA9IDVdID0gXCJTeW1ib2xcIjtcbiAgICAvKiogVGhlIE5vcCBmaWVsZCBpcyB1bnJlY29nbml6ZWQuICovXG4gICAgVGFnW1RhZ1tcIk5vcFwiXSA9IDEyN10gPSBcIk5vcFwiO1xufSkoVGFnIHx8IChleHBvcnRzLlRhZyA9IFRhZyA9IHt9KSk7XG52YXIgRmxhdztcbihmdW5jdGlvbiAoRmxhdykge1xuICAgIEZsYXdbRmxhd1tcIkVkaWN0T3V0cHV0XCJdID0gMF0gPSBcIkVkaWN0T3V0cHV0XCI7XG4gICAgRmxhd1tGbGF3W1wiRWRpY3RSdW5lSWRcIl0gPSAxXSA9IFwiRWRpY3RSdW5lSWRcIjtcbiAgICBGbGF3W0ZsYXdbXCJJbnZhbGlkU2NyaXB0XCJdID0gMl0gPSBcIkludmFsaWRTY3JpcHRcIjtcbiAgICBGbGF3W0ZsYXdbXCJPcGNvZGVcIl0gPSAzXSA9IFwiT3Bjb2RlXCI7XG4gICAgRmxhd1tGbGF3W1wiU3VwcGx5T3ZlcmZsb3dcIl0gPSA0XSA9IFwiU3VwcGx5T3ZlcmZsb3dcIjtcbiAgICBGbGF3W0ZsYXdbXCJUcmFpbGluZ0ludGVnZXJzXCJdID0gNV0gPSBcIlRyYWlsaW5nSW50ZWdlcnNcIjtcbiAgICBGbGF3W0ZsYXdbXCJUcnVuY2F0ZWRGaWVsZFwiXSA9IDZdID0gXCJUcnVuY2F0ZWRGaWVsZFwiO1xuICAgIEZsYXdbRmxhd1tcIlVucmVjb2duaXplZEV2ZW5UYWdcIl0gPSA3XSA9IFwiVW5yZWNvZ25pemVkRXZlblRhZ1wiO1xuICAgIEZsYXdbRmxhd1tcIlVucmVjb2duaXplZEZsYWdcIl0gPSA4XSA9IFwiVW5yZWNvZ25pemVkRmxhZ1wiO1xuICAgIEZsYXdbRmxhd1tcIlZhcmludFwiXSA9IDldID0gXCJWYXJpbnRcIjtcbn0pKEZsYXcgfHwgKGV4cG9ydHMuRmxhdyA9IEZsYXcgPSB7fSkpO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG59XG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5jbGFzcyBUZXJtcyB7XG4gICAgY29uc3RydWN0b3IoYW1vdW50LCBjYXAsIGhlaWdodCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xuICAgICAgICB0aGlzLmNhcCA9IGNhcDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbn1cbmV4cG9ydHMuVGVybXMgPSBUZXJtcztcbmNsYXNzIFJ1bmUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBSdW5lLnRvTmFtZSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIHRvTmFtZShzKSB7XG4gICAgICAgIHJldHVybiAoMCwgYmFzZTI2XzEuYmFzZTI2RGVjb2RlKShzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21OYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5lKCgwLCBiYXNlMjZfMS5iYXNlMjZFbmNvZGUpKCgwLCBzcGFjZXJzXzEucmVtb3ZlU3BhY2VycykobmFtZSkpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5lID0gUnVuZTtcbmNsYXNzIEV0Y2hpbmcge1xuICAgIGNvbnN0cnVjdG9yKGRpdmlzaWJpbGl0eSwgcHJlbWluZSwgcnVuZSwgc3BhY2Vycywgc3ltYm9sLCB0ZXJtcywgdHVyYm8pIHtcbiAgICAgICAgdGhpcy5kaXZpc2liaWxpdHkgPSBkaXZpc2liaWxpdHk7XG4gICAgICAgIHRoaXMucHJlbWluZSA9IHByZW1pbmU7XG4gICAgICAgIHRoaXMucnVuZSA9IHJ1bmU7XG4gICAgICAgIHRoaXMuc3BhY2VycyA9IHNwYWNlcnM7XG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB0aGlzLnRlcm1zID0gdGVybXM7XG4gICAgICAgIHRoaXMudHVyYm8gPSB0dXJibztcbiAgICB9XG59XG5leHBvcnRzLkV0Y2hpbmcgPSBFdGNoaW5nO1xuRXRjaGluZy5NQVhfRElWSVNJQklMSVRZID0gMzg7XG5FdGNoaW5nLk1BWF9TUEFDRVJTID0gMTM0MjE3NzI3O1xuY2xhc3MgUnVuZXN0b25lIHtcbiAgICBjb25zdHJ1Y3RvcihlZGljdHMgPSBbXSwgZXRjaGluZywgbWludCwgcG9pbnRlcikge1xuICAgICAgICB0aGlzLmVkaWN0cyA9IGVkaWN0cztcbiAgICAgICAgdGhpcy5ldGNoaW5nID0gZXRjaGluZztcbiAgICAgICAgdGhpcy5taW50ID0gbWludDtcbiAgICAgICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShqc29uLCB0eXBlID0gJ2V0Y2gnKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnZXRjaCcpIHtcbiAgICAgICAgICAgIGpzb24gPSBqc29uO1xuICAgICAgICAgICAgY29uc3QgcnVuZW5hbWUgPSBSdW5lLmZyb21OYW1lKGpzb24ubmFtZSk7XG4gICAgICAgICAgICBjb25zdCB0ZXJtcyA9IG5ldyBUZXJtcyhqc29uLmFtb3VudCwganNvbi5jYXAsIG5ldyBSYW5nZShqc29uLnN0YXJ0SGVpZ2h0ID8gKDAsIGZ0c18xLnNvbWUpKGpzb24uc3RhcnRIZWlnaHQpIDogKDAsIGZ0c18xLm5vbmUpKCksIGpzb24uZW5kSGVpZ2h0ID8gKDAsIGZ0c18xLnNvbWUpKGpzb24uZW5kSGVpZ2h0KSA6ICgwLCBmdHNfMS5ub25lKSgpKSwgbmV3IFJhbmdlKGpzb24uc3RhcnRPZmZzZXQgPyAoMCwgZnRzXzEuc29tZSkoanNvbi5zdGFydE9mZnNldCkgOiAoMCwgZnRzXzEubm9uZSkoKSwganNvbi5lbmRPZmZzZXQgPyAoMCwgZnRzXzEuc29tZSkoanNvbi5lbmRPZmZzZXQpIDogKDAsIGZ0c18xLm5vbmUpKCkpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpdmlzaWJpbGl0eSA9IGpzb24uZGl2aXNpYmlsaXR5ID8gKDAsIGZ0c18xLnNvbWUpKGpzb24uZGl2aXNpYmlsaXR5KSA6ICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICAgICAgY29uc3QgcHJlbWluZSA9IGpzb24ucHJlbWluZSA/ICgwLCBmdHNfMS5zb21lKShqc29uLnByZW1pbmUpIDogKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgICAgICBjb25zdCBzcGFjZXJzID0ganNvbi5uYW1lLmluZGV4T2YoJ+KAoicpID4gLTEgPyAoMCwgZnRzXzEuc29tZSkoKDAsIHNwYWNlcnNfMS5nZXRTcGFjZXJzVmFsKShqc29uLm5hbWUpKSA6ICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0ganNvbi5zeW1ib2wgPyAoMCwgZnRzXzEuc29tZSkoanNvbi5zeW1ib2wpIDogKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyID0gdHlwZW9mIGpzb24ucG9pbnRlciA9PT0gJ251bWJlcicgPyAoMCwgZnRzXzEuc29tZSkoanNvbi5wb2ludGVyKSA6ICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICAgICAgY29uc3QgZXRjaGluZyA9IG5ldyBFdGNoaW5nKGRpdmlzaWJpbGl0eSwgcHJlbWluZSwgKDAsIGZ0c18xLnNvbWUpKHJ1bmVuYW1lKSwgc3BhY2Vycywgc3ltYm9sLCAoMCwgZnRzXzEuc29tZSkodGVybXMpLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVuZXN0b25lKFtdLCAoMCwgZnRzXzEuc29tZSkoZXRjaGluZyksICgwLCBmdHNfMS5ub25lKSgpLCBwb2ludGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbWludCcpIHtcbiAgICAgICAgICAgIGpzb24gPSBqc29uO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IHR5cGVvZiBqc29uLnBvaW50ZXIgPT09ICdudW1iZXInID8gKDAsIGZ0c18xLnNvbWUpKGpzb24ucG9pbnRlcikgOiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVuZXN0b25lKFtdLCAoMCwgZnRzXzEubm9uZSkoKSwgKDAsIGZ0c18xLnNvbWUpKG5ldyBSdW5lSWQoanNvbi5ibG9jaywganNvbi50eElkeCkpLCBwb2ludGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90ICR7dHlwZX0gc3VwcG9ydCBub3dgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZGVjaXBoZXIocmF3VHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uZnJvbUhleChyYXdUeCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBSdW5lc3RvbmUucGF5bG9hZCh0eCk7XG4gICAgICAgIGlmIChwYXlsb2FkLmlzU29tZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlZ2VycyA9IFJ1bmVzdG9uZS5pbnRlZ2VycyhwYXlsb2FkLnZhbHVlKCkpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IE1lc3NhZ2UuZnJvbV9pbnRlZ2Vycyh0eCwgaW50ZWdlcnMudmFsdWUoKSk7XG4gICAgICAgICAgICBjb25zdCBldGNoaW5nID0gbWVzc2FnZS5nZXRFdGNoaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBtaW50ID0gbWVzc2FnZS5nZXRNaW50KCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyID0gbWVzc2FnZS5nZXRQb2ludGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLnNvbWUpKG5ldyBSdW5lc3RvbmUobWVzc2FnZS5lZGljdHMsIGV0Y2hpbmcsIG1pbnQsIHBvaW50ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgfVxuICAgIGVuY2lwaGVyKCkge1xuICAgICAgICBjb25zdCBtc2cgPSB0aGlzLnRvTWVzc2FnZSgpO1xuICAgICAgICBjb25zdCBtc2dCdWZmID0gbXNnLnRvQnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IEJ1ZmZlci5mcm9tKCc2YTVkJywgJ2hleCcpOyAvLyBPUF9SRVRVUk4gT1BfMTNcbiAgICAgICAgbGV0IHB1c2hOdW07XG4gICAgICAgIGlmIChtc2dCdWZmLmxlbmd0aCA8IDB4NGMpIHtcbiAgICAgICAgICAgIHB1c2hOdW0gPSBCdWZmZXIuYWxsb2MoMSk7XG4gICAgICAgICAgICBwdXNoTnVtLndyaXRlVWludDgobXNnQnVmZi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZ0J1ZmYubGVuZ3RoIDwgMHgxMDApIHtcbiAgICAgICAgICAgIHB1c2hOdW0gPSBCdWZmZXIuYWxsb2MoMik7XG4gICAgICAgICAgICBwdXNoTnVtLndyaXRlVWludDgoMHg0Yyk7XG4gICAgICAgICAgICBwdXNoTnVtLndyaXRlVWludDgobXNnQnVmZi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZ0J1ZmYubGVuZ3RoIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgcHVzaE51bSA9IEJ1ZmZlci5hbGxvYygzKTtcbiAgICAgICAgICAgIHB1c2hOdW0ud3JpdGVVaW50OCgweDRkKTtcbiAgICAgICAgICAgIHB1c2hOdW0ud3JpdGVVaW50MTZMRShtc2dCdWZmLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXNnQnVmZi5sZW5ndGggPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgcHVzaE51bSA9IEJ1ZmZlci5hbGxvYyg1KTtcbiAgICAgICAgICAgIHB1c2hOdW0ud3JpdGVVaW50OCgweDRlKTtcbiAgICAgICAgICAgIHB1c2hOdW0ud3JpdGVVaW50MzJMRShtc2dCdWZmLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJydW5lc3RvbmUgdG9vIGJpZyFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgcHVzaE51bSwgbXNnQnVmZl0pO1xuICAgIH1cbiAgICBzdGF0aWMgcGF5bG9hZCh0eCkge1xuICAgICAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiB0eC5vdXRzKSB7XG4gICAgICAgICAgICAvL3NjcmlwdC5mcm9tQVNNXG4gICAgICAgICAgICBjb25zdCBscyA9IGJpdGNvaW5qc19saWJfMS5zY3JpcHQuZGVjb21waWxlKG91dHB1dC5zY3JpcHQpO1xuICAgICAgICAgICAgaWYgKGxzWzBdICE9PSBiaXRjb2luanNfbGliXzEuc2NyaXB0Lk9QUy5PUF9SRVRVUk4pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsc1sxXSAhPT0gUnVuZXN0b25lLk1BR0lDX05VTUJFUikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBsc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShBcnJheS5mcm9tKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICB9XG4gICAgc3RhdGljIGludGVnZXJzKHBheWxvYWQpIHtcbiAgICAgICAgbGV0IGludGVnZXJzID0gW107XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBwYXlsb2FkLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgbiwgbGVuIH0gPSAoMCwgbGViMTI4XzEuZGVjb2RlTEVCMTI4KShwYXlsb2FkLnNsaWNlKGkpKTtcbiAgICAgICAgICAgIGludGVnZXJzLnB1c2gobik7XG4gICAgICAgICAgICBpICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGZ0c18xLnNvbWUpKGludGVnZXJzKTtcbiAgICB9XG4gICAgdG9NZXNzYWdlKCkge1xuICAgICAgICBsZXQgZmllbGRzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBldGNoaW5nID0gdGhpcy5ldGNoaW5nLnZhbHVlKCk7XG4gICAgICAgIGlmIChldGNoaW5nKSB7XG4gICAgICAgICAgICBsZXQgZmxhZ3MgPSAxO1xuICAgICAgICAgICAgaWYgKGV0Y2hpbmcudGVybXMuaXNTb21lKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFzayA9IDEgPDwgRmxhZy5UZXJtcztcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV0Y2hpbmcudHVyYm8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFzayA9IDEgPDwgRmxhZy5UdXJibztcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGRzLnNldChUYWcuRmxhZ3MsIFtCaWdJbnQoZmxhZ3MpXSk7XG4gICAgICAgICAgICBjb25zdCBydW5lID0gZXRjaGluZy5ydW5lLnZhbHVlKCk7XG4gICAgICAgICAgICBpZiAocnVuZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLlJ1bmUsIFtCaWdJbnQocnVuZS52YWx1ZSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpdmlzaWJpbGl0eSA9IGV0Y2hpbmcuZGl2aXNpYmlsaXR5LnZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoZGl2aXNpYmlsaXR5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnNldChUYWcuRGl2aXNpYmlsaXR5LCBbQmlnSW50KGRpdmlzaWJpbGl0eSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNwYWNlcnMgPSBldGNoaW5nLnNwYWNlcnMudmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzcGFjZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnNldChUYWcuU3BhY2VycywgW0JpZ0ludChzcGFjZXJzKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gZXRjaGluZy5zeW1ib2wudmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KFRhZy5TeW1ib2wsIFtCaWdJbnQoc3ltYm9sLmNoYXJDb2RlQXQoMCkpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmVtaW5lID0gZXRjaGluZy5wcmVtaW5lLnZhbHVlKCk7XG4gICAgICAgICAgICBpZiAocHJlbWluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLlByZW1pbmUsIFtCaWdJbnQocHJlbWluZSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRlcm1zID0gZXRjaGluZy50ZXJtcy52YWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHRlcm1zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnNldChUYWcuQW1vdW50LCBbQmlnSW50KHRlcm1zLmFtb3VudCldKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KFRhZy5DYXAsIFtCaWdJbnQodGVybXMuY2FwKV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodFN0YXJ0ID0gdGVybXMuaGVpZ2h0LnN0YXJ0LnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLkhlaWdodFN0YXJ0LCBbQmlnSW50KGhlaWdodFN0YXJ0KV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHRFbmQgPSB0ZXJtcy5oZWlnaHQuZW5kLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodEVuZCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KFRhZy5IZWlnaHRFbmQsIFtCaWdJbnQoaGVpZ2h0RW5kKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRTdGFydCA9IHRlcm1zLm9mZnNldC5zdGFydC52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KFRhZy5PZmZzZXRTdGFydCwgW0JpZ0ludChvZmZzZXRTdGFydCldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0RW5kID0gdGVybXMub2Zmc2V0LmVuZC52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnNldChUYWcuT2Zmc2V0RW5kLCBbQmlnSW50KG9mZnNldEVuZCldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWludCA9IHRoaXMubWludC52YWx1ZSgpO1xuICAgICAgICBpZiAobWludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmllbGRzLnNldChUYWcuTWludCwgW0JpZ0ludChtaW50LmJsb2NrKSwgQmlnSW50KG1pbnQuaWR4KV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLnBvaW50ZXIudmFsdWUoKTtcbiAgICAgICAgaWYgKHBvaW50ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLlBvaW50ZXIsIFtCaWdJbnQocG9pbnRlcildKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2UoZmllbGRzLCB0aGlzLmVkaWN0cywgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5lc3RvbmUgPSBSdW5lc3RvbmU7XG5SdW5lc3RvbmUuTUFHSUNfTlVNQkVSID0gOTM7XG5jbGFzcyBNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMgPSBuZXcgTWFwKCksIGVkaWN0cyA9IFtdLCBmbGF3cyA9IDApIHtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMuZWRpY3RzID0gZWRpY3RzO1xuICAgICAgICB0aGlzLmZsYXdzID0gZmxhd3M7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tX2ludGVnZXJzKHR4LCBpbnRlZ2Vycykge1xuICAgICAgICBsZXQgZmllbGRzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgZWRpY3RzID0gW107XG4gICAgICAgIGxldCBmbGF3cyA9IDA7XG4gICAgICAgIGxldCBpc0JvZHkgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnRlZ2Vycy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgdGFnID0gaW50ZWdlcnNbaV07XG4gICAgICAgICAgICBpZiAoTnVtYmVyKHRhZykgPT09IFRhZy5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgaXNCb2R5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQm9keSkge1xuICAgICAgICAgICAgICAgIC8vIEZpZWxkczpcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gaW50ZWdlcnNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHMgPSBmaWVsZHMuZ2V0KE51bWJlcih0YWcpKSB8fCBbXTtcbiAgICAgICAgICAgICAgICB2YWxzLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KE51bWJlcih0YWcpLCB2YWxzKTtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGljdHM6XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gbmV3IFJ1bmVJZCgwLCAwKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mICgwLCB1dGlsc18xLmNodW5rcykoaW50ZWdlcnMuc2xpY2UoaSksIDQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggIT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhd3MgfD0gRmxhdy5UcmFpbGluZ0ludGVnZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpZC5uZXh0KGNodW5rWzBdLCBjaHVua1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5pc1NvbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhd3MgfD0gRmxhdy5FZGljdFJ1bmVJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaWN0ID0gRWRpY3QuZnJvbV9pbnRlZ2Vycyh0eCwgbmV4dC52YWx1ZSgpLCBjaHVua1syXSwgY2h1bmtbM10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVkaWN0LmlzU29tZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGF3cyB8PSBGbGF3LkVkaWN0T3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWQgPSBuZXh0LnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaWN0cy5wdXNoKGVkaWN0LnZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGZpZWxkcywgZWRpY3RzLCBmbGF3cyk7XG4gICAgfVxuICAgIGFkZEZpZWxkVmFsKHRhZywgdmFsKSB7XG4gICAgICAgIGNvbnN0IHZhbHMgPSB0aGlzLmZpZWxkcy5nZXQoTnVtYmVyKHRhZykpIHx8IFtdO1xuICAgICAgICB2YWxzLnB1c2godmFsKTtcbiAgICAgICAgdGhpcy5maWVsZHMuc2V0KE51bWJlcih0YWcpLCB2YWxzKTtcbiAgICB9XG4gICAgYWRkRWRpY3QoZWRpY3QpIHtcbiAgICAgICAgdGhpcy5lZGljdHMucHVzaChlZGljdCk7XG4gICAgfVxuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICBjb25zdCBidWZmQXJyID0gW107XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBmaWVsZHMuXG4gICAgICAgIGZvciAoY29uc3QgW3RhZywgdmFsc10gb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdCdWZmID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICAgICAgICAgIHRhZ0J1ZmYud3JpdGVVSW50OCh0YWcpO1xuICAgICAgICAgICAgICAgIGJ1ZmZBcnIucHVzaCh0YWdCdWZmKTtcbiAgICAgICAgICAgICAgICBidWZmQXJyLnB1c2goQnVmZmVyLmZyb20oKDAsIGxlYjEyOF8xLmVuY29kZUxFQjEyOCkodmFsKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBlZGljdHMuXG4gICAgICAgIGlmICh0aGlzLmVkaWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBidWZmQXJyLnB1c2goQnVmZmVyLmZyb20oJzAwJywgJ2hleCcpKTtcbiAgICAgICAgICAgIC8vIDEpIFNvcnQgYnkgYmxvY2sgaGVpZ2h0XG4gICAgICAgICAgICAvLyAyKSBTb3J0IGJ5IHR4IGlkeFxuICAgICAgICAgICAgdGhpcy5lZGljdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhLmlkLmJsb2NrID09IGIuaWQuYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuaWQuaWR4IC0gYi5pZC5pZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLmlkLmJsb2NrIC0gYi5pZC5ibG9jaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gMykgRGVsdGEgZW5jb2RlXG4gICAgICAgICAgICBsZXQgbGFzdEJsb2NrSGVpZ2h0ID0gMG47XG4gICAgICAgICAgICBsZXQgbGFzdFR4SWR4ID0gMG47XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWRpY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpY3QgPSB0aGlzLmVkaWN0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RCbG9ja0hlaWdodCA9IEJpZ0ludChlZGljdC5pZC5ibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUeElkeCA9IEJpZ0ludChlZGljdC5pZC5pZHgpO1xuICAgICAgICAgICAgICAgICAgICBidWZmQXJyLnB1c2goQnVmZmVyLmZyb20oKDAsIGxlYjEyOF8xLmVuY29kZUxFQjEyOCkobGFzdEJsb2NrSGVpZ2h0KSkpO1xuICAgICAgICAgICAgICAgICAgICBidWZmQXJyLnB1c2goQnVmZmVyLmZyb20oKDAsIGxlYjEyOF8xLmVuY29kZUxFQjEyOCkobGFzdFR4SWR4KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyckJsb2NrSGVpZ2h0ID0gQmlnSW50KGVkaWN0LmlkLmJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyclR4SWR4ID0gQmlnSW50KGVkaWN0LmlkLmlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyQmxvY2tIZWlnaHQgPT0gbGFzdEJsb2NrSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVR4SWR4ID0gY3VyclR4SWR4IC0gbGFzdFR4SWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFR4SWR4ID0gY3VyclR4SWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZkFyci5wdXNoKEJ1ZmZlci5mcm9tKCgwLCBsZWIxMjhfMS5lbmNvZGVMRUIxMjgpKDBuKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZkFyci5wdXNoKEJ1ZmZlci5mcm9tKCgwLCBsZWIxMjhfMS5lbmNvZGVMRUIxMjgpKGRlbHRhVHhJZHgpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YUJsb2NrSGVpZ2h0ID0gY3VyckJsb2NrSGVpZ2h0IC0gbGFzdEJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2NrSGVpZ2h0ID0gY3VyckJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFR4SWR4ID0gY3VyclR4SWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZkFyci5wdXNoKEJ1ZmZlci5mcm9tKCgwLCBsZWIxMjhfMS5lbmNvZGVMRUIxMjgpKGRlbHRhQmxvY2tIZWlnaHQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmQXJyLnB1c2goQnVmZmVyLmZyb20oKDAsIGxlYjEyOF8xLmVuY29kZUxFQjEyOCkoY3VyclR4SWR4KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZBcnIucHVzaChCdWZmZXIuZnJvbSgoMCwgbGViMTI4XzEuZW5jb2RlTEVCMTI4KShCaWdJbnQoZWRpY3QuYW1vdW50KSkpKTtcbiAgICAgICAgICAgICAgICBidWZmQXJyLnB1c2goQnVmZmVyLmZyb20oKDAsIGxlYjEyOF8xLmVuY29kZUxFQjEyOCkoQmlnSW50KGVkaWN0Lm91dHB1dCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmZkFycik7XG4gICAgfVxuICAgIGdldEZsYWdzKCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMuZmllbGRzLmdldChUYWcuRmxhZ3MpKTtcbiAgICB9XG4gICAgaGFzRmxhZ3MoZmxhZykge1xuICAgICAgICBjb25zdCBmbGFncyA9IHRoaXMuZ2V0RmxhZ3MoKTtcbiAgICAgICAgY29uc3QgbWFzayA9IDEgPDwgZmxhZztcbiAgICAgICAgcmV0dXJuIChmbGFncyAmIG1hc2spICE9IDA7XG4gICAgfVxuICAgIGdldE1pbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHMuaGFzKFRhZy5NaW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtibG9jaywgdHhdID0gdGhpcy5maWVsZHMuZ2V0KFRhZy5NaW50KTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShuZXcgUnVuZUlkKE51bWJlcihibG9jayksIE51bWJlcih0eCkpKTtcbiAgICB9XG4gICAgZ2V0RXRjaGluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZsYWdzKEZsYWcuRXRjaGluZykpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXZpc2liaWxpdHkgPSB0aGlzLmdldERpdmlzaWJpbGl0eSgpO1xuICAgICAgICBjb25zdCBwcmVtaW5lID0gdGhpcy5nZXRQcmVtaW5lKCk7XG4gICAgICAgIGNvbnN0IHJ1bmUgPSB0aGlzLmdldFJ1bmUoKTtcbiAgICAgICAgY29uc3Qgc3BhY2VycyA9IHRoaXMuZ2V0U3BhY2VycygpO1xuICAgICAgICBjb25zdCBzeW1ib2wgPSB0aGlzLmdldFN5bWJvbCgpO1xuICAgICAgICBjb25zdCB0ZXJtcyA9IHRoaXMuZ2V0VGVybXMoKTtcbiAgICAgICAgY29uc3QgdHVyYm8gPSB0aGlzLmhhc0ZsYWdzKEZsYWcuVHVyYm8pO1xuICAgICAgICByZXR1cm4gKDAsIGZ0c18xLnNvbWUpKG5ldyBFdGNoaW5nKGRpdmlzaWJpbGl0eSwgcHJlbWluZSwgcnVuZSwgc3BhY2Vycywgc3ltYm9sLCB0ZXJtcywgdHVyYm8pKTtcbiAgICB9XG4gICAgZ2V0RGl2aXNpYmlsaXR5KCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzLmhhcyhUYWcuRGl2aXNpYmlsaXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtkaXZpc2liaWxpdHldID0gdGhpcy5maWVsZHMuZ2V0KFRhZy5EaXZpc2liaWxpdHkpO1xuICAgICAgICBpZiAoZGl2aXNpYmlsaXR5ID4gRXRjaGluZy5NQVhfRElWSVNJQklMSVRZKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRpdmlzaWJpbGl0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGZ0c18xLnNvbWUpKE51bWJlcihkaXZpc2liaWxpdHkpKTtcbiAgICB9XG4gICAgZ2V0UHJlbWluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLlByZW1pbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3ByZW1pbmVdID0gdGhpcy5maWVsZHMuZ2V0KFRhZy5QcmVtaW5lKTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShOdW1iZXIocHJlbWluZSkpO1xuICAgIH1cbiAgICBnZXRSdW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzLmhhcyhUYWcuUnVuZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcnVuZV0gPSB0aGlzLmZpZWxkcy5nZXQoVGFnLlJ1bmUpO1xuICAgICAgICByZXR1cm4gKDAsIGZ0c18xLnNvbWUpKG5ldyBSdW5lKHJ1bmUpKTtcbiAgICB9XG4gICAgZ2V0U3BhY2VycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLlNwYWNlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3NwYWNlcnNdID0gdGhpcy5maWVsZHMuZ2V0KFRhZy5TcGFjZXJzKTtcbiAgICAgICAgaWYgKHNwYWNlcnMgPiBFdGNoaW5nLk1BWF9TUEFDRVJTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNwYWNlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShOdW1iZXIoc3BhY2VycykpO1xuICAgIH1cbiAgICBnZXRIZWlnaHRTdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLkhlaWdodFN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtoZWlnaHRTdGFydF0gPSB0aGlzLmZpZWxkcy5nZXQoVGFnLkhlaWdodFN0YXJ0KTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShOdW1iZXIoaGVpZ2h0U3RhcnQpKTtcbiAgICB9XG4gICAgZ2V0SGVpZ2h0RW5kKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzLmhhcyhUYWcuSGVpZ2h0RW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtoZWlnaHRFbmRdID0gdGhpcy5maWVsZHMuZ2V0KFRhZy5IZWlnaHRFbmQpO1xuICAgICAgICByZXR1cm4gKDAsIGZ0c18xLnNvbWUpKE51bWJlcihoZWlnaHRFbmQpKTtcbiAgICB9XG4gICAgZ2V0T2Zmc2V0U3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHMuaGFzKFRhZy5PZmZzZXRTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb2Zmc2V0U3RhcnRdID0gdGhpcy5maWVsZHMuZ2V0KFRhZy5PZmZzZXRTdGFydCk7XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkoTnVtYmVyKG9mZnNldFN0YXJ0KSk7XG4gICAgfVxuICAgIGdldE9mZnNldEVuZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLk9mZnNldEVuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb2Zmc2V0RW5kXSA9IHRoaXMuZmllbGRzLmdldChUYWcuT2Zmc2V0RW5kKTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShOdW1iZXIob2Zmc2V0RW5kKSk7XG4gICAgfVxuICAgIGdldENhcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLkNhcCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbY2FwXSA9IHRoaXMuZmllbGRzLmdldChUYWcuQ2FwKTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShOdW1iZXIoY2FwKSk7XG4gICAgfVxuICAgIGdldEFtb3VudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLkFtb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYW1vdW50XSA9IHRoaXMuZmllbGRzLmdldChUYWcuQW1vdW50KTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShOdW1iZXIoYW1vdW50KSk7XG4gICAgfVxuICAgIGdldFN5bWJvbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLlN5bWJvbCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbc3ltYm9sXSA9IHRoaXMuZmllbGRzLmdldChUYWcuU3ltYm9sKTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShTdHJpbmcuZnJvbUNoYXJDb2RlKE51bWJlcihzeW1ib2wpKSk7XG4gICAgfVxuICAgIGdldFRlcm1zKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRmxhZ3MoRmxhZy5UZXJtcykpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLmdldENhcCgpO1xuICAgICAgICBpZiAoIWNhcC5pc1NvbWUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gY2FwIGZpZWxkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHRoaXMuZ2V0QW1vdW50KCk7XG4gICAgICAgIGlmICghYW1vdW50LmlzU29tZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBhbW91bnQgZmllbGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVpZ2h0U3RhcnQgPSB0aGlzLmdldEhlaWdodFN0YXJ0KCk7XG4gICAgICAgIGNvbnN0IGhlaWdodEVuZCA9IHRoaXMuZ2V0SGVpZ2h0RW5kKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFN0YXJ0ID0gdGhpcy5nZXRPZmZzZXRTdGFydCgpO1xuICAgICAgICBjb25zdCBvZmZzZXRFbmQgPSB0aGlzLmdldE9mZnNldEVuZCgpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBuZXcgUmFuZ2UoaGVpZ2h0U3RhcnQsIGhlaWdodEVuZCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG5ldyBSYW5nZShvZmZzZXRTdGFydCwgb2Zmc2V0RW5kKTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShuZXcgVGVybXMoYW1vdW50LnZhbHVlKCksIGNhcC52YWx1ZSgpLCBoZWlnaHQsIG9mZnNldCkpO1xuICAgIH1cbiAgICBnZXRQb2ludGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzLmhhcyhUYWcuUG9pbnRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcG9pbnRlcl0gPSB0aGlzLmZpZWxkcy5nZXQoVGFnLlBvaW50ZXIpO1xuICAgICAgICByZXR1cm4gKDAsIGZ0c18xLnNvbWUpKE51bWJlcihwb2ludGVyKSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNzYWdlID0gTWVzc2FnZTtcbmNsYXNzIEV0Y2hJbnNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzID0gbmV3IE1hcCgpLCBkYXRhID0gQnVmZmVyLmFsbG9jKDApKSB7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBzZXRDb250ZW50KGNvbnRlbnRUeXBlLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuZmllbGRzLnNldCgxLCBCdWZmZXIuZnJvbShjb250ZW50VHlwZSwgJ3V0ZjgnKSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHNldFJ1bmUocnVuZSkge1xuICAgICAgICBjb25zdCBuID0gKDAsIGJhc2UyNl8xLmJhc2UyNkVuY29kZSkoKDAsIHNwYWNlcnNfMS5yZW1vdmVTcGFjZXJzKShydW5lKSk7XG4gICAgICAgIGxldCBuc3RyID0gbi50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChuc3RyLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgIG5zdHIgPSAnMCcgKyBuc3RyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RmllbGQoRXRjaEluc2NyaXB0aW9uLlRhZy5SVU5FLCBCdWZmZXIuZnJvbShuc3RyLCAnaGV4JykucmV2ZXJzZSgpKTtcbiAgICB9XG4gICAgc2V0RmllbGQoZmllbGQsIHZhbCkge1xuICAgICAgICB0aGlzLmZpZWxkcy5zZXQoZmllbGQsIHZhbCk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNpcGhlcihyYXdUeCwgaW5wdXRJZHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uZnJvbUhleChyYXdUeCk7XG4gICAgICAgIGNvbnN0IHdpdG5lc3MgPSB0eC5pbnNbaW5wdXRJZHhdLndpdG5lc3M7XG4gICAgICAgIGNvbnN0IHRhcHNjcmlwdCA9IHdpdG5lc3NbMV07XG4gICAgICAgIGNvbnN0IGxzID0gYml0Y29pbmpzX2xpYl8xLnNjcmlwdC5kZWNvbXBpbGUodGFwc2NyaXB0KTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBkYXRhQ2h1bmtzID0gW107XG4gICAgICAgIGxldCBpc0RhdGEgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDU7IGkgPCBscy5sZW5ndGggLSAxOykge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBsc1tpXTtcbiAgICAgICAgICAgIGlmIChjaHVuayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlzRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0YVxuICAgICAgICAgICAgICAgIGRhdGFDaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmllbGRzXG4gICAgICAgICAgICAgICAgY29uc3QgdGFnID0gY2h1bmsgLSA4MDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBsc1tpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZi53cml0ZVVpbnQ4KHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zZXQodGFnLCBidWZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zZXQodGFnLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFdGNoSW5zY3JpcHRpb24oZmllbGRzLCBCdWZmZXIuY29uY2F0KGRhdGFDaHVua3MpKTtcbiAgICB9XG4gICAgZW5jaXBoZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXMucHVzaChCdWZmZXIuZnJvbSgnMDA2MzAzNmY3MjY0JywgJ2hleCcpIC8vIDAgT1BfSUYgXCJvcmRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5maWVsZHMuZW50cmllcygpKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSkgLy8gU29ydGluZyBieSB0YWcgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKFt0YWcsIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdCdWZmID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICAgICAgICAgIHRhZ0J1ZmYud3JpdGVVSW50OCh0YWcpO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKEJ1ZmZlci5mcm9tKCcwMScsICdoZXgnKSk7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGFnQnVmZik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggIT0gMSB8fCB2YWxbMF0gIT0gMHgwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCgoMCwgdXRpbHNfMS50b1B1c2hEYXRhKSh2YWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXMucHVzaChCdWZmZXIuZnJvbSgnMDAnLCAnaGV4JykpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUNodW5rcyA9ICgwLCB1dGlsc18xLmNodW5rcykoQXJyYXkuZnJvbSh0aGlzLmRhdGEpLCA1MjApO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBkYXRhQ2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goKDAsIHV0aWxzXzEudG9QdXNoRGF0YSkoQnVmZmVyLmZyb20oY2h1bmspKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMucHVzaChCdWZmZXIuZnJvbSgnMDA2MycsICdoZXgnKSAvLyAwIE9QX0lGXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgcnVuZSA9IHRoaXMuZmllbGRzLmdldChFdGNoSW5zY3JpcHRpb24uVGFnLlJVTkUpO1xuICAgICAgICAgICAgaWYgKCFydW5lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW5lIGZvdW5kIWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goKDAsIHV0aWxzXzEudG9QdXNoRGF0YSkocnVuZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKEJ1ZmZlci5mcm9tKCc2OCcsICdoZXgnKSk7IC8vIE9QX0VORElGXG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KHJlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5FdGNoSW5zY3JpcHRpb24gPSBFdGNoSW5zY3JpcHRpb247XG5FdGNoSW5zY3JpcHRpb24uVGFnID0ge1xuICAgIENPTlRFTlRfVFlQRTogMSxcbiAgICBQT0lOVEVSOiAyLFxuICAgIFBBUkVOVDogMyxcbiAgICBNRVRBREFUQTogNSxcbiAgICBNRVRBUFJPVE9DT0w6IDcsXG4gICAgQ09OVEVOVF9FTkNPRElORzogOSxcbiAgICBERUxFR0FURTogMTEsXG4gICAgUlVORTogMTNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/runelib/dist/runestones.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/runelib/dist/spacers.js":
/*!**********************************************!*\
  !*** ./node_modules/runelib/dist/spacers.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.removeSpacers = exports.getSpacersVal = exports.applySpacers = void 0;\nfunction applySpacers(str, spacers) {\n    let res = '';\n    for (let i = 0; i < str.length; i++) {\n        res += str.charAt(i);\n        if (spacers > 0) {\n            // Get the least significant bit\n            let bit = spacers & 1;\n            if (bit === 1) {\n                res += '•';\n            }\n            // Right shift the number to process the next bit\n            spacers >>= 1;\n        }\n    }\n    return res;\n}\nexports.applySpacers = applySpacers;\nfunction getSpacersVal(str) {\n    let res = 0;\n    let spacersCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        const char = str.charAt(i);\n        if (char === '•') {\n            res += 1 << (i - 1 - spacersCnt);\n            spacersCnt++;\n        }\n    }\n    return res;\n}\nexports.getSpacersVal = getSpacersVal;\nfunction removeSpacers(rune) {\n    return rune.replace(/[•]+/g, \"\");\n}\nexports.removeSpacers = removeSpacers;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L3NwYWNlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9ydW5lbGliL2Rpc3Qvc3BhY2Vycy5qcz9mMzExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZW1vdmVTcGFjZXJzID0gZXhwb3J0cy5nZXRTcGFjZXJzVmFsID0gZXhwb3J0cy5hcHBseVNwYWNlcnMgPSB2b2lkIDA7XG5mdW5jdGlvbiBhcHBseVNwYWNlcnMoc3RyLCBzcGFjZXJzKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlcyArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpZiAoc3BhY2VycyA+IDApIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0XG4gICAgICAgICAgICBsZXQgYml0ID0gc3BhY2VycyAmIDE7XG4gICAgICAgICAgICBpZiAoYml0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9ICfigKInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmlnaHQgc2hpZnQgdGhlIG51bWJlciB0byBwcm9jZXNzIHRoZSBuZXh0IGJpdFxuICAgICAgICAgICAgc3BhY2VycyA+Pj0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5hcHBseVNwYWNlcnMgPSBhcHBseVNwYWNlcnM7XG5mdW5jdGlvbiBnZXRTcGFjZXJzVmFsKHN0cikge1xuICAgIGxldCByZXMgPSAwO1xuICAgIGxldCBzcGFjZXJzQ250ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICfigKInKSB7XG4gICAgICAgICAgICByZXMgKz0gMSA8PCAoaSAtIDEgLSBzcGFjZXJzQ250KTtcbiAgICAgICAgICAgIHNwYWNlcnNDbnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5nZXRTcGFjZXJzVmFsID0gZ2V0U3BhY2Vyc1ZhbDtcbmZ1bmN0aW9uIHJlbW92ZVNwYWNlcnMocnVuZSkge1xuICAgIHJldHVybiBydW5lLnJlcGxhY2UoL1vigKJdKy9nLCBcIlwiKTtcbn1cbmV4cG9ydHMucmVtb3ZlU3BhY2VycyA9IHJlbW92ZVNwYWNlcnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/runelib/dist/spacers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/runelib/dist/utils.js":
/*!********************************************!*\
  !*** ./node_modules/runelib/dist/utils.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toPushData = exports.chunks = exports.toHex = exports.zero2 = void 0;\n/**\n * Prepends a '0' to an odd character length word to ensure it has an even number of characters.\n * @param {string} word - The input word.\n * @returns {string} - The word with a leading '0' if it's an odd character length; otherwise, the original word.\n */\nconst zero2 = (word) => {\n    if (word.length % 2 === 1) {\n        return '0' + word;\n    }\n    else {\n        return word;\n    }\n};\nexports.zero2 = zero2;\n/**\n * Converts an array of numbers to a hexadecimal string representation.\n * @param {number[]} msg - The input array of numbers.\n * @returns {string} - The hexadecimal string representation of the input array.\n */\nconst toHex = (msg) => {\n    let res = '';\n    for (let i = 0; i < msg.length; i++) {\n        res += (0, exports.zero2)(msg[i].toString(16));\n    }\n    return res;\n};\nexports.toHex = toHex;\nfunction chunks(bin, chunkSize) {\n    const chunks = [];\n    let offset = 0;\n    while (offset < bin.length) {\n        // Use Buffer.slice to create a chunk. This method does not copy the memory;\n        // it creates a new Buffer that references the original memory.\n        const chunk = bin.slice(offset, offset + chunkSize);\n        chunks.push(chunk);\n        offset += chunkSize;\n    }\n    return chunks;\n}\nexports.chunks = chunks;\nfunction toPushData(data) {\n    const res = [];\n    const dLen = data.length;\n    if (dLen < 0x4c) {\n        const dLenBuff = Buffer.alloc(1);\n        dLenBuff.writeUInt8(dLen);\n        res.push(dLenBuff);\n    }\n    else if (dLen <= 0xff) {\n        // OP_PUSHDATA1\n        res.push(Buffer.from('4c', 'hex'));\n        const dLenBuff = Buffer.alloc(1);\n        dLenBuff.writeUInt8(dLen);\n        res.push(dLenBuff);\n    }\n    else if (dLen <= 0xffff) {\n        // OP_PUSHDATA2\n        res.push(Buffer.from('4d', 'hex'));\n        const dLenBuff = Buffer.alloc(2);\n        dLenBuff.writeUint16LE(dLen);\n        res.push(dLenBuff);\n    }\n    else {\n        // OP_PUSHDATA4\n        res.push(Buffer.from('4e', 'hex'));\n        const dLenBuff = Buffer.alloc(4);\n        dLenBuff.writeUint32LE(dLen);\n        res.push(dLenBuff);\n    }\n    res.push(data);\n    return Buffer.concat(res);\n}\nexports.toPushData = toPushData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsYUFBYTtBQUNuRTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUSwrREFBK0Q7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9ydW5lbGliL2Rpc3QvdXRpbHMuanM/MGNhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9QdXNoRGF0YSA9IGV4cG9ydHMuY2h1bmtzID0gZXhwb3J0cy50b0hleCA9IGV4cG9ydHMuemVybzIgPSB2b2lkIDA7XG4vKipcbiAqIFByZXBlbmRzIGEgJzAnIHRvIGFuIG9kZCBjaGFyYWN0ZXIgbGVuZ3RoIHdvcmQgdG8gZW5zdXJlIGl0IGhhcyBhbiBldmVuIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICogQHBhcmFtIHtzdHJpbmd9IHdvcmQgLSBUaGUgaW5wdXQgd29yZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHdvcmQgd2l0aCBhIGxlYWRpbmcgJzAnIGlmIGl0J3MgYW4gb2RkIGNoYXJhY3RlciBsZW5ndGg7IG90aGVyd2lzZSwgdGhlIG9yaWdpbmFsIHdvcmQuXG4gKi9cbmNvbnN0IHplcm8yID0gKHdvcmQpID0+IHtcbiAgICBpZiAod29yZC5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdvcmQ7XG4gICAgfVxufTtcbmV4cG9ydHMuemVybzIgPSB6ZXJvMjtcbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgbnVtYmVycyB0byBhIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyW119IG1zZyAtIFRoZSBpbnB1dCBhcnJheSBvZiBudW1iZXJzLlxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnB1dCBhcnJheS5cbiAqL1xuY29uc3QgdG9IZXggPSAobXNnKSA9PiB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlcyArPSAoMCwgZXhwb3J0cy56ZXJvMikobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZnVuY3Rpb24gY2h1bmtzKGJpbiwgY2h1bmtTaXplKSB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IGJpbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gVXNlIEJ1ZmZlci5zbGljZSB0byBjcmVhdGUgYSBjaHVuay4gVGhpcyBtZXRob2QgZG9lcyBub3QgY29weSB0aGUgbWVtb3J5O1xuICAgICAgICAvLyBpdCBjcmVhdGVzIGEgbmV3IEJ1ZmZlciB0aGF0IHJlZmVyZW5jZXMgdGhlIG9yaWdpbmFsIG1lbW9yeS5cbiAgICAgICAgY29uc3QgY2h1bmsgPSBiaW4uc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjaHVua1NpemUpO1xuICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgfVxuICAgIHJldHVybiBjaHVua3M7XG59XG5leHBvcnRzLmNodW5rcyA9IGNodW5rcztcbmZ1bmN0aW9uIHRvUHVzaERhdGEoZGF0YSkge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRMZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBpZiAoZExlbiA8IDB4NGMpIHtcbiAgICAgICAgY29uc3QgZExlbkJ1ZmYgPSBCdWZmZXIuYWxsb2MoMSk7XG4gICAgICAgIGRMZW5CdWZmLndyaXRlVUludDgoZExlbik7XG4gICAgICAgIHJlcy5wdXNoKGRMZW5CdWZmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZExlbiA8PSAweGZmKSB7XG4gICAgICAgIC8vIE9QX1BVU0hEQVRBMVxuICAgICAgICByZXMucHVzaChCdWZmZXIuZnJvbSgnNGMnLCAnaGV4JykpO1xuICAgICAgICBjb25zdCBkTGVuQnVmZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgZExlbkJ1ZmYud3JpdGVVSW50OChkTGVuKTtcbiAgICAgICAgcmVzLnB1c2goZExlbkJ1ZmYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkTGVuIDw9IDB4ZmZmZikge1xuICAgICAgICAvLyBPUF9QVVNIREFUQTJcbiAgICAgICAgcmVzLnB1c2goQnVmZmVyLmZyb20oJzRkJywgJ2hleCcpKTtcbiAgICAgICAgY29uc3QgZExlbkJ1ZmYgPSBCdWZmZXIuYWxsb2MoMik7XG4gICAgICAgIGRMZW5CdWZmLndyaXRlVWludDE2TEUoZExlbik7XG4gICAgICAgIHJlcy5wdXNoKGRMZW5CdWZmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE9QX1BVU0hEQVRBNFxuICAgICAgICByZXMucHVzaChCdWZmZXIuZnJvbSgnNGUnLCAnaGV4JykpO1xuICAgICAgICBjb25zdCBkTGVuQnVmZiA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgZExlbkJ1ZmYud3JpdGVVaW50MzJMRShkTGVuKTtcbiAgICAgICAgcmVzLnB1c2goZExlbkJ1ZmYpO1xuICAgIH1cbiAgICByZXMucHVzaChkYXRhKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChyZXMpO1xufVxuZXhwb3J0cy50b1B1c2hEYXRhID0gdG9QdXNoRGF0YTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/runelib/dist/utils.js\n");

/***/ })

};
;
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ripple-binary-codec";
exports.ids = ["vendor-chunks/ripple-binary-codec"];
exports.modules = {

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/binary.js":
/*!*********************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/binary.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint-disable func-style */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/index.js\");\nconst binary_parser_1 = __webpack_require__(/*! ./serdes/binary-parser */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js\");\nObject.defineProperty(exports, \"BinaryParser\", ({ enumerable: true, get: function () { return binary_parser_1.BinaryParser; } }));\nconst hash_prefixes_1 = __webpack_require__(/*! ./hash-prefixes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/hash-prefixes.js\");\nconst binary_serializer_1 = __webpack_require__(/*! ./serdes/binary-serializer */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js\");\nObject.defineProperty(exports, \"BinarySerializer\", ({ enumerable: true, get: function () { return binary_serializer_1.BinarySerializer; } }));\nObject.defineProperty(exports, \"BytesList\", ({ enumerable: true, get: function () { return binary_serializer_1.BytesList; } }));\nconst hashes_1 = __webpack_require__(/*! ./hashes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/hashes.js\");\nObject.defineProperty(exports, \"sha512Half\", ({ enumerable: true, get: function () { return hashes_1.sha512Half; } }));\nObject.defineProperty(exports, \"transactionID\", ({ enumerable: true, get: function () { return hashes_1.transactionID; } }));\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/index.js\");\nconst bigInt = __webpack_require__(/*! big-integer */ \"(ssr)/./node_modules/ripple-binary-codec/node_modules/big-integer/BigInteger.js\");\n/**\n * Construct a BinaryParser\n *\n * @param bytes hex-string to construct BinaryParser from\n * @param definitions rippled definitions used to parse the values of transaction types and such.\n *                          Can be customized for sidechains and amendments.\n * @returns A BinaryParser\n */\nconst makeParser = (bytes, definitions) => new binary_parser_1.BinaryParser(bytes, definitions);\nexports.makeParser = makeParser;\n/**\n * Parse BinaryParser into JSON\n *\n * @param parser BinaryParser object\n * @param definitions rippled definitions used to parse the values of transaction types and such.\n *                          Can be customized for sidechains and amendments.\n * @returns JSON for the bytes in the BinaryParser\n */\nconst readJSON = (parser, definitions = enums_1.DEFAULT_DEFINITIONS) => parser.readType(types_1.coreTypes.STObject).toJSON(definitions);\nexports.readJSON = readJSON;\n/**\n * Parse a hex-string into its JSON interpretation\n *\n * @param bytes hex-string to parse into JSON\n * @param definitions rippled definitions used to parse the values of transaction types and such.\n *                          Can be customized for sidechains and amendments.\n * @returns JSON\n */\nconst binaryToJSON = (bytes, definitions) => readJSON(makeParser(bytes, definitions), definitions);\nexports.binaryToJSON = binaryToJSON;\n/**\n * Function to serialize JSON object representing a transaction\n *\n * @param object JSON object to serialize\n * @param opts options for serializing, including optional prefix, suffix, signingFieldOnly, and definitions\n * @returns A Buffer containing the serialized object\n */\nfunction serializeObject(object, opts = {}) {\n    const { prefix, suffix, signingFieldsOnly = false, definitions } = opts;\n    const bytesList = new binary_serializer_1.BytesList();\n    if (prefix) {\n        bytesList.put(prefix);\n    }\n    const filter = signingFieldsOnly\n        ? (f) => f.isSigningField\n        : undefined;\n    types_1.coreTypes.STObject\n        .from(object, filter, definitions)\n        .toBytesSink(bytesList);\n    if (suffix) {\n        bytesList.put(suffix);\n    }\n    return bytesList.toBytes();\n}\nexports.serializeObject = serializeObject;\n/**\n * Serialize an object for signing\n *\n * @param transaction Transaction to serialize\n * @param prefix Prefix bytes to put before the serialized object\n * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns A Buffer with the serialized object\n */\nfunction signingData(transaction, prefix = hash_prefixes_1.HashPrefix.transactionSig, opts = {}) {\n    return serializeObject(transaction, {\n        prefix,\n        signingFieldsOnly: true,\n        definitions: opts.definitions,\n    });\n}\nexports.signingData = signingData;\n/**\n * Serialize a signingClaim\n *\n * @param claim A claim object to serialize\n * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns the serialized object with appropriate prefix\n */\nfunction signingClaimData(claim) {\n    const num = bigInt(String(claim.amount));\n    const prefix = hash_prefixes_1.HashPrefix.paymentChannelClaim;\n    const channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();\n    const amount = types_1.coreTypes.UInt64.from(num).toBytes();\n    const bytesList = new binary_serializer_1.BytesList();\n    bytesList.put(prefix);\n    bytesList.put(channel);\n    bytesList.put(amount);\n    return bytesList.toBytes();\n}\nexports.signingClaimData = signingClaimData;\n/**\n * Serialize a transaction object for multiSigning\n *\n * @param transaction transaction to serialize\n * @param signingAccount Account to sign the transaction with\n * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns serialized transaction with appropriate prefix and suffix\n */\nfunction multiSigningData(transaction, signingAccount, opts = {\n    definitions: enums_1.DEFAULT_DEFINITIONS,\n}) {\n    const prefix = hash_prefixes_1.HashPrefix.transactionMultiSig;\n    const suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();\n    return serializeObject(transaction, {\n        prefix,\n        suffix,\n        signingFieldsOnly: true,\n        definitions: opts.definitions,\n    });\n}\nexports.multiSigningData = multiSigningData;\n//# sourceMappingURL=binary.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2JpbmFyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLHdCQUF3QixHQUFHLGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQjtBQUNyUixnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBUztBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxxR0FBd0I7QUFDeEQsZ0RBQStDLEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQy9ILHdCQUF3QixtQkFBTyxDQUFDLHVGQUFpQjtBQUNqRCw0QkFBNEIsbUJBQU8sQ0FBQyw2R0FBNEI7QUFDaEUsb0RBQW1ELEVBQUUscUNBQXFDLGdEQUFnRCxFQUFDO0FBQzNJLDZDQUE0QyxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUM3SCxpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBVTtBQUNuQyw4Q0FBNkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDcEgsaURBQWdELEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQzFILGdCQUFnQixtQkFBTyxDQUFDLDZFQUFTO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxvR0FBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxZQUFZLHlEQUF5RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvYmluYXJ5LmpzPzM0MzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBmdW5jLXN0eWxlICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYW5zYWN0aW9uSUQgPSBleHBvcnRzLnNoYTUxMkhhbGYgPSBleHBvcnRzLmJpbmFyeVRvSlNPTiA9IGV4cG9ydHMuc2lnbmluZ0NsYWltRGF0YSA9IGV4cG9ydHMuc2lnbmluZ0RhdGEgPSBleHBvcnRzLm11bHRpU2lnbmluZ0RhdGEgPSBleHBvcnRzLnJlYWRKU09OID0gZXhwb3J0cy5zZXJpYWxpemVPYmplY3QgPSBleHBvcnRzLm1ha2VQYXJzZXIgPSBleHBvcnRzLkJ5dGVzTGlzdCA9IGV4cG9ydHMuQmluYXJ5U2VyaWFsaXplciA9IGV4cG9ydHMuQmluYXJ5UGFyc2VyID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgYmluYXJ5X3BhcnNlcl8xID0gcmVxdWlyZShcIi4vc2VyZGVzL2JpbmFyeS1wYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaW5hcnlQYXJzZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpbmFyeV9wYXJzZXJfMS5CaW5hcnlQYXJzZXI7IH0gfSk7XG5jb25zdCBoYXNoX3ByZWZpeGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoLXByZWZpeGVzXCIpO1xuY29uc3QgYmluYXJ5X3NlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcmRlcy9iaW5hcnktc2VyaWFsaXplclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpbmFyeVNlcmlhbGl6ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpbmFyeV9zZXJpYWxpemVyXzEuQmluYXJ5U2VyaWFsaXplcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ5dGVzTGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmluYXJ5X3NlcmlhbGl6ZXJfMS5CeXRlc0xpc3Q7IH0gfSk7XG5jb25zdCBoYXNoZXNfMSA9IHJlcXVpcmUoXCIuL2hhc2hlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTUxMkhhbGZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc18xLnNoYTUxMkhhbGY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmFuc2FjdGlvbklEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoZXNfMS50cmFuc2FjdGlvbklEOyB9IH0pO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuY29uc3QgYmlnSW50ID0gcmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBCaW5hcnlQYXJzZXJcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgaGV4LXN0cmluZyB0byBjb25zdHJ1Y3QgQmluYXJ5UGFyc2VyIGZyb21cbiAqIEBwYXJhbSBkZWZpbml0aW9ucyByaXBwbGVkIGRlZmluaXRpb25zIHVzZWQgdG8gcGFyc2UgdGhlIHZhbHVlcyBvZiB0cmFuc2FjdGlvbiB0eXBlcyBhbmQgc3VjaC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgY3VzdG9taXplZCBmb3Igc2lkZWNoYWlucyBhbmQgYW1lbmRtZW50cy5cbiAqIEByZXR1cm5zIEEgQmluYXJ5UGFyc2VyXG4gKi9cbmNvbnN0IG1ha2VQYXJzZXIgPSAoYnl0ZXMsIGRlZmluaXRpb25zKSA9PiBuZXcgYmluYXJ5X3BhcnNlcl8xLkJpbmFyeVBhcnNlcihieXRlcywgZGVmaW5pdGlvbnMpO1xuZXhwb3J0cy5tYWtlUGFyc2VyID0gbWFrZVBhcnNlcjtcbi8qKlxuICogUGFyc2UgQmluYXJ5UGFyc2VyIGludG8gSlNPTlxuICpcbiAqIEBwYXJhbSBwYXJzZXIgQmluYXJ5UGFyc2VyIG9iamVjdFxuICogQHBhcmFtIGRlZmluaXRpb25zIHJpcHBsZWQgZGVmaW5pdGlvbnMgdXNlZCB0byBwYXJzZSB0aGUgdmFsdWVzIG9mIHRyYW5zYWN0aW9uIHR5cGVzIGFuZCBzdWNoLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBjdXN0b21pemVkIGZvciBzaWRlY2hhaW5zIGFuZCBhbWVuZG1lbnRzLlxuICogQHJldHVybnMgSlNPTiBmb3IgdGhlIGJ5dGVzIGluIHRoZSBCaW5hcnlQYXJzZXJcbiAqL1xuY29uc3QgcmVhZEpTT04gPSAocGFyc2VyLCBkZWZpbml0aW9ucyA9IGVudW1zXzEuREVGQVVMVF9ERUZJTklUSU9OUykgPT4gcGFyc2VyLnJlYWRUeXBlKHR5cGVzXzEuY29yZVR5cGVzLlNUT2JqZWN0KS50b0pTT04oZGVmaW5pdGlvbnMpO1xuZXhwb3J0cy5yZWFkSlNPTiA9IHJlYWRKU09OO1xuLyoqXG4gKiBQYXJzZSBhIGhleC1zdHJpbmcgaW50byBpdHMgSlNPTiBpbnRlcnByZXRhdGlvblxuICpcbiAqIEBwYXJhbSBieXRlcyBoZXgtc3RyaW5nIHRvIHBhcnNlIGludG8gSlNPTlxuICogQHBhcmFtIGRlZmluaXRpb25zIHJpcHBsZWQgZGVmaW5pdGlvbnMgdXNlZCB0byBwYXJzZSB0aGUgdmFsdWVzIG9mIHRyYW5zYWN0aW9uIHR5cGVzIGFuZCBzdWNoLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBjdXN0b21pemVkIGZvciBzaWRlY2hhaW5zIGFuZCBhbWVuZG1lbnRzLlxuICogQHJldHVybnMgSlNPTlxuICovXG5jb25zdCBiaW5hcnlUb0pTT04gPSAoYnl0ZXMsIGRlZmluaXRpb25zKSA9PiByZWFkSlNPTihtYWtlUGFyc2VyKGJ5dGVzLCBkZWZpbml0aW9ucyksIGRlZmluaXRpb25zKTtcbmV4cG9ydHMuYmluYXJ5VG9KU09OID0gYmluYXJ5VG9KU09OO1xuLyoqXG4gKiBGdW5jdGlvbiB0byBzZXJpYWxpemUgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHJhbnNhY3Rpb25cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IEpTT04gb2JqZWN0IHRvIHNlcmlhbGl6ZVxuICogQHBhcmFtIG9wdHMgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcsIGluY2x1ZGluZyBvcHRpb25hbCBwcmVmaXgsIHN1ZmZpeCwgc2lnbmluZ0ZpZWxkT25seSwgYW5kIGRlZmluaXRpb25zXG4gKiBAcmV0dXJucyBBIEJ1ZmZlciBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIG9iamVjdFxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3Qob2JqZWN0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHByZWZpeCwgc3VmZml4LCBzaWduaW5nRmllbGRzT25seSA9IGZhbHNlLCBkZWZpbml0aW9ucyB9ID0gb3B0cztcbiAgICBjb25zdCBieXRlc0xpc3QgPSBuZXcgYmluYXJ5X3NlcmlhbGl6ZXJfMS5CeXRlc0xpc3QoKTtcbiAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGJ5dGVzTGlzdC5wdXQocHJlZml4KTtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyID0gc2lnbmluZ0ZpZWxkc09ubHlcbiAgICAgICAgPyAoZikgPT4gZi5pc1NpZ25pbmdGaWVsZFxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB0eXBlc18xLmNvcmVUeXBlcy5TVE9iamVjdFxuICAgICAgICAuZnJvbShvYmplY3QsIGZpbHRlciwgZGVmaW5pdGlvbnMpXG4gICAgICAgIC50b0J5dGVzU2luayhieXRlc0xpc3QpO1xuICAgIGlmIChzdWZmaXgpIHtcbiAgICAgICAgYnl0ZXNMaXN0LnB1dChzdWZmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXNMaXN0LnRvQnl0ZXMoKTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplT2JqZWN0O1xuLyoqXG4gKiBTZXJpYWxpemUgYW4gb2JqZWN0IGZvciBzaWduaW5nXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIHNlcmlhbGl6ZVxuICogQHBhcmFtIHByZWZpeCBQcmVmaXggYnl0ZXMgdG8gcHV0IGJlZm9yZSB0aGUgc2VyaWFsaXplZCBvYmplY3RcbiAqIEBwYXJhbSBvcHRzLmRlZmluaXRpb25zIEN1c3RvbSByaXBwbGVkIHR5cGVzIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0LiBVc2VkIGZvciBzaWRlY2hhaW5zIGFuZCBhbWVuZG1lbnRzLlxuICogQHJldHVybnMgQSBCdWZmZXIgd2l0aCB0aGUgc2VyaWFsaXplZCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc2lnbmluZ0RhdGEodHJhbnNhY3Rpb24sIHByZWZpeCA9IGhhc2hfcHJlZml4ZXNfMS5IYXNoUHJlZml4LnRyYW5zYWN0aW9uU2lnLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KHRyYW5zYWN0aW9uLCB7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgc2lnbmluZ0ZpZWxkc09ubHk6IHRydWUsXG4gICAgICAgIGRlZmluaXRpb25zOiBvcHRzLmRlZmluaXRpb25zLFxuICAgIH0pO1xufVxuZXhwb3J0cy5zaWduaW5nRGF0YSA9IHNpZ25pbmdEYXRhO1xuLyoqXG4gKiBTZXJpYWxpemUgYSBzaWduaW5nQ2xhaW1cbiAqXG4gKiBAcGFyYW0gY2xhaW0gQSBjbGFpbSBvYmplY3QgdG8gc2VyaWFsaXplXG4gKiBAcGFyYW0gb3B0cy5kZWZpbml0aW9ucyBDdXN0b20gcmlwcGxlZCB0eXBlcyB0byB1c2UgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdC4gVXNlZCBmb3Igc2lkZWNoYWlucyBhbmQgYW1lbmRtZW50cy5cbiAqIEByZXR1cm5zIHRoZSBzZXJpYWxpemVkIG9iamVjdCB3aXRoIGFwcHJvcHJpYXRlIHByZWZpeFxuICovXG5mdW5jdGlvbiBzaWduaW5nQ2xhaW1EYXRhKGNsYWltKSB7XG4gICAgY29uc3QgbnVtID0gYmlnSW50KFN0cmluZyhjbGFpbS5hbW91bnQpKTtcbiAgICBjb25zdCBwcmVmaXggPSBoYXNoX3ByZWZpeGVzXzEuSGFzaFByZWZpeC5wYXltZW50Q2hhbm5lbENsYWltO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0eXBlc18xLmNvcmVUeXBlcy5IYXNoMjU2LmZyb20oY2xhaW0uY2hhbm5lbCkudG9CeXRlcygpO1xuICAgIGNvbnN0IGFtb3VudCA9IHR5cGVzXzEuY29yZVR5cGVzLlVJbnQ2NC5mcm9tKG51bSkudG9CeXRlcygpO1xuICAgIGNvbnN0IGJ5dGVzTGlzdCA9IG5ldyBiaW5hcnlfc2VyaWFsaXplcl8xLkJ5dGVzTGlzdCgpO1xuICAgIGJ5dGVzTGlzdC5wdXQocHJlZml4KTtcbiAgICBieXRlc0xpc3QucHV0KGNoYW5uZWwpO1xuICAgIGJ5dGVzTGlzdC5wdXQoYW1vdW50KTtcbiAgICByZXR1cm4gYnl0ZXNMaXN0LnRvQnl0ZXMoKTtcbn1cbmV4cG9ydHMuc2lnbmluZ0NsYWltRGF0YSA9IHNpZ25pbmdDbGFpbURhdGE7XG4vKipcbiAqIFNlcmlhbGl6ZSBhIHRyYW5zYWN0aW9uIG9iamVjdCBmb3IgbXVsdGlTaWduaW5nXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIHRyYW5zYWN0aW9uIHRvIHNlcmlhbGl6ZVxuICogQHBhcmFtIHNpZ25pbmdBY2NvdW50IEFjY291bnQgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24gd2l0aFxuICogQHBhcmFtIG9wdHMuZGVmaW5pdGlvbnMgQ3VzdG9tIHJpcHBsZWQgdHlwZXMgdG8gdXNlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQuIFVzZWQgZm9yIHNpZGVjaGFpbnMgYW5kIGFtZW5kbWVudHMuXG4gKiBAcmV0dXJucyBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIHdpdGggYXBwcm9wcmlhdGUgcHJlZml4IGFuZCBzdWZmaXhcbiAqL1xuZnVuY3Rpb24gbXVsdGlTaWduaW5nRGF0YSh0cmFuc2FjdGlvbiwgc2lnbmluZ0FjY291bnQsIG9wdHMgPSB7XG4gICAgZGVmaW5pdGlvbnM6IGVudW1zXzEuREVGQVVMVF9ERUZJTklUSU9OUyxcbn0pIHtcbiAgICBjb25zdCBwcmVmaXggPSBoYXNoX3ByZWZpeGVzXzEuSGFzaFByZWZpeC50cmFuc2FjdGlvbk11bHRpU2lnO1xuICAgIGNvbnN0IHN1ZmZpeCA9IHR5cGVzXzEuY29yZVR5cGVzLkFjY291bnRJRC5mcm9tKHNpZ25pbmdBY2NvdW50KS50b0J5dGVzKCk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdCh0cmFuc2FjdGlvbiwge1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHN1ZmZpeCxcbiAgICAgICAgc2lnbmluZ0ZpZWxkc09ubHk6IHRydWUsXG4gICAgICAgIGRlZmluaXRpb25zOiBvcHRzLmRlZmluaXRpb25zLFxuICAgIH0pO1xufVxuZXhwb3J0cy5tdWx0aVNpZ25pbmdEYXRhID0gbXVsdGlTaWduaW5nRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/binary.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/coretypes.js":
/*!************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/coretypes.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.DEFAULT_DEFINITIONS = exports.ledgerHashes = exports.binary = exports.hashes = void 0;\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/index.js\");\nObject.defineProperty(exports, \"DEFAULT_DEFINITIONS\", ({ enumerable: true, get: function () { return enums_1.DEFAULT_DEFINITIONS; } }));\nObject.defineProperty(exports, \"Field\", ({ enumerable: true, get: function () { return enums_1.Field; } }));\nObject.defineProperty(exports, \"TransactionType\", ({ enumerable: true, get: function () { return enums_1.TransactionType; } }));\nObject.defineProperty(exports, \"LedgerEntryType\", ({ enumerable: true, get: function () { return enums_1.LedgerEntryType; } }));\nObject.defineProperty(exports, \"Type\", ({ enumerable: true, get: function () { return enums_1.Type; } }));\nObject.defineProperty(exports, \"TransactionResult\", ({ enumerable: true, get: function () { return enums_1.TransactionResult; } }));\nconst types = __importStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/index.js\"));\nexports.types = types;\nconst binary = __importStar(__webpack_require__(/*! ./binary */ \"(ssr)/./node_modules/ripple-binary-codec/dist/binary.js\"));\nexports.binary = binary;\nconst shamap_1 = __webpack_require__(/*! ./shamap */ \"(ssr)/./node_modules/ripple-binary-codec/dist/shamap.js\");\nObject.defineProperty(exports, \"ShaMap\", ({ enumerable: true, get: function () { return shamap_1.ShaMap; } }));\nconst ledgerHashes = __importStar(__webpack_require__(/*! ./ledger-hashes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/ledger-hashes.js\"));\nexports.ledgerHashes = ledgerHashes;\nconst hashes = __importStar(__webpack_require__(/*! ./hashes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/hashes.js\"));\nexports.hashes = hashes;\nconst quality_1 = __webpack_require__(/*! ./quality */ \"(ssr)/./node_modules/ripple-binary-codec/dist/quality.js\");\nObject.defineProperty(exports, \"quality\", ({ enumerable: true, get: function () { return quality_1.quality; } }));\nconst hash_prefixes_1 = __webpack_require__(/*! ./hash-prefixes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/hash-prefixes.js\");\nObject.defineProperty(exports, \"HashPrefix\", ({ enumerable: true, get: function () { return hash_prefixes_1.HashPrefix; } }));\n//# sourceMappingURL=coretypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2NvcmV0eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGNBQWMsR0FBRyxrQkFBa0IsR0FBRyxlQUFlLEdBQUcseUJBQXlCLEdBQUcsWUFBWSxHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLGFBQWEsR0FBRywyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUMzUSxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBUztBQUNqQyx1REFBc0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDckkseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLG1EQUFrRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM3SCxtREFBa0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDN0gsd0NBQXVDLEVBQUUscUNBQXFDLHdCQUF3QixFQUFDO0FBQ3ZHLHFEQUFvRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUNqSSwyQkFBMkIsbUJBQU8sQ0FBQyw2RUFBUztBQUM1QyxhQUFhO0FBQ2IsNEJBQTRCLG1CQUFPLENBQUMseUVBQVU7QUFDOUMsY0FBYztBQUNkLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFVO0FBQ25DLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1RyxrQ0FBa0MsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDM0Qsb0JBQW9CO0FBQ3BCLDRCQUE0QixtQkFBTyxDQUFDLHlFQUFVO0FBQzlDLGNBQWM7QUFDZCxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBVztBQUNyQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0csd0JBQXdCLG1CQUFPLENBQUMsdUZBQWlCO0FBQ2pELDhDQUE2QyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMzSCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC9jb3JldHlwZXMuanM/OGMzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50eXBlcyA9IGV4cG9ydHMuU2hhTWFwID0gZXhwb3J0cy5IYXNoUHJlZml4ID0gZXhwb3J0cy5xdWFsaXR5ID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlc3VsdCA9IGV4cG9ydHMuVHlwZSA9IGV4cG9ydHMuTGVkZ2VyRW50cnlUeXBlID0gZXhwb3J0cy5UcmFuc2FjdGlvblR5cGUgPSBleHBvcnRzLkZpZWxkID0gZXhwb3J0cy5ERUZBVUxUX0RFRklOSVRJT05TID0gZXhwb3J0cy5sZWRnZXJIYXNoZXMgPSBleHBvcnRzLmJpbmFyeSA9IGV4cG9ydHMuaGFzaGVzID0gdm9pZCAwO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiREVGQVVMVF9ERUZJTklUSU9OU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW51bXNfMS5ERUZBVUxUX0RFRklOSVRJT05TOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmllbGRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuRmllbGQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvblR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuVHJhbnNhY3Rpb25UeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGVkZ2VyRW50cnlUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnVtc18xLkxlZGdlckVudHJ5VHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uUmVzdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnVtc18xLlRyYW5zYWN0aW9uUmVzdWx0OyB9IH0pO1xuY29uc3QgdHlwZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIikpO1xuZXhwb3J0cy50eXBlcyA9IHR5cGVzO1xuY29uc3QgYmluYXJ5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpbmFyeVwiKSk7XG5leHBvcnRzLmJpbmFyeSA9IGJpbmFyeTtcbmNvbnN0IHNoYW1hcF8xID0gcmVxdWlyZShcIi4vc2hhbWFwXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hhTWFwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFtYXBfMS5TaGFNYXA7IH0gfSk7XG5jb25zdCBsZWRnZXJIYXNoZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbGVkZ2VyLWhhc2hlc1wiKSk7XG5leHBvcnRzLmxlZGdlckhhc2hlcyA9IGxlZGdlckhhc2hlcztcbmNvbnN0IGhhc2hlcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9oYXNoZXNcIikpO1xuZXhwb3J0cy5oYXNoZXMgPSBoYXNoZXM7XG5jb25zdCBxdWFsaXR5XzEgPSByZXF1aXJlKFwiLi9xdWFsaXR5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicXVhbGl0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcXVhbGl0eV8xLnF1YWxpdHk7IH0gfSk7XG5jb25zdCBoYXNoX3ByZWZpeGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoLXByZWZpeGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGFzaFByZWZpeFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaF9wcmVmaXhlc18xLkhhc2hQcmVmaXg7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JldHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/coretypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/enums/bytes.js":
/*!**************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/enums/bytes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BytesLookup = exports.Bytes = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/*\n * @brief: Bytes, name, and ordinal representing one type, ledger_type, transaction type, or result\n */\nclass Bytes {\n    constructor(name, ordinal, ordinalWidth) {\n        this.name = name;\n        this.ordinal = ordinal;\n        this.ordinalWidth = ordinalWidth;\n        this.bytes = buffer_1.Buffer.alloc(ordinalWidth);\n        for (let i = 0; i < ordinalWidth; i++) {\n            this.bytes[ordinalWidth - i - 1] = (ordinal >>> (i * 8)) & 0xff;\n        }\n    }\n    toJSON() {\n        return this.name;\n    }\n    toBytesSink(sink) {\n        sink.put(this.bytes);\n    }\n    toBytes() {\n        return this.bytes;\n    }\n}\nexports.Bytes = Bytes;\n/*\n * @brief: Collection of Bytes objects, mapping bidirectionally\n */\nclass BytesLookup {\n    constructor(types, ordinalWidth) {\n        this.ordinalWidth = ordinalWidth;\n        Object.entries(types).forEach(([k, v]) => {\n            this.add(k, v);\n        });\n    }\n    /**\n     * Add a new name value pair to the BytesLookup.\n     *\n     * @param name - A human readable name for the field.\n     * @param value - The numeric value for the field.\n     * @throws if the name or value already exist in the lookup because it's unclear how to decode.\n     */\n    add(name, value) {\n        if (this[name]) {\n            throw new SyntaxError(`Attempted to add a value with a duplicate name \"${name}\". This is not allowed because it is unclear how to decode.`);\n        }\n        if (this[value.toString()]) {\n            throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: \"${name}\" and previous name: \"${this[value.toString()]}. This is not allowed because it is unclear how to decode.\\nGiven value: ${value.toString()}`);\n        }\n        this[name] = new Bytes(name, value, this.ordinalWidth);\n        this[value.toString()] = this[name];\n    }\n    from(value) {\n        return value instanceof Bytes ? value : this[value];\n    }\n    fromParser(parser) {\n        return this.from(parser.readUIntN(this.ordinalWidth).toString());\n    }\n}\nexports.BytesLookup = BytesLookup;\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGFBQWE7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLEtBQUs7QUFDMUY7QUFDQTtBQUNBLDZHQUE2RyxLQUFLLHdCQUF3Qix1QkFBdUIsMkVBQTJFLGlCQUFpQjtBQUM3UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL2J5dGVzLmpzPzI3Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ5dGVzTG9va3VwID0gZXhwb3J0cy5CeXRlcyA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG4vKlxuICogQGJyaWVmOiBCeXRlcywgbmFtZSwgYW5kIG9yZGluYWwgcmVwcmVzZW50aW5nIG9uZSB0eXBlLCBsZWRnZXJfdHlwZSwgdHJhbnNhY3Rpb24gdHlwZSwgb3IgcmVzdWx0XG4gKi9cbmNsYXNzIEJ5dGVzIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBvcmRpbmFsLCBvcmRpbmFsV2lkdGgpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICAgICAgdGhpcy5vcmRpbmFsV2lkdGggPSBvcmRpbmFsV2lkdGg7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2Mob3JkaW5hbFdpZHRoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRpbmFsV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ieXRlc1tvcmRpbmFsV2lkdGggLSBpIC0gMV0gPSAob3JkaW5hbCA+Pj4gKGkgKiA4KSkgJiAweGZmO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgdG9CeXRlc1Npbmsoc2luaykge1xuICAgICAgICBzaW5rLnB1dCh0aGlzLmJ5dGVzKTtcbiAgICB9XG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXM7XG4gICAgfVxufVxuZXhwb3J0cy5CeXRlcyA9IEJ5dGVzO1xuLypcbiAqIEBicmllZjogQ29sbGVjdGlvbiBvZiBCeXRlcyBvYmplY3RzLCBtYXBwaW5nIGJpZGlyZWN0aW9uYWxseVxuICovXG5jbGFzcyBCeXRlc0xvb2t1cCB7XG4gICAgY29uc3RydWN0b3IodHlwZXMsIG9yZGluYWxXaWR0aCkge1xuICAgICAgICB0aGlzLm9yZGluYWxXaWR0aCA9IG9yZGluYWxXaWR0aDtcbiAgICAgICAgT2JqZWN0LmVudHJpZXModHlwZXMpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGQoaywgdik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgbmFtZSB2YWx1ZSBwYWlyIHRvIHRoZSBCeXRlc0xvb2t1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gQSBodW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWVyaWMgdmFsdWUgZm9yIHRoZSBmaWVsZC5cbiAgICAgKiBAdGhyb3dzIGlmIHRoZSBuYW1lIG9yIHZhbHVlIGFscmVhZHkgZXhpc3QgaW4gdGhlIGxvb2t1cCBiZWNhdXNlIGl0J3MgdW5jbGVhciBob3cgdG8gZGVjb2RlLlxuICAgICAqL1xuICAgIGFkZChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBBdHRlbXB0ZWQgdG8gYWRkIGEgdmFsdWUgd2l0aCBhIGR1cGxpY2F0ZSBuYW1lIFwiJHtuYW1lfVwiLiBUaGlzIGlzIG5vdCBhbGxvd2VkIGJlY2F1c2UgaXQgaXMgdW5jbGVhciBob3cgdG8gZGVjb2RlLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW3ZhbHVlLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEF0dGVtcHRlZCB0byBhZGQgYSBkdXBsaWNhdGUgdmFsdWUgdW5kZXIgYSBkaWZmZXJlbnQgbmFtZSAoR2l2ZW4gbmFtZTogXCIke25hbWV9XCIgYW5kIHByZXZpb3VzIG5hbWU6IFwiJHt0aGlzW3ZhbHVlLnRvU3RyaW5nKCldfS4gVGhpcyBpcyBub3QgYWxsb3dlZCBiZWNhdXNlIGl0IGlzIHVuY2xlYXIgaG93IHRvIGRlY29kZS5cXG5HaXZlbiB2YWx1ZTogJHt2YWx1ZS50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbbmFtZV0gPSBuZXcgQnl0ZXMobmFtZSwgdmFsdWUsIHRoaXMub3JkaW5hbFdpZHRoKTtcbiAgICAgICAgdGhpc1t2YWx1ZS50b1N0cmluZygpXSA9IHRoaXNbbmFtZV07XG4gICAgfVxuICAgIGZyb20odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQnl0ZXMgPyB2YWx1ZSA6IHRoaXNbdmFsdWVdO1xuICAgIH1cbiAgICBmcm9tUGFyc2VyKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKHBhcnNlci5yZWFkVUludE4odGhpcy5vcmRpbmFsV2lkdGgpLnRvU3RyaW5nKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnl0ZXNMb29rdXAgPSBCeXRlc0xvb2t1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/enums/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/enums/constants.js":
/*!******************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/enums/constants.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TRANSACTION_RESULT_WIDTH = exports.TRANSACTION_TYPE_WIDTH = exports.LEDGER_ENTRY_WIDTH = exports.TYPE_WIDTH = void 0;\nexports.TYPE_WIDTH = 2;\nexports.LEDGER_ENTRY_WIDTH = 2;\nexports.TRANSACTION_TYPE_WIDTH = 2;\nexports.TRANSACTION_RESULT_WIDTH = 1;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyw4QkFBOEIsR0FBRywwQkFBMEIsR0FBRyxrQkFBa0I7QUFDbkgsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL2NvbnN0YW50cy5qcz83MjhmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UUkFOU0FDVElPTl9SRVNVTFRfV0lEVEggPSBleHBvcnRzLlRSQU5TQUNUSU9OX1RZUEVfV0lEVEggPSBleHBvcnRzLkxFREdFUl9FTlRSWV9XSURUSCA9IGV4cG9ydHMuVFlQRV9XSURUSCA9IHZvaWQgMDtcbmV4cG9ydHMuVFlQRV9XSURUSCA9IDI7XG5leHBvcnRzLkxFREdFUl9FTlRSWV9XSURUSCA9IDI7XG5leHBvcnRzLlRSQU5TQUNUSU9OX1RZUEVfV0lEVEggPSAyO1xuZXhwb3J0cy5UUkFOU0FDVElPTl9SRVNVTFRfV0lEVEggPSAxO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/enums/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/enums/field.js":
/*!**************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/enums/field.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FieldLookup = void 0;\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/bytes.js\");\nconst serialized_type_1 = __webpack_require__(/*! ../types/serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/constants.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/*\n * @brief: Serialize a field based on type_code and Field.nth\n */\nfunction fieldHeader(type, nth) {\n    const header = [];\n    if (type < 16) {\n        if (nth < 16) {\n            header.push((type << 4) | nth);\n        }\n        else {\n            header.push(type << 4, nth);\n        }\n    }\n    else if (nth < 16) {\n        header.push(nth, type);\n    }\n    else {\n        header.push(0, type, nth);\n    }\n    return buffer_1.Buffer.from(header);\n}\nfunction buildField([name, info], typeOrdinal) {\n    const field = fieldHeader(typeOrdinal, info.nth);\n    return {\n        name: name,\n        nth: info.nth,\n        isVariableLengthEncoded: info.isVLEncoded,\n        isSerialized: info.isSerialized,\n        isSigningField: info.isSigningField,\n        ordinal: (typeOrdinal << 16) | info.nth,\n        type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),\n        header: field,\n        associatedType: serialized_type_1.SerializedType, // For later assignment in ./types/index.js or Definitions.updateAll(...)\n    };\n}\n/*\n * @brief: The collection of all fields as defined in definitions.json\n */\nclass FieldLookup {\n    constructor(fields, types) {\n        fields.forEach(([name, field_info]) => {\n            const typeOrdinal = types[field_info.type];\n            this[name] = buildField([name, field_info], typeOrdinal);\n            this[this[name].ordinal.toString()] = this[name];\n        });\n    }\n    fromString(value) {\n        return this[value];\n    }\n}\nexports.FieldLookup = FieldLookup;\n//# sourceMappingURL=field.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL2ZpZWxkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBUztBQUNqQywwQkFBMEIsbUJBQU8sQ0FBQyx3R0FBMEI7QUFDNUQsb0JBQW9CLG1CQUFPLENBQUMscUZBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL2ZpZWxkLmpzPzQxMTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpZWxkTG9va3VwID0gdm9pZCAwO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3Qgc2VyaWFsaXplZF90eXBlXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMvc2VyaWFsaXplZC10eXBlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLypcbiAqIEBicmllZjogU2VyaWFsaXplIGEgZmllbGQgYmFzZWQgb24gdHlwZV9jb2RlIGFuZCBGaWVsZC5udGhcbiAqL1xuZnVuY3Rpb24gZmllbGRIZWFkZXIodHlwZSwgbnRoKSB7XG4gICAgY29uc3QgaGVhZGVyID0gW107XG4gICAgaWYgKHR5cGUgPCAxNikge1xuICAgICAgICBpZiAobnRoIDwgMTYpIHtcbiAgICAgICAgICAgIGhlYWRlci5wdXNoKCh0eXBlIDw8IDQpIHwgbnRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlci5wdXNoKHR5cGUgPDwgNCwgbnRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChudGggPCAxNikge1xuICAgICAgICBoZWFkZXIucHVzaChudGgsIHR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVhZGVyLnB1c2goMCwgdHlwZSwgbnRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGhlYWRlcik7XG59XG5mdW5jdGlvbiBidWlsZEZpZWxkKFtuYW1lLCBpbmZvXSwgdHlwZU9yZGluYWwpIHtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkSGVhZGVyKHR5cGVPcmRpbmFsLCBpbmZvLm50aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgbnRoOiBpbmZvLm50aCxcbiAgICAgICAgaXNWYXJpYWJsZUxlbmd0aEVuY29kZWQ6IGluZm8uaXNWTEVuY29kZWQsXG4gICAgICAgIGlzU2VyaWFsaXplZDogaW5mby5pc1NlcmlhbGl6ZWQsXG4gICAgICAgIGlzU2lnbmluZ0ZpZWxkOiBpbmZvLmlzU2lnbmluZ0ZpZWxkLFxuICAgICAgICBvcmRpbmFsOiAodHlwZU9yZGluYWwgPDwgMTYpIHwgaW5mby5udGgsXG4gICAgICAgIHR5cGU6IG5ldyBieXRlc18xLkJ5dGVzKGluZm8udHlwZSwgdHlwZU9yZGluYWwsIGNvbnN0YW50c18xLlRZUEVfV0lEVEgpLFxuICAgICAgICBoZWFkZXI6IGZpZWxkLFxuICAgICAgICBhc3NvY2lhdGVkVHlwZTogc2VyaWFsaXplZF90eXBlXzEuU2VyaWFsaXplZFR5cGUsIC8vIEZvciBsYXRlciBhc3NpZ25tZW50IGluIC4vdHlwZXMvaW5kZXguanMgb3IgRGVmaW5pdGlvbnMudXBkYXRlQWxsKC4uLilcbiAgICB9O1xufVxuLypcbiAqIEBicmllZjogVGhlIGNvbGxlY3Rpb24gb2YgYWxsIGZpZWxkcyBhcyBkZWZpbmVkIGluIGRlZmluaXRpb25zLmpzb25cbiAqL1xuY2xhc3MgRmllbGRMb29rdXAge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgdHlwZXMpIHtcbiAgICAgICAgZmllbGRzLmZvckVhY2goKFtuYW1lLCBmaWVsZF9pbmZvXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZU9yZGluYWwgPSB0eXBlc1tmaWVsZF9pbmZvLnR5cGVdO1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGJ1aWxkRmllbGQoW25hbWUsIGZpZWxkX2luZm9dLCB0eXBlT3JkaW5hbCk7XG4gICAgICAgICAgICB0aGlzW3RoaXNbbmFtZV0ub3JkaW5hbC50b1N0cmluZygpXSA9IHRoaXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3ZhbHVlXTtcbiAgICB9XG59XG5leHBvcnRzLkZpZWxkTG9va3VwID0gRmllbGRMb29rdXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWVsZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/enums/field.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/enums/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/enums/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TRANSACTION_TYPES = exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.Bytes = void 0;\nconst enums = __importStar(__webpack_require__(/*! ./definitions.json */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/definitions.json\"));\nconst xrpl_definitions_base_1 = __webpack_require__(/*! ./xrpl-definitions-base */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js\");\nObject.defineProperty(exports, \"XrplDefinitionsBase\", ({ enumerable: true, get: function () { return xrpl_definitions_base_1.XrplDefinitionsBase; } }));\nObject.defineProperty(exports, \"Bytes\", ({ enumerable: true, get: function () { return xrpl_definitions_base_1.Bytes; } }));\n/**\n * By default, coreTypes from the `types` folder is where known type definitions are initialized to avoid import cycles.\n */\nconst DEFAULT_DEFINITIONS = new xrpl_definitions_base_1.XrplDefinitionsBase(enums, {});\nexports.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;\nconst Type = DEFAULT_DEFINITIONS.type;\nexports.Type = Type;\nconst LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;\nexports.LedgerEntryType = LedgerEntryType;\nconst TransactionType = DEFAULT_DEFINITIONS.transactionType;\nexports.TransactionType = TransactionType;\nconst TransactionResult = DEFAULT_DEFINITIONS.transactionResult;\nexports.TransactionResult = TransactionResult;\nconst Field = DEFAULT_DEFINITIONS.field;\nexports.Field = Field;\n/*\n * @brief: All valid transaction types\n */\nconst TRANSACTION_TYPES = DEFAULT_DEFINITIONS.transactionNames;\nexports.TRANSACTION_TYPES = TRANSACTION_TYPES;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUIsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLGFBQWE7QUFDcE4sMkJBQTJCLG1CQUFPLENBQUMsZ0dBQW9CO0FBQ3ZELGdDQUFnQyxtQkFBTyxDQUFDLDZHQUF5QjtBQUNqRSx1REFBc0QsRUFBRSxxQ0FBcUMsdURBQXVELEVBQUM7QUFDckoseUNBQXdDLEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRiwyQkFBMkI7QUFDM0I7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvZW51bXMvaW5kZXguanM/NzQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UUkFOU0FDVElPTl9UWVBFUyA9IGV4cG9ydHMuVHJhbnNhY3Rpb25UeXBlID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlc3VsdCA9IGV4cG9ydHMuTGVkZ2VyRW50cnlUeXBlID0gZXhwb3J0cy5UeXBlID0gZXhwb3J0cy5GaWVsZCA9IGV4cG9ydHMuREVGQVVMVF9ERUZJTklUSU9OUyA9IGV4cG9ydHMuWHJwbERlZmluaXRpb25zQmFzZSA9IGV4cG9ydHMuQnl0ZXMgPSB2b2lkIDA7XG5jb25zdCBlbnVtcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9kZWZpbml0aW9ucy5qc29uXCIpKTtcbmNvbnN0IHhycGxfZGVmaW5pdGlvbnNfYmFzZV8xID0gcmVxdWlyZShcIi4veHJwbC1kZWZpbml0aW9ucy1iYXNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWHJwbERlZmluaXRpb25zQmFzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwbF9kZWZpbml0aW9uc19iYXNlXzEuWHJwbERlZmluaXRpb25zQmFzZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBsX2RlZmluaXRpb25zX2Jhc2VfMS5CeXRlczsgfSB9KTtcbi8qKlxuICogQnkgZGVmYXVsdCwgY29yZVR5cGVzIGZyb20gdGhlIGB0eXBlc2AgZm9sZGVyIGlzIHdoZXJlIGtub3duIHR5cGUgZGVmaW5pdGlvbnMgYXJlIGluaXRpYWxpemVkIHRvIGF2b2lkIGltcG9ydCBjeWNsZXMuXG4gKi9cbmNvbnN0IERFRkFVTFRfREVGSU5JVElPTlMgPSBuZXcgeHJwbF9kZWZpbml0aW9uc19iYXNlXzEuWHJwbERlZmluaXRpb25zQmFzZShlbnVtcywge30pO1xuZXhwb3J0cy5ERUZBVUxUX0RFRklOSVRJT05TID0gREVGQVVMVF9ERUZJTklUSU9OUztcbmNvbnN0IFR5cGUgPSBERUZBVUxUX0RFRklOSVRJT05TLnR5cGU7XG5leHBvcnRzLlR5cGUgPSBUeXBlO1xuY29uc3QgTGVkZ2VyRW50cnlUeXBlID0gREVGQVVMVF9ERUZJTklUSU9OUy5sZWRnZXJFbnRyeVR5cGU7XG5leHBvcnRzLkxlZGdlckVudHJ5VHlwZSA9IExlZGdlckVudHJ5VHlwZTtcbmNvbnN0IFRyYW5zYWN0aW9uVHlwZSA9IERFRkFVTFRfREVGSU5JVElPTlMudHJhbnNhY3Rpb25UeXBlO1xuZXhwb3J0cy5UcmFuc2FjdGlvblR5cGUgPSBUcmFuc2FjdGlvblR5cGU7XG5jb25zdCBUcmFuc2FjdGlvblJlc3VsdCA9IERFRkFVTFRfREVGSU5JVElPTlMudHJhbnNhY3Rpb25SZXN1bHQ7XG5leHBvcnRzLlRyYW5zYWN0aW9uUmVzdWx0ID0gVHJhbnNhY3Rpb25SZXN1bHQ7XG5jb25zdCBGaWVsZCA9IERFRkFVTFRfREVGSU5JVElPTlMuZmllbGQ7XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG4vKlxuICogQGJyaWVmOiBBbGwgdmFsaWQgdHJhbnNhY3Rpb24gdHlwZXNcbiAqL1xuY29uc3QgVFJBTlNBQ1RJT05fVFlQRVMgPSBERUZBVUxUX0RFRklOSVRJT05TLnRyYW5zYWN0aW9uTmFtZXM7XG5leHBvcnRzLlRSQU5TQUNUSU9OX1RZUEVTID0gVFJBTlNBQ1RJT05fVFlQRVM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/enums/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BytesLookup = exports.Bytes = exports.FieldLookup = exports.XrplDefinitionsBase = void 0;\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/bytes.js\");\nObject.defineProperty(exports, \"Bytes\", ({ enumerable: true, get: function () { return bytes_1.Bytes; } }));\nObject.defineProperty(exports, \"BytesLookup\", ({ enumerable: true, get: function () { return bytes_1.BytesLookup; } }));\nconst field_1 = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/field.js\");\nObject.defineProperty(exports, \"FieldLookup\", ({ enumerable: true, get: function () { return field_1.FieldLookup; } }));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/constants.js\");\n/**\n * Stores the various types and fields for rippled to be used to encode/decode information later on.\n * XrplDefinitions should be instantiated instead of this class.\n */\nclass XrplDefinitionsBase {\n    /**\n     * Present rippled types in a typed and updatable format.\n     * For an example of the input format see `definitions.json`\n     * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen\n     *\n     * See the definitions.test.js file for examples of how to create your own updated definitions.json.\n     *\n     * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.\n     * @param types - A list of type objects with the same name as the fields defined.\n     *              You can use the coreTypes object if you are not adding new types.\n     */\n    constructor(enums, types) {\n        this.type = new bytes_1.BytesLookup(enums.TYPES, constants_1.TYPE_WIDTH);\n        this.ledgerEntryType = new bytes_1.BytesLookup(enums.LEDGER_ENTRY_TYPES, constants_1.LEDGER_ENTRY_WIDTH);\n        this.transactionType = new bytes_1.BytesLookup(enums.TRANSACTION_TYPES, constants_1.TRANSACTION_TYPE_WIDTH);\n        this.transactionResult = new bytes_1.BytesLookup(enums.TRANSACTION_RESULTS, constants_1.TRANSACTION_RESULT_WIDTH);\n        this.field = new field_1.FieldLookup(enums.FIELDS, enums.TYPES);\n        this.transactionNames = Object.entries(enums.TRANSACTION_TYPES)\n            .filter(([_key, value]) => value >= 0)\n            .map(([key, _value]) => key);\n        this.dataTypes = {}; // Filled in via associateTypes\n        this.associateTypes(types);\n    }\n    /**\n     * Associates each Field to a corresponding class that TypeScript can recognize.\n     *\n     * @param types a list of type objects with the same name as the fields defined.\n     *              Defaults to xrpl.js's core type definitions.\n     */\n    associateTypes(types) {\n        // Overwrite any existing type definitions with the given types\n        this.dataTypes = Object.assign({}, this.dataTypes, types);\n        Object.values(this.field).forEach((field) => {\n            field.associatedType = this.dataTypes[field.type.name];\n        });\n        this.field['TransactionType'].associatedType = this.transactionType;\n        this.field['TransactionResult'].associatedType = this.transactionResult;\n        this.field['LedgerEntryType'].associatedType = this.ledgerEntryType;\n    }\n    getAssociatedTypes() {\n        return this.dataTypes;\n    }\n}\nexports.XrplDefinitionsBase = XrplDefinitionsBase;\n//# sourceMappingURL=xrpl-definitions-base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL3hycGwtZGVmaW5pdGlvbnMtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxhQUFhLEdBQUcsbUJBQW1CLEdBQUcsMkJBQTJCO0FBQ3ZGLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFTO0FBQ2pDLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RywrQ0FBOEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDckgsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVM7QUFDakMsK0NBQThDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ3JILG9CQUFvQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC9lbnVtcy94cnBsLWRlZmluaXRpb25zLWJhc2UuanM/NjA1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnl0ZXNMb29rdXAgPSBleHBvcnRzLkJ5dGVzID0gZXhwb3J0cy5GaWVsZExvb2t1cCA9IGV4cG9ydHMuWHJwbERlZmluaXRpb25zQmFzZSA9IHZvaWQgMDtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlc18xLkJ5dGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnl0ZXNMb29rdXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzXzEuQnl0ZXNMb29rdXA7IH0gfSk7XG5jb25zdCBmaWVsZF8xID0gcmVxdWlyZShcIi4vZmllbGRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaWVsZExvb2t1cFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmllbGRfMS5GaWVsZExvb2t1cDsgfSB9KTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBTdG9yZXMgdGhlIHZhcmlvdXMgdHlwZXMgYW5kIGZpZWxkcyBmb3IgcmlwcGxlZCB0byBiZSB1c2VkIHRvIGVuY29kZS9kZWNvZGUgaW5mb3JtYXRpb24gbGF0ZXIgb24uXG4gKiBYcnBsRGVmaW5pdGlvbnMgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCBpbnN0ZWFkIG9mIHRoaXMgY2xhc3MuXG4gKi9cbmNsYXNzIFhycGxEZWZpbml0aW9uc0Jhc2Uge1xuICAgIC8qKlxuICAgICAqIFByZXNlbnQgcmlwcGxlZCB0eXBlcyBpbiBhIHR5cGVkIGFuZCB1cGRhdGFibGUgZm9ybWF0LlxuICAgICAqIEZvciBhbiBleGFtcGxlIG9mIHRoZSBpbnB1dCBmb3JtYXQgc2VlIGBkZWZpbml0aW9ucy5qc29uYFxuICAgICAqIFRvIGdlbmVyYXRlIGEgbmV3IGRlZmluaXRpb25zIGZpbGUgZnJvbSByaXBwbGVkIHNvdXJjZSBjb2RlLCB1c2UgdGhpcyB0b29sOiBodHRwczovL2dpdGh1Yi5jb20vUmljaGFyZEFIL3hycGwtY29kZWMtZ2VuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIGRlZmluaXRpb25zLnRlc3QuanMgZmlsZSBmb3IgZXhhbXBsZXMgb2YgaG93IHRvIGNyZWF0ZSB5b3VyIG93biB1cGRhdGVkIGRlZmluaXRpb25zLmpzb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW51bXMgLSBBIGpzb24gZW5jb2Rpbmcgb2YgdGhlIGNvcmUgdHlwZXMsIHRyYW5zYWN0aW9uIHR5cGVzLCB0cmFuc2FjdGlvbiByZXN1bHRzLCB0cmFuc2FjdGlvbiBuYW1lcywgYW5kIGZpZWxkcy5cbiAgICAgKiBAcGFyYW0gdHlwZXMgLSBBIGxpc3Qgb2YgdHlwZSBvYmplY3RzIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZmllbGRzIGRlZmluZWQuXG4gICAgICogICAgICAgICAgICAgIFlvdSBjYW4gdXNlIHRoZSBjb3JlVHlwZXMgb2JqZWN0IGlmIHlvdSBhcmUgbm90IGFkZGluZyBuZXcgdHlwZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW51bXMsIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IG5ldyBieXRlc18xLkJ5dGVzTG9va3VwKGVudW1zLlRZUEVTLCBjb25zdGFudHNfMS5UWVBFX1dJRFRIKTtcbiAgICAgICAgdGhpcy5sZWRnZXJFbnRyeVR5cGUgPSBuZXcgYnl0ZXNfMS5CeXRlc0xvb2t1cChlbnVtcy5MRURHRVJfRU5UUllfVFlQRVMsIGNvbnN0YW50c18xLkxFREdFUl9FTlRSWV9XSURUSCk7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25UeXBlID0gbmV3IGJ5dGVzXzEuQnl0ZXNMb29rdXAoZW51bXMuVFJBTlNBQ1RJT05fVFlQRVMsIGNvbnN0YW50c18xLlRSQU5TQUNUSU9OX1RZUEVfV0lEVEgpO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uUmVzdWx0ID0gbmV3IGJ5dGVzXzEuQnl0ZXNMb29rdXAoZW51bXMuVFJBTlNBQ1RJT05fUkVTVUxUUywgY29uc3RhbnRzXzEuVFJBTlNBQ1RJT05fUkVTVUxUX1dJRFRIKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IG5ldyBmaWVsZF8xLkZpZWxkTG9va3VwKGVudW1zLkZJRUxEUywgZW51bXMuVFlQRVMpO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uTmFtZXMgPSBPYmplY3QuZW50cmllcyhlbnVtcy5UUkFOU0FDVElPTl9UWVBFUylcbiAgICAgICAgICAgIC5maWx0ZXIoKFtfa2V5LCB2YWx1ZV0pID0+IHZhbHVlID49IDApXG4gICAgICAgICAgICAubWFwKChba2V5LCBfdmFsdWVdKSA9PiBrZXkpO1xuICAgICAgICB0aGlzLmRhdGFUeXBlcyA9IHt9OyAvLyBGaWxsZWQgaW4gdmlhIGFzc29jaWF0ZVR5cGVzXG4gICAgICAgIHRoaXMuYXNzb2NpYXRlVHlwZXModHlwZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVzIGVhY2ggRmllbGQgdG8gYSBjb3JyZXNwb25kaW5nIGNsYXNzIHRoYXQgVHlwZVNjcmlwdCBjYW4gcmVjb2duaXplLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVzIGEgbGlzdCBvZiB0eXBlIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBmaWVsZHMgZGVmaW5lZC5cbiAgICAgKiAgICAgICAgICAgICAgRGVmYXVsdHMgdG8geHJwbC5qcydzIGNvcmUgdHlwZSBkZWZpbml0aW9ucy5cbiAgICAgKi9cbiAgICBhc3NvY2lhdGVUeXBlcyh0eXBlcykge1xuICAgICAgICAvLyBPdmVyd3JpdGUgYW55IGV4aXN0aW5nIHR5cGUgZGVmaW5pdGlvbnMgd2l0aCB0aGUgZ2l2ZW4gdHlwZXNcbiAgICAgICAgdGhpcy5kYXRhVHlwZXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRhdGFUeXBlcywgdHlwZXMpO1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuZmllbGQpLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBmaWVsZC5hc3NvY2lhdGVkVHlwZSA9IHRoaXMuZGF0YVR5cGVzW2ZpZWxkLnR5cGUubmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpZWxkWydUcmFuc2FjdGlvblR5cGUnXS5hc3NvY2lhdGVkVHlwZSA9IHRoaXMudHJhbnNhY3Rpb25UeXBlO1xuICAgICAgICB0aGlzLmZpZWxkWydUcmFuc2FjdGlvblJlc3VsdCddLmFzc29jaWF0ZWRUeXBlID0gdGhpcy50cmFuc2FjdGlvblJlc3VsdDtcbiAgICAgICAgdGhpcy5maWVsZFsnTGVkZ2VyRW50cnlUeXBlJ10uYXNzb2NpYXRlZFR5cGUgPSB0aGlzLmxlZGdlckVudHJ5VHlwZTtcbiAgICB9XG4gICAgZ2V0QXNzb2NpYXRlZFR5cGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVHlwZXM7XG4gICAgfVxufVxuZXhwb3J0cy5YcnBsRGVmaW5pdGlvbnNCYXNlID0gWHJwbERlZmluaXRpb25zQmFzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhycGwtZGVmaW5pdGlvbnMtYmFzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.XrplDefinitions = void 0;\nconst xrpl_definitions_base_1 = __webpack_require__(/*! ./xrpl-definitions-base */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/index.js\");\n/**\n * Stores the various types and fields for rippled to be used to encode/decode information later on.\n * Should be used instead of XrplDefinitionsBase since this defines default `types` for serializing/deserializing\n * ledger data.\n */\nclass XrplDefinitions extends xrpl_definitions_base_1.XrplDefinitionsBase {\n    /**\n     * Present rippled types in a typed and updatable format.\n     * For an example of the input format see `definitions.json`\n     * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen\n     *\n     * See the definitions.test.js file for examples of how to create your own updated definitions.json.\n     *\n     * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.\n     * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.\n     *              These types will be included in addition to the coreTypes used on mainnet.\n     */\n    constructor(enums, additionalTypes) {\n        const types = Object.assign({}, types_1.coreTypes, additionalTypes);\n        super(enums, types);\n    }\n}\nexports.XrplDefinitions = XrplDefinitions;\n//# sourceMappingURL=xrpl-definitions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL3hycGwtZGVmaW5pdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGdDQUFnQyxtQkFBTyxDQUFDLDZHQUF5QjtBQUNqRSxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2VudW1zL3hycGwtZGVmaW5pdGlvbnMuanM/ODYzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWHJwbERlZmluaXRpb25zID0gdm9pZCAwO1xuY29uc3QgeHJwbF9kZWZpbml0aW9uc19iYXNlXzEgPSByZXF1aXJlKFwiLi94cnBsLWRlZmluaXRpb25zLWJhc2VcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuLyoqXG4gKiBTdG9yZXMgdGhlIHZhcmlvdXMgdHlwZXMgYW5kIGZpZWxkcyBmb3IgcmlwcGxlZCB0byBiZSB1c2VkIHRvIGVuY29kZS9kZWNvZGUgaW5mb3JtYXRpb24gbGF0ZXIgb24uXG4gKiBTaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIFhycGxEZWZpbml0aW9uc0Jhc2Ugc2luY2UgdGhpcyBkZWZpbmVzIGRlZmF1bHQgYHR5cGVzYCBmb3Igc2VyaWFsaXppbmcvZGVzZXJpYWxpemluZ1xuICogbGVkZ2VyIGRhdGEuXG4gKi9cbmNsYXNzIFhycGxEZWZpbml0aW9ucyBleHRlbmRzIHhycGxfZGVmaW5pdGlvbnNfYmFzZV8xLlhycGxEZWZpbml0aW9uc0Jhc2Uge1xuICAgIC8qKlxuICAgICAqIFByZXNlbnQgcmlwcGxlZCB0eXBlcyBpbiBhIHR5cGVkIGFuZCB1cGRhdGFibGUgZm9ybWF0LlxuICAgICAqIEZvciBhbiBleGFtcGxlIG9mIHRoZSBpbnB1dCBmb3JtYXQgc2VlIGBkZWZpbml0aW9ucy5qc29uYFxuICAgICAqIFRvIGdlbmVyYXRlIGEgbmV3IGRlZmluaXRpb25zIGZpbGUgZnJvbSByaXBwbGVkIHNvdXJjZSBjb2RlLCB1c2UgdGhpcyB0b29sOiBodHRwczovL2dpdGh1Yi5jb20vUmljaGFyZEFIL3hycGwtY29kZWMtZ2VuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIGRlZmluaXRpb25zLnRlc3QuanMgZmlsZSBmb3IgZXhhbXBsZXMgb2YgaG93IHRvIGNyZWF0ZSB5b3VyIG93biB1cGRhdGVkIGRlZmluaXRpb25zLmpzb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW51bXMgLSBBIGpzb24gZW5jb2Rpbmcgb2YgdGhlIGNvcmUgdHlwZXMsIHRyYW5zYWN0aW9uIHR5cGVzLCB0cmFuc2FjdGlvbiByZXN1bHRzLCB0cmFuc2FjdGlvbiBuYW1lcywgYW5kIGZpZWxkcy5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbFR5cGVzIC0gQSBsaXN0IG9mIFNlcmlhbGl6ZWRUeXBlIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBmaWVsZHMgZGVmaW5lZC5cbiAgICAgKiAgICAgICAgICAgICAgVGhlc2UgdHlwZXMgd2lsbCBiZSBpbmNsdWRlZCBpbiBhZGRpdGlvbiB0byB0aGUgY29yZVR5cGVzIHVzZWQgb24gbWFpbm5ldC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbnVtcywgYWRkaXRpb25hbFR5cGVzKSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZXNfMS5jb3JlVHlwZXMsIGFkZGl0aW9uYWxUeXBlcyk7XG4gICAgICAgIHN1cGVyKGVudW1zLCB0eXBlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5YcnBsRGVmaW5pdGlvbnMgPSBYcnBsRGVmaW5pdGlvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14cnBsLWRlZmluaXRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/hash-prefixes.js":
/*!****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/hash-prefixes.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HashPrefix = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Write a 32 bit integer to a Buffer\n *\n * @param uint32 32 bit integer to write to buffer\n * @returns a buffer with the bytes representation of uint32\n */\nfunction bytes(uint32) {\n    const result = buffer_1.Buffer.alloc(4);\n    result.writeUInt32BE(uint32, 0);\n    return result;\n}\n/**\n * Maps HashPrefix names to their byte representation\n */\nconst HashPrefix = {\n    transactionID: bytes(0x54584e00),\n    // transaction plus metadata\n    transaction: bytes(0x534e4400),\n    // account state\n    accountStateEntry: bytes(0x4d4c4e00),\n    // inner node in tree\n    innerNode: bytes(0x4d494e00),\n    // ledger master data for signing\n    ledgerHeader: bytes(0x4c575200),\n    // inner transaction to sign\n    transactionSig: bytes(0x53545800),\n    // inner transaction to sign\n    transactionMultiSig: bytes(0x534d5400),\n    // validation for signing\n    validation: bytes(0x56414c00),\n    // proposal for signing\n    proposal: bytes(0x50525000),\n    // payment channel claim\n    paymentChannelClaim: bytes(0x434c4d00),\n};\nexports.HashPrefix = HashPrefix;\n//# sourceMappingURL=hash-prefixes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2hhc2gtcHJlZml4ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvaGFzaC1wcmVmaXhlcy5qcz80ZTY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IYXNoUHJlZml4ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogV3JpdGUgYSAzMiBiaXQgaW50ZWdlciB0byBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB1aW50MzIgMzIgYml0IGludGVnZXIgdG8gd3JpdGUgdG8gYnVmZmVyXG4gKiBAcmV0dXJucyBhIGJ1ZmZlciB3aXRoIHRoZSBieXRlcyByZXByZXNlbnRhdGlvbiBvZiB1aW50MzJcbiAqL1xuZnVuY3Rpb24gYnl0ZXModWludDMyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDQpO1xuICAgIHJlc3VsdC53cml0ZVVJbnQzMkJFKHVpbnQzMiwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogTWFwcyBIYXNoUHJlZml4IG5hbWVzIHRvIHRoZWlyIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAqL1xuY29uc3QgSGFzaFByZWZpeCA9IHtcbiAgICB0cmFuc2FjdGlvbklEOiBieXRlcygweDU0NTg0ZTAwKSxcbiAgICAvLyB0cmFuc2FjdGlvbiBwbHVzIG1ldGFkYXRhXG4gICAgdHJhbnNhY3Rpb246IGJ5dGVzKDB4NTM0ZTQ0MDApLFxuICAgIC8vIGFjY291bnQgc3RhdGVcbiAgICBhY2NvdW50U3RhdGVFbnRyeTogYnl0ZXMoMHg0ZDRjNGUwMCksXG4gICAgLy8gaW5uZXIgbm9kZSBpbiB0cmVlXG4gICAgaW5uZXJOb2RlOiBieXRlcygweDRkNDk0ZTAwKSxcbiAgICAvLyBsZWRnZXIgbWFzdGVyIGRhdGEgZm9yIHNpZ25pbmdcbiAgICBsZWRnZXJIZWFkZXI6IGJ5dGVzKDB4NGM1NzUyMDApLFxuICAgIC8vIGlubmVyIHRyYW5zYWN0aW9uIHRvIHNpZ25cbiAgICB0cmFuc2FjdGlvblNpZzogYnl0ZXMoMHg1MzU0NTgwMCksXG4gICAgLy8gaW5uZXIgdHJhbnNhY3Rpb24gdG8gc2lnblxuICAgIHRyYW5zYWN0aW9uTXVsdGlTaWc6IGJ5dGVzKDB4NTM0ZDU0MDApLFxuICAgIC8vIHZhbGlkYXRpb24gZm9yIHNpZ25pbmdcbiAgICB2YWxpZGF0aW9uOiBieXRlcygweDU2NDE0YzAwKSxcbiAgICAvLyBwcm9wb3NhbCBmb3Igc2lnbmluZ1xuICAgIHByb3Bvc2FsOiBieXRlcygweDUwNTI1MDAwKSxcbiAgICAvLyBwYXltZW50IGNoYW5uZWwgY2xhaW1cbiAgICBwYXltZW50Q2hhbm5lbENsYWltOiBieXRlcygweDQzNGM0ZDAwKSxcbn07XG5leHBvcnRzLkhhc2hQcmVmaXggPSBIYXNoUHJlZml4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC1wcmVmaXhlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/hash-prefixes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/hashes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/hashes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;\nconst hash_prefixes_1 = __webpack_require__(/*! ./hash-prefixes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/hash-prefixes.js\");\nconst createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\");\nconst hash_256_1 = __webpack_require__(/*! ./types/hash-256 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-256.js\");\nconst binary_serializer_1 = __webpack_require__(/*! ./serdes/binary-serializer */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Class for hashing with SHA512\n * @extends BytesList So SerializedTypes can write bytes to a Sha512Half\n */\nclass Sha512Half extends binary_serializer_1.BytesList {\n    constructor() {\n        super(...arguments);\n        this.hash = createHash('sha512');\n    }\n    /**\n     * Construct a new Sha512Hash and write bytes this.hash\n     *\n     * @param bytes bytes to write to this.hash\n     * @returns the new Sha512Hash object\n     */\n    static put(bytes) {\n        return new Sha512Half().put(bytes);\n    }\n    /**\n     * Write bytes to an existing Sha512Hash\n     *\n     * @param bytes bytes to write to object\n     * @returns the Sha512 object\n     */\n    put(bytes) {\n        this.hash.update(bytes);\n        return this;\n    }\n    /**\n     * Compute SHA512 hash and slice in half\n     *\n     * @returns half of a SHA512 hash\n     */\n    finish256() {\n        return buffer_1.Buffer.from(this.hash.digest().slice(0, 32));\n    }\n    /**\n     * Constructs a Hash256 from the Sha512Half object\n     *\n     * @returns a Hash256 object\n     */\n    finish() {\n        return new hash_256_1.Hash256(this.finish256());\n    }\n}\nexports.Sha512Half = Sha512Half;\n/**\n * compute SHA512 hash of a list of bytes\n *\n * @param args zero or more arguments to hash\n * @returns the sha512half hash of the arguments.\n */\nfunction sha512Half(...args) {\n    const hash = new Sha512Half();\n    args.forEach((a) => hash.put(a));\n    return hash.finish256();\n}\nexports.sha512Half = sha512Half;\n/**\n * Construct a transactionID from a Serialized Transaction\n *\n * @param serialized bytes to hash\n * @returns a Hash256 object\n */\nfunction transactionID(serialized) {\n    return new hash_256_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));\n}\nexports.transactionID = transactionID;\n//# sourceMappingURL=hashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2hhc2hlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDL0Qsd0JBQXdCLG1CQUFPLENBQUMsdUZBQWlCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDhEQUFhO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFrQjtBQUM3Qyw0QkFBNEIsbUJBQU8sQ0FBQyw2R0FBNEI7QUFDaEUsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2hhc2hlcy5qcz80NTljIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50cmFuc2FjdGlvbklEID0gZXhwb3J0cy5zaGE1MTJIYWxmID0gZXhwb3J0cy5TaGE1MTJIYWxmID0gdm9pZCAwO1xuY29uc3QgaGFzaF9wcmVmaXhlc18xID0gcmVxdWlyZShcIi4vaGFzaC1wcmVmaXhlc1wiKTtcbmNvbnN0IGNyZWF0ZUhhc2ggPSByZXF1aXJlKFwiY3JlYXRlLWhhc2hcIik7XG5jb25zdCBoYXNoXzI1Nl8xID0gcmVxdWlyZShcIi4vdHlwZXMvaGFzaC0yNTZcIik7XG5jb25zdCBiaW5hcnlfc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyZGVzL2JpbmFyeS1zZXJpYWxpemVyXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogQ2xhc3MgZm9yIGhhc2hpbmcgd2l0aCBTSEE1MTJcbiAqIEBleHRlbmRzIEJ5dGVzTGlzdCBTbyBTZXJpYWxpemVkVHlwZXMgY2FuIHdyaXRlIGJ5dGVzIHRvIGEgU2hhNTEySGFsZlxuICovXG5jbGFzcyBTaGE1MTJIYWxmIGV4dGVuZHMgYmluYXJ5X3NlcmlhbGl6ZXJfMS5CeXRlc0xpc3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhc2ggPSBjcmVhdGVIYXNoKCdzaGE1MTInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IFNoYTUxMkhhc2ggYW5kIHdyaXRlIGJ5dGVzIHRoaXMuaGFzaFxuICAgICAqXG4gICAgICogQHBhcmFtIGJ5dGVzIGJ5dGVzIHRvIHdyaXRlIHRvIHRoaXMuaGFzaFxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgU2hhNTEySGFzaCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgcHV0KGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhNTEySGFsZigpLnB1dChieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGJ5dGVzIHRvIGFuIGV4aXN0aW5nIFNoYTUxMkhhc2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBieXRlcyB0byB3cml0ZSB0byBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgU2hhNTEyIG9iamVjdFxuICAgICAqL1xuICAgIHB1dChieXRlcykge1xuICAgICAgICB0aGlzLmhhc2gudXBkYXRlKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgU0hBNTEyIGhhc2ggYW5kIHNsaWNlIGluIGhhbGZcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGhhbGYgb2YgYSBTSEE1MTIgaGFzaFxuICAgICAqL1xuICAgIGZpbmlzaDI1NigpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHRoaXMuaGFzaC5kaWdlc3QoKS5zbGljZSgwLCAzMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgSGFzaDI1NiBmcm9tIHRoZSBTaGE1MTJIYWxmIG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBIYXNoMjU2IG9iamVjdFxuICAgICAqL1xuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBoYXNoXzI1Nl8xLkhhc2gyNTYodGhpcy5maW5pc2gyNTYoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaGE1MTJIYWxmID0gU2hhNTEySGFsZjtcbi8qKlxuICogY29tcHV0ZSBTSEE1MTIgaGFzaCBvZiBhIGxpc3Qgb2YgYnl0ZXNcbiAqXG4gKiBAcGFyYW0gYXJncyB6ZXJvIG9yIG1vcmUgYXJndW1lbnRzIHRvIGhhc2hcbiAqIEByZXR1cm5zIHRoZSBzaGE1MTJoYWxmIGhhc2ggb2YgdGhlIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2hhNTEySGFsZiguLi5hcmdzKSB7XG4gICAgY29uc3QgaGFzaCA9IG5ldyBTaGE1MTJIYWxmKCk7XG4gICAgYXJncy5mb3JFYWNoKChhKSA9PiBoYXNoLnB1dChhKSk7XG4gICAgcmV0dXJuIGhhc2guZmluaXNoMjU2KCk7XG59XG5leHBvcnRzLnNoYTUxMkhhbGYgPSBzaGE1MTJIYWxmO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbklEIGZyb20gYSBTZXJpYWxpemVkIFRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWQgYnl0ZXMgdG8gaGFzaFxuICogQHJldHVybnMgYSBIYXNoMjU2IG9iamVjdFxuICovXG5mdW5jdGlvbiB0cmFuc2FjdGlvbklEKHNlcmlhbGl6ZWQpIHtcbiAgICByZXR1cm4gbmV3IGhhc2hfMjU2XzEuSGFzaDI1NihzaGE1MTJIYWxmKGhhc2hfcHJlZml4ZXNfMS5IYXNoUHJlZml4LnRyYW5zYWN0aW9uSUQsIHNlcmlhbGl6ZWQpKTtcbn1cbmV4cG9ydHMudHJhbnNhY3Rpb25JRCA9IHRyYW5zYWN0aW9uSUQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/hashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;\nconst assert = __importStar(__webpack_require__(/*! assert */ \"assert\"));\nconst coretypes_1 = __webpack_require__(/*! ./coretypes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/coretypes.js\");\nconst ledger_hashes_1 = __webpack_require__(/*! ./ledger-hashes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/ledger-hashes.js\");\nObject.defineProperty(exports, \"decodeLedgerData\", ({ enumerable: true, get: function () { return ledger_hashes_1.decodeLedgerData; } }));\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/index.js\");\nObject.defineProperty(exports, \"XrplDefinitionsBase\", ({ enumerable: true, get: function () { return enums_1.XrplDefinitionsBase; } }));\nObject.defineProperty(exports, \"TRANSACTION_TYPES\", ({ enumerable: true, get: function () { return enums_1.TRANSACTION_TYPES; } }));\nObject.defineProperty(exports, \"DEFAULT_DEFINITIONS\", ({ enumerable: true, get: function () { return enums_1.DEFAULT_DEFINITIONS; } }));\nconst xrpl_definitions_1 = __webpack_require__(/*! ./enums/xrpl-definitions */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js\");\nObject.defineProperty(exports, \"XrplDefinitions\", ({ enumerable: true, get: function () { return xrpl_definitions_1.XrplDefinitions; } }));\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/index.js\");\nObject.defineProperty(exports, \"coreTypes\", ({ enumerable: true, get: function () { return types_1.coreTypes; } }));\nconst { signingData, signingClaimData, multiSigningData, binaryToJSON, serializeObject, } = coretypes_1.binary;\n/**\n * Decode a transaction\n *\n * @param binary hex-string of the encoded transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns the JSON representation of the transaction\n */\nfunction decode(binary, definitions) {\n    assert.ok(typeof binary === 'string', 'binary must be a hex string');\n    return binaryToJSON(binary, definitions);\n}\nexports.decode = decode;\n/**\n * Encode a transaction\n *\n * @param json The JSON representation of a transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n *\n * @returns A hex-string of the encoded transaction\n */\nfunction encode(json, definitions) {\n    assert.ok(typeof json === 'object');\n    return serializeObject(json, { definitions })\n        .toString('hex')\n        .toUpperCase();\n}\nexports.encode = encode;\n/**\n * Encode a transaction and prepare for signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForSigning(json, definitions) {\n    assert.ok(typeof json === 'object');\n    return signingData(json, coretypes_1.HashPrefix.transactionSig, {\n        definitions,\n    })\n        .toString('hex')\n        .toUpperCase();\n}\nexports.encodeForSigning = encodeForSigning;\n/**\n * Encode a transaction and prepare for signing with a claim\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForSigningClaim(json) {\n    assert.ok(typeof json === 'object');\n    return signingClaimData(json)\n        .toString('hex')\n        .toUpperCase();\n}\nexports.encodeForSigningClaim = encodeForSigningClaim;\n/**\n * Encode a transaction and prepare for multi-signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForMultisigning(json, signer, definitions) {\n    assert.ok(typeof json === 'object');\n    assert.equal(json['SigningPubKey'], '');\n    const definitionsOpt = definitions ? { definitions } : undefined;\n    return multiSigningData(json, signer, definitionsOpt)\n        .toString('hex')\n        .toUpperCase();\n}\nexports.encodeForMultisigning = encodeForMultisigning;\n/**\n * Encode a quality value\n *\n * @param value string representation of a number\n * @returns a hex-string representing the quality\n */\nfunction encodeQuality(value) {\n    assert.ok(typeof value === 'string');\n    return coretypes_1.quality.encode(value).toString('hex').toUpperCase();\n}\nexports.encodeQuality = encodeQuality;\n/**\n * Decode a quality value\n *\n * @param value hex-string of a quality\n * @returns a string representing the quality\n */\nfunction decodeQuality(value) {\n    assert.ok(typeof value === 'string');\n    return coretypes_1.quality.decode(value).toString();\n}\nexports.decodeQuality = decodeQuality;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyx3QkFBd0IsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUMzVSw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBYTtBQUN6Qyx3QkFBd0IsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDakQsb0RBQW1ELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3ZJLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFTO0FBQ2pDLHVEQUFzRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNySSxxREFBb0QsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDakksdURBQXNELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ3JJLDJCQUEyQixtQkFBTyxDQUFDLHlHQUEwQjtBQUM3RCxtREFBa0QsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDeEksZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVM7QUFDakMsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2pILFFBQVEsa0ZBQWtGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC9pbmRleC5qcz9lZTcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvcmVUeXBlcyA9IGV4cG9ydHMuREVGQVVMVF9ERUZJTklUSU9OUyA9IGV4cG9ydHMuWHJwbERlZmluaXRpb25zQmFzZSA9IGV4cG9ydHMuWHJwbERlZmluaXRpb25zID0gZXhwb3J0cy5UUkFOU0FDVElPTl9UWVBFUyA9IGV4cG9ydHMuZGVjb2RlTGVkZ2VyRGF0YSA9IGV4cG9ydHMuZGVjb2RlUXVhbGl0eSA9IGV4cG9ydHMuZW5jb2RlUXVhbGl0eSA9IGV4cG9ydHMuZW5jb2RlRm9yTXVsdGlzaWduaW5nID0gZXhwb3J0cy5lbmNvZGVGb3JTaWduaW5nQ2xhaW0gPSBleHBvcnRzLmVuY29kZUZvclNpZ25pbmcgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgY29yZXR5cGVzXzEgPSByZXF1aXJlKFwiLi9jb3JldHlwZXNcIik7XG5jb25zdCBsZWRnZXJfaGFzaGVzXzEgPSByZXF1aXJlKFwiLi9sZWRnZXItaGFzaGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlTGVkZ2VyRGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGVkZ2VyX2hhc2hlc18xLmRlY29kZUxlZGdlckRhdGE7IH0gfSk7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJYcnBsRGVmaW5pdGlvbnNCYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnVtc18xLlhycGxEZWZpbml0aW9uc0Jhc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUUkFOU0FDVElPTl9UWVBFU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW51bXNfMS5UUkFOU0FDVElPTl9UWVBFUzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRFRkFVTFRfREVGSU5JVElPTlNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuREVGQVVMVF9ERUZJTklUSU9OUzsgfSB9KTtcbmNvbnN0IHhycGxfZGVmaW5pdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2VudW1zL3hycGwtZGVmaW5pdGlvbnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJYcnBsRGVmaW5pdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycGxfZGVmaW5pdGlvbnNfMS5YcnBsRGVmaW5pdGlvbnM7IH0gfSk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3JlVHlwZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuY29yZVR5cGVzOyB9IH0pO1xuY29uc3QgeyBzaWduaW5nRGF0YSwgc2lnbmluZ0NsYWltRGF0YSwgbXVsdGlTaWduaW5nRGF0YSwgYmluYXJ5VG9KU09OLCBzZXJpYWxpemVPYmplY3QsIH0gPSBjb3JldHlwZXNfMS5iaW5hcnk7XG4vKipcbiAqIERlY29kZSBhIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIGJpbmFyeSBoZXgtc3RyaW5nIG9mIHRoZSBlbmNvZGVkIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gZGVmaW5pdGlvbnMgQ3VzdG9tIHJpcHBsZWQgdHlwZXMgdG8gdXNlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQuIFVzZWQgZm9yIHNpZGVjaGFpbnMgYW5kIGFtZW5kbWVudHMuXG4gKiBAcmV0dXJucyB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGJpbmFyeSwgZGVmaW5pdGlvbnMpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIGJpbmFyeSA9PT0gJ3N0cmluZycsICdiaW5hcnkgbXVzdCBiZSBhIGhleCBzdHJpbmcnKTtcbiAgICByZXR1cm4gYmluYXJ5VG9KU09OKGJpbmFyeSwgZGVmaW5pdGlvbnMpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIEVuY29kZSBhIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIGpzb24gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGRlZmluaXRpb25zIEN1c3RvbSByaXBwbGVkIHR5cGVzIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0LiBVc2VkIGZvciBzaWRlY2hhaW5zIGFuZCBhbWVuZG1lbnRzLlxuICpcbiAqIEByZXR1cm5zIEEgaGV4LXN0cmluZyBvZiB0aGUgZW5jb2RlZCB0cmFuc2FjdGlvblxuICovXG5mdW5jdGlvbiBlbmNvZGUoanNvbiwgZGVmaW5pdGlvbnMpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIGpzb24gPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KGpzb24sIHsgZGVmaW5pdGlvbnMgfSlcbiAgICAgICAgLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICAudG9VcHBlckNhc2UoKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLyoqXG4gKiBFbmNvZGUgYSB0cmFuc2FjdGlvbiBhbmQgcHJlcGFyZSBmb3Igc2lnbmluZ1xuICpcbiAqIEBwYXJhbSBqc29uIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBzaWduZXIgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYWNjb3VudCB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoXG4gKiBAcGFyYW0gZGVmaW5pdGlvbnMgQ3VzdG9tIHJpcHBsZWQgdHlwZXMgdG8gdXNlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQuIFVzZWQgZm9yIHNpZGVjaGFpbnMgYW5kIGFtZW5kbWVudHMuXG4gKiBAcmV0dXJucyBhIGhleCBzdHJpbmcgb2YgdGhlIGVuY29kZWQgdHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gZW5jb2RlRm9yU2lnbmluZyhqc29uLCBkZWZpbml0aW9ucykge1xuICAgIGFzc2VydC5vayh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcpO1xuICAgIHJldHVybiBzaWduaW5nRGF0YShqc29uLCBjb3JldHlwZXNfMS5IYXNoUHJlZml4LnRyYW5zYWN0aW9uU2lnLCB7XG4gICAgICAgIGRlZmluaXRpb25zLFxuICAgIH0pXG4gICAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG59XG5leHBvcnRzLmVuY29kZUZvclNpZ25pbmcgPSBlbmNvZGVGb3JTaWduaW5nO1xuLyoqXG4gKiBFbmNvZGUgYSB0cmFuc2FjdGlvbiBhbmQgcHJlcGFyZSBmb3Igc2lnbmluZyB3aXRoIGEgY2xhaW1cbiAqXG4gKiBAcGFyYW0ganNvbiBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gc2lnbmVyIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGFjY291bnQgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24gd2l0aFxuICogQHBhcmFtIGRlZmluaXRpb25zIEN1c3RvbSByaXBwbGVkIHR5cGVzIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0LiBVc2VkIGZvciBzaWRlY2hhaW5zIGFuZCBhbWVuZG1lbnRzLlxuICogQHJldHVybnMgYSBoZXggc3RyaW5nIG9mIHRoZSBlbmNvZGVkIHRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUZvclNpZ25pbmdDbGFpbShqc29uKSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiBqc29uID09PSAnb2JqZWN0Jyk7XG4gICAgcmV0dXJuIHNpZ25pbmdDbGFpbURhdGEoanNvbilcbiAgICAgICAgLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICAudG9VcHBlckNhc2UoKTtcbn1cbmV4cG9ydHMuZW5jb2RlRm9yU2lnbmluZ0NsYWltID0gZW5jb2RlRm9yU2lnbmluZ0NsYWltO1xuLyoqXG4gKiBFbmNvZGUgYSB0cmFuc2FjdGlvbiBhbmQgcHJlcGFyZSBmb3IgbXVsdGktc2lnbmluZ1xuICpcbiAqIEBwYXJhbSBqc29uIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBzaWduZXIgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYWNjb3VudCB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoXG4gKiBAcGFyYW0gZGVmaW5pdGlvbnMgQ3VzdG9tIHJpcHBsZWQgdHlwZXMgdG8gdXNlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQuIFVzZWQgZm9yIHNpZGVjaGFpbnMgYW5kIGFtZW5kbWVudHMuXG4gKiBAcmV0dXJucyBhIGhleCBzdHJpbmcgb2YgdGhlIGVuY29kZWQgdHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gZW5jb2RlRm9yTXVsdGlzaWduaW5nKGpzb24sIHNpZ25lciwgZGVmaW5pdGlvbnMpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIGpzb24gPT09ICdvYmplY3QnKTtcbiAgICBhc3NlcnQuZXF1YWwoanNvblsnU2lnbmluZ1B1YktleSddLCAnJyk7XG4gICAgY29uc3QgZGVmaW5pdGlvbnNPcHQgPSBkZWZpbml0aW9ucyA/IHsgZGVmaW5pdGlvbnMgfSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbXVsdGlTaWduaW5nRGF0YShqc29uLCBzaWduZXIsIGRlZmluaXRpb25zT3B0KVxuICAgICAgICAudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpO1xufVxuZXhwb3J0cy5lbmNvZGVGb3JNdWx0aXNpZ25pbmcgPSBlbmNvZGVGb3JNdWx0aXNpZ25pbmc7XG4vKipcbiAqIEVuY29kZSBhIHF1YWxpdHkgdmFsdWVcbiAqXG4gKiBAcGFyYW0gdmFsdWUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbnVtYmVyXG4gKiBAcmV0dXJucyBhIGhleC1zdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBxdWFsaXR5XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVF1YWxpdHkodmFsdWUpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XG4gICAgcmV0dXJuIGNvcmV0eXBlc18xLnF1YWxpdHkuZW5jb2RlKHZhbHVlKS50b1N0cmluZygnaGV4JykudG9VcHBlckNhc2UoKTtcbn1cbmV4cG9ydHMuZW5jb2RlUXVhbGl0eSA9IGVuY29kZVF1YWxpdHk7XG4vKipcbiAqIERlY29kZSBhIHF1YWxpdHkgdmFsdWVcbiAqXG4gKiBAcGFyYW0gdmFsdWUgaGV4LXN0cmluZyBvZiBhIHF1YWxpdHlcbiAqIEByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcXVhbGl0eVxuICovXG5mdW5jdGlvbiBkZWNvZGVRdWFsaXR5KHZhbHVlKSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpO1xuICAgIHJldHVybiBjb3JldHlwZXNfMS5xdWFsaXR5LmRlY29kZSh2YWx1ZSkudG9TdHJpbmcoKTtcbn1cbmV4cG9ydHMuZGVjb2RlUXVhbGl0eSA9IGRlY29kZVF1YWxpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/ledger-hashes.js":
/*!****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/ledger-hashes.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;\nconst assert = __importStar(__webpack_require__(/*! assert */ \"assert\"));\nconst shamap_1 = __webpack_require__(/*! ./shamap */ \"(ssr)/./node_modules/ripple-binary-codec/dist/shamap.js\");\nconst hash_prefixes_1 = __webpack_require__(/*! ./hash-prefixes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/hash-prefixes.js\");\nconst hashes_1 = __webpack_require__(/*! ./hashes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/hashes.js\");\nconst binary_1 = __webpack_require__(/*! ./binary */ \"(ssr)/./node_modules/ripple-binary-codec/dist/binary.js\");\nconst hash_256_1 = __webpack_require__(/*! ./types/hash-256 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-256.js\");\nconst st_object_1 = __webpack_require__(/*! ./types/st-object */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/st-object.js\");\nconst uint_64_1 = __webpack_require__(/*! ./types/uint-64 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-64.js\");\nconst uint_32_1 = __webpack_require__(/*! ./types/uint-32 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-32.js\");\nconst uint_8_1 = __webpack_require__(/*! ./types/uint-8 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-8.js\");\nconst binary_parser_1 = __webpack_require__(/*! ./serdes/binary-parser */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js\");\nconst bigInt = __webpack_require__(/*! big-integer */ \"(ssr)/./node_modules/ripple-binary-codec/node_modules/big-integer/BigInteger.js\");\n/**\n * Computes the hash of a list of objects\n *\n * @param itemizer Converts an item into a format that can be added to SHAMap\n * @param itemsJson Array of items to add to a SHAMap\n * @returns the hash of the SHAMap\n */\nfunction computeHash(itemizer, itemsJson) {\n    const map = new shamap_1.ShaMap();\n    itemsJson.forEach((item) => map.addItem(...itemizer(item)));\n    return map.hash();\n}\n/**\n * Convert a transaction into an index and an item\n *\n * @param json transaction with metadata\n * @returns a tuple of index and item to be added to SHAMap\n */\nfunction transactionItemizer(json) {\n    assert.ok(json.hash);\n    const index = hash_256_1.Hash256.from(json.hash);\n    const item = {\n        hashPrefix() {\n            return hash_prefixes_1.HashPrefix.transaction;\n        },\n        toBytesSink(sink) {\n            const serializer = new binary_1.BinarySerializer(sink);\n            serializer.writeLengthEncoded(st_object_1.STObject.from(json));\n            serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));\n        },\n    };\n    return [index, item, undefined];\n}\n/**\n * Convert an entry to a pair Hash256 and ShaMapNode\n *\n * @param json JSON describing a ledger entry item\n * @returns a tuple of index and item to be added to SHAMap\n */\nfunction entryItemizer(json) {\n    const index = hash_256_1.Hash256.from(json.index);\n    const bytes = (0, binary_1.serializeObject)(json);\n    const item = {\n        hashPrefix() {\n            return hash_prefixes_1.HashPrefix.accountStateEntry;\n        },\n        toBytesSink(sink) {\n            sink.put(bytes);\n        },\n    };\n    return [index, item, undefined];\n}\n/**\n * Function computing the hash of a transaction tree\n *\n * @param param An array of transaction objects to hash\n * @returns A Hash256 object\n */\nfunction transactionTreeHash(param) {\n    const itemizer = transactionItemizer;\n    return computeHash(itemizer, param);\n}\nexports.transactionTreeHash = transactionTreeHash;\n/**\n * Function computing the hash of accountState\n *\n * @param param A list of accountStates hash\n * @returns A Hash256 object\n */\nfunction accountStateHash(param) {\n    const itemizer = entryItemizer;\n    return computeHash(itemizer, param);\n}\nexports.accountStateHash = accountStateHash;\n/**\n * Serialize and hash a ledger header\n *\n * @param header a ledger header\n * @returns the hash of header\n */\nfunction ledgerHash(header) {\n    const hash = new hashes_1.Sha512Half();\n    hash.put(hash_prefixes_1.HashPrefix.ledgerHeader);\n    assert.ok(header.parent_close_time !== undefined);\n    assert.ok(header.close_flags !== undefined);\n    uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash);\n    uint_64_1.UInt64.from(bigInt(String(header.total_coins))).toBytesSink(hash);\n    hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash);\n    hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash);\n    hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash);\n    uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash);\n    uint_32_1.UInt32.from(header.close_time).toBytesSink(hash);\n    uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash);\n    uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash);\n    return hash.finish();\n}\nexports.ledgerHash = ledgerHash;\n/**\n * Decodes a serialized ledger header\n *\n * @param binary A serialized ledger header\n * @param definitions Type definitions to parse the ledger objects.\n *      Used if there are non-default ledger objects to decode.\n * @returns A JSON object describing a ledger header\n */\nfunction decodeLedgerData(binary, definitions) {\n    assert.ok(typeof binary === 'string', 'binary must be a hex string');\n    const parser = new binary_parser_1.BinaryParser(binary, definitions);\n    return {\n        ledger_index: parser.readUInt32(),\n        total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),\n        parent_hash: parser.readType(hash_256_1.Hash256).toHex(),\n        transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),\n        account_hash: parser.readType(hash_256_1.Hash256).toHex(),\n        parent_close_time: parser.readUInt32(),\n        close_time: parser.readUInt32(),\n        close_time_resolution: parser.readUInt8(),\n        close_flags: parser.readUInt8(),\n    };\n}\nexports.decodeLedgerData = decodeLedgerData;\n//# sourceMappingURL=ledger-hashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2xlZGdlci1oYXNoZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLGtCQUFrQixHQUFHLDJCQUEyQixHQUFHLHdCQUF3QjtBQUN0Ryw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBVTtBQUNuQyx3QkFBd0IsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMseUVBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMseUVBQVU7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMseUZBQWtCO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLDJGQUFtQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsdUZBQWlCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFnQjtBQUN6Qyx3QkFBd0IsbUJBQU8sQ0FBQyxxR0FBd0I7QUFDeEQsZUFBZSxtQkFBTyxDQUFDLG9HQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2xlZGdlci1oYXNoZXMuanM/ZGUwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVMZWRnZXJEYXRhID0gZXhwb3J0cy5sZWRnZXJIYXNoID0gZXhwb3J0cy50cmFuc2FjdGlvblRyZWVIYXNoID0gZXhwb3J0cy5hY2NvdW50U3RhdGVIYXNoID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3Qgc2hhbWFwXzEgPSByZXF1aXJlKFwiLi9zaGFtYXBcIik7XG5jb25zdCBoYXNoX3ByZWZpeGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoLXByZWZpeGVzXCIpO1xuY29uc3QgaGFzaGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoZXNcIik7XG5jb25zdCBiaW5hcnlfMSA9IHJlcXVpcmUoXCIuL2JpbmFyeVwiKTtcbmNvbnN0IGhhc2hfMjU2XzEgPSByZXF1aXJlKFwiLi90eXBlcy9oYXNoLTI1NlwiKTtcbmNvbnN0IHN0X29iamVjdF8xID0gcmVxdWlyZShcIi4vdHlwZXMvc3Qtb2JqZWN0XCIpO1xuY29uc3QgdWludF82NF8xID0gcmVxdWlyZShcIi4vdHlwZXMvdWludC02NFwiKTtcbmNvbnN0IHVpbnRfMzJfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3VpbnQtMzJcIik7XG5jb25zdCB1aW50XzhfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3VpbnQtOFwiKTtcbmNvbnN0IGJpbmFyeV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3NlcmRlcy9iaW5hcnktcGFyc2VyXCIpO1xuY29uc3QgYmlnSW50ID0gcmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgaGFzaCBvZiBhIGxpc3Qgb2Ygb2JqZWN0c1xuICpcbiAqIEBwYXJhbSBpdGVtaXplciBDb252ZXJ0cyBhbiBpdGVtIGludG8gYSBmb3JtYXQgdGhhdCBjYW4gYmUgYWRkZWQgdG8gU0hBTWFwXG4gKiBAcGFyYW0gaXRlbXNKc29uIEFycmF5IG9mIGl0ZW1zIHRvIGFkZCB0byBhIFNIQU1hcFxuICogQHJldHVybnMgdGhlIGhhc2ggb2YgdGhlIFNIQU1hcFxuICovXG5mdW5jdGlvbiBjb21wdXRlSGFzaChpdGVtaXplciwgaXRlbXNKc29uKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IHNoYW1hcF8xLlNoYU1hcCgpO1xuICAgIGl0ZW1zSnNvbi5mb3JFYWNoKChpdGVtKSA9PiBtYXAuYWRkSXRlbSguLi5pdGVtaXplcihpdGVtKSkpO1xuICAgIHJldHVybiBtYXAuaGFzaCgpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdHJhbnNhY3Rpb24gaW50byBhbiBpbmRleCBhbmQgYW4gaXRlbVxuICpcbiAqIEBwYXJhbSBqc29uIHRyYW5zYWN0aW9uIHdpdGggbWV0YWRhdGFcbiAqIEByZXR1cm5zIGEgdHVwbGUgb2YgaW5kZXggYW5kIGl0ZW0gdG8gYmUgYWRkZWQgdG8gU0hBTWFwXG4gKi9cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uSXRlbWl6ZXIoanNvbikge1xuICAgIGFzc2VydC5vayhqc29uLmhhc2gpO1xuICAgIGNvbnN0IGluZGV4ID0gaGFzaF8yNTZfMS5IYXNoMjU2LmZyb20oanNvbi5oYXNoKTtcbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICBoYXNoUHJlZml4KCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hfcHJlZml4ZXNfMS5IYXNoUHJlZml4LnRyYW5zYWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICB0b0J5dGVzU2luayhzaW5rKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3IGJpbmFyeV8xLkJpbmFyeVNlcmlhbGl6ZXIoc2luayk7XG4gICAgICAgICAgICBzZXJpYWxpemVyLndyaXRlTGVuZ3RoRW5jb2RlZChzdF9vYmplY3RfMS5TVE9iamVjdC5mcm9tKGpzb24pKTtcbiAgICAgICAgICAgIHNlcmlhbGl6ZXIud3JpdGVMZW5ndGhFbmNvZGVkKHN0X29iamVjdF8xLlNUT2JqZWN0LmZyb20oanNvbi5tZXRhRGF0YSkpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtpbmRleCwgaXRlbSwgdW5kZWZpbmVkXTtcbn1cbi8qKlxuICogQ29udmVydCBhbiBlbnRyeSB0byBhIHBhaXIgSGFzaDI1NiBhbmQgU2hhTWFwTm9kZVxuICpcbiAqIEBwYXJhbSBqc29uIEpTT04gZGVzY3JpYmluZyBhIGxlZGdlciBlbnRyeSBpdGVtXG4gKiBAcmV0dXJucyBhIHR1cGxlIG9mIGluZGV4IGFuZCBpdGVtIHRvIGJlIGFkZGVkIHRvIFNIQU1hcFxuICovXG5mdW5jdGlvbiBlbnRyeUl0ZW1pemVyKGpzb24pIHtcbiAgICBjb25zdCBpbmRleCA9IGhhc2hfMjU2XzEuSGFzaDI1Ni5mcm9tKGpzb24uaW5kZXgpO1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIGJpbmFyeV8xLnNlcmlhbGl6ZU9iamVjdCkoanNvbik7XG4gICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgaGFzaFByZWZpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNoX3ByZWZpeGVzXzEuSGFzaFByZWZpeC5hY2NvdW50U3RhdGVFbnRyeTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9CeXRlc1Npbmsoc2luaykge1xuICAgICAgICAgICAgc2luay5wdXQoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtpbmRleCwgaXRlbSwgdW5kZWZpbmVkXTtcbn1cbi8qKlxuICogRnVuY3Rpb24gY29tcHV0aW5nIHRoZSBoYXNoIG9mIGEgdHJhbnNhY3Rpb24gdHJlZVxuICpcbiAqIEBwYXJhbSBwYXJhbSBBbiBhcnJheSBvZiB0cmFuc2FjdGlvbiBvYmplY3RzIHRvIGhhc2hcbiAqIEByZXR1cm5zIEEgSGFzaDI1NiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gdHJhbnNhY3Rpb25UcmVlSGFzaChwYXJhbSkge1xuICAgIGNvbnN0IGl0ZW1pemVyID0gdHJhbnNhY3Rpb25JdGVtaXplcjtcbiAgICByZXR1cm4gY29tcHV0ZUhhc2goaXRlbWl6ZXIsIHBhcmFtKTtcbn1cbmV4cG9ydHMudHJhbnNhY3Rpb25UcmVlSGFzaCA9IHRyYW5zYWN0aW9uVHJlZUhhc2g7XG4vKipcbiAqIEZ1bmN0aW9uIGNvbXB1dGluZyB0aGUgaGFzaCBvZiBhY2NvdW50U3RhdGVcbiAqXG4gKiBAcGFyYW0gcGFyYW0gQSBsaXN0IG9mIGFjY291bnRTdGF0ZXMgaGFzaFxuICogQHJldHVybnMgQSBIYXNoMjU2IG9iamVjdFxuICovXG5mdW5jdGlvbiBhY2NvdW50U3RhdGVIYXNoKHBhcmFtKSB7XG4gICAgY29uc3QgaXRlbWl6ZXIgPSBlbnRyeUl0ZW1pemVyO1xuICAgIHJldHVybiBjb21wdXRlSGFzaChpdGVtaXplciwgcGFyYW0pO1xufVxuZXhwb3J0cy5hY2NvdW50U3RhdGVIYXNoID0gYWNjb3VudFN0YXRlSGFzaDtcbi8qKlxuICogU2VyaWFsaXplIGFuZCBoYXNoIGEgbGVkZ2VyIGhlYWRlclxuICpcbiAqIEBwYXJhbSBoZWFkZXIgYSBsZWRnZXIgaGVhZGVyXG4gKiBAcmV0dXJucyB0aGUgaGFzaCBvZiBoZWFkZXJcbiAqL1xuZnVuY3Rpb24gbGVkZ2VySGFzaChoZWFkZXIpIHtcbiAgICBjb25zdCBoYXNoID0gbmV3IGhhc2hlc18xLlNoYTUxMkhhbGYoKTtcbiAgICBoYXNoLnB1dChoYXNoX3ByZWZpeGVzXzEuSGFzaFByZWZpeC5sZWRnZXJIZWFkZXIpO1xuICAgIGFzc2VydC5vayhoZWFkZXIucGFyZW50X2Nsb3NlX3RpbWUgIT09IHVuZGVmaW5lZCk7XG4gICAgYXNzZXJ0Lm9rKGhlYWRlci5jbG9zZV9mbGFncyAhPT0gdW5kZWZpbmVkKTtcbiAgICB1aW50XzMyXzEuVUludDMyLmZyb20oaGVhZGVyLmxlZGdlcl9pbmRleCkudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgdWludF82NF8xLlVJbnQ2NC5mcm9tKGJpZ0ludChTdHJpbmcoaGVhZGVyLnRvdGFsX2NvaW5zKSkpLnRvQnl0ZXNTaW5rKGhhc2gpO1xuICAgIGhhc2hfMjU2XzEuSGFzaDI1Ni5mcm9tKGhlYWRlci5wYXJlbnRfaGFzaCkudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgaGFzaF8yNTZfMS5IYXNoMjU2LmZyb20oaGVhZGVyLnRyYW5zYWN0aW9uX2hhc2gpLnRvQnl0ZXNTaW5rKGhhc2gpO1xuICAgIGhhc2hfMjU2XzEuSGFzaDI1Ni5mcm9tKGhlYWRlci5hY2NvdW50X2hhc2gpLnRvQnl0ZXNTaW5rKGhhc2gpO1xuICAgIHVpbnRfMzJfMS5VSW50MzIuZnJvbShoZWFkZXIucGFyZW50X2Nsb3NlX3RpbWUpLnRvQnl0ZXNTaW5rKGhhc2gpO1xuICAgIHVpbnRfMzJfMS5VSW50MzIuZnJvbShoZWFkZXIuY2xvc2VfdGltZSkudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgdWludF84XzEuVUludDguZnJvbShoZWFkZXIuY2xvc2VfdGltZV9yZXNvbHV0aW9uKS50b0J5dGVzU2luayhoYXNoKTtcbiAgICB1aW50XzhfMS5VSW50OC5mcm9tKGhlYWRlci5jbG9zZV9mbGFncykudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgcmV0dXJuIGhhc2guZmluaXNoKCk7XG59XG5leHBvcnRzLmxlZGdlckhhc2ggPSBsZWRnZXJIYXNoO1xuLyoqXG4gKiBEZWNvZGVzIGEgc2VyaWFsaXplZCBsZWRnZXIgaGVhZGVyXG4gKlxuICogQHBhcmFtIGJpbmFyeSBBIHNlcmlhbGl6ZWQgbGVkZ2VyIGhlYWRlclxuICogQHBhcmFtIGRlZmluaXRpb25zIFR5cGUgZGVmaW5pdGlvbnMgdG8gcGFyc2UgdGhlIGxlZGdlciBvYmplY3RzLlxuICogICAgICBVc2VkIGlmIHRoZXJlIGFyZSBub24tZGVmYXVsdCBsZWRnZXIgb2JqZWN0cyB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyBBIEpTT04gb2JqZWN0IGRlc2NyaWJpbmcgYSBsZWRnZXIgaGVhZGVyXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUxlZGdlckRhdGEoYmluYXJ5LCBkZWZpbml0aW9ucykge1xuICAgIGFzc2VydC5vayh0eXBlb2YgYmluYXJ5ID09PSAnc3RyaW5nJywgJ2JpbmFyeSBtdXN0IGJlIGEgaGV4IHN0cmluZycpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBiaW5hcnlfcGFyc2VyXzEuQmluYXJ5UGFyc2VyKGJpbmFyeSwgZGVmaW5pdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZGdlcl9pbmRleDogcGFyc2VyLnJlYWRVSW50MzIoKSxcbiAgICAgICAgdG90YWxfY29pbnM6IHBhcnNlci5yZWFkVHlwZSh1aW50XzY0XzEuVUludDY0KS52YWx1ZU9mKCkudG9TdHJpbmcoKSxcbiAgICAgICAgcGFyZW50X2hhc2g6IHBhcnNlci5yZWFkVHlwZShoYXNoXzI1Nl8xLkhhc2gyNTYpLnRvSGV4KCksXG4gICAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IHBhcnNlci5yZWFkVHlwZShoYXNoXzI1Nl8xLkhhc2gyNTYpLnRvSGV4KCksXG4gICAgICAgIGFjY291bnRfaGFzaDogcGFyc2VyLnJlYWRUeXBlKGhhc2hfMjU2XzEuSGFzaDI1NikudG9IZXgoKSxcbiAgICAgICAgcGFyZW50X2Nsb3NlX3RpbWU6IHBhcnNlci5yZWFkVUludDMyKCksXG4gICAgICAgIGNsb3NlX3RpbWU6IHBhcnNlci5yZWFkVUludDMyKCksXG4gICAgICAgIGNsb3NlX3RpbWVfcmVzb2x1dGlvbjogcGFyc2VyLnJlYWRVSW50OCgpLFxuICAgICAgICBjbG9zZV9mbGFnczogcGFyc2VyLnJlYWRVSW50OCgpLFxuICAgIH07XG59XG5leHBvcnRzLmRlY29kZUxlZGdlckRhdGEgPSBkZWNvZGVMZWRnZXJEYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVkZ2VyLWhhc2hlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/ledger-hashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/quality.js":
/*!**********************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/quality.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.quality = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/index.js\");\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst bigInt = __webpack_require__(/*! big-integer */ \"(ssr)/./node_modules/ripple-binary-codec/node_modules/big-integer/BigInteger.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * class for encoding and decoding quality\n */\nclass quality {\n    /**\n     * Encode quality amount\n     *\n     * @param arg string representation of an amount\n     * @returns Serialized quality\n     */\n    static encode(quality) {\n        const decimal = new decimal_js_1.Decimal(quality);\n        const exponent = decimal.e - 15;\n        const qualityString = decimal.times(`1e${-exponent}`).abs().toString();\n        const bytes = types_1.coreTypes.UInt64.from(bigInt(qualityString)).toBytes();\n        bytes[0] = exponent + 100;\n        return bytes;\n    }\n    /**\n     * Decode quality amount\n     *\n     * @param arg hex-string denoting serialized quality\n     * @returns deserialized quality\n     */\n    static decode(quality) {\n        const bytes = buffer_1.Buffer.from(quality, 'hex').slice(-8);\n        const exponent = bytes[0] - 100;\n        const mantissa = new decimal_js_1.Decimal(`0x${bytes.slice(1).toString('hex')}`);\n        return mantissa.times(`1e${exponent}`);\n    }\n}\nexports.quality = quality;\n//# sourceMappingURL=quality.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3F1YWxpdHkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFTO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxvR0FBYTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELCtCQUErQjtBQUN0RixtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3F1YWxpdHkuanM/YzkxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucXVhbGl0eSA9IHZvaWQgMDtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3QgYmlnSW50ID0gcmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogY2xhc3MgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBxdWFsaXR5XG4gKi9cbmNsYXNzIHF1YWxpdHkge1xuICAgIC8qKlxuICAgICAqIEVuY29kZSBxdWFsaXR5IGFtb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gYW1vdW50XG4gICAgICogQHJldHVybnMgU2VyaWFsaXplZCBxdWFsaXR5XG4gICAgICovXG4gICAgc3RhdGljIGVuY29kZShxdWFsaXR5KSB7XG4gICAgICAgIGNvbnN0IGRlY2ltYWwgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwocXVhbGl0eSk7XG4gICAgICAgIGNvbnN0IGV4cG9uZW50ID0gZGVjaW1hbC5lIC0gMTU7XG4gICAgICAgIGNvbnN0IHF1YWxpdHlTdHJpbmcgPSBkZWNpbWFsLnRpbWVzKGAxZSR7LWV4cG9uZW50fWApLmFicygpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdHlwZXNfMS5jb3JlVHlwZXMuVUludDY0LmZyb20oYmlnSW50KHF1YWxpdHlTdHJpbmcpKS50b0J5dGVzKCk7XG4gICAgICAgIGJ5dGVzWzBdID0gZXhwb25lbnQgKyAxMDA7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIHF1YWxpdHkgYW1vdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIGhleC1zdHJpbmcgZGVub3Rpbmcgc2VyaWFsaXplZCBxdWFsaXR5XG4gICAgICogQHJldHVybnMgZGVzZXJpYWxpemVkIHF1YWxpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjb2RlKHF1YWxpdHkpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShxdWFsaXR5LCAnaGV4Jykuc2xpY2UoLTgpO1xuICAgICAgICBjb25zdCBleHBvbmVudCA9IGJ5dGVzWzBdIC0gMTAwO1xuICAgICAgICBjb25zdCBtYW50aXNzYSA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChgMHgke2J5dGVzLnNsaWNlKDEpLnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgICAgICAgcmV0dXJuIG1hbnRpc3NhLnRpbWVzKGAxZSR7ZXhwb25lbnR9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5xdWFsaXR5ID0gcXVhbGl0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1YWxpdHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/quality.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BinaryParser = void 0;\nconst assert = __importStar(__webpack_require__(/*! assert */ \"assert\"));\nconst enums_1 = __webpack_require__(/*! ../enums */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/index.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * BinaryParser is used to compute fields and values from a HexString\n */\nclass BinaryParser {\n    /**\n     * Initialize bytes to a hex string\n     *\n     * @param hexBytes a hex string\n     * @param definitions Rippled definitions used to parse the values of transaction types and such.\n     *                          Can be customized for sidechains and amendments.\n     */\n    constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS) {\n        this.bytes = buffer_1.Buffer.from(hexBytes, 'hex');\n        this.definitions = definitions;\n    }\n    /**\n     * Peek the first byte of the BinaryParser\n     *\n     * @returns The first byte of the BinaryParser\n     */\n    peek() {\n        assert.ok(this.bytes.byteLength !== 0);\n        return this.bytes[0];\n    }\n    /**\n     * Consume the first n bytes of the BinaryParser\n     *\n     * @param n the number of bytes to skip\n     */\n    skip(n) {\n        assert.ok(n <= this.bytes.byteLength);\n        this.bytes = this.bytes.slice(n);\n    }\n    /**\n     * read the first n bytes from the BinaryParser\n     *\n     * @param n The number of bytes to read\n     * @return The bytes\n     */\n    read(n) {\n        assert.ok(n <= this.bytes.byteLength);\n        const slice = this.bytes.slice(0, n);\n        this.skip(n);\n        return slice;\n    }\n    /**\n     * Read an integer of given size\n     *\n     * @param n The number of bytes to read\n     * @return The number represented by those bytes\n     */\n    readUIntN(n) {\n        assert.ok(0 < n && n <= 4, 'invalid n');\n        return this.read(n).reduce((a, b) => (a << 8) | b) >>> 0;\n    }\n    readUInt8() {\n        return this.readUIntN(1);\n    }\n    readUInt16() {\n        return this.readUIntN(2);\n    }\n    readUInt32() {\n        return this.readUIntN(4);\n    }\n    size() {\n        return this.bytes.byteLength;\n    }\n    end(customEnd) {\n        const length = this.bytes.byteLength;\n        return length === 0 || (customEnd !== undefined && length <= customEnd);\n    }\n    /**\n     * Reads variable length encoded bytes\n     *\n     * @return The variable length bytes\n     */\n    readVariableLength() {\n        return this.read(this.readVariableLengthLength());\n    }\n    /**\n     * Reads the length of the variable length encoded bytes\n     *\n     * @return The length of the variable length encoded bytes\n     */\n    readVariableLengthLength() {\n        const b1 = this.readUInt8();\n        if (b1 <= 192) {\n            return b1;\n        }\n        else if (b1 <= 240) {\n            const b2 = this.readUInt8();\n            return 193 + (b1 - 193) * 256 + b2;\n        }\n        else if (b1 <= 254) {\n            const b2 = this.readUInt8();\n            const b3 = this.readUInt8();\n            return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;\n        }\n        throw new Error('Invalid variable length indicator');\n    }\n    /**\n     * Reads the field ordinal from the BinaryParser\n     *\n     * @return Field ordinal\n     */\n    readFieldOrdinal() {\n        let type = this.readUInt8();\n        let nth = type & 15;\n        type >>= 4;\n        if (type === 0) {\n            type = this.readUInt8();\n            if (type === 0 || type < 16) {\n                throw new Error('Cannot read FieldOrdinal, type_code out of range');\n            }\n        }\n        if (nth === 0) {\n            nth = this.readUInt8();\n            if (nth === 0 || nth < 16) {\n                throw new Error('Cannot read FieldOrdinal, field_code out of range');\n            }\n        }\n        return (type << 16) | nth;\n    }\n    /**\n     * Read the field from the BinaryParser\n     *\n     * @return The field represented by the bytes at the head of the BinaryParser\n     */\n    readField() {\n        return this.definitions.field.fromString(this.readFieldOrdinal().toString());\n    }\n    /**\n     * Read a given type from the BinaryParser\n     *\n     * @param type The type that you want to read from the BinaryParser\n     * @return The instance of that type read from the BinaryParser\n     */\n    readType(type) {\n        return type.fromParser(this);\n    }\n    /**\n     * Get the type associated with a given field\n     *\n     * @param field The field that you wan to get the type of\n     * @return The type associated with the given field\n     */\n    typeForField(field) {\n        return field.associatedType;\n    }\n    /**\n     * Read value of the type specified by field from the BinaryParser\n     *\n     * @param field The field that you want to get the associated value for\n     * @return The value associated with the given field\n     */\n    readFieldValue(field) {\n        const type = this.typeForField(field);\n        if (!type) {\n            throw new Error(`unsupported: (${field.name}, ${field.type.name})`);\n        }\n        const sizeHint = field.isVariableLengthEncoded\n            ? this.readVariableLengthLength()\n            : undefined;\n        const value = type.fromParser(this, sizeHint);\n        if (value === undefined) {\n            throw new Error(`fromParser for (${field.name}, ${field.type.name}) -> undefined `);\n        }\n        return value;\n    }\n    /**\n     * Get the next field and value from the BinaryParser\n     *\n     * @return The field and value\n     */\n    readFieldAndValue() {\n        const field = this.readField();\n        return [field, this.readFieldValue(field)];\n    }\n}\nexports.BinaryParser = BinaryParser;\n//# sourceMappingURL=binary-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3NlcmRlcy9iaW5hcnktcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsNEJBQTRCLG1CQUFPLENBQUMsc0JBQVE7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVU7QUFDbEMsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXLElBQUksZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxXQUFXLElBQUksZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3NlcmRlcy9iaW5hcnktcGFyc2VyLmpzP2FjNmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmluYXJ5UGFyc2VyID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuLi9lbnVtc1wiKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG4vKipcbiAqIEJpbmFyeVBhcnNlciBpcyB1c2VkIHRvIGNvbXB1dGUgZmllbGRzIGFuZCB2YWx1ZXMgZnJvbSBhIEhleFN0cmluZ1xuICovXG5jbGFzcyBCaW5hcnlQYXJzZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYnl0ZXMgdG8gYSBoZXggc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGV4Qnl0ZXMgYSBoZXggc3RyaW5nXG4gICAgICogQHBhcmFtIGRlZmluaXRpb25zIFJpcHBsZWQgZGVmaW5pdGlvbnMgdXNlZCB0byBwYXJzZSB0aGUgdmFsdWVzIG9mIHRyYW5zYWN0aW9uIHR5cGVzIGFuZCBzdWNoLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgY3VzdG9taXplZCBmb3Igc2lkZWNoYWlucyBhbmQgYW1lbmRtZW50cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihoZXhCeXRlcywgZGVmaW5pdGlvbnMgPSBlbnVtc18xLkRFRkFVTFRfREVGSU5JVElPTlMpIHtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGhleEJ5dGVzLCAnaGV4Jyk7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVlayB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgYnl0ZSBvZiB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICovXG4gICAgcGVlaygpIHtcbiAgICAgICAgYXNzZXJ0Lm9rKHRoaXMuYnl0ZXMuYnl0ZUxlbmd0aCAhPT0gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdW1lIHRoZSBmaXJzdCBuIGJ5dGVzIG9mIHRoZSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gc2tpcFxuICAgICAqL1xuICAgIHNraXAobikge1xuICAgICAgICBhc3NlcnQub2sobiA8PSB0aGlzLmJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcy5zbGljZShuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVhZCB0aGUgZmlyc3QgbiBieXRlcyBmcm9tIHRoZSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZFxuICAgICAqIEByZXR1cm4gVGhlIGJ5dGVzXG4gICAgICovXG4gICAgcmVhZChuKSB7XG4gICAgICAgIGFzc2VydC5vayhuIDw9IHRoaXMuYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNsaWNlID0gdGhpcy5ieXRlcy5zbGljZSgwLCBuKTtcbiAgICAgICAgdGhpcy5za2lwKG4pO1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYW4gaW50ZWdlciBvZiBnaXZlbiBzaXplXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWRcbiAgICAgKiBAcmV0dXJuIFRoZSBudW1iZXIgcmVwcmVzZW50ZWQgYnkgdGhvc2UgYnl0ZXNcbiAgICAgKi9cbiAgICByZWFkVUludE4obikge1xuICAgICAgICBhc3NlcnQub2soMCA8IG4gJiYgbiA8PSA0LCAnaW52YWxpZCBuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWQobikucmVkdWNlKChhLCBiKSA9PiAoYSA8PCA4KSB8IGIpID4+PiAwO1xuICAgIH1cbiAgICByZWFkVUludDgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRVSW50TigxKTtcbiAgICB9XG4gICAgcmVhZFVJbnQxNigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVJbnROKDIpO1xuICAgIH1cbiAgICByZWFkVUludDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVUludE4oNCk7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGVuZChjdXN0b21FbmQpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5ieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoID09PSAwIHx8IChjdXN0b21FbmQgIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPD0gY3VzdG9tRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdmFyaWFibGUgbGVuZ3RoIGVuY29kZWQgYnl0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIHZhcmlhYmxlIGxlbmd0aCBieXRlc1xuICAgICAqL1xuICAgIHJlYWRWYXJpYWJsZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZCh0aGlzLnJlYWRWYXJpYWJsZUxlbmd0aExlbmd0aCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGxlbmd0aCBvZiB0aGUgdmFyaWFibGUgbGVuZ3RoIGVuY29kZWQgYnl0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIGxlbmd0aCBvZiB0aGUgdmFyaWFibGUgbGVuZ3RoIGVuY29kZWQgYnl0ZXNcbiAgICAgKi9cbiAgICByZWFkVmFyaWFibGVMZW5ndGhMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IGIxID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgaWYgKGIxIDw9IDE5Mikge1xuICAgICAgICAgICAgcmV0dXJuIGIxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIxIDw9IDI0MCkge1xuICAgICAgICAgICAgY29uc3QgYjIgPSB0aGlzLnJlYWRVSW50OCgpO1xuICAgICAgICAgICAgcmV0dXJuIDE5MyArIChiMSAtIDE5MykgKiAyNTYgKyBiMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiMSA8PSAyNTQpIHtcbiAgICAgICAgICAgIGNvbnN0IGIyID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgICAgIHJldHVybiAxMjQ4MSArIChiMSAtIDI0MSkgKiA2NTUzNiArIGIyICogMjU2ICsgYjM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhcmlhYmxlIGxlbmd0aCBpbmRpY2F0b3InKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGZpZWxkIG9yZGluYWwgZnJvbSB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEZpZWxkIG9yZGluYWxcbiAgICAgKi9cbiAgICByZWFkRmllbGRPcmRpbmFsKCkge1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMucmVhZFVJbnQ4KCk7XG4gICAgICAgIGxldCBudGggPSB0eXBlICYgMTU7XG4gICAgICAgIHR5cGUgPj49IDQ7XG4gICAgICAgIGlmICh0eXBlID09PSAwKSB7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAwIHx8IHR5cGUgPCAxNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgRmllbGRPcmRpbmFsLCB0eXBlX2NvZGUgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG50aCA9PT0gMCkge1xuICAgICAgICAgICAgbnRoID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgICAgIGlmIChudGggPT09IDAgfHwgbnRoIDwgMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIEZpZWxkT3JkaW5hbCwgZmllbGRfY29kZSBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHR5cGUgPDwgMTYpIHwgbnRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBmaWVsZCBmcm9tIHRoZSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIGZpZWxkIHJlcHJlc2VudGVkIGJ5IHRoZSBieXRlcyBhdCB0aGUgaGVhZCBvZiB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICovXG4gICAgcmVhZEZpZWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9ucy5maWVsZC5mcm9tU3RyaW5nKHRoaXMucmVhZEZpZWxkT3JkaW5hbCgpLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgZ2l2ZW4gdHlwZSBmcm9tIHRoZSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIHRoYXQgeW91IHdhbnQgdG8gcmVhZCBmcm9tIHRoZSBCaW5hcnlQYXJzZXJcbiAgICAgKiBAcmV0dXJuIFRoZSBpbnN0YW5jZSBvZiB0aGF0IHR5cGUgcmVhZCBmcm9tIHRoZSBCaW5hcnlQYXJzZXJcbiAgICAgKi9cbiAgICByZWFkVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmZyb21QYXJzZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBmaWVsZFxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkIFRoZSBmaWVsZCB0aGF0IHlvdSB3YW4gdG8gZ2V0IHRoZSB0eXBlIG9mXG4gICAgICogQHJldHVybiBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGZpZWxkXG4gICAgICovXG4gICAgdHlwZUZvckZpZWxkKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5hc3NvY2lhdGVkVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCB2YWx1ZSBvZiB0aGUgdHlwZSBzcGVjaWZpZWQgYnkgZmllbGQgZnJvbSB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGQgVGhlIGZpZWxkIHRoYXQgeW91IHdhbnQgdG8gZ2V0IHRoZSBhc3NvY2lhdGVkIHZhbHVlIGZvclxuICAgICAqIEByZXR1cm4gVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gZmllbGRcbiAgICAgKi9cbiAgICByZWFkRmllbGRWYWx1ZShmaWVsZCkge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlRm9yRmllbGQoZmllbGQpO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQ6ICgke2ZpZWxkLm5hbWV9LCAke2ZpZWxkLnR5cGUubmFtZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZUhpbnQgPSBmaWVsZC5pc1ZhcmlhYmxlTGVuZ3RoRW5jb2RlZFxuICAgICAgICAgICAgPyB0aGlzLnJlYWRWYXJpYWJsZUxlbmd0aExlbmd0aCgpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlLmZyb21QYXJzZXIodGhpcywgc2l6ZUhpbnQpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcm9tUGFyc2VyIGZvciAoJHtmaWVsZC5uYW1lfSwgJHtmaWVsZC50eXBlLm5hbWV9KSAtPiB1bmRlZmluZWQgYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgZmllbGQgYW5kIHZhbHVlIGZyb20gdGhlIEJpbmFyeVBhcnNlclxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgZmllbGQgYW5kIHZhbHVlXG4gICAgICovXG4gICAgcmVhZEZpZWxkQW5kVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5yZWFkRmllbGQoKTtcbiAgICAgICAgcmV0dXJuIFtmaWVsZCwgdGhpcy5yZWFkRmllbGRWYWx1ZShmaWVsZCldO1xuICAgIH1cbn1cbmV4cG9ydHMuQmluYXJ5UGFyc2VyID0gQmluYXJ5UGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5LXBhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BinarySerializer = exports.BytesList = void 0;\nconst assert = __importStar(__webpack_require__(/*! assert */ \"assert\"));\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Bytes list is a collection of buffer objects\n */\nclass BytesList {\n    constructor() {\n        this.bytesArray = [];\n    }\n    /**\n     * Get the total number of bytes in the BytesList\n     *\n     * @return the number of bytes\n     */\n    getLength() {\n        return buffer_1.Buffer.concat(this.bytesArray).byteLength;\n    }\n    /**\n     * Put bytes in the BytesList\n     *\n     * @param bytesArg A Buffer\n     * @return this BytesList\n     */\n    put(bytesArg) {\n        const bytes = buffer_1.Buffer.from(bytesArg); // Temporary, to catch instances of Uint8Array being passed in\n        this.bytesArray.push(bytes);\n        return this;\n    }\n    /**\n     * Write this BytesList to the back of another bytes list\n     *\n     *  @param list The BytesList to write to\n     */\n    toBytesSink(list) {\n        list.put(this.toBytes());\n    }\n    toBytes() {\n        return buffer_1.Buffer.concat(this.bytesArray);\n    }\n    toHex() {\n        return this.toBytes().toString('hex').toUpperCase();\n    }\n}\nexports.BytesList = BytesList;\n/**\n * BinarySerializer is used to write fields and values to buffers\n */\nclass BinarySerializer {\n    constructor(sink) {\n        this.sink = new BytesList();\n        this.sink = sink;\n    }\n    /**\n     * Write a value to this BinarySerializer\n     *\n     * @param value a SerializedType value\n     */\n    write(value) {\n        value.toBytesSink(this.sink);\n    }\n    /**\n     * Write bytes to this BinarySerializer\n     *\n     * @param bytes the bytes to write\n     */\n    put(bytes) {\n        this.sink.put(bytes);\n    }\n    /**\n     * Write a value of a given type to this BinarySerializer\n     *\n     * @param type the type to write\n     * @param value a value of that type\n     */\n    writeType(type, value) {\n        this.write(type.from(value));\n    }\n    /**\n     * Write BytesList to this BinarySerializer\n     *\n     * @param bl BytesList to write to BinarySerializer\n     */\n    writeBytesList(bl) {\n        bl.toBytesSink(this.sink);\n    }\n    /**\n     * Calculate the header of Variable Length encoded bytes\n     *\n     * @param length the length of the bytes\n     */\n    encodeVariableLength(length) {\n        const lenBytes = buffer_1.Buffer.alloc(3);\n        if (length <= 192) {\n            lenBytes[0] = length;\n            return lenBytes.slice(0, 1);\n        }\n        else if (length <= 12480) {\n            length -= 193;\n            lenBytes[0] = 193 + (length >>> 8);\n            lenBytes[1] = length & 0xff;\n            return lenBytes.slice(0, 2);\n        }\n        else if (length <= 918744) {\n            length -= 12481;\n            lenBytes[0] = 241 + (length >>> 16);\n            lenBytes[1] = (length >> 8) & 0xff;\n            lenBytes[2] = length & 0xff;\n            return lenBytes.slice(0, 3);\n        }\n        throw new Error('Overflow error');\n    }\n    /**\n     * Write field and value to BinarySerializer\n     *\n     * @param field field to write to BinarySerializer\n     * @param value value to write to BinarySerializer\n     */\n    writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {\n        const associatedValue = field.associatedType.from(value);\n        assert.ok(associatedValue.toBytesSink !== undefined);\n        assert.ok(field.name !== undefined);\n        this.sink.put(field.header);\n        if (field.isVariableLengthEncoded) {\n            this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);\n        }\n        else {\n            associatedValue.toBytesSink(this.sink);\n        }\n    }\n    /**\n     * Write a variable length encoded value to the BinarySerializer\n     *\n     * @param value length encoded value to write to BytesList\n     */\n    writeLengthEncoded(value, isUnlModifyWorkaround = false) {\n        const bytes = new BytesList();\n        if (!isUnlModifyWorkaround) {\n            // this part doesn't happen for the Account field in a UNLModify transaction\n            value.toBytesSink(bytes);\n        }\n        this.put(this.encodeVariableLength(bytes.getLength()));\n        this.writeBytesList(bytes);\n    }\n}\nexports.BinarySerializer = BinarySerializer;\n//# sourceMappingURL=binary-serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3NlcmRlcy9iaW5hcnktc2VyaWFsaXplci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsaUJBQWlCO0FBQzVDLDRCQUE0QixtQkFBTyxDQUFDLHNCQUFRO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC9zZXJkZXMvYmluYXJ5LXNlcmlhbGl6ZXIuanM/NDIyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaW5hcnlTZXJpYWxpemVyID0gZXhwb3J0cy5CeXRlc0xpc3QgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBCeXRlcyBsaXN0IGlzIGEgY29sbGVjdGlvbiBvZiBidWZmZXIgb2JqZWN0c1xuICovXG5jbGFzcyBCeXRlc0xpc3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ5dGVzQXJyYXkgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIEJ5dGVzTGlzdFxuICAgICAqXG4gICAgICogQHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICovXG4gICAgZ2V0TGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdCh0aGlzLmJ5dGVzQXJyYXkpLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1dCBieXRlcyBpbiB0aGUgQnl0ZXNMaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnl0ZXNBcmcgQSBCdWZmZXJcbiAgICAgKiBAcmV0dXJuIHRoaXMgQnl0ZXNMaXN0XG4gICAgICovXG4gICAgcHV0KGJ5dGVzQXJnKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oYnl0ZXNBcmcpOyAvLyBUZW1wb3JhcnksIHRvIGNhdGNoIGluc3RhbmNlcyBvZiBVaW50OEFycmF5IGJlaW5nIHBhc3NlZCBpblxuICAgICAgICB0aGlzLmJ5dGVzQXJyYXkucHVzaChieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGlzIEJ5dGVzTGlzdCB0byB0aGUgYmFjayBvZiBhbm90aGVyIGJ5dGVzIGxpc3RcbiAgICAgKlxuICAgICAqICBAcGFyYW0gbGlzdCBUaGUgQnl0ZXNMaXN0IHRvIHdyaXRlIHRvXG4gICAgICovXG4gICAgdG9CeXRlc1NpbmsobGlzdCkge1xuICAgICAgICBsaXN0LnB1dCh0aGlzLnRvQnl0ZXMoKSk7XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuY29uY2F0KHRoaXMuYnl0ZXNBcnJheSk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCkudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5CeXRlc0xpc3QgPSBCeXRlc0xpc3Q7XG4vKipcbiAqIEJpbmFyeVNlcmlhbGl6ZXIgaXMgdXNlZCB0byB3cml0ZSBmaWVsZHMgYW5kIHZhbHVlcyB0byBidWZmZXJzXG4gKi9cbmNsYXNzIEJpbmFyeVNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpbmspIHtcbiAgICAgICAgdGhpcy5zaW5rID0gbmV3IEJ5dGVzTGlzdCgpO1xuICAgICAgICB0aGlzLnNpbmsgPSBzaW5rO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIHZhbHVlIHRvIHRoaXMgQmluYXJ5U2VyaWFsaXplclxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIGEgU2VyaWFsaXplZFR5cGUgdmFsdWVcbiAgICAgKi9cbiAgICB3cml0ZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZS50b0J5dGVzU2luayh0aGlzLnNpbmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBieXRlcyB0byB0aGlzIEJpbmFyeVNlcmlhbGl6ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gd3JpdGVcbiAgICAgKi9cbiAgICBwdXQoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5zaW5rLnB1dChieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgdmFsdWUgb2YgYSBnaXZlbiB0eXBlIHRvIHRoaXMgQmluYXJ5U2VyaWFsaXplclxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0gdmFsdWUgYSB2YWx1ZSBvZiB0aGF0IHR5cGVcbiAgICAgKi9cbiAgICB3cml0ZVR5cGUodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy53cml0ZSh0eXBlLmZyb20odmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgQnl0ZXNMaXN0IHRvIHRoaXMgQmluYXJ5U2VyaWFsaXplclxuICAgICAqXG4gICAgICogQHBhcmFtIGJsIEJ5dGVzTGlzdCB0byB3cml0ZSB0byBCaW5hcnlTZXJpYWxpemVyXG4gICAgICovXG4gICAgd3JpdGVCeXRlc0xpc3QoYmwpIHtcbiAgICAgICAgYmwudG9CeXRlc1NpbmsodGhpcy5zaW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBoZWFkZXIgb2YgVmFyaWFibGUgTGVuZ3RoIGVuY29kZWQgYnl0ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZXNcbiAgICAgKi9cbiAgICBlbmNvZGVWYXJpYWJsZUxlbmd0aChsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbGVuQnl0ZXMgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMyk7XG4gICAgICAgIGlmIChsZW5ndGggPD0gMTkyKSB7XG4gICAgICAgICAgICBsZW5CeXRlc1swXSA9IGxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBsZW5CeXRlcy5zbGljZSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPD0gMTI0ODApIHtcbiAgICAgICAgICAgIGxlbmd0aCAtPSAxOTM7XG4gICAgICAgICAgICBsZW5CeXRlc1swXSA9IDE5MyArIChsZW5ndGggPj4+IDgpO1xuICAgICAgICAgICAgbGVuQnl0ZXNbMV0gPSBsZW5ndGggJiAweGZmO1xuICAgICAgICAgICAgcmV0dXJuIGxlbkJ5dGVzLnNsaWNlKDAsIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8PSA5MTg3NDQpIHtcbiAgICAgICAgICAgIGxlbmd0aCAtPSAxMjQ4MTtcbiAgICAgICAgICAgIGxlbkJ5dGVzWzBdID0gMjQxICsgKGxlbmd0aCA+Pj4gMTYpO1xuICAgICAgICAgICAgbGVuQnl0ZXNbMV0gPSAobGVuZ3RoID4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIGxlbkJ5dGVzWzJdID0gbGVuZ3RoICYgMHhmZjtcbiAgICAgICAgICAgIHJldHVybiBsZW5CeXRlcy5zbGljZSgwLCAzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJmbG93IGVycm9yJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGZpZWxkIGFuZCB2YWx1ZSB0byBCaW5hcnlTZXJpYWxpemVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGQgZmllbGQgdG8gd3JpdGUgdG8gQmluYXJ5U2VyaWFsaXplclxuICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byB3cml0ZSB0byBCaW5hcnlTZXJpYWxpemVyXG4gICAgICovXG4gICAgd3JpdGVGaWVsZEFuZFZhbHVlKGZpZWxkLCB2YWx1ZSwgaXNVbmxNb2RpZnlXb3JrYXJvdW5kID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRlZFZhbHVlID0gZmllbGQuYXNzb2NpYXRlZFR5cGUuZnJvbSh2YWx1ZSk7XG4gICAgICAgIGFzc2VydC5vayhhc3NvY2lhdGVkVmFsdWUudG9CeXRlc1NpbmsgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGFzc2VydC5vayhmaWVsZC5uYW1lICE9PSB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnNpbmsucHV0KGZpZWxkLmhlYWRlcik7XG4gICAgICAgIGlmIChmaWVsZC5pc1ZhcmlhYmxlTGVuZ3RoRW5jb2RlZCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUxlbmd0aEVuY29kZWQoYXNzb2NpYXRlZFZhbHVlLCBpc1VubE1vZGlmeVdvcmthcm91bmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzb2NpYXRlZFZhbHVlLnRvQnl0ZXNTaW5rKHRoaXMuc2luayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggZW5jb2RlZCB2YWx1ZSB0byB0aGUgQmluYXJ5U2VyaWFsaXplclxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIGxlbmd0aCBlbmNvZGVkIHZhbHVlIHRvIHdyaXRlIHRvIEJ5dGVzTGlzdFxuICAgICAqL1xuICAgIHdyaXRlTGVuZ3RoRW5jb2RlZCh2YWx1ZSwgaXNVbmxNb2RpZnlXb3JrYXJvdW5kID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgQnl0ZXNMaXN0KCk7XG4gICAgICAgIGlmICghaXNVbmxNb2RpZnlXb3JrYXJvdW5kKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHBhcnQgZG9lc24ndCBoYXBwZW4gZm9yIHRoZSBBY2NvdW50IGZpZWxkIGluIGEgVU5MTW9kaWZ5IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICB2YWx1ZS50b0J5dGVzU2luayhieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXQodGhpcy5lbmNvZGVWYXJpYWJsZUxlbmd0aChieXRlcy5nZXRMZW5ndGgoKSkpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXNMaXN0KGJ5dGVzKTtcbiAgICB9XG59XG5leHBvcnRzLkJpbmFyeVNlcmlhbGl6ZXIgPSBCaW5hcnlTZXJpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5LXNlcmlhbGl6ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/shamap.js":
/*!*********************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/shamap.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/index.js\");\nconst hash_prefixes_1 = __webpack_require__(/*! ./hash-prefixes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/hash-prefixes.js\");\nconst hashes_1 = __webpack_require__(/*! ./hashes */ \"(ssr)/./node_modules/ripple-binary-codec/dist/hashes.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Abstract class describing a SHAMapNode\n */\nclass ShaMapNode {\n}\nexports.ShaMapNode = ShaMapNode;\n/**\n * Class describing a Leaf of SHAMap\n */\nclass ShaMapLeaf extends ShaMapNode {\n    constructor(index, item) {\n        super();\n        this.index = index;\n        this.item = item;\n    }\n    /**\n     * @returns true as ShaMapLeaf is a leaf node\n     */\n    isLeaf() {\n        return true;\n    }\n    /**\n     * @returns false as ShaMapLeaf is not an inner node\n     */\n    isInner() {\n        return false;\n    }\n    /**\n     * Get the prefix of the this.item\n     *\n     * @returns The hash prefix, unless this.item is undefined, then it returns an empty Buffer\n     */\n    hashPrefix() {\n        return this.item === undefined ? buffer_1.Buffer.alloc(0) : this.item.hashPrefix();\n    }\n    /**\n     * Hash the bytes representation of this\n     *\n     * @returns hash of this.item concatenated with this.index\n     */\n    hash() {\n        const hash = hashes_1.Sha512Half.put(this.hashPrefix());\n        this.toBytesSink(hash);\n        return hash.finish();\n    }\n    /**\n     * Write the bytes representation of this to a BytesList\n     * @param list BytesList to write bytes to\n     */\n    toBytesSink(list) {\n        if (this.item !== undefined) {\n            this.item.toBytesSink(list);\n        }\n        this.index.toBytesSink(list);\n    }\n}\nexports.ShaMapLeaf = ShaMapLeaf;\n/**\n * Class defining an Inner Node of a SHAMap\n */\nclass ShaMapInner extends ShaMapNode {\n    constructor(depth = 0) {\n        super();\n        this.depth = depth;\n        this.slotBits = 0;\n        this.branches = Array(16);\n    }\n    /**\n     * @returns true as ShaMapInner is an inner node\n     */\n    isInner() {\n        return true;\n    }\n    /**\n     * @returns false as ShaMapInner is not a leaf node\n     */\n    isLeaf() {\n        return false;\n    }\n    /**\n     * Get the hash prefix for this node\n     *\n     * @returns hash prefix describing an inner node\n     */\n    hashPrefix() {\n        return hash_prefixes_1.HashPrefix.innerNode;\n    }\n    /**\n     * Set a branch of this node to be another node\n     *\n     * @param slot Slot to add branch to this.branches\n     * @param branch Branch to add\n     */\n    setBranch(slot, branch) {\n        this.slotBits = this.slotBits | (1 << slot);\n        this.branches[slot] = branch;\n    }\n    /**\n     * @returns true if node is empty\n     */\n    empty() {\n        return this.slotBits === 0;\n    }\n    /**\n     * Compute the hash of this node\n     *\n     * @returns The hash of this node\n     */\n    hash() {\n        if (this.empty()) {\n            return types_1.coreTypes.Hash256.ZERO_256;\n        }\n        const hash = hashes_1.Sha512Half.put(this.hashPrefix());\n        this.toBytesSink(hash);\n        return hash.finish();\n    }\n    /**\n     * Writes the bytes representation of this node to a BytesList\n     *\n     * @param list BytesList to write bytes to\n     */\n    toBytesSink(list) {\n        for (let i = 0; i < this.branches.length; i++) {\n            const branch = this.branches[i];\n            const hash = branch\n                ? branch.hash()\n                : types_1.coreTypes.Hash256.ZERO_256;\n            hash.toBytesSink(list);\n        }\n    }\n    /**\n     * Add item to the SHAMap\n     *\n     * @param index Hash of the index of the item being inserted\n     * @param item Item to insert in the map\n     * @param leaf Leaf node to insert when branch doesn't exist\n     */\n    addItem(index, item, leaf) {\n        assert_1.strict.ok(index !== undefined);\n        if (index !== undefined) {\n            const nibble = index.nibblet(this.depth);\n            const existing = this.branches[nibble];\n            if (existing === undefined) {\n                this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));\n            }\n            else if (existing instanceof ShaMapLeaf) {\n                const newInner = new ShaMapInner(this.depth + 1);\n                newInner.addItem(existing.index, undefined, existing);\n                newInner.addItem(index, item, leaf);\n                this.setBranch(nibble, newInner);\n            }\n            else if (existing instanceof ShaMapInner) {\n                existing.addItem(index, item, leaf);\n            }\n            else {\n                throw new Error('invalid ShaMap.addItem call');\n            }\n        }\n    }\n}\nclass ShaMap extends ShaMapInner {\n}\nexports.ShaMap = ShaMap;\n//# sourceMappingURL=shamap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3NoYW1hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjO0FBQ3hELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLHVGQUFpQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBVTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3NoYW1hcC5qcz9kYWM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaGFNYXBMZWFmID0gZXhwb3J0cy5TaGFNYXBOb2RlID0gZXhwb3J0cy5TaGFNYXAgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBoYXNoX3ByZWZpeGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoLXByZWZpeGVzXCIpO1xuY29uc3QgaGFzaGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoZXNcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBkZXNjcmliaW5nIGEgU0hBTWFwTm9kZVxuICovXG5jbGFzcyBTaGFNYXBOb2RlIHtcbn1cbmV4cG9ydHMuU2hhTWFwTm9kZSA9IFNoYU1hcE5vZGU7XG4vKipcbiAqIENsYXNzIGRlc2NyaWJpbmcgYSBMZWFmIG9mIFNIQU1hcFxuICovXG5jbGFzcyBTaGFNYXBMZWFmIGV4dGVuZHMgU2hhTWFwTm9kZSB7XG4gICAgY29uc3RydWN0b3IoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLml0ZW0gPSBpdGVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGFzIFNoYU1hcExlYWYgaXMgYSBsZWFmIG5vZGVcbiAgICAgKi9cbiAgICBpc0xlYWYoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmYWxzZSBhcyBTaGFNYXBMZWFmIGlzIG5vdCBhbiBpbm5lciBub2RlXG4gICAgICovXG4gICAgaXNJbm5lcigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByZWZpeCBvZiB0aGUgdGhpcy5pdGVtXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaGFzaCBwcmVmaXgsIHVubGVzcyB0aGlzLml0ZW0gaXMgdW5kZWZpbmVkLCB0aGVuIGl0IHJldHVybnMgYW4gZW1wdHkgQnVmZmVyXG4gICAgICovXG4gICAgaGFzaFByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbSA9PT0gdW5kZWZpbmVkID8gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDApIDogdGhpcy5pdGVtLmhhc2hQcmVmaXgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFzaCB0aGUgYnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgdGhpc1xuICAgICAqXG4gICAgICogQHJldHVybnMgaGFzaCBvZiB0aGlzLml0ZW0gY29uY2F0ZW5hdGVkIHdpdGggdGhpcy5pbmRleFxuICAgICAqL1xuICAgIGhhc2goKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBoYXNoZXNfMS5TaGE1MTJIYWxmLnB1dCh0aGlzLmhhc2hQcmVmaXgoKSk7XG4gICAgICAgIHRoaXMudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgYnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0byBhIEJ5dGVzTGlzdFxuICAgICAqIEBwYXJhbSBsaXN0IEJ5dGVzTGlzdCB0byB3cml0ZSBieXRlcyB0b1xuICAgICAqL1xuICAgIHRvQnl0ZXNTaW5rKGxpc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW0udG9CeXRlc1NpbmsobGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleC50b0J5dGVzU2luayhsaXN0KTtcbiAgICB9XG59XG5leHBvcnRzLlNoYU1hcExlYWYgPSBTaGFNYXBMZWFmO1xuLyoqXG4gKiBDbGFzcyBkZWZpbmluZyBhbiBJbm5lciBOb2RlIG9mIGEgU0hBTWFwXG4gKi9cbmNsYXNzIFNoYU1hcElubmVyIGV4dGVuZHMgU2hhTWFwTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZGVwdGggPSAwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgdGhpcy5zbG90Qml0cyA9IDA7XG4gICAgICAgIHRoaXMuYnJhbmNoZXMgPSBBcnJheSgxNik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRydWUgYXMgU2hhTWFwSW5uZXIgaXMgYW4gaW5uZXIgbm9kZVxuICAgICAqL1xuICAgIGlzSW5uZXIoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmYWxzZSBhcyBTaGFNYXBJbm5lciBpcyBub3QgYSBsZWFmIG5vZGVcbiAgICAgKi9cbiAgICBpc0xlYWYoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBoYXNoIHByZWZpeCBmb3IgdGhpcyBub2RlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBoYXNoIHByZWZpeCBkZXNjcmliaW5nIGFuIGlubmVyIG5vZGVcbiAgICAgKi9cbiAgICBoYXNoUHJlZml4KCkge1xuICAgICAgICByZXR1cm4gaGFzaF9wcmVmaXhlc18xLkhhc2hQcmVmaXguaW5uZXJOb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBicmFuY2ggb2YgdGhpcyBub2RlIHRvIGJlIGFub3RoZXIgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHNsb3QgU2xvdCB0byBhZGQgYnJhbmNoIHRvIHRoaXMuYnJhbmNoZXNcbiAgICAgKiBAcGFyYW0gYnJhbmNoIEJyYW5jaCB0byBhZGRcbiAgICAgKi9cbiAgICBzZXRCcmFuY2goc2xvdCwgYnJhbmNoKSB7XG4gICAgICAgIHRoaXMuc2xvdEJpdHMgPSB0aGlzLnNsb3RCaXRzIHwgKDEgPDwgc2xvdCk7XG4gICAgICAgIHRoaXMuYnJhbmNoZXNbc2xvdF0gPSBicmFuY2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgbm9kZSBpcyBlbXB0eVxuICAgICAqL1xuICAgIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbG90Qml0cyA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgaGFzaCBvZiB0aGlzIG5vZGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoaXMgbm9kZVxuICAgICAqL1xuICAgIGhhc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlc18xLmNvcmVUeXBlcy5IYXNoMjU2LlpFUk9fMjU2O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc2ggPSBoYXNoZXNfMS5TaGE1MTJIYWxmLnB1dCh0aGlzLmhhc2hQcmVmaXgoKSk7XG4gICAgICAgIHRoaXMudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdGhlIGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSB0byBhIEJ5dGVzTGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3QgQnl0ZXNMaXN0IHRvIHdyaXRlIGJ5dGVzIHRvXG4gICAgICovXG4gICAgdG9CeXRlc1NpbmsobGlzdCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IHRoaXMuYnJhbmNoZXNbaV07XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gYnJhbmNoXG4gICAgICAgICAgICAgICAgPyBicmFuY2guaGFzaCgpXG4gICAgICAgICAgICAgICAgOiB0eXBlc18xLmNvcmVUeXBlcy5IYXNoMjU2LlpFUk9fMjU2O1xuICAgICAgICAgICAgaGFzaC50b0J5dGVzU2luayhsaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgaXRlbSB0byB0aGUgU0hBTWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggSGFzaCBvZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gYmVpbmcgaW5zZXJ0ZWRcbiAgICAgKiBAcGFyYW0gaXRlbSBJdGVtIHRvIGluc2VydCBpbiB0aGUgbWFwXG4gICAgICogQHBhcmFtIGxlYWYgTGVhZiBub2RlIHRvIGluc2VydCB3aGVuIGJyYW5jaCBkb2Vzbid0IGV4aXN0XG4gICAgICovXG4gICAgYWRkSXRlbShpbmRleCwgaXRlbSwgbGVhZikge1xuICAgICAgICBhc3NlcnRfMS5zdHJpY3Qub2soaW5kZXggIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuaWJibGUgPSBpbmRleC5uaWJibGV0KHRoaXMuZGVwdGgpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmJyYW5jaGVzW25pYmJsZV07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QnJhbmNoKG5pYmJsZSwgbGVhZiB8fCBuZXcgU2hhTWFwTGVhZihpbmRleCwgaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmcgaW5zdGFuY2VvZiBTaGFNYXBMZWFmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SW5uZXIgPSBuZXcgU2hhTWFwSW5uZXIodGhpcy5kZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgIG5ld0lubmVyLmFkZEl0ZW0oZXhpc3RpbmcuaW5kZXgsIHVuZGVmaW5lZCwgZXhpc3RpbmcpO1xuICAgICAgICAgICAgICAgIG5ld0lubmVyLmFkZEl0ZW0oaW5kZXgsIGl0ZW0sIGxlYWYpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QnJhbmNoKG5pYmJsZSwgbmV3SW5uZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmcgaW5zdGFuY2VvZiBTaGFNYXBJbm5lcikge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLmFkZEl0ZW0oaW5kZXgsIGl0ZW0sIGxlYWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNoYU1hcC5hZGRJdGVtIGNhbGwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNoYU1hcCBleHRlbmRzIFNoYU1hcElubmVyIHtcbn1cbmV4cG9ydHMuU2hhTWFwID0gU2hhTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhbWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/shamap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/account-id.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/account-id.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AccountID = void 0;\nconst ripple_address_codec_1 = __webpack_require__(/*! ripple-address-codec */ \"(ssr)/./node_modules/ripple-address-codec/dist/index.js\");\nconst hash_160_1 = __webpack_require__(/*! ./hash-160 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-160.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst HEX_REGEX = /^[A-F0-9]{40}$/;\n/**\n * Class defining how to encode and decode an AccountID\n */\nclass AccountID extends hash_160_1.Hash160 {\n    constructor(bytes) {\n        super(bytes !== null && bytes !== void 0 ? bytes : AccountID.defaultAccountID.bytes);\n    }\n    /**\n     * Defines how to construct an AccountID\n     *\n     * @param value either an existing AccountID, a hex-string, or a base58 r-Address\n     * @returns an AccountID object\n     */\n    static from(value) {\n        if (value instanceof AccountID) {\n            return value;\n        }\n        if (typeof value === 'string') {\n            if (value === '') {\n                return new AccountID();\n            }\n            return HEX_REGEX.test(value)\n                ? new AccountID(buffer_1.Buffer.from(value, 'hex'))\n                : this.fromBase58(value);\n        }\n        throw new Error('Cannot construct AccountID from value given');\n    }\n    /**\n     * Defines how to build an AccountID from a base58 r-Address\n     *\n     * @param value a base58 r-Address\n     * @returns an AccountID object\n     */\n    static fromBase58(value) {\n        if ((0, ripple_address_codec_1.isValidXAddress)(value)) {\n            const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(value);\n            if (classic.tag !== false)\n                throw new Error('Only allowed to have tag on Account or Destination');\n            value = classic.classicAddress;\n        }\n        return new AccountID(buffer_1.Buffer.from((0, ripple_address_codec_1.decodeAccountID)(value)));\n    }\n    /**\n     * Overload of toJSON\n     *\n     * @returns the base58 string for this AccountID\n     */\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n     * Defines how to encode AccountID into a base58 address\n     *\n     * @returns the base58 string defined by this.bytes\n     */\n    toBase58() {\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);\n        /* eslint-enable @typescript-eslint/no-explicit-any */\n    }\n}\nexports.AccountID = AccountID;\nAccountID.defaultAccountID = new AccountID(buffer_1.Buffer.alloc(20));\n//# sourceMappingURL=account-id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2FjY291bnQtaWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLCtCQUErQixtQkFBTyxDQUFDLHFGQUFzQjtBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQyw2QkFBNkIsR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2FjY291bnQtaWQuanM/MjZkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWNjb3VudElEID0gdm9pZCAwO1xuY29uc3QgcmlwcGxlX2FkZHJlc3NfY29kZWNfMSA9IHJlcXVpcmUoXCJyaXBwbGUtYWRkcmVzcy1jb2RlY1wiKTtcbmNvbnN0IGhhc2hfMTYwXzEgPSByZXF1aXJlKFwiLi9oYXNoLTE2MFwiKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG5jb25zdCBIRVhfUkVHRVggPSAvXltBLUYwLTldezQwfSQvO1xuLyoqXG4gKiBDbGFzcyBkZWZpbmluZyBob3cgdG8gZW5jb2RlIGFuZCBkZWNvZGUgYW4gQWNjb3VudElEXG4gKi9cbmNsYXNzIEFjY291bnRJRCBleHRlbmRzIGhhc2hfMTYwXzEuSGFzaDE2MCB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoYnl0ZXMgIT09IG51bGwgJiYgYnl0ZXMgIT09IHZvaWQgMCA/IGJ5dGVzIDogQWNjb3VudElELmRlZmF1bHRBY2NvdW50SUQuYnl0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGhvdyB0byBjb25zdHJ1Y3QgYW4gQWNjb3VudElEXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgZWl0aGVyIGFuIGV4aXN0aW5nIEFjY291bnRJRCwgYSBoZXgtc3RyaW5nLCBvciBhIGJhc2U1OCByLUFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyBhbiBBY2NvdW50SUQgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQWNjb3VudElEKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjY291bnRJRCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEhFWF9SRUdFWC50ZXN0KHZhbHVlKVxuICAgICAgICAgICAgICAgID8gbmV3IEFjY291bnRJRChidWZmZXJfMS5CdWZmZXIuZnJvbSh2YWx1ZSwgJ2hleCcpKVxuICAgICAgICAgICAgICAgIDogdGhpcy5mcm9tQmFzZTU4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgQWNjb3VudElEIGZyb20gdmFsdWUgZ2l2ZW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBob3cgdG8gYnVpbGQgYW4gQWNjb3VudElEIGZyb20gYSBiYXNlNTggci1BZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgYSBiYXNlNTggci1BZGRyZXNzXG4gICAgICogQHJldHVybnMgYW4gQWNjb3VudElEIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmFzZTU4KHZhbHVlKSB7XG4gICAgICAgIGlmICgoMCwgcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5pc1ZhbGlkWEFkZHJlc3MpKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NpYyA9ICgwLCByaXBwbGVfYWRkcmVzc19jb2RlY18xLnhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcykodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzaWMudGFnICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgYWxsb3dlZCB0byBoYXZlIHRhZyBvbiBBY2NvdW50IG9yIERlc3RpbmF0aW9uJyk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNsYXNzaWMuY2xhc3NpY0FkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50SUQoYnVmZmVyXzEuQnVmZmVyLmZyb20oKDAsIHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZGVjb2RlQWNjb3VudElEKSh2YWx1ZSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWQgb2YgdG9KU09OXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgYmFzZTU4IHN0cmluZyBmb3IgdGhpcyBBY2NvdW50SURcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaG93IHRvIGVuY29kZSBBY2NvdW50SUQgaW50byBhIGJhc2U1OCBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgYmFzZTU4IHN0cmluZyBkZWZpbmVkIGJ5IHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICB0b0Jhc2U1OCgpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgICByZXR1cm4gKDAsIHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZW5jb2RlQWNjb3VudElEKSh0aGlzLmJ5dGVzKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50SUQgPSBBY2NvdW50SUQ7XG5BY2NvdW50SUQuZGVmYXVsdEFjY291bnRJRCA9IG5ldyBBY2NvdW50SUQoYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDIwKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50LWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/account-id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/amount.js":
/*!***************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/amount.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Amount = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst binary_parser_1 = __webpack_require__(/*! ../serdes/binary-parser */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js\");\nconst account_id_1 = __webpack_require__(/*! ./account-id */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/account-id.js\");\nconst currency_1 = __webpack_require__(/*! ./currency */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/currency.js\");\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst bigInt = __webpack_require__(/*! big-integer */ \"(ssr)/./node_modules/ripple-binary-codec/node_modules/big-integer/BigInteger.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Constants for validating amounts\n */\nconst MIN_IOU_EXPONENT = -96;\nconst MAX_IOU_EXPONENT = 80;\nconst MAX_IOU_PRECISION = 16;\nconst MAX_DROPS = new decimal_js_1.Decimal('1e17');\nconst MIN_XRP = new decimal_js_1.Decimal('1e-6');\nconst mask = bigInt(0x00000000ffffffff);\n/**\n * decimal.js configuration for Amount IOUs\n */\ndecimal_js_1.Decimal.config({\n    toExpPos: MAX_IOU_EXPONENT + MAX_IOU_PRECISION,\n    toExpNeg: MIN_IOU_EXPONENT - MAX_IOU_PRECISION,\n});\n/**\n * Type guard for AmountObject\n */\nfunction isAmountObject(arg) {\n    const keys = Object.keys(arg).sort();\n    return (keys.length === 3 &&\n        keys[0] === 'currency' &&\n        keys[1] === 'issuer' &&\n        keys[2] === 'value');\n}\n/**\n * Class for serializing/Deserializing Amounts\n */\nclass Amount extends serialized_type_1.SerializedType {\n    constructor(bytes) {\n        super(bytes !== null && bytes !== void 0 ? bytes : Amount.defaultAmount.bytes);\n    }\n    /**\n     * Construct an amount from an IOU or string amount\n     *\n     * @param value An Amount, object representing an IOU, or a string\n     *     representing an integer amount\n     * @returns An Amount object\n     */\n    static from(value) {\n        if (value instanceof Amount) {\n            return value;\n        }\n        let amount = buffer_1.Buffer.alloc(8);\n        if (typeof value === 'string') {\n            Amount.assertXrpIsValid(value);\n            const number = bigInt(value);\n            const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];\n            intBuf[0].writeUInt32BE(Number(number.shiftRight(32)), 0);\n            intBuf[1].writeUInt32BE(Number(number.and(mask)), 0);\n            amount = buffer_1.Buffer.concat(intBuf);\n            amount[0] |= 0x40;\n            return new Amount(amount);\n        }\n        if (isAmountObject(value)) {\n            const number = new decimal_js_1.Decimal(value.value);\n            Amount.assertIouIsValid(number);\n            if (number.isZero()) {\n                amount[0] |= 0x80;\n            }\n            else {\n                const integerNumberString = number\n                    .times(`1e${-(number.e - 15)}`)\n                    .abs()\n                    .toString();\n                const num = bigInt(integerNumberString);\n                const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];\n                intBuf[0].writeUInt32BE(Number(num.shiftRight(32)), 0);\n                intBuf[1].writeUInt32BE(Number(num.and(mask)), 0);\n                amount = buffer_1.Buffer.concat(intBuf);\n                amount[0] |= 0x80;\n                if (number.gt(new decimal_js_1.Decimal(0))) {\n                    amount[0] |= 0x40;\n                }\n                const exponent = number.e - 15;\n                const exponentByte = 97 + exponent;\n                amount[0] |= exponentByte >>> 2;\n                amount[1] |= (exponentByte & 0x03) << 6;\n            }\n            const currency = currency_1.Currency.from(value.currency).toBytes();\n            const issuer = account_id_1.AccountID.from(value.issuer).toBytes();\n            return new Amount(buffer_1.Buffer.concat([amount, currency, issuer]));\n        }\n        throw new Error('Invalid type to construct an Amount');\n    }\n    /**\n     * Read an amount from a BinaryParser\n     *\n     * @param parser BinaryParser to read the Amount from\n     * @returns An Amount object\n     */\n    static fromParser(parser) {\n        const isXRP = parser.peek() & 0x80;\n        const numBytes = isXRP ? 48 : 8;\n        return new Amount(parser.read(numBytes));\n    }\n    /**\n     * Get the JSON representation of this Amount\n     *\n     * @returns the JSON interpretation of this.bytes\n     */\n    toJSON() {\n        if (this.isNative()) {\n            const bytes = this.bytes;\n            const isPositive = bytes[0] & 0x40;\n            const sign = isPositive ? '' : '-';\n            bytes[0] &= 0x3f;\n            const msb = bigInt(bytes.slice(0, 4).readUInt32BE(0));\n            const lsb = bigInt(bytes.slice(4).readUInt32BE(0));\n            const num = msb.shiftLeft(32).or(lsb);\n            return `${sign}${num.toString()}`;\n        }\n        else {\n            const parser = new binary_parser_1.BinaryParser(this.toString());\n            const mantissa = parser.read(8);\n            const currency = currency_1.Currency.fromParser(parser);\n            const issuer = account_id_1.AccountID.fromParser(parser);\n            const b1 = mantissa[0];\n            const b2 = mantissa[1];\n            const isPositive = b1 & 0x40;\n            const sign = isPositive ? '' : '-';\n            const exponent = ((b1 & 0x3f) << 2) + ((b2 & 0xff) >> 6) - 97;\n            mantissa[0] = 0;\n            mantissa[1] &= 0x3f;\n            const value = new decimal_js_1.Decimal(`${sign}0x${mantissa.toString('hex')}`).times(`1e${exponent}`);\n            Amount.assertIouIsValid(value);\n            return {\n                value: value.toString(),\n                currency: currency.toJSON(),\n                issuer: issuer.toJSON(),\n            };\n        }\n    }\n    /**\n     * Validate XRP amount\n     *\n     * @param amount String representing XRP amount\n     * @returns void, but will throw if invalid amount\n     */\n    static assertXrpIsValid(amount) {\n        if (amount.indexOf('.') !== -1) {\n            throw new Error(`${amount.toString()} is an illegal amount`);\n        }\n        const decimal = new decimal_js_1.Decimal(amount);\n        if (!decimal.isZero()) {\n            if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {\n                throw new Error(`${amount.toString()} is an illegal amount`);\n            }\n        }\n    }\n    /**\n     * Validate IOU.value amount\n     *\n     * @param decimal Decimal.js object representing IOU.value\n     * @returns void, but will throw if invalid amount\n     */\n    static assertIouIsValid(decimal) {\n        if (!decimal.isZero()) {\n            const p = decimal.precision();\n            const e = decimal.e - 15;\n            if (p > MAX_IOU_PRECISION ||\n                e > MAX_IOU_EXPONENT ||\n                e < MIN_IOU_EXPONENT) {\n                throw new Error('Decimal precision out of range');\n            }\n            this.verifyNoDecimal(decimal);\n        }\n    }\n    /**\n     * Ensure that the value after being multiplied by the exponent does not\n     * contain a decimal.\n     *\n     * @param decimal a Decimal object\n     * @returns a string of the object without a decimal\n     */\n    static verifyNoDecimal(decimal) {\n        const integerNumberString = decimal\n            .times(`1e${-(decimal.e - 15)}`)\n            .abs()\n            .toString();\n        if (integerNumberString.indexOf('.') !== -1) {\n            throw new Error('Decimal place found in integerNumberString');\n        }\n    }\n    /**\n     * Test if this amount is in units of Native Currency(XRP)\n     *\n     * @returns true if Native (XRP)\n     */\n    isNative() {\n        return (this.bytes[0] & 0x80) === 0;\n    }\n}\nexports.Amount = Amount;\nAmount.defaultAmount = new Amount(buffer_1.Buffer.from('4000000000000000', 'hex'));\n//# sourceMappingURL=amount.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2Ftb3VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QscUJBQXFCLG1CQUFPLENBQUMsOERBQVk7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsc0dBQXlCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLHVGQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFZO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLGlHQUFtQjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsb0dBQWE7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxFQUFFLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxJQUFJLHlCQUF5QixjQUFjLFNBQVM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2Ftb3VudC5qcz82YWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbW91bnQgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbmNvbnN0IGJpbmFyeV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9zZXJkZXMvYmluYXJ5LXBhcnNlclwiKTtcbmNvbnN0IGFjY291bnRfaWRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnQtaWRcIik7XG5jb25zdCBjdXJyZW5jeV8xID0gcmVxdWlyZShcIi4vY3VycmVuY3lcIik7XG5jb25zdCBzZXJpYWxpemVkX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZWQtdHlwZVwiKTtcbmNvbnN0IGJpZ0ludCA9IHJlcXVpcmUoXCJiaWctaW50ZWdlclwiKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG4vKipcbiAqIENvbnN0YW50cyBmb3IgdmFsaWRhdGluZyBhbW91bnRzXG4gKi9cbmNvbnN0IE1JTl9JT1VfRVhQT05FTlQgPSAtOTY7XG5jb25zdCBNQVhfSU9VX0VYUE9ORU5UID0gODA7XG5jb25zdCBNQVhfSU9VX1BSRUNJU0lPTiA9IDE2O1xuY29uc3QgTUFYX0RST1BTID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKCcxZTE3Jyk7XG5jb25zdCBNSU5fWFJQID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKCcxZS02Jyk7XG5jb25zdCBtYXNrID0gYmlnSW50KDB4MDAwMDAwMDBmZmZmZmZmZik7XG4vKipcbiAqIGRlY2ltYWwuanMgY29uZmlndXJhdGlvbiBmb3IgQW1vdW50IElPVXNcbiAqL1xuZGVjaW1hbF9qc18xLkRlY2ltYWwuY29uZmlnKHtcbiAgICB0b0V4cFBvczogTUFYX0lPVV9FWFBPTkVOVCArIE1BWF9JT1VfUFJFQ0lTSU9OLFxuICAgIHRvRXhwTmVnOiBNSU5fSU9VX0VYUE9ORU5UIC0gTUFYX0lPVV9QUkVDSVNJT04sXG59KTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgQW1vdW50T2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzQW1vdW50T2JqZWN0KGFyZykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICByZXR1cm4gKGtleXMubGVuZ3RoID09PSAzICYmXG4gICAgICAgIGtleXNbMF0gPT09ICdjdXJyZW5jeScgJiZcbiAgICAgICAga2V5c1sxXSA9PT0gJ2lzc3VlcicgJiZcbiAgICAgICAga2V5c1syXSA9PT0gJ3ZhbHVlJyk7XG59XG4vKipcbiAqIENsYXNzIGZvciBzZXJpYWxpemluZy9EZXNlcmlhbGl6aW5nIEFtb3VudHNcbiAqL1xuY2xhc3MgQW1vdW50IGV4dGVuZHMgc2VyaWFsaXplZF90eXBlXzEuU2VyaWFsaXplZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGJ5dGVzICE9PSBudWxsICYmIGJ5dGVzICE9PSB2b2lkIDAgPyBieXRlcyA6IEFtb3VudC5kZWZhdWx0QW1vdW50LmJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIGFtb3VudCBmcm9tIGFuIElPVSBvciBzdHJpbmcgYW1vdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgQW4gQW1vdW50LCBvYmplY3QgcmVwcmVzZW50aW5nIGFuIElPVSwgb3IgYSBzdHJpbmdcbiAgICAgKiAgICAgcmVwcmVzZW50aW5nIGFuIGludGVnZXIgYW1vdW50XG4gICAgICogQHJldHVybnMgQW4gQW1vdW50IG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbW91bnQgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoOCk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBBbW91bnQuYXNzZXJ0WHJwSXNWYWxpZCh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBudW1iZXIgPSBiaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgaW50QnVmID0gW2J1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KSwgYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDQpXTtcbiAgICAgICAgICAgIGludEJ1ZlswXS53cml0ZVVJbnQzMkJFKE51bWJlcihudW1iZXIuc2hpZnRSaWdodCgzMikpLCAwKTtcbiAgICAgICAgICAgIGludEJ1ZlsxXS53cml0ZVVJbnQzMkJFKE51bWJlcihudW1iZXIuYW5kKG1hc2spKSwgMCk7XG4gICAgICAgICAgICBhbW91bnQgPSBidWZmZXJfMS5CdWZmZXIuY29uY2F0KGludEJ1Zik7XG4gICAgICAgICAgICBhbW91bnRbMF0gfD0gMHg0MDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW1vdW50KGFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQW1vdW50T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgbnVtYmVyID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIEFtb3VudC5hc3NlcnRJb3VJc1ZhbGlkKG51bWJlcik7XG4gICAgICAgICAgICBpZiAobnVtYmVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgYW1vdW50WzBdIHw9IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlZ2VyTnVtYmVyU3RyaW5nID0gbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIC50aW1lcyhgMWUkey0obnVtYmVyLmUgLSAxNSl9YClcbiAgICAgICAgICAgICAgICAgICAgLmFicygpXG4gICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bSA9IGJpZ0ludChpbnRlZ2VyTnVtYmVyU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRCdWYgPSBbYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDQpLCBidWZmZXJfMS5CdWZmZXIuYWxsb2MoNCldO1xuICAgICAgICAgICAgICAgIGludEJ1ZlswXS53cml0ZVVJbnQzMkJFKE51bWJlcihudW0uc2hpZnRSaWdodCgzMikpLCAwKTtcbiAgICAgICAgICAgICAgICBpbnRCdWZbMV0ud3JpdGVVSW50MzJCRShOdW1iZXIobnVtLmFuZChtYXNrKSksIDApO1xuICAgICAgICAgICAgICAgIGFtb3VudCA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoaW50QnVmKTtcbiAgICAgICAgICAgICAgICBhbW91bnRbMF0gfD0gMHg4MDtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyLmd0KG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50WzBdIHw9IDB4NDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50ID0gbnVtYmVyLmUgLSAxNTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBvbmVudEJ5dGUgPSA5NyArIGV4cG9uZW50O1xuICAgICAgICAgICAgICAgIGFtb3VudFswXSB8PSBleHBvbmVudEJ5dGUgPj4+IDI7XG4gICAgICAgICAgICAgICAgYW1vdW50WzFdIHw9IChleHBvbmVudEJ5dGUgJiAweDAzKSA8PCA2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3VycmVuY3kgPSBjdXJyZW5jeV8xLkN1cnJlbmN5LmZyb20odmFsdWUuY3VycmVuY3kpLnRvQnl0ZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzc3VlciA9IGFjY291bnRfaWRfMS5BY2NvdW50SUQuZnJvbSh2YWx1ZS5pc3N1ZXIpLnRvQnl0ZXMoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW1vdW50KGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW2Ftb3VudCwgY3VycmVuY3ksIGlzc3Vlcl0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZSB0byBjb25zdHJ1Y3QgYW4gQW1vdW50Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYW4gYW1vdW50IGZyb20gYSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJzZXIgQmluYXJ5UGFyc2VyIHRvIHJlYWQgdGhlIEFtb3VudCBmcm9tXG4gICAgICogQHJldHVybnMgQW4gQW1vdW50IG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUGFyc2VyKHBhcnNlcikge1xuICAgICAgICBjb25zdCBpc1hSUCA9IHBhcnNlci5wZWVrKCkgJiAweDgwO1xuICAgICAgICBjb25zdCBudW1CeXRlcyA9IGlzWFJQID8gNDggOiA4O1xuICAgICAgICByZXR1cm4gbmV3IEFtb3VudChwYXJzZXIucmVhZChudW1CeXRlcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBBbW91bnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBKU09OIGludGVycHJldGF0aW9uIG9mIHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmF0aXZlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5ieXRlcztcbiAgICAgICAgICAgIGNvbnN0IGlzUG9zaXRpdmUgPSBieXRlc1swXSAmIDB4NDA7XG4gICAgICAgICAgICBjb25zdCBzaWduID0gaXNQb3NpdGl2ZSA/ICcnIDogJy0nO1xuICAgICAgICAgICAgYnl0ZXNbMF0gJj0gMHgzZjtcbiAgICAgICAgICAgIGNvbnN0IG1zYiA9IGJpZ0ludChieXRlcy5zbGljZSgwLCA0KS5yZWFkVUludDMyQkUoMCkpO1xuICAgICAgICAgICAgY29uc3QgbHNiID0gYmlnSW50KGJ5dGVzLnNsaWNlKDQpLnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgICAgICBjb25zdCBudW0gPSBtc2Iuc2hpZnRMZWZ0KDMyKS5vcihsc2IpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3NpZ259JHtudW0udG9TdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IGJpbmFyeV9wYXJzZXJfMS5CaW5hcnlQYXJzZXIodGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGNvbnN0IG1hbnRpc3NhID0gcGFyc2VyLnJlYWQoOCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW5jeSA9IGN1cnJlbmN5XzEuQ3VycmVuY3kuZnJvbVBhcnNlcihwYXJzZXIpO1xuICAgICAgICAgICAgY29uc3QgaXNzdWVyID0gYWNjb3VudF9pZF8xLkFjY291bnRJRC5mcm9tUGFyc2VyKHBhcnNlcik7XG4gICAgICAgICAgICBjb25zdCBiMSA9IG1hbnRpc3NhWzBdO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBtYW50aXNzYVsxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzUG9zaXRpdmUgPSBiMSAmIDB4NDA7XG4gICAgICAgICAgICBjb25zdCBzaWduID0gaXNQb3NpdGl2ZSA/ICcnIDogJy0nO1xuICAgICAgICAgICAgY29uc3QgZXhwb25lbnQgPSAoKGIxICYgMHgzZikgPDwgMikgKyAoKGIyICYgMHhmZikgPj4gNikgLSA5NztcbiAgICAgICAgICAgIG1hbnRpc3NhWzBdID0gMDtcbiAgICAgICAgICAgIG1hbnRpc3NhWzFdICY9IDB4M2Y7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChgJHtzaWdufTB4JHttYW50aXNzYS50b1N0cmluZygnaGV4Jyl9YCkudGltZXMoYDFlJHtleHBvbmVudH1gKTtcbiAgICAgICAgICAgIEFtb3VudC5hc3NlcnRJb3VJc1ZhbGlkKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LnRvSlNPTigpLFxuICAgICAgICAgICAgICAgIGlzc3VlcjogaXNzdWVyLnRvSlNPTigpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBYUlAgYW1vdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IFN0cmluZyByZXByZXNlbnRpbmcgWFJQIGFtb3VudFxuICAgICAqIEByZXR1cm5zIHZvaWQsIGJ1dCB3aWxsIHRocm93IGlmIGludmFsaWQgYW1vdW50XG4gICAgICovXG4gICAgc3RhdGljIGFzc2VydFhycElzVmFsaWQoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Ftb3VudC50b1N0cmluZygpfSBpcyBhbiBpbGxlZ2FsIGFtb3VudGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY2ltYWwgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYW1vdW50KTtcbiAgICAgICAgaWYgKCFkZWNpbWFsLmlzWmVybygpKSB7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbC5sdChNSU5fWFJQKSB8fCBkZWNpbWFsLmd0KE1BWF9EUk9QUykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YW1vdW50LnRvU3RyaW5nKCl9IGlzIGFuIGlsbGVnYWwgYW1vdW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgSU9VLnZhbHVlIGFtb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtIGRlY2ltYWwgRGVjaW1hbC5qcyBvYmplY3QgcmVwcmVzZW50aW5nIElPVS52YWx1ZVxuICAgICAqIEByZXR1cm5zIHZvaWQsIGJ1dCB3aWxsIHRocm93IGlmIGludmFsaWQgYW1vdW50XG4gICAgICovXG4gICAgc3RhdGljIGFzc2VydElvdUlzVmFsaWQoZGVjaW1hbCkge1xuICAgICAgICBpZiAoIWRlY2ltYWwuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBkZWNpbWFsLnByZWNpc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgZSA9IGRlY2ltYWwuZSAtIDE1O1xuICAgICAgICAgICAgaWYgKHAgPiBNQVhfSU9VX1BSRUNJU0lPTiB8fFxuICAgICAgICAgICAgICAgIGUgPiBNQVhfSU9VX0VYUE9ORU5UIHx8XG4gICAgICAgICAgICAgICAgZSA8IE1JTl9JT1VfRVhQT05FTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2ltYWwgcHJlY2lzaW9uIG91dCBvZiByYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52ZXJpZnlOb0RlY2ltYWwoZGVjaW1hbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgdGhlIHZhbHVlIGFmdGVyIGJlaW5nIG11bHRpcGxpZWQgYnkgdGhlIGV4cG9uZW50IGRvZXMgbm90XG4gICAgICogY29udGFpbiBhIGRlY2ltYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVjaW1hbCBhIERlY2ltYWwgb2JqZWN0XG4gICAgICogQHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIG9iamVjdCB3aXRob3V0IGEgZGVjaW1hbFxuICAgICAqL1xuICAgIHN0YXRpYyB2ZXJpZnlOb0RlY2ltYWwoZGVjaW1hbCkge1xuICAgICAgICBjb25zdCBpbnRlZ2VyTnVtYmVyU3RyaW5nID0gZGVjaW1hbFxuICAgICAgICAgICAgLnRpbWVzKGAxZSR7LShkZWNpbWFsLmUgLSAxNSl9YClcbiAgICAgICAgICAgIC5hYnMoKVxuICAgICAgICAgICAgLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChpbnRlZ2VyTnVtYmVyU3RyaW5nLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjaW1hbCBwbGFjZSBmb3VuZCBpbiBpbnRlZ2VyTnVtYmVyU3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGlzIGFtb3VudCBpcyBpbiB1bml0cyBvZiBOYXRpdmUgQ3VycmVuY3koWFJQKVxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBOYXRpdmUgKFhSUClcbiAgICAgKi9cbiAgICBpc05hdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJ5dGVzWzBdICYgMHg4MCkgPT09IDA7XG4gICAgfVxufVxuZXhwb3J0cy5BbW91bnQgPSBBbW91bnQ7XG5BbW91bnQuZGVmYXVsdEFtb3VudCA9IG5ldyBBbW91bnQoYnVmZmVyXzEuQnVmZmVyLmZyb20oJzQwMDAwMDAwMDAwMDAwMDAnLCAnaGV4JykpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1vdW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/amount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/blob.js":
/*!*************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/blob.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Blob = void 0;\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Variable length encoded type\n */\nclass Blob extends serialized_type_1.SerializedType {\n    constructor(bytes) {\n        super(bytes);\n    }\n    /**\n     * Defines how to read a Blob from a BinaryParser\n     *\n     * @param parser The binary parser to read the Blob from\n     * @param hint The length of the blob, computed by readVariableLengthLength() and passed in\n     * @returns A Blob object\n     */\n    static fromParser(parser, hint) {\n        return new Blob(parser.read(hint));\n    }\n    /**\n     * Create a Blob object from a hex-string\n     *\n     * @param value existing Blob object or a hex-string\n     * @returns A Blob object\n     */\n    static from(value) {\n        if (value instanceof Blob) {\n            return value;\n        }\n        if (typeof value === 'string') {\n            return new Blob(buffer_1.Buffer.from(value, 'hex'));\n        }\n        throw new Error('Cannot construct Blob from value given');\n    }\n}\nexports.Blob = Blob;\n//# sourceMappingURL=blob.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2Jsb2IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLDBCQUEwQixtQkFBTyxDQUFDLGlHQUFtQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvYmxvYi5qcz82MGNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CbG9iID0gdm9pZCAwO1xuY29uc3Qgc2VyaWFsaXplZF90eXBlXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVkLXR5cGVcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBWYXJpYWJsZSBsZW5ndGggZW5jb2RlZCB0eXBlXG4gKi9cbmNsYXNzIEJsb2IgZXh0ZW5kcyBzZXJpYWxpemVkX3R5cGVfMS5TZXJpYWxpemVkVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoYnl0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGhvdyB0byByZWFkIGEgQmxvYiBmcm9tIGEgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyc2VyIFRoZSBiaW5hcnkgcGFyc2VyIHRvIHJlYWQgdGhlIEJsb2IgZnJvbVxuICAgICAqIEBwYXJhbSBoaW50IFRoZSBsZW5ndGggb2YgdGhlIGJsb2IsIGNvbXB1dGVkIGJ5IHJlYWRWYXJpYWJsZUxlbmd0aExlbmd0aCgpIGFuZCBwYXNzZWQgaW5cbiAgICAgKiBAcmV0dXJucyBBIEJsb2Igb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGZyb21QYXJzZXIocGFyc2VyLCBoaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvYihwYXJzZXIucmVhZChoaW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEJsb2Igb2JqZWN0IGZyb20gYSBoZXgtc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgZXhpc3RpbmcgQmxvYiBvYmplY3Qgb3IgYSBoZXgtc3RyaW5nXG4gICAgICogQHJldHVybnMgQSBCbG9iIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHZhbHVlLCAnaGV4JykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBCbG9iIGZyb20gdmFsdWUgZ2l2ZW4nKTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2IgPSBCbG9iO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/blob.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/currency.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/currency.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Currency = void 0;\nconst hash_160_1 = __webpack_require__(/*! ./hash-160 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-160.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst XRP_HEX_REGEX = /^0{40}$/;\nconst ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\\]|]{3}$/;\nconst HEX_REGEX = /^[A-F0-9]{40}$/;\n// eslint-disable-next-line no-control-regex\nconst STANDARD_FORMAT_HEX_REGEX = /^0{24}[\\x00-\\x7F]{6}0{10}$/;\n/**\n * Convert an ISO code to a currency bytes representation\n */\nfunction isoToBytes(iso) {\n    const bytes = buffer_1.Buffer.alloc(20);\n    if (iso !== 'XRP') {\n        const isoBytes = iso.split('').map((c) => c.charCodeAt(0));\n        bytes.set(isoBytes, 12);\n    }\n    return bytes;\n}\n/**\n * Tests if ISO is a valid iso code\n */\nfunction isIsoCode(iso) {\n    return ISO_REGEX.test(iso);\n}\nfunction isoCodeFromHex(code) {\n    const iso = code.toString();\n    if (iso === 'XRP') {\n        return null;\n    }\n    if (isIsoCode(iso)) {\n        return iso;\n    }\n    return null;\n}\n/**\n * Tests if hex is a valid hex-string\n */\nfunction isHex(hex) {\n    return HEX_REGEX.test(hex);\n}\n/**\n * Tests if a string is a valid representation of a currency\n */\nfunction isStringRepresentation(input) {\n    return input.length === 3 || isHex(input);\n}\n/**\n * Tests if a Buffer is a valid representation of a currency\n */\nfunction isBytesArray(bytes) {\n    return bytes.byteLength === 20;\n}\n/**\n * Ensures that a value is a valid representation of a currency\n */\nfunction isValidRepresentation(input) {\n    return input instanceof buffer_1.Buffer\n        ? isBytesArray(input)\n        : isStringRepresentation(input);\n}\n/**\n * Generate bytes from a string or buffer representation of a currency\n */\nfunction bytesFromRepresentation(input) {\n    if (!isValidRepresentation(input)) {\n        throw new Error(`Unsupported Currency representation: ${input}`);\n    }\n    return input.length === 3 ? isoToBytes(input) : buffer_1.Buffer.from(input, 'hex');\n}\n/**\n * Class defining how to encode and decode Currencies\n */\nclass Currency extends hash_160_1.Hash160 {\n    constructor(byteBuf) {\n        super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : Currency.XRP.bytes);\n        const hex = this.bytes.toString('hex');\n        if (XRP_HEX_REGEX.test(hex)) {\n            this._iso = 'XRP';\n        }\n        else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {\n            this._iso = isoCodeFromHex(this.bytes.slice(12, 15));\n        }\n        else {\n            this._iso = null;\n        }\n    }\n    /**\n     * Return the ISO code of this currency\n     *\n     * @returns ISO code if it exists, else null\n     */\n    iso() {\n        return this._iso;\n    }\n    /**\n     * Constructs a Currency object\n     *\n     * @param val Currency object or a string representation of a currency\n     */\n    static from(value) {\n        if (value instanceof Currency) {\n            return value;\n        }\n        if (typeof value === 'string') {\n            return new Currency(bytesFromRepresentation(value));\n        }\n        throw new Error('Cannot construct Currency from value given');\n    }\n    /**\n     * Gets the JSON representation of a currency\n     *\n     * @returns JSON representation\n     */\n    toJSON() {\n        const iso = this.iso();\n        if (iso !== null) {\n            return iso;\n        }\n        return this.bytes.toString('hex').toUpperCase();\n    }\n}\nexports.Currency = Currency;\nCurrency.XRP = new Currency(buffer_1.Buffer.alloc(20));\n//# sourceMappingURL=currency.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2N1cnJlbmN5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQywwQkFBMEIsR0FBRztBQUM3QiwyQ0FBMkMsTUFBTSxFQUFFO0FBQ25ELDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0Esc0NBQXNDLEdBQUcsWUFBWSxFQUFFLEVBQUUsR0FBRztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxNQUFNO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvY3VycmVuY3kuanM/MGI0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3VycmVuY3kgPSB2b2lkIDA7XG5jb25zdCBoYXNoXzE2MF8xID0gcmVxdWlyZShcIi4vaGFzaC0xNjBcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuY29uc3QgWFJQX0hFWF9SRUdFWCA9IC9eMHs0MH0kLztcbmNvbnN0IElTT19SRUdFWCA9IC9eW0EtWjAtOWEtej8hQCMkJV4mKigpe31bXFxdfF17M30kLztcbmNvbnN0IEhFWF9SRUdFWCA9IC9eW0EtRjAtOV17NDB9JC87XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3QgU1RBTkRBUkRfRk9STUFUX0hFWF9SRUdFWCA9IC9eMHsyNH1bXFx4MDAtXFx4N0ZdezZ9MHsxMH0kLztcbi8qKlxuICogQ29udmVydCBhbiBJU08gY29kZSB0byBhIGN1cnJlbmN5IGJ5dGVzIHJlcHJlc2VudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGlzb1RvQnl0ZXMoaXNvKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMjApO1xuICAgIGlmIChpc28gIT09ICdYUlAnKSB7XG4gICAgICAgIGNvbnN0IGlzb0J5dGVzID0gaXNvLnNwbGl0KCcnKS5tYXAoKGMpID0+IGMuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIGJ5dGVzLnNldChpc29CeXRlcywgMTIpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIFRlc3RzIGlmIElTTyBpcyBhIHZhbGlkIGlzbyBjb2RlXG4gKi9cbmZ1bmN0aW9uIGlzSXNvQ29kZShpc28pIHtcbiAgICByZXR1cm4gSVNPX1JFR0VYLnRlc3QoaXNvKTtcbn1cbmZ1bmN0aW9uIGlzb0NvZGVGcm9tSGV4KGNvZGUpIHtcbiAgICBjb25zdCBpc28gPSBjb2RlLnRvU3RyaW5nKCk7XG4gICAgaWYgKGlzbyA9PT0gJ1hSUCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0lzb0NvZGUoaXNvKSkge1xuICAgICAgICByZXR1cm4gaXNvO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogVGVzdHMgaWYgaGV4IGlzIGEgdmFsaWQgaGV4LXN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleChoZXgpIHtcbiAgICByZXR1cm4gSEVYX1JFR0VYLnRlc3QoaGV4KTtcbn1cbi8qKlxuICogVGVzdHMgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhIGN1cnJlbmN5XG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nUmVwcmVzZW50YXRpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQubGVuZ3RoID09PSAzIHx8IGlzSGV4KGlucHV0KTtcbn1cbi8qKlxuICogVGVzdHMgaWYgYSBCdWZmZXIgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhIGN1cnJlbmN5XG4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXNBcnJheShieXRlcykge1xuICAgIHJldHVybiBieXRlcy5ieXRlTGVuZ3RoID09PSAyMDtcbn1cbi8qKlxuICogRW5zdXJlcyB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhIGN1cnJlbmN5XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSZXByZXNlbnRhdGlvbihpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIGJ1ZmZlcl8xLkJ1ZmZlclxuICAgICAgICA/IGlzQnl0ZXNBcnJheShpbnB1dClcbiAgICAgICAgOiBpc1N0cmluZ1JlcHJlc2VudGF0aW9uKGlucHV0KTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYnl0ZXMgZnJvbSBhIHN0cmluZyBvciBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgYSBjdXJyZW5jeVxuICovXG5mdW5jdGlvbiBieXRlc0Zyb21SZXByZXNlbnRhdGlvbihpbnB1dCkge1xuICAgIGlmICghaXNWYWxpZFJlcHJlc2VudGF0aW9uKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIEN1cnJlbmN5IHJlcHJlc2VudGF0aW9uOiAke2lucHV0fWApO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQubGVuZ3RoID09PSAzID8gaXNvVG9CeXRlcyhpbnB1dCkgOiBidWZmZXJfMS5CdWZmZXIuZnJvbShpbnB1dCwgJ2hleCcpO1xufVxuLyoqXG4gKiBDbGFzcyBkZWZpbmluZyBob3cgdG8gZW5jb2RlIGFuZCBkZWNvZGUgQ3VycmVuY2llc1xuICovXG5jbGFzcyBDdXJyZW5jeSBleHRlbmRzIGhhc2hfMTYwXzEuSGFzaDE2MCB7XG4gICAgY29uc3RydWN0b3IoYnl0ZUJ1Zikge1xuICAgICAgICBzdXBlcihieXRlQnVmICE9PSBudWxsICYmIGJ5dGVCdWYgIT09IHZvaWQgMCA/IGJ5dGVCdWYgOiBDdXJyZW5jeS5YUlAuYnl0ZXMpO1xuICAgICAgICBjb25zdCBoZXggPSB0aGlzLmJ5dGVzLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgaWYgKFhSUF9IRVhfUkVHRVgudGVzdChoZXgpKSB7XG4gICAgICAgICAgICB0aGlzLl9pc28gPSAnWFJQJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChTVEFOREFSRF9GT1JNQVRfSEVYX1JFR0VYLnRlc3QoaGV4KSkge1xuICAgICAgICAgICAgdGhpcy5faXNvID0gaXNvQ29kZUZyb21IZXgodGhpcy5ieXRlcy5zbGljZSgxMiwgMTUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBJU08gY29kZSBvZiB0aGlzIGN1cnJlbmN5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJU08gY29kZSBpZiBpdCBleGlzdHMsIGVsc2UgbnVsbFxuICAgICAqL1xuICAgIGlzbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIEN1cnJlbmN5IG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbCBDdXJyZW5jeSBvYmplY3Qgb3IgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjdXJyZW5jeVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEN1cnJlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VycmVuY3koYnl0ZXNGcm9tUmVwcmVzZW50YXRpb24odmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgQ3VycmVuY3kgZnJvbSB2YWx1ZSBnaXZlbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgY3VycmVuY3lcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEpTT04gcmVwcmVzZW50YXRpb25cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGlzbyA9IHRoaXMuaXNvKCk7XG4gICAgICAgIGlmIChpc28gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpc287XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DdXJyZW5jeSA9IEN1cnJlbmN5O1xuQ3VycmVuY3kuWFJQID0gbmV3IEN1cnJlbmN5KGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygyMCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VycmVuY3kuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/currency.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-128.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/hash-128.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Hash128 = void 0;\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Hash with a width of 128 bits\n */\nclass Hash128 extends hash_1.Hash {\n    constructor(bytes) {\n        if (bytes && bytes.byteLength === 0) {\n            bytes = Hash128.ZERO_128.bytes;\n        }\n        super(bytes !== null && bytes !== void 0 ? bytes : Hash128.ZERO_128.bytes);\n    }\n    /**\n     * Get the hex representation of a hash-128 bytes, allowing unset\n     *\n     * @returns hex String of this.bytes\n     */\n    toHex() {\n        const hex = this.toBytes().toString('hex').toUpperCase();\n        if (/^0+$/.exec(hex)) {\n            return '';\n        }\n        return hex;\n    }\n}\nexports.Hash128 = Hash128;\nHash128.width = 16;\nHash128.ZERO_128 = new Hash128(buffer_1.Buffer.alloc(Hash128.width));\n//# sourceMappingURL=hash-128.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2hhc2gtMTI4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsMkVBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvaGFzaC0xMjguanM/OWMyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzaDEyOCA9IHZvaWQgMDtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBIYXNoIHdpdGggYSB3aWR0aCBvZiAxMjggYml0c1xuICovXG5jbGFzcyBIYXNoMTI4IGV4dGVuZHMgaGFzaF8xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIGlmIChieXRlcyAmJiBieXRlcy5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBieXRlcyA9IEhhc2gxMjguWkVST18xMjguYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYnl0ZXMgIT09IG51bGwgJiYgYnl0ZXMgIT09IHZvaWQgMCA/IGJ5dGVzIDogSGFzaDEyOC5aRVJPXzEyOC5ieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIGEgaGFzaC0xMjggYnl0ZXMsIGFsbG93aW5nIHVuc2V0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBoZXggU3RyaW5nIG9mIHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICB0b0hleCgpIHtcbiAgICAgICAgY29uc3QgaGV4ID0gdGhpcy50b0J5dGVzKCkudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmICgvXjArJC8uZXhlYyhoZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICB9XG59XG5leHBvcnRzLkhhc2gxMjggPSBIYXNoMTI4O1xuSGFzaDEyOC53aWR0aCA9IDE2O1xuSGFzaDEyOC5aRVJPXzEyOCA9IG5ldyBIYXNoMTI4KGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhIYXNoMTI4LndpZHRoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLTEyOC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-128.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-160.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/hash-160.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Hash160 = void 0;\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Hash with a width of 160 bits\n */\nclass Hash160 extends hash_1.Hash {\n    constructor(bytes) {\n        if (bytes && bytes.byteLength === 0) {\n            bytes = Hash160.ZERO_160.bytes;\n        }\n        super(bytes !== null && bytes !== void 0 ? bytes : Hash160.ZERO_160.bytes);\n    }\n}\nexports.Hash160 = Hash160;\nHash160.width = 20;\nHash160.ZERO_160 = new Hash160(buffer_1.Buffer.alloc(Hash160.width));\n//# sourceMappingURL=hash-160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2hhc2gtMTYwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsMkVBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvaGFzaC0xNjAuanM/NTM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzaDE2MCA9IHZvaWQgMDtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBIYXNoIHdpdGggYSB3aWR0aCBvZiAxNjAgYml0c1xuICovXG5jbGFzcyBIYXNoMTYwIGV4dGVuZHMgaGFzaF8xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIGlmIChieXRlcyAmJiBieXRlcy5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBieXRlcyA9IEhhc2gxNjAuWkVST18xNjAuYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYnl0ZXMgIT09IG51bGwgJiYgYnl0ZXMgIT09IHZvaWQgMCA/IGJ5dGVzIDogSGFzaDE2MC5aRVJPXzE2MC5ieXRlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNoMTYwID0gSGFzaDE2MDtcbkhhc2gxNjAud2lkdGggPSAyMDtcbkhhc2gxNjAuWkVST18xNjAgPSBuZXcgSGFzaDE2MChidWZmZXJfMS5CdWZmZXIuYWxsb2MoSGFzaDE2MC53aWR0aCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC0xNjAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-160.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-256.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/hash-256.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Hash256 = void 0;\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Hash with a width of 256 bits\n */\nclass Hash256 extends hash_1.Hash {\n    constructor(bytes) {\n        super(bytes !== null && bytes !== void 0 ? bytes : Hash256.ZERO_256.bytes);\n    }\n}\nexports.Hash256 = Hash256;\nHash256.width = 32;\nHash256.ZERO_256 = new Hash256(buffer_1.Buffer.alloc(Hash256.width));\n//# sourceMappingURL=hash-256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2hhc2gtMjU2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsMkVBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvaGFzaC0yNTYuanM/ZjIyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzaDI1NiA9IHZvaWQgMDtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBIYXNoIHdpdGggYSB3aWR0aCBvZiAyNTYgYml0c1xuICovXG5jbGFzcyBIYXNoMjU2IGV4dGVuZHMgaGFzaF8xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGJ5dGVzICE9PSBudWxsICYmIGJ5dGVzICE9PSB2b2lkIDAgPyBieXRlcyA6IEhhc2gyNTYuWkVST18yNTYuYnl0ZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaDI1NiA9IEhhc2gyNTY7XG5IYXNoMjU2LndpZHRoID0gMzI7XG5IYXNoMjU2LlpFUk9fMjU2ID0gbmV3IEhhc2gyNTYoYnVmZmVyXzEuQnVmZmVyLmFsbG9jKEhhc2gyNTYud2lkdGgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/hash.js":
/*!*************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/hash.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Hash = void 0;\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Base class defining how to encode and decode hashes\n */\nclass Hash extends serialized_type_1.Comparable {\n    constructor(bytes) {\n        super(bytes);\n        if (this.bytes.byteLength !== this.constructor.width) {\n            throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);\n        }\n    }\n    /**\n     * Construct a Hash object from an existing Hash object or a hex-string\n     *\n     * @param value A hash object or hex-string of a hash\n     */\n    static from(value) {\n        if (value instanceof this) {\n            return value;\n        }\n        if (typeof value === 'string') {\n            return new this(buffer_1.Buffer.from(value, 'hex'));\n        }\n        throw new Error('Cannot construct Hash from given value');\n    }\n    /**\n     * Read a Hash object from a BinaryParser\n     *\n     * @param parser BinaryParser to read the hash from\n     * @param hint length of the bytes to read, optional\n     */\n    static fromParser(parser, hint) {\n        return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));\n    }\n    /**\n     * Overloaded operator for comparing two hash objects\n     *\n     * @param other The Hash to compare this to\n     */\n    compareTo(other) {\n        return this.bytes.compare(this.constructor.from(other).bytes);\n    }\n    /**\n     * @returns the hex-string representation of this Hash\n     */\n    toString() {\n        return this.toHex();\n    }\n    /**\n     * Returns four bits at the specified depth within a hash\n     *\n     * @param depth The depth of the four bits\n     * @returns The number represented by the four bits\n     */\n    nibblet(depth) {\n        const byteIx = depth > 0 ? (depth / 2) | 0 : 0;\n        let b = this.bytes[byteIx];\n        if (depth % 2 === 0) {\n            b = (b & 0xf0) >>> 4;\n        }\n        else {\n            b = b & 0x0f;\n        }\n        return b;\n    }\n}\nexports.Hash = Hash;\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2hhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLDBCQUEwQixtQkFBTyxDQUFDLGlHQUFtQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2hhc2guanM/N2U1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzaCA9IHZvaWQgMDtcbmNvbnN0IHNlcmlhbGl6ZWRfdHlwZV8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplZC10eXBlXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogQmFzZSBjbGFzcyBkZWZpbmluZyBob3cgdG8gZW5jb2RlIGFuZCBkZWNvZGUgaGFzaGVzXG4gKi9cbmNsYXNzIEhhc2ggZXh0ZW5kcyBzZXJpYWxpemVkX3R5cGVfMS5Db21wYXJhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcihieXRlcyk7XG4gICAgICAgIGlmICh0aGlzLmJ5dGVzLmJ5dGVMZW5ndGggIT09IHRoaXMuY29uc3RydWN0b3Iud2lkdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBIYXNoIGxlbmd0aCAke3RoaXMuYnl0ZXMuYnl0ZUxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBIYXNoIG9iamVjdCBmcm9tIGFuIGV4aXN0aW5nIEhhc2ggb2JqZWN0IG9yIGEgaGV4LXN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEEgaGFzaCBvYmplY3Qgb3IgaGV4LXN0cmluZyBvZiBhIGhhc2hcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhidWZmZXJfMS5CdWZmZXIuZnJvbSh2YWx1ZSwgJ2hleCcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgSGFzaCBmcm9tIGdpdmVuIHZhbHVlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBIYXNoIG9iamVjdCBmcm9tIGEgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyc2VyIEJpbmFyeVBhcnNlciB0byByZWFkIHRoZSBoYXNoIGZyb21cbiAgICAgKiBAcGFyYW0gaGludCBsZW5ndGggb2YgdGhlIGJ5dGVzIHRvIHJlYWQsIG9wdGlvbmFsXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QYXJzZXIocGFyc2VyLCBoaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhwYXJzZXIucmVhZChoaW50ICE9PSBudWxsICYmIGhpbnQgIT09IHZvaWQgMCA/IGhpbnQgOiB0aGlzLndpZHRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJsb2FkZWQgb3BlcmF0b3IgZm9yIGNvbXBhcmluZyB0d28gaGFzaCBvYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIEhhc2ggdG8gY29tcGFyZSB0aGlzIHRvXG4gICAgICovXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmNvbXBhcmUodGhpcy5jb25zdHJ1Y3Rvci5mcm9tKG90aGVyKS5ieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSBoZXgtc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSGFzaFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZvdXIgYml0cyBhdCB0aGUgc3BlY2lmaWVkIGRlcHRoIHdpdGhpbiBhIGhhc2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGZvdXIgYml0c1xuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGZvdXIgYml0c1xuICAgICAqL1xuICAgIG5pYmJsZXQoZGVwdGgpIHtcbiAgICAgICAgY29uc3QgYnl0ZUl4ID0gZGVwdGggPiAwID8gKGRlcHRoIC8gMikgfCAwIDogMDtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ5dGVzW2J5dGVJeF07XG4gICAgICAgIGlmIChkZXB0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIGIgPSAoYiAmIDB4ZjApID4+PiA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYiA9IGIgJiAweDBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Vector256 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.STObject = exports.STArray = exports.PathSet = exports.Hash256 = exports.Hash160 = exports.Hash128 = exports.Currency = exports.Blob = exports.Amount = exports.AccountID = exports.coreTypes = void 0;\nconst account_id_1 = __webpack_require__(/*! ./account-id */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/account-id.js\");\nObject.defineProperty(exports, \"AccountID\", ({ enumerable: true, get: function () { return account_id_1.AccountID; } }));\nconst amount_1 = __webpack_require__(/*! ./amount */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/amount.js\");\nObject.defineProperty(exports, \"Amount\", ({ enumerable: true, get: function () { return amount_1.Amount; } }));\nconst blob_1 = __webpack_require__(/*! ./blob */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/blob.js\");\nObject.defineProperty(exports, \"Blob\", ({ enumerable: true, get: function () { return blob_1.Blob; } }));\nconst currency_1 = __webpack_require__(/*! ./currency */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/currency.js\");\nObject.defineProperty(exports, \"Currency\", ({ enumerable: true, get: function () { return currency_1.Currency; } }));\nconst hash_128_1 = __webpack_require__(/*! ./hash-128 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-128.js\");\nObject.defineProperty(exports, \"Hash128\", ({ enumerable: true, get: function () { return hash_128_1.Hash128; } }));\nconst hash_160_1 = __webpack_require__(/*! ./hash-160 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-160.js\");\nObject.defineProperty(exports, \"Hash160\", ({ enumerable: true, get: function () { return hash_160_1.Hash160; } }));\nconst hash_256_1 = __webpack_require__(/*! ./hash-256 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-256.js\");\nObject.defineProperty(exports, \"Hash256\", ({ enumerable: true, get: function () { return hash_256_1.Hash256; } }));\nconst issue_1 = __webpack_require__(/*! ./issue */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/issue.js\");\nconst path_set_1 = __webpack_require__(/*! ./path-set */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/path-set.js\");\nObject.defineProperty(exports, \"PathSet\", ({ enumerable: true, get: function () { return path_set_1.PathSet; } }));\nconst st_array_1 = __webpack_require__(/*! ./st-array */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/st-array.js\");\nObject.defineProperty(exports, \"STArray\", ({ enumerable: true, get: function () { return st_array_1.STArray; } }));\nconst st_object_1 = __webpack_require__(/*! ./st-object */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/st-object.js\");\nObject.defineProperty(exports, \"STObject\", ({ enumerable: true, get: function () { return st_object_1.STObject; } }));\nconst uint_16_1 = __webpack_require__(/*! ./uint-16 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-16.js\");\nObject.defineProperty(exports, \"UInt16\", ({ enumerable: true, get: function () { return uint_16_1.UInt16; } }));\nconst uint_32_1 = __webpack_require__(/*! ./uint-32 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-32.js\");\nObject.defineProperty(exports, \"UInt32\", ({ enumerable: true, get: function () { return uint_32_1.UInt32; } }));\nconst uint_64_1 = __webpack_require__(/*! ./uint-64 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-64.js\");\nObject.defineProperty(exports, \"UInt64\", ({ enumerable: true, get: function () { return uint_64_1.UInt64; } }));\nconst uint_8_1 = __webpack_require__(/*! ./uint-8 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-8.js\");\nObject.defineProperty(exports, \"UInt8\", ({ enumerable: true, get: function () { return uint_8_1.UInt8; } }));\nconst vector_256_1 = __webpack_require__(/*! ./vector-256 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/vector-256.js\");\nObject.defineProperty(exports, \"Vector256\", ({ enumerable: true, get: function () { return vector_256_1.Vector256; } }));\nconst xchain_bridge_1 = __webpack_require__(/*! ./xchain-bridge */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/xchain-bridge.js\");\nconst enums_1 = __webpack_require__(/*! ../enums */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/index.js\");\nconst coreTypes = {\n    AccountID: account_id_1.AccountID,\n    Amount: amount_1.Amount,\n    Blob: blob_1.Blob,\n    Currency: currency_1.Currency,\n    Hash128: hash_128_1.Hash128,\n    Hash160: hash_160_1.Hash160,\n    Hash256: hash_256_1.Hash256,\n    Issue: issue_1.Issue,\n    PathSet: path_set_1.PathSet,\n    STArray: st_array_1.STArray,\n    STObject: st_object_1.STObject,\n    UInt8: uint_8_1.UInt8,\n    UInt16: uint_16_1.UInt16,\n    UInt32: uint_32_1.UInt32,\n    UInt64: uint_64_1.UInt64,\n    Vector256: vector_256_1.Vector256,\n    XChainBridge: xchain_bridge_1.XChainBridge,\n};\nexports.coreTypes = coreTypes;\n// Ensures that the DEFAULT_DEFINITIONS object connects these types to fields for serializing/deserializing\n// This is done here instead of in enums/index.ts to avoid a circular dependency\n// because some of the above types depend on BinarySerializer which depends on enums/index.ts.\nenums_1.DEFAULT_DEFINITIONS.associateTypes(coreTypes);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQzVSLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFjO0FBQzNDLDZDQUE0QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN0SCxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBVTtBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsZUFBZSxtQkFBTyxDQUFDLDJFQUFRO0FBQy9CLHdDQUF1QyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUN0RyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBWTtBQUN2Qyw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkMsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILG1CQUFtQixtQkFBTyxDQUFDLG1GQUFZO0FBQ3ZDLDJDQUEwQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNoSCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBWTtBQUN2QywyQ0FBMEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDaEgsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkMsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILG1CQUFtQixtQkFBTyxDQUFDLG1GQUFZO0FBQ3ZDLDJDQUEwQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNoSCxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBYTtBQUN6Qyw0Q0FBMkMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbkgsa0JBQWtCLG1CQUFPLENBQUMsaUZBQVc7QUFDckMsMENBQXlDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQzdHLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFXO0FBQ3JDLDBDQUF5QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM3RyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBVztBQUNyQywwQ0FBeUMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDN0csaUJBQWlCLG1CQUFPLENBQUMsK0VBQVU7QUFDbkMseUNBQXdDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQzFHLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFjO0FBQzNDLDZDQUE0QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN0SCx3QkFBd0IsbUJBQU8sQ0FBQyw2RkFBaUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy9pbmRleC5qcz85M2U0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WZWN0b3IyNTYgPSBleHBvcnRzLlVJbnQ2NCA9IGV4cG9ydHMuVUludDMyID0gZXhwb3J0cy5VSW50MTYgPSBleHBvcnRzLlVJbnQ4ID0gZXhwb3J0cy5TVE9iamVjdCA9IGV4cG9ydHMuU1RBcnJheSA9IGV4cG9ydHMuUGF0aFNldCA9IGV4cG9ydHMuSGFzaDI1NiA9IGV4cG9ydHMuSGFzaDE2MCA9IGV4cG9ydHMuSGFzaDEyOCA9IGV4cG9ydHMuQ3VycmVuY3kgPSBleHBvcnRzLkJsb2IgPSBleHBvcnRzLkFtb3VudCA9IGV4cG9ydHMuQWNjb3VudElEID0gZXhwb3J0cy5jb3JlVHlwZXMgPSB2b2lkIDA7XG5jb25zdCBhY2NvdW50X2lkXzEgPSByZXF1aXJlKFwiLi9hY2NvdW50LWlkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWNjb3VudElEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50X2lkXzEuQWNjb3VudElEOyB9IH0pO1xuY29uc3QgYW1vdW50XzEgPSByZXF1aXJlKFwiLi9hbW91bnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbW91bnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFtb3VudF8xLkFtb3VudDsgfSB9KTtcbmNvbnN0IGJsb2JfMSA9IHJlcXVpcmUoXCIuL2Jsb2JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCbG9iXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBibG9iXzEuQmxvYjsgfSB9KTtcbmNvbnN0IGN1cnJlbmN5XzEgPSByZXF1aXJlKFwiLi9jdXJyZW5jeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkN1cnJlbmN5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW5jeV8xLkN1cnJlbmN5OyB9IH0pO1xuY29uc3QgaGFzaF8xMjhfMSA9IHJlcXVpcmUoXCIuL2hhc2gtMTI4XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGFzaDEyOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaF8xMjhfMS5IYXNoMTI4OyB9IH0pO1xuY29uc3QgaGFzaF8xNjBfMSA9IHJlcXVpcmUoXCIuL2hhc2gtMTYwXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGFzaDE2MFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaF8xNjBfMS5IYXNoMTYwOyB9IH0pO1xuY29uc3QgaGFzaF8yNTZfMSA9IHJlcXVpcmUoXCIuL2hhc2gtMjU2XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGFzaDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaF8yNTZfMS5IYXNoMjU2OyB9IH0pO1xuY29uc3QgaXNzdWVfMSA9IHJlcXVpcmUoXCIuL2lzc3VlXCIpO1xuY29uc3QgcGF0aF9zZXRfMSA9IHJlcXVpcmUoXCIuL3BhdGgtc2V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGF0aFNldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGF0aF9zZXRfMS5QYXRoU2V0OyB9IH0pO1xuY29uc3Qgc3RfYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3N0LWFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU1RBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RfYXJyYXlfMS5TVEFycmF5OyB9IH0pO1xuY29uc3Qgc3Rfb2JqZWN0XzEgPSByZXF1aXJlKFwiLi9zdC1vYmplY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTVE9iamVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Rfb2JqZWN0XzEuU1RPYmplY3Q7IH0gfSk7XG5jb25zdCB1aW50XzE2XzEgPSByZXF1aXJlKFwiLi91aW50LTE2XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVUludDE2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1aW50XzE2XzEuVUludDE2OyB9IH0pO1xuY29uc3QgdWludF8zMl8xID0gcmVxdWlyZShcIi4vdWludC0zMlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVJbnQzMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWludF8zMl8xLlVJbnQzMjsgfSB9KTtcbmNvbnN0IHVpbnRfNjRfMSA9IHJlcXVpcmUoXCIuL3VpbnQtNjRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVSW50NjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVpbnRfNjRfMS5VSW50NjQ7IH0gfSk7XG5jb25zdCB1aW50XzhfMSA9IHJlcXVpcmUoXCIuL3VpbnQtOFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVJbnQ4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1aW50XzhfMS5VSW50ODsgfSB9KTtcbmNvbnN0IHZlY3Rvcl8yNTZfMSA9IHJlcXVpcmUoXCIuL3ZlY3Rvci0yNTZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWZWN0b3IyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZlY3Rvcl8yNTZfMS5WZWN0b3IyNTY7IH0gfSk7XG5jb25zdCB4Y2hhaW5fYnJpZGdlXzEgPSByZXF1aXJlKFwiLi94Y2hhaW4tYnJpZGdlXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuLi9lbnVtc1wiKTtcbmNvbnN0IGNvcmVUeXBlcyA9IHtcbiAgICBBY2NvdW50SUQ6IGFjY291bnRfaWRfMS5BY2NvdW50SUQsXG4gICAgQW1vdW50OiBhbW91bnRfMS5BbW91bnQsXG4gICAgQmxvYjogYmxvYl8xLkJsb2IsXG4gICAgQ3VycmVuY3k6IGN1cnJlbmN5XzEuQ3VycmVuY3ksXG4gICAgSGFzaDEyODogaGFzaF8xMjhfMS5IYXNoMTI4LFxuICAgIEhhc2gxNjA6IGhhc2hfMTYwXzEuSGFzaDE2MCxcbiAgICBIYXNoMjU2OiBoYXNoXzI1Nl8xLkhhc2gyNTYsXG4gICAgSXNzdWU6IGlzc3VlXzEuSXNzdWUsXG4gICAgUGF0aFNldDogcGF0aF9zZXRfMS5QYXRoU2V0LFxuICAgIFNUQXJyYXk6IHN0X2FycmF5XzEuU1RBcnJheSxcbiAgICBTVE9iamVjdDogc3Rfb2JqZWN0XzEuU1RPYmplY3QsXG4gICAgVUludDg6IHVpbnRfOF8xLlVJbnQ4LFxuICAgIFVJbnQxNjogdWludF8xNl8xLlVJbnQxNixcbiAgICBVSW50MzI6IHVpbnRfMzJfMS5VSW50MzIsXG4gICAgVUludDY0OiB1aW50XzY0XzEuVUludDY0LFxuICAgIFZlY3RvcjI1NjogdmVjdG9yXzI1Nl8xLlZlY3RvcjI1NixcbiAgICBYQ2hhaW5CcmlkZ2U6IHhjaGFpbl9icmlkZ2VfMS5YQ2hhaW5CcmlkZ2UsXG59O1xuZXhwb3J0cy5jb3JlVHlwZXMgPSBjb3JlVHlwZXM7XG4vLyBFbnN1cmVzIHRoYXQgdGhlIERFRkFVTFRfREVGSU5JVElPTlMgb2JqZWN0IGNvbm5lY3RzIHRoZXNlIHR5cGVzIHRvIGZpZWxkcyBmb3Igc2VyaWFsaXppbmcvZGVzZXJpYWxpemluZ1xuLy8gVGhpcyBpcyBkb25lIGhlcmUgaW5zdGVhZCBvZiBpbiBlbnVtcy9pbmRleC50cyB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbi8vIGJlY2F1c2Ugc29tZSBvZiB0aGUgYWJvdmUgdHlwZXMgZGVwZW5kIG9uIEJpbmFyeVNlcmlhbGl6ZXIgd2hpY2ggZGVwZW5kcyBvbiBlbnVtcy9pbmRleC50cy5cbmVudW1zXzEuREVGQVVMVF9ERUZJTklUSU9OUy5hc3NvY2lhdGVUeXBlcyhjb3JlVHlwZXMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/issue.js":
/*!**************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/issue.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Issue = void 0;\nconst binary_parser_1 = __webpack_require__(/*! ../serdes/binary-parser */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js\");\nconst account_id_1 = __webpack_require__(/*! ./account-id */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/account-id.js\");\nconst currency_1 = __webpack_require__(/*! ./currency */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/currency.js\");\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Type guard for AmountObject\n */\nfunction isIssueObject(arg) {\n    const keys = Object.keys(arg).sort();\n    if (keys.length === 1) {\n        return keys[0] === 'currency';\n    }\n    return keys.length === 2 && keys[0] === 'currency' && keys[1] === 'issuer';\n}\n/**\n * Class for serializing/Deserializing Amounts\n */\nclass Issue extends serialized_type_1.SerializedType {\n    constructor(bytes) {\n        super(bytes !== null && bytes !== void 0 ? bytes : Issue.ZERO_ISSUED_CURRENCY.bytes);\n    }\n    /**\n     * Construct an amount from an IOU or string amount\n     *\n     * @param value An Amount, object representing an IOU, or a string\n     *     representing an integer amount\n     * @returns An Amount object\n     */\n    static from(value) {\n        if (value instanceof Issue) {\n            return value;\n        }\n        if (isIssueObject(value)) {\n            const currency = currency_1.Currency.from(value.currency).toBytes();\n            if (value.issuer == null) {\n                return new Issue(currency);\n            }\n            const issuer = account_id_1.AccountID.from(value.issuer).toBytes();\n            return new Issue(buffer_1.Buffer.concat([currency, issuer]));\n        }\n        throw new Error('Invalid type to construct an Amount');\n    }\n    /**\n     * Read an amount from a BinaryParser\n     *\n     * @param parser BinaryParser to read the Amount from\n     * @returns An Amount object\n     */\n    static fromParser(parser) {\n        const currency = parser.read(20);\n        if (new currency_1.Currency(currency).toJSON() === 'XRP') {\n            return new Issue(currency);\n        }\n        const currencyAndIssuer = [currency, parser.read(20)];\n        return new Issue(buffer_1.Buffer.concat(currencyAndIssuer));\n    }\n    /**\n     * Get the JSON representation of this Amount\n     *\n     * @returns the JSON interpretation of this.bytes\n     */\n    toJSON() {\n        const parser = new binary_parser_1.BinaryParser(this.toString());\n        const currency = currency_1.Currency.fromParser(parser);\n        if (currency.toJSON() === 'XRP') {\n            return { currency: currency.toJSON() };\n        }\n        const issuer = account_id_1.AccountID.fromParser(parser);\n        return {\n            currency: currency.toJSON(),\n            issuer: issuer.toJSON(),\n        };\n    }\n}\nexports.Issue = Issue;\nIssue.ZERO_ISSUED_CURRENCY = new Issue(buffer_1.Buffer.alloc(20));\n//# sourceMappingURL=issue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2lzc3VlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYix3QkFBd0IsbUJBQU8sQ0FBQyxzR0FBeUI7QUFDekQscUJBQXFCLG1CQUFPLENBQUMsdUZBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsaUdBQW1CO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy9pc3N1ZS5qcz9hNGRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc3N1ZSA9IHZvaWQgMDtcbmNvbnN0IGJpbmFyeV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9zZXJkZXMvYmluYXJ5LXBhcnNlclwiKTtcbmNvbnN0IGFjY291bnRfaWRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnQtaWRcIik7XG5jb25zdCBjdXJyZW5jeV8xID0gcmVxdWlyZShcIi4vY3VycmVuY3lcIik7XG5jb25zdCBzZXJpYWxpemVkX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZWQtdHlwZVwiKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIEFtb3VudE9iamVjdFxuICovXG5mdW5jdGlvbiBpc0lzc3VlT2JqZWN0KGFyZykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGtleXNbMF0gPT09ICdjdXJyZW5jeSc7XG4gICAgfVxuICAgIHJldHVybiBrZXlzLmxlbmd0aCA9PT0gMiAmJiBrZXlzWzBdID09PSAnY3VycmVuY3knICYmIGtleXNbMV0gPT09ICdpc3N1ZXInO1xufVxuLyoqXG4gKiBDbGFzcyBmb3Igc2VyaWFsaXppbmcvRGVzZXJpYWxpemluZyBBbW91bnRzXG4gKi9cbmNsYXNzIElzc3VlIGV4dGVuZHMgc2VyaWFsaXplZF90eXBlXzEuU2VyaWFsaXplZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGJ5dGVzICE9PSBudWxsICYmIGJ5dGVzICE9PSB2b2lkIDAgPyBieXRlcyA6IElzc3VlLlpFUk9fSVNTVUVEX0NVUlJFTkNZLmJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIGFtb3VudCBmcm9tIGFuIElPVSBvciBzdHJpbmcgYW1vdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgQW4gQW1vdW50LCBvYmplY3QgcmVwcmVzZW50aW5nIGFuIElPVSwgb3IgYSBzdHJpbmdcbiAgICAgKiAgICAgcmVwcmVzZW50aW5nIGFuIGludGVnZXIgYW1vdW50XG4gICAgICogQHJldHVybnMgQW4gQW1vdW50IG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElzc3VlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSXNzdWVPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW5jeSA9IGN1cnJlbmN5XzEuQ3VycmVuY3kuZnJvbSh2YWx1ZS5jdXJyZW5jeSkudG9CeXRlcygpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmlzc3VlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJc3N1ZShjdXJyZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXIgPSBhY2NvdW50X2lkXzEuQWNjb3VudElELmZyb20odmFsdWUuaXNzdWVyKS50b0J5dGVzKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElzc3VlKGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW2N1cnJlbmN5LCBpc3N1ZXJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUgdG8gY29uc3RydWN0IGFuIEFtb3VudCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGFuIGFtb3VudCBmcm9tIGEgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyc2VyIEJpbmFyeVBhcnNlciB0byByZWFkIHRoZSBBbW91bnQgZnJvbVxuICAgICAqIEByZXR1cm5zIEFuIEFtb3VudCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBhcnNlcihwYXJzZXIpIHtcbiAgICAgICAgY29uc3QgY3VycmVuY3kgPSBwYXJzZXIucmVhZCgyMCk7XG4gICAgICAgIGlmIChuZXcgY3VycmVuY3lfMS5DdXJyZW5jeShjdXJyZW5jeSkudG9KU09OKCkgPT09ICdYUlAnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElzc3VlKGN1cnJlbmN5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW5jeUFuZElzc3VlciA9IFtjdXJyZW5jeSwgcGFyc2VyLnJlYWQoMjApXTtcbiAgICAgICAgcmV0dXJuIG5ldyBJc3N1ZShidWZmZXJfMS5CdWZmZXIuY29uY2F0KGN1cnJlbmN5QW5kSXNzdWVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEFtb3VudFxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIEpTT04gaW50ZXJwcmV0YXRpb24gb2YgdGhpcy5ieXRlc1xuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IGJpbmFyeV9wYXJzZXJfMS5CaW5hcnlQYXJzZXIodGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgY29uc3QgY3VycmVuY3kgPSBjdXJyZW5jeV8xLkN1cnJlbmN5LmZyb21QYXJzZXIocGFyc2VyKTtcbiAgICAgICAgaWYgKGN1cnJlbmN5LnRvSlNPTigpID09PSAnWFJQJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgY3VycmVuY3k6IGN1cnJlbmN5LnRvSlNPTigpIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNzdWVyID0gYWNjb3VudF9pZF8xLkFjY291bnRJRC5mcm9tUGFyc2VyKHBhcnNlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3kudG9KU09OKCksXG4gICAgICAgICAgICBpc3N1ZXI6IGlzc3Vlci50b0pTT04oKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLklzc3VlID0gSXNzdWU7XG5Jc3N1ZS5aRVJPX0lTU1VFRF9DVVJSRU5DWSA9IG5ldyBJc3N1ZShidWZmZXJfMS5CdWZmZXIuYWxsb2MoMjApKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzc3VlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/issue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/path-set.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/path-set.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PathSet = void 0;\nconst account_id_1 = __webpack_require__(/*! ./account-id */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/account-id.js\");\nconst currency_1 = __webpack_require__(/*! ./currency */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/currency.js\");\nconst binary_parser_1 = __webpack_require__(/*! ../serdes/binary-parser */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js\");\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Constants for separating Paths in a PathSet\n */\nconst PATHSET_END_BYTE = 0x00;\nconst PATH_SEPARATOR_BYTE = 0xff;\n/**\n * Constant for masking types of a Hop\n */\nconst TYPE_ACCOUNT = 0x01;\nconst TYPE_CURRENCY = 0x10;\nconst TYPE_ISSUER = 0x20;\n/**\n * TypeGuard for HopObject\n */\nfunction isHopObject(arg) {\n    return (arg.issuer !== undefined ||\n        arg.account !== undefined ||\n        arg.currency !== undefined);\n}\n/**\n * TypeGuard for PathSet\n */\nfunction isPathSet(arg) {\n    return ((Array.isArray(arg) && arg.length === 0) ||\n        (Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0) ||\n        (Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0])));\n}\n/**\n * Serialize and Deserialize a Hop\n */\nclass Hop extends serialized_type_1.SerializedType {\n    /**\n     * Create a Hop from a HopObject\n     *\n     * @param value Either a hop or HopObject to create a hop with\n     * @returns a Hop\n     */\n    static from(value) {\n        if (value instanceof Hop) {\n            return value;\n        }\n        const bytes = [buffer_1.Buffer.from([0])];\n        if (value.account) {\n            bytes.push(account_id_1.AccountID.from(value.account).toBytes());\n            bytes[0][0] |= TYPE_ACCOUNT;\n        }\n        if (value.currency) {\n            bytes.push(currency_1.Currency.from(value.currency).toBytes());\n            bytes[0][0] |= TYPE_CURRENCY;\n        }\n        if (value.issuer) {\n            bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());\n            bytes[0][0] |= TYPE_ISSUER;\n        }\n        return new Hop(buffer_1.Buffer.concat(bytes));\n    }\n    /**\n     * Construct a Hop from a BinaryParser\n     *\n     * @param parser BinaryParser to read the Hop from\n     * @returns a Hop\n     */\n    static fromParser(parser) {\n        const type = parser.readUInt8();\n        const bytes = [buffer_1.Buffer.from([type])];\n        if (type & TYPE_ACCOUNT) {\n            bytes.push(parser.read(account_id_1.AccountID.width));\n        }\n        if (type & TYPE_CURRENCY) {\n            bytes.push(parser.read(currency_1.Currency.width));\n        }\n        if (type & TYPE_ISSUER) {\n            bytes.push(parser.read(account_id_1.AccountID.width));\n        }\n        return new Hop(buffer_1.Buffer.concat(bytes));\n    }\n    /**\n     * Get the JSON interpretation of this hop\n     *\n     * @returns a HopObject, an JS object with optional account, issuer, and currency\n     */\n    toJSON() {\n        const hopParser = new binary_parser_1.BinaryParser(this.bytes.toString('hex'));\n        const type = hopParser.readUInt8();\n        let account, currency, issuer;\n        if (type & TYPE_ACCOUNT) {\n            account = account_id_1.AccountID.fromParser(hopParser).toJSON();\n        }\n        if (type & TYPE_CURRENCY) {\n            currency = currency_1.Currency.fromParser(hopParser).toJSON();\n        }\n        if (type & TYPE_ISSUER) {\n            issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();\n        }\n        const result = {};\n        if (account) {\n            result.account = account;\n        }\n        if (issuer) {\n            result.issuer = issuer;\n        }\n        if (currency) {\n            result.currency = currency;\n        }\n        return result;\n    }\n    /**\n     * get a number representing the type of this hop\n     *\n     * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop\n     */\n    type() {\n        return this.bytes[0];\n    }\n}\n/**\n * Class for serializing/deserializing Paths\n */\nclass Path extends serialized_type_1.SerializedType {\n    /**\n     * construct a Path from an array of Hops\n     *\n     * @param value Path or array of HopObjects to construct a Path\n     * @returns the Path\n     */\n    static from(value) {\n        if (value instanceof Path) {\n            return value;\n        }\n        const bytes = [];\n        value.forEach((hop) => {\n            bytes.push(Hop.from(hop).toBytes());\n        });\n        return new Path(buffer_1.Buffer.concat(bytes));\n    }\n    /**\n     * Read a Path from a BinaryParser\n     *\n     * @param parser BinaryParser to read Path from\n     * @returns the Path represented by the bytes read from the BinaryParser\n     */\n    static fromParser(parser) {\n        const bytes = [];\n        while (!parser.end()) {\n            bytes.push(Hop.fromParser(parser).toBytes());\n            if (parser.peek() === PATHSET_END_BYTE ||\n                parser.peek() === PATH_SEPARATOR_BYTE) {\n                break;\n            }\n        }\n        return new Path(buffer_1.Buffer.concat(bytes));\n    }\n    /**\n     * Get the JSON representation of this Path\n     *\n     * @returns an Array of HopObject constructed from this.bytes\n     */\n    toJSON() {\n        const json = [];\n        const pathParser = new binary_parser_1.BinaryParser(this.toString());\n        while (!pathParser.end()) {\n            json.push(Hop.fromParser(pathParser).toJSON());\n        }\n        return json;\n    }\n}\n/**\n * Deserialize and Serialize the PathSet type\n */\nclass PathSet extends serialized_type_1.SerializedType {\n    /**\n     * Construct a PathSet from an Array of Arrays representing paths\n     *\n     * @param value A PathSet or Array of Array of HopObjects\n     * @returns the PathSet constructed from value\n     */\n    static from(value) {\n        if (value instanceof PathSet) {\n            return value;\n        }\n        if (isPathSet(value)) {\n            const bytes = [];\n            value.forEach((path) => {\n                bytes.push(Path.from(path).toBytes());\n                bytes.push(buffer_1.Buffer.from([PATH_SEPARATOR_BYTE]));\n            });\n            bytes[bytes.length - 1] = buffer_1.Buffer.from([PATHSET_END_BYTE]);\n            return new PathSet(buffer_1.Buffer.concat(bytes));\n        }\n        throw new Error('Cannot construct PathSet from given value');\n    }\n    /**\n     * Construct a PathSet from a BinaryParser\n     *\n     * @param parser A BinaryParser to read PathSet from\n     * @returns the PathSet read from parser\n     */\n    static fromParser(parser) {\n        const bytes = [];\n        while (!parser.end()) {\n            bytes.push(Path.fromParser(parser).toBytes());\n            bytes.push(parser.read(1));\n            if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {\n                break;\n            }\n        }\n        return new PathSet(buffer_1.Buffer.concat(bytes));\n    }\n    /**\n     * Get the JSON representation of this PathSet\n     *\n     * @returns an Array of Array of HopObjects, representing this PathSet\n     */\n    toJSON() {\n        const json = [];\n        const pathParser = new binary_parser_1.BinaryParser(this.toString());\n        while (!pathParser.end()) {\n            json.push(Path.fromParser(pathParser).toJSON());\n            pathParser.skip(1);\n        }\n        return json;\n    }\n}\nexports.PathSet = PathSet;\n//# sourceMappingURL=path-set.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3BhdGgtc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBWTtBQUN2Qyx3QkFBd0IsbUJBQU8sQ0FBQyxzR0FBeUI7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsaUdBQW1CO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy9wYXRoLXNldC5qcz82NjdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRoU2V0ID0gdm9pZCAwO1xuY29uc3QgYWNjb3VudF9pZF8xID0gcmVxdWlyZShcIi4vYWNjb3VudC1pZFwiKTtcbmNvbnN0IGN1cnJlbmN5XzEgPSByZXF1aXJlKFwiLi9jdXJyZW5jeVwiKTtcbmNvbnN0IGJpbmFyeV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9zZXJkZXMvYmluYXJ5LXBhcnNlclwiKTtcbmNvbnN0IHNlcmlhbGl6ZWRfdHlwZV8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplZC10eXBlXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogQ29uc3RhbnRzIGZvciBzZXBhcmF0aW5nIFBhdGhzIGluIGEgUGF0aFNldFxuICovXG5jb25zdCBQQVRIU0VUX0VORF9CWVRFID0gMHgwMDtcbmNvbnN0IFBBVEhfU0VQQVJBVE9SX0JZVEUgPSAweGZmO1xuLyoqXG4gKiBDb25zdGFudCBmb3IgbWFza2luZyB0eXBlcyBvZiBhIEhvcFxuICovXG5jb25zdCBUWVBFX0FDQ09VTlQgPSAweDAxO1xuY29uc3QgVFlQRV9DVVJSRU5DWSA9IDB4MTA7XG5jb25zdCBUWVBFX0lTU1VFUiA9IDB4MjA7XG4vKipcbiAqIFR5cGVHdWFyZCBmb3IgSG9wT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzSG9wT2JqZWN0KGFyZykge1xuICAgIHJldHVybiAoYXJnLmlzc3VlciAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGFyZy5hY2NvdW50ICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgYXJnLmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpO1xufVxuLyoqXG4gKiBUeXBlR3VhcmQgZm9yIFBhdGhTZXRcbiAqL1xuZnVuY3Rpb24gaXNQYXRoU2V0KGFyZykge1xuICAgIHJldHVybiAoKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShhcmcpICYmIEFycmF5LmlzQXJyYXkoYXJnWzBdKSAmJiBhcmdbMF0ubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShhcmcpICYmIEFycmF5LmlzQXJyYXkoYXJnWzBdKSAmJiBpc0hvcE9iamVjdChhcmdbMF1bMF0pKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSBhbmQgRGVzZXJpYWxpemUgYSBIb3BcbiAqL1xuY2xhc3MgSG9wIGV4dGVuZHMgc2VyaWFsaXplZF90eXBlXzEuU2VyaWFsaXplZFR5cGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEhvcCBmcm9tIGEgSG9wT2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgRWl0aGVyIGEgaG9wIG9yIEhvcE9iamVjdCB0byBjcmVhdGUgYSBob3Agd2l0aFxuICAgICAqIEByZXR1cm5zIGEgSG9wXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBbYnVmZmVyXzEuQnVmZmVyLmZyb20oWzBdKV07XG4gICAgICAgIGlmICh2YWx1ZS5hY2NvdW50KSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKGFjY291bnRfaWRfMS5BY2NvdW50SUQuZnJvbSh2YWx1ZS5hY2NvdW50KS50b0J5dGVzKCkpO1xuICAgICAgICAgICAgYnl0ZXNbMF1bMF0gfD0gVFlQRV9BQ0NPVU5UO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5jdXJyZW5jeSkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChjdXJyZW5jeV8xLkN1cnJlbmN5LmZyb20odmFsdWUuY3VycmVuY3kpLnRvQnl0ZXMoKSk7XG4gICAgICAgICAgICBieXRlc1swXVswXSB8PSBUWVBFX0NVUlJFTkNZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5pc3N1ZXIpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goYWNjb3VudF9pZF8xLkFjY291bnRJRC5mcm9tKHZhbHVlLmlzc3VlcikudG9CeXRlcygpKTtcbiAgICAgICAgICAgIGJ5dGVzWzBdWzBdIHw9IFRZUEVfSVNTVUVSO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSG9wKGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoYnl0ZXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgSG9wIGZyb20gYSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJzZXIgQmluYXJ5UGFyc2VyIHRvIHJlYWQgdGhlIEhvcCBmcm9tXG4gICAgICogQHJldHVybnMgYSBIb3BcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBhcnNlcihwYXJzZXIpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcnNlci5yZWFkVUludDgoKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBbYnVmZmVyXzEuQnVmZmVyLmZyb20oW3R5cGVdKV07XG4gICAgICAgIGlmICh0eXBlICYgVFlQRV9BQ0NPVU5UKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHBhcnNlci5yZWFkKGFjY291bnRfaWRfMS5BY2NvdW50SUQud2lkdGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSAmIFRZUEVfQ1VSUkVOQ1kpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2gocGFyc2VyLnJlYWQoY3VycmVuY3lfMS5DdXJyZW5jeS53aWR0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICYgVFlQRV9JU1NVRVIpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2gocGFyc2VyLnJlYWQoYWNjb3VudF9pZF8xLkFjY291bnRJRC53aWR0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSG9wKGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoYnl0ZXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBKU09OIGludGVycHJldGF0aW9uIG9mIHRoaXMgaG9wXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIEhvcE9iamVjdCwgYW4gSlMgb2JqZWN0IHdpdGggb3B0aW9uYWwgYWNjb3VudCwgaXNzdWVyLCBhbmQgY3VycmVuY3lcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGhvcFBhcnNlciA9IG5ldyBiaW5hcnlfcGFyc2VyXzEuQmluYXJ5UGFyc2VyKHRoaXMuYnl0ZXMudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IGhvcFBhcnNlci5yZWFkVUludDgoKTtcbiAgICAgICAgbGV0IGFjY291bnQsIGN1cnJlbmN5LCBpc3N1ZXI7XG4gICAgICAgIGlmICh0eXBlICYgVFlQRV9BQ0NPVU5UKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gYWNjb3VudF9pZF8xLkFjY291bnRJRC5mcm9tUGFyc2VyKGhvcFBhcnNlcikudG9KU09OKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgJiBUWVBFX0NVUlJFTkNZKSB7XG4gICAgICAgICAgICBjdXJyZW5jeSA9IGN1cnJlbmN5XzEuQ3VycmVuY3kuZnJvbVBhcnNlcihob3BQYXJzZXIpLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICYgVFlQRV9JU1NVRVIpIHtcbiAgICAgICAgICAgIGlzc3VlciA9IGFjY291bnRfaWRfMS5BY2NvdW50SUQuZnJvbVBhcnNlcihob3BQYXJzZXIpLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAoYWNjb3VudCkge1xuICAgICAgICAgICAgcmVzdWx0LmFjY291bnQgPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc3N1ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pc3N1ZXIgPSBpc3N1ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbmN5KSB7XG4gICAgICAgICAgICByZXN1bHQuY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoaXMgaG9wXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIG51bWJlciB0byBiZSBiaXR3aXNlIGFuZC1lZCB3aXRoIFRZUEVfIGNvbnN0YW50cyB0byBkZXNjcmliZSB0aGUgdHlwZXMgaW4gdGhlIGhvcFxuICAgICAqL1xuICAgIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzWzBdO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgZm9yIHNlcmlhbGl6aW5nL2Rlc2VyaWFsaXppbmcgUGF0aHNcbiAqL1xuY2xhc3MgUGF0aCBleHRlbmRzIHNlcmlhbGl6ZWRfdHlwZV8xLlNlcmlhbGl6ZWRUeXBlIHtcbiAgICAvKipcbiAgICAgKiBjb25zdHJ1Y3QgYSBQYXRoIGZyb20gYW4gYXJyYXkgb2YgSG9wc1xuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFBhdGggb3IgYXJyYXkgb2YgSG9wT2JqZWN0cyB0byBjb25zdHJ1Y3QgYSBQYXRoXG4gICAgICogQHJldHVybnMgdGhlIFBhdGhcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoaG9wKSA9PiB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKEhvcC5mcm9tKGhvcCkudG9CeXRlcygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aChidWZmZXJfMS5CdWZmZXIuY29uY2F0KGJ5dGVzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBQYXRoIGZyb20gYSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJzZXIgQmluYXJ5UGFyc2VyIHRvIHJlYWQgUGF0aCBmcm9tXG4gICAgICogQHJldHVybnMgdGhlIFBhdGggcmVwcmVzZW50ZWQgYnkgdGhlIGJ5dGVzIHJlYWQgZnJvbSB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QYXJzZXIocGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgICAgIHdoaWxlICghcGFyc2VyLmVuZCgpKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKEhvcC5mcm9tUGFyc2VyKHBhcnNlcikudG9CeXRlcygpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZXIucGVlaygpID09PSBQQVRIU0VUX0VORF9CWVRFIHx8XG4gICAgICAgICAgICAgICAgcGFyc2VyLnBlZWsoKSA9PT0gUEFUSF9TRVBBUkFUT1JfQllURSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGF0aChidWZmZXJfMS5CdWZmZXIuY29uY2F0KGJ5dGVzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFBhdGhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIEFycmF5IG9mIEhvcE9iamVjdCBjb25zdHJ1Y3RlZCBmcm9tIHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSBbXTtcbiAgICAgICAgY29uc3QgcGF0aFBhcnNlciA9IG5ldyBiaW5hcnlfcGFyc2VyXzEuQmluYXJ5UGFyc2VyKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIHdoaWxlICghcGF0aFBhcnNlci5lbmQoKSkge1xuICAgICAgICAgICAganNvbi5wdXNoKEhvcC5mcm9tUGFyc2VyKHBhdGhQYXJzZXIpLnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG59XG4vKipcbiAqIERlc2VyaWFsaXplIGFuZCBTZXJpYWxpemUgdGhlIFBhdGhTZXQgdHlwZVxuICovXG5jbGFzcyBQYXRoU2V0IGV4dGVuZHMgc2VyaWFsaXplZF90eXBlXzEuU2VyaWFsaXplZFR5cGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFBhdGhTZXQgZnJvbSBhbiBBcnJheSBvZiBBcnJheXMgcmVwcmVzZW50aW5nIHBhdGhzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgQSBQYXRoU2V0IG9yIEFycmF5IG9mIEFycmF5IG9mIEhvcE9iamVjdHNcbiAgICAgKiBAcmV0dXJucyB0aGUgUGF0aFNldCBjb25zdHJ1Y3RlZCBmcm9tIHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUGF0aFNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhdGhTZXQodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goUGF0aC5mcm9tKHBhdGgpLnRvQnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChidWZmZXJfMS5CdWZmZXIuZnJvbShbUEFUSF9TRVBBUkFUT1JfQllURV0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gPSBidWZmZXJfMS5CdWZmZXIuZnJvbShbUEFUSFNFVF9FTkRfQllURV0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRoU2V0KGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoYnl0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgUGF0aFNldCBmcm9tIGdpdmVuIHZhbHVlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFBhdGhTZXQgZnJvbSBhIEJpbmFyeVBhcnNlclxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcnNlciBBIEJpbmFyeVBhcnNlciB0byByZWFkIFBhdGhTZXQgZnJvbVxuICAgICAqIEByZXR1cm5zIHRoZSBQYXRoU2V0IHJlYWQgZnJvbSBwYXJzZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBhcnNlcihwYXJzZXIpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFwYXJzZXIuZW5kKCkpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goUGF0aC5mcm9tUGFyc2VyKHBhcnNlcikudG9CeXRlcygpKTtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2gocGFyc2VyLnJlYWQoMSkpO1xuICAgICAgICAgICAgaWYgKGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdWzBdID09IFBBVEhTRVRfRU5EX0JZVEUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGhTZXQoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChieXRlcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBQYXRoU2V0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBBcnJheSBvZiBBcnJheSBvZiBIb3BPYmplY3RzLCByZXByZXNlbnRpbmcgdGhpcyBQYXRoU2V0XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBqc29uID0gW107XG4gICAgICAgIGNvbnN0IHBhdGhQYXJzZXIgPSBuZXcgYmluYXJ5X3BhcnNlcl8xLkJpbmFyeVBhcnNlcih0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB3aGlsZSAoIXBhdGhQYXJzZXIuZW5kKCkpIHtcbiAgICAgICAgICAgIGpzb24ucHVzaChQYXRoLmZyb21QYXJzZXIocGF0aFBhcnNlcikudG9KU09OKCkpO1xuICAgICAgICAgICAgcGF0aFBhcnNlci5za2lwKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aFNldCA9IFBhdGhTZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLXNldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/path-set.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js":
/*!************************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/serialized-type.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Comparable = exports.SerializedType = void 0;\nconst binary_serializer_1 = __webpack_require__(/*! ../serdes/binary-serializer */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * The base class for all binary-codec types\n */\nclass SerializedType {\n    constructor(bytes) {\n        this.bytes = buffer_1.Buffer.alloc(0);\n        this.bytes = bytes !== null && bytes !== void 0 ? bytes : buffer_1.Buffer.alloc(0);\n    }\n    static fromParser(parser, hint) {\n        throw new Error('fromParser not implemented');\n        return this.fromParser(parser, hint);\n    }\n    static from(value) {\n        throw new Error('from not implemented');\n        return this.from(value);\n    }\n    /**\n     * Write the bytes representation of a SerializedType to a BytesList\n     *\n     * @param list The BytesList to write SerializedType bytes to\n     */\n    toBytesSink(list) {\n        list.put(this.bytes);\n    }\n    /**\n     * Get the hex representation of a SerializedType's bytes\n     *\n     * @returns hex String of this.bytes\n     */\n    toHex() {\n        return this.toBytes().toString('hex').toUpperCase();\n    }\n    /**\n     * Get the bytes representation of a SerializedType\n     *\n     * @returns A buffer of the bytes\n     */\n    toBytes() {\n        if (this.bytes) {\n            return this.bytes;\n        }\n        const bytes = new binary_serializer_1.BytesList();\n        this.toBytesSink(bytes);\n        return bytes.toBytes();\n    }\n    /**\n     * Return the JSON representation of a SerializedType\n     *\n     * @param _definitions rippled definitions used to parse the values of transaction types and such.\n     *                          Unused in default, but used in STObject, STArray\n     *                          Can be customized for sidechains and amendments.\n     * @returns any type, if not overloaded returns hexString representation of bytes\n     */\n    toJSON(_definitions) {\n        return this.toHex();\n    }\n    /**\n     * @returns hexString representation of this.bytes\n     */\n    toString() {\n        return this.toHex();\n    }\n}\nexports.SerializedType = SerializedType;\n/**\n * Base class for SerializedTypes that are comparable\n */\nclass Comparable extends SerializedType {\n    lt(other) {\n        return this.compareTo(other) < 0;\n    }\n    eq(other) {\n        return this.compareTo(other) === 0;\n    }\n    gt(other) {\n        return this.compareTo(other) > 0;\n    }\n    gte(other) {\n        return this.compareTo(other) > -1;\n    }\n    lte(other) {\n        return this.compareTo(other) < 1;\n    }\n    /**\n     * Overload this method to define how two Comparable SerializedTypes are compared\n     *\n     * @param other The comparable object to compare this to\n     * @returns A number denoting the relationship of this and other\n     */\n    compareTo(other) {\n        throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);\n    }\n}\nexports.Comparable = Comparable;\n//# sourceMappingURL=serialized-type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3NlcmlhbGl6ZWQtdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxzQkFBc0I7QUFDM0MsNEJBQTRCLG1CQUFPLENBQUMsOEdBQTZCO0FBQ2pFLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlCQUFpQixNQUFNLGlCQUFpQjtBQUNsRjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3NlcmlhbGl6ZWQtdHlwZS5qcz8wMGYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wYXJhYmxlID0gZXhwb3J0cy5TZXJpYWxpemVkVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGJpbmFyeV9zZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi4vc2VyZGVzL2JpbmFyeS1zZXJpYWxpemVyXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBiaW5hcnktY29kZWMgdHlwZXNcbiAqL1xuY2xhc3MgU2VyaWFsaXplZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcyAhPT0gbnVsbCAmJiBieXRlcyAhPT0gdm9pZCAwID8gYnl0ZXMgOiBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUGFyc2VyKHBhcnNlciwgaGludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21QYXJzZXIgbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21QYXJzZXIocGFyc2VyLCBoaW50KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgdGhlIGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIGEgU2VyaWFsaXplZFR5cGUgdG8gYSBCeXRlc0xpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0IFRoZSBCeXRlc0xpc3QgdG8gd3JpdGUgU2VyaWFsaXplZFR5cGUgYnl0ZXMgdG9cbiAgICAgKi9cbiAgICB0b0J5dGVzU2luayhsaXN0KSB7XG4gICAgICAgIGxpc3QucHV0KHRoaXMuYnl0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGhleCByZXByZXNlbnRhdGlvbiBvZiBhIFNlcmlhbGl6ZWRUeXBlJ3MgYnl0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGhleCBTdHJpbmcgb2YgdGhpcy5ieXRlc1xuICAgICAqL1xuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCkudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgYSBTZXJpYWxpemVkVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBidWZmZXIgb2YgdGhlIGJ5dGVzXG4gICAgICovXG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IGJpbmFyeV9zZXJpYWxpemVyXzEuQnl0ZXNMaXN0KCk7XG4gICAgICAgIHRoaXMudG9CeXRlc1NpbmsoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gYnl0ZXMudG9CeXRlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBTZXJpYWxpemVkVHlwZVxuICAgICAqXG4gICAgICogQHBhcmFtIF9kZWZpbml0aW9ucyByaXBwbGVkIGRlZmluaXRpb25zIHVzZWQgdG8gcGFyc2UgdGhlIHZhbHVlcyBvZiB0cmFuc2FjdGlvbiB0eXBlcyBhbmQgc3VjaC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVW51c2VkIGluIGRlZmF1bHQsIGJ1dCB1c2VkIGluIFNUT2JqZWN0LCBTVEFycmF5XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBjdXN0b21pemVkIGZvciBzaWRlY2hhaW5zIGFuZCBhbWVuZG1lbnRzLlxuICAgICAqIEByZXR1cm5zIGFueSB0eXBlLCBpZiBub3Qgb3ZlcmxvYWRlZCByZXR1cm5zIGhleFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBieXRlc1xuICAgICAqL1xuICAgIHRvSlNPTihfZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgaGV4U3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcmlhbGl6ZWRUeXBlID0gU2VyaWFsaXplZFR5cGU7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFNlcmlhbGl6ZWRUeXBlcyB0aGF0IGFyZSBjb21wYXJhYmxlXG4gKi9cbmNsYXNzIENvbXBhcmFibGUgZXh0ZW5kcyBTZXJpYWxpemVkVHlwZSB7XG4gICAgbHQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA8IDA7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPT09IDA7XG4gICAgfVxuICAgIGd0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPiAwO1xuICAgIH1cbiAgICBndGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA+IC0xO1xuICAgIH1cbiAgICBsdGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA8IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJsb2FkIHRoaXMgbWV0aG9kIHRvIGRlZmluZSBob3cgdHdvIENvbXBhcmFibGUgU2VyaWFsaXplZFR5cGVzIGFyZSBjb21wYXJlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBjb21wYXJhYmxlIG9iamVjdCB0byBjb21wYXJlIHRoaXMgdG9cbiAgICAgKiBAcmV0dXJucyBBIG51bWJlciBkZW5vdGluZyB0aGUgcmVsYXRpb25zaGlwIG9mIHRoaXMgYW5kIG90aGVyXG4gICAgICovXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGNvbXBhcmUgJHt0aGlzLnRvU3RyaW5nKCl9IGFuZCAke290aGVyLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wYXJhYmxlID0gQ29tcGFyYWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbGl6ZWQtdHlwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/st-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/st-array.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.STArray = void 0;\nconst enums_1 = __webpack_require__(/*! ../enums */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/index.js\");\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst st_object_1 = __webpack_require__(/*! ./st-object */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/st-object.js\");\nconst binary_parser_1 = __webpack_require__(/*! ../serdes/binary-parser */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst ARRAY_END_MARKER = buffer_1.Buffer.from([0xf1]);\nconst ARRAY_END_MARKER_NAME = 'ArrayEndMarker';\nconst OBJECT_END_MARKER = buffer_1.Buffer.from([0xe1]);\n/**\n * TypeGuard for Array<JsonObject>\n */\nfunction isObjects(args) {\n    return (Array.isArray(args) && (args.length === 0 || typeof args[0] === 'object'));\n}\n/**\n * Class for serializing and deserializing Arrays of Objects\n */\nclass STArray extends serialized_type_1.SerializedType {\n    /**\n     * Construct an STArray from a BinaryParser\n     *\n     * @param parser BinaryParser to parse an STArray from\n     * @returns An STArray Object\n     */\n    static fromParser(parser) {\n        const bytes = [];\n        while (!parser.end()) {\n            const field = parser.readField();\n            if (field.name === ARRAY_END_MARKER_NAME) {\n                break;\n            }\n            bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);\n        }\n        bytes.push(ARRAY_END_MARKER);\n        return new STArray(buffer_1.Buffer.concat(bytes));\n    }\n    /**\n     * Construct an STArray from an Array of JSON Objects\n     *\n     * @param value STArray or Array of Objects to parse into an STArray\n     * @param definitions optional, types and values to use to encode/decode a transaction\n     * @returns An STArray object\n     */\n    static from(value, definitions = enums_1.DEFAULT_DEFINITIONS) {\n        if (value instanceof STArray) {\n            return value;\n        }\n        if (isObjects(value)) {\n            const bytes = [];\n            value.forEach((obj) => {\n                bytes.push(st_object_1.STObject.from(obj, undefined, definitions).toBytes());\n            });\n            bytes.push(ARRAY_END_MARKER);\n            return new STArray(buffer_1.Buffer.concat(bytes));\n        }\n        throw new Error('Cannot construct STArray from value given');\n    }\n    /**\n     * Return the JSON representation of this.bytes\n     *\n     * @param definitions optional, types and values to use to encode/decode a transaction\n     * @returns An Array of JSON objects\n     */\n    toJSON(definitions = enums_1.DEFAULT_DEFINITIONS) {\n        const result = [];\n        const arrayParser = new binary_parser_1.BinaryParser(this.toString(), definitions);\n        while (!arrayParser.end()) {\n            const field = arrayParser.readField();\n            if (field.name === ARRAY_END_MARKER_NAME) {\n                break;\n            }\n            const outer = {};\n            outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON(definitions);\n            result.push(outer);\n        }\n        return result;\n    }\n}\nexports.STArray = STArray;\n//# sourceMappingURL=st-array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3N0LWFycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBVTtBQUNsQywwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBbUI7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMscUZBQWE7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsc0dBQXlCO0FBQ3pELGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvc3QtYXJyYXkuanM/MDJkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1RBcnJheSA9IHZvaWQgMDtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi4vZW51bXNcIik7XG5jb25zdCBzZXJpYWxpemVkX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZWQtdHlwZVwiKTtcbmNvbnN0IHN0X29iamVjdF8xID0gcmVxdWlyZShcIi4vc3Qtb2JqZWN0XCIpO1xuY29uc3QgYmluYXJ5X3BhcnNlcl8xID0gcmVxdWlyZShcIi4uL3NlcmRlcy9iaW5hcnktcGFyc2VyXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNvbnN0IEFSUkFZX0VORF9NQVJLRVIgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShbMHhmMV0pO1xuY29uc3QgQVJSQVlfRU5EX01BUktFUl9OQU1FID0gJ0FycmF5RW5kTWFya2VyJztcbmNvbnN0IE9CSkVDVF9FTkRfTUFSS0VSID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oWzB4ZTFdKTtcbi8qKlxuICogVHlwZUd1YXJkIGZvciBBcnJheTxKc29uT2JqZWN0PlxuICovXG5mdW5jdGlvbiBpc09iamVjdHMoYXJncykge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiAoYXJncy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSk7XG59XG4vKipcbiAqIENsYXNzIGZvciBzZXJpYWxpemluZyBhbmQgZGVzZXJpYWxpemluZyBBcnJheXMgb2YgT2JqZWN0c1xuICovXG5jbGFzcyBTVEFycmF5IGV4dGVuZHMgc2VyaWFsaXplZF90eXBlXzEuU2VyaWFsaXplZFR5cGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBTVEFycmF5IGZyb20gYSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJzZXIgQmluYXJ5UGFyc2VyIHRvIHBhcnNlIGFuIFNUQXJyYXkgZnJvbVxuICAgICAqIEByZXR1cm5zIEFuIFNUQXJyYXkgT2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGZyb21QYXJzZXIocGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgICAgIHdoaWxlICghcGFyc2VyLmVuZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHBhcnNlci5yZWFkRmllbGQoKTtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lID09PSBBUlJBWV9FTkRfTUFSS0VSX05BTUUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzLnB1c2goZmllbGQuaGVhZGVyLCBwYXJzZXIucmVhZEZpZWxkVmFsdWUoZmllbGQpLnRvQnl0ZXMoKSwgT0JKRUNUX0VORF9NQVJLRVIpO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2goQVJSQVlfRU5EX01BUktFUik7XG4gICAgICAgIHJldHVybiBuZXcgU1RBcnJheShidWZmZXJfMS5CdWZmZXIuY29uY2F0KGJ5dGVzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBTVEFycmF5IGZyb20gYW4gQXJyYXkgb2YgSlNPTiBPYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgU1RBcnJheSBvciBBcnJheSBvZiBPYmplY3RzIHRvIHBhcnNlIGludG8gYW4gU1RBcnJheVxuICAgICAqIEBwYXJhbSBkZWZpbml0aW9ucyBvcHRpb25hbCwgdHlwZXMgYW5kIHZhbHVlcyB0byB1c2UgdG8gZW5jb2RlL2RlY29kZSBhIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybnMgQW4gU1RBcnJheSBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSwgZGVmaW5pdGlvbnMgPSBlbnVtc18xLkRFRkFVTFRfREVGSU5JVElPTlMpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU1RBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdHModmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChzdF9vYmplY3RfMS5TVE9iamVjdC5mcm9tKG9iaiwgdW5kZWZpbmVkLCBkZWZpbml0aW9ucykudG9CeXRlcygpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnl0ZXMucHVzaChBUlJBWV9FTkRfTUFSS0VSKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU1RBcnJheShidWZmZXJfMS5CdWZmZXIuY29uY2F0KGJ5dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IFNUQXJyYXkgZnJvbSB2YWx1ZSBnaXZlbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcy5ieXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIGRlZmluaXRpb25zIG9wdGlvbmFsLCB0eXBlcyBhbmQgdmFsdWVzIHRvIHVzZSB0byBlbmNvZGUvZGVjb2RlIGEgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBBbiBBcnJheSBvZiBKU09OIG9iamVjdHNcbiAgICAgKi9cbiAgICB0b0pTT04oZGVmaW5pdGlvbnMgPSBlbnVtc18xLkRFRkFVTFRfREVGSU5JVElPTlMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGFycmF5UGFyc2VyID0gbmV3IGJpbmFyeV9wYXJzZXJfMS5CaW5hcnlQYXJzZXIodGhpcy50b1N0cmluZygpLCBkZWZpbml0aW9ucyk7XG4gICAgICAgIHdoaWxlICghYXJyYXlQYXJzZXIuZW5kKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gYXJyYXlQYXJzZXIucmVhZEZpZWxkKCk7XG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSA9PT0gQVJSQVlfRU5EX01BUktFUl9OQU1FKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdXRlciA9IHt9O1xuICAgICAgICAgICAgb3V0ZXJbZmllbGQubmFtZV0gPSBzdF9vYmplY3RfMS5TVE9iamVjdC5mcm9tUGFyc2VyKGFycmF5UGFyc2VyKS50b0pTT04oZGVmaW5pdGlvbnMpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3V0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5TVEFycmF5ID0gU1RBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0LWFycmF5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/st-array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/st-object.js":
/*!******************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/st-object.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.STObject = void 0;\nconst enums_1 = __webpack_require__(/*! ../enums */ \"(ssr)/./node_modules/ripple-binary-codec/dist/enums/index.js\");\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst ripple_address_codec_1 = __webpack_require__(/*! ripple-address-codec */ \"(ssr)/./node_modules/ripple-address-codec/dist/index.js\");\nconst binary_parser_1 = __webpack_require__(/*! ../serdes/binary-parser */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js\");\nconst binary_serializer_1 = __webpack_require__(/*! ../serdes/binary-serializer */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst st_array_1 = __webpack_require__(/*! ./st-array */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/st-array.js\");\nconst OBJECT_END_MARKER_BYTE = buffer_1.Buffer.from([0xe1]);\nconst OBJECT_END_MARKER = 'ObjectEndMarker';\nconst ST_OBJECT = 'STObject';\nconst DESTINATION = 'Destination';\nconst ACCOUNT = 'Account';\nconst SOURCE_TAG = 'SourceTag';\nconst DEST_TAG = 'DestinationTag';\n/**\n * Break down an X-Address into an account and a tag\n *\n * @param field Name of field\n * @param xAddress X-Address corresponding to the field\n */\nfunction handleXAddress(field, xAddress) {\n    const decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(xAddress);\n    let tagName;\n    if (field === DESTINATION)\n        tagName = DEST_TAG;\n    else if (field === ACCOUNT)\n        tagName = SOURCE_TAG;\n    else if (decoded.tag !== false)\n        throw new Error(`${field} cannot have an associated tag`);\n    return decoded.tag !== false\n        ? { [field]: decoded.classicAddress, [tagName]: decoded.tag }\n        : { [field]: decoded.classicAddress };\n}\n/**\n * Validate that two objects don't both have the same tag fields\n *\n * @param obj1 First object to check for tags\n * @param obj2 Second object to check for tags\n * @throws When both objects have SourceTag or DestinationTag\n */\nfunction checkForDuplicateTags(obj1, obj2) {\n    if (!(obj1[SOURCE_TAG] === undefined || obj2[SOURCE_TAG] === undefined))\n        throw new Error('Cannot have Account X-Address and SourceTag');\n    if (!(obj1[DEST_TAG] === undefined || obj2[DEST_TAG] === undefined))\n        throw new Error('Cannot have Destination X-Address and DestinationTag');\n}\n/**\n * Class for Serializing/Deserializing objects\n */\nclass STObject extends serialized_type_1.SerializedType {\n    /**\n     * Construct a STObject from a BinaryParser\n     *\n     * @param parser BinaryParser to read STObject from\n     * @returns A STObject object\n     */\n    static fromParser(parser) {\n        const list = new binary_serializer_1.BytesList();\n        const bytes = new binary_serializer_1.BinarySerializer(list);\n        while (!parser.end()) {\n            const field = parser.readField();\n            if (field.name === OBJECT_END_MARKER) {\n                break;\n            }\n            const associatedValue = parser.readFieldValue(field);\n            bytes.writeFieldAndValue(field, associatedValue);\n            if (field.type.name === ST_OBJECT) {\n                bytes.put(OBJECT_END_MARKER_BYTE);\n            }\n        }\n        return new STObject(list.toBytes());\n    }\n    /**\n     * Construct a STObject from a JSON object\n     *\n     * @param value An object to include\n     * @param filter optional, denote which field to include in serialized object\n     * @param definitions optional, types and values to use to encode/decode a transaction\n     * @returns a STObject object\n     */\n    static from(value, filter, definitions = enums_1.DEFAULT_DEFINITIONS) {\n        if (value instanceof STObject) {\n            return value;\n        }\n        const list = new binary_serializer_1.BytesList();\n        const bytes = new binary_serializer_1.BinarySerializer(list);\n        let isUnlModify = false;\n        const xAddressDecoded = Object.entries(value).reduce((acc, [key, val]) => {\n            let handled = undefined;\n            if (val && (0, ripple_address_codec_1.isValidXAddress)(val.toString())) {\n                handled = handleXAddress(key, val.toString());\n                checkForDuplicateTags(handled, value);\n            }\n            return Object.assign(acc, handled !== null && handled !== void 0 ? handled : { [key]: val });\n        }, {});\n        let sorted = Object.keys(xAddressDecoded)\n            .map((f) => definitions.field[f])\n            .filter((f) => f !== undefined &&\n            xAddressDecoded[f.name] !== undefined &&\n            f.isSerialized)\n            .sort((a, b) => {\n            return a.ordinal - b.ordinal;\n        });\n        if (filter !== undefined) {\n            sorted = sorted.filter(filter);\n        }\n        sorted.forEach((field) => {\n            const associatedValue = field.type.name === ST_OBJECT\n                ? this.from(xAddressDecoded[field.name], undefined, definitions)\n                : field.type.name === 'STArray'\n                    ? st_array_1.STArray.from(xAddressDecoded[field.name], definitions)\n                    : field.associatedType.from(xAddressDecoded[field.name]);\n            if (associatedValue == undefined) {\n                throw new TypeError(`Unable to interpret \"${field.name}: ${xAddressDecoded[field.name]}\".`);\n            }\n            if (associatedValue.name === 'UNLModify') {\n                // triggered when the TransactionType field has a value of 'UNLModify'\n                isUnlModify = true;\n            }\n            // true when in the UNLModify pseudotransaction (after the transaction type has been processed) and working with the\n            // Account field\n            // The Account field must not be a part of the UNLModify pseudotransaction encoding, due to a bug in rippled\n            const isUnlModifyWorkaround = field.name == 'Account' && isUnlModify;\n            bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);\n            if (field.type.name === ST_OBJECT) {\n                bytes.put(OBJECT_END_MARKER_BYTE);\n            }\n        });\n        return new STObject(list.toBytes());\n    }\n    /**\n     * Get the JSON interpretation of this.bytes\n     * @param definitions rippled definitions used to parse the values of transaction types and such.\n     *                          Can be customized for sidechains and amendments.\n     * @returns a JSON object\n     */\n    toJSON(definitions) {\n        const objectParser = new binary_parser_1.BinaryParser(this.toString(), definitions);\n        const accumulator = {};\n        while (!objectParser.end()) {\n            const field = objectParser.readField();\n            if (field.name === OBJECT_END_MARKER) {\n                break;\n            }\n            accumulator[field.name] = objectParser\n                .readFieldValue(field)\n                .toJSON(definitions);\n        }\n        return accumulator;\n    }\n}\nexports.STObject = STObject;\n//# sourceMappingURL=st-object.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3N0LW9iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVU7QUFDbEMsMEJBQTBCLG1CQUFPLENBQUMsaUdBQW1CO0FBQ3JELCtCQUErQixtQkFBTyxDQUFDLHFGQUFzQjtBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyxzR0FBeUI7QUFDekQsNEJBQTRCLG1CQUFPLENBQUMsOEdBQTZCO0FBQ2pFLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixZQUFZO0FBQ3ZHLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVcsSUFBSSw0QkFBNEI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy9zdC1vYmplY3QuanM/NTdmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1RPYmplY3QgPSB2b2lkIDA7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4uL2VudW1zXCIpO1xuY29uc3Qgc2VyaWFsaXplZF90eXBlXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVkLXR5cGVcIik7XG5jb25zdCByaXBwbGVfYWRkcmVzc19jb2RlY18xID0gcmVxdWlyZShcInJpcHBsZS1hZGRyZXNzLWNvZGVjXCIpO1xuY29uc3QgYmluYXJ5X3BhcnNlcl8xID0gcmVxdWlyZShcIi4uL3NlcmRlcy9iaW5hcnktcGFyc2VyXCIpO1xuY29uc3QgYmluYXJ5X3NlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuLi9zZXJkZXMvYmluYXJ5LXNlcmlhbGl6ZXJcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuY29uc3Qgc3RfYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3N0LWFycmF5XCIpO1xuY29uc3QgT0JKRUNUX0VORF9NQVJLRVJfQllURSA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFsweGUxXSk7XG5jb25zdCBPQkpFQ1RfRU5EX01BUktFUiA9ICdPYmplY3RFbmRNYXJrZXInO1xuY29uc3QgU1RfT0JKRUNUID0gJ1NUT2JqZWN0JztcbmNvbnN0IERFU1RJTkFUSU9OID0gJ0Rlc3RpbmF0aW9uJztcbmNvbnN0IEFDQ09VTlQgPSAnQWNjb3VudCc7XG5jb25zdCBTT1VSQ0VfVEFHID0gJ1NvdXJjZVRhZyc7XG5jb25zdCBERVNUX1RBRyA9ICdEZXN0aW5hdGlvblRhZyc7XG4vKipcbiAqIEJyZWFrIGRvd24gYW4gWC1BZGRyZXNzIGludG8gYW4gYWNjb3VudCBhbmQgYSB0YWdcbiAqXG4gKiBAcGFyYW0gZmllbGQgTmFtZSBvZiBmaWVsZFxuICogQHBhcmFtIHhBZGRyZXNzIFgtQWRkcmVzcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBmaWVsZFxuICovXG5mdW5jdGlvbiBoYW5kbGVYQWRkcmVzcyhmaWVsZCwgeEFkZHJlc3MpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gKDAsIHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEueEFkZHJlc3NUb0NsYXNzaWNBZGRyZXNzKSh4QWRkcmVzcyk7XG4gICAgbGV0IHRhZ05hbWU7XG4gICAgaWYgKGZpZWxkID09PSBERVNUSU5BVElPTilcbiAgICAgICAgdGFnTmFtZSA9IERFU1RfVEFHO1xuICAgIGVsc2UgaWYgKGZpZWxkID09PSBBQ0NPVU5UKVxuICAgICAgICB0YWdOYW1lID0gU09VUkNFX1RBRztcbiAgICBlbHNlIGlmIChkZWNvZGVkLnRhZyAhPT0gZmFsc2UpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmaWVsZH0gY2Fubm90IGhhdmUgYW4gYXNzb2NpYXRlZCB0YWdgKTtcbiAgICByZXR1cm4gZGVjb2RlZC50YWcgIT09IGZhbHNlXG4gICAgICAgID8geyBbZmllbGRdOiBkZWNvZGVkLmNsYXNzaWNBZGRyZXNzLCBbdGFnTmFtZV06IGRlY29kZWQudGFnIH1cbiAgICAgICAgOiB7IFtmaWVsZF06IGRlY29kZWQuY2xhc3NpY0FkZHJlc3MgfTtcbn1cbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0d28gb2JqZWN0cyBkb24ndCBib3RoIGhhdmUgdGhlIHNhbWUgdGFnIGZpZWxkc1xuICpcbiAqIEBwYXJhbSBvYmoxIEZpcnN0IG9iamVjdCB0byBjaGVjayBmb3IgdGFnc1xuICogQHBhcmFtIG9iajIgU2Vjb25kIG9iamVjdCB0byBjaGVjayBmb3IgdGFnc1xuICogQHRocm93cyBXaGVuIGJvdGggb2JqZWN0cyBoYXZlIFNvdXJjZVRhZyBvciBEZXN0aW5hdGlvblRhZ1xuICovXG5mdW5jdGlvbiBjaGVja0ZvckR1cGxpY2F0ZVRhZ3Mob2JqMSwgb2JqMikge1xuICAgIGlmICghKG9iajFbU09VUkNFX1RBR10gPT09IHVuZGVmaW5lZCB8fCBvYmoyW1NPVVJDRV9UQUddID09PSB1bmRlZmluZWQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIEFjY291bnQgWC1BZGRyZXNzIGFuZCBTb3VyY2VUYWcnKTtcbiAgICBpZiAoIShvYmoxW0RFU1RfVEFHXSA9PT0gdW5kZWZpbmVkIHx8IG9iajJbREVTVF9UQUddID09PSB1bmRlZmluZWQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIERlc3RpbmF0aW9uIFgtQWRkcmVzcyBhbmQgRGVzdGluYXRpb25UYWcnKTtcbn1cbi8qKlxuICogQ2xhc3MgZm9yIFNlcmlhbGl6aW5nL0Rlc2VyaWFsaXppbmcgb2JqZWN0c1xuICovXG5jbGFzcyBTVE9iamVjdCBleHRlbmRzIHNlcmlhbGl6ZWRfdHlwZV8xLlNlcmlhbGl6ZWRUeXBlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBTVE9iamVjdCBmcm9tIGEgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyc2VyIEJpbmFyeVBhcnNlciB0byByZWFkIFNUT2JqZWN0IGZyb21cbiAgICAgKiBAcmV0dXJucyBBIFNUT2JqZWN0IG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUGFyc2VyKHBhcnNlcikge1xuICAgICAgICBjb25zdCBsaXN0ID0gbmV3IGJpbmFyeV9zZXJpYWxpemVyXzEuQnl0ZXNMaXN0KCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IGJpbmFyeV9zZXJpYWxpemVyXzEuQmluYXJ5U2VyaWFsaXplcihsaXN0KTtcbiAgICAgICAgd2hpbGUgKCFwYXJzZXIuZW5kKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gcGFyc2VyLnJlYWRGaWVsZCgpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IE9CSkVDVF9FTkRfTUFSS0VSKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhc3NvY2lhdGVkVmFsdWUgPSBwYXJzZXIucmVhZEZpZWxkVmFsdWUoZmllbGQpO1xuICAgICAgICAgICAgYnl0ZXMud3JpdGVGaWVsZEFuZFZhbHVlKGZpZWxkLCBhc3NvY2lhdGVkVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLnR5cGUubmFtZSA9PT0gU1RfT0JKRUNUKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHV0KE9CSkVDVF9FTkRfTUFSS0VSX0JZVEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU1RPYmplY3QobGlzdC50b0J5dGVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBTVE9iamVjdCBmcm9tIGEgSlNPTiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBBbiBvYmplY3QgdG8gaW5jbHVkZVxuICAgICAqIEBwYXJhbSBmaWx0ZXIgb3B0aW9uYWwsIGRlbm90ZSB3aGljaCBmaWVsZCB0byBpbmNsdWRlIGluIHNlcmlhbGl6ZWQgb2JqZWN0XG4gICAgICogQHBhcmFtIGRlZmluaXRpb25zIG9wdGlvbmFsLCB0eXBlcyBhbmQgdmFsdWVzIHRvIHVzZSB0byBlbmNvZGUvZGVjb2RlIGEgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBhIFNUT2JqZWN0IG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZhbHVlLCBmaWx0ZXIsIGRlZmluaXRpb25zID0gZW51bXNfMS5ERUZBVUxUX0RFRklOSVRJT05TKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNUT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdCA9IG5ldyBiaW5hcnlfc2VyaWFsaXplcl8xLkJ5dGVzTGlzdCgpO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBiaW5hcnlfc2VyaWFsaXplcl8xLkJpbmFyeVNlcmlhbGl6ZXIobGlzdCk7XG4gICAgICAgIGxldCBpc1VubE1vZGlmeSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB4QWRkcmVzc0RlY29kZWQgPSBPYmplY3QuZW50cmllcyh2YWx1ZSkucmVkdWNlKChhY2MsIFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiAoMCwgcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5pc1ZhbGlkWEFkZHJlc3MpKHZhbC50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSBoYW5kbGVYQWRkcmVzcyhrZXksIHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBjaGVja0ZvckR1cGxpY2F0ZVRhZ3MoaGFuZGxlZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCBoYW5kbGVkICE9PSBudWxsICYmIGhhbmRsZWQgIT09IHZvaWQgMCA/IGhhbmRsZWQgOiB7IFtrZXldOiB2YWwgfSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgbGV0IHNvcnRlZCA9IE9iamVjdC5rZXlzKHhBZGRyZXNzRGVjb2RlZClcbiAgICAgICAgICAgIC5tYXAoKGYpID0+IGRlZmluaXRpb25zLmZpZWxkW2ZdKVxuICAgICAgICAgICAgLmZpbHRlcigoZikgPT4gZiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB4QWRkcmVzc0RlY29kZWRbZi5uYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmLmlzU2VyaWFsaXplZClcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYS5vcmRpbmFsIC0gYi5vcmRpbmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBzb3J0ZWQuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgc29ydGVkLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhc3NvY2lhdGVkVmFsdWUgPSBmaWVsZC50eXBlLm5hbWUgPT09IFNUX09CSkVDVFxuICAgICAgICAgICAgICAgID8gdGhpcy5mcm9tKHhBZGRyZXNzRGVjb2RlZFtmaWVsZC5uYW1lXSwgdW5kZWZpbmVkLCBkZWZpbml0aW9ucylcbiAgICAgICAgICAgICAgICA6IGZpZWxkLnR5cGUubmFtZSA9PT0gJ1NUQXJyYXknXG4gICAgICAgICAgICAgICAgICAgID8gc3RfYXJyYXlfMS5TVEFycmF5LmZyb20oeEFkZHJlc3NEZWNvZGVkW2ZpZWxkLm5hbWVdLCBkZWZpbml0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgOiBmaWVsZC5hc3NvY2lhdGVkVHlwZS5mcm9tKHhBZGRyZXNzRGVjb2RlZFtmaWVsZC5uYW1lXSk7XG4gICAgICAgICAgICBpZiAoYXNzb2NpYXRlZFZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuYWJsZSB0byBpbnRlcnByZXQgXCIke2ZpZWxkLm5hbWV9OiAke3hBZGRyZXNzRGVjb2RlZFtmaWVsZC5uYW1lXX1cIi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3NvY2lhdGVkVmFsdWUubmFtZSA9PT0gJ1VOTE1vZGlmeScpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQgd2hlbiB0aGUgVHJhbnNhY3Rpb25UeXBlIGZpZWxkIGhhcyBhIHZhbHVlIG9mICdVTkxNb2RpZnknXG4gICAgICAgICAgICAgICAgaXNVbmxNb2RpZnkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJ1ZSB3aGVuIGluIHRoZSBVTkxNb2RpZnkgcHNldWRvdHJhbnNhY3Rpb24gKGFmdGVyIHRoZSB0cmFuc2FjdGlvbiB0eXBlIGhhcyBiZWVuIHByb2Nlc3NlZCkgYW5kIHdvcmtpbmcgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIEFjY291bnQgZmllbGRcbiAgICAgICAgICAgIC8vIFRoZSBBY2NvdW50IGZpZWxkIG11c3Qgbm90IGJlIGEgcGFydCBvZiB0aGUgVU5MTW9kaWZ5IHBzZXVkb3RyYW5zYWN0aW9uIGVuY29kaW5nLCBkdWUgdG8gYSBidWcgaW4gcmlwcGxlZFxuICAgICAgICAgICAgY29uc3QgaXNVbmxNb2RpZnlXb3JrYXJvdW5kID0gZmllbGQubmFtZSA9PSAnQWNjb3VudCcgJiYgaXNVbmxNb2RpZnk7XG4gICAgICAgICAgICBieXRlcy53cml0ZUZpZWxkQW5kVmFsdWUoZmllbGQsIGFzc29jaWF0ZWRWYWx1ZSwgaXNVbmxNb2RpZnlXb3JrYXJvdW5kKTtcbiAgICAgICAgICAgIGlmIChmaWVsZC50eXBlLm5hbWUgPT09IFNUX09CSkVDVCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1dChPQkpFQ1RfRU5EX01BUktFUl9CWVRFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgU1RPYmplY3QobGlzdC50b0J5dGVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEpTT04gaW50ZXJwcmV0YXRpb24gb2YgdGhpcy5ieXRlc1xuICAgICAqIEBwYXJhbSBkZWZpbml0aW9ucyByaXBwbGVkIGRlZmluaXRpb25zIHVzZWQgdG8gcGFyc2UgdGhlIHZhbHVlcyBvZiB0cmFuc2FjdGlvbiB0eXBlcyBhbmQgc3VjaC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIGN1c3RvbWl6ZWQgZm9yIHNpZGVjaGFpbnMgYW5kIGFtZW5kbWVudHMuXG4gICAgICogQHJldHVybnMgYSBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIHRvSlNPTihkZWZpbml0aW9ucykge1xuICAgICAgICBjb25zdCBvYmplY3RQYXJzZXIgPSBuZXcgYmluYXJ5X3BhcnNlcl8xLkJpbmFyeVBhcnNlcih0aGlzLnRvU3RyaW5nKCksIGRlZmluaXRpb25zKTtcbiAgICAgICAgY29uc3QgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgd2hpbGUgKCFvYmplY3RQYXJzZXIuZW5kKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gb2JqZWN0UGFyc2VyLnJlYWRGaWVsZCgpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IE9CSkVDVF9FTkRfTUFSS0VSKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2N1bXVsYXRvcltmaWVsZC5uYW1lXSA9IG9iamVjdFBhcnNlclxuICAgICAgICAgICAgICAgIC5yZWFkRmllbGRWYWx1ZShmaWVsZClcbiAgICAgICAgICAgICAgICAudG9KU09OKGRlZmluaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxufVxuZXhwb3J0cy5TVE9iamVjdCA9IFNUT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Qtb2JqZWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/st-object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-16.js":
/*!****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/uint-16.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UInt16 = void 0;\nconst uint_1 = __webpack_require__(/*! ./uint */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Derived UInt class for serializing/deserializing 16 bit UInt\n */\nclass UInt16 extends uint_1.UInt {\n    constructor(bytes) {\n        super(bytes !== null && bytes !== void 0 ? bytes : UInt16.defaultUInt16.bytes);\n    }\n    static fromParser(parser) {\n        return new UInt16(parser.read(UInt16.width));\n    }\n    /**\n     * Construct a UInt16 object from a number\n     *\n     * @param val UInt16 object or number\n     */\n    static from(val) {\n        if (val instanceof UInt16) {\n            return val;\n        }\n        if (typeof val === 'number') {\n            const buf = buffer_1.Buffer.alloc(UInt16.width);\n            buf.writeUInt16BE(val, 0);\n            return new UInt16(buf);\n        }\n        throw new Error('Can not construct UInt16 with given value');\n    }\n    /**\n     * get the value of a UInt16 object\n     *\n     * @returns the number represented by this.bytes\n     */\n    valueOf() {\n        return this.bytes.readUInt16BE(0);\n    }\n}\nexports.UInt16 = UInt16;\nUInt16.width = 16 / 8; // 2\nUInt16.defaultUInt16 = new UInt16(buffer_1.Buffer.alloc(UInt16.width));\n//# sourceMappingURL=uint-16.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3VpbnQtMTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGVBQWUsbUJBQU8sQ0FBQywyRUFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHVCQUF1QjtBQUN2QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3VpbnQtMTYuanM/Nzc2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVUludDE2ID0gdm9pZCAwO1xuY29uc3QgdWludF8xID0gcmVxdWlyZShcIi4vdWludFwiKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG4vKipcbiAqIERlcml2ZWQgVUludCBjbGFzcyBmb3Igc2VyaWFsaXppbmcvZGVzZXJpYWxpemluZyAxNiBiaXQgVUludFxuICovXG5jbGFzcyBVSW50MTYgZXh0ZW5kcyB1aW50XzEuVUludCB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoYnl0ZXMgIT09IG51bGwgJiYgYnl0ZXMgIT09IHZvaWQgMCA/IGJ5dGVzIDogVUludDE2LmRlZmF1bHRVSW50MTYuYnl0ZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBhcnNlcihwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVSW50MTYocGFyc2VyLnJlYWQoVUludDE2LndpZHRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFVJbnQxNiBvYmplY3QgZnJvbSBhIG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbCBVSW50MTYgb2JqZWN0IG9yIG51bWJlclxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZhbCkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVUludDE2KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKFVJbnQxNi53aWR0aCk7XG4gICAgICAgICAgICBidWYud3JpdGVVSW50MTZCRSh2YWwsIDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVSW50MTYoYnVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29uc3RydWN0IFVJbnQxNiB3aXRoIGdpdmVuIHZhbHVlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmFsdWUgb2YgYSBVSW50MTYgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgbnVtYmVyIHJlcHJlc2VudGVkIGJ5IHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5yZWFkVUludDE2QkUoMCk7XG4gICAgfVxufVxuZXhwb3J0cy5VSW50MTYgPSBVSW50MTY7XG5VSW50MTYud2lkdGggPSAxNiAvIDg7IC8vIDJcblVJbnQxNi5kZWZhdWx0VUludDE2ID0gbmV3IFVJbnQxNihidWZmZXJfMS5CdWZmZXIuYWxsb2MoVUludDE2LndpZHRoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aW50LTE2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-16.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-32.js":
/*!****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/uint-32.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UInt32 = void 0;\nconst uint_1 = __webpack_require__(/*! ./uint */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Derived UInt class for serializing/deserializing 32 bit UInt\n */\nclass UInt32 extends uint_1.UInt {\n    constructor(bytes) {\n        super(bytes !== null && bytes !== void 0 ? bytes : UInt32.defaultUInt32.bytes);\n    }\n    static fromParser(parser) {\n        return new UInt32(parser.read(UInt32.width));\n    }\n    /**\n     * Construct a UInt32 object from a number\n     *\n     * @param val UInt32 object or number\n     */\n    static from(val) {\n        if (val instanceof UInt32) {\n            return val;\n        }\n        const buf = buffer_1.Buffer.alloc(UInt32.width);\n        if (typeof val === 'string') {\n            const num = Number.parseInt(val);\n            buf.writeUInt32BE(num, 0);\n            return new UInt32(buf);\n        }\n        if (typeof val === 'number') {\n            buf.writeUInt32BE(val, 0);\n            return new UInt32(buf);\n        }\n        throw new Error('Cannot construct UInt32 from given value');\n    }\n    /**\n     * get the value of a UInt32 object\n     *\n     * @returns the number represented by this.bytes\n     */\n    valueOf() {\n        return this.bytes.readUInt32BE(0);\n    }\n}\nexports.UInt32 = UInt32;\nUInt32.width = 32 / 8; // 4\nUInt32.defaultUInt32 = new UInt32(buffer_1.Buffer.alloc(UInt32.width));\n//# sourceMappingURL=uint-32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3VpbnQtMzIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGVBQWUsbUJBQU8sQ0FBQywyRUFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCx1QkFBdUI7QUFDdkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy91aW50LTMyLmpzPzRjMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVJbnQzMiA9IHZvaWQgMDtcbmNvbnN0IHVpbnRfMSA9IHJlcXVpcmUoXCIuL3VpbnRcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBEZXJpdmVkIFVJbnQgY2xhc3MgZm9yIHNlcmlhbGl6aW5nL2Rlc2VyaWFsaXppbmcgMzIgYml0IFVJbnRcbiAqL1xuY2xhc3MgVUludDMyIGV4dGVuZHMgdWludF8xLlVJbnQge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGJ5dGVzICE9PSBudWxsICYmIGJ5dGVzICE9PSB2b2lkIDAgPyBieXRlcyA6IFVJbnQzMi5kZWZhdWx0VUludDMyLmJ5dGVzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21QYXJzZXIocGFyc2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVUludDMyKHBhcnNlci5yZWFkKFVJbnQzMi53aWR0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBVSW50MzIgb2JqZWN0IGZyb20gYSBudW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWwgVUludDMyIG9iamVjdCBvciBudW1iZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFVJbnQzMikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoVUludDMyLndpZHRoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIucGFyc2VJbnQodmFsKTtcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKG51bSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVJbnQzMihidWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYnVmLndyaXRlVUludDMyQkUodmFsLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVUludDMyKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IFVJbnQzMiBmcm9tIGdpdmVuIHZhbHVlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmFsdWUgb2YgYSBVSW50MzIgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgbnVtYmVyIHJlcHJlc2VudGVkIGJ5IHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5yZWFkVUludDMyQkUoMCk7XG4gICAgfVxufVxuZXhwb3J0cy5VSW50MzIgPSBVSW50MzI7XG5VSW50MzIud2lkdGggPSAzMiAvIDg7IC8vIDRcblVJbnQzMi5kZWZhdWx0VUludDMyID0gbmV3IFVJbnQzMihidWZmZXJfMS5CdWZmZXIuYWxsb2MoVUludDMyLndpZHRoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aW50LTMyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-64.js":
/*!****************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/uint-64.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UInt64 = void 0;\nconst uint_1 = __webpack_require__(/*! ./uint */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint.js\");\nconst bigInt = __webpack_require__(/*! big-integer */ \"(ssr)/./node_modules/ripple-binary-codec/node_modules/big-integer/BigInteger.js\");\nconst big_integer_1 = __webpack_require__(/*! big-integer */ \"(ssr)/./node_modules/ripple-binary-codec/node_modules/big-integer/BigInteger.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;\nconst mask = bigInt(0x00000000ffffffff);\n/**\n * Derived UInt class for serializing/deserializing 64 bit UInt\n */\nclass UInt64 extends uint_1.UInt {\n    constructor(bytes) {\n        super(bytes !== null && bytes !== void 0 ? bytes : UInt64.defaultUInt64.bytes);\n    }\n    static fromParser(parser) {\n        return new UInt64(parser.read(UInt64.width));\n    }\n    /**\n     * Construct a UInt64 object\n     *\n     * @param val A UInt64, hex-string, bigInt, or number\n     * @returns A UInt64 object\n     */\n    static from(val) {\n        if (val instanceof UInt64) {\n            return val;\n        }\n        let buf = buffer_1.Buffer.alloc(UInt64.width);\n        if (typeof val === 'number') {\n            if (val < 0) {\n                throw new Error('value must be an unsigned integer');\n            }\n            const number = bigInt(val);\n            const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];\n            intBuf[0].writeUInt32BE(Number(number.shiftRight(32)), 0);\n            intBuf[1].writeUInt32BE(Number(number.and(mask)), 0);\n            return new UInt64(buffer_1.Buffer.concat(intBuf));\n        }\n        if (typeof val === 'string') {\n            if (!HEX_REGEX.test(val)) {\n                throw new Error(`${val} is not a valid hex-string`);\n            }\n            const strBuf = val.padStart(16, '0');\n            buf = buffer_1.Buffer.from(strBuf, 'hex');\n            return new UInt64(buf);\n        }\n        if ((0, big_integer_1.isInstance)(val)) {\n            const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];\n            intBuf[0].writeUInt32BE(Number(val.shiftRight(bigInt(32))), 0);\n            intBuf[1].writeUInt32BE(Number(val.and(mask)), 0);\n            return new UInt64(buffer_1.Buffer.concat(intBuf));\n        }\n        throw new Error('Cannot construct UInt64 from given value');\n    }\n    /**\n     * The JSON representation of a UInt64 object\n     *\n     * @returns a hex-string\n     */\n    toJSON() {\n        return this.bytes.toString('hex').toUpperCase();\n    }\n    /**\n     * Get the value of the UInt64\n     *\n     * @returns the number represented buy this.bytes\n     */\n    valueOf() {\n        const msb = bigInt(this.bytes.slice(0, 4).readUInt32BE(0));\n        const lsb = bigInt(this.bytes.slice(4).readUInt32BE(0));\n        return msb.shiftLeft(bigInt(32)).or(lsb);\n    }\n    /**\n     * Get the bytes representation of the UInt64 object\n     *\n     * @returns 8 bytes representing the UInt64\n     */\n    toBytes() {\n        return this.bytes;\n    }\n}\nexports.UInt64 = UInt64;\nUInt64.width = 64 / 8; // 8\nUInt64.defaultUInt64 = new UInt64(buffer_1.Buffer.alloc(UInt64.width));\n//# sourceMappingURL=uint-64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3VpbnQtNjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGVBQWUsbUJBQU8sQ0FBQywyRUFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsb0dBQWE7QUFDcEMsc0JBQXNCLG1CQUFPLENBQUMsb0dBQWE7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEMsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCx1QkFBdUI7QUFDdkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy91aW50LTY0LmpzPzdlOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVJbnQ2NCA9IHZvaWQgMDtcbmNvbnN0IHVpbnRfMSA9IHJlcXVpcmUoXCIuL3VpbnRcIik7XG5jb25zdCBiaWdJbnQgPSByZXF1aXJlKFwiYmlnLWludGVnZXJcIik7XG5jb25zdCBiaWdfaW50ZWdlcl8xID0gcmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNvbnN0IEhFWF9SRUdFWCA9IC9eW2EtZkEtRjAtOV17MSwxNn0kLztcbmNvbnN0IG1hc2sgPSBiaWdJbnQoMHgwMDAwMDAwMGZmZmZmZmZmKTtcbi8qKlxuICogRGVyaXZlZCBVSW50IGNsYXNzIGZvciBzZXJpYWxpemluZy9kZXNlcmlhbGl6aW5nIDY0IGJpdCBVSW50XG4gKi9cbmNsYXNzIFVJbnQ2NCBleHRlbmRzIHVpbnRfMS5VSW50IHtcbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcihieXRlcyAhPT0gbnVsbCAmJiBieXRlcyAhPT0gdm9pZCAwID8gYnl0ZXMgOiBVSW50NjQuZGVmYXVsdFVJbnQ2NC5ieXRlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUGFyc2VyKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gbmV3IFVJbnQ2NChwYXJzZXIucmVhZChVSW50NjQud2lkdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgVUludDY0IG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbCBBIFVJbnQ2NCwgaGV4LXN0cmluZywgYmlnSW50LCBvciBudW1iZXJcbiAgICAgKiBAcmV0dXJucyBBIFVJbnQ2NCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFVJbnQ2NCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVmID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKFVJbnQ2NC53aWR0aCk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gdW5zaWduZWQgaW50ZWdlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbnVtYmVyID0gYmlnSW50KHZhbCk7XG4gICAgICAgICAgICBjb25zdCBpbnRCdWYgPSBbYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDQpLCBidWZmZXJfMS5CdWZmZXIuYWxsb2MoNCldO1xuICAgICAgICAgICAgaW50QnVmWzBdLndyaXRlVUludDMyQkUoTnVtYmVyKG51bWJlci5zaGlmdFJpZ2h0KDMyKSksIDApO1xuICAgICAgICAgICAgaW50QnVmWzFdLndyaXRlVUludDMyQkUoTnVtYmVyKG51bWJlci5hbmQobWFzaykpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVUludDY0KGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoaW50QnVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIUhFWF9SRUdFWC50ZXN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dmFsfSBpcyBub3QgYSB2YWxpZCBoZXgtc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJCdWYgPSB2YWwucGFkU3RhcnQoMTYsICcwJyk7XG4gICAgICAgICAgICBidWYgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShzdHJCdWYsICdoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVUludDY0KGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBiaWdfaW50ZWdlcl8xLmlzSW5zdGFuY2UpKHZhbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGludEJ1ZiA9IFtidWZmZXJfMS5CdWZmZXIuYWxsb2MoNCksIGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KV07XG4gICAgICAgICAgICBpbnRCdWZbMF0ud3JpdGVVSW50MzJCRShOdW1iZXIodmFsLnNoaWZ0UmlnaHQoYmlnSW50KDMyKSkpLCAwKTtcbiAgICAgICAgICAgIGludEJ1ZlsxXS53cml0ZVVJbnQzMkJFKE51bWJlcih2YWwuYW5kKG1hc2spKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVJbnQ2NChidWZmZXJfMS5CdWZmZXIuY29uY2F0KGludEJ1ZikpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBVSW50NjQgZnJvbSBnaXZlbiB2YWx1ZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIFVJbnQ2NCBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgaGV4LXN0cmluZ1xuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIFVJbnQ2NFxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIG51bWJlciByZXByZXNlbnRlZCBidXkgdGhpcy5ieXRlc1xuICAgICAqL1xuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIGNvbnN0IG1zYiA9IGJpZ0ludCh0aGlzLmJ5dGVzLnNsaWNlKDAsIDQpLnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgIGNvbnN0IGxzYiA9IGJpZ0ludCh0aGlzLmJ5dGVzLnNsaWNlKDQpLnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgIHJldHVybiBtc2Iuc2hpZnRMZWZ0KGJpZ0ludCgzMikpLm9yKGxzYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgdGhlIFVJbnQ2NCBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIDggYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBVSW50NjRcbiAgICAgKi9cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcztcbiAgICB9XG59XG5leHBvcnRzLlVJbnQ2NCA9IFVJbnQ2NDtcblVJbnQ2NC53aWR0aCA9IDY0IC8gODsgLy8gOFxuVUludDY0LmRlZmF1bHRVSW50NjQgPSBuZXcgVUludDY0KGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhVSW50NjQud2lkdGgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpbnQtNjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-8.js":
/*!***************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/uint-8.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UInt8 = void 0;\nconst uint_1 = __webpack_require__(/*! ./uint */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/uint.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n/**\n * Derived UInt class for serializing/deserializing 8 bit UInt\n */\nclass UInt8 extends uint_1.UInt {\n    constructor(bytes) {\n        super(bytes !== null && bytes !== void 0 ? bytes : UInt8.defaultUInt8.bytes);\n    }\n    static fromParser(parser) {\n        return new UInt8(parser.read(UInt8.width));\n    }\n    /**\n     * Construct a UInt8 object from a number\n     *\n     * @param val UInt8 object or number\n     */\n    static from(val) {\n        if (val instanceof UInt8) {\n            return val;\n        }\n        if (typeof val === 'number') {\n            const buf = buffer_1.Buffer.alloc(UInt8.width);\n            buf.writeUInt8(val, 0);\n            return new UInt8(buf);\n        }\n        throw new Error('Cannot construct UInt8 from given value');\n    }\n    /**\n     * get the value of a UInt8 object\n     *\n     * @returns the number represented by this.bytes\n     */\n    valueOf() {\n        return this.bytes.readUInt8(0);\n    }\n}\nexports.UInt8 = UInt8;\nUInt8.width = 8 / 8; // 1\nUInt8.defaultUInt8 = new UInt8(buffer_1.Buffer.alloc(UInt8.width));\n//# sourceMappingURL=uint-8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3VpbnQtOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLDJFQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IscUJBQXFCO0FBQ3JCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvdWludC04LmpzPzAyNDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVJbnQ4ID0gdm9pZCAwO1xuY29uc3QgdWludF8xID0gcmVxdWlyZShcIi4vdWludFwiKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG4vKipcbiAqIERlcml2ZWQgVUludCBjbGFzcyBmb3Igc2VyaWFsaXppbmcvZGVzZXJpYWxpemluZyA4IGJpdCBVSW50XG4gKi9cbmNsYXNzIFVJbnQ4IGV4dGVuZHMgdWludF8xLlVJbnQge1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGJ5dGVzICE9PSBudWxsICYmIGJ5dGVzICE9PSB2b2lkIDAgPyBieXRlcyA6IFVJbnQ4LmRlZmF1bHRVSW50OC5ieXRlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUGFyc2VyKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gbmV3IFVJbnQ4KHBhcnNlci5yZWFkKFVJbnQ4LndpZHRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFVJbnQ4IG9iamVjdCBmcm9tIGEgbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIFVJbnQ4IG9iamVjdCBvciBudW1iZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFVJbnQ4KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKFVJbnQ4LndpZHRoKTtcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQ4KHZhbCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVJbnQ4KGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IFVJbnQ4IGZyb20gZ2l2ZW4gdmFsdWUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2YWx1ZSBvZiBhIFVJbnQ4IG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIG51bWJlciByZXByZXNlbnRlZCBieSB0aGlzLmJ5dGVzXG4gICAgICovXG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMucmVhZFVJbnQ4KDApO1xuICAgIH1cbn1cbmV4cG9ydHMuVUludDggPSBVSW50ODtcblVJbnQ4LndpZHRoID0gOCAvIDg7IC8vIDFcblVJbnQ4LmRlZmF1bHRVSW50OCA9IG5ldyBVSW50OChidWZmZXJfMS5CdWZmZXIuYWxsb2MoVUludDgud2lkdGgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpbnQtOC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/uint-8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/uint.js":
/*!*************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/uint.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UInt = void 0;\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\n/**\n * Compare numbers and bigInts n1 and n2\n *\n * @param n1 First object to compare\n * @param n2 Second object to compare\n * @returns -1, 0, or 1, depending on how the two objects compare\n */\nfunction compare(n1, n2) {\n    return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;\n}\n/**\n * Base class for serializing and deserializing unsigned integers.\n */\nclass UInt extends serialized_type_1.Comparable {\n    constructor(bytes) {\n        super(bytes);\n    }\n    /**\n     * Overload of compareTo for Comparable\n     *\n     * @param other other UInt to compare this to\n     * @returns -1, 0, or 1 depending on how the objects relate to each other\n     */\n    compareTo(other) {\n        return compare(this.valueOf(), other.valueOf());\n    }\n    /**\n     * Convert a UInt object to JSON\n     *\n     * @returns number or string represented by this.bytes\n     */\n    toJSON() {\n        const val = this.valueOf();\n        return typeof val === 'number' ? val : val.toString();\n    }\n}\nexports.UInt = UInt;\n//# sourceMappingURL=uint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3VpbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLDBCQUEwQixtQkFBTyxDQUFDLGlHQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvdWludC5qcz84NGE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VSW50ID0gdm9pZCAwO1xuY29uc3Qgc2VyaWFsaXplZF90eXBlXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVkLXR5cGVcIik7XG4vKipcbiAqIENvbXBhcmUgbnVtYmVycyBhbmQgYmlnSW50cyBuMSBhbmQgbjJcbiAqXG4gKiBAcGFyYW0gbjEgRmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBuMiBTZWNvbmQgb2JqZWN0IHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIC0xLCAwLCBvciAxLCBkZXBlbmRpbmcgb24gaG93IHRoZSB0d28gb2JqZWN0cyBjb21wYXJlXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUobjEsIG4yKSB7XG4gICAgcmV0dXJuIG4xIDwgbjIgPyAtMSA6IG4xID09IG4yID8gMCA6IDE7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHNlcmlhbGl6aW5nIGFuZCBkZXNlcmlhbGl6aW5nIHVuc2lnbmVkIGludGVnZXJzLlxuICovXG5jbGFzcyBVSW50IGV4dGVuZHMgc2VyaWFsaXplZF90eXBlXzEuQ29tcGFyYWJsZSB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoYnl0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVybG9hZCBvZiBjb21wYXJlVG8gZm9yIENvbXBhcmFibGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciBvdGhlciBVSW50IHRvIGNvbXBhcmUgdGhpcyB0b1xuICAgICAqIEByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiBob3cgdGhlIG9iamVjdHMgcmVsYXRlIHRvIGVhY2ggb3RoZXJcbiAgICAgKi9cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBVSW50IG9iamVjdCB0byBKU09OXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgPyB2YWwgOiB2YWwudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLlVJbnQgPSBVSW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWludC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/uint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/vector-256.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/vector-256.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Vector256 = void 0;\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst hash_256_1 = __webpack_require__(/*! ./hash-256 */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/hash-256.js\");\nconst binary_serializer_1 = __webpack_require__(/*! ../serdes/binary-serializer */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js\");\n/**\n * TypeGuard for Array<string>\n */\nfunction isStrings(arg) {\n    return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === 'string');\n}\n/**\n * Class for serializing and deserializing vectors of Hash256\n */\nclass Vector256 extends serialized_type_1.SerializedType {\n    constructor(bytes) {\n        super(bytes);\n    }\n    /**\n     * Construct a Vector256 from a BinaryParser\n     *\n     * @param parser BinaryParser to\n     * @param hint length of the vector, in bytes, optional\n     * @returns a Vector256 object\n     */\n    static fromParser(parser, hint) {\n        const bytesList = new binary_serializer_1.BytesList();\n        const bytes = hint !== null && hint !== void 0 ? hint : parser.size();\n        const hashes = bytes / 32;\n        for (let i = 0; i < hashes; i++) {\n            hash_256_1.Hash256.fromParser(parser).toBytesSink(bytesList);\n        }\n        return new Vector256(bytesList.toBytes());\n    }\n    /**\n     * Construct a Vector256 object from an array of hashes\n     *\n     * @param value A Vector256 object or array of hex-strings representing Hash256's\n     * @returns a Vector256 object\n     */\n    static from(value) {\n        if (value instanceof Vector256) {\n            return value;\n        }\n        if (isStrings(value)) {\n            const bytesList = new binary_serializer_1.BytesList();\n            value.forEach((hash) => {\n                hash_256_1.Hash256.from(hash).toBytesSink(bytesList);\n            });\n            return new Vector256(bytesList.toBytes());\n        }\n        throw new Error('Cannot construct Vector256 from given value');\n    }\n    /**\n     * Return an Array of hex-strings represented by this.bytes\n     *\n     * @returns An Array of strings representing the Hash256 objects\n     */\n    toJSON() {\n        if (this.bytes.byteLength % 32 !== 0) {\n            throw new Error('Invalid bytes for Vector256');\n        }\n        const result = [];\n        for (let i = 0; i < this.bytes.byteLength; i += 32) {\n            result.push(this.bytes\n                .slice(i, i + 32)\n                .toString('hex')\n                .toUpperCase());\n        }\n        return result;\n    }\n}\nexports.Vector256 = Vector256;\n//# sourceMappingURL=vector-256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3ZlY3Rvci0yNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLDBCQUEwQixtQkFBTyxDQUFDLGlHQUFtQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBWTtBQUN2Qyw0QkFBNEIsbUJBQU8sQ0FBQyw4R0FBNkI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvdmVjdG9yLTI1Ni5qcz9jOGQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WZWN0b3IyNTYgPSB2b2lkIDA7XG5jb25zdCBzZXJpYWxpemVkX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZWQtdHlwZVwiKTtcbmNvbnN0IGhhc2hfMjU2XzEgPSByZXF1aXJlKFwiLi9oYXNoLTI1NlwiKTtcbmNvbnN0IGJpbmFyeV9zZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi4vc2VyZGVzL2JpbmFyeS1zZXJpYWxpemVyXCIpO1xuLyoqXG4gKiBUeXBlR3VhcmQgZm9yIEFycmF5PHN0cmluZz5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmdzKGFyZykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZykgJiYgKGFyZy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIGFyZ1swXSA9PT0gJ3N0cmluZycpO1xufVxuLyoqXG4gKiBDbGFzcyBmb3Igc2VyaWFsaXppbmcgYW5kIGRlc2VyaWFsaXppbmcgdmVjdG9ycyBvZiBIYXNoMjU2XG4gKi9cbmNsYXNzIFZlY3RvcjI1NiBleHRlbmRzIHNlcmlhbGl6ZWRfdHlwZV8xLlNlcmlhbGl6ZWRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcihieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFZlY3RvcjI1NiBmcm9tIGEgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyc2VyIEJpbmFyeVBhcnNlciB0b1xuICAgICAqIEBwYXJhbSBoaW50IGxlbmd0aCBvZiB0aGUgdmVjdG9yLCBpbiBieXRlcywgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyBhIFZlY3RvcjI1NiBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBhcnNlcihwYXJzZXIsIGhpbnQpIHtcbiAgICAgICAgY29uc3QgYnl0ZXNMaXN0ID0gbmV3IGJpbmFyeV9zZXJpYWxpemVyXzEuQnl0ZXNMaXN0KCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gaGludCAhPT0gbnVsbCAmJiBoaW50ICE9PSB2b2lkIDAgPyBoaW50IDogcGFyc2VyLnNpemUoKTtcbiAgICAgICAgY29uc3QgaGFzaGVzID0gYnl0ZXMgLyAzMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoZXM7IGkrKykge1xuICAgICAgICAgICAgaGFzaF8yNTZfMS5IYXNoMjU2LmZyb21QYXJzZXIocGFyc2VyKS50b0J5dGVzU2luayhieXRlc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMjU2KGJ5dGVzTGlzdC50b0J5dGVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBWZWN0b3IyNTYgb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgaGFzaGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgQSBWZWN0b3IyNTYgb2JqZWN0IG9yIGFycmF5IG9mIGhleC1zdHJpbmdzIHJlcHJlc2VudGluZyBIYXNoMjU2J3NcbiAgICAgKiBAcmV0dXJucyBhIFZlY3RvcjI1NiBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBWZWN0b3IyNTYpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpbmdzKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXNMaXN0ID0gbmV3IGJpbmFyeV9zZXJpYWxpemVyXzEuQnl0ZXNMaXN0KCk7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChoYXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFzaF8yNTZfMS5IYXNoMjU2LmZyb20oaGFzaCkudG9CeXRlc1NpbmsoYnl0ZXNMaXN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyNTYoYnl0ZXNMaXN0LnRvQnl0ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IFZlY3RvcjI1NiBmcm9tIGdpdmVuIHZhbHVlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBBcnJheSBvZiBoZXgtc3RyaW5ncyByZXByZXNlbnRlZCBieSB0aGlzLmJ5dGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBBcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgSGFzaDI1NiBvYmplY3RzXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAodGhpcy5ieXRlcy5ieXRlTGVuZ3RoICUgMzIgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlcyBmb3IgVmVjdG9yMjU2Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ieXRlcy5ieXRlTGVuZ3RoOyBpICs9IDMyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmJ5dGVzXG4gICAgICAgICAgICAgICAgLnNsaWNlKGksIGkgKyAzMilcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5WZWN0b3IyNTYgPSBWZWN0b3IyNTY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWN0b3ItMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/vector-256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/types/xchain-bridge.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/types/xchain-bridge.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.XChainBridge = void 0;\nconst binary_parser_1 = __webpack_require__(/*! ../serdes/binary-parser */ \"(ssr)/./node_modules/ripple-binary-codec/dist/serdes/binary-parser.js\");\nconst account_id_1 = __webpack_require__(/*! ./account-id */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/account-id.js\");\nconst serialized_type_1 = __webpack_require__(/*! ./serialized-type */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/serialized-type.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst issue_1 = __webpack_require__(/*! ./issue */ \"(ssr)/./node_modules/ripple-binary-codec/dist/types/issue.js\");\n/**\n * Type guard for XChainBridgeObject\n */\nfunction isXChainBridgeObject(arg) {\n    const keys = Object.keys(arg).sort();\n    return (keys.length === 4 &&\n        keys[0] === 'IssuingChainDoor' &&\n        keys[1] === 'IssuingChainIssue' &&\n        keys[2] === 'LockingChainDoor' &&\n        keys[3] === 'LockingChainIssue');\n}\n/**\n * Class for serializing/deserializing XChainBridges\n */\nclass XChainBridge extends serialized_type_1.SerializedType {\n    constructor(bytes) {\n        super(bytes !== null && bytes !== void 0 ? bytes : XChainBridge.ZERO_XCHAIN_BRIDGE.bytes);\n    }\n    /**\n     * Construct a cross-chain bridge from a JSON\n     *\n     * @param value XChainBridge or JSON to parse into an XChainBridge\n     * @returns An XChainBridge object\n     */\n    static from(value) {\n        if (value instanceof XChainBridge) {\n            return value;\n        }\n        if (!isXChainBridgeObject(value)) {\n            throw new Error('Invalid type to construct an XChainBridge');\n        }\n        const bytes = [];\n        this.TYPE_ORDER.forEach((item) => {\n            const { name, type } = item;\n            if (type === account_id_1.AccountID) {\n                bytes.push(buffer_1.Buffer.from([0x14]));\n            }\n            const object = type.from(value[name]);\n            bytes.push(object.toBytes());\n        });\n        return new XChainBridge(buffer_1.Buffer.concat(bytes));\n    }\n    /**\n     * Read an XChainBridge from a BinaryParser\n     *\n     * @param parser BinaryParser to read the XChainBridge from\n     * @returns An XChainBridge object\n     */\n    static fromParser(parser) {\n        const bytes = [];\n        this.TYPE_ORDER.forEach((item) => {\n            const { type } = item;\n            if (type === account_id_1.AccountID) {\n                parser.skip(1);\n                bytes.push(buffer_1.Buffer.from([0x14]));\n            }\n            const object = type.fromParser(parser);\n            bytes.push(object.toBytes());\n        });\n        return new XChainBridge(buffer_1.Buffer.concat(bytes));\n    }\n    /**\n     * Get the JSON representation of this XChainBridge\n     *\n     * @returns the JSON interpretation of this.bytes\n     */\n    toJSON() {\n        const parser = new binary_parser_1.BinaryParser(this.toString());\n        const json = {};\n        XChainBridge.TYPE_ORDER.forEach((item) => {\n            const { name, type } = item;\n            if (type === account_id_1.AccountID) {\n                parser.skip(1);\n            }\n            const object = type.fromParser(parser).toJSON();\n            json[name] = object;\n        });\n        return json;\n    }\n}\nexports.XChainBridge = XChainBridge;\nXChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge(buffer_1.Buffer.concat([\n    buffer_1.Buffer.from([0x14]),\n    buffer_1.Buffer.alloc(40),\n    buffer_1.Buffer.from([0x14]),\n    buffer_1.Buffer.alloc(40),\n]));\nXChainBridge.TYPE_ORDER = [\n    { name: 'LockingChainDoor', type: account_id_1.AccountID },\n    { name: 'LockingChainIssue', type: issue_1.Issue },\n    { name: 'IssuingChainDoor', type: account_id_1.AccountID },\n    { name: 'IssuingChainIssue', type: issue_1.Issue },\n];\n//# sourceMappingURL=xchain-bridge.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3hjaGFpbi1icmlkZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLHdCQUF3QixtQkFBTyxDQUFDLHNHQUF5QjtBQUN6RCxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBYztBQUMzQywwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBbUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0RBQXdEO0FBQzlELE1BQU0sZ0RBQWdEO0FBQ3RELE1BQU0sd0RBQXdEO0FBQzlELE1BQU0sZ0RBQWdEO0FBQ3REO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMveGNoYWluLWJyaWRnZS5qcz9mNDRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5YQ2hhaW5CcmlkZ2UgPSB2b2lkIDA7XG5jb25zdCBiaW5hcnlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vc2VyZGVzL2JpbmFyeS1wYXJzZXJcIik7XG5jb25zdCBhY2NvdW50X2lkXzEgPSByZXF1aXJlKFwiLi9hY2NvdW50LWlkXCIpO1xuY29uc3Qgc2VyaWFsaXplZF90eXBlXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVkLXR5cGVcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuY29uc3QgaXNzdWVfMSA9IHJlcXVpcmUoXCIuL2lzc3VlXCIpO1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBYQ2hhaW5CcmlkZ2VPYmplY3RcbiAqL1xuZnVuY3Rpb24gaXNYQ2hhaW5CcmlkZ2VPYmplY3QoYXJnKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZykuc29ydCgpO1xuICAgIHJldHVybiAoa2V5cy5sZW5ndGggPT09IDQgJiZcbiAgICAgICAga2V5c1swXSA9PT0gJ0lzc3VpbmdDaGFpbkRvb3InICYmXG4gICAgICAgIGtleXNbMV0gPT09ICdJc3N1aW5nQ2hhaW5Jc3N1ZScgJiZcbiAgICAgICAga2V5c1syXSA9PT0gJ0xvY2tpbmdDaGFpbkRvb3InICYmXG4gICAgICAgIGtleXNbM10gPT09ICdMb2NraW5nQ2hhaW5Jc3N1ZScpO1xufVxuLyoqXG4gKiBDbGFzcyBmb3Igc2VyaWFsaXppbmcvZGVzZXJpYWxpemluZyBYQ2hhaW5CcmlkZ2VzXG4gKi9cbmNsYXNzIFhDaGFpbkJyaWRnZSBleHRlbmRzIHNlcmlhbGl6ZWRfdHlwZV8xLlNlcmlhbGl6ZWRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcihieXRlcyAhPT0gbnVsbCAmJiBieXRlcyAhPT0gdm9pZCAwID8gYnl0ZXMgOiBYQ2hhaW5CcmlkZ2UuWkVST19YQ0hBSU5fQlJJREdFLmJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgY3Jvc3MtY2hhaW4gYnJpZGdlIGZyb20gYSBKU09OXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgWENoYWluQnJpZGdlIG9yIEpTT04gdG8gcGFyc2UgaW50byBhbiBYQ2hhaW5CcmlkZ2VcbiAgICAgKiBAcmV0dXJucyBBbiBYQ2hhaW5CcmlkZ2Ugb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgWENoYWluQnJpZGdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1hDaGFpbkJyaWRnZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlIHRvIGNvbnN0cnVjdCBhbiBYQ2hhaW5CcmlkZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgICAgICB0aGlzLlRZUEVfT1JERVIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IGFjY291bnRfaWRfMS5BY2NvdW50SUQpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFsweDE0XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gdHlwZS5mcm9tKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2gob2JqZWN0LnRvQnl0ZXMoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFhDaGFpbkJyaWRnZShidWZmZXJfMS5CdWZmZXIuY29uY2F0KGJ5dGVzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYW4gWENoYWluQnJpZGdlIGZyb20gYSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJzZXIgQmluYXJ5UGFyc2VyIHRvIHJlYWQgdGhlIFhDaGFpbkJyaWRnZSBmcm9tXG4gICAgICogQHJldHVybnMgQW4gWENoYWluQnJpZGdlIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUGFyc2VyKHBhcnNlcikge1xuICAgICAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgICAgICB0aGlzLlRZUEVfT1JERVIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IGFjY291bnRfaWRfMS5BY2NvdW50SUQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2tpcCgxKTtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFsweDE0XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gdHlwZS5mcm9tUGFyc2VyKHBhcnNlcik7XG4gICAgICAgICAgICBieXRlcy5wdXNoKG9iamVjdC50b0J5dGVzKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBYQ2hhaW5CcmlkZ2UoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChieXRlcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBYQ2hhaW5CcmlkZ2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBKU09OIGludGVycHJldGF0aW9uIG9mIHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBiaW5hcnlfcGFyc2VyXzEuQmluYXJ5UGFyc2VyKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7fTtcbiAgICAgICAgWENoYWluQnJpZGdlLlRZUEVfT1JERVIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IGFjY291bnRfaWRfMS5BY2NvdW50SUQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2tpcCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHR5cGUuZnJvbVBhcnNlcihwYXJzZXIpLnRvSlNPTigpO1xuICAgICAgICAgICAganNvbltuYW1lXSA9IG9iamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbn1cbmV4cG9ydHMuWENoYWluQnJpZGdlID0gWENoYWluQnJpZGdlO1xuWENoYWluQnJpZGdlLlpFUk9fWENIQUlOX0JSSURHRSA9IG5ldyBYQ2hhaW5CcmlkZ2UoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbXG4gICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oWzB4MTRdKSxcbiAgICBidWZmZXJfMS5CdWZmZXIuYWxsb2MoNDApLFxuICAgIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFsweDE0XSksXG4gICAgYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDQwKSxcbl0pKTtcblhDaGFpbkJyaWRnZS5UWVBFX09SREVSID0gW1xuICAgIHsgbmFtZTogJ0xvY2tpbmdDaGFpbkRvb3InLCB0eXBlOiBhY2NvdW50X2lkXzEuQWNjb3VudElEIH0sXG4gICAgeyBuYW1lOiAnTG9ja2luZ0NoYWluSXNzdWUnLCB0eXBlOiBpc3N1ZV8xLklzc3VlIH0sXG4gICAgeyBuYW1lOiAnSXNzdWluZ0NoYWluRG9vcicsIHR5cGU6IGFjY291bnRfaWRfMS5BY2NvdW50SUQgfSxcbiAgICB7IG5hbWU6ICdJc3N1aW5nQ2hhaW5Jc3N1ZScsIHR5cGU6IGlzc3VlXzEuSXNzdWUgfSxcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD14Y2hhaW4tYnJpZGdlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/dist/types/xchain-bridge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/node_modules/big-integer/BigInteger.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/node_modules/big-integer/BigInteger.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < digits[i]) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif ( true && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n        return bigInt;\r\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9ub2RlX21vZHVsZXMvYmlnLWludGVnZXIvQmlnSW50ZWdlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxlQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUJBQXFCLElBQUk7QUFDeEU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSSxLQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBMEM7QUFDOUMsSUFBSSxtQ0FBUTtBQUNaO0FBQ0EsS0FBSztBQUFBLGtHQUFDO0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL25vZGVfbW9kdWxlcy9iaWctaW50ZWdlci9CaWdJbnRlZ2VyLmpzPzM5ZmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJpZ0ludCA9IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgQkFTRSA9IDFlNyxcclxuICAgICAgICBMT0dfQkFTRSA9IDcsXHJcbiAgICAgICAgTUFYX0lOVCA9IDkwMDcxOTkyNTQ3NDA5OTIsXHJcbiAgICAgICAgTUFYX0lOVF9BUlIgPSBzbWFsbFRvQXJyYXkoTUFYX0lOVCksXHJcbiAgICAgICAgREVGQVVMVF9BTFBIQUJFVCA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XHJcblxyXG4gICAgdmFyIHN1cHBvcnRzTmF0aXZlQmlnSW50ID0gdHlwZW9mIEJpZ0ludCA9PT0gXCJmdW5jdGlvblwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIEludGVnZXIodiwgcmFkaXgsIGFscGhhYmV0LCBjYXNlU2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICBpZiAodHlwZW9mIHJhZGl4ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gK3JhZGl4ID09PSAxMCAmJiAhYWxwaGFiZXQgPyBwYXJzZVZhbHVlKHYpIDogcGFyc2VCYXNlKHYsIHJhZGl4LCBhbHBoYWJldCwgY2FzZVNlbnNpdGl2ZSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQmlnSW50ZWdlcih2YWx1ZSwgc2lnbikge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnNpZ24gPSBzaWduO1xyXG4gICAgICAgIHRoaXMuaXNTbWFsbCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEludGVnZXIucHJvdG90eXBlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBTbWFsbEludGVnZXIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zaWduID0gdmFsdWUgPCAwO1xyXG4gICAgICAgIHRoaXMuaXNTbWFsbCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlZ2VyLnByb3RvdHlwZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTmF0aXZlQmlnSW50KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzUHJlY2lzZShuKSB7XHJcbiAgICAgICAgcmV0dXJuIC1NQVhfSU5UIDwgbiAmJiBuIDwgTUFYX0lOVDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbWFsbFRvQXJyYXkobikgeyAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBkb2Vzbid0IHJlZmVyZW5jZSBCQVNFLCBuZWVkIHRvIGNoYW5nZSB0aGlzIGZ1bmN0aW9uIGlmIEJBU0UgY2hhbmdlc1xyXG4gICAgICAgIGlmIChuIDwgMWU3KVxyXG4gICAgICAgICAgICByZXR1cm4gW25dO1xyXG4gICAgICAgIGlmIChuIDwgMWUxNClcclxuICAgICAgICAgICAgcmV0dXJuIFtuICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTcpXTtcclxuICAgICAgICByZXR1cm4gW24gJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlNykgJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlMTQpXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcnJheVRvU21hbGwoYXJyKSB7IC8vIElmIEJBU0UgY2hhbmdlcyB0aGlzIGZ1bmN0aW9uIG1heSBuZWVkIHRvIGNoYW5nZVxyXG4gICAgICAgIHRyaW0oYXJyKTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoIDwgNCAmJiBjb21wYXJlQWJzKGFyciwgTUFYX0lOVF9BUlIpIDwgMCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGFyclswXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGFyclswXSArIGFyclsxXSAqIEJBU0U7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gYXJyWzBdICsgKGFyclsxXSArIGFyclsyXSAqIEJBU0UpICogQkFTRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyaW0odikge1xyXG4gICAgICAgIHZhciBpID0gdi5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKHZbLS1pXSA9PT0gMCk7XHJcbiAgICAgICAgdi5sZW5ndGggPSBpICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpIHsgLy8gZnVuY3Rpb24gc2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gWWFmZmxlJ3MgbGlicmFyeSBodHRwczovL2dpdGh1Yi5jb20vWWFmZmxlL0JpZ0ludGVnZXJcclxuICAgICAgICB2YXIgeCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIHZhciBpID0gLTE7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB4W2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUobikge1xyXG4gICAgICAgIGlmIChuID4gMCkgcmV0dXJuIE1hdGguZmxvb3Iobik7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChuKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGQoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEubGVuZ3RoID49IGIubGVuZ3RoXHJcbiAgICAgICAgdmFyIGxfYSA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBsX2IgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsX2EpLFxyXG4gICAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBzdW0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxfYjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gKyBiW2ldICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gc3VtID49IGJhc2UgPyAxIDogMDtcclxuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsX2EpIHtcclxuICAgICAgICAgICAgc3VtID0gYVtpXSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IHN1bSA9PT0gYmFzZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICByW2krK10gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYXJyeSA+IDApIHIucHVzaChjYXJyeSk7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkQW55KGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggPj0gYi5sZW5ndGgpIHJldHVybiBhZGQoYSwgYik7XHJcbiAgICAgICAgcmV0dXJuIGFkZChiLCBhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTbWFsbChhLCBjYXJyeSkgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGNhcnJ5IGlzIG51bWJlciB3aXRoIDAgPD0gY2FycnkgPCBNQVhfSU5UXHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHN1bSwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gLSBiYXNlICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihzdW0gLyBiYXNlKTtcclxuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICAgICAgY2FycnkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xyXG4gICAgICAgICAgICByW2krK10gPSBjYXJyeSAlIGJhc2U7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYSwgTWF0aC5hYnMoYikpLCB0aGlzLnNpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkQW55KGEsIGIpLCB0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBsdXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UoYSArIGIpKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhICsgYik7XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoTWF0aC5hYnMoYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYiwgTWF0aC5hYnMoYSkpLCBhIDwgMCk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wbHVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgKyBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcclxuICAgIH1cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUucGx1cyA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYWRkO1xyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHsgLy8gYXNzdW1lcyBhIGFuZCBiIGFyZSBhcnJheXMgd2l0aCBhID49IGJcclxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGFfbCksXHJcbiAgICAgICAgICAgIGJvcnJvdyA9IDAsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBpLCBkaWZmZXJlbmNlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBiX2w7IGkrKykge1xyXG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gYVtpXSAtIGJvcnJvdyAtIGJbaV07XHJcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZGlmZmVyZW5jZSArPSBiYXNlO1xyXG4gICAgICAgICAgICAgICAgYm9ycm93ID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIGJvcnJvdyA9IDA7XHJcbiAgICAgICAgICAgIHJbaV0gPSBkaWZmZXJlbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSBiX2w7IGkgPCBhX2w7IGkrKykge1xyXG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gYVtpXSAtIGJvcnJvdztcclxuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSBkaWZmZXJlbmNlICs9IGJhc2U7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcltpKytdID0gZGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbaV0gPSBkaWZmZXJlbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKDsgaSA8IGFfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJbaV0gPSBhW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmltKHIpO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0QW55KGEsIGIsIHNpZ24pIHtcclxuICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgaWYgKGNvbXBhcmVBYnMoYSwgYikgPj0gMCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHN1YnRyYWN0KGEsIGIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gc3VidHJhY3QoYiwgYSk7XHJcbiAgICAgICAgICAgIHNpZ24gPSAhc2lnbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWUgPSBhcnJheVRvU21hbGwodmFsdWUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKHNpZ24pIHZhbHVlID0gLXZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcih2YWx1ZSwgc2lnbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3RTbWFsbChhLCBiLCBzaWduKSB7IC8vIGFzc3VtZXMgYSBpcyBhcnJheSwgYiBpcyBudW1iZXIgd2l0aCAwIDw9IGIgPCBNQVhfSU5UXHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcclxuICAgICAgICAgICAgY2FycnkgPSAtYixcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGksIGRpZmZlcmVuY2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gYVtpXSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IoZGlmZmVyZW5jZSAvIGJhc2UpO1xyXG4gICAgICAgICAgICBkaWZmZXJlbmNlICU9IGJhc2U7XHJcbiAgICAgICAgICAgIHJbaV0gPSBkaWZmZXJlbmNlIDwgMCA/IGRpZmZlcmVuY2UgKyBiYXNlIDogZGlmZmVyZW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgciA9IGFycmF5VG9TbWFsbChyKTtcclxuICAgICAgICBpZiAodHlwZW9mIHIgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKHNpZ24pIHIgPSAtcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIocik7XHJcbiAgICAgICAgfSByZXR1cm4gbmV3IEJpZ0ludGVnZXIociwgc2lnbik7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpXHJcbiAgICAgICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKGEsIE1hdGguYWJzKGIpLCB0aGlzLnNpZ24pO1xyXG4gICAgICAgIHJldHVybiBzdWJ0cmFjdEFueShhLCBiLCB0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbnVzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAoYSA8IDAgIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKGEgLSBiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwoYiwgTWF0aC5hYnMoYSksIGEgPj0gMCk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5taW51cyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAtIHBhcnNlVmFsdWUodikudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5taW51cyA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcih0aGlzLnZhbHVlLCAhdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2lnbiA9IHRoaXMuc2lnbjtcclxuICAgICAgICB2YXIgc21hbGwgPSBuZXcgU21hbGxJbnRlZ2VyKC10aGlzLnZhbHVlKTtcclxuICAgICAgICBzbWFsbC5zaWduID0gIXNpZ247XHJcbiAgICAgICAgcmV0dXJuIHNtYWxsO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KC10aGlzLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMudmFsdWUsIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihNYXRoLmFicyh0aGlzLnZhbHVlKSk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSA+PSAwID8gdGhpcy52YWx1ZSA6IC10aGlzLnZhbHVlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlMb25nKGEsIGIpIHtcclxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICBsID0gYV9sICsgYl9sLFxyXG4gICAgICAgICAgICByID0gY3JlYXRlQXJyYXkobCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBwcm9kdWN0LCBjYXJyeSwgaSwgYV9pLCBiX2o7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFfbDsgKytpKSB7XHJcbiAgICAgICAgICAgIGFfaSA9IGFbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYl9sOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGJfaiA9IGJbal07XHJcbiAgICAgICAgICAgICAgICBwcm9kdWN0ID0gYV9pICogYl9qICsgcltpICsgal07XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcltpICsgal0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgICAgICAgICAgcltpICsgaiArIDFdICs9IGNhcnJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlTbWFsbChhLCBiKSB7IC8vIGFzc3VtZXMgYSBpcyBhcnJheSwgYiBpcyBudW1iZXIgd2l0aCB8YnwgPCBCQVNFXHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgICAgcHJvZHVjdCwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHByb2R1Y3QgPSBhW2ldICogYiArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xyXG4gICAgICAgICAgICByW2ldID0gcHJvZHVjdCAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xyXG4gICAgICAgICAgICByW2krK10gPSBjYXJyeSAlIGJhc2U7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzaGlmdExlZnQoeCwgbikge1xyXG4gICAgICAgIHZhciByID0gW107XHJcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHIucHVzaCgwKTtcclxuICAgICAgICByZXR1cm4gci5jb25jYXQoeCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlLYXJhdHN1YmEoeCwgeSkge1xyXG4gICAgICAgIHZhciBuID0gTWF0aC5tYXgoeC5sZW5ndGgsIHkubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgaWYgKG4gPD0gMzApIHJldHVybiBtdWx0aXBseUxvbmcoeCwgeSk7XHJcbiAgICAgICAgbiA9IE1hdGguY2VpbChuIC8gMik7XHJcblxyXG4gICAgICAgIHZhciBiID0geC5zbGljZShuKSxcclxuICAgICAgICAgICAgYSA9IHguc2xpY2UoMCwgbiksXHJcbiAgICAgICAgICAgIGQgPSB5LnNsaWNlKG4pLFxyXG4gICAgICAgICAgICBjID0geS5zbGljZSgwLCBuKTtcclxuXHJcbiAgICAgICAgdmFyIGFjID0gbXVsdGlwbHlLYXJhdHN1YmEoYSwgYyksXHJcbiAgICAgICAgICAgIGJkID0gbXVsdGlwbHlLYXJhdHN1YmEoYiwgZCksXHJcbiAgICAgICAgICAgIGFiY2QgPSBtdWx0aXBseUthcmF0c3ViYShhZGRBbnkoYSwgYiksIGFkZEFueShjLCBkKSk7XHJcblxyXG4gICAgICAgIHZhciBwcm9kdWN0ID0gYWRkQW55KGFkZEFueShhYywgc2hpZnRMZWZ0KHN1YnRyYWN0KHN1YnRyYWN0KGFiY2QsIGFjKSwgYmQpLCBuKSksIHNoaWZ0TGVmdChiZCwgMiAqIG4pKTtcclxuICAgICAgICB0cmltKHByb2R1Y3QpO1xyXG4gICAgICAgIHJldHVybiBwcm9kdWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIGEgc3VyZmFjZSBmaXQgb2YgYSBncmFwaCBwbG90dGluZyB0aGUgcGVyZm9ybWFuY2UgZGlmZmVyZW5jZVxyXG4gICAgLy8gYmV0d2VlbiBsb25nIG11bHRpcGxpY2F0aW9uIGFuZCBrYXJhdHN1YmEgbXVsdGlwbGljYXRpb24gdmVyc3VzIHRoZSBsZW5ndGhzIG9mIHRoZSB0d28gYXJyYXlzLlxyXG4gICAgZnVuY3Rpb24gdXNlS2FyYXRzdWJhKGwxLCBsMikge1xyXG4gICAgICAgIHJldHVybiAtMC4wMTIgKiBsMSAtIDAuMDEyICogbDIgKyAwLjAwMDAxNSAqIGwxICogbDIgPiAwO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZSxcclxuICAgICAgICAgICAgc2lnbiA9IHRoaXMuc2lnbiAhPT0gbi5zaWduLFxyXG4gICAgICAgICAgICBhYnM7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgICAgIGlmIChiID09PSAxKSByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgaWYgKGIgPT09IC0xKSByZXR1cm4gdGhpcy5uZWdhdGUoKTtcclxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMoYik7XHJcbiAgICAgICAgICAgIGlmIChhYnMgPCBCQVNFKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlTbWFsbChhLCBhYnMpLCBzaWduKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gc21hbGxUb0FycmF5KGFicyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1c2VLYXJhdHN1YmEoYS5sZW5ndGgsIGIubGVuZ3RoKSkgLy8gS2FyYXRzdWJhIGlzIG9ubHkgZmFzdGVyIGZvciBjZXJ0YWluIGFycmF5IHNpemVzXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUthcmF0c3ViYShhLCBiKSwgc2lnbik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5TG9uZyhhLCBiKSwgc2lnbik7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRpbWVzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlTbWFsbEFuZEFycmF5KGEsIGIsIHNpZ24pIHsgLy8gYSA+PSAwXHJcbiAgICAgICAgaWYgKGEgPCBCQVNFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseVNtYWxsKGIsIGEpLCBzaWduKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5TG9uZyhiLCBzbWFsbFRvQXJyYXkoYSkpLCBzaWduKTtcclxuICAgIH1cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgaWYgKGlzUHJlY2lzZShhLnZhbHVlICogdGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYS52YWx1ZSAqIHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLCBzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpLCB0aGlzLnNpZ24gIT09IGEuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgaWYgKGEudmFsdWUgPT09IDApIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgIGlmIChhLnZhbHVlID09PSAxKSByZXR1cm4gdGhpcztcclxuICAgICAgICBpZiAoYS52YWx1ZSA9PT0gLTEpIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xyXG4gICAgICAgIHJldHVybiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoTWF0aC5hYnMoYS52YWx1ZSksIHRoaXMudmFsdWUsIHRoaXMuc2lnbiAhPT0gYS5zaWduKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VWYWx1ZSh2KS5fbXVsdGlwbHlCeVNtYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudGltZXMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgKiBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcclxuICAgIH1cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudGltZXMgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNxdWFyZShhKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmFzc2VydCgyICogQkFTRSAqIEJBU0UgPCBNQVhfSU5UKTtcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gY3JlYXRlQXJyYXkobCArIGwpLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgcHJvZHVjdCwgY2FycnksIGksIGFfaSwgYV9qO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgYV9pID0gYVtpXTtcclxuICAgICAgICAgICAgY2FycnkgPSAwIC0gYV9pICogYV9pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYV9qID0gYVtqXTtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3QgPSAyICogKGFfaSAqIGFfaikgKyByW2kgKyBqXSArIGNhcnJ5O1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHByb2R1Y3QgLyBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHJbaSArIGpdID0gcHJvZHVjdCAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW2kgKyBsXSA9IGNhcnJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmltKHIpO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoc3F1YXJlKHRoaXMudmFsdWUpLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUgKiB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmIChpc1ByZWNpc2UodmFsdWUpKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHNxdWFyZShzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpKSwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAqIHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpdk1vZDEoYSwgYikgeyAvLyBMZWZ0IG92ZXIgZnJvbSBwcmV2aW91cyB2ZXJzaW9uLiBQZXJmb3JtcyBmYXN0ZXIgdGhhbiBkaXZNb2QyIG9uIHNtYWxsZXIgaW5wdXQgc2l6ZXMuXHJcbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGIubGVuZ3RoKSxcclxuICAgICAgICAgICAgZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0ID0gYltiX2wgLSAxXSxcclxuICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvblxyXG4gICAgICAgICAgICBsYW1iZGEgPSBNYXRoLmNlaWwoYmFzZSAvICgyICogZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KSksXHJcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IG11bHRpcGx5U21hbGwoYSwgbGFtYmRhKSxcclxuICAgICAgICAgICAgZGl2aXNvciA9IG11bHRpcGx5U21hbGwoYiwgbGFtYmRhKSxcclxuICAgICAgICAgICAgcXVvdGllbnREaWdpdCwgc2hpZnQsIGNhcnJ5LCBib3Jyb3csIGksIGwsIHE7XHJcbiAgICAgICAgaWYgKHJlbWFpbmRlci5sZW5ndGggPD0gYV9sKSByZW1haW5kZXIucHVzaCgwKTtcclxuICAgICAgICBkaXZpc29yLnB1c2goMCk7XHJcbiAgICAgICAgZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0ID0gZGl2aXNvcltiX2wgLSAxXTtcclxuICAgICAgICBmb3IgKHNoaWZ0ID0gYV9sIC0gYl9sOyBzaGlmdCA+PSAwOyBzaGlmdC0tKSB7XHJcbiAgICAgICAgICAgIHF1b3RpZW50RGlnaXQgPSBiYXNlIC0gMTtcclxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlcltzaGlmdCArIGJfbF0gIT09IGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCkge1xyXG4gICAgICAgICAgICAgICAgcXVvdGllbnREaWdpdCA9IE1hdGguZmxvb3IoKHJlbWFpbmRlcltzaGlmdCArIGJfbF0gKiBiYXNlICsgcmVtYWluZGVyW3NoaWZ0ICsgYl9sIC0gMV0pIC8gZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBxdW90aWVudERpZ2l0IDw9IGJhc2UgLSAxXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcclxuICAgICAgICAgICAgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgbCA9IGRpdmlzb3IubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBxdW90aWVudERpZ2l0ICogZGl2aXNvcltpXTtcclxuICAgICAgICAgICAgICAgIHEgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgKz0gcmVtYWluZGVyW3NoaWZ0ICsgaV0gLSAoY2FycnkgLSBxICogYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IHE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9ycm93IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gYm9ycm93ICsgYmFzZTtcclxuICAgICAgICAgICAgICAgICAgICBib3Jyb3cgPSAtMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBib3Jyb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoYm9ycm93ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBxdW90aWVudERpZ2l0IC09IDE7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FycnkgKz0gcmVtYWluZGVyW3NoaWZ0ICsgaV0gLSBiYXNlICsgZGl2aXNvcltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FycnkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gY2FycnkgKyBiYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBjYXJyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJvcnJvdyArPSBjYXJyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRbc2hpZnRdID0gcXVvdGllbnREaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGVub3JtYWxpemF0aW9uXHJcbiAgICAgICAgcmVtYWluZGVyID0gZGl2TW9kU21hbGwocmVtYWluZGVyLCBsYW1iZGEpWzBdO1xyXG4gICAgICAgIHJldHVybiBbYXJyYXlUb1NtYWxsKHJlc3VsdCksIGFycmF5VG9TbWFsbChyZW1haW5kZXIpXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXZNb2QyKGEsIGIpIHsgLy8gSW1wbGVtZW50YXRpb24gaWRlYSBzaGFtZWxlc3NseSBzdG9sZW4gZnJvbSBTaWxlbnQgTWF0dCdzIGxpYnJhcnkgaHR0cDovL3NpbGVudG1hdHQuY29tL2JpZ2ludGVnZXIvXHJcbiAgICAgICAgLy8gUGVyZm9ybXMgZmFzdGVyIHRoYW4gZGl2TW9kMSBvbiBsYXJnZXIgaW5wdXQgc2l6ZXMuXHJcbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXHJcbiAgICAgICAgICAgIHBhcnQgPSBbXSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGd1ZXNzLCB4bGVuLCBoaWdoeCwgaGlnaHksIGNoZWNrO1xyXG4gICAgICAgIHdoaWxlIChhX2wpIHtcclxuICAgICAgICAgICAgcGFydC51bnNoaWZ0KGFbLS1hX2xdKTtcclxuICAgICAgICAgICAgdHJpbShwYXJ0KTtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmVBYnMocGFydCwgYikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhsZW4gPSBwYXJ0Lmxlbmd0aDtcclxuICAgICAgICAgICAgaGlnaHggPSBwYXJ0W3hsZW4gLSAxXSAqIGJhc2UgKyBwYXJ0W3hsZW4gLSAyXTtcclxuICAgICAgICAgICAgaGlnaHkgPSBiW2JfbCAtIDFdICogYmFzZSArIGJbYl9sIC0gMl07XHJcbiAgICAgICAgICAgIGlmICh4bGVuID4gYl9sKSB7XHJcbiAgICAgICAgICAgICAgICBoaWdoeCA9IChoaWdoeCArIDEpICogYmFzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBndWVzcyA9IE1hdGguY2VpbChoaWdoeCAvIGhpZ2h5KTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgY2hlY2sgPSBtdWx0aXBseVNtYWxsKGIsIGd1ZXNzKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlQWJzKGNoZWNrLCBwYXJ0KSA8PSAwKSBicmVhaztcclxuICAgICAgICAgICAgICAgIGd1ZXNzLS07XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKGd1ZXNzKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZ3Vlc3MpO1xyXG4gICAgICAgICAgICBwYXJ0ID0gc3VidHJhY3QocGFydCwgY2hlY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIHJldHVybiBbYXJyYXlUb1NtYWxsKHJlc3VsdCksIGFycmF5VG9TbWFsbChwYXJ0KV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kU21hbGwodmFsdWUsIGxhbWJkYSkge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHF1b3RpZW50ID0gY3JlYXRlQXJyYXkobGVuZ3RoKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGksIHEsIHJlbWFpbmRlciwgZGl2aXNvcjtcclxuICAgICAgICByZW1haW5kZXIgPSAwO1xyXG4gICAgICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSByZW1haW5kZXIgKiBiYXNlICsgdmFsdWVbaV07XHJcbiAgICAgICAgICAgIHEgPSB0cnVuY2F0ZShkaXZpc29yIC8gbGFtYmRhKTtcclxuICAgICAgICAgICAgcmVtYWluZGVyID0gZGl2aXNvciAtIHEgKiBsYW1iZGE7XHJcbiAgICAgICAgICAgIHF1b3RpZW50W2ldID0gcSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbcXVvdGllbnQsIHJlbWFpbmRlciB8IDBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpdk1vZEFueShzZWxmLCB2KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlLCBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICBpZiAoc3VwcG9ydHNOYXRpdmVCaWdJbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtuZXcgTmF0aXZlQmlnSW50KHNlbGYudmFsdWUgLyBuLnZhbHVlKSwgbmV3IE5hdGl2ZUJpZ0ludChzZWxmLnZhbHVlICUgbi52YWx1ZSldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYSA9IHNlbGYudmFsdWUsIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIHZhciBxdW90aWVudDtcclxuICAgICAgICBpZiAoYiA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpdmlkZSBieSB6ZXJvXCIpO1xyXG4gICAgICAgIGlmIChzZWxmLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKGEgLyBiKSksIG5ldyBTbWFsbEludGVnZXIoYSAlIGIpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW0ludGVnZXJbMF0sIHNlbGZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChiID09PSAxKSByZXR1cm4gW3NlbGYsIEludGVnZXJbMF1dO1xyXG4gICAgICAgICAgICBpZiAoYiA9PSAtMSkgcmV0dXJuIFtzZWxmLm5lZ2F0ZSgpLCBJbnRlZ2VyWzBdXTtcclxuICAgICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKGIpO1xyXG4gICAgICAgICAgICBpZiAoYWJzIDwgQkFTRSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkaXZNb2RTbWFsbChhLCBhYnMpO1xyXG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBhcnJheVRvU21hbGwodmFsdWVbMF0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IHZhbHVlWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2lnbikgcmVtYWluZGVyID0gLXJlbWFpbmRlcjtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVvdGllbnQgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaWduICE9PSBuLnNpZ24pIHF1b3RpZW50ID0gLXF1b3RpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFNtYWxsSW50ZWdlcihxdW90aWVudCksIG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LCBzZWxmLnNpZ24gIT09IG4uc2lnbiksIG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IHNtYWxsVG9BcnJheShhYnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcGFyaXNvbiA9IGNvbXBhcmVBYnMoYSwgYik7XHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gPT09IC0xKSByZXR1cm4gW0ludGVnZXJbMF0sIHNlbGZdO1xyXG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSAwKSByZXR1cm4gW0ludGVnZXJbc2VsZi5zaWduID09PSBuLnNpZ24gPyAxIDogLTFdLCBJbnRlZ2VyWzBdXTtcclxuXHJcbiAgICAgICAgLy8gZGl2TW9kMSBpcyBmYXN0ZXIgb24gc21hbGxlciBpbnB1dCBzaXplc1xyXG4gICAgICAgIGlmIChhLmxlbmd0aCArIGIubGVuZ3RoIDw9IDIwMClcclxuICAgICAgICAgICAgdmFsdWUgPSBkaXZNb2QxKGEsIGIpO1xyXG4gICAgICAgIGVsc2UgdmFsdWUgPSBkaXZNb2QyKGEsIGIpO1xyXG5cclxuICAgICAgICBxdW90aWVudCA9IHZhbHVlWzBdO1xyXG4gICAgICAgIHZhciBxU2lnbiA9IHNlbGYuc2lnbiAhPT0gbi5zaWduLFxyXG4gICAgICAgICAgICBtb2QgPSB2YWx1ZVsxXSxcclxuICAgICAgICAgICAgbVNpZ24gPSBzZWxmLnNpZ247XHJcbiAgICAgICAgaWYgKHR5cGVvZiBxdW90aWVudCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAocVNpZ24pIHF1b3RpZW50ID0gLXF1b3RpZW50O1xyXG4gICAgICAgICAgICBxdW90aWVudCA9IG5ldyBTbWFsbEludGVnZXIocXVvdGllbnQpO1xyXG4gICAgICAgIH0gZWxzZSBxdW90aWVudCA9IG5ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LCBxU2lnbik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtb2QgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKG1TaWduKSBtb2QgPSAtbW9kO1xyXG4gICAgICAgICAgICBtb2QgPSBuZXcgU21hbGxJbnRlZ2VyKG1vZCk7XHJcbiAgICAgICAgfSBlbHNlIG1vZCA9IG5ldyBCaWdJbnRlZ2VyKG1vZCwgbVNpZ24pO1xyXG4gICAgICAgIHJldHVybiBbcXVvdGllbnQsIG1vZF07XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGl2TW9kQW55KHRoaXMsIHYpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHF1b3RpZW50OiByZXN1bHRbMF0sXHJcbiAgICAgICAgICAgIHJlbWFpbmRlcjogcmVzdWx0WzFdXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmRpdm1vZCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kO1xyXG5cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBkaXZNb2RBbnkodGhpcywgdilbMF07XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5vdmVyID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgLyBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm92ZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm92ZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gZGl2TW9kQW55KHRoaXMsIHYpWzFdO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubW9kID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5yZW1haW5kZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgJSBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kID0gQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWUsXHJcbiAgICAgICAgICAgIHZhbHVlLCB4LCB5O1xyXG4gICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gSW50ZWdlclsxXTtcclxuICAgICAgICBpZiAoYSA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgaWYgKGEgPT09IDEpIHJldHVybiBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIGlmIChhID09PSAtMSkgcmV0dXJuIG4uaXNFdmVuKCkgPyBJbnRlZ2VyWzFdIDogSW50ZWdlclstMV07XHJcbiAgICAgICAgaWYgKG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuLmlzU21hbGwpIHRocm93IG5ldyBFcnJvcihcIlRoZSBleHBvbmVudCBcIiArIG4udG9TdHJpbmcoKSArIFwiIGlzIHRvbyBsYXJnZS5cIik7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQcmVjaXNlKHZhbHVlID0gTWF0aC5wb3coYSwgYikpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodHJ1bmNhdGUodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeCA9IHRoaXM7XHJcbiAgICAgICAgeSA9IEludGVnZXJbMV07XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKGIgJiAxID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgICAgICAgIC0tYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIGIgLz0gMjtcclxuICAgICAgICAgICAgeCA9IHguc3F1YXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucG93ID0gQmlnSW50ZWdlci5wcm90b3R5cGUucG93O1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZTtcclxuICAgICAgICB2YXIgXzAgPSBCaWdJbnQoMCksIF8xID0gQmlnSW50KDEpLCBfMiA9IEJpZ0ludCgyKTtcclxuICAgICAgICBpZiAoYiA9PT0gXzApIHJldHVybiBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIGlmIChhID09PSBfMCkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgaWYgKGEgPT09IF8xKSByZXR1cm4gSW50ZWdlclsxXTtcclxuICAgICAgICBpZiAoYSA9PT0gQmlnSW50KC0xKSkgcmV0dXJuIG4uaXNFdmVuKCkgPyBJbnRlZ2VyWzFdIDogSW50ZWdlclstMV07XHJcbiAgICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpKSByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludChfMCk7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzO1xyXG4gICAgICAgIHZhciB5ID0gSW50ZWdlclsxXTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoKGIgJiBfMSkgPT09IF8xKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgICAgICAgIC0tYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYiA9PT0gXzApIGJyZWFrO1xyXG4gICAgICAgICAgICBiIC89IF8yO1xyXG4gICAgICAgICAgICB4ID0geC5zcXVhcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gZnVuY3Rpb24gKGV4cCwgbW9kKSB7XHJcbiAgICAgICAgZXhwID0gcGFyc2VWYWx1ZShleHApO1xyXG4gICAgICAgIG1vZCA9IHBhcnNlVmFsdWUobW9kKTtcclxuICAgICAgICBpZiAobW9kLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdGFrZSBtb2RQb3cgd2l0aCBtb2R1bHVzIDBcIik7XHJcbiAgICAgICAgdmFyIHIgPSBJbnRlZ2VyWzFdLFxyXG4gICAgICAgICAgICBiYXNlID0gdGhpcy5tb2QobW9kKTtcclxuICAgICAgICBpZiAoZXhwLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBleHAgPSBleHAubXVsdGlwbHkoSW50ZWdlclstMV0pO1xyXG4gICAgICAgICAgICBiYXNlID0gYmFzZS5tb2RJbnYobW9kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGV4cC5pc1Bvc2l0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGJhc2UuaXNaZXJvKCkpIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgICAgICBpZiAoZXhwLmlzT2RkKCkpIHIgPSByLm11bHRpcGx5KGJhc2UpLm1vZChtb2QpO1xyXG4gICAgICAgICAgICBleHAgPSBleHAuZGl2aWRlKDIpO1xyXG4gICAgICAgICAgICBiYXNlID0gYmFzZS5zcXVhcmUoKS5tb2QobW9kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tb2RQb3cgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdztcclxuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlQWJzKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlQWJzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxyXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSByZXR1cm4gMTtcclxuICAgICAgICByZXR1cm4gY29tcGFyZUFicyhhLCBiKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IE1hdGguYWJzKHRoaXMudmFsdWUpLFxyXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGIgPSBNYXRoLmFicyhiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmNvbXBhcmVBYnMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZTtcclxuICAgICAgICB2YXIgYiA9IHBhcnNlVmFsdWUodikudmFsdWU7XHJcbiAgICAgICAgYSA9IGEgPj0gMCA/IGEgOiAtYTtcclxuICAgICAgICBiID0gYiA+PSAwID8gYiA6IC1iO1xyXG4gICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGFib3V0IGNvbXBhcmlzb24gd2l0aCBJbmZpbml0eTpcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGV0ZXJvbHNvbi9CaWdJbnRlZ2VyLmpzL2lzc3Vlcy82MVxyXG4gICAgICAgIGlmICh2ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxyXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG4uc2lnbiA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGFyZUFicyhhLCBiKSAqICh0aGlzLnNpZ24gPyAtMSA6IDEpO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYSA8IDAgIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhIDwgMCA/IDEgOiAtMTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh2ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZTtcclxuICAgICAgICB2YXIgYiA9IHBhcnNlVmFsdWUodikudmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XHJcbiAgICB9XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmNvbXBhcmVUbyA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5lcSA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZXF1YWxzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5lcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpICE9PSAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubmVxID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ub3RFcXVhbHMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm5lcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubmVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPiAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZ3QgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmdyZWF0ZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmd0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3NlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA8IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5sdCA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubGVzc2VyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sdCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyID0gQmlnSW50ZWdlci5wcm90b3R5cGUubHQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXI7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpID49IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5nZXEgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ2VxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPD0gMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmxlcSA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscztcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlWzBdICYgMSkgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgQmlnSW50KDEpKSA9PT0gQmlnSW50KDApO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZVswXSAmIDEpID09PSAxO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT09IDE7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiBCaWdJbnQoMSkpID09PSBCaWdJbnQoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuc2lnbjtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPiAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpZ247XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlIDwgMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmU7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy52YWx1ZSkgPT09IDE7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJzKCkudmFsdWUgPT09IEJpZ0ludCgxKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBCaWdJbnQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xyXG4gICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKG4uaXNVbml0KCkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChuLmNvbXBhcmVBYnMoMikgPT09IDApIHJldHVybiB0aGlzLmlzRXZlbigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZChuKS5pc1plcm8oKTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5O1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzQmFzaWNQcmltZSh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSB2LmFicygpO1xyXG4gICAgICAgIGlmIChuLmlzVW5pdCgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKG4uZXF1YWxzKDIpIHx8IG4uZXF1YWxzKDMpIHx8IG4uZXF1YWxzKDUpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAobi5pc0V2ZW4oKSB8fCBuLmlzRGl2aXNpYmxlQnkoMykgfHwgbi5pc0RpdmlzaWJsZUJ5KDUpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKG4ubGVzc2VyKDQ5KSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBpZiBpdCdzIHByaW1lOiBsZXQgdGhlIG90aGVyIGZ1bmN0aW9ucyBmaWd1cmUgaXQgb3V0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWlsbGVyUmFiaW5UZXN0KG4sIGEpIHtcclxuICAgICAgICB2YXIgblByZXYgPSBuLnByZXYoKSxcclxuICAgICAgICAgICAgYiA9IG5QcmV2LFxyXG4gICAgICAgICAgICByID0gMCxcclxuICAgICAgICAgICAgZCwgdCwgaSwgeDtcclxuICAgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkgYiA9IGIuZGl2aWRlKDIpLCByKys7XHJcbiAgICAgICAgbmV4dDogZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKG4ubGVzc2VyKGFbaV0pKSBjb250aW51ZTtcclxuICAgICAgICAgICAgeCA9IGJpZ0ludChhW2ldKS5tb2RQb3coYiwgbik7XHJcbiAgICAgICAgICAgIGlmICh4LmlzVW5pdCgpIHx8IHguZXF1YWxzKG5QcmV2KSkgY29udGludWU7XHJcbiAgICAgICAgICAgIGZvciAoZCA9IHIgLSAxOyBkICE9IDA7IGQtLSkge1xyXG4gICAgICAgICAgICAgICAgeCA9IHguc3F1YXJlKCkubW9kKG4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHguaXNVbml0KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICh4LmVxdWFscyhuUHJldikpIGNvbnRpbnVlIG5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgXCJzdHJpY3RcIiB0byB0cnVlIHRvIGZvcmNlIEdSSC1zdXBwb3J0ZWQgbG93ZXIgYm91bmQgb2YgMipsb2coTileMlxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZSA9IGZ1bmN0aW9uIChzdHJpY3QpIHtcclxuICAgICAgICB2YXIgaXNQcmltZSA9IGlzQmFzaWNQcmltZSh0aGlzKTtcclxuICAgICAgICBpZiAoaXNQcmltZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaXNQcmltZTtcclxuICAgICAgICB2YXIgbiA9IHRoaXMuYWJzKCk7XHJcbiAgICAgICAgdmFyIGJpdHMgPSBuLmJpdExlbmd0aCgpO1xyXG4gICAgICAgIGlmIChiaXRzIDw9IDY0KVxyXG4gICAgICAgICAgICByZXR1cm4gbWlsbGVyUmFiaW5UZXN0KG4sIFsyLCAzLCA1LCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5LCAzMSwgMzddKTtcclxuICAgICAgICB2YXIgbG9nTiA9IE1hdGgubG9nKDIpICogYml0cy50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgdmFyIHQgPSBNYXRoLmNlaWwoKHN0cmljdCA9PT0gdHJ1ZSkgPyAoMiAqIE1hdGgucG93KGxvZ04sIDIpKSA6IGxvZ04pO1xyXG4gICAgICAgIGZvciAodmFyIGEgPSBbXSwgaSA9IDA7IGkgPCB0OyBpKyspIHtcclxuICAgICAgICAgICAgYS5wdXNoKGJpZ0ludChpICsgMikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWlsbGVyUmFiaW5UZXN0KG4sIGEpO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNQcmltZSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJpbWU7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMsIHJuZykge1xyXG4gICAgICAgIHZhciBpc1ByaW1lID0gaXNCYXNpY1ByaW1lKHRoaXMpO1xyXG4gICAgICAgIGlmIChpc1ByaW1lICE9PSB1bmRlZmluZWQpIHJldHVybiBpc1ByaW1lO1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5hYnMoKTtcclxuICAgICAgICB2YXIgdCA9IGl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCA/IDUgOiBpdGVyYXRpb25zO1xyXG4gICAgICAgIGZvciAodmFyIGEgPSBbXSwgaSA9IDA7IGkgPCB0OyBpKyspIHtcclxuICAgICAgICAgICAgYS5wdXNoKGJpZ0ludC5yYW5kQmV0d2VlbigyLCBuLm1pbnVzKDIpLCBybmcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pbGxlclJhYmluVGVzdChuLCBhKTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludiA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdmFyIHQgPSBiaWdJbnQuemVybywgbmV3VCA9IGJpZ0ludC5vbmUsIHIgPSBwYXJzZVZhbHVlKG4pLCBuZXdSID0gdGhpcy5hYnMoKSwgcSwgbGFzdFQsIGxhc3RSO1xyXG4gICAgICAgIHdoaWxlICghbmV3Ui5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICBxID0gci5kaXZpZGUobmV3Uik7XHJcbiAgICAgICAgICAgIGxhc3RUID0gdDtcclxuICAgICAgICAgICAgbGFzdFIgPSByO1xyXG4gICAgICAgICAgICB0ID0gbmV3VDtcclxuICAgICAgICAgICAgciA9IG5ld1I7XHJcbiAgICAgICAgICAgIG5ld1QgPSBsYXN0VC5zdWJ0cmFjdChxLm11bHRpcGx5KG5ld1QpKTtcclxuICAgICAgICAgICAgbmV3UiA9IGxhc3RSLnN1YnRyYWN0KHEubXVsdGlwbHkobmV3UikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXIuaXNVbml0KCkpIHRocm93IG5ldyBFcnJvcih0aGlzLnRvU3RyaW5nKCkgKyBcIiBhbmQgXCIgKyBuLnRvU3RyaW5nKCkgKyBcIiBhcmUgbm90IGNvLXByaW1lXCIpO1xyXG4gICAgICAgIGlmICh0LmNvbXBhcmUoMCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHQgPSB0LmFkZChuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0Lm5lZ2F0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tb2RJbnYgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm1vZEludiA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwgMSwgdGhpcy5zaWduKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKHZhbHVlLCAxKSwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUgKyAxIDwgTUFYX0lOVCkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUgKyAxKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoTUFYX0lOVF9BUlIsIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSArIEJpZ0ludCgxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKHZhbHVlLCAxKSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKHZhbHVlLCAxLCB0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSAtIDEgPiAtTUFYX0lOVCkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUgLSAxKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoTUFYX0lOVF9BUlIsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlIC0gQmlnSW50KDEpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcG93ZXJzT2ZUd28gPSBbMV07XHJcbiAgICB3aGlsZSAoMiAqIHBvd2Vyc09mVHdvW3Bvd2Vyc09mVHdvLmxlbmd0aCAtIDFdIDw9IEJBU0UpIHBvd2Vyc09mVHdvLnB1c2goMiAqIHBvd2Vyc09mVHdvW3Bvd2Vyc09mVHdvLmxlbmd0aCAtIDFdKTtcclxuICAgIHZhciBwb3dlcnMyTGVuZ3RoID0gcG93ZXJzT2ZUd28ubGVuZ3RoLCBoaWdoZXN0UG93ZXIyID0gcG93ZXJzT2ZUd29bcG93ZXJzMkxlbmd0aCAtIDFdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNoaWZ0X2lzU21hbGwobikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyhuKSA8PSBCQVNFO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLnRvSlNOdW1iZXIoKTtcclxuICAgICAgICBpZiAoIXNoaWZ0X2lzU21hbGwobikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFN0cmluZyhuKSArIFwiIGlzIHRvbyBsYXJnZSBmb3Igc2hpZnRpbmcuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobiA8IDApIHJldHVybiB0aGlzLnNoaWZ0UmlnaHQoLW4pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xyXG4gICAgICAgIGlmIChyZXN1bHQuaXNaZXJvKCkpIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgd2hpbGUgKG4gPj0gcG93ZXJzMkxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsdGlwbHkoaGlnaGVzdFBvd2VyMik7XHJcbiAgICAgICAgICAgIG4gLT0gcG93ZXJzMkxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQubXVsdGlwbHkocG93ZXJzT2ZUd29bbl0pO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIHJlbVF1bztcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodikudG9KU051bWJlcigpO1xyXG4gICAgICAgIGlmICghc2hpZnRfaXNTbWFsbChuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pICsgXCIgaXMgdG9vIGxhcmdlIGZvciBzaGlmdGluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuIDwgMCkgcmV0dXJuIHRoaXMuc2hpZnRMZWZ0KC1uKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcztcclxuICAgICAgICB3aGlsZSAobiA+PSBwb3dlcnMyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaXNaZXJvKCkgfHwgKHJlc3VsdC5pc05lZ2F0aXZlKCkgJiYgcmVzdWx0LmlzVW5pdCgpKSkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgcmVtUXVvID0gZGl2TW9kQW55KHJlc3VsdCwgaGlnaGVzdFBvd2VyMik7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlbVF1b1sxXS5pc05lZ2F0aXZlKCkgPyByZW1RdW9bMF0ucHJldigpIDogcmVtUXVvWzBdO1xyXG4gICAgICAgICAgICBuIC09IHBvd2VyczJMZW5ndGggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1RdW8gPSBkaXZNb2RBbnkocmVzdWx0LCBwb3dlcnNPZlR3b1tuXSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbVF1b1sxXS5pc05lZ2F0aXZlKCkgPyByZW1RdW9bMF0ucHJldigpIDogcmVtUXVvWzBdO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc2hpZnRSaWdodCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4gICAgZnVuY3Rpb24gYml0d2lzZSh4LCB5LCBmbikge1xyXG4gICAgICAgIHkgPSBwYXJzZVZhbHVlKHkpO1xyXG4gICAgICAgIHZhciB4U2lnbiA9IHguaXNOZWdhdGl2ZSgpLCB5U2lnbiA9IHkuaXNOZWdhdGl2ZSgpO1xyXG4gICAgICAgIHZhciB4UmVtID0geFNpZ24gPyB4Lm5vdCgpIDogeCxcclxuICAgICAgICAgICAgeVJlbSA9IHlTaWduID8geS5ub3QoKSA6IHk7XHJcbiAgICAgICAgdmFyIHhEaWdpdCA9IDAsIHlEaWdpdCA9IDA7XHJcbiAgICAgICAgdmFyIHhEaXZNb2QgPSBudWxsLCB5RGl2TW9kID0gbnVsbDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgd2hpbGUgKCF4UmVtLmlzWmVybygpIHx8ICF5UmVtLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIHhEaXZNb2QgPSBkaXZNb2RBbnkoeFJlbSwgaGlnaGVzdFBvd2VyMik7XHJcbiAgICAgICAgICAgIHhEaWdpdCA9IHhEaXZNb2RbMV0udG9KU051bWJlcigpO1xyXG4gICAgICAgICAgICBpZiAoeFNpZ24pIHtcclxuICAgICAgICAgICAgICAgIHhEaWdpdCA9IGhpZ2hlc3RQb3dlcjIgLSAxIC0geERpZ2l0OyAvLyB0d28ncyBjb21wbGVtZW50IGZvciBuZWdhdGl2ZSBudW1iZXJzXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHlEaXZNb2QgPSBkaXZNb2RBbnkoeVJlbSwgaGlnaGVzdFBvd2VyMik7XHJcbiAgICAgICAgICAgIHlEaWdpdCA9IHlEaXZNb2RbMV0udG9KU051bWJlcigpO1xyXG4gICAgICAgICAgICBpZiAoeVNpZ24pIHtcclxuICAgICAgICAgICAgICAgIHlEaWdpdCA9IGhpZ2hlc3RQb3dlcjIgLSAxIC0geURpZ2l0OyAvLyB0d28ncyBjb21wbGVtZW50IGZvciBuZWdhdGl2ZSBudW1iZXJzXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHhSZW0gPSB4RGl2TW9kWzBdO1xyXG4gICAgICAgICAgICB5UmVtID0geURpdk1vZFswXTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZm4oeERpZ2l0LCB5RGlnaXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN1bSA9IGZuKHhTaWduID8gMSA6IDAsIHlTaWduID8gMSA6IDApICE9PSAwID8gYmlnSW50KC0xKSA6IGJpZ0ludCgwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IHN1bS5tdWx0aXBseShoaWdoZXN0UG93ZXIyKS5hZGQoYmlnSW50KHJlc3VsdFtpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5wcmV2KCk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ub3QgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm5vdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYgYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5hbmQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmFuZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgcmV0dXJuIGJpdHdpc2UodGhpcywgbiwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgfCBiOyB9KTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm9yID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm9yO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgcmV0dXJuIGJpdHdpc2UodGhpcywgbiwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgXiBiOyB9KTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnhvciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUueG9yID0gQmlnSW50ZWdlci5wcm90b3R5cGUueG9yO1xyXG5cclxuICAgIHZhciBMT0JNQVNLX0kgPSAxIDw8IDMwLCBMT0JNQVNLX0JJID0gKEJBU0UgJiAtQkFTRSkgKiAoQkFTRSAmIC1CQVNFKSB8IExPQk1BU0tfSTtcclxuICAgIGZ1bmN0aW9uIHJvdWdoTE9CKG4pIHsgLy8gZ2V0IGxvd2VzdE9uZUJpdCAocm91Z2gpXHJcbiAgICAgICAgLy8gU21hbGxJbnRlZ2VyOiByZXR1cm4gTWluKGxvd2VzdE9uZUJpdChuKSwgMSA8PCAzMClcclxuICAgICAgICAvLyBCaWdJbnRlZ2VyOiByZXR1cm4gTWluKGxvd2VzdE9uZUJpdChuKSwgMSA8PCAxNCkgW0JBU0U9MWU3XVxyXG4gICAgICAgIHZhciB2ID0gbi52YWx1ZSxcclxuICAgICAgICAgICAgeCA9IHR5cGVvZiB2ID09PSBcIm51bWJlclwiID8gdiB8IExPQk1BU0tfSSA6XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdiA9PT0gXCJiaWdpbnRcIiA/IHYgfCBCaWdJbnQoTE9CTUFTS19JKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdlswXSArIHZbMV0gKiBCQVNFIHwgTE9CTUFTS19CSTtcclxuICAgICAgICByZXR1cm4geCAmIC14O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGludGVnZXJMb2dhcml0aG0odmFsdWUsIGJhc2UpIHtcclxuICAgICAgICBpZiAoYmFzZS5jb21wYXJlVG8odmFsdWUpIDw9IDApIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IGludGVnZXJMb2dhcml0aG0odmFsdWUsIGJhc2Uuc3F1YXJlKGJhc2UpKTtcclxuICAgICAgICAgICAgdmFyIHAgPSB0bXAucDtcclxuICAgICAgICAgICAgdmFyIGUgPSB0bXAuZTtcclxuICAgICAgICAgICAgdmFyIHQgPSBwLm11bHRpcGx5KGJhc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gdC5jb21wYXJlVG8odmFsdWUpIDw9IDAgPyB7IHA6IHQsIGU6IGUgKiAyICsgMSB9IDogeyBwOiBwLCBlOiBlICogMiB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBwOiBiaWdJbnQoMSksIGU6IDAgfTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzO1xyXG4gICAgICAgIGlmIChuLmNvbXBhcmVUbyhiaWdJbnQoMCkpIDwgMCkge1xyXG4gICAgICAgICAgICBuID0gbi5uZWdhdGUoKS5zdWJ0cmFjdChiaWdJbnQoMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobi5jb21wYXJlVG8oYmlnSW50KDApKSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmlnSW50KDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmlnSW50KGludGVnZXJMb2dhcml0aG0obiwgYmlnSW50KDIpKS5lKS5hZGQoYmlnSW50KDEpKTtcclxuICAgIH1cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYml0TGVuZ3RoID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGg7XHJcblxyXG4gICAgZnVuY3Rpb24gbWF4KGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICByZXR1cm4gYS5ncmVhdGVyKGIpID8gYSA6IGI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtaW4oYSwgYikge1xyXG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpO1xyXG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpO1xyXG4gICAgICAgIHJldHVybiBhLmxlc3NlcihiKSA/IGEgOiBiO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2NkKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcclxuICAgICAgICBpZiAoYS5lcXVhbHMoYikpIHJldHVybiBhO1xyXG4gICAgICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYjtcclxuICAgICAgICBpZiAoYi5pc1plcm8oKSkgcmV0dXJuIGE7XHJcbiAgICAgICAgdmFyIGMgPSBJbnRlZ2VyWzFdLCBkLCB0O1xyXG4gICAgICAgIHdoaWxlIChhLmlzRXZlbigpICYmIGIuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgZCA9IG1pbihyb3VnaExPQihhKSwgcm91Z2hMT0IoYikpO1xyXG4gICAgICAgICAgICBhID0gYS5kaXZpZGUoZCk7XHJcbiAgICAgICAgICAgIGIgPSBiLmRpdmlkZShkKTtcclxuICAgICAgICAgICAgYyA9IGMubXVsdGlwbHkoZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XHJcbiAgICAgICAgICAgIGEgPSBhLmRpdmlkZShyb3VnaExPQihhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBiLmRpdmlkZShyb3VnaExPQihiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGEuZ3JlYXRlcihiKSkge1xyXG4gICAgICAgICAgICAgICAgdCA9IGI7IGIgPSBhOyBhID0gdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gYi5zdWJ0cmFjdChhKTtcclxuICAgICAgICB9IHdoaWxlICghYi5pc1plcm8oKSk7XHJcbiAgICAgICAgcmV0dXJuIGMuaXNVbml0KCkgPyBhIDogYS5tdWx0aXBseShjKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGxjbShhLCBiKSB7XHJcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSkuYWJzKCk7XHJcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYikuYWJzKCk7XHJcbiAgICAgICAgcmV0dXJuIGEuZGl2aWRlKGdjZChhLCBiKSkubXVsdGlwbHkoYik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByYW5kQmV0d2VlbihhLCBiLCBybmcpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICB2YXIgdXNlZFJORyA9IHJuZyB8fCBNYXRoLnJhbmRvbTtcclxuICAgICAgICB2YXIgbG93ID0gbWluKGEsIGIpLCBoaWdoID0gbWF4KGEsIGIpO1xyXG4gICAgICAgIHZhciByYW5nZSA9IGhpZ2guc3VidHJhY3QobG93KS5hZGQoMSk7XHJcbiAgICAgICAgaWYgKHJhbmdlLmlzU21hbGwpIHJldHVybiBsb3cuYWRkKE1hdGguZmxvb3IodXNlZFJORygpICogcmFuZ2UpKTtcclxuICAgICAgICB2YXIgZGlnaXRzID0gdG9CYXNlKHJhbmdlLCBCQVNFKS52YWx1ZTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIHJlc3RyaWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0b3AgPSByZXN0cmljdGVkID8gZGlnaXRzW2ldICsgKGkgKyAxIDwgZGlnaXRzLmxlbmd0aCA/IGRpZ2l0c1tpICsgMV0gLyBCQVNFIDogMCkgOiBCQVNFO1xyXG4gICAgICAgICAgICB2YXIgZGlnaXQgPSB0cnVuY2F0ZSh1c2VkUk5HKCkgKiB0b3ApO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChkaWdpdCk7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdCA8IGRpZ2l0c1tpXSkgcmVzdHJpY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG93LmFkZChJbnRlZ2VyLmZyb21BcnJheShyZXN1bHQsIEJBU0UsIGZhbHNlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhcnNlQmFzZSA9IGZ1bmN0aW9uICh0ZXh0LCBiYXNlLCBhbHBoYWJldCwgY2FzZVNlbnNpdGl2ZSkge1xyXG4gICAgICAgIGFscGhhYmV0ID0gYWxwaGFiZXQgfHwgREVGQVVMVF9BTFBIQUJFVDtcclxuICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xyXG4gICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xyXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBhbHBoYWJldCA9IGFscGhhYmV0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgYWJzQmFzZSA9IE1hdGguYWJzKGJhc2UpO1xyXG4gICAgICAgIHZhciBhbHBoYWJldFZhbHVlcyA9IHt9O1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhbHBoYWJldFZhbHVlc1thbHBoYWJldFtpXV0gPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0W2ldO1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gXCItXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoYyBpbiBhbHBoYWJldFZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFscGhhYmV0VmFsdWVzW2NdID49IGFic0Jhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCIxXCIgJiYgYWJzQmFzZSA9PT0gMSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiICsgYmFzZSArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBiYXNlID0gcGFyc2VWYWx1ZShiYXNlKTtcclxuICAgICAgICB2YXIgZGlnaXRzID0gW107XHJcbiAgICAgICAgdmFyIGlzTmVnYXRpdmUgPSB0ZXh0WzBdID09PSBcIi1cIjtcclxuICAgICAgICBmb3IgKGkgPSBpc05lZ2F0aXZlID8gMSA6IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGV4dFtpXTtcclxuICAgICAgICAgICAgaWYgKGMgaW4gYWxwaGFiZXRWYWx1ZXMpIGRpZ2l0cy5wdXNoKHBhcnNlVmFsdWUoYWxwaGFiZXRWYWx1ZXNbY10pKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI8XCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGk7XHJcbiAgICAgICAgICAgICAgICBkbyB7IGkrKzsgfSB3aGlsZSAodGV4dFtpXSAhPT0gXCI+XCIgJiYgaSA8IHRleHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKHBhcnNlVmFsdWUodGV4dC5zbGljZShzdGFydCArIDEsIGkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYyArIFwiIGlzIG5vdCBhIHZhbGlkIGNoYXJhY3RlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMsIGJhc2UsIGlzTmVnYXRpdmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IEludGVnZXJbMF0sIHBvdyA9IEludGVnZXJbMV0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hZGQoZGlnaXRzW2ldLnRpbWVzKHBvdykpO1xyXG4gICAgICAgICAgICBwb3cgPSBwb3cudGltZXMoYmFzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc05lZ2F0aXZlID8gdmFsLm5lZ2F0ZSgpIDogdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShkaWdpdCwgYWxwaGFiZXQpIHtcclxuICAgICAgICBhbHBoYWJldCA9IGFscGhhYmV0IHx8IERFRkFVTFRfQUxQSEFCRVQ7XHJcbiAgICAgICAgaWYgKGRpZ2l0IDwgYWxwaGFiZXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtkaWdpdF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIjxcIiArIGRpZ2l0ICsgXCI+XCI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9CYXNlKG4sIGJhc2UpIHtcclxuICAgICAgICBiYXNlID0gYmlnSW50KGJhc2UpO1xyXG4gICAgICAgIGlmIChiYXNlLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4geyB2YWx1ZTogWzBdLCBpc05lZ2F0aXZlOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBub256ZXJvIG51bWJlcnMgdG8gYmFzZSAwLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJhc2UuZXF1YWxzKC0xKSkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIHsgdmFsdWU6IFswXSwgaXNOZWdhdGl2ZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW10uY29uY2F0LmFwcGx5KFtdLCBBcnJheS5hcHBseShudWxsLCBBcnJheSgtbi50b0pTTnVtYmVyKCkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLCBbMSwgMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBBcnJheS5hcHBseShudWxsLCBBcnJheShuLnRvSlNOdW1iZXIoKSAtIDEpKVxyXG4gICAgICAgICAgICAgICAgLm1hcChBcnJheS5wcm90b3R5cGUudmFsdWVPZiwgWzAsIDFdKTtcclxuICAgICAgICAgICAgYXJyLnVuc2hpZnQoWzFdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBbXS5jb25jYXQuYXBwbHkoW10sIGFyciksXHJcbiAgICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5lZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSAmJiBiYXNlLmlzUG9zaXRpdmUoKSkge1xyXG4gICAgICAgICAgICBuZWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBuID0gbi5hYnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJhc2UuaXNVbml0KCkpIHtcclxuICAgICAgICAgICAgaWYgKG4uaXNaZXJvKCkpIHJldHVybiB7IHZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KG4udG9KU051bWJlcigpKSlcclxuICAgICAgICAgICAgICAgICAgICAubWFwKE51bWJlci5wcm90b3R5cGUudmFsdWVPZiwgMSksXHJcbiAgICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBuZWdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG91dCA9IFtdO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gbiwgZGl2bW9kO1xyXG4gICAgICAgIHdoaWxlIChsZWZ0LmlzTmVnYXRpdmUoKSB8fCBsZWZ0LmNvbXBhcmVBYnMoYmFzZSkgPj0gMCkge1xyXG4gICAgICAgICAgICBkaXZtb2QgPSBsZWZ0LmRpdm1vZChiYXNlKTtcclxuICAgICAgICAgICAgbGVmdCA9IGRpdm1vZC5xdW90aWVudDtcclxuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gZGl2bW9kLnJlbWFpbmRlcjtcclxuICAgICAgICAgICAgaWYgKGRpZ2l0LmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgZGlnaXQgPSBiYXNlLm1pbnVzKGRpZ2l0KS5hYnMoKTtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0Lm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXQucHVzaChkaWdpdC50b0pTTnVtYmVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdXQucHVzaChsZWZ0LnRvSlNOdW1iZXIoKSk7XHJcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG91dC5yZXZlcnNlKCksIGlzTmVnYXRpdmU6IG5lZyB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvQmFzZVN0cmluZyhuLCBiYXNlLCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBhcnIgPSB0b0Jhc2UobiwgYmFzZSk7XHJcbiAgICAgICAgcmV0dXJuIChhcnIuaXNOZWdhdGl2ZSA/IFwiLVwiIDogXCJcIikgKyBhcnIudmFsdWUubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoeCwgYWxwaGFiZXQpO1xyXG4gICAgICAgIH0pLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcclxuICAgIH07XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKHJhZGl4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvQmFzZSh0aGlzLCByYWRpeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChyYWRpeCkge1xyXG4gICAgICAgIHJldHVybiB0b0Jhc2UodGhpcywgcmFkaXgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCwgYWxwaGFiZXQpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcclxuICAgICAgICBpZiAocmFkaXggIT09IDEwIHx8IGFscGhhYmV0KSByZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMsIHJhZGl4LCBhbHBoYWJldCk7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZhbHVlLCBsID0gdi5sZW5ndGgsIHN0ciA9IFN0cmluZyh2Wy0tbF0pLCB6ZXJvcyA9IFwiMDAwMDAwMFwiLCBkaWdpdDtcclxuICAgICAgICB3aGlsZSAoLS1sID49IDApIHtcclxuICAgICAgICAgICAgZGlnaXQgPSBTdHJpbmcodltsXSk7XHJcbiAgICAgICAgICAgIHN0ciArPSB6ZXJvcy5zbGljZShkaWdpdC5sZW5ndGgpICsgZGlnaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaWduID0gdGhpcy5zaWduID8gXCItXCIgOiBcIlwiO1xyXG4gICAgICAgIHJldHVybiBzaWduICsgc3RyO1xyXG4gICAgfTtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHJhZGl4LCBhbHBoYWJldCkge1xyXG4gICAgICAgIGlmIChyYWRpeCA9PT0gdW5kZWZpbmVkKSByYWRpeCA9IDEwO1xyXG4gICAgICAgIGlmIChyYWRpeCAhPSAxMCB8fCBhbHBoYWJldCkgcmV0dXJuIHRvQmFzZVN0cmluZyh0aGlzLCByYWRpeCwgYWxwaGFiZXQpO1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9KU09OID0gQmlnSW50ZWdlci5wcm90b3R5cGUudG9KU09OID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nKCk7IH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLnRvU3RyaW5nKCksIDEwKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0pTTnVtYmVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZjtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTTnVtYmVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS50b0pTTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLnRvU3RyaW5nKCksIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZ1ZhbHVlKHYpIHtcclxuICAgICAgICBpZiAoaXNQcmVjaXNlKCt2KSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9ICt2O1xyXG4gICAgICAgICAgICBpZiAoeCA9PT0gdHJ1bmNhdGUoeCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydHNOYXRpdmVCaWdJbnQgPyBuZXcgTmF0aXZlQmlnSW50KEJpZ0ludCh4KSkgOiBuZXcgU21hbGxJbnRlZ2VyKHgpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgdik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaWduID0gdlswXSA9PT0gXCItXCI7XHJcbiAgICAgICAgaWYgKHNpZ24pIHYgPSB2LnNsaWNlKDEpO1xyXG4gICAgICAgIHZhciBzcGxpdCA9IHYuc3BsaXQoL2UvaSk7XHJcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIgKyBzcGxpdC5qb2luKFwiZVwiKSk7XHJcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICB2YXIgZXhwID0gc3BsaXRbMV07XHJcbiAgICAgICAgICAgIGlmIChleHBbMF0gPT09IFwiK1wiKSBleHAgPSBleHAuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIGV4cCA9ICtleHA7XHJcbiAgICAgICAgICAgIGlmIChleHAgIT09IHRydW5jYXRlKGV4cCkgfHwgIWlzUHJlY2lzZShleHApKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgZXhwICsgXCIgaXMgbm90IGEgdmFsaWQgZXhwb25lbnQuXCIpO1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHNwbGl0WzBdO1xyXG4gICAgICAgICAgICB2YXIgZGVjaW1hbFBsYWNlID0gdGV4dC5pbmRleE9mKFwiLlwiKTtcclxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQbGFjZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBleHAgLT0gdGV4dC5sZW5ndGggLSBkZWNpbWFsUGxhY2UgLSAxO1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgZGVjaW1hbFBsYWNlKSArIHRleHQuc2xpY2UoZGVjaW1hbFBsYWNlICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV4cCA8IDApIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbmNsdWRlIG5lZ2F0aXZlIGV4cG9uZW50IHBhcnQgZm9yIGludGVnZXJzXCIpO1xyXG4gICAgICAgICAgICB0ZXh0ICs9IChuZXcgQXJyYXkoZXhwICsgMSkpLmpvaW4oXCIwXCIpO1xyXG4gICAgICAgICAgICB2ID0gdGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzVmFsaWQgPSAvXihbMC05XVswLTldKikkLy50ZXN0KHYpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHYpO1xyXG4gICAgICAgIGlmIChzdXBwb3J0c05hdGl2ZUJpZ0ludCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludChCaWdJbnQoc2lnbiA/IFwiLVwiICsgdiA6IHYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHIgPSBbXSwgbWF4ID0gdi5sZW5ndGgsIGwgPSBMT0dfQkFTRSwgbWluID0gbWF4IC0gbDtcclxuICAgICAgICB3aGlsZSAobWF4ID4gMCkge1xyXG4gICAgICAgICAgICByLnB1c2goK3Yuc2xpY2UobWluLCBtYXgpKTtcclxuICAgICAgICAgICAgbWluIC09IGw7XHJcbiAgICAgICAgICAgIGlmIChtaW4gPCAwKSBtaW4gPSAwO1xyXG4gICAgICAgICAgICBtYXggLT0gbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpbShyKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIociwgc2lnbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VOdW1iZXJWYWx1ZSh2KSB7XHJcbiAgICAgICAgaWYgKHN1cHBvcnRzTmF0aXZlQmlnSW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KEJpZ0ludCh2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1ByZWNpc2UodikpIHtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHRydW5jYXRlKHYpKSB0aHJvdyBuZXcgRXJyb3IodiArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlclZhbHVlKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJiaWdpbnRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9XHJcbiAgICAvLyBQcmUtZGVmaW5lIG51bWJlcnMgaW4gcmFuZ2UgWy05OTksOTk5XVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcclxuICAgICAgICBJbnRlZ2VyW2ldID0gcGFyc2VWYWx1ZShpKTtcclxuICAgICAgICBpZiAoaSA+IDApIEludGVnZXJbLWldID0gcGFyc2VWYWx1ZSgtaSk7XHJcbiAgICB9XHJcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG4gICAgSW50ZWdlci5vbmUgPSBJbnRlZ2VyWzFdO1xyXG4gICAgSW50ZWdlci56ZXJvID0gSW50ZWdlclswXTtcclxuICAgIEludGVnZXIubWludXNPbmUgPSBJbnRlZ2VyWy0xXTtcclxuICAgIEludGVnZXIubWF4ID0gbWF4O1xyXG4gICAgSW50ZWdlci5taW4gPSBtaW47XHJcbiAgICBJbnRlZ2VyLmdjZCA9IGdjZDtcclxuICAgIEludGVnZXIubGNtID0gbGNtO1xyXG4gICAgSW50ZWdlci5pc0luc3RhbmNlID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBCaWdJbnRlZ2VyIHx8IHggaW5zdGFuY2VvZiBTbWFsbEludGVnZXIgfHwgeCBpbnN0YW5jZW9mIE5hdGl2ZUJpZ0ludDsgfTtcclxuICAgIEludGVnZXIucmFuZEJldHdlZW4gPSByYW5kQmV0d2VlbjtcclxuXHJcbiAgICBJbnRlZ2VyLmZyb21BcnJheSA9IGZ1bmN0aW9uIChkaWdpdHMsIGJhc2UsIGlzTmVnYXRpdmUpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cy5tYXAocGFyc2VWYWx1ZSksIHBhcnNlVmFsdWUoYmFzZSB8fCAxMCksIGlzTmVnYXRpdmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gSW50ZWdlcjtcclxufSkoKTtcclxuXHJcbi8vIE5vZGUuanMgY2hlY2tcclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KFwiZXhwb3J0c1wiKSkge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiaWdJbnQ7XHJcbn1cclxuXHJcbi8vYW1kIGNoZWNrXHJcbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGJpZ0ludDtcclxuICAgIH0pO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-binary-codec/node_modules/big-integer/BigInteger.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-binary-codec/dist/enums/definitions.json":
/*!**********************************************************************!*\
  !*** ./node_modules/ripple-binary-codec/dist/enums/definitions.json ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"TYPES":{"Done":-1,"Unknown":-2,"NotPresent":0,"UInt16":1,"UInt32":2,"UInt64":3,"Hash128":4,"Hash256":5,"Amount":6,"Blob":7,"AccountID":8,"STObject":14,"STArray":15,"UInt8":16,"Hash160":17,"PathSet":18,"Vector256":19,"UInt96":20,"UInt192":21,"UInt384":22,"UInt512":23,"Issue":24,"XChainBridge":25,"Transaction":10001,"LedgerEntry":10002,"Validation":10003,"Metadata":10004},"LEDGER_ENTRY_TYPES":{"Invalid":-1,"AccountRoot":97,"DirectoryNode":100,"RippleState":114,"Ticket":84,"SignerList":83,"Offer":111,"Bridge":105,"LedgerHashes":104,"Amendments":102,"XChainOwnedClaimID":113,"XChainOwnedCreateAccountClaimID":116,"FeeSettings":115,"Escrow":117,"PayChannel":120,"Check":67,"DepositPreauth":112,"NegativeUNL":78,"NFTokenPage":80,"NFTokenOffer":55,"AMM":121,"DID":73,"Any":-3,"Child":-2,"Nickname":110,"Contract":99,"GeneratorMap":103},"FIELDS":[["Generic",{"nth":0,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Unknown"}],["Invalid",{"nth":-1,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Unknown"}],["ObjectEndMarker",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["ArrayEndMarker",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["hash",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Hash256"}],["index",{"nth":258,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Hash256"}],["taker_gets_funded",{"nth":258,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Amount"}],["taker_pays_funded",{"nth":259,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Amount"}],["LedgerEntry",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"LedgerEntry"}],["Transaction",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Transaction"}],["Validation",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Validation"}],["Metadata",{"nth":257,"isVLEncoded":false,"isSerialized":false,"isSigningField":false,"type":"Metadata"}],["CloseResolution",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["Method",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["TransactionResult",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["TickSize",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["UNLModifyDisabling",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["HookResult",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["WasLockingChainSend",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt8"}],["LedgerEntryType",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["TransactionType",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["SignerWeight",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["TransferFee",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["TradingFee",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["DiscountedFee",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["Version",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookStateChangeCount",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookEmitCount",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookExecutionIndex",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["HookApiVersion",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt16"}],["NetworkID",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["Flags",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SourceTag",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["Sequence",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["PreviousTxnLgrSeq",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LedgerSequence",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["CloseTime",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ParentCloseTime",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SigningTime",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["Expiration",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TransferRate",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["WalletSize",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["OwnerCount",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["DestinationTag",{"nth":14,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["HighQualityIn",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["HighQualityOut",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LowQualityIn",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LowQualityOut",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["QualityIn",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["QualityOut",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["StampEscrow",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["BondAmount",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LoadFee",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["OfferSequence",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["FirstLedgerSequence",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["LastLedgerSequence",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TransactionIndex",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["OperationLimit",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ReferenceFeeUnits",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ReserveBase",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ReserveIncrement",{"nth":32,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SetFlag",{"nth":33,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["ClearFlag",{"nth":34,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SignerQuorum",{"nth":35,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["CancelAfter",{"nth":36,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["FinishAfter",{"nth":37,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SignerListID",{"nth":38,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["SettleDelay",{"nth":39,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TicketCount",{"nth":40,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["TicketSequence",{"nth":41,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["NFTokenTaxon",{"nth":42,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["MintedNFTokens",{"nth":43,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["BurnedNFTokens",{"nth":44,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["HookStateCount",{"nth":45,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["EmitGeneration",{"nth":46,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["VoteWeight",{"nth":48,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["FirstNFTokenSequence",{"nth":50,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt32"}],["IndexNext",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["IndexPrevious",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["BookNode",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["OwnerNode",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["BaseFee",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["ExchangeRate",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["LowNode",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HighNode",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["DestinationNode",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["Cookie",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["ServerVersion",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["NFTokenOfferNode",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["EmitBurden",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HookOn",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HookInstructionCount",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["HookReturnCode",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["ReferenceCount",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["XChainClaimID",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["XChainAccountCreateCount",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["XChainAccountClaimCount",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"UInt64"}],["EmailHash",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash128"}],["TakerPaysCurrency",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["TakerPaysIssuer",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["TakerGetsCurrency",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["TakerGetsIssuer",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash160"}],["LedgerHash",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ParentHash",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["TransactionHash",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["AccountHash",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["PreviousTxnID",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["LedgerIndex",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["WalletLocator",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["RootIndex",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["AccountTxnID",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NFTokenID",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmitParentTxnID",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmitNonce",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["EmitHookHash",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["AMMID",{"nth":14,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["BookDirectory",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["InvoiceID",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Nickname",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Amendment",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Digest",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Channel",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ConsensusHash",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["CheckID",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["ValidatedHash",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["PreviousPageMin",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NextPageMin",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NFTokenBuyOffer",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["NFTokenSellOffer",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookStateKey",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookHash",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookNamespace",{"nth":32,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["HookSetTxnID",{"nth":33,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Hash256"}],["Amount",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Balance",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LimitAmount",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["TakerPays",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["TakerGets",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LowLimit",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["HighLimit",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Fee",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["SendMax",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["DeliverMin",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Amount2",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["BidMin",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["BidMax",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["MinimumOffer",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["RippleEscrow",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["DeliveredAmount",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["NFTokenBrokerFee",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["BaseFeeDrops",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["ReserveBaseDrops",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["ReserveIncrementDrops",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LPTokenOut",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LPTokenIn",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["EPrice",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["Price",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["SignatureReward",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["MinAccountCreateAmount",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["LPTokenBalance",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Amount"}],["PublicKey",{"nth":1,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MessageKey",{"nth":2,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["SigningPubKey",{"nth":3,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["TxnSignature",{"nth":4,"isVLEncoded":true,"isSerialized":true,"isSigningField":false,"type":"Blob"}],["URI",{"nth":5,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Signature",{"nth":6,"isVLEncoded":true,"isSerialized":true,"isSigningField":false,"type":"Blob"}],["Domain",{"nth":7,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["FundCode",{"nth":8,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["RemoveCode",{"nth":9,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["ExpireCode",{"nth":10,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["CreateCode",{"nth":11,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MemoType",{"nth":12,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MemoData",{"nth":13,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MemoFormat",{"nth":14,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Fulfillment",{"nth":16,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Condition",{"nth":17,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["MasterSignature",{"nth":18,"isVLEncoded":true,"isSerialized":true,"isSigningField":false,"type":"Blob"}],["UNLModifyValidator",{"nth":19,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["ValidatorToDisable",{"nth":20,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["ValidatorToReEnable",{"nth":21,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookStateData",{"nth":22,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookReturnString",{"nth":23,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookParameterName",{"nth":24,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["HookParameterValue",{"nth":25,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["DIDDocument",{"nth":26,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Data",{"nth":27,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Blob"}],["Account",{"nth":1,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Owner",{"nth":2,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Destination",{"nth":3,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Issuer",{"nth":4,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Authorize",{"nth":5,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Unauthorize",{"nth":6,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["RegularKey",{"nth":8,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["NFTokenMinter",{"nth":9,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["EmitCallback",{"nth":10,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["HookAccount",{"nth":16,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["OtherChainSource",{"nth":18,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["OtherChainDestination",{"nth":19,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["AttestationSignerAccount",{"nth":20,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["AttestationRewardAccount",{"nth":21,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["LockingChainDoor",{"nth":22,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["IssuingChainDoor",{"nth":23,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"AccountID"}],["Indexes",{"nth":1,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["Hashes",{"nth":2,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["Amendments",{"nth":3,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["NFTokenOffers",{"nth":4,"isVLEncoded":true,"isSerialized":true,"isSigningField":true,"type":"Vector256"}],["Paths",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"PathSet"}],["LockingChainIssue",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Issue"}],["IssuingChainIssue",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Issue"}],["Asset",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Issue"}],["Asset2",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"Issue"}],["XChainBridge",{"nth":1,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"XChainBridge"}],["TransactionMetaData",{"nth":2,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["CreatedNode",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["DeletedNode",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["ModifiedNode",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["PreviousFields",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["FinalFields",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["NewFields",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["TemplateEntry",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Memo",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["SignerEntry",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["NFToken",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["EmitDetails",{"nth":13,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Hook",{"nth":14,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Signer",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Majority",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["DisabledValidator",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["EmittedTxn",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookExecution",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookDefinition",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookParameter",{"nth":23,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["HookGrant",{"nth":24,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["VoteEntry",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["AuctionSlot",{"nth":26,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["AuthAccount",{"nth":27,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["XChainClaimProofSig",{"nth":28,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["XChainCreateAccountProofSig",{"nth":29,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["XChainClaimAttestationCollectionElement",{"nth":30,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["XChainCreateAccountAttestationCollectionElement",{"nth":31,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STObject"}],["Signers",{"nth":3,"isVLEncoded":false,"isSerialized":true,"isSigningField":false,"type":"STArray"}],["SignerEntries",{"nth":4,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Template",{"nth":5,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Necessary",{"nth":6,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Sufficient",{"nth":7,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["AffectedNodes",{"nth":8,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Memos",{"nth":9,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["NFTokens",{"nth":10,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Hooks",{"nth":11,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["VoteSlots",{"nth":12,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["Majorities",{"nth":16,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["DisabledValidators",{"nth":17,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookExecutions",{"nth":18,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookParameters",{"nth":19,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["HookGrants",{"nth":20,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["XChainClaimAttestations",{"nth":21,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["XChainCreateAccountAttestations",{"nth":22,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}],["AuthAccounts",{"nth":25,"isVLEncoded":false,"isSerialized":true,"isSigningField":true,"type":"STArray"}]],"TRANSACTION_RESULTS":{"telLOCAL_ERROR":-399,"telBAD_DOMAIN":-398,"telBAD_PATH_COUNT":-397,"telBAD_PUBLIC_KEY":-396,"telFAILED_PROCESSING":-395,"telINSUF_FEE_P":-394,"telNO_DST_PARTIAL":-393,"telCAN_NOT_QUEUE":-392,"telCAN_NOT_QUEUE_BALANCE":-391,"telCAN_NOT_QUEUE_BLOCKS":-390,"telCAN_NOT_QUEUE_BLOCKED":-389,"telCAN_NOT_QUEUE_FEE":-388,"telCAN_NOT_QUEUE_FULL":-387,"telWRONG_NETWORK":-386,"telREQUIRES_NETWORK_ID":-385,"telNETWORK_ID_MAKES_TX_NON_CANONICAL":-384,"temMALFORMED":-299,"temBAD_AMOUNT":-298,"temBAD_CURRENCY":-297,"temBAD_EXPIRATION":-296,"temBAD_FEE":-295,"temBAD_ISSUER":-294,"temBAD_LIMIT":-293,"temBAD_OFFER":-292,"temBAD_PATH":-291,"temBAD_PATH_LOOP":-290,"temBAD_REGKEY":-289,"temBAD_SEND_XRP_LIMIT":-288,"temBAD_SEND_XRP_MAX":-287,"temBAD_SEND_XRP_NO_DIRECT":-286,"temBAD_SEND_XRP_PARTIAL":-285,"temBAD_SEND_XRP_PATHS":-284,"temBAD_SEQUENCE":-283,"temBAD_SIGNATURE":-282,"temBAD_SRC_ACCOUNT":-281,"temBAD_TRANSFER_RATE":-280,"temDST_IS_SRC":-279,"temDST_NEEDED":-278,"temINVALID":-277,"temINVALID_FLAG":-276,"temREDUNDANT":-275,"temRIPPLE_EMPTY":-274,"temDISABLED":-273,"temBAD_SIGNER":-272,"temBAD_QUORUM":-271,"temBAD_WEIGHT":-270,"temBAD_TICK_SIZE":-269,"temINVALID_ACCOUNT_ID":-268,"temCANNOT_PREAUTH_SELF":-267,"temINVALID_COUNT":-266,"temUNCERTAIN":-265,"temUNKNOWN":-264,"temSEQ_AND_TICKET":-263,"temBAD_NFTOKEN_TRANSFER_FEE":-262,"temBAD_AMM_TOKENS":-261,"temXCHAIN_EQUAL_DOOR_ACCOUNTS":-260,"temXCHAIN_BAD_PROOF":-259,"temXCHAIN_BRIDGE_BAD_ISSUES":-258,"temXCHAIN_BRIDGE_NONDOOR_OWNER":-257,"temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT":-256,"temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT":-255,"temEMPTY_DID":-254,"tefFAILURE":-199,"tefALREADY":-198,"tefBAD_ADD_AUTH":-197,"tefBAD_AUTH":-196,"tefBAD_LEDGER":-195,"tefCREATED":-194,"tefEXCEPTION":-193,"tefINTERNAL":-192,"tefNO_AUTH_REQUIRED":-191,"tefPAST_SEQ":-190,"tefWRONG_PRIOR":-189,"tefMASTER_DISABLED":-188,"tefMAX_LEDGER":-187,"tefBAD_SIGNATURE":-186,"tefBAD_QUORUM":-185,"tefNOT_MULTI_SIGNING":-184,"tefBAD_AUTH_MASTER":-183,"tefINVARIANT_FAILED":-182,"tefTOO_BIG":-181,"tefNO_TICKET":-180,"tefNFTOKEN_IS_NOT_TRANSFERABLE":-179,"terRETRY":-99,"terFUNDS_SPENT":-98,"terINSUF_FEE_B":-97,"terNO_ACCOUNT":-96,"terNO_AUTH":-95,"terNO_LINE":-94,"terOWNERS":-93,"terPRE_SEQ":-92,"terLAST":-91,"terNO_RIPPLE":-90,"terQUEUED":-89,"terPRE_TICKET":-88,"terNO_AMM":-87,"terSUBMITTED":-86,"tesSUCCESS":0,"tecCLAIM":100,"tecPATH_PARTIAL":101,"tecUNFUNDED_ADD":102,"tecUNFUNDED_OFFER":103,"tecUNFUNDED_PAYMENT":104,"tecFAILED_PROCESSING":105,"tecDIR_FULL":121,"tecINSUF_RESERVE_LINE":122,"tecINSUF_RESERVE_OFFER":123,"tecNO_DST":124,"tecNO_DST_INSUF_XRP":125,"tecNO_LINE_INSUF_RESERVE":126,"tecNO_LINE_REDUNDANT":127,"tecPATH_DRY":128,"tecUNFUNDED":129,"tecNO_ALTERNATIVE_KEY":130,"tecNO_REGULAR_KEY":131,"tecOWNERS":132,"tecNO_ISSUER":133,"tecNO_AUTH":134,"tecNO_LINE":135,"tecINSUFF_FEE":136,"tecFROZEN":137,"tecNO_TARGET":138,"tecNO_PERMISSION":139,"tecNO_ENTRY":140,"tecINSUFFICIENT_RESERVE":141,"tecNEED_MASTER_KEY":142,"tecDST_TAG_NEEDED":143,"tecINTERNAL":144,"tecOVERSIZE":145,"tecCRYPTOCONDITION_ERROR":146,"tecINVARIANT_FAILED":147,"tecEXPIRED":148,"tecDUPLICATE":149,"tecKILLED":150,"tecHAS_OBLIGATIONS":151,"tecTOO_SOON":152,"tecHOOK_REJECTED":153,"tecMAX_SEQUENCE_REACHED":154,"tecNO_SUITABLE_NFTOKEN_PAGE":155,"tecNFTOKEN_BUY_SELL_MISMATCH":156,"tecNFTOKEN_OFFER_TYPE_MISMATCH":157,"tecCANT_ACCEPT_OWN_NFTOKEN_OFFER":158,"tecINSUFFICIENT_FUNDS":159,"tecOBJECT_NOT_FOUND":160,"tecINSUFFICIENT_PAYMENT":161,"tecUNFUNDED_AMM":162,"tecAMM_BALANCE":163,"tecAMM_FAILED":164,"tecAMM_INVALID_TOKENS":165,"tecAMM_EMPTY":166,"tecAMM_NOT_EMPTY":167,"tecAMM_ACCOUNT":168,"tecINCOMPLETE":169,"tecXCHAIN_BAD_TRANSFER_ISSUE":170,"tecXCHAIN_NO_CLAIM_ID":171,"tecXCHAIN_BAD_CLAIM_ID":172,"tecXCHAIN_CLAIM_NO_QUORUM":173,"tecXCHAIN_PROOF_UNKNOWN_KEY":174,"tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE":175,"tecXCHAIN_WRONG_CHAIN":176,"tecXCHAIN_REWARD_MISMATCH":177,"tecXCHAIN_NO_SIGNERS_LIST":178,"tecXCHAIN_SENDING_ACCOUNT_MISMATCH":179,"tecXCHAIN_INSUFF_CREATE_AMOUNT":180,"tecXCHAIN_ACCOUNT_CREATE_PAST":181,"tecXCHAIN_ACCOUNT_CREATE_TOO_MANY":182,"tecXCHAIN_PAYMENT_FAILED":183,"tecXCHAIN_SELF_COMMIT":184,"tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR":185,"tecXCHAIN_CREATE_ACCOUNT_DISABLED":186,"tecEMPTY_DID":187},"TRANSACTION_TYPES":{"Invalid":-1,"Payment":0,"EscrowCreate":1,"EscrowFinish":2,"AccountSet":3,"EscrowCancel":4,"SetRegularKey":5,"NickNameSet":6,"OfferCreate":7,"OfferCancel":8,"Contract":9,"TicketCreate":10,"TicketCancel":11,"SignerListSet":12,"PaymentChannelCreate":13,"PaymentChannelFund":14,"PaymentChannelClaim":15,"CheckCreate":16,"CheckCash":17,"CheckCancel":18,"DepositPreauth":19,"TrustSet":20,"AccountDelete":21,"SetHook":22,"NFTokenMint":25,"NFTokenBurn":26,"NFTokenCreateOffer":27,"NFTokenCancelOffer":28,"NFTokenAcceptOffer":29,"Clawback":30,"AMMCreate":35,"AMMDeposit":36,"AMMWithdraw":37,"AMMVote":38,"AMMBid":39,"AMMDelete":40,"XChainCreateClaimID":41,"XChainCommit":42,"XChainClaim":43,"XChainAccountCreateCommit":44,"XChainAddClaimAttestation":45,"XChainAddAccountCreateAttestation":46,"XChainModifyBridge":47,"XChainCreateBridge":48,"DIDSet":49,"DIDDelete":50,"EnableAmendment":100,"SetFee":101,"UNLModify":102}}');

/***/ })

};
;
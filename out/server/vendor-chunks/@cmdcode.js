"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@cmdcode";
exports.ids = ["vendor-chunks/@cmdcode"];
exports.modules = {

/***/ "(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/buff-utils/dist/module.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Buff: () => (/* binding */ Buff),\n/* harmony export */   Encoder: () => (/* binding */ Encoder),\n/* harmony export */   Hex: () => (/* binding */ Hex),\n/* harmony export */   Stream: () => (/* binding */ Stream),\n/* harmony export */   Txt: () => (/* binding */ Txt),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   buffer: () => (/* binding */ buffer),\n/* harmony export */   util: () => (/* binding */ utils)\n/* harmony export */ });\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58check = /* @__PURE__ */ (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = /* @__PURE__ */ genBech32('bech32');\nconst bech32m = /* @__PURE__ */ genBech32('bech32m');\n\nconst Encoder = {\n    b58chk: {\n        encode: (data) => base58check(sha256).encode(data),\n        decode: (data) => base58check(sha256).decode(data)\n    },\n    base64: {\n        encode: (data) => base64.encode(data),\n        decode: (data) => base64.decode(data)\n    },\n    b64url: {\n        encode: (data) => base64url.encode(data),\n        decode: (data) => base64url.decode(data)\n    },\n    bech32: {\n        to_words: bech32.toWords,\n        to_bytes: bech32.fromWords,\n        encode: (prefix, words, limit = false) => {\n            return bech32.encode(prefix, words, limit);\n        },\n        decode: (data, limit = false) => {\n            const { prefix, words } = bech32.decode(data, limit);\n            return { prefix, words };\n        }\n    },\n    bech32m: {\n        to_words: bech32m.toWords,\n        to_bytes: bech32m.fromWords,\n        encode: (prefix, words, limit = false) => {\n            return bech32m.encode(prefix, words, limit);\n        },\n        decode: (data, limit = false) => {\n            const { prefix, words } = bech32m.decode(data, limit);\n            return { prefix, words };\n        }\n    }\n};\n\nfunction within_size(data, size) {\n    if (data.length > size) {\n        throw new TypeError(`Data is larger than array size: ${data.length} > ${size}`);\n    }\n}\nfunction is_hex$1(hex) {\n    if (hex.match(/[^a-fA-f0-9]/) !== null) {\n        throw new TypeError('Invalid characters in hex string: ' + hex);\n    }\n    if (hex.length % 2 !== 0) {\n        throw new Error(`Length of hex string is invalid: ${hex.length}`);\n    }\n}\nfunction is_json(str) {\n    try {\n        JSON.parse(str);\n    }\n    catch {\n        throw new TypeError('JSON string is invalid!');\n    }\n}\nfunction is_safe_num(num) {\n    if (num > Number.MAX_SAFE_INTEGER) {\n        throw new TypeError('Number exceeds safe bounds!');\n    }\n}\nfunction is_prefix(actual, target) {\n    if (actual !== target) {\n        throw new TypeError(`Bech32 prefix does not match: ${actual} !== ${target}`);\n    }\n}\n\nvar assert = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    is_hex: is_hex$1,\n    is_json: is_json,\n    is_prefix: is_prefix,\n    is_safe_num: is_safe_num,\n    within_size: within_size\n});\n\nconst _0n = BigInt(0);\nconst _255n = BigInt(255);\nconst _256n = BigInt(256);\nfunction big_size(big) {\n    if (big <= 0xffn)\n        return 1;\n    if (big <= 0xffffn)\n        return 2;\n    if (big <= 0xffffffffn)\n        return 4;\n    if (big <= 0xffffffffffffffffn)\n        return 8;\n    if (big <= 0xffffffffffffffffffffffffffffffffn)\n        return 16;\n    if (big <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) {\n        return 32;\n    }\n    throw new TypeError('Must specify a fixed buffer size for bigints greater than 32 bytes.');\n}\nfunction bigToBytes(big, size, endian = 'be') {\n    if (size === undefined)\n        size = big_size(big);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (big > _0n) {\n        const byte = big & _255n;\n        const num = Number(byte);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        big = (big - byte) / _256n;\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToBig(bytes) {\n    let num = BigInt(0);\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * _256n) + BigInt(bytes[i]);\n    }\n    return BigInt(num);\n}\n\nfunction binToBytes(binary) {\n    const bins = binary.split('').map(Number);\n    if (bins.length % 8 !== 0) {\n        throw new Error(`Binary array is invalid length: ${binary.length}`);\n    }\n    const bytes = new Uint8Array(bins.length / 8);\n    for (let i = 0, ct = 0; i < bins.length; i += 8, ct++) {\n        let byte = 0;\n        for (let j = 0; j < 8; j++) {\n            byte |= (bins[i + j] << (7 - j));\n        }\n        bytes[ct] = byte;\n    }\n    return bytes;\n}\nfunction bytesToBin(bytes) {\n    const bin = new Array(bytes.length * 8);\n    let count = 0;\n    for (const num of bytes) {\n        if (num > 255) {\n            throw new Error(`Invalid byte value: ${num}. Byte values must be between 0 and 255.`);\n        }\n        for (let i = 7; i >= 0; i--, count++) {\n            bin[count] = (num >> i) & 1;\n        }\n    }\n    return bin.join('');\n}\n\nfunction num_size(num) {\n    if (num <= 0xFF)\n        return 1;\n    if (num <= 0xFFFF)\n        return 2;\n    if (num <= 0xFFFFFFFF)\n        return 4;\n    throw new TypeError('Numbers larger than 4 bytes must specify a fixed size!');\n}\nfunction numToBytes(num, size, endian = 'be') {\n    if (size === undefined)\n        size = num_size(num);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (num > 0) {\n        const byte = num & 255;\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        num = (num - byte) / 256;\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToNum(bytes) {\n    let num = 0;\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * 256) + bytes[i];\n        is_safe_num(num);\n    }\n    return num;\n}\n\nconst ec = new TextEncoder();\nconst dc = new TextDecoder();\nfunction strToBytes(str) {\n    return ec.encode(str);\n}\nfunction bytesToStr(bytes) {\n    return dc.decode(bytes);\n}\nfunction hex_size(hexstr, size) {\n    is_hex$1(hexstr);\n    const len = hexstr.length / 2;\n    if (size === undefined)\n        size = len;\n    if (len > size) {\n        throw new TypeError(`Hex string is larger than array size: ${len} > ${size}`);\n    }\n    return size;\n}\nfunction hexToBytes(hexstr, size, endian = 'le') {\n    size = hex_size(hexstr, size);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    for (let i = 0; i < hexstr.length; i += 2) {\n        const char = hexstr.substring(i, i + 2);\n        const num = parseInt(char, 16);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToHex(bytes) {\n    let chars = '';\n    for (let i = 0; i < bytes.length; i++) {\n        chars += bytes[i].toString(16).padStart(2, '0');\n    }\n    return chars;\n}\nconst Hex = {\n    encode: bytesToHex,\n    decode: hexToBytes\n};\nconst Txt = {\n    encode: strToBytes,\n    decode: bytesToStr\n};\n\nconst { getRandomValues } = crypto ?? globalThis.crypto ?? window.crypto;\nfunction random(size = 32) {\n    if (typeof getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(size));\n    }\n    throw new Error('Crypto module missing getRandomValues!');\n}\nfunction is_hex(input) {\n    if (input.match(/[^a-fA-f0-9]/) === null &&\n        input.length % 2 === 0) {\n        return true;\n    }\n    return false;\n}\nfunction is_bytes(input) {\n    if (typeof input === 'string' &&\n        is_hex(input)) {\n        return true;\n    }\n    else if (typeof input === 'number' ||\n        typeof input === 'bigint' ||\n        input instanceof Uint8Array) {\n        return true;\n    }\n    else if (Array.isArray(input) &&\n        input.every(e => typeof e === 'number')) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction set_buffer(data, size, endian = 'be') {\n    if (size === undefined)\n        size = data.length;\n    within_size(data, size);\n    const buffer = new Uint8Array(size).fill(0);\n    const offset = (endian === 'be') ? 0 : size - data.length;\n    buffer.set(data, offset);\n    return buffer;\n}\nfunction join_array(arr) {\n    let i, offset = 0;\n    const size = arr.reduce((len, arr) => len + arr.length, 0);\n    const buff = new Uint8Array(size);\n    for (i = 0; i < arr.length; i++) {\n        const a = arr[i];\n        buff.set(a, offset);\n        offset += a.length;\n    }\n    return buff;\n}\nfunction bigint_replacer(_, v) {\n    return typeof v === 'bigint'\n        ? `${v}n`\n        : v;\n}\nfunction bigint_reviver(_, v) {\n    return typeof v === 'string' && /n$/.test(v)\n        ? BigInt(v.slice(0, -1))\n        : v;\n}\nfunction parse_data$1(data_blob, chunk_size, total_size) {\n    const len = data_blob.length, count = total_size / chunk_size;\n    if (total_size % chunk_size !== 0) {\n        throw new TypeError(`Invalid parameters: ${total_size} % ${chunk_size} !== 0`);\n    }\n    if (len !== total_size) {\n        throw new TypeError(`Invalid data stream: ${len} !== ${total_size}`);\n    }\n    if (len % chunk_size !== 0) {\n        throw new TypeError(`Invalid data stream: ${len} % ${chunk_size} !== 0`);\n    }\n    const chunks = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const idx = i * chunk_size;\n        chunks[i] = data_blob.subarray(idx, idx + chunk_size);\n    }\n    return chunks;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    bigint_replacer: bigint_replacer,\n    bigint_reviver: bigint_reviver,\n    is_bytes: is_bytes,\n    is_hex: is_hex,\n    join_array: join_array,\n    parse_data: parse_data$1,\n    random: random,\n    set_buffer: set_buffer\n});\n\nfunction buffer_data(data, size, endian) {\n    if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    else if (data instanceof Uint8Array) {\n        return set_buffer(data, size, endian);\n    }\n    else if (Array.isArray(data)) {\n        const bytes = data.map(e => buffer_data(e, size, endian));\n        return join_array(bytes);\n    }\n    else if (typeof data === 'string') {\n        return hexToBytes(data, size, endian);\n    }\n    else if (typeof data === 'bigint') {\n        return bigToBytes(data, size, endian);\n    }\n    else if (typeof data === 'number') {\n        return numToBytes(data, size, endian);\n    }\n    else if (typeof data === 'boolean') {\n        return Uint8Array.of(data ? 1 : 0);\n    }\n    throw new TypeError('Unsupported format:' + String(typeof data));\n}\n\nclass Buff extends Uint8Array {\n    static { this.num = numToBuff; }\n    static { this.big = bigToBuff; }\n    static { this.bin = binToBuff; }\n    static { this.raw = rawToBuff; }\n    static { this.str = strToBuff; }\n    static { this.hex = hexToBuff; }\n    static { this.bytes = buffer; }\n    static { this.json = jsonToBuff; }\n    static { this.base64 = base64ToBuff; }\n    static { this.b64url = b64urlToBuff; }\n    static { this.bech32 = bech32ToBuff; }\n    static { this.bech32m = bech32mToBuff; }\n    static { this.b58chk = b58chkToBuff; }\n    static { this.encode = strToBytes; }\n    static { this.decode = bytesToStr; }\n    static { this.parse = parse_data; }\n    static { this.is_bytes = is_bytes; }\n    static { this.is_hex = is_hex; }\n    static random(size = 32) {\n        const rand = random(size);\n        return new Buff(rand, size);\n    }\n    static now(size = 4) {\n        const stamp = Math.floor(Date.now() / 1000);\n        return new Buff(stamp, size);\n    }\n    constructor(data, size, endian) {\n        if (data instanceof Buff &&\n            size === undefined) {\n            return data;\n        }\n        const buffer = buffer_data(data, size, endian);\n        super(buffer);\n    }\n    get arr() {\n        return [...this];\n    }\n    get num() {\n        return this.to_num();\n    }\n    get big() {\n        return this.to_big();\n    }\n    get str() {\n        return this.to_str();\n    }\n    get hex() {\n        return this.to_hex();\n    }\n    get raw() {\n        return new Uint8Array(this);\n    }\n    get bin() {\n        return this.to_bin();\n    }\n    get b58chk() {\n        return this.to_b58chk();\n    }\n    get base64() {\n        return this.to_base64();\n    }\n    get b64url() {\n        return this.to_b64url();\n    }\n    get digest() {\n        return this.to_hash();\n    }\n    get id() {\n        return this.to_hash().hex;\n    }\n    get stream() {\n        return new Stream(this);\n    }\n    to_num(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return bytesToNum(bytes);\n    }\n    to_big(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return bytesToBig(bytes);\n    }\n    to_bin() {\n        return bytesToBin(this);\n    }\n    to_hash() {\n        const digest = sha256(this);\n        return new Buff(digest);\n    }\n    to_json(reviver) {\n        if (reviver === undefined) {\n            reviver = bigint_reviver;\n        }\n        const str = bytesToStr(this);\n        return JSON.parse(str, reviver);\n    }\n    to_bech32(prefix, limit) {\n        const { encode, to_words } = Encoder.bech32;\n        const words = to_words(this);\n        return encode(prefix, words, limit);\n    }\n    to_bech32m(prefix, limit) {\n        const { encode, to_words } = Encoder.bech32m;\n        const words = to_words(this);\n        return encode(prefix, words, limit);\n    }\n    to_str() { return bytesToStr(this); }\n    to_hex() { return bytesToHex(this); }\n    to_bytes() { return new Uint8Array(this); }\n    to_b58chk() { return Encoder.b58chk.encode(this); }\n    to_base64() { return Encoder.base64.encode(this); }\n    to_b64url() { return Encoder.b64url.encode(this); }\n    append(data) {\n        return Buff.join([this, Buff.bytes(data)]);\n    }\n    prepend(data) {\n        return Buff.join([Buff.bytes(data), this]);\n    }\n    reverse() {\n        const arr = new Uint8Array(this).reverse();\n        return new Buff(arr);\n    }\n    slice(start, end) {\n        const arr = new Uint8Array(this).slice(start, end);\n        return new Buff(arr);\n    }\n    set(array, offset) {\n        this.set(array, offset);\n    }\n    subarray(begin, end) {\n        const arr = new Uint8Array(this).subarray(begin, end);\n        return new Buff(arr);\n    }\n    write(bytes, offset) {\n        const b = Buff.bytes(bytes);\n        this.set(b, offset);\n    }\n    add_varint(endian) {\n        const size = Buff.calc_varint(this.length, endian);\n        return Buff.join([size, this]);\n    }\n    static from(data) {\n        return new Buff(Uint8Array.from(data));\n    }\n    static of(...args) {\n        return new Buff(Uint8Array.of(...args));\n    }\n    static join(arr) {\n        const bytes = arr.map(e => Buff.bytes(e));\n        const joined = join_array(bytes);\n        return new Buff(joined);\n    }\n    static sort(arr, size) {\n        const hex = arr.map(e => buffer(e, size).hex);\n        hex.sort();\n        return hex.map(e => Buff.hex(e, size));\n    }\n    static calc_varint(num, endian) {\n        if (num < 0xFD) {\n            return Buff.num(num, 1);\n        }\n        else if (num < 0x10000) {\n            return Buff.of(0xFD, ...Buff.num(num, 2, endian));\n        }\n        else if (num < 0x100000000) {\n            return Buff.of(0xFE, ...Buff.num(num, 4, endian));\n        }\n        else if (BigInt(num) < 0x10000000000000000n) {\n            return Buff.of(0xFF, ...Buff.num(num, 8, endian));\n        }\n        else {\n            throw new Error(`Value is too large: ${num}`);\n        }\n    }\n}\nfunction numToBuff(number, size, endian) {\n    return new Buff(number, size, endian);\n}\nfunction binToBuff(data, size, endian) {\n    return new Buff(binToBytes(data), size, endian);\n}\nfunction bigToBuff(bigint, size, endian) {\n    return new Buff(bigint, size, endian);\n}\nfunction rawToBuff(data, size, endian) {\n    return new Buff(data, size, endian);\n}\nfunction strToBuff(data, size, endian) {\n    return new Buff(strToBytes(data), size, endian);\n}\nfunction hexToBuff(data, size, endian) {\n    return new Buff(data, size, endian);\n}\nfunction jsonToBuff(data, replacer) {\n    if (replacer === undefined) {\n        replacer = bigint_replacer;\n    }\n    const str = JSON.stringify(data, replacer);\n    return new Buff(strToBytes(str));\n}\nfunction base64ToBuff(data) {\n    return new Buff(Encoder.base64.decode(data));\n}\nfunction b64urlToBuff(data) {\n    return new Buff(Encoder.b64url.decode(data));\n}\nfunction bech32ToBuff(data, limit, chk_prefix) {\n    const { decode, to_bytes } = Encoder.bech32;\n    const { prefix, words } = decode(data, limit);\n    const bytes = to_bytes(words);\n    if (typeof chk_prefix === 'string') {\n        is_prefix(prefix, chk_prefix);\n    }\n    return new Buff(bytes);\n}\nfunction bech32mToBuff(data, limit, chk_prefix) {\n    const { decode, to_bytes } = Encoder.bech32m;\n    const { prefix, words } = decode(data, limit);\n    const bytes = to_bytes(words);\n    if (typeof chk_prefix === 'string') {\n        is_prefix(prefix, chk_prefix);\n    }\n    return new Buff(bytes);\n}\nfunction b58chkToBuff(data) {\n    return new Buff(Encoder.b58chk.decode(data));\n}\nfunction parse_data(data_blob, chunk_size, total_size) {\n    const bytes = buffer_data(data_blob);\n    const chunks = parse_data$1(bytes, chunk_size, total_size);\n    return chunks.map(e => Buff.bytes(e));\n}\nclass Stream {\n    constructor(data) {\n        this.data = Buff.bytes(data);\n        this.size = this.data.length;\n    }\n    peek(size) {\n        if (size > this.size) {\n            throw new Error(`Size greater than stream: ${size} > ${this.size}`);\n        }\n        return new Buff(this.data.slice(0, size));\n    }\n    read(size) {\n        const chunk = this.peek(size);\n        this.data = this.data.slice(size);\n        this.size = this.data.length;\n        return chunk;\n    }\n    read_varint(endian) {\n        const num = this.read(1).num;\n        switch (true) {\n            case (num >= 0 && num < 0xFD):\n                return num;\n            case (num === 0xFD):\n                return this.read(2).to_num(endian);\n            case (num === 0xFE):\n                return this.read(4).to_num(endian);\n            case (num === 0xFF):\n                return this.read(8).to_num(endian);\n            default:\n                throw new Error(`Varint is out of range: ${num}`);\n        }\n    }\n}\nfunction buffer(bytes, size, end) {\n    return new Buff(bytes, size, end);\n}\n\n\n//# sourceMappingURL=module.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi11dGlscy9kaXN0L21vZHVsZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEU7QUFDMUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9idWZmLXV0aWxzL2Rpc3QvbW9kdWxlLm1qcz9kZTkzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cblxuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5jb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cblxuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5jbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5cbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5jb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5cbi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXNcblxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGFpbiguLi5hcmdzKSB7XG4gICAgLy8gV3JhcCBjYWxsIGluIGNsb3N1cmUgc28gSklUIGNhbiBpbmxpbmUgY2FsbHNcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWy0xXS5lbmNvZGUoYXJnc1stMl0uZW5jb2RlKFsuLi5dKSlcbiAgICBjb25zdCBlbmNvZGUgPSBBcnJheS5mcm9tKGFyZ3MpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZW5jb2RlKSA6IGkuZW5jb2RlKSwgdW5kZWZpbmVkKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1swXS5kZWNvZGUoYXJnc1sxXS5kZWNvZGUoLi4uKSlcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZGVjb2RlKSA6IGkuZGVjb2RlKSwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuLyoqXG4gKiBFbmNvZGVzIGludGVnZXIgcmFkaXggcmVwcmVzZW50YXRpb24gdG8gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhbHBoYWJldCBhbmQgYmFja1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYWxwaGFiZXQoYWxwaGFiZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGFkIHN0cmluZ3MgYXJyYXkgc28gaXQgaGFzIGludGVnZXIgbnVtYmVyIG9mIGJpdHNcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogU2xvdzogTyhuXjIpIHRpbWUgY29tcGxleGl0eVxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgLy8gYmFzZSAxIGlzIGltcG9zc2libGVcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IE1hdGguZmxvb3IoZGlnaXRCYXNlIC8gdG8pO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gcm91bmRlZDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocm91bmRlZCkgfHwgcm91bmRlZCAqIHRvICsgY2FycnkgIT09IGRpZ2l0QmFzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyb3VuZGVkKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IC8qQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGZyb20sIHRvKSA9PiBmcm9tICsgKHRvIC0gZ2NkKGZyb20sIHRvKSk7XG4vKipcbiAqIEltcGxlbWVudGVkIHdpdGggbnVtYmVycywgYmVjYXVzZSBCaWdJbnQgaXMgNXggc2xvd2VyXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGEsIGZyb20sIHRvLCBwYWRkaW5nKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDI6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7IC8vIGJpdHdpc2UgcG9zaXRpb24gaW4gY3VycmVudCBlbGVtZW50XG4gICAgY29uc3QgbWFzayA9IDIgKiogdG8gLSAxO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxOyAvLyBjbGVhbiBjYXJyeSwgb3RoZXJ3aXNlIGl0IHdpbGwgY2F1c2Ugb3ZlcmZsb3dcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIElmIGJvdGggYmFzZXMgYXJlIHBvd2VyIG9mIHNhbWUgbnVtYmVyIChsaWtlIGAyKio4IDwtPiAyKio2NGApLFxuICogdGhlcmUgaXMgYSBsaW5lYXIgYWxnb3JpdGhtLiBGb3Igbm93IHdlIGhhdmUgaW1wbGVtZW50YXRpb24gZm9yIHBvd2VyLW9mLXR3byBiYXNlcyBvbmx5LlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNvbnN0IGJhc2U2NCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmNvbnN0IGJhc2U2NHVybCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbi8vIGJhc2U1OCBjb2RlXG4vLyAtLS0tLS0tLS0tLVxuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5jb25zdCBiYXNlNTggPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jyk7XG5jb25zdCBiYXNlNThjaGVjayA9IC8qIEBfX1BVUkVfXyAqLyAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgcHJlZml4IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBwcmVmaXh9YCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3b3JkcykgfHwgKHdvcmRzLmxlbmd0aCAmJiB0eXBlb2Ygd29yZHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSB3b3JkcyBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycywgbm90ICR7dHlwZW9mIHdvcmRzfWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShsb3dlcmVkLCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICByZXR1cm4gYCR7bG93ZXJlZH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtzdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgX3dvcmRzID0gc3RyLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChfd29yZHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoX3dvcmRzKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghX3dvcmRzLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlVG9CeXRlcywgZGVjb2RlVW5zYWZlLCBmcm9tV29yZHMsIGZyb21Xb3Jkc1Vuc2FmZSwgdG9Xb3JkcyB9O1xufVxuY29uc3QgYmVjaDMyID0gLyogQF9fUFVSRV9fICovIGdlbkJlY2gzMignYmVjaDMyJyk7XG5jb25zdCBiZWNoMzJtID0gLyogQF9fUFVSRV9fICovIGdlbkJlY2gzMignYmVjaDMybScpO1xuXG5jb25zdCBFbmNvZGVyID0ge1xuICAgIGI1OGNoazoge1xuICAgICAgICBlbmNvZGU6IChkYXRhKSA9PiBiYXNlNThjaGVjayhzaGEyNTYpLmVuY29kZShkYXRhKSxcbiAgICAgICAgZGVjb2RlOiAoZGF0YSkgPT4gYmFzZTU4Y2hlY2soc2hhMjU2KS5kZWNvZGUoZGF0YSlcbiAgICB9LFxuICAgIGJhc2U2NDoge1xuICAgICAgICBlbmNvZGU6IChkYXRhKSA9PiBiYXNlNjQuZW5jb2RlKGRhdGEpLFxuICAgICAgICBkZWNvZGU6IChkYXRhKSA9PiBiYXNlNjQuZGVjb2RlKGRhdGEpXG4gICAgfSxcbiAgICBiNjR1cmw6IHtcbiAgICAgICAgZW5jb2RlOiAoZGF0YSkgPT4gYmFzZTY0dXJsLmVuY29kZShkYXRhKSxcbiAgICAgICAgZGVjb2RlOiAoZGF0YSkgPT4gYmFzZTY0dXJsLmRlY29kZShkYXRhKVxuICAgIH0sXG4gICAgYmVjaDMyOiB7XG4gICAgICAgIHRvX3dvcmRzOiBiZWNoMzIudG9Xb3JkcyxcbiAgICAgICAgdG9fYnl0ZXM6IGJlY2gzMi5mcm9tV29yZHMsXG4gICAgICAgIGVuY29kZTogKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBiZWNoMzIuZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGF0YSwgbGltaXQgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBiZWNoMzIuZGVjb2RlKGRhdGEsIGxpbWl0KTtcbiAgICAgICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVjaDMybToge1xuICAgICAgICB0b193b3JkczogYmVjaDMybS50b1dvcmRzLFxuICAgICAgICB0b19ieXRlczogYmVjaDMybS5mcm9tV29yZHMsXG4gICAgICAgIGVuY29kZTogKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBiZWNoMzJtLmVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRhdGEsIGxpbWl0ID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gYmVjaDMybS5kZWNvZGUoZGF0YSwgbGltaXQpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd2l0aGluX3NpemUoZGF0YSwgc2l6ZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IHNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRGF0YSBpcyBsYXJnZXIgdGhhbiBhcnJheSBzaXplOiAke2RhdGEubGVuZ3RofSA+ICR7c2l6ZX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc19oZXgkMShoZXgpIHtcbiAgICBpZiAoaGV4Lm1hdGNoKC9bXmEtZkEtZjAtOV0vKSAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlcnMgaW4gaGV4IHN0cmluZzogJyArIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExlbmd0aCBvZiBoZXggc3RyaW5nIGlzIGludmFsaWQ6ICR7aGV4Lmxlbmd0aH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc19qc29uKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIEpTT04ucGFyc2Uoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKU09OIHN0cmluZyBpcyBpbnZhbGlkIScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzX3NhZmVfbnVtKG51bSkge1xuICAgIGlmIChudW0gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOdW1iZXIgZXhjZWVkcyBzYWZlIGJvdW5kcyEnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc19wcmVmaXgoYWN0dWFsLCB0YXJnZXQpIHtcbiAgICBpZiAoYWN0dWFsICE9PSB0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQmVjaDMyIHByZWZpeCBkb2VzIG5vdCBtYXRjaDogJHthY3R1YWx9ICE9PSAke3RhcmdldH1gKTtcbiAgICB9XG59XG5cbnZhciBhc3NlcnQgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGlzX2hleDogaXNfaGV4JDEsXG4gICAgaXNfanNvbjogaXNfanNvbixcbiAgICBpc19wcmVmaXg6IGlzX3ByZWZpeCxcbiAgICBpc19zYWZlX251bTogaXNfc2FmZV9udW0sXG4gICAgd2l0aGluX3NpemU6IHdpdGhpbl9zaXplXG59KTtcblxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzI1NW4gPSBCaWdJbnQoMjU1KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5mdW5jdGlvbiBiaWdfc2l6ZShiaWcpIHtcbiAgICBpZiAoYmlnIDw9IDB4ZmZuKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAoYmlnIDw9IDB4ZmZmZm4pXG4gICAgICAgIHJldHVybiAyO1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZm4pXG4gICAgICAgIHJldHVybiA0O1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZmZmZmZmZmZmbilcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgaWYgKGJpZyA8PSAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbilcbiAgICAgICAgcmV0dXJuIDE2O1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbikge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3Qgc3BlY2lmeSBhIGZpeGVkIGJ1ZmZlciBzaXplIGZvciBiaWdpbnRzIGdyZWF0ZXIgdGhhbiAzMiBieXRlcy4nKTtcbn1cbmZ1bmN0aW9uIGJpZ1RvQnl0ZXMoYmlnLCBzaXplLCBlbmRpYW4gPSAnYmUnKSB7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2l6ZSA9IGJpZ19zaXplKGJpZyk7XG4gICAgY29uc3QgdXNlX2xlID0gKGVuZGlhbiA9PT0gJ2xlJyk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgbGV0IG9mZnNldCA9ICh1c2VfbGUpID8gMCA6IHNpemUgLSAxO1xuICAgIHdoaWxlIChiaWcgPiBfMG4pIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGJpZyAmIF8yNTVuO1xuICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIoYnl0ZSk7XG4gICAgICAgIGlmICh1c2VfbGUpIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KG9mZnNldCsrLCBudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0LS0sIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgYmlnID0gKGJpZyAtIGJ5dGUpIC8gXzI1Nm47XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb0JpZyhieXRlcykge1xuICAgIGxldCBudW0gPSBCaWdJbnQoMCk7XG4gICAgZm9yIChsZXQgaSA9IGJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG51bSA9IChudW0gKiBfMjU2bikgKyBCaWdJbnQoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KG51bSk7XG59XG5cbmZ1bmN0aW9uIGJpblRvQnl0ZXMoYmluYXJ5KSB7XG4gICAgY29uc3QgYmlucyA9IGJpbmFyeS5zcGxpdCgnJykubWFwKE51bWJlcik7XG4gICAgaWYgKGJpbnMubGVuZ3RoICUgOCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmFyeSBhcnJheSBpcyBpbnZhbGlkIGxlbmd0aDogJHtiaW5hcnkubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbnMubGVuZ3RoIC8gOCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGN0ID0gMDsgaSA8IGJpbnMubGVuZ3RoOyBpICs9IDgsIGN0KyspIHtcbiAgICAgICAgbGV0IGJ5dGUgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgICAgICAgYnl0ZSB8PSAoYmluc1tpICsgal0gPDwgKDcgLSBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXNbY3RdID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gYnl0ZXNUb0JpbihieXRlcykge1xuICAgIGNvbnN0IGJpbiA9IG5ldyBBcnJheShieXRlcy5sZW5ndGggKiA4KTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgbnVtIG9mIGJ5dGVzKSB7XG4gICAgICAgIGlmIChudW0gPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBieXRlIHZhbHVlOiAke251bX0uIEJ5dGUgdmFsdWVzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgaS0tLCBjb3VudCsrKSB7XG4gICAgICAgICAgICBiaW5bY291bnRdID0gKG51bSA+PiBpKSAmIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJpbi5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gbnVtX3NpemUobnVtKSB7XG4gICAgaWYgKG51bSA8PSAweEZGKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAobnVtIDw9IDB4RkZGRilcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgaWYgKG51bSA8PSAweEZGRkZGRkZGKVxuICAgICAgICByZXR1cm4gNDtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOdW1iZXJzIGxhcmdlciB0aGFuIDQgYnl0ZXMgbXVzdCBzcGVjaWZ5IGEgZml4ZWQgc2l6ZSEnKTtcbn1cbmZ1bmN0aW9uIG51bVRvQnl0ZXMobnVtLCBzaXplLCBlbmRpYW4gPSAnYmUnKSB7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2l6ZSA9IG51bV9zaXplKG51bSk7XG4gICAgY29uc3QgdXNlX2xlID0gKGVuZGlhbiA9PT0gJ2xlJyk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgbGV0IG9mZnNldCA9ICh1c2VfbGUpID8gMCA6IHNpemUgLSAxO1xuICAgIHdoaWxlIChudW0gPiAwKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBudW0gJiAyNTU7XG4gICAgICAgIGlmICh1c2VfbGUpIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KG9mZnNldCsrLCBudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0LS0sIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtID0gKG51bSAtIGJ5dGUpIC8gMjU2O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9OdW0oYnl0ZXMpIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgKGxldCBpID0gYnl0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbnVtID0gKG51bSAqIDI1NikgKyBieXRlc1tpXTtcbiAgICAgICAgaXNfc2FmZV9udW0obnVtKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbn1cblxuY29uc3QgZWMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IGRjID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBzdHJUb0J5dGVzKHN0cikge1xuICAgIHJldHVybiBlYy5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9TdHIoYnl0ZXMpIHtcbiAgICByZXR1cm4gZGMuZGVjb2RlKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGhleF9zaXplKGhleHN0ciwgc2l6ZSkge1xuICAgIGlzX2hleCQxKGhleHN0cik7XG4gICAgY29uc3QgbGVuID0gaGV4c3RyLmxlbmd0aCAvIDI7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2l6ZSA9IGxlbjtcbiAgICBpZiAobGVuID4gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBIZXggc3RyaW5nIGlzIGxhcmdlciB0aGFuIGFycmF5IHNpemU6ICR7bGVufSA+ICR7c2l6ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleHN0ciwgc2l6ZSwgZW5kaWFuID0gJ2xlJykge1xuICAgIHNpemUgPSBoZXhfc2l6ZShoZXhzdHIsIHNpemUpO1xuICAgIGNvbnN0IHVzZV9sZSA9IChlbmRpYW4gPT09ICdsZScpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAodXNlX2xlKSA/IDAgOiBzaXplIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhleHN0ci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBjaGFyID0gaGV4c3RyLnN1YnN0cmluZyhpLCBpICsgMik7XG4gICAgICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KGNoYXIsIDE2KTtcbiAgICAgICAgaWYgKHVzZV9sZSkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0KyssIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQtLSwgbnVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBsZXQgY2hhcnMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoYXJzICs9IGJ5dGVzW2ldLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG59XG5jb25zdCBIZXggPSB7XG4gICAgZW5jb2RlOiBieXRlc1RvSGV4LFxuICAgIGRlY29kZTogaGV4VG9CeXRlc1xufTtcbmNvbnN0IFR4dCA9IHtcbiAgICBlbmNvZGU6IHN0clRvQnl0ZXMsXG4gICAgZGVjb2RlOiBieXRlc1RvU3RyXG59O1xuXG5jb25zdCB7IGdldFJhbmRvbVZhbHVlcyB9ID0gY3J5cHRvID8/IGdsb2JhbFRoaXMuY3J5cHRvID8/IHdpbmRvdy5jcnlwdG87XG5mdW5jdGlvbiByYW5kb20oc2l6ZSA9IDMyKSB7XG4gICAgaWYgKHR5cGVvZiBnZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyeXB0byBtb2R1bGUgbWlzc2luZyBnZXRSYW5kb21WYWx1ZXMhJyk7XG59XG5mdW5jdGlvbiBpc19oZXgoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goL1teYS1mQS1mMC05XS8pID09PSBudWxsICYmXG4gICAgICAgIGlucHV0Lmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzX2J5dGVzKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgaXNfaGV4KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnIHx8XG4gICAgICAgIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiZcbiAgICAgICAgaW5wdXQuZXZlcnkoZSA9PiB0eXBlb2YgZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9idWZmZXIoZGF0YSwgc2l6ZSwgZW5kaWFuID0gJ2JlJykge1xuICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpXG4gICAgICAgIHNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICB3aXRoaW5fc2l6ZShkYXRhLCBzaXplKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzaXplKS5maWxsKDApO1xuICAgIGNvbnN0IG9mZnNldCA9IChlbmRpYW4gPT09ICdiZScpID8gMCA6IHNpemUgLSBkYXRhLmxlbmd0aDtcbiAgICBidWZmZXIuc2V0KGRhdGEsIG9mZnNldCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGpvaW5fYXJyYXkoYXJyKSB7XG4gICAgbGV0IGksIG9mZnNldCA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IGFyci5yZWR1Y2UoKGxlbiwgYXJyKSA9PiBsZW4gKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyW2ldO1xuICAgICAgICBidWZmLnNldChhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWZmO1xufVxuZnVuY3Rpb24gYmlnaW50X3JlcGxhY2VyKF8sIHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdiaWdpbnQnXG4gICAgICAgID8gYCR7dn1uYFxuICAgICAgICA6IHY7XG59XG5mdW5jdGlvbiBiaWdpbnRfcmV2aXZlcihfLCB2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJyAmJiAvbiQvLnRlc3QodilcbiAgICAgICAgPyBCaWdJbnQodi5zbGljZSgwLCAtMSkpXG4gICAgICAgIDogdjtcbn1cbmZ1bmN0aW9uIHBhcnNlX2RhdGEkMShkYXRhX2Jsb2IsIGNodW5rX3NpemUsIHRvdGFsX3NpemUpIHtcbiAgICBjb25zdCBsZW4gPSBkYXRhX2Jsb2IubGVuZ3RoLCBjb3VudCA9IHRvdGFsX3NpemUgLyBjaHVua19zaXplO1xuICAgIGlmICh0b3RhbF9zaXplICUgY2h1bmtfc2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHBhcmFtZXRlcnM6ICR7dG90YWxfc2l6ZX0gJSAke2NodW5rX3NpemV9ICE9PSAwYCk7XG4gICAgfVxuICAgIGlmIChsZW4gIT09IHRvdGFsX3NpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBkYXRhIHN0cmVhbTogJHtsZW59ICE9PSAke3RvdGFsX3NpemV9YCk7XG4gICAgfVxuICAgIGlmIChsZW4gJSBjaHVua19zaXplICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZGF0YSBzdHJlYW06ICR7bGVufSAlICR7Y2h1bmtfc2l6ZX0gIT09IDBgKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaSAqIGNodW5rX3NpemU7XG4gICAgICAgIGNodW5rc1tpXSA9IGRhdGFfYmxvYi5zdWJhcnJheShpZHgsIGlkeCArIGNodW5rX3NpemUpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bmtzO1xufVxuXG52YXIgdXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGJpZ2ludF9yZXBsYWNlcjogYmlnaW50X3JlcGxhY2VyLFxuICAgIGJpZ2ludF9yZXZpdmVyOiBiaWdpbnRfcmV2aXZlcixcbiAgICBpc19ieXRlczogaXNfYnl0ZXMsXG4gICAgaXNfaGV4OiBpc19oZXgsXG4gICAgam9pbl9hcnJheTogam9pbl9hcnJheSxcbiAgICBwYXJzZV9kYXRhOiBwYXJzZV9kYXRhJDEsXG4gICAgcmFuZG9tOiByYW5kb20sXG4gICAgc2V0X2J1ZmZlcjogc2V0X2J1ZmZlclxufSk7XG5cbmZ1bmN0aW9uIGJ1ZmZlcl9kYXRhKGRhdGEsIHNpemUsIGVuZGlhbikge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gc2V0X2J1ZmZlcihkYXRhLCBzaXplLCBlbmRpYW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZGF0YS5tYXAoZSA9PiBidWZmZXJfZGF0YShlLCBzaXplLCBlbmRpYW4pKTtcbiAgICAgICAgcmV0dXJuIGpvaW5fYXJyYXkoYnl0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMoZGF0YSwgc2l6ZSwgZW5kaWFuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBiaWdUb0J5dGVzKGRhdGEsIHNpemUsIGVuZGlhbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbnVtVG9CeXRlcyhkYXRhLCBzaXplLCBlbmRpYW4pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5Lm9mKGRhdGEgPyAxIDogMCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIGZvcm1hdDonICsgU3RyaW5nKHR5cGVvZiBkYXRhKSk7XG59XG5cbmNsYXNzIEJ1ZmYgZXh0ZW5kcyBVaW50OEFycmF5IHtcbiAgICBzdGF0aWMgeyB0aGlzLm51bSA9IG51bVRvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYmlnID0gYmlnVG9CdWZmOyB9XG4gICAgc3RhdGljIHsgdGhpcy5iaW4gPSBiaW5Ub0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLnJhdyA9IHJhd1RvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuc3RyID0gc3RyVG9CdWZmOyB9XG4gICAgc3RhdGljIHsgdGhpcy5oZXggPSBoZXhUb0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJ5dGVzID0gYnVmZmVyOyB9XG4gICAgc3RhdGljIHsgdGhpcy5qc29uID0ganNvblRvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYmFzZTY0ID0gYmFzZTY0VG9CdWZmOyB9XG4gICAgc3RhdGljIHsgdGhpcy5iNjR1cmwgPSBiNjR1cmxUb0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJlY2gzMiA9IGJlY2gzMlRvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYmVjaDMybSA9IGJlY2gzMm1Ub0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmI1OGNoayA9IGI1OGNoa1RvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuZW5jb2RlID0gc3RyVG9CeXRlczsgfVxuICAgIHN0YXRpYyB7IHRoaXMuZGVjb2RlID0gYnl0ZXNUb1N0cjsgfVxuICAgIHN0YXRpYyB7IHRoaXMucGFyc2UgPSBwYXJzZV9kYXRhOyB9XG4gICAgc3RhdGljIHsgdGhpcy5pc19ieXRlcyA9IGlzX2J5dGVzOyB9XG4gICAgc3RhdGljIHsgdGhpcy5pc19oZXggPSBpc19oZXg7IH1cbiAgICBzdGF0aWMgcmFuZG9tKHNpemUgPSAzMikge1xuICAgICAgICBjb25zdCByYW5kID0gcmFuZG9tKHNpemUpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYocmFuZCwgc2l6ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBub3coc2l6ZSA9IDQpIHtcbiAgICAgICAgY29uc3Qgc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKHN0YW1wLCBzaXplKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZiAmJlxuICAgICAgICAgICAgc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJfZGF0YShkYXRhLCBzaXplLCBlbmRpYW4pO1xuICAgICAgICBzdXBlcihidWZmZXIpO1xuICAgIH1cbiAgICBnZXQgYXJyKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXNdO1xuICAgIH1cbiAgICBnZXQgbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b19udW0oKTtcbiAgICB9XG4gICAgZ2V0IGJpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9fYmlnKCk7XG4gICAgfVxuICAgIGdldCBzdHIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX3N0cigpO1xuICAgIH1cbiAgICBnZXQgaGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b19oZXgoKTtcbiAgICB9XG4gICAgZ2V0IHJhdygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMpO1xuICAgIH1cbiAgICBnZXQgYmluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b19iaW4oKTtcbiAgICB9XG4gICAgZ2V0IGI1OGNoaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9fYjU4Y2hrKCk7XG4gICAgfVxuICAgIGdldCBiYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX2Jhc2U2NCgpO1xuICAgIH1cbiAgICBnZXQgYjY0dXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b19iNjR1cmwoKTtcbiAgICB9XG4gICAgZ2V0IGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9faGFzaCgpO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX2hhc2goKS5oZXg7XG4gICAgfVxuICAgIGdldCBzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKHRoaXMpO1xuICAgIH1cbiAgICB0b19udW0oZW5kaWFuID0gJ2JlJykge1xuICAgICAgICBjb25zdCBieXRlcyA9IChlbmRpYW4gPT09ICdiZScpXG4gICAgICAgICAgICA/IHRoaXMucmV2ZXJzZSgpXG4gICAgICAgICAgICA6IHRoaXM7XG4gICAgICAgIHJldHVybiBieXRlc1RvTnVtKGJ5dGVzKTtcbiAgICB9XG4gICAgdG9fYmlnKGVuZGlhbiA9ICdiZScpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSAoZW5kaWFuID09PSAnYmUnKVxuICAgICAgICAgICAgPyB0aGlzLnJldmVyc2UoKVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0JpZyhieXRlcyk7XG4gICAgfVxuICAgIHRvX2JpbigpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9CaW4odGhpcyk7XG4gICAgfVxuICAgIHRvX2hhc2goKSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IHNoYTI1Nih0aGlzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGRpZ2VzdCk7XG4gICAgfVxuICAgIHRvX2pzb24ocmV2aXZlcikge1xuICAgICAgICBpZiAocmV2aXZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXZpdmVyID0gYmlnaW50X3Jldml2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cih0aGlzKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLCByZXZpdmVyKTtcbiAgICB9XG4gICAgdG9fYmVjaDMyKHByZWZpeCwgbGltaXQpIHtcbiAgICAgICAgY29uc3QgeyBlbmNvZGUsIHRvX3dvcmRzIH0gPSBFbmNvZGVyLmJlY2gzMjtcbiAgICAgICAgY29uc3Qgd29yZHMgPSB0b193b3Jkcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCk7XG4gICAgfVxuICAgIHRvX2JlY2gzMm0ocHJlZml4LCBsaW1pdCkge1xuICAgICAgICBjb25zdCB7IGVuY29kZSwgdG9fd29yZHMgfSA9IEVuY29kZXIuYmVjaDMybTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSB0b193b3Jkcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCk7XG4gICAgfVxuICAgIHRvX3N0cigpIHsgcmV0dXJuIGJ5dGVzVG9TdHIodGhpcyk7IH1cbiAgICB0b19oZXgoKSB7IHJldHVybiBieXRlc1RvSGV4KHRoaXMpOyB9XG4gICAgdG9fYnl0ZXMoKSB7IHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzKTsgfVxuICAgIHRvX2I1OGNoaygpIHsgcmV0dXJuIEVuY29kZXIuYjU4Y2hrLmVuY29kZSh0aGlzKTsgfVxuICAgIHRvX2Jhc2U2NCgpIHsgcmV0dXJuIEVuY29kZXIuYmFzZTY0LmVuY29kZSh0aGlzKTsgfVxuICAgIHRvX2I2NHVybCgpIHsgcmV0dXJuIEVuY29kZXIuYjY0dXJsLmVuY29kZSh0aGlzKTsgfVxuICAgIGFwcGVuZChkYXRhKSB7XG4gICAgICAgIHJldHVybiBCdWZmLmpvaW4oW3RoaXMsIEJ1ZmYuYnl0ZXMoZGF0YSldKTtcbiAgICB9XG4gICAgcHJlcGVuZChkYXRhKSB7XG4gICAgICAgIHJldHVybiBCdWZmLmpvaW4oW0J1ZmYuYnl0ZXMoZGF0YSksIHRoaXNdKTtcbiAgICB9XG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcykucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYoYXJyKTtcbiAgICB9XG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSh0aGlzKS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGFycik7XG4gICAgfVxuICAgIHNldChhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuc2V0KGFycmF5LCBvZmZzZXQpO1xuICAgIH1cbiAgICBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMpLnN1YmFycmF5KGJlZ2luLCBlbmQpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYoYXJyKTtcbiAgICB9XG4gICAgd3JpdGUoYnl0ZXMsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBiID0gQnVmZi5ieXRlcyhieXRlcyk7XG4gICAgICAgIHRoaXMuc2V0KGIsIG9mZnNldCk7XG4gICAgfVxuICAgIGFkZF92YXJpbnQoZW5kaWFuKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBCdWZmLmNhbGNfdmFyaW50KHRoaXMubGVuZ3RoLCBlbmRpYW4pO1xuICAgICAgICByZXR1cm4gQnVmZi5qb2luKFtzaXplLCB0aGlzXSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKFVpbnQ4QXJyYXkuZnJvbShkYXRhKSk7XG4gICAgfVxuICAgIHN0YXRpYyBvZiguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZihVaW50OEFycmF5Lm9mKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgc3RhdGljIGpvaW4oYXJyKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyLm1hcChlID0+IEJ1ZmYuYnl0ZXMoZSkpO1xuICAgICAgICBjb25zdCBqb2luZWQgPSBqb2luX2FycmF5KGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGpvaW5lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBzb3J0KGFyciwgc2l6ZSkge1xuICAgICAgICBjb25zdCBoZXggPSBhcnIubWFwKGUgPT4gYnVmZmVyKGUsIHNpemUpLmhleCk7XG4gICAgICAgIGhleC5zb3J0KCk7XG4gICAgICAgIHJldHVybiBoZXgubWFwKGUgPT4gQnVmZi5oZXgoZSwgc2l6ZSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY2FsY192YXJpbnQobnVtLCBlbmRpYW4pIHtcbiAgICAgICAgaWYgKG51bSA8IDB4RkQpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmLm51bShudW0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmLm9mKDB4RkQsIC4uLkJ1ZmYubnVtKG51bSwgMiwgZW5kaWFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobnVtIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmLm9mKDB4RkUsIC4uLkJ1ZmYubnVtKG51bSwgNCwgZW5kaWFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQmlnSW50KG51bSkgPCAweDEwMDAwMDAwMDAwMDAwMDAwbikge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmYub2YoMHhGRiwgLi4uQnVmZi5udW0obnVtLCA4LCBlbmRpYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgaXMgdG9vIGxhcmdlOiAke251bX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG51bVRvQnVmZihudW1iZXIsIHNpemUsIGVuZGlhbikge1xuICAgIHJldHVybiBuZXcgQnVmZihudW1iZXIsIHNpemUsIGVuZGlhbik7XG59XG5mdW5jdGlvbiBiaW5Ub0J1ZmYoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKGJpblRvQnl0ZXMoZGF0YSksIHNpemUsIGVuZGlhbik7XG59XG5mdW5jdGlvbiBiaWdUb0J1ZmYoYmlnaW50LCBzaXplLCBlbmRpYW4pIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYoYmlnaW50LCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24gcmF3VG9CdWZmKGRhdGEsIHNpemUsIGVuZGlhbikge1xuICAgIHJldHVybiBuZXcgQnVmZihkYXRhLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24gc3RyVG9CdWZmKGRhdGEsIHNpemUsIGVuZGlhbikge1xuICAgIHJldHVybiBuZXcgQnVmZihzdHJUb0J5dGVzKGRhdGEpLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24gaGV4VG9CdWZmKGRhdGEsIHNpemUsIGVuZGlhbikge1xuICAgIHJldHVybiBuZXcgQnVmZihkYXRhLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24ganNvblRvQnVmZihkYXRhLCByZXBsYWNlcikge1xuICAgIGlmIChyZXBsYWNlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcGxhY2VyID0gYmlnaW50X3JlcGxhY2VyO1xuICAgIH1cbiAgICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeShkYXRhLCByZXBsYWNlcik7XG4gICAgcmV0dXJuIG5ldyBCdWZmKHN0clRvQnl0ZXMoc3RyKSk7XG59XG5mdW5jdGlvbiBiYXNlNjRUb0J1ZmYoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQnVmZihFbmNvZGVyLmJhc2U2NC5kZWNvZGUoZGF0YSkpO1xufVxuZnVuY3Rpb24gYjY0dXJsVG9CdWZmKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYoRW5jb2Rlci5iNjR1cmwuZGVjb2RlKGRhdGEpKTtcbn1cbmZ1bmN0aW9uIGJlY2gzMlRvQnVmZihkYXRhLCBsaW1pdCwgY2hrX3ByZWZpeCkge1xuICAgIGNvbnN0IHsgZGVjb2RlLCB0b19ieXRlcyB9ID0gRW5jb2Rlci5iZWNoMzI7XG4gICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoZGF0YSwgbGltaXQpO1xuICAgIGNvbnN0IGJ5dGVzID0gdG9fYnl0ZXMod29yZHMpO1xuICAgIGlmICh0eXBlb2YgY2hrX3ByZWZpeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaXNfcHJlZml4KHByZWZpeCwgY2hrX3ByZWZpeCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZihieXRlcyk7XG59XG5mdW5jdGlvbiBiZWNoMzJtVG9CdWZmKGRhdGEsIGxpbWl0LCBjaGtfcHJlZml4KSB7XG4gICAgY29uc3QgeyBkZWNvZGUsIHRvX2J5dGVzIH0gPSBFbmNvZGVyLmJlY2gzMm07XG4gICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoZGF0YSwgbGltaXQpO1xuICAgIGNvbnN0IGJ5dGVzID0gdG9fYnl0ZXMod29yZHMpO1xuICAgIGlmICh0eXBlb2YgY2hrX3ByZWZpeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaXNfcHJlZml4KHByZWZpeCwgY2hrX3ByZWZpeCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZihieXRlcyk7XG59XG5mdW5jdGlvbiBiNThjaGtUb0J1ZmYoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQnVmZihFbmNvZGVyLmI1OGNoay5kZWNvZGUoZGF0YSkpO1xufVxuZnVuY3Rpb24gcGFyc2VfZGF0YShkYXRhX2Jsb2IsIGNodW5rX3NpemUsIHRvdGFsX3NpemUpIHtcbiAgICBjb25zdCBieXRlcyA9IGJ1ZmZlcl9kYXRhKGRhdGFfYmxvYik7XG4gICAgY29uc3QgY2h1bmtzID0gcGFyc2VfZGF0YSQxKGJ5dGVzLCBjaHVua19zaXplLCB0b3RhbF9zaXplKTtcbiAgICByZXR1cm4gY2h1bmtzLm1hcChlID0+IEJ1ZmYuYnl0ZXMoZSkpO1xufVxuY2xhc3MgU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmYuYnl0ZXMoZGF0YSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIHBlZWsoc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSA+IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaXplIGdyZWF0ZXIgdGhhbiBzdHJlYW06ICR7c2l6ZX0gPiAke3RoaXMuc2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYodGhpcy5kYXRhLnNsaWNlKDAsIHNpemUpKTtcbiAgICB9XG4gICAgcmVhZChzaXplKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5wZWVrKHNpemUpO1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc2xpY2Uoc2l6ZSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgcmVhZF92YXJpbnQoZW5kaWFuKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IHRoaXMucmVhZCgxKS5udW07XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgY2FzZSAobnVtID49IDAgJiYgbnVtIDwgMHhGRCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICAgIGNhc2UgKG51bSA9PT0gMHhGRCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZCgyKS50b19udW0oZW5kaWFuKTtcbiAgICAgICAgICAgIGNhc2UgKG51bSA9PT0gMHhGRSk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZCg0KS50b19udW0oZW5kaWFuKTtcbiAgICAgICAgICAgIGNhc2UgKG51bSA9PT0gMHhGRik6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZCg4KS50b19udW0oZW5kaWFuKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYXJpbnQgaXMgb3V0IG9mIHJhbmdlOiAke251bX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1ZmZlcihieXRlcywgc2l6ZSwgZW5kKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKGJ5dGVzLCBzaXplLCBlbmQpO1xufVxuXG5leHBvcnQgeyBCdWZmLCBFbmNvZGVyLCBIZXgsIFN0cmVhbSwgVHh0LCBhc3NlcnQsIGJ1ZmZlciwgdXRpbHMgYXMgdXRpbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   is_hex: () => (/* binding */ is_hex),\n/* harmony export */   is_json: () => (/* binding */ is_json),\n/* harmony export */   is_prefix: () => (/* binding */ is_prefix),\n/* harmony export */   is_safe_num: () => (/* binding */ is_safe_num),\n/* harmony export */   within_size: () => (/* binding */ within_size)\n/* harmony export */ });\nfunction within_size(data, size) {\n    if (data.length > size) {\n        throw new TypeError(`Data is larger than array size: ${data.length} > ${size}`);\n    }\n}\nfunction is_hex(hex) {\n    if (hex.match(/[^a-fA-f0-9]/) !== null) {\n        throw new TypeError('Invalid characters in hex string: ' + hex);\n    }\n    if (hex.length % 2 !== 0) {\n        throw new Error(`Length of hex string is invalid: ${hex.length}`);\n    }\n}\nfunction is_json(str) {\n    try {\n        JSON.parse(str);\n    }\n    catch {\n        throw new TypeError('JSON string is invalid!');\n    }\n}\nfunction is_safe_num(num) {\n    if (num > Number.MAX_SAFE_INTEGER) {\n        throw new TypeError('Number exceeds safe bounds!');\n    }\n}\nfunction is_prefix(actual, target) {\n    if (actual !== target) {\n        throw new TypeError(`Bech32 prefix does not match: ${actual} !== ${target}`);\n    }\n}\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFPO0FBQ1A7QUFDQSwrREFBK0QsYUFBYSxJQUFJLEtBQUs7QUFDckY7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNkRBQTZELFFBQVEsTUFBTSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2J1ZmYvZGlzdC9hc3NlcnQuanM/ZTQzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gd2l0aGluX3NpemUoZGF0YSwgc2l6ZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IHNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRGF0YSBpcyBsYXJnZXIgdGhhbiBhcnJheSBzaXplOiAke2RhdGEubGVuZ3RofSA+ICR7c2l6ZX1gKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNfaGV4KGhleCkge1xuICAgIGlmIChoZXgubWF0Y2goL1teYS1mQS1mMC05XS8pICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVycyBpbiBoZXggc3RyaW5nOiAnICsgaGV4KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTGVuZ3RoIG9mIGhleCBzdHJpbmcgaXMgaW52YWxpZDogJHtoZXgubGVuZ3RofWApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc19qc29uKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIEpTT04ucGFyc2Uoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKU09OIHN0cmluZyBpcyBpbnZhbGlkIScpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc19zYWZlX251bShudW0pIHtcbiAgICBpZiAobnVtID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTnVtYmVyIGV4Y2VlZHMgc2FmZSBib3VuZHMhJyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzX3ByZWZpeChhY3R1YWwsIHRhcmdldCkge1xuICAgIGlmIChhY3R1YWwgIT09IHRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBCZWNoMzIgcHJlZml4IGRvZXMgbm90IG1hdGNoOiAke2FjdHVhbH0gIT09ICR7dGFyZ2V0fWApO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/buff.js":
/*!*************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/buff.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Buff: () => (/* binding */ Buff),\n/* harmony export */   Stream: () => (/* binding */ Stream),\n/* harmony export */   buffer: () => (/* binding */ buffer)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/assert.js\");\n/* harmony import */ var _encode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encode.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/encode.js\");\n/* harmony import */ var _format_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./format/index.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/utils.js\");\n\n\n\n\n\n\nclass Buff extends Uint8Array {\n    static { this.num = numToBuff; }\n    static { this.big = bigToBuff; }\n    static { this.bin = binToBuff; }\n    static { this.raw = rawToBuff; }\n    static { this.str = strToBuff; }\n    static { this.hex = hexToBuff; }\n    static { this.bytes = buffer; }\n    static { this.json = jsonToBuff; }\n    static { this.base64 = base64ToBuff; }\n    static { this.b64url = b64urlToBuff; }\n    static { this.bech32 = bech32ToBuff; }\n    static { this.bech32m = bech32mToBuff; }\n    static { this.b58chk = b58chkToBuff; }\n    static { this.encode = _format_index_js__WEBPACK_IMPORTED_MODULE_2__.strToBytes; }\n    static { this.decode = _format_index_js__WEBPACK_IMPORTED_MODULE_2__.bytesToStr; }\n    static { this.parse = parse_data; }\n    static { this.is_bytes = _utils_js__WEBPACK_IMPORTED_MODULE_3__.is_bytes; }\n    static { this.is_hex = _utils_js__WEBPACK_IMPORTED_MODULE_3__.is_hex; }\n    static { this.is_equal = is_equal; }\n    static random(size = 32) {\n        const rand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(size);\n        return new Buff(rand, size);\n    }\n    static now(size = 4) {\n        const stamp = Math.floor(Date.now() / 1000);\n        return new Buff(stamp, size);\n    }\n    constructor(data, size, endian) {\n        if (data instanceof Buff &&\n            size === undefined) {\n            return data;\n        }\n        const buffer = _format_index_js__WEBPACK_IMPORTED_MODULE_2__.buffer_data(data, size, endian);\n        super(buffer);\n    }\n    get arr() {\n        return [...this];\n    }\n    get num() {\n        return this.to_num();\n    }\n    get big() {\n        return this.to_big();\n    }\n    get str() {\n        return this.to_str();\n    }\n    get hex() {\n        return this.to_hex();\n    }\n    get raw() {\n        return new Uint8Array(this);\n    }\n    get bin() {\n        return this.to_bin();\n    }\n    get b58chk() {\n        return this.to_b58chk();\n    }\n    get base64() {\n        return this.to_base64();\n    }\n    get b64url() {\n        return this.to_b64url();\n    }\n    get digest() {\n        return this.to_hash();\n    }\n    get id() {\n        return this.to_hash().hex;\n    }\n    get stream() {\n        return new Stream(this);\n    }\n    to_num(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return _format_index_js__WEBPACK_IMPORTED_MODULE_2__.bytesToNum(bytes);\n    }\n    to_big(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return _format_index_js__WEBPACK_IMPORTED_MODULE_2__.bytesToBig(bytes);\n    }\n    to_bin() {\n        return _format_index_js__WEBPACK_IMPORTED_MODULE_2__.bytesToBin(this);\n    }\n    to_hash() {\n        const digest = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__.sha256)(this);\n        return new Buff(digest);\n    }\n    to_json(reviver) {\n        if (reviver === undefined) {\n            reviver = _utils_js__WEBPACK_IMPORTED_MODULE_3__.bigint_reviver;\n        }\n        const str = _format_index_js__WEBPACK_IMPORTED_MODULE_2__.bytesToStr(this);\n        return JSON.parse(str, reviver);\n    }\n    to_bech32(prefix, limit) {\n        const { encode, to_words } = _encode_js__WEBPACK_IMPORTED_MODULE_1__.Bech32;\n        const words = to_words(this);\n        return encode(prefix, words, limit);\n    }\n    to_bech32m(prefix, limit) {\n        const { encode, to_words } = _encode_js__WEBPACK_IMPORTED_MODULE_1__.Bech32m;\n        const words = to_words(this);\n        return encode(prefix, words, limit);\n    }\n    to_str() { return _format_index_js__WEBPACK_IMPORTED_MODULE_2__.bytesToStr(this); }\n    to_hex() { return _format_index_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex(this); }\n    to_bytes() { return new Uint8Array(this); }\n    to_b58chk() { return _encode_js__WEBPACK_IMPORTED_MODULE_1__.B58chk.encode(this); }\n    to_base64() { return _encode_js__WEBPACK_IMPORTED_MODULE_1__.Base64.encode(this); }\n    to_b64url() { return _encode_js__WEBPACK_IMPORTED_MODULE_1__.B64url.encode(this); }\n    append(data) {\n        return Buff.join([this, Buff.bytes(data)]);\n    }\n    equals(data) {\n        return buffer(data).hex === this.hex;\n    }\n    prepend(data) {\n        return Buff.join([Buff.bytes(data), this]);\n    }\n    reverse() {\n        const arr = new Uint8Array(this).reverse();\n        return new Buff(arr);\n    }\n    slice(start, end) {\n        const arr = new Uint8Array(this).slice(start, end);\n        return new Buff(arr);\n    }\n    set(array, offset) {\n        this.set(array, offset);\n    }\n    subarray(begin, end) {\n        const arr = new Uint8Array(this).subarray(begin, end);\n        return new Buff(arr);\n    }\n    write(bytes, offset) {\n        const b = Buff.bytes(bytes);\n        this.set(b, offset);\n    }\n    add_varint(endian) {\n        const size = Buff.calc_varint(this.length, endian);\n        return Buff.join([size, this]);\n    }\n    toJSON() {\n        return this.hex;\n    }\n    toString() {\n        return this.hex;\n    }\n    static from(data) {\n        return new Buff(Uint8Array.from(data));\n    }\n    static of(...args) {\n        return new Buff(Uint8Array.of(...args));\n    }\n    static join(arr) {\n        const bytes = arr.map(e => Buff.bytes(e));\n        const joined = _utils_js__WEBPACK_IMPORTED_MODULE_3__.join_array(bytes);\n        return new Buff(joined);\n    }\n    static sort(arr, size) {\n        const hex = arr.map(e => buffer(e, size).hex);\n        hex.sort();\n        return hex.map(e => Buff.hex(e, size));\n    }\n    static calc_varint(num, endian) {\n        if (num < 0xFD) {\n            return Buff.num(num, 1);\n        }\n        else if (num < 0x10000) {\n            return Buff.of(0xFD, ...Buff.num(num, 2, endian));\n        }\n        else if (num < 0x100000000) {\n            return Buff.of(0xFE, ...Buff.num(num, 4, endian));\n        }\n        else if (BigInt(num) < 0x10000000000000000n) {\n            return Buff.of(0xFF, ...Buff.num(num, 8, endian));\n        }\n        else {\n            throw new Error(`Value is too large: ${num}`);\n        }\n    }\n}\nfunction numToBuff(number, size, endian) {\n    return new Buff(number, size, endian);\n}\nfunction binToBuff(data, size, endian) {\n    return new Buff(_format_index_js__WEBPACK_IMPORTED_MODULE_2__.binToBytes(data), size, endian);\n}\nfunction bigToBuff(bigint, size, endian) {\n    return new Buff(bigint, size, endian);\n}\nfunction rawToBuff(data, size, endian) {\n    return new Buff(data, size, endian);\n}\nfunction strToBuff(data, size, endian) {\n    return new Buff(_format_index_js__WEBPACK_IMPORTED_MODULE_2__.strToBytes(data), size, endian);\n}\nfunction hexToBuff(data, size, endian) {\n    return new Buff(data, size, endian);\n}\nfunction jsonToBuff(data, replacer) {\n    if (replacer === undefined) {\n        replacer = _utils_js__WEBPACK_IMPORTED_MODULE_3__.bigint_replacer;\n    }\n    const str = JSON.stringify(data, replacer);\n    return new Buff(_format_index_js__WEBPACK_IMPORTED_MODULE_2__.strToBytes(str));\n}\nfunction base64ToBuff(data) {\n    return new Buff(_encode_js__WEBPACK_IMPORTED_MODULE_1__.Base64.decode(data));\n}\nfunction b64urlToBuff(data) {\n    return new Buff(_encode_js__WEBPACK_IMPORTED_MODULE_1__.B64url.decode(data));\n}\nfunction bech32ToBuff(data, limit, chk_prefix) {\n    const { decode, to_bytes } = _encode_js__WEBPACK_IMPORTED_MODULE_1__.Bech32;\n    const { prefix, words } = decode(data, limit);\n    const bytes = to_bytes(words);\n    if (typeof chk_prefix === 'string') {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__.is_prefix(prefix, chk_prefix);\n    }\n    return new Buff(bytes);\n}\nfunction bech32mToBuff(data, limit, chk_prefix) {\n    const { decode, to_bytes } = _encode_js__WEBPACK_IMPORTED_MODULE_1__.Bech32m;\n    const { prefix, words } = decode(data, limit);\n    const bytes = to_bytes(words);\n    if (typeof chk_prefix === 'string') {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__.is_prefix(prefix, chk_prefix);\n    }\n    return new Buff(bytes);\n}\nfunction b58chkToBuff(data) {\n    return new Buff(_encode_js__WEBPACK_IMPORTED_MODULE_1__.B58chk.decode(data));\n}\nfunction parse_data(data_blob, chunk_size, total_size) {\n    const bytes = _format_index_js__WEBPACK_IMPORTED_MODULE_2__.buffer_data(data_blob);\n    const chunks = _utils_js__WEBPACK_IMPORTED_MODULE_3__.parse_data(bytes, chunk_size, total_size);\n    return chunks.map(e => Buff.bytes(e));\n}\nfunction is_equal(a, b) {\n    return new Buff(a).hex === new Buff(b).hex;\n}\nfunction buffer(bytes, size, end) {\n    return new Buff(bytes, size, end);\n}\nclass Stream {\n    constructor(data) {\n        this.data = Buff.bytes(data);\n        this.size = this.data.length;\n    }\n    peek(size) {\n        if (size > this.size) {\n            throw new Error(`Size greater than stream: ${size} > ${this.size}`);\n        }\n        return new Buff(this.data.slice(0, size));\n    }\n    read(size) {\n        const chunk = this.peek(size);\n        this.data = this.data.slice(size);\n        this.size = this.data.length;\n        return chunk;\n    }\n    read_varint(endian) {\n        const num = this.read(1).num;\n        switch (true) {\n            case (num >= 0 && num < 0xFD):\n                return num;\n            case (num === 0xFD):\n                return this.read(2).to_num(endian);\n            case (num === 0xFE):\n                return this.read(4).to_num(endian);\n            case (num === 0xFF):\n                return this.read(8).to_num(endian);\n            default:\n                throw new Error(`Varint is out of range: ${num}`);\n        }\n    }\n}\n//# sourceMappingURL=buff.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2J1ZmYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ0k7QUFDWjtBQUNDO0FBQ0U7QUFDTjtBQUM1QjtBQUNQLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhLGNBQWMsd0RBQWM7QUFDekMsYUFBYSxjQUFjLHdEQUFjO0FBQ3pDLGFBQWE7QUFDYixhQUFhLGdCQUFnQiwrQ0FBYTtBQUMxQyxhQUFhLGNBQWMsNkNBQVc7QUFDdEMsYUFBYTtBQUNiO0FBQ0EscUJBQXFCLGdFQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBYztBQUM3QjtBQUNBO0FBQ0EsZUFBZSx3REFBYztBQUM3QjtBQUNBO0FBQ0EsdUJBQXVCLDREQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFtQjtBQUN6QztBQUNBLG9CQUFvQix3REFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CLEVBQUUsOENBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CLEVBQUUsK0NBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPLHdEQUFjO0FBQ3BDLGVBQWUsT0FBTyx3REFBYztBQUNwQyxpQkFBaUI7QUFDakIsa0JBQWtCLE9BQU8sOENBQWM7QUFDdkMsa0JBQWtCLE9BQU8sOENBQWM7QUFDdkMsa0JBQWtCLE9BQU8sOENBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQW9CO0FBQ3ZDO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQWM7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBYztBQUNsQztBQUNBO0FBQ0Esb0JBQW9CLDhDQUFjO0FBQ2xDO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQixFQUFFLDhDQUFjO0FBQy9DLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQSxRQUFRLGlEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CLEVBQUUsK0NBQWU7QUFDaEQsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBLFFBQVEsaURBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFjO0FBQ2xDO0FBQ0E7QUFDQSxrQkFBa0IseURBQWU7QUFDakMsbUJBQW1CLGlEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNLElBQUksVUFBVTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsSUFBSTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2J1ZmYvZGlzdC9idWZmLmpzPzA1NWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgKiBhcyBlbmNvZGVyIGZyb20gJy4vZW5jb2RlLmpzJztcbmltcG9ydCAqIGFzIGZtdCBmcm9tICcuL2Zvcm1hdC9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIEJ1ZmYgZXh0ZW5kcyBVaW50OEFycmF5IHtcbiAgICBzdGF0aWMgeyB0aGlzLm51bSA9IG51bVRvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYmlnID0gYmlnVG9CdWZmOyB9XG4gICAgc3RhdGljIHsgdGhpcy5iaW4gPSBiaW5Ub0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLnJhdyA9IHJhd1RvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuc3RyID0gc3RyVG9CdWZmOyB9XG4gICAgc3RhdGljIHsgdGhpcy5oZXggPSBoZXhUb0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJ5dGVzID0gYnVmZmVyOyB9XG4gICAgc3RhdGljIHsgdGhpcy5qc29uID0ganNvblRvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYmFzZTY0ID0gYmFzZTY0VG9CdWZmOyB9XG4gICAgc3RhdGljIHsgdGhpcy5iNjR1cmwgPSBiNjR1cmxUb0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJlY2gzMiA9IGJlY2gzMlRvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYmVjaDMybSA9IGJlY2gzMm1Ub0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmI1OGNoayA9IGI1OGNoa1RvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuZW5jb2RlID0gZm10LnN0clRvQnl0ZXM7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmRlY29kZSA9IGZtdC5ieXRlc1RvU3RyOyB9XG4gICAgc3RhdGljIHsgdGhpcy5wYXJzZSA9IHBhcnNlX2RhdGE7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmlzX2J5dGVzID0gdXRpbC5pc19ieXRlczsgfVxuICAgIHN0YXRpYyB7IHRoaXMuaXNfaGV4ID0gdXRpbC5pc19oZXg7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmlzX2VxdWFsID0gaXNfZXF1YWw7IH1cbiAgICBzdGF0aWMgcmFuZG9tKHNpemUgPSAzMikge1xuICAgICAgICBjb25zdCByYW5kID0gcmFuZG9tQnl0ZXMoc2l6ZSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZihyYW5kLCBzaXplKTtcbiAgICB9XG4gICAgc3RhdGljIG5vdyhzaXplID0gNCkge1xuICAgICAgICBjb25zdCBzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYoc3RhbXAsIHNpemUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBzaXplLCBlbmRpYW4pIHtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCdWZmICYmXG4gICAgICAgICAgICBzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGZtdC5idWZmZXJfZGF0YShkYXRhLCBzaXplLCBlbmRpYW4pO1xuICAgICAgICBzdXBlcihidWZmZXIpO1xuICAgIH1cbiAgICBnZXQgYXJyKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXNdO1xuICAgIH1cbiAgICBnZXQgbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b19udW0oKTtcbiAgICB9XG4gICAgZ2V0IGJpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9fYmlnKCk7XG4gICAgfVxuICAgIGdldCBzdHIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX3N0cigpO1xuICAgIH1cbiAgICBnZXQgaGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b19oZXgoKTtcbiAgICB9XG4gICAgZ2V0IHJhdygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMpO1xuICAgIH1cbiAgICBnZXQgYmluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b19iaW4oKTtcbiAgICB9XG4gICAgZ2V0IGI1OGNoaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9fYjU4Y2hrKCk7XG4gICAgfVxuICAgIGdldCBiYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX2Jhc2U2NCgpO1xuICAgIH1cbiAgICBnZXQgYjY0dXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b19iNjR1cmwoKTtcbiAgICB9XG4gICAgZ2V0IGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9faGFzaCgpO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX2hhc2goKS5oZXg7XG4gICAgfVxuICAgIGdldCBzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKHRoaXMpO1xuICAgIH1cbiAgICB0b19udW0oZW5kaWFuID0gJ2JlJykge1xuICAgICAgICBjb25zdCBieXRlcyA9IChlbmRpYW4gPT09ICdiZScpXG4gICAgICAgICAgICA/IHRoaXMucmV2ZXJzZSgpXG4gICAgICAgICAgICA6IHRoaXM7XG4gICAgICAgIHJldHVybiBmbXQuYnl0ZXNUb051bShieXRlcyk7XG4gICAgfVxuICAgIHRvX2JpZyhlbmRpYW4gPSAnYmUnKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gKGVuZGlhbiA9PT0gJ2JlJylcbiAgICAgICAgICAgID8gdGhpcy5yZXZlcnNlKClcbiAgICAgICAgICAgIDogdGhpcztcbiAgICAgICAgcmV0dXJuIGZtdC5ieXRlc1RvQmlnKGJ5dGVzKTtcbiAgICB9XG4gICAgdG9fYmluKCkge1xuICAgICAgICByZXR1cm4gZm10LmJ5dGVzVG9CaW4odGhpcyk7XG4gICAgfVxuICAgIHRvX2hhc2goKSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IHNoYTI1Nih0aGlzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGRpZ2VzdCk7XG4gICAgfVxuICAgIHRvX2pzb24ocmV2aXZlcikge1xuICAgICAgICBpZiAocmV2aXZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXZpdmVyID0gdXRpbC5iaWdpbnRfcmV2aXZlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHIgPSBmbXQuYnl0ZXNUb1N0cih0aGlzKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLCByZXZpdmVyKTtcbiAgICB9XG4gICAgdG9fYmVjaDMyKHByZWZpeCwgbGltaXQpIHtcbiAgICAgICAgY29uc3QgeyBlbmNvZGUsIHRvX3dvcmRzIH0gPSBlbmNvZGVyLkJlY2gzMjtcbiAgICAgICAgY29uc3Qgd29yZHMgPSB0b193b3Jkcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCk7XG4gICAgfVxuICAgIHRvX2JlY2gzMm0ocHJlZml4LCBsaW1pdCkge1xuICAgICAgICBjb25zdCB7IGVuY29kZSwgdG9fd29yZHMgfSA9IGVuY29kZXIuQmVjaDMybTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSB0b193b3Jkcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCk7XG4gICAgfVxuICAgIHRvX3N0cigpIHsgcmV0dXJuIGZtdC5ieXRlc1RvU3RyKHRoaXMpOyB9XG4gICAgdG9faGV4KCkgeyByZXR1cm4gZm10LmJ5dGVzVG9IZXgodGhpcyk7IH1cbiAgICB0b19ieXRlcygpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMpOyB9XG4gICAgdG9fYjU4Y2hrKCkgeyByZXR1cm4gZW5jb2Rlci5CNThjaGsuZW5jb2RlKHRoaXMpOyB9XG4gICAgdG9fYmFzZTY0KCkgeyByZXR1cm4gZW5jb2Rlci5CYXNlNjQuZW5jb2RlKHRoaXMpOyB9XG4gICAgdG9fYjY0dXJsKCkgeyByZXR1cm4gZW5jb2Rlci5CNjR1cmwuZW5jb2RlKHRoaXMpOyB9XG4gICAgYXBwZW5kKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYuam9pbihbdGhpcywgQnVmZi5ieXRlcyhkYXRhKV0pO1xuICAgIH1cbiAgICBlcXVhbHMoZGF0YSkge1xuICAgICAgICByZXR1cm4gYnVmZmVyKGRhdGEpLmhleCA9PT0gdGhpcy5oZXg7XG4gICAgfVxuICAgIHByZXBlbmQoZGF0YSkge1xuICAgICAgICByZXR1cm4gQnVmZi5qb2luKFtCdWZmLmJ5dGVzKGRhdGEpLCB0aGlzXSk7XG4gICAgfVxuICAgIHJldmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMpLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGFycik7XG4gICAgfVxuICAgIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcykuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZihhcnIpO1xuICAgIH1cbiAgICBzZXQoYXJyYXksIG9mZnNldCkge1xuICAgICAgICB0aGlzLnNldChhcnJheSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSh0aGlzKS5zdWJhcnJheShiZWdpbiwgZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGFycik7XG4gICAgfVxuICAgIHdyaXRlKGJ5dGVzLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYiA9IEJ1ZmYuYnl0ZXMoYnl0ZXMpO1xuICAgICAgICB0aGlzLnNldChiLCBvZmZzZXQpO1xuICAgIH1cbiAgICBhZGRfdmFyaW50KGVuZGlhbikge1xuICAgICAgICBjb25zdCBzaXplID0gQnVmZi5jYWxjX3ZhcmludCh0aGlzLmxlbmd0aCwgZW5kaWFuKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmYuam9pbihbc2l6ZSwgdGhpc10pO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhleDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhleDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYoVWludDhBcnJheS5mcm9tKGRhdGEpKTtcbiAgICB9XG4gICAgc3RhdGljIG9mKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKFVpbnQ4QXJyYXkub2YoLi4uYXJncykpO1xuICAgIH1cbiAgICBzdGF0aWMgam9pbihhcnIpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnIubWFwKGUgPT4gQnVmZi5ieXRlcyhlKSk7XG4gICAgICAgIGNvbnN0IGpvaW5lZCA9IHV0aWwuam9pbl9hcnJheShieXRlcyk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZihqb2luZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgc29ydChhcnIsIHNpemUpIHtcbiAgICAgICAgY29uc3QgaGV4ID0gYXJyLm1hcChlID0+IGJ1ZmZlcihlLCBzaXplKS5oZXgpO1xuICAgICAgICBoZXguc29ydCgpO1xuICAgICAgICByZXR1cm4gaGV4Lm1hcChlID0+IEJ1ZmYuaGV4KGUsIHNpemUpKTtcbiAgICB9XG4gICAgc3RhdGljIGNhbGNfdmFyaW50KG51bSwgZW5kaWFuKSB7XG4gICAgICAgIGlmIChudW0gPCAweEZEKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZi5udW0obnVtLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW0gPCAweDEwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZi5vZigweEZELCAuLi5CdWZmLm51bShudW0sIDIsIGVuZGlhbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bSA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZi5vZigweEZFLCAuLi5CdWZmLm51bShudW0sIDQsIGVuZGlhbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJpZ0ludChudW0pIDwgMHgxMDAwMDAwMDAwMDAwMDAwMG4pIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmLm9mKDB4RkYsIC4uLkJ1ZmYubnVtKG51bSwgOCwgZW5kaWFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGlzIHRvbyBsYXJnZTogJHtudW19YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBudW1Ub0J1ZmYobnVtYmVyLCBzaXplLCBlbmRpYW4pIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYobnVtYmVyLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24gYmluVG9CdWZmKGRhdGEsIHNpemUsIGVuZGlhbikge1xuICAgIHJldHVybiBuZXcgQnVmZihmbXQuYmluVG9CeXRlcyhkYXRhKSwgc2l6ZSwgZW5kaWFuKTtcbn1cbmZ1bmN0aW9uIGJpZ1RvQnVmZihiaWdpbnQsIHNpemUsIGVuZGlhbikge1xuICAgIHJldHVybiBuZXcgQnVmZihiaWdpbnQsIHNpemUsIGVuZGlhbik7XG59XG5mdW5jdGlvbiByYXdUb0J1ZmYoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKGRhdGEsIHNpemUsIGVuZGlhbik7XG59XG5mdW5jdGlvbiBzdHJUb0J1ZmYoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKGZtdC5zdHJUb0J5dGVzKGRhdGEpLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24gaGV4VG9CdWZmKGRhdGEsIHNpemUsIGVuZGlhbikge1xuICAgIHJldHVybiBuZXcgQnVmZihkYXRhLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24ganNvblRvQnVmZihkYXRhLCByZXBsYWNlcikge1xuICAgIGlmIChyZXBsYWNlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcGxhY2VyID0gdXRpbC5iaWdpbnRfcmVwbGFjZXI7XG4gICAgfVxuICAgIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIHJlcGxhY2VyKTtcbiAgICByZXR1cm4gbmV3IEJ1ZmYoZm10LnN0clRvQnl0ZXMoc3RyKSk7XG59XG5mdW5jdGlvbiBiYXNlNjRUb0J1ZmYoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQnVmZihlbmNvZGVyLkJhc2U2NC5kZWNvZGUoZGF0YSkpO1xufVxuZnVuY3Rpb24gYjY0dXJsVG9CdWZmKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYoZW5jb2Rlci5CNjR1cmwuZGVjb2RlKGRhdGEpKTtcbn1cbmZ1bmN0aW9uIGJlY2gzMlRvQnVmZihkYXRhLCBsaW1pdCwgY2hrX3ByZWZpeCkge1xuICAgIGNvbnN0IHsgZGVjb2RlLCB0b19ieXRlcyB9ID0gZW5jb2Rlci5CZWNoMzI7XG4gICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoZGF0YSwgbGltaXQpO1xuICAgIGNvbnN0IGJ5dGVzID0gdG9fYnl0ZXMod29yZHMpO1xuICAgIGlmICh0eXBlb2YgY2hrX3ByZWZpeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXNzZXJ0LmlzX3ByZWZpeChwcmVmaXgsIGNoa19wcmVmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJ1ZmYoYnl0ZXMpO1xufVxuZnVuY3Rpb24gYmVjaDMybVRvQnVmZihkYXRhLCBsaW1pdCwgY2hrX3ByZWZpeCkge1xuICAgIGNvbnN0IHsgZGVjb2RlLCB0b19ieXRlcyB9ID0gZW5jb2Rlci5CZWNoMzJtO1xuICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKGRhdGEsIGxpbWl0KTtcbiAgICBjb25zdCBieXRlcyA9IHRvX2J5dGVzKHdvcmRzKTtcbiAgICBpZiAodHlwZW9mIGNoa19wcmVmaXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFzc2VydC5pc19wcmVmaXgocHJlZml4LCBjaGtfcHJlZml4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGI1OGNoa1RvQnVmZihkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKGVuY29kZXIuQjU4Y2hrLmRlY29kZShkYXRhKSk7XG59XG5mdW5jdGlvbiBwYXJzZV9kYXRhKGRhdGFfYmxvYiwgY2h1bmtfc2l6ZSwgdG90YWxfc2l6ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZm10LmJ1ZmZlcl9kYXRhKGRhdGFfYmxvYik7XG4gICAgY29uc3QgY2h1bmtzID0gdXRpbC5wYXJzZV9kYXRhKGJ5dGVzLCBjaHVua19zaXplLCB0b3RhbF9zaXplKTtcbiAgICByZXR1cm4gY2h1bmtzLm1hcChlID0+IEJ1ZmYuYnl0ZXMoZSkpO1xufVxuZnVuY3Rpb24gaXNfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBuZXcgQnVmZihhKS5oZXggPT09IG5ldyBCdWZmKGIpLmhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoYnl0ZXMsIHNpemUsIGVuZCkge1xuICAgIHJldHVybiBuZXcgQnVmZihieXRlcywgc2l6ZSwgZW5kKTtcbn1cbmV4cG9ydCBjbGFzcyBTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZi5ieXRlcyhkYXRhKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgcGVlayhzaXplKSB7XG4gICAgICAgIGlmIChzaXplID4gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpemUgZ3JlYXRlciB0aGFuIHN0cmVhbTogJHtzaXplfSA+ICR7dGhpcy5zaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnVmZih0aGlzLmRhdGEuc2xpY2UoMCwgc2l6ZSkpO1xuICAgIH1cbiAgICByZWFkKHNpemUpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLnBlZWsoc2l6ZSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zbGljZShzaXplKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICByZWFkX3ZhcmludChlbmRpYW4pIHtcbiAgICAgICAgY29uc3QgbnVtID0gdGhpcy5yZWFkKDEpLm51bTtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIChudW0gPj0gMCAmJiBudW0gPCAweEZEKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgICAgY2FzZSAobnVtID09PSAweEZEKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkKDIpLnRvX251bShlbmRpYW4pO1xuICAgICAgICAgICAgY2FzZSAobnVtID09PSAweEZFKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkKDQpLnRvX251bShlbmRpYW4pO1xuICAgICAgICAgICAgY2FzZSAobnVtID09PSAweEZGKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkKDgpLnRvX251bShlbmRpYW4pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhcmludCBpcyBvdXQgb2YgcmFuZ2U6ICR7bnVtfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/buff.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/encode.js":
/*!***************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/encode.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   B58chk: () => (/* binding */ B58chk),\n/* harmony export */   B64url: () => (/* binding */ B64url),\n/* harmony export */   Base64: () => (/* binding */ Base64),\n/* harmony export */   Bech32: () => (/* binding */ Bech32),\n/* harmony export */   Bech32m: () => (/* binding */ Bech32m),\n/* harmony export */   Hex: () => (/* binding */ Hex),\n/* harmony export */   Txt: () => (/* binding */ Txt)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _format_str_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format/str.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/str.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@cmdcode/buff/node_modules/@scure/base/lib/esm/index.js\");\n\n\n\nconst Hex = {\n    encode: _format_str_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex,\n    decode: _format_str_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes\n};\nconst Txt = {\n    encode: _format_str_js__WEBPACK_IMPORTED_MODULE_0__.strToBytes,\n    decode: _format_str_js__WEBPACK_IMPORTED_MODULE_0__.bytesToStr\n};\nconst B58chk = {\n    encode: (data) => (0,_scure_base__WEBPACK_IMPORTED_MODULE_1__.base58check)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256).encode(data),\n    decode: (data) => (0,_scure_base__WEBPACK_IMPORTED_MODULE_1__.base58check)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256).decode(data)\n};\nconst Base64 = {\n    encode: (data) => _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.encode(data),\n    decode: (data) => _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.decode(data)\n};\nconst B64url = {\n    encode: (data) => _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64urlnopad.encode(data),\n    decode: (data) => _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64urlnopad.decode(data)\n};\nconst Bech32 = {\n    to_words: _scure_base__WEBPACK_IMPORTED_MODULE_1__.bech32.toWords,\n    to_bytes: _scure_base__WEBPACK_IMPORTED_MODULE_1__.bech32.fromWords,\n    encode: (prefix, words, limit = false) => {\n        return _scure_base__WEBPACK_IMPORTED_MODULE_1__.bech32.encode(prefix, words, limit);\n    },\n    decode: (data, limit = false) => {\n        const { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_1__.bech32.decode(data, limit);\n        return { prefix, words };\n    }\n};\nconst Bech32m = {\n    to_words: _scure_base__WEBPACK_IMPORTED_MODULE_1__.bech32m.toWords,\n    to_bytes: _scure_base__WEBPACK_IMPORTED_MODULE_1__.bech32m.fromWords,\n    encode: (prefix, words, limit = false) => {\n        return _scure_base__WEBPACK_IMPORTED_MODULE_1__.bech32m.encode(prefix, words, limit);\n    },\n    decode: (data, limit = false) => {\n        const { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_1__.bech32m.decode(data, limit);\n        return { prefix, words };\n    }\n};\n//# sourceMappingURL=encode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2VuY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ21DO0FBQ0U7QUFDNUU7QUFDUCxZQUFZLHNEQUFVO0FBQ3RCLFlBQVksc0RBQVU7QUFDdEI7QUFDTztBQUNQLFlBQVksc0RBQVU7QUFDdEIsWUFBWSxzREFBVTtBQUN0QjtBQUNPO0FBQ1Asc0JBQXNCLHdEQUFXLENBQUMsd0RBQU07QUFDeEMsc0JBQXNCLHdEQUFXLENBQUMsd0RBQU07QUFDeEM7QUFDTztBQUNQLHNCQUFzQiwrQ0FBTTtBQUM1QixzQkFBc0IsK0NBQU07QUFDNUI7QUFDTztBQUNQLHNCQUFzQix1REFBYztBQUNwQyxzQkFBc0IsdURBQWM7QUFDcEM7QUFDTztBQUNQLGNBQWMsK0NBQU07QUFDcEIsY0FBYywrQ0FBTTtBQUNwQjtBQUNBLGVBQWUsK0NBQU07QUFDckIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGdCQUFnQixFQUFFLCtDQUFNO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ087QUFDUCxjQUFjLGdEQUFPO0FBQ3JCLGNBQWMsZ0RBQU87QUFDckI7QUFDQSxlQUFlLGdEQUFPO0FBQ3RCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixnQkFBZ0IsRUFBRSxnREFBTztBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2VuY29kZS5qcz8xOTRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IGJ5dGVzVG9TdHIsIGJ5dGVzVG9IZXgsIGhleFRvQnl0ZXMsIHN0clRvQnl0ZXMgfSBmcm9tICcuL2Zvcm1hdC9zdHIuanMnO1xuaW1wb3J0IHsgYmFzZTU4Y2hlY2ssIGJhc2U2NCwgYmFzZTY0dXJsbm9wYWQsIGJlY2gzMiwgYmVjaDMybSB9IGZyb20gJ0BzY3VyZS9iYXNlJztcbmV4cG9ydCBjb25zdCBIZXggPSB7XG4gICAgZW5jb2RlOiBieXRlc1RvSGV4LFxuICAgIGRlY29kZTogaGV4VG9CeXRlc1xufTtcbmV4cG9ydCBjb25zdCBUeHQgPSB7XG4gICAgZW5jb2RlOiBzdHJUb0J5dGVzLFxuICAgIGRlY29kZTogYnl0ZXNUb1N0clxufTtcbmV4cG9ydCBjb25zdCBCNThjaGsgPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gYmFzZTU4Y2hlY2soc2hhMjU2KS5lbmNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoZGF0YSkgPT4gYmFzZTU4Y2hlY2soc2hhMjU2KS5kZWNvZGUoZGF0YSlcbn07XG5leHBvcnQgY29uc3QgQmFzZTY0ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IGJhc2U2NC5lbmNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoZGF0YSkgPT4gYmFzZTY0LmRlY29kZShkYXRhKVxufTtcbmV4cG9ydCBjb25zdCBCNjR1cmwgPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gYmFzZTY0dXJsbm9wYWQuZW5jb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKGRhdGEpID0+IGJhc2U2NHVybG5vcGFkLmRlY29kZShkYXRhKVxufTtcbmV4cG9ydCBjb25zdCBCZWNoMzIgPSB7XG4gICAgdG9fd29yZHM6IGJlY2gzMi50b1dvcmRzLFxuICAgIHRvX2J5dGVzOiBiZWNoMzIuZnJvbVdvcmRzLFxuICAgIGVuY29kZTogKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gZmFsc2UpID0+IHtcbiAgICAgICAgcmV0dXJuIGJlY2gzMi5lbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQpO1xuICAgIH0sXG4gICAgZGVjb2RlOiAoZGF0YSwgbGltaXQgPSBmYWxzZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGJlY2gzMi5kZWNvZGUoZGF0YSwgbGltaXQpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBCZWNoMzJtID0ge1xuICAgIHRvX3dvcmRzOiBiZWNoMzJtLnRvV29yZHMsXG4gICAgdG9fYnl0ZXM6IGJlY2gzMm0uZnJvbVdvcmRzLFxuICAgIGVuY29kZTogKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gZmFsc2UpID0+IHtcbiAgICAgICAgcmV0dXJuIGJlY2gzMm0uZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0KTtcbiAgICB9LFxuICAgIGRlY29kZTogKGRhdGEsIGxpbWl0ID0gZmFsc2UpID0+IHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBiZWNoMzJtLmRlY29kZShkYXRhLCBsaW1pdCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/encode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/format/big.js":
/*!*******************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/format/big.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bigToBytes: () => (/* binding */ bigToBytes),\n/* harmony export */   bytesToBig: () => (/* binding */ bytesToBig)\n/* harmony export */ });\nconst _0n = BigInt(0);\nconst _255n = BigInt(255);\nconst _256n = BigInt(256);\nfunction big_size(big) {\n    if (big <= 0xffn)\n        return 1;\n    if (big <= 0xffffn)\n        return 2;\n    if (big <= 0xffffffffn)\n        return 4;\n    if (big <= 0xffffffffffffffffn)\n        return 8;\n    if (big <= 0xffffffffffffffffffffffffffffffffn)\n        return 16;\n    if (big <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) {\n        return 32;\n    }\n    throw new TypeError('Must specify a fixed buffer size for bigints greater than 32 bytes.');\n}\nfunction bigToBytes(big, size, endian = 'be') {\n    if (size === undefined)\n        size = big_size(big);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (big > _0n) {\n        const byte = big & _255n;\n        const num = Number(byte);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        big = (big - byte) / _256n;\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToBig(bytes) {\n    let num = BigInt(0);\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * _256n) + BigInt(bytes[i]);\n    }\n    return BigInt(num);\n}\n//# sourceMappingURL=big.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2Zvcm1hdC9iaWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2J1ZmYvZGlzdC9mb3JtYXQvYmlnLmpzP2I0OTgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzI1NW4gPSBCaWdJbnQoMjU1KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5mdW5jdGlvbiBiaWdfc2l6ZShiaWcpIHtcbiAgICBpZiAoYmlnIDw9IDB4ZmZuKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAoYmlnIDw9IDB4ZmZmZm4pXG4gICAgICAgIHJldHVybiAyO1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZm4pXG4gICAgICAgIHJldHVybiA0O1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZmZmZmZmZmZmbilcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgaWYgKGJpZyA8PSAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbilcbiAgICAgICAgcmV0dXJuIDE2O1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbikge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3Qgc3BlY2lmeSBhIGZpeGVkIGJ1ZmZlciBzaXplIGZvciBiaWdpbnRzIGdyZWF0ZXIgdGhhbiAzMiBieXRlcy4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBiaWdUb0J5dGVzKGJpZywgc2l6ZSwgZW5kaWFuID0gJ2JlJykge1xuICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpXG4gICAgICAgIHNpemUgPSBiaWdfc2l6ZShiaWcpO1xuICAgIGNvbnN0IHVzZV9sZSA9IChlbmRpYW4gPT09ICdsZScpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAodXNlX2xlKSA/IDAgOiBzaXplIC0gMTtcbiAgICB3aGlsZSAoYmlnID4gXzBuKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBiaWcgJiBfMjU1bjtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKGJ5dGUpO1xuICAgICAgICBpZiAodXNlX2xlKSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQrKywgbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KG9mZnNldC0tLCBudW0pO1xuICAgICAgICB9XG4gICAgICAgIGJpZyA9IChiaWcgLSBieXRlKSAvIF8yNTZuO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvQmlnKGJ5dGVzKSB7XG4gICAgbGV0IG51bSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gYnl0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbnVtID0gKG51bSAqIF8yNTZuKSArIEJpZ0ludChieXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQobnVtKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/format/big.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/format/bin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/format/bin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   binToBytes: () => (/* binding */ binToBytes),\n/* harmony export */   bytesToBin: () => (/* binding */ bytesToBin)\n/* harmony export */ });\nfunction binToBytes(binary) {\n    const bins = binary.split('').map(Number);\n    if (bins.length % 8 !== 0) {\n        throw new Error(`Binary array is invalid length: ${binary.length}`);\n    }\n    const bytes = new Uint8Array(bins.length / 8);\n    for (let i = 0, ct = 0; i < bins.length; i += 8, ct++) {\n        let byte = 0;\n        for (let j = 0; j < 8; j++) {\n            byte |= (bins[i + j] << (7 - j));\n        }\n        bytes[ct] = byte;\n    }\n    return bytes;\n}\nfunction bytesToBin(bytes) {\n    const bin = new Array(bytes.length * 8);\n    let count = 0;\n    for (const num of bytes) {\n        if (num > 255) {\n            throw new Error(`Invalid byte value: ${num}. Byte values must be between 0 and 255.`);\n        }\n        for (let i = 7; i >= 0; i--, count++) {\n            bin[count] = (num >> i) & 1;\n        }\n    }\n    return bin.join('');\n}\n//# sourceMappingURL=bin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2Zvcm1hdC9iaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2J1ZmYvZGlzdC9mb3JtYXQvYmluLmpzP2YzZmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGJpblRvQnl0ZXMoYmluYXJ5KSB7XG4gICAgY29uc3QgYmlucyA9IGJpbmFyeS5zcGxpdCgnJykubWFwKE51bWJlcik7XG4gICAgaWYgKGJpbnMubGVuZ3RoICUgOCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmFyeSBhcnJheSBpcyBpbnZhbGlkIGxlbmd0aDogJHtiaW5hcnkubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbnMubGVuZ3RoIC8gOCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGN0ID0gMDsgaSA8IGJpbnMubGVuZ3RoOyBpICs9IDgsIGN0KyspIHtcbiAgICAgICAgbGV0IGJ5dGUgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgICAgICAgYnl0ZSB8PSAoYmluc1tpICsgal0gPDwgKDcgLSBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXNbY3RdID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9CaW4oYnl0ZXMpIHtcbiAgICBjb25zdCBiaW4gPSBuZXcgQXJyYXkoYnl0ZXMubGVuZ3RoICogOCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IG51bSBvZiBieXRlcykge1xuICAgICAgICBpZiAobnVtID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnl0ZSB2YWx1ZTogJHtudW19LiBCeXRlIHZhbHVlcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1LmApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSA3OyBpID49IDA7IGktLSwgY291bnQrKykge1xuICAgICAgICAgICAgYmluW2NvdW50XSA9IChudW0gPj4gaSkgJiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaW4uam9pbignJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/format/bin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/format/buffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/format/buffer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buffer_data: () => (/* binding */ buffer_data)\n/* harmony export */ });\n/* harmony import */ var _big_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./big.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/big.js\");\n/* harmony import */ var _num_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./num.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/num.js\");\n/* harmony import */ var _str_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./str.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/str.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/utils.js\");\n\n\n\n\nfunction buffer_data(data, size, endian) {\n    if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    else if (data instanceof Uint8Array) {\n        return _utils_js__WEBPACK_IMPORTED_MODULE_3__.set_buffer(data, size, endian);\n    }\n    else if (Array.isArray(data)) {\n        const bytes = data.map(e => buffer_data(e, size, endian));\n        return _utils_js__WEBPACK_IMPORTED_MODULE_3__.join_array(bytes);\n    }\n    else if (typeof data === 'string') {\n        return (0,_str_js__WEBPACK_IMPORTED_MODULE_2__.hexToBytes)(data, size, endian);\n    }\n    else if (typeof data === 'bigint') {\n        return (0,_big_js__WEBPACK_IMPORTED_MODULE_0__.bigToBytes)(data, size, endian);\n    }\n    else if (typeof data === 'number') {\n        return (0,_num_js__WEBPACK_IMPORTED_MODULE_1__.numToBytes)(data, size, endian);\n    }\n    else if (typeof data === 'boolean') {\n        return Uint8Array.of(data ? 1 : 0);\n    }\n    throw new TypeError('Unsupported format:' + String(typeof data));\n}\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2Zvcm1hdC9idWZmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0M7QUFDQTtBQUNBO0FBQ0Y7QUFDN0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBZTtBQUM5QjtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0EsZUFBZSxtREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2J1ZmYvZGlzdC9mb3JtYXQvYnVmZmVyLmpzPzllYWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmlnVG9CeXRlcyB9IGZyb20gJy4vYmlnLmpzJztcbmltcG9ydCB7IG51bVRvQnl0ZXMgfSBmcm9tICcuL251bS5qcyc7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIH0gZnJvbSAnLi9zdHIuanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyX2RhdGEoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiB1dGlsLnNldF9idWZmZXIoZGF0YSwgc2l6ZSwgZW5kaWFuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGRhdGEubWFwKGUgPT4gYnVmZmVyX2RhdGEoZSwgc2l6ZSwgZW5kaWFuKSk7XG4gICAgICAgIHJldHVybiB1dGlsLmpvaW5fYXJyYXkoYnl0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMoZGF0YSwgc2l6ZSwgZW5kaWFuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBiaWdUb0J5dGVzKGRhdGEsIHNpemUsIGVuZGlhbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbnVtVG9CeXRlcyhkYXRhLCBzaXplLCBlbmRpYW4pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5Lm9mKGRhdGEgPyAxIDogMCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIGZvcm1hdDonICsgU3RyaW5nKHR5cGVvZiBkYXRhKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/format/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/format/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/format/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bigToBytes: () => (/* reexport safe */ _big_js__WEBPACK_IMPORTED_MODULE_0__.bigToBytes),\n/* harmony export */   binToBytes: () => (/* reexport safe */ _bin_js__WEBPACK_IMPORTED_MODULE_1__.binToBytes),\n/* harmony export */   buffer_data: () => (/* reexport safe */ _buffer_js__WEBPACK_IMPORTED_MODULE_2__.buffer_data),\n/* harmony export */   bytesToBig: () => (/* reexport safe */ _big_js__WEBPACK_IMPORTED_MODULE_0__.bytesToBig),\n/* harmony export */   bytesToBin: () => (/* reexport safe */ _bin_js__WEBPACK_IMPORTED_MODULE_1__.bytesToBin),\n/* harmony export */   bytesToHex: () => (/* reexport safe */ _str_js__WEBPACK_IMPORTED_MODULE_4__.bytesToHex),\n/* harmony export */   bytesToNum: () => (/* reexport safe */ _num_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNum),\n/* harmony export */   bytesToStr: () => (/* reexport safe */ _str_js__WEBPACK_IMPORTED_MODULE_4__.bytesToStr),\n/* harmony export */   hexToBytes: () => (/* reexport safe */ _str_js__WEBPACK_IMPORTED_MODULE_4__.hexToBytes),\n/* harmony export */   numToBytes: () => (/* reexport safe */ _num_js__WEBPACK_IMPORTED_MODULE_3__.numToBytes),\n/* harmony export */   strToBytes: () => (/* reexport safe */ _str_js__WEBPACK_IMPORTED_MODULE_4__.strToBytes)\n/* harmony export */ });\n/* harmony import */ var _big_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./big.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/big.js\");\n/* harmony import */ var _bin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bin.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/bin.js\");\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/buffer.js\");\n/* harmony import */ var _num_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./num.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/num.js\");\n/* harmony import */ var _str_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./str.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/format/str.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2Zvcm1hdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlCO0FBQ0E7QUFDRztBQUNIO0FBQ0E7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9idWZmL2Rpc3QvZm9ybWF0L2luZGV4LmpzPzU1ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9iaWcuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9iaW4uanMnO1xuZXhwb3J0ICogZnJvbSAnLi9idWZmZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9udW0uanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zdHIuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/format/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/format/num.js":
/*!*******************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/format/num.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bytesToNum: () => (/* binding */ bytesToNum),\n/* harmony export */   numToBytes: () => (/* binding */ numToBytes)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assert.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/assert.js\");\n\nfunction num_size(num) {\n    if (num <= 0xFF)\n        return 1;\n    if (num <= 0xFFFF)\n        return 2;\n    if (num <= 0xFFFFFFFF)\n        return 4;\n    throw new TypeError('Numbers larger than 4 bytes must specify a fixed size!');\n}\nfunction numToBytes(num, size, endian = 'be') {\n    if (size === undefined)\n        size = num_size(num);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (num > 0) {\n        const byte = num & 255;\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        num = (num - byte) / 256;\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToNum(bytes) {\n    let num = 0;\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * 256) + bytes[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.is_safe_num)(num);\n    }\n    return num;\n}\n//# sourceMappingURL=num.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2Zvcm1hdC9udW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsUUFBUSx1REFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2J1ZmYvZGlzdC9mb3JtYXQvbnVtLmpzPzJhZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNfc2FmZV9udW0gfSBmcm9tICcuLi9hc3NlcnQuanMnO1xuZnVuY3Rpb24gbnVtX3NpemUobnVtKSB7XG4gICAgaWYgKG51bSA8PSAweEZGKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAobnVtIDw9IDB4RkZGRilcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgaWYgKG51bSA8PSAweEZGRkZGRkZGKVxuICAgICAgICByZXR1cm4gNDtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOdW1iZXJzIGxhcmdlciB0aGFuIDQgYnl0ZXMgbXVzdCBzcGVjaWZ5IGEgZml4ZWQgc2l6ZSEnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1Ub0J5dGVzKG51bSwgc2l6ZSwgZW5kaWFuID0gJ2JlJykge1xuICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpXG4gICAgICAgIHNpemUgPSBudW1fc2l6ZShudW0pO1xuICAgIGNvbnN0IHVzZV9sZSA9IChlbmRpYW4gPT09ICdsZScpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAodXNlX2xlKSA/IDAgOiBzaXplIC0gMTtcbiAgICB3aGlsZSAobnVtID4gMCkge1xuICAgICAgICBjb25zdCBieXRlID0gbnVtICYgMjU1O1xuICAgICAgICBpZiAodXNlX2xlKSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQrKywgbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KG9mZnNldC0tLCBudW0pO1xuICAgICAgICB9XG4gICAgICAgIG51bSA9IChudW0gLSBieXRlKSAvIDI1NjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bShieXRlcykge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBieXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBudW0gPSAobnVtICogMjU2KSArIGJ5dGVzW2ldO1xuICAgICAgICBpc19zYWZlX251bShudW0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/format/num.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/format/str.js":
/*!*******************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/format/str.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToStr: () => (/* binding */ bytesToStr),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   strToBytes: () => (/* binding */ strToBytes)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assert.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/assert.js\");\n\nconst ec = new TextEncoder();\nconst dc = new TextDecoder();\nfunction strToBytes(str) {\n    return ec.encode(str);\n}\nfunction bytesToStr(bytes) {\n    return dc.decode(bytes);\n}\nfunction hex_size(hexstr, size) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.is_hex)(hexstr);\n    const len = hexstr.length / 2;\n    if (size === undefined)\n        size = len;\n    if (len > size) {\n        throw new TypeError(`Hex string is larger than array size: ${len} > ${size}`);\n    }\n    return size;\n}\nfunction hexToBytes(hexstr, size, endian = 'le') {\n    size = hex_size(hexstr, size);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    for (let i = 0; i < hexstr.length; i += 2) {\n        const char = hexstr.substring(i, i + 2);\n        const num = parseInt(char, 16);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToHex(bytes) {\n    let chars = '';\n    for (let i = 0; i < bytes.length; i++) {\n        chars += bytes[i].toString(16).padStart(2, '0');\n    }\n    return chars;\n}\n//# sourceMappingURL=str.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2Zvcm1hdC9zdHIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0M7QUFDdEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEtBQUssSUFBSSxLQUFLO0FBQ25GO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9idWZmL2Rpc3QvZm9ybWF0L3N0ci5qcz9jOWU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzX2hleCB9IGZyb20gJy4uL2Fzc2VydC5qcyc7XG5jb25zdCBlYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgZGMgPSBuZXcgVGV4dERlY29kZXIoKTtcbmV4cG9ydCBmdW5jdGlvbiBzdHJUb0J5dGVzKHN0cikge1xuICAgIHJldHVybiBlYy5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvU3RyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGRjLmRlY29kZShieXRlcyk7XG59XG5mdW5jdGlvbiBoZXhfc2l6ZShoZXhzdHIsIHNpemUpIHtcbiAgICBpc19oZXgoaGV4c3RyKTtcbiAgICBjb25zdCBsZW4gPSBoZXhzdHIubGVuZ3RoIC8gMjtcbiAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzaXplID0gbGVuO1xuICAgIGlmIChsZW4gPiBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEhleCBzdHJpbmcgaXMgbGFyZ2VyIHRoYW4gYXJyYXkgc2l6ZTogJHtsZW59ID4gJHtzaXplfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleHN0ciwgc2l6ZSwgZW5kaWFuID0gJ2xlJykge1xuICAgIHNpemUgPSBoZXhfc2l6ZShoZXhzdHIsIHNpemUpO1xuICAgIGNvbnN0IHVzZV9sZSA9IChlbmRpYW4gPT09ICdsZScpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAodXNlX2xlKSA/IDAgOiBzaXplIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhleHN0ci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBjaGFyID0gaGV4c3RyLnN1YnN0cmluZyhpLCBpICsgMik7XG4gICAgICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KGNoYXIsIDE2KTtcbiAgICAgICAgaWYgKHVzZV9sZSkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0KyssIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQtLSwgbnVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgbGV0IGNoYXJzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGFycyArPSBieXRlc1tpXS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/format/str.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   B58chk: () => (/* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.B58chk),\n/* harmony export */   B64url: () => (/* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.B64url),\n/* harmony export */   Base64: () => (/* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.Base64),\n/* harmony export */   Bech32: () => (/* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.Bech32),\n/* harmony export */   Bech32m: () => (/* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.Bech32m),\n/* harmony export */   Buff: () => (/* reexport safe */ _buff_js__WEBPACK_IMPORTED_MODULE_0__.Buff),\n/* harmony export */   Hex: () => (/* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.Hex),\n/* harmony export */   Stream: () => (/* reexport safe */ _buff_js__WEBPACK_IMPORTED_MODULE_0__.Stream),\n/* harmony export */   Txt: () => (/* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.Txt),\n/* harmony export */   assert: () => (/* reexport module object */ _assert_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   buffer: () => (/* reexport safe */ _buff_js__WEBPACK_IMPORTED_MODULE_0__.buffer),\n/* harmony export */   util: () => (/* reexport module object */ _utils_js__WEBPACK_IMPORTED_MODULE_4__)\n/* harmony export */ });\n/* harmony import */ var _buff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buff.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/buff.js\");\n/* harmony import */ var _encode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encode.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/encode.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/types.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assert.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/utils.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ0U7QUFDRDtBQUNXO0FBQ0g7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9idWZmL2Rpc3QvaW5kZXguanM/MDk5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2J1ZmYuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbmNvZGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy5qcyc7XG5leHBvcnQgKiBhcyBhc3NlcnQgZnJvbSAnLi9hc3NlcnQuanMnO1xuZXhwb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWxzLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/types.js":
/*!**************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/types.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L3R5cGVzLmpzP2U4YTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/dist/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/@cmdcode/buff/dist/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bigint_replacer: () => (/* binding */ bigint_replacer),\n/* harmony export */   bigint_reviver: () => (/* binding */ bigint_reviver),\n/* harmony export */   is_bytes: () => (/* binding */ is_bytes),\n/* harmony export */   is_hex: () => (/* binding */ is_hex),\n/* harmony export */   join_array: () => (/* binding */ join_array),\n/* harmony export */   parse_data: () => (/* binding */ parse_data),\n/* harmony export */   set_buffer: () => (/* binding */ set_buffer)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ \"(ssr)/./node_modules/@cmdcode/buff/dist/assert.js\");\n\nfunction is_hex(input) {\n    if (input.match(/[^a-fA-F0-9]/) === null &&\n        input.length % 2 === 0) {\n        return true;\n    }\n    return false;\n}\nfunction is_bytes(input) {\n    if (typeof input === 'string' && is_hex(input)) {\n        return true;\n    }\n    else if (typeof input === 'number' ||\n        typeof input === 'bigint' ||\n        input instanceof Uint8Array) {\n        return true;\n    }\n    else if (Array.isArray(input) &&\n        input.every(e => typeof e === 'number')) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction set_buffer(data, size, endian = 'be') {\n    if (size === undefined)\n        size = data.length;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.within_size)(data, size);\n    const buffer = new Uint8Array(size).fill(0);\n    const offset = (endian === 'be') ? 0 : size - data.length;\n    buffer.set(data, offset);\n    return buffer;\n}\nfunction join_array(arr) {\n    let i, offset = 0;\n    const size = arr.reduce((len, arr) => len + arr.length, 0);\n    const buff = new Uint8Array(size);\n    for (i = 0; i < arr.length; i++) {\n        const a = arr[i];\n        buff.set(a, offset);\n        offset += a.length;\n    }\n    return buff;\n}\nfunction bigint_replacer(_, v) {\n    return typeof v === 'bigint'\n        ? `${v}n`\n        : v;\n}\nfunction bigint_reviver(_, v) {\n    return typeof v === 'string' && /^[0-9]+n$/.test(v)\n        ? BigInt(v.slice(0, -1))\n        : v;\n}\nfunction parse_data(data_blob, chunk_size, total_size) {\n    const len = data_blob.length, count = total_size / chunk_size;\n    if (total_size % chunk_size !== 0) {\n        throw new TypeError(`Invalid parameters: ${total_size} % ${chunk_size} !== 0`);\n    }\n    if (len !== total_size) {\n        throw new TypeError(`Invalid data stream: ${len} !== ${total_size}`);\n    }\n    if (len % chunk_size !== 0) {\n        throw new TypeError(`Invalid data stream: ${len} % ${chunk_size} !== 0`);\n    }\n    const chunks = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const idx = i * chunk_size;\n        chunks[i] = data_blob.subarray(idx, idx + chunk_size);\n    }\n    return chunks;\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ25DO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUksdURBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1EQUFtRCxZQUFZLElBQUksWUFBWTtBQUMvRTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUssTUFBTSxXQUFXO0FBQzFFO0FBQ0E7QUFDQSxvREFBb0QsS0FBSyxJQUFJLFlBQVk7QUFDekU7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2J1ZmYvZGlzdC91dGlscy5qcz80NjljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdpdGhpbl9zaXplIH0gZnJvbSAnLi9hc3NlcnQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2hleChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5tYXRjaCgvW15hLWZBLUYwLTldLykgPT09IG51bGwgJiZcbiAgICAgICAgaW5wdXQubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzX2J5dGVzKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgaXNfaGV4KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnIHx8XG4gICAgICAgIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiZcbiAgICAgICAgaW5wdXQuZXZlcnkoZSA9PiB0eXBlb2YgZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYnVmZmVyKGRhdGEsIHNpemUsIGVuZGlhbiA9ICdiZScpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzaXplID0gZGF0YS5sZW5ndGg7XG4gICAgd2l0aGluX3NpemUoZGF0YSwgc2l6ZSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSkuZmlsbCgwKTtcbiAgICBjb25zdCBvZmZzZXQgPSAoZW5kaWFuID09PSAnYmUnKSA/IDAgOiBzaXplIC0gZGF0YS5sZW5ndGg7XG4gICAgYnVmZmVyLnNldChkYXRhLCBvZmZzZXQpO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gam9pbl9hcnJheShhcnIpIHtcbiAgICBsZXQgaSwgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBzaXplID0gYXJyLnJlZHVjZSgobGVuLCBhcnIpID0+IGxlbiArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJbaV07XG4gICAgICAgIGJ1ZmYuc2V0KGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5leHBvcnQgZnVuY3Rpb24gYmlnaW50X3JlcGxhY2VyKF8sIHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdiaWdpbnQnXG4gICAgICAgID8gYCR7dn1uYFxuICAgICAgICA6IHY7XG59XG5leHBvcnQgZnVuY3Rpb24gYmlnaW50X3Jldml2ZXIoXywgdikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgL15bMC05XStuJC8udGVzdCh2KVxuICAgICAgICA/IEJpZ0ludCh2LnNsaWNlKDAsIC0xKSlcbiAgICAgICAgOiB2O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlX2RhdGEoZGF0YV9ibG9iLCBjaHVua19zaXplLCB0b3RhbF9zaXplKSB7XG4gICAgY29uc3QgbGVuID0gZGF0YV9ibG9iLmxlbmd0aCwgY291bnQgPSB0b3RhbF9zaXplIC8gY2h1bmtfc2l6ZTtcbiAgICBpZiAodG90YWxfc2l6ZSAlIGNodW5rX3NpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwYXJhbWV0ZXJzOiAke3RvdGFsX3NpemV9ICUgJHtjaHVua19zaXplfSAhPT0gMGApO1xuICAgIH1cbiAgICBpZiAobGVuICE9PSB0b3RhbF9zaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZGF0YSBzdHJlYW06ICR7bGVufSAhPT0gJHt0b3RhbF9zaXplfWApO1xuICAgIH1cbiAgICBpZiAobGVuICUgY2h1bmtfc2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGRhdGEgc3RyZWFtOiAke2xlbn0gJSAke2NodW5rX3NpemV9ICE9PSAwYCk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGkgKiBjaHVua19zaXplO1xuICAgICAgICBjaHVua3NbaV0gPSBkYXRhX2Jsb2Iuc3ViYXJyYXkoaWR4LCBpZHggKyBjaHVua19zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/buff/node_modules/@scure/base/lib/esm/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@cmdcode/buff/node_modules/@scure/base/lib/esm/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&\n    typeof Uint8Array.fromBase64 === 'function')();\nconst decodeBase64Builtin = (s, isUrl) => {\n    astr('base64', s);\n    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n    const alphabet = isUrl ? 'base64url' : 'base64';\n    if (s.length > 0 && !re.test(s))\n        throw new Error('invalid base64');\n    return Uint8Array.fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nconst base64 = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64(); },\n    decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nconst base64url = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },\n    decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n/**\n * base58: flickr version. Check out `base58`.\n */\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\n/**\n * base58: XRP version. Check out `base58`.\n */\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nconst createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nconst base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nconst bech32 = genBech32('bech32');\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nconst bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&\n    typeof Uint8Array.fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin = {\n    encode(data) { abytes(data); return data.toHex(); },\n    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nconst hex = hasHexBuiltin\n    ? hexBuiltin\n    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n        return s.toLowerCase();\n    }));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n/** @deprecated */\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\n/** @deprecated */\nconst str = bytesToString; // as in python, but for bytes only\n/** @deprecated */\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\n/** @deprecated */\nconst bytes = stringToBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixFQUFFLGNBQWMsUUFBUTtBQUM5RztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU8sY0FBYyxRQUFRO0FBQ3JGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQSxvREFBb0QsR0FBRztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0EsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQSw4REFBOEQsTUFBTSxLQUFLLElBQUksWUFBWSxzQkFBc0I7QUFDL0c7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsR0FBRyxPQUFPLEtBQUs7QUFDL0U7QUFDQTtBQUNBLGlFQUFpRSxLQUFLLE9BQU8sS0FBSztBQUNsRjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUNBQXVDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQjtBQUNsQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvYnVmZi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcz9hYjJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmZ1bmN0aW9uIGFieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAnICsgbGVuZ3RocyArICcsIGdvdCBsZW5ndGg9JyArIGIubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlPZihpc1N0cmluZywgYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnIuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJyLmV2ZXJ5KChpdGVtKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSk7XG4gICAgfVxufVxuLy8gbm8gYWJ5dGVzOiBzZWVtcyB0byBoYXZlIDEwJSBzbG93ZG93bi4gV2h5PyFcbmZ1bmN0aW9uIGFmbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzdHIobGFiZWwsIGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH06IHN0cmluZyBleHBlY3RlZGApO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGFBcnIoaW5wdXQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBhc3RyQXJyKGxhYmVsLCBpbnB1dCkge1xuICAgIGlmICghaXNBcnJheU9mKHRydWUsIGlucHV0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2xhYmVsfTogYXJyYXkgb2Ygc3RyaW5ncyBleHBlY3RlZGApO1xufVxuZnVuY3Rpb24gYW51bUFycihsYWJlbCwgaW5wdXQpIHtcbiAgICBpZiAoIWlzQXJyYXlPZihmYWxzZSwgaW5wdXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9OiBhcnJheSBvZiBudW1iZXJzIGV4cGVjdGVkYCk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBpZCA9IChhKSA9PiBhO1xuICAgIC8vIFdyYXAgY2FsbCBpbiBjbG9zdXJlIHNvIEpJVCBjYW4gaW5saW5lIGNhbGxzXG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gICAgY29uc3QgZW5jb2RlID0gYXJncy5tYXAoKHgpID0+IHguZW5jb2RlKS5yZWR1Y2VSaWdodCh3cmFwLCBpZCk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbMF0uZGVjb2RlKGFyZ3NbMV0uZGVjb2RlKC4uLikpXG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5tYXAoKHgpID0+IHguZGVjb2RlKS5yZWR1Y2Uod3JhcCwgaWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG4vKipcbiAqIEVuY29kZXMgaW50ZWdlciByYWRpeCByZXByZXNlbnRhdGlvbiB0byBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGFscGhhYmV0IGFuZCBiYWNrLlxuICogQ291bGQgYWxzbyBiZSBhcnJheSBvZiBzdHJpbmdzLlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYWxwaGFiZXQobGV0dGVycykge1xuICAgIC8vIG1hcHBpbmcgMSB0byBcImJcIlxuICAgIGNvbnN0IGxldHRlcnNBID0gdHlwZW9mIGxldHRlcnMgPT09ICdzdHJpbmcnID8gbGV0dGVycy5zcGxpdCgnJykgOiBsZXR0ZXJzO1xuICAgIGNvbnN0IGxlbiA9IGxldHRlcnNBLmxlbmd0aDtcbiAgICBhc3RyQXJyKCdhbHBoYWJldCcsIGxldHRlcnNBKTtcbiAgICAvLyBtYXBwaW5nIFwiYlwiIHRvIDFcbiAgICBjb25zdCBpbmRleGVzID0gbmV3IE1hcChsZXR0ZXJzQS5tYXAoKGwsIGkpID0+IFtsLCBpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgYUFycihkaWdpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGkpIHx8IGkgPCAwIHx8IGkgPj0gbGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmVuY29kZTogZGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldCBcIiR7aX1cIi4gQWxsb3dlZDogJHtsZXR0ZXJzfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZXR0ZXJzQVtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgYUFycihpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhc3RyKCdhbHBoYWJldC5kZWNvZGUnLCBsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBpbmRleGVzLmdldChsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7bGV0dGVyc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBhc3RyKCdqb2luJywgc2VwYXJhdG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBhc3RyQXJyKCdqb2luLmRlY29kZScsIGZyb20pO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgYXN0cignam9pbi5kZWNvZGUnLCB0byk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYWQgc3RyaW5ncyBhcnJheSBzbyBpdCBoYXMgaW50ZWdlciBudW1iZXIgb2YgYml0c1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhbnVtYmVyKGJpdHMpO1xuICAgIGFzdHIoJ3BhZGRpbmcnLCBjaHIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBhc3RyQXJyKCdwYWRkaW5nLmVuY29kZScsIGRhdGEpO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGFzdHJBcnIoJ3BhZGRpbmcuZGVjb2RlJywgaW5wdXQpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZzogaW52YWxpZCwgc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gZW5kIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlID0gbGFzdCAqIGJpdHM7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGUgJSA4ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmc6IGludmFsaWQsIHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgYWZuKGZuKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG4vKipcbiAqIFNsb3c6IE8obl4yKSB0aW1lIGNvbXBsZXhpdHlcbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgLy8gYmFzZSAxIGlzIGltcG9zc2libGVcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiBpbnZhbGlkIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogaW52YWxpZCB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBhQXJyKGRhdGEpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEsIChkKSA9PiB7XG4gICAgICAgIGFudW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW50ZWdlcjogJHtkfWApO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9KTtcbiAgICBjb25zdCBkbGVuID0gZGlnaXRzLmxlbmd0aDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZnJvbUNhcnJ5ID0gZnJvbSAqIGNhcnJ5O1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbUNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICBmcm9tQ2FycnkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tQ2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRpZ2l0QmFzZSAvIHRvO1xuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpdik7XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSByb3VuZGVkO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyb3VuZGVkKSB8fCByb3VuZGVkICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXJvdW5kZWQpXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gKGEsIGIpID0+IChiID09PSAwID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbmNvbnN0IHBvd2VycyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDIgKiogaSk7XG4gICAgcmV0dXJuIHJlcztcbn0pKCk7XG4vKipcbiAqIEltcGxlbWVudGVkIHdpdGggbnVtYmVycywgYmVjYXVzZSBCaWdJbnQgaXMgNXggc2xvd2VyXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBhQXJyKGRhdGEpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICAgIGNvbnN0IG1heCA9IHBvd2Vyc1tmcm9tXTtcbiAgICBjb25zdCBtYXNrID0gcG93ZXJzW3RvXSAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYW51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gbWF4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjb25zdCBwb3cgPSBwb3dlcnNbcG9zXTtcbiAgICAgICAgaWYgKHBvdyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNhcnJ5Jyk7XG4gICAgICAgIGNhcnJ5ICY9IHBvdyAtIDE7IC8vIGNsZWFuIGNhcnJ5LCBvdGhlcndpc2UgaXQgd2lsbCBjYXVzZSBvdmVyZmxvd1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5ID4gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhbnVtYmVyKG51bSk7XG4gICAgY29uc3QgXzI1NiA9IDIgKiogODtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgXzI1NiwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBhbnVtQXJyKCdyYWRpeC5kZWNvZGUnLCBkaWdpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIF8yNTYpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBJZiBib3RoIGJhc2VzIGFyZSBwb3dlciBvZiBzYW1lIG51bWJlciAobGlrZSBgMioqOCA8LT4gMioqNjRgKSxcbiAqIHRoZXJlIGlzIGEgbGluZWFyIGFsZ29yaXRobS4gRm9yIG5vdyB3ZSBoYXZlIGltcGxlbWVudGF0aW9uIGZvciBwb3dlci1vZi10d28gYmFzZXMgb25seS5cbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhbnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBhbnVtQXJyKCdyYWRpeDIuZGVjb2RlJywgZGlnaXRzKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGFmbihmbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYW51bWJlcihsZW4pO1xuICAgIGFmbihmbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgY29udmVydFJhZGl4LCBjb252ZXJ0UmFkaXgyLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nLFxufTtcbi8vIFJGQyA0NjQ4IGFrYSBSRkMgMzU0OFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIGJhc2UxNiBlbmNvZGluZyBmcm9tIFJGQyA0NjQ4LlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMTYuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICcxMkFCJ1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlMTYgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIEhhcyBwYWRkaW5nLlxuICogVXNlIGBiYXNlMzJub3BhZGAgZm9yIHVucGFkZGVkIHZlcnNpb24uXG4gKiBBbHNvIGNoZWNrIG91dCBgYmFzZTMyaGV4YCwgYGJhc2UzMmhleG5vcGFkYCwgYGJhc2UzMmNyb2NrZm9yZGAuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UzMi5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0NLVlE9PT09J1xuICogYmFzZTMyLmRlY29kZSgnQ0tWUT09PT0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIE5vIHBhZGRpbmcuXG4gKiBVc2UgYGJhc2UzMmAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQWxzbyBjaGVjayBvdXQgYGJhc2UzMmhleGAsIGBiYXNlMzJoZXhub3BhZGAsIGBiYXNlMzJjcm9ja2ZvcmRgLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0NLVlEnXG4gKiBiYXNlMzJub3BhZC5kZWNvZGUoJ0NLVlEnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMm5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gUGFkZGVkLiBDb21wYXJlZCB0byBvcmRpbmFyeSBgYmFzZTMyYCwgc2xpZ2h0bHkgZGlmZmVyZW50IGFscGhhYmV0LlxuICogVXNlIGBiYXNlMzJoZXhub3BhZGAgZm9yIHVucGFkZGVkIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UzMmhleC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJzJBTEc9PT09J1xuICogYmFzZTMyaGV4LmRlY29kZSgnMkFMRz09PT0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIE5vIHBhZGRpbmcuIENvbXBhcmVkIHRvIG9yZGluYXJ5IGBiYXNlMzJgLCBzbGlnaHRseSBkaWZmZXJlbnQgYWxwaGFiZXQuXG4gKiBVc2UgYGJhc2UzMmhleGAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJoZXhub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJzJBTEcnXG4gKiBiYXNlMzJoZXhub3BhZC5kZWNvZGUoJzJBTEcnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleG5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gRG91ZyBDcm9ja2ZvcmQncyB2ZXJzaW9uLlxuICogaHR0cHM6Ly93d3cuY3JvY2tmb3JkLmNvbS9iYXNlMzIuaHRtbFxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJjcm9ja2ZvcmQuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICcyQU5HJ1xuICogYmFzZTMyY3JvY2tmb3JkLmRlY29kZSgnMkFORycpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbi8vIEJ1aWx0LWluIGJhc2U2NCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9tYmFzZTY0XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IGhhc0Jhc2U2NEJ1aWx0aW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvQmFzZTY0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCA9PT0gJ2Z1bmN0aW9uJykoKTtcbmNvbnN0IGRlY29kZUJhc2U2NEJ1aWx0aW4gPSAocywgaXNVcmwpID0+IHtcbiAgICBhc3RyKCdiYXNlNjQnLCBzKTtcbiAgICBjb25zdCByZSA9IGlzVXJsID8gL15bQS1aYS16MC05PV8tXSskLyA6IC9eW0EtWmEtejAtOT0rL10rJC87XG4gICAgY29uc3QgYWxwaGFiZXQgPSBpc1VybCA/ICdiYXNlNjR1cmwnIDogJ2Jhc2U2NCc7XG4gICAgaWYgKHMubGVuZ3RoID4gMCAmJiAhcmUudGVzdChzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2U2NCcpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb21CYXNlNjQocywgeyBhbHBoYWJldCwgbGFzdENodW5rSGFuZGxpbmc6ICdzdHJpY3QnIH0pO1xufTtcbi8qKlxuICogYmFzZTY0IGZyb20gUkZDIDQ2NDguIFBhZGRlZC5cbiAqIFVzZSBgYmFzZTY0bm9wYWRgIGZvciB1bnBhZGRlZCB2ZXJzaW9uLlxuICogQWxzbyBjaGVjayBvdXQgYGJhc2U2NHVybGAsIGBiYXNlNjR1cmxub3BhZGAuXG4gKiBGYWxscyBiYWNrIHRvIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTY0LmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzPSdcbiAqIGJhc2U2NC5kZWNvZGUoJ0Vxcz0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgYmFzZTY0ID0gaGFzQmFzZTY0QnVpbHRpbiA/IHtcbiAgICBlbmNvZGUoYikgeyBhYnl0ZXMoYik7IHJldHVybiBiLnRvQmFzZTY0KCk7IH0sXG4gICAgZGVjb2RlKHMpIHsgcmV0dXJuIGRlY29kZUJhc2U2NEJ1aWx0aW4ocywgZmFsc2UpOyB9LFxufSA6IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlNjQgZnJvbSBSRkMgNDY0OC4gTm8gcGFkZGluZy5cbiAqIFVzZSBgYmFzZTY0YCBmb3IgcGFkZGVkIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U2NG5vcGFkLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzJ1xuICogYmFzZTY0bm9wYWQuZGVjb2RlKCdFcXMnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U2NG5vcGFkID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBqb2luKCcnKSk7XG4vKipcbiAqIGJhc2U2NCBmcm9tIFJGQyA0NjQ4LCB1c2luZyBVUkwtc2FmZSBhbHBoYWJldC4gUGFkZGVkLlxuICogVXNlIGBiYXNlNjR1cmxub3BhZGAgZm9yIHVucGFkZGVkIHZlcnNpb24uXG4gKiBGYWxscyBiYWNrIHRvIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTY0dXJsLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzPSdcbiAqIGJhc2U2NHVybC5kZWNvZGUoJ0Vxcz0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gaGFzQmFzZTY0QnVpbHRpbiA/IHtcbiAgICBlbmNvZGUoYikgeyBhYnl0ZXMoYik7IHJldHVybiBiLnRvQmFzZTY0KHsgYWxwaGFiZXQ6ICdiYXNlNjR1cmwnIH0pOyB9LFxuICAgIGRlY29kZShzKSB7IHJldHVybiBkZWNvZGVCYXNlNjRCdWlsdGluKHMsIHRydWUpOyB9LFxufSA6IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlNjQgZnJvbSBSRkMgNDY0OCwgdXNpbmcgVVJMLXNhZmUgYWxwaGFiZXQuIE5vIHBhZGRpbmcuXG4gKiBVc2UgYGJhc2U2NHVybGAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlNjR1cmxub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0VxcydcbiAqIGJhc2U2NHVybG5vcGFkLmRlY29kZSgnRXFzJyk7XG4gKiAvLyA9PiBVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxub3BhZCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgam9pbignJykpO1xuLy8gYmFzZTU4IGNvZGVcbi8vIC0tLS0tLS0tLS0tXG5jb25zdCBnZW5CYXNlNTggPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoYWJjKSA9PiBjaGFpbihyYWRpeCg1OCksIGFscGhhYmV0KGFiYyksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTU4OiBiYXNlNjQgd2l0aG91dCBhbWJpZ291cyBjaGFyYWN0ZXJzICssIC8sIDAsIE8sIEksIGwuXG4gKiBRdWFkcmF0aWMgKE8obl4yKSkgLSBzbywgY2FuJ3QgYmUgdXNlZCBvbiBsYXJnZSBpbnB1dHMuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U1OC5kZWNvZGUoJzAxYWJjZGVmJyk7XG4gKiAvLyA9PiAnM1VoSlcnXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuLyoqXG4gKiBiYXNlNTg6IGZsaWNrciB2ZXJzaW9uLiBDaGVjayBvdXQgYGJhc2U1OGAuXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbi8qKlxuICogYmFzZTU4OiBYUlAgdmVyc2lvbi4gQ2hlY2sgb3V0IGBiYXNlNThgLlxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyBEYXRhIGxlbiAoaW5kZXgpIC0+IGVuY29kZWQgYmxvY2sgbGVuXG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG4vKipcbiAqIGJhc2U1ODogWE1SIHZlcnNpb24uIENoZWNrIG91dCBgYmFzZTU4YC5cbiAqIERvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4gKiBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbi8qKlxuICogTWV0aG9kLCB3aGljaCBjcmVhdGVzIGJhc2U1OGNoZWNrIGVuY29kZXIuXG4gKiBSZXF1aXJlcyBmdW5jdGlvbiwgY2FsY3VsYXRpbmcgc2hhMjU2LlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuLyoqXG4gKiBVc2UgYGNyZWF0ZUJhc2U1OGNoZWNrYCBpbnN0ZWFkLlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OGNoZWNrID0gY3JlYXRlQmFzZTU4Y2hlY2s7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgcG93ZXJzWzMwXV0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBhc3RyKCdiZWNoMzIuZW5jb2RlIHByZWZpeCcsIHByZWZpeCk7XG4gICAgICAgIGlmIChpc0J5dGVzKHdvcmRzKSlcbiAgICAgICAgICAgIHdvcmRzID0gQXJyYXkuZnJvbSh3b3Jkcyk7XG4gICAgICAgIGFudW1BcnIoJ2JlY2gzMi5lbmNvZGUnLCB3b3Jkcyk7XG4gICAgICAgIGNvbnN0IHBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBpZiAocGxlbiA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcHJlZml4IGxlbmd0aCAke3BsZW59YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHBsZW4gKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKGxvd2VyZWQsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIHJldHVybiBgJHtsb3dlcmVkfTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke3N1bX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGFzdHIoJ2JlY2gzMi5kZWNvZGUgaW5wdXQnLCBzdHIpO1xuICAgICAgICBjb25zdCBzbGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKHNsZW4gPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc2xlbiA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgc3RyaW5nIGxlbmd0aDogJHtzbGVufSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gbG93ZXJlZC5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbG93ZXJlZC5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBsb3dlcmVkLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKGRhdGEpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFkYXRhLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVGcm9tQnl0ZXMocHJlZml4LCBieXRlcykge1xuICAgICAgICByZXR1cm4gZW5jb2RlKHByZWZpeCwgdG9Xb3JkcyhieXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGRlY29kZSxcbiAgICAgICAgZW5jb2RlRnJvbUJ5dGVzLFxuICAgICAgICBkZWNvZGVUb0J5dGVzLFxuICAgICAgICBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGZyb21Xb3JkcyxcbiAgICAgICAgZnJvbVdvcmRzVW5zYWZlLFxuICAgICAgICB0b1dvcmRzLFxuICAgIH07XG59XG4vKipcbiAqIGJlY2gzMiBmcm9tIEJJUCAxNzMuIE9wZXJhdGVzIG9uIHdvcmRzLlxuICogRm9yIGhpZ2gtbGV2ZWwsIGNoZWNrIG91dCBzY3VyZS1idGMtc2lnbmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9zY3VyZS1idGMtc2lnbmVyLlxuICovXG5leHBvcnQgY29uc3QgYmVjaDMyID0gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbi8qKlxuICogYmVjaDMybSBmcm9tIEJJUCAzNTAuIE9wZXJhdGVzIG9uIHdvcmRzLlxuICogSXQgd2FzIHRvIG1pdGlnYXRlIGBiZWNoMzJgIHdlYWtuZXNzZXMuXG4gKiBGb3IgaGlnaC1sZXZlbCwgY2hlY2sgb3V0IHNjdXJlLWJ0Yy1zaWduZXI6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3NjdXJlLWJ0Yy1zaWduZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBiZWNoMzJtID0gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG4vKipcbiAqIFVURi04LXRvLWJ5dGUgZGVjb2Rlci4gVXNlcyBidWlsdC1pbiBUZXh0RGVjb2RlciAvIFRleHRFbmNvZGVyLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBiID0gdXRmOC5kZWNvZGUoXCJoZXlcIik7IC8vID0+IG5ldyBVaW50OEFycmF5KFsgMTA0LCAxMDEsIDEyMSBdKVxuICogY29uc3Qgc3RyID0gdXRmOC5lbmNvZGUoYik7IC8vIFwiaGV5XCJcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgdXRmOCA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoc3RyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSxcbn07XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBoYXNIZXhCdWlsdGluID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbicpKCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IGhleEJ1aWx0aW4gPSB7XG4gICAgZW5jb2RlKGRhdGEpIHsgYWJ5dGVzKGRhdGEpOyByZXR1cm4gZGF0YS50b0hleCgpOyB9LFxuICAgIGRlY29kZShzKSB7IGFzdHIoJ2hleCcsIHMpOyByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KHMpOyB9LFxufTtcbi8qKlxuICogaGV4IHN0cmluZyBkZWNvZGVyLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgYiA9IGhleC5kZWNvZGUoXCIwMTAyZmZcIik7IC8vID0+IG5ldyBVaW50OEFycmF5KFsgMSwgMiwgMjU1IF0pXG4gKiBjb25zdCBzdHIgPSBoZXguZW5jb2RlKGIpOyAvLyBcIjAxMDJmZlwiXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGhleCA9IGhhc0hleEJ1aWx0aW5cbiAgICA/IGhleEJ1aWx0aW5cbiAgICA6IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG4gICAgfSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7IC8vIGFzIGluIHB5dGhvbiwgYnV0IGZvciBieXRlcyBvbmx5XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgY29uc3QgYnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/buff/node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/assert.js":
/*!***********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/assert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   fail: () => (/* binding */ fail),\n/* harmony export */   in_field: () => (/* binding */ in_field),\n/* harmony export */   ok: () => (/* binding */ ok),\n/* harmony export */   on_curve: () => (/* binding */ on_curve),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   valid_chain: () => (/* binding */ valid_chain),\n/* harmony export */   valid_derive_state: () => (/* binding */ valid_derive_state),\n/* harmony export */   valid_hash: () => (/* binding */ valid_hash),\n/* harmony export */   valid_index: () => (/* binding */ valid_index),\n/* harmony export */   valid_path: () => (/* binding */ valid_path),\n/* harmony export */   valid_pubkey: () => (/* binding */ valid_pubkey)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/const.js\");\n\n\nfunction ok(value, message) {\n    if (value === false)\n        throw new Error(message ?? 'Assertion failed!');\n}\nfunction fail(error, throws = false) {\n    if (!throws)\n        return false;\n    throw new Error(error);\n}\nfunction size(input, size, throws) {\n    const bytes = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(input);\n    if (bytes.length !== size) {\n        return fail(`Invalid byte size: ${bytes.hex} !== ${size}`, throws);\n    }\n    return true;\n}\nfunction exists(input) {\n    if (typeof input === 'undefined') {\n        throw new TypeError('Input is undefined!');\n    }\n    if (input === null) {\n        throw new TypeError('Input is null!');\n    }\n}\nfunction on_curve(x, throws) {\n    if (!(typeof x === 'bigint' && _const_js__WEBPACK_IMPORTED_MODULE_1__._0n < x && x < _const_js__WEBPACK_IMPORTED_MODULE_1__._P)) {\n        fail('x value is not on the curve!', throws);\n    }\n    return true;\n}\nfunction in_field(x, throws) {\n    if (!(typeof x === 'bigint' && _const_js__WEBPACK_IMPORTED_MODULE_1__._0n < x && x < _const_js__WEBPACK_IMPORTED_MODULE_1__._N)) {\n        fail('x value is not in the field!', throws);\n    }\n    return true;\n}\nfunction valid_chain(path, code) {\n    if (code === undefined) {\n        if (!path.startsWith('m')) {\n            throw new Error('You need to specify a chain-code for a non-root path.');\n        }\n    }\n    else {\n        if (_cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(code).length !== 32) {\n            throw new Error('Chain code must be 32 bytes!');\n        }\n    }\n}\nfunction valid_path(path) {\n    const regex = /^(m)?(\\/)?(\\w+'?\\/)*\\w+'?$/;\n    if (path !== '' && path.match(regex) === null) {\n        throw new Error('Provided path string is invalid: ' + path);\n    }\n}\nfunction valid_hash(hash) {\n    const regex = /^[0-9a-fA-F]{64}$/;\n    if (hash.match(regex) === null) {\n        throw new Error('Provided hash string is invalid: ' + hash);\n    }\n}\nfunction valid_index(index) {\n    if (index > 0x80000000) {\n        throw new TypeError('Index value must not exceed 31 bits.');\n    }\n}\nfunction valid_pubkey(pubkey) {\n    const key = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pubkey);\n    if (key.length !== 33) {\n        throw new TypeError('Index value must not exceed 31 bits.');\n    }\n}\nfunction valid_derive_state(hardened, is_private) {\n    if (hardened && !is_private) {\n        throw new Error('Cannot derive hardedened paths when is_private is false!');\n    }\n}\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0k7QUFDbEM7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0IsK0NBQUk7QUFDdEI7QUFDQSwwQ0FBMEMsV0FBVyxNQUFNLEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUNBQW1DLDBDQUFHLFlBQVkseUNBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1DQUFtQywwQ0FBRyxZQUFZLHlDQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQ0FBZ0MsR0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdCQUFnQiwrQ0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2NyeXB0by10b29scy9kaXN0L2Fzc2VydC5qcz8xNzI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmJztcbmltcG9ydCB7IF9OLCBfUCwgXzBuIH0gZnJvbSAnLi9jb25zdC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSA/PyAnQXNzZXJ0aW9uIGZhaWxlZCEnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmYWlsKGVycm9yLCB0aHJvd3MgPSBmYWxzZSkge1xuICAgIGlmICghdGhyb3dzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaXplKGlucHV0LCBzaXplLCB0aHJvd3MpIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmYuYnl0ZXMoaW5wdXQpO1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoYEludmFsaWQgYnl0ZSBzaXplOiAke2J5dGVzLmhleH0gIT09ICR7c2l6ZX1gLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHMoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBpcyB1bmRlZmluZWQhJyk7XG4gICAgfVxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBpcyBudWxsIScpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBvbl9jdXJ2ZSh4LCB0aHJvd3MpIHtcbiAgICBpZiAoISh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgX1ApKSB7XG4gICAgICAgIGZhaWwoJ3ggdmFsdWUgaXMgbm90IG9uIHRoZSBjdXJ2ZSEnLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbl9maWVsZCh4LCB0aHJvd3MpIHtcbiAgICBpZiAoISh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgX04pKSB7XG4gICAgICAgIGZhaWwoJ3ggdmFsdWUgaXMgbm90IGluIHRoZSBmaWVsZCEnLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZF9jaGFpbihwYXRoLCBjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnbScpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHNwZWNpZnkgYSBjaGFpbi1jb2RlIGZvciBhIG5vbi1yb290IHBhdGguJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCdWZmLmJ5dGVzKGNvZGUpLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhaW4gY29kZSBtdXN0IGJlIDMyIGJ5dGVzIScpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkX3BhdGgocGF0aCkge1xuICAgIGNvbnN0IHJlZ2V4ID0gL14obSk/KFxcLyk/KFxcdysnP1xcLykqXFx3Kyc/JC87XG4gICAgaWYgKHBhdGggIT09ICcnICYmIHBhdGgubWF0Y2gocmVnZXgpID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgcGF0aCBzdHJpbmcgaXMgaW52YWxpZDogJyArIHBhdGgpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZF9oYXNoKGhhc2gpIHtcbiAgICBjb25zdCByZWdleCA9IC9eWzAtOWEtZkEtRl17NjR9JC87XG4gICAgaWYgKGhhc2gubWF0Y2gocmVnZXgpID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgaGFzaCBzdHJpbmcgaXMgaW52YWxpZDogJyArIGhhc2gpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZF9pbmRleChpbmRleCkge1xuICAgIGlmIChpbmRleCA+IDB4ODAwMDAwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXggdmFsdWUgbXVzdCBub3QgZXhjZWVkIDMxIGJpdHMuJyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkX3B1YmtleShwdWJrZXkpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmLmJ5dGVzKHB1YmtleSk7XG4gICAgaWYgKGtleS5sZW5ndGggIT09IDMzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luZGV4IHZhbHVlIG11c3Qgbm90IGV4Y2VlZCAzMSBiaXRzLicpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZF9kZXJpdmVfc3RhdGUoaGFyZGVuZWQsIGlzX3ByaXZhdGUpIHtcbiAgICBpZiAoaGFyZGVuZWQgJiYgIWlzX3ByaXZhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVyaXZlIGhhcmRlZGVuZWQgcGF0aHMgd2hlbiBpc19wcml2YXRlIGlzIGZhbHNlIScpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/const.js":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/const.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _0n: () => (/* binding */ _0n),\n/* harmony export */   _1n: () => (/* binding */ _1n),\n/* harmony export */   _2n: () => (/* binding */ _2n),\n/* harmony export */   _3n: () => (/* binding */ _3n),\n/* harmony export */   _4n: () => (/* binding */ _4n),\n/* harmony export */   _G: () => (/* binding */ _G),\n/* harmony export */   _N: () => (/* binding */ _N),\n/* harmony export */   _P: () => (/* binding */ _P)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n\nconst curve = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.CURVE;\nconst _N = curve.n;\nconst _P = curve.p;\nconst _G = { x: curve.Gx, y: curve.Gy };\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _4n = BigInt(4);\n//# sourceMappingURL=const.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvY29uc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ3BELGNBQWMsOERBQVM7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdG9vbHMvZGlzdC9jb25zdC5qcz85NzhiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmNvbnN0IGN1cnZlID0gc2VjcDI1NmsxLkNVUlZFO1xuZXhwb3J0IGNvbnN0IF9OID0gY3VydmUubjtcbmV4cG9ydCBjb25zdCBfUCA9IGN1cnZlLnA7XG5leHBvcnQgY29uc3QgX0cgPSB7IHg6IGN1cnZlLkd4LCB5OiBjdXJ2ZS5HeSB9O1xuZXhwb3J0IGNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmV4cG9ydCBjb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5leHBvcnQgY29uc3QgXzJuID0gQmlnSW50KDIpO1xuZXhwb3J0IGNvbnN0IF8zbiA9IEJpZ0ludCgzKTtcbmV4cG9ydCBjb25zdCBfNG4gPSBCaWdJbnQoNCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/const.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONST: () => (/* reexport module object */ _const_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   Field: () => (/* reexport safe */ _lib_ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field),\n/* harmony export */   Point: () => (/* reexport safe */ _lib_ecc_js__WEBPACK_IMPORTED_MODULE_1__.Point),\n/* harmony export */   assert: () => (/* reexport module object */ _assert_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   cipher: () => (/* reexport module object */ _lib_cipher_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   hash: () => (/* reexport module object */ _lib_hash_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   hd: () => (/* reexport module object */ _lib_hd_js__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   keys: () => (/* reexport module object */ _lib_keys_js__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   math: () => (/* reexport module object */ _lib_math_js__WEBPACK_IMPORTED_MODULE_9__),\n/* harmony export */   merkle: () => (/* reexport module object */ _lib_merkle_js__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   shamir: () => (/* reexport module object */ _lib_shamir_js__WEBPACK_IMPORTED_MODULE_12__),\n/* harmony export */   signer: () => (/* reexport module object */ _lib_sig_js__WEBPACK_IMPORTED_MODULE_11__),\n/* harmony export */   util: () => (/* reexport module object */ _util_js__WEBPACK_IMPORTED_MODULE_13__)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _lib_ecc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/ecc.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/types.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/assert.js\");\n/* harmony import */ var _lib_cipher_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/cipher.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/cipher.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/const.js\");\n/* harmony import */ var _lib_hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/hash.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/hash.js\");\n/* harmony import */ var _lib_hd_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/hd.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/hd.js\");\n/* harmony import */ var _lib_keys_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/keys.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/keys.js\");\n/* harmony import */ var _lib_math_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/math.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/math.js\");\n/* harmony import */ var _lib_merkle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/merkle.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/merkle.js\");\n/* harmony import */ var _lib_sig_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/sig.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/sig.js\");\n/* harmony import */ var _lib_shamir_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/shamir.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/shamir.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/util.js\");\n\nconst noble = { secp: _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1, schnorr: _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr };\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUM5RCxnQkFBZ0IsSUFBSSx5RUFBUztBQUNQO0FBQ0Y7QUFDVztBQUNJO0FBQ047QUFDRTtBQUNKO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNSO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvaW5kZXguanM/MzA1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWNwMjU2azEgYXMgc2VjcCwgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmV4cG9ydCBjb25zdCBub2JsZSA9IHsgc2VjcCwgc2Nobm9yciB9O1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZWNjLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMuanMnO1xuZXhwb3J0ICogYXMgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0LmpzJztcbmV4cG9ydCAqIGFzIGNpcGhlciBmcm9tICcuL2xpYi9jaXBoZXIuanMnO1xuZXhwb3J0ICogYXMgQ09OU1QgZnJvbSAnLi9jb25zdC5qcyc7XG5leHBvcnQgKiBhcyBoYXNoIGZyb20gJy4vbGliL2hhc2guanMnO1xuZXhwb3J0ICogYXMgaGQgZnJvbSAnLi9saWIvaGQuanMnO1xuZXhwb3J0ICogYXMga2V5cyBmcm9tICcuL2xpYi9rZXlzLmpzJztcbmV4cG9ydCAqIGFzIG1hdGggZnJvbSAnLi9saWIvbWF0aC5qcyc7XG5leHBvcnQgKiBhcyBtZXJrbGUgZnJvbSAnLi9saWIvbWVya2xlLmpzJztcbmV4cG9ydCAqIGFzIHNpZ25lciBmcm9tICcuL2xpYi9zaWcuanMnO1xuZXhwb3J0ICogYXMgc2hhbWlyIGZyb20gJy4vbGliL3NoYW1pci5qcyc7XG5leHBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbC5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/cipher.js":
/*!***************************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/cipher.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt_cbc: () => (/* binding */ decrypt_cbc),\n/* harmony export */   decrypt_gcm: () => (/* binding */ decrypt_gcm),\n/* harmony export */   encrypt_cbc: () => (/* binding */ encrypt_cbc),\n/* harmony export */   encrypt_gcm: () => (/* binding */ encrypt_gcm)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/ciphers/aes */ \"(ssr)/./node_modules/@noble/ciphers/esm/aes.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/assert.js\");\n\n\n\nfunction decrypt_cbc(payload, secret, vector) {\n    const dat = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(payload);\n    const sec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(secret);\n    const vec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(vector);\n    _assert_js__WEBPACK_IMPORTED_MODULE_2__.size(vec, 16);\n    const dec = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_1__.cbc)(sec, vec).decrypt(dat);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(dec);\n}\nfunction encrypt_cbc(payload, secret, vector) {\n    const dat = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(payload);\n    const sec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(secret);\n    const vec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(vector);\n    _assert_js__WEBPACK_IMPORTED_MODULE_2__.size(vec, 16);\n    const enc = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_1__.cbc)(sec, vec).encrypt(dat);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(enc);\n}\nfunction decrypt_gcm(payload, secret, vector) {\n    const dat = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(payload);\n    const sec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(secret);\n    const vec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(vector);\n    _assert_js__WEBPACK_IMPORTED_MODULE_2__.size(vec, 12);\n    const dec = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_1__.gcm)(sec, vec).decrypt(dat);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(dec);\n}\nfunction encrypt_gcm(payload, secret, vector) {\n    const dat = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(payload);\n    const sec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(secret);\n    const vec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(vector);\n    _assert_js__WEBPACK_IMPORTED_MODULE_2__.size(vec, 12);\n    const enc = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_1__.gcm)(sec, vec).encrypt(dat);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(enc);\n}\n//# sourceMappingURL=cipher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL2NpcGhlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFDO0FBQ1M7QUFDUDtBQUNoQztBQUNQLGdCQUFnQiwrQ0FBSTtBQUNwQixnQkFBZ0IsK0NBQUk7QUFDcEIsZ0JBQWdCLCtDQUFJO0FBQ3BCLElBQUksNENBQVc7QUFDZixnQkFBZ0IsdURBQUc7QUFDbkIsV0FBVywrQ0FBSTtBQUNmO0FBQ087QUFDUCxnQkFBZ0IsK0NBQUk7QUFDcEIsZ0JBQWdCLCtDQUFJO0FBQ3BCLGdCQUFnQiwrQ0FBSTtBQUNwQixJQUFJLDRDQUFXO0FBQ2YsZ0JBQWdCLHVEQUFHO0FBQ25CLFdBQVcsK0NBQUk7QUFDZjtBQUNPO0FBQ1AsZ0JBQWdCLCtDQUFJO0FBQ3BCLGdCQUFnQiwrQ0FBSTtBQUNwQixnQkFBZ0IsK0NBQUk7QUFDcEIsSUFBSSw0Q0FBVztBQUNmLGdCQUFnQix1REFBRztBQUNuQixXQUFXLCtDQUFJO0FBQ2Y7QUFDTztBQUNQLGdCQUFnQiwrQ0FBSTtBQUNwQixnQkFBZ0IsK0NBQUk7QUFDcEIsZ0JBQWdCLCtDQUFJO0FBQ3BCLElBQUksNENBQVc7QUFDZixnQkFBZ0IsdURBQUc7QUFDbkIsV0FBVywrQ0FBSTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdG9vbHMvZGlzdC9saWIvY2lwaGVyLmpzPzBkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZiB9IGZyb20gJ0BjbWRjb2RlL2J1ZmYnO1xuaW1wb3J0IHsgY2JjLCBnY20gfSBmcm9tICdAbm9ibGUvY2lwaGVycy9hZXMnO1xuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJy4uL2Fzc2VydC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdF9jYmMocGF5bG9hZCwgc2VjcmV0LCB2ZWN0b3IpIHtcbiAgICBjb25zdCBkYXQgPSBCdWZmLmJ5dGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHNlYyA9IEJ1ZmYuYnl0ZXMoc2VjcmV0KTtcbiAgICBjb25zdCB2ZWMgPSBCdWZmLmJ5dGVzKHZlY3Rvcik7XG4gICAgYXNzZXJ0LnNpemUodmVjLCAxNik7XG4gICAgY29uc3QgZGVjID0gY2JjKHNlYywgdmVjKS5kZWNyeXB0KGRhdCk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KGRlYyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jcnlwdF9jYmMocGF5bG9hZCwgc2VjcmV0LCB2ZWN0b3IpIHtcbiAgICBjb25zdCBkYXQgPSBCdWZmLmJ5dGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHNlYyA9IEJ1ZmYuYnl0ZXMoc2VjcmV0KTtcbiAgICBjb25zdCB2ZWMgPSBCdWZmLmJ5dGVzKHZlY3Rvcik7XG4gICAgYXNzZXJ0LnNpemUodmVjLCAxNik7XG4gICAgY29uc3QgZW5jID0gY2JjKHNlYywgdmVjKS5lbmNyeXB0KGRhdCk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KGVuYyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdF9nY20ocGF5bG9hZCwgc2VjcmV0LCB2ZWN0b3IpIHtcbiAgICBjb25zdCBkYXQgPSBCdWZmLmJ5dGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHNlYyA9IEJ1ZmYuYnl0ZXMoc2VjcmV0KTtcbiAgICBjb25zdCB2ZWMgPSBCdWZmLmJ5dGVzKHZlY3Rvcik7XG4gICAgYXNzZXJ0LnNpemUodmVjLCAxMik7XG4gICAgY29uc3QgZGVjID0gZ2NtKHNlYywgdmVjKS5kZWNyeXB0KGRhdCk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KGRlYyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jcnlwdF9nY20ocGF5bG9hZCwgc2VjcmV0LCB2ZWN0b3IpIHtcbiAgICBjb25zdCBkYXQgPSBCdWZmLmJ5dGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHNlYyA9IEJ1ZmYuYnl0ZXMoc2VjcmV0KTtcbiAgICBjb25zdCB2ZWMgPSBCdWZmLmJ5dGVzKHZlY3Rvcik7XG4gICAgYXNzZXJ0LnNpemUodmVjLCAxMik7XG4gICAgY29uc3QgZW5jID0gZ2NtKHNlYywgdmVjKS5lbmNyeXB0KGRhdCk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KGVuYyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaXBoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/cipher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/ecc.js":
/*!************************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/ecc.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   Point: () => (/* binding */ Point)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/const.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/math.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/assert.js\");\n\n\n\n\n\nconst NoblePoint = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.ProjectivePoint;\nclass Field extends Uint8Array {\n    static { this.N = _const_js__WEBPACK_IMPORTED_MODULE_1__._N; }\n    static add(x) {\n        return x.map(e => Field.mod(e)).reduce((p, n) => p.add(n));\n    }\n    static mod(x) {\n        return new Field(x);\n    }\n    static mul(x) {\n        return x.map(e => Field.mod(e)).reduce((p, n) => p.mul(n));\n    }\n    static is_valid(value, throws) {\n        const big = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(value, 32).big;\n        return _assert_js__WEBPACK_IMPORTED_MODULE_3__.in_field(big, throws);\n    }\n    static random() {\n        return Field.mod(_cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.random(32));\n    }\n    constructor(x) {\n        const b = _math_js__WEBPACK_IMPORTED_MODULE_2__.mod_n(normalizeField(x));\n        Field.is_valid(b, true);\n        super(_cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.big(b, 32), 32);\n    }\n    get buff() {\n        return new _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff(this);\n    }\n    get raw() {\n        return this.buff.raw;\n    }\n    get big() {\n        return this.buff.big;\n    }\n    get hex() {\n        return this.buff.hex;\n    }\n    get point() {\n        return this.generate();\n    }\n    get hasOddY() {\n        return this.point.hasOddY;\n    }\n    get negated() {\n        return (this.hasOddY)\n            ? this.negate()\n            : this;\n    }\n    gt(value) {\n        const x = new Field(value);\n        return x.big > this.big;\n    }\n    lt(value) {\n        const x = new Field(value);\n        return x.big < this.big;\n    }\n    eq(value) {\n        const x = new Field(value);\n        return x.big === this.big;\n    }\n    ne(value) {\n        const x = new Field(value);\n        return x.big !== this.big;\n    }\n    add(value) {\n        const x = Field.mod(value);\n        const a = _math_js__WEBPACK_IMPORTED_MODULE_2__.fd.add(this.big, x.big);\n        return new Field(a);\n    }\n    sub(value) {\n        const x = Field.mod(value);\n        const a = _math_js__WEBPACK_IMPORTED_MODULE_2__.fd.sub(this.big, x.big);\n        return new Field(a);\n    }\n    mul(value) {\n        const x = Field.mod(value);\n        const a = _math_js__WEBPACK_IMPORTED_MODULE_2__.fd.mul(this.big, x.big);\n        return new Field(a);\n    }\n    pow(value) {\n        const x = Field.mod(value);\n        const a = _math_js__WEBPACK_IMPORTED_MODULE_2__.fd.pow(this.big, x.big);\n        return new Field(a);\n    }\n    div(value) {\n        const x = Field.mod(value);\n        const a = _math_js__WEBPACK_IMPORTED_MODULE_2__.fd.div(this.big, x.big);\n        return new Field(a);\n    }\n    negate() {\n        return new Field(Field.N - this.big);\n    }\n    generate() {\n        const base = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.ProjectivePoint.BASE;\n        const point = base.multiply(this.big);\n        return Point.import(point);\n    }\n}\nclass Point {\n    static { this.P = _const_js__WEBPACK_IMPORTED_MODULE_1__._P; }\n    static { this.G = new Point(_const_js__WEBPACK_IMPORTED_MODULE_1__._G.x, _const_js__WEBPACK_IMPORTED_MODULE_1__._G.y); }\n    static { this.curve = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.CURVE; }\n    static { this.base = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.ProjectivePoint.BASE; }\n    static from_x(bytes, even_y = false) {\n        let cp = normalizePoint(bytes);\n        if (cp.length === 32) {\n            cp = cp.prepend(0x02);\n        }\n        else if (even_y) {\n            cp[0] = 0x02;\n        }\n        _assert_js__WEBPACK_IMPORTED_MODULE_3__.size(cp, 33);\n        const point = NoblePoint.fromHex(cp.hex);\n        point.assertValidity();\n        return new Point(point.x, point.y);\n    }\n    static generate(value) {\n        const field = Field.mod(value);\n        const point = Point.base.multiply(field.big);\n        return Point.import(point);\n    }\n    static { this.mul = Point.generate; }\n    static import(point) {\n        const p = (point instanceof Point)\n            ? { x: point.x.big, y: point.y.big }\n            : { x: point.x, y: point.y };\n        return new Point(p.x, p.y);\n    }\n    constructor(x, y) {\n        this._p = new NoblePoint(x, y, 1n);\n        this.p.assertValidity();\n    }\n    get p() {\n        return this._p;\n    }\n    get x() {\n        return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.big(this.p.x, 32);\n    }\n    get y() {\n        return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.big(this.p.y, 32);\n    }\n    get buff() {\n        return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(this.p.toRawBytes(true));\n    }\n    get raw() {\n        return this.buff.raw;\n    }\n    get hex() {\n        return this.buff.hex;\n    }\n    get hasEvenY() {\n        return this.p.hasEvenY();\n    }\n    get hasOddY() {\n        return !this.p.hasEvenY();\n    }\n    get negated() {\n        return (this.hasOddY)\n            ? this.negate()\n            : this;\n    }\n    eq(value) {\n        const p = (value instanceof Point) ? value : Point.from_x(value);\n        return this.x.big === p.x.big && this.y.big === p.y.big;\n    }\n    add(x) {\n        return (x instanceof Point)\n            ? Point.import(this.p.add(x.p))\n            : Point.import(this.p.add(Point.generate(x).p));\n    }\n    sub(x) {\n        return (x instanceof Point)\n            ? Point.import(this.p.subtract(x.p))\n            : Point.import(this.p.subtract(Point.generate(x).p));\n    }\n    mul(value) {\n        return (value instanceof Point)\n            ? Point.import(this.p.multiply(value.x.big))\n            : Point.import(this.p.multiply(Field.mod(value).big));\n    }\n    negate() {\n        return Point.import(this.p.negate());\n    }\n}\nfunction normalizeField(value) {\n    if (value instanceof Field) {\n        return value.big;\n    }\n    if (value instanceof Point) {\n        return value.x.big;\n    }\n    if (value instanceof Uint8Array) {\n        return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(value).big;\n    }\n    if (typeof value === 'string') {\n        return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.hex(value).big;\n    }\n    if (typeof value === 'number') {\n        return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.num(value).big;\n    }\n    if (typeof value === 'bigint') {\n        return BigInt(value);\n    }\n    throw TypeError('Invalid input type:' + typeof value);\n}\nfunction normalizePoint(value) {\n    if (value instanceof Field) {\n        return value.point.buff;\n    }\n    if (value instanceof Point) {\n        return value.buff;\n    }\n    if (value instanceof Uint8Array ||\n        typeof value === 'string') {\n        return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(value);\n    }\n    if (typeof value === 'number' ||\n        typeof value === 'bigint') {\n        return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(value, 32);\n    }\n    throw new TypeError(`Unknown type: ${typeof value}`);\n}\n//# sourceMappingURL=ecc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL2VjYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFDO0FBQ2U7QUFDWDtBQUNQO0FBQ0s7QUFDdkMsbUJBQW1CLDhEQUFTO0FBQ3JCO0FBQ1AsYUFBYSxTQUFTLHlDQUFFO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFJO0FBQ3hCLGVBQWUsZ0RBQWU7QUFDOUI7QUFDQTtBQUNBLHlCQUF5QiwrQ0FBSTtBQUM3QjtBQUNBO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCO0FBQ0EsY0FBYywrQ0FBSTtBQUNsQjtBQUNBO0FBQ0EsbUJBQW1CLCtDQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGFBQWEsU0FBUyx5Q0FBRTtBQUN4QixhQUFhLG1CQUFtQix5Q0FBRSxJQUFJLHlDQUFFO0FBQ3hDLGFBQWEsYUFBYSw4REFBUztBQUNuQyxhQUFhLFlBQVksOERBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQ0FBSTtBQUNuQjtBQUNBO0FBQ0EsZUFBZSwrQ0FBSTtBQUNuQjtBQUNBO0FBQ0EsZUFBZSwrQ0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0NBQUk7QUFDbkI7QUFDQTtBQUNBLGVBQWUsK0NBQUk7QUFDbkI7QUFDQTtBQUNBLGVBQWUsK0NBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQ0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtDQUFJO0FBQ25CO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2NyeXB0by10b29scy9kaXN0L2xpYi9lY2MuanM/OWQ2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmIH0gZnJvbSAnQGNtZGNvZGUvYnVmZic7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgeyBfTiwgX1AsIF9HIH0gZnJvbSAnLi4vY29uc3QuanMnO1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJy4uL2Fzc2VydC5qcyc7XG5jb25zdCBOb2JsZVBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmV4cG9ydCBjbGFzcyBGaWVsZCBleHRlbmRzIFVpbnQ4QXJyYXkge1xuICAgIHN0YXRpYyB7IHRoaXMuTiA9IF9OOyB9XG4gICAgc3RhdGljIGFkZCh4KSB7XG4gICAgICAgIHJldHVybiB4Lm1hcChlID0+IEZpZWxkLm1vZChlKSkucmVkdWNlKChwLCBuKSA9PiBwLmFkZChuKSk7XG4gICAgfVxuICAgIHN0YXRpYyBtb2QoeCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkKHgpO1xuICAgIH1cbiAgICBzdGF0aWMgbXVsKHgpIHtcbiAgICAgICAgcmV0dXJuIHgubWFwKGUgPT4gRmllbGQubW9kKGUpKS5yZWR1Y2UoKHAsIG4pID0+IHAubXVsKG4pKTtcbiAgICB9XG4gICAgc3RhdGljIGlzX3ZhbGlkKHZhbHVlLCB0aHJvd3MpIHtcbiAgICAgICAgY29uc3QgYmlnID0gQnVmZi5ieXRlcyh2YWx1ZSwgMzIpLmJpZztcbiAgICAgICAgcmV0dXJuIGFzc2VydC5pbl9maWVsZChiaWcsIHRocm93cyk7XG4gICAgfVxuICAgIHN0YXRpYyByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBGaWVsZC5tb2QoQnVmZi5yYW5kb20oMzIpKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeCkge1xuICAgICAgICBjb25zdCBiID0gbWF0aC5tb2Rfbihub3JtYWxpemVGaWVsZCh4KSk7XG4gICAgICAgIEZpZWxkLmlzX3ZhbGlkKGIsIHRydWUpO1xuICAgICAgICBzdXBlcihCdWZmLmJpZyhiLCAzMiksIDMyKTtcbiAgICB9XG4gICAgZ2V0IGJ1ZmYoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZih0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHJhdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZi5yYXc7XG4gICAgfVxuICAgIGdldCBiaWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmYuYmlnO1xuICAgIH1cbiAgICBnZXQgaGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmLmhleDtcbiAgICB9XG4gICAgZ2V0IHBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpO1xuICAgIH1cbiAgICBnZXQgaGFzT2RkWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnQuaGFzT2RkWTtcbiAgICB9XG4gICAgZ2V0IG5lZ2F0ZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5oYXNPZGRZKVxuICAgICAgICAgICAgPyB0aGlzLm5lZ2F0ZSgpXG4gICAgICAgICAgICA6IHRoaXM7XG4gICAgfVxuICAgIGd0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHggPSBuZXcgRmllbGQodmFsdWUpO1xuICAgICAgICByZXR1cm4geC5iaWcgPiB0aGlzLmJpZztcbiAgICB9XG4gICAgbHQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeCA9IG5ldyBGaWVsZCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB4LmJpZyA8IHRoaXMuYmlnO1xuICAgIH1cbiAgICBlcSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gbmV3IEZpZWxkKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHguYmlnID09PSB0aGlzLmJpZztcbiAgICB9XG4gICAgbmUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeCA9IG5ldyBGaWVsZCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB4LmJpZyAhPT0gdGhpcy5iaWc7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYSA9IG1hdGguZmQuYWRkKHRoaXMuYmlnLCB4LmJpZyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoYSk7XG4gICAgfVxuICAgIHN1Yih2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYSA9IG1hdGguZmQuc3ViKHRoaXMuYmlnLCB4LmJpZyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoYSk7XG4gICAgfVxuICAgIG11bCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYSA9IG1hdGguZmQubXVsKHRoaXMuYmlnLCB4LmJpZyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoYSk7XG4gICAgfVxuICAgIHBvdyh2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYSA9IG1hdGguZmQucG93KHRoaXMuYmlnLCB4LmJpZyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoYSk7XG4gICAgfVxuICAgIGRpdih2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYSA9IG1hdGguZmQuZGl2KHRoaXMuYmlnLCB4LmJpZyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoYSk7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZChGaWVsZC5OIC0gdGhpcy5iaWcpO1xuICAgIH1cbiAgICBnZW5lcmF0ZSgpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuQkFTRTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBiYXNlLm11bHRpcGx5KHRoaXMuYmlnKTtcbiAgICAgICAgcmV0dXJuIFBvaW50LmltcG9ydChwb2ludCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFBvaW50IHtcbiAgICBzdGF0aWMgeyB0aGlzLlAgPSBfUDsgfVxuICAgIHN0YXRpYyB7IHRoaXMuRyA9IG5ldyBQb2ludChfRy54LCBfRy55KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuY3VydmUgPSBzZWNwMjU2azEuQ1VSVkU7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJhc2UgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LkJBU0U7IH1cbiAgICBzdGF0aWMgZnJvbV94KGJ5dGVzLCBldmVuX3kgPSBmYWxzZSkge1xuICAgICAgICBsZXQgY3AgPSBub3JtYWxpemVQb2ludChieXRlcyk7XG4gICAgICAgIGlmIChjcC5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgICAgICBjcCA9IGNwLnByZXBlbmQoMHgwMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbl95KSB7XG4gICAgICAgICAgICBjcFswXSA9IDB4MDI7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0LnNpemUoY3AsIDMzKTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBOb2JsZVBvaW50LmZyb21IZXgoY3AuaGV4KTtcbiAgICAgICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBQb2ludC5iYXNlLm11bHRpcGx5KGZpZWxkLmJpZyk7XG4gICAgICAgIHJldHVybiBQb2ludC5pbXBvcnQocG9pbnQpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLm11bCA9IFBvaW50LmdlbmVyYXRlOyB9XG4gICAgc3RhdGljIGltcG9ydChwb2ludCkge1xuICAgICAgICBjb25zdCBwID0gKHBvaW50IGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICA/IHsgeDogcG9pbnQueC5iaWcsIHk6IHBvaW50LnkuYmlnIH1cbiAgICAgICAgICAgIDogeyB4OiBwb2ludC54LCB5OiBwb2ludC55IH07XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQocC54LCBwLnkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgICAgIHRoaXMuX3AgPSBuZXcgTm9ibGVQb2ludCh4LCB5LCAxbik7XG4gICAgICAgIHRoaXMucC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICBnZXQgcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3A7XG4gICAgfVxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gQnVmZi5iaWcodGhpcy5wLngsIDMyKTtcbiAgICB9XG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiBCdWZmLmJpZyh0aGlzLnAueSwgMzIpO1xuICAgIH1cbiAgICBnZXQgYnVmZigpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYucmF3KHRoaXMucC50b1Jhd0J5dGVzKHRydWUpKTtcbiAgICB9XG4gICAgZ2V0IHJhdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZi5yYXc7XG4gICAgfVxuICAgIGdldCBoZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmYuaGV4O1xuICAgIH1cbiAgICBnZXQgaGFzRXZlblkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnAuaGFzRXZlblkoKTtcbiAgICB9XG4gICAgZ2V0IGhhc09kZFkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5wLmhhc0V2ZW5ZKCk7XG4gICAgfVxuICAgIGdldCBuZWdhdGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaGFzT2RkWSlcbiAgICAgICAgICAgID8gdGhpcy5uZWdhdGUoKVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgIH1cbiAgICBlcSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBwID0gKHZhbHVlIGluc3RhbmNlb2YgUG9pbnQpID8gdmFsdWUgOiBQb2ludC5mcm9tX3godmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy54LmJpZyA9PT0gcC54LmJpZyAmJiB0aGlzLnkuYmlnID09PSBwLnkuYmlnO1xuICAgIH1cbiAgICBhZGQoeCkge1xuICAgICAgICByZXR1cm4gKHggaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgID8gUG9pbnQuaW1wb3J0KHRoaXMucC5hZGQoeC5wKSlcbiAgICAgICAgICAgIDogUG9pbnQuaW1wb3J0KHRoaXMucC5hZGQoUG9pbnQuZ2VuZXJhdGUoeCkucCkpO1xuICAgIH1cbiAgICBzdWIoeCkge1xuICAgICAgICByZXR1cm4gKHggaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgID8gUG9pbnQuaW1wb3J0KHRoaXMucC5zdWJ0cmFjdCh4LnApKVxuICAgICAgICAgICAgOiBQb2ludC5pbXBvcnQodGhpcy5wLnN1YnRyYWN0KFBvaW50LmdlbmVyYXRlKHgpLnApKTtcbiAgICB9XG4gICAgbXVsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgID8gUG9pbnQuaW1wb3J0KHRoaXMucC5tdWx0aXBseSh2YWx1ZS54LmJpZykpXG4gICAgICAgICAgICA6IFBvaW50LmltcG9ydCh0aGlzLnAubXVsdGlwbHkoRmllbGQubW9kKHZhbHVlKS5iaWcpKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gUG9pbnQuaW1wb3J0KHRoaXMucC5uZWdhdGUoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRmllbGQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaWVsZCkge1xuICAgICAgICByZXR1cm4gdmFsdWUuYmlnO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICByZXR1cm4gdmFsdWUueC5iaWc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYucmF3KHZhbHVlKS5iaWc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBCdWZmLmhleCh2YWx1ZSkuYmlnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gQnVmZi5udW0odmFsdWUpLmJpZztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlOicgKyB0eXBlb2YgdmFsdWUpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaWVsZCkge1xuICAgICAgICByZXR1cm4gdmFsdWUucG9pbnQuYnVmZjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmJ1ZmY7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQnVmZi5ieXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYuYnl0ZXModmFsdWUsIDMyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5rbm93biB0eXBlOiAke3R5cGVvZiB2YWx1ZX1gKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVjYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/ecc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/hash.js":
/*!*************************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/hash.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hash160: () => (/* binding */ hash160),\n/* harmony export */   hash256: () => (/* binding */ hash256),\n/* harmony export */   hash340: () => (/* binding */ hash340),\n/* harmony export */   hmac256: () => (/* binding */ hmac256),\n/* harmony export */   hmac512: () => (/* binding */ hmac512),\n/* harmony export */   pkdf256: () => (/* binding */ pkdf256),\n/* harmony export */   pkdf512: () => (/* binding */ pkdf512),\n/* harmony export */   ripe160: () => (/* binding */ ripe160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   taghash: () => (/* binding */ taghash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(ssr)/./node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n\n\n\n\n\n\nfunction sha256(...data) {\n    const b = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join(data);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(b));\n}\nfunction sha512(...data) {\n    const b = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join(data);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_2__.sha512)(b));\n}\nfunction ripe160(...data) {\n    const b = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join(data);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(b));\n}\nfunction hash256(...data) {\n    const b = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join(data);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(b)));\n}\nfunction hash160(...data) {\n    const b = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join(data);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(b)));\n}\nfunction hmac256(key, ...data) {\n    const k = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(key);\n    const b = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join(data);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_4__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, k, b));\n}\nfunction hmac512(key, ...data) {\n    const k = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(key);\n    const b = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join(data);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_4__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_2__.sha512, k, b));\n}\nfunction taghash(tag) {\n    const hash = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.str(tag).digest;\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([hash, hash]);\n}\nfunction hash340(tag, ...data) {\n    const hash = taghash(tag);\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([hash, ...data]).digest;\n}\nfunction pkdf256(secret, salt, count = 2048) {\n    const sec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(secret);\n    const slt = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(salt);\n    const key = (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_5__.pbkdf2)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, sec, slt, { c: count, dkLen: 32 });\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(key);\n}\nfunction pkdf512(secret, salt, count = 2048) {\n    const sec = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(secret);\n    const slt = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(salt);\n    const key = (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_5__.pbkdf2)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_2__.sha512, sec, slt, { c: count, dkLen: 64 });\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(key);\n}\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL2hhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDUTtBQUNBO0FBQ007QUFDVjtBQUNiO0FBQzlCO0FBQ1AsY0FBYywrQ0FBSTtBQUNsQixXQUFXLCtDQUFJLEtBQUssNERBQUk7QUFDeEI7QUFDTztBQUNQLGNBQWMsK0NBQUk7QUFDbEIsV0FBVywrQ0FBSSxLQUFLLDREQUFJO0FBQ3hCO0FBQ087QUFDUCxjQUFjLCtDQUFJO0FBQ2xCLFdBQVcsK0NBQUksS0FBSyxrRUFBSTtBQUN4QjtBQUNPO0FBQ1AsY0FBYywrQ0FBSTtBQUNsQixXQUFXLCtDQUFJLEtBQUssNERBQUksQ0FBQyw0REFBSTtBQUM3QjtBQUNPO0FBQ1AsY0FBYywrQ0FBSTtBQUNsQixXQUFXLCtDQUFJLEtBQUssa0VBQUksQ0FBQyw0REFBSTtBQUM3QjtBQUNPO0FBQ1AsY0FBYywrQ0FBSTtBQUNsQixjQUFjLCtDQUFJO0FBQ2xCLFdBQVcsK0NBQUksS0FBSyx3REFBSSxDQUFDLHdEQUFJO0FBQzdCO0FBQ087QUFDUCxjQUFjLCtDQUFJO0FBQ2xCLGNBQWMsK0NBQUk7QUFDbEIsV0FBVywrQ0FBSSxLQUFLLHdEQUFJLENBQUMsd0RBQUk7QUFDN0I7QUFDTztBQUNQLGlCQUFpQiwrQ0FBSTtBQUNyQixXQUFXLCtDQUFJO0FBQ2Y7QUFDTztBQUNQO0FBQ0EsV0FBVywrQ0FBSTtBQUNmO0FBQ087QUFDUCxnQkFBZ0IsK0NBQUk7QUFDcEIsZ0JBQWdCLCtDQUFJO0FBQ3BCLGdCQUFnQiw0REFBTSxDQUFDLHdEQUFJLGNBQWMscUJBQXFCO0FBQzlELFdBQVcsK0NBQUk7QUFDZjtBQUNPO0FBQ1AsZ0JBQWdCLCtDQUFJO0FBQ3BCLGdCQUFnQiwrQ0FBSTtBQUNwQixnQkFBZ0IsNERBQU0sQ0FBQyx3REFBSSxjQUFjLHFCQUFxQjtBQUM5RCxXQUFXLCtDQUFJO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2NyeXB0by10b29scy9kaXN0L2xpYi9oYXNoLmpzP2I4MWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGJrZGYyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9wYmtkZjInO1xuaW1wb3J0IHsgc2hhMjU2IGFzIHMyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyBzaGE1MTIgYXMgczUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhNTEyJztcbmltcG9ydCB7IHJpcGVtZDE2MCBhcyByMTYwIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAnO1xuaW1wb3J0IHsgaG1hYyBhcyBITUFDIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmJztcbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTYoLi4uZGF0YSkge1xuICAgIGNvbnN0IGIgPSBCdWZmLmpvaW4oZGF0YSk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KHMyNTYoYikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYTUxMiguLi5kYXRhKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmYuam9pbihkYXRhKTtcbiAgICByZXR1cm4gQnVmZi5yYXcoczUxMihiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmlwZTE2MCguLi5kYXRhKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmYuam9pbihkYXRhKTtcbiAgICByZXR1cm4gQnVmZi5yYXcocjE2MChiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaDI1NiguLi5kYXRhKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmYuam9pbihkYXRhKTtcbiAgICByZXR1cm4gQnVmZi5yYXcoczI1NihzMjU2KGIpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaDE2MCguLi5kYXRhKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmYuam9pbihkYXRhKTtcbiAgICByZXR1cm4gQnVmZi5yYXcocjE2MChzMjU2KGIpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaG1hYzI1NihrZXksIC4uLmRhdGEpIHtcbiAgICBjb25zdCBrID0gQnVmZi5ieXRlcyhrZXkpO1xuICAgIGNvbnN0IGIgPSBCdWZmLmpvaW4oZGF0YSk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KEhNQUMoczI1NiwgaywgYikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhtYWM1MTIoa2V5LCAuLi5kYXRhKSB7XG4gICAgY29uc3QgayA9IEJ1ZmYuYnl0ZXMoa2V5KTtcbiAgICBjb25zdCBiID0gQnVmZi5qb2luKGRhdGEpO1xuICAgIHJldHVybiBCdWZmLnJhdyhITUFDKHM1MTIsIGssIGIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0YWdoYXNoKHRhZykge1xuICAgIGNvbnN0IGhhc2ggPSBCdWZmLnN0cih0YWcpLmRpZ2VzdDtcbiAgICByZXR1cm4gQnVmZi5qb2luKFtoYXNoLCBoYXNoXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaDM0MCh0YWcsIC4uLmRhdGEpIHtcbiAgICBjb25zdCBoYXNoID0gdGFnaGFzaCh0YWcpO1xuICAgIHJldHVybiBCdWZmLmpvaW4oW2hhc2gsIC4uLmRhdGFdKS5kaWdlc3Q7XG59XG5leHBvcnQgZnVuY3Rpb24gcGtkZjI1NihzZWNyZXQsIHNhbHQsIGNvdW50ID0gMjA0OCkge1xuICAgIGNvbnN0IHNlYyA9IEJ1ZmYuYnl0ZXMoc2VjcmV0KTtcbiAgICBjb25zdCBzbHQgPSBCdWZmLmJ5dGVzKHNhbHQpO1xuICAgIGNvbnN0IGtleSA9IHBia2RmMihzMjU2LCBzZWMsIHNsdCwgeyBjOiBjb3VudCwgZGtMZW46IDMyIH0pO1xuICAgIHJldHVybiBCdWZmLnJhdyhrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBrZGY1MTIoc2VjcmV0LCBzYWx0LCBjb3VudCA9IDIwNDgpIHtcbiAgICBjb25zdCBzZWMgPSBCdWZmLmJ5dGVzKHNlY3JldCk7XG4gICAgY29uc3Qgc2x0ID0gQnVmZi5ieXRlcyhzYWx0KTtcbiAgICBjb25zdCBrZXkgPSBwYmtkZjIoczUxMiwgc2VjLCBzbHQsIHsgYzogY291bnQsIGRrTGVuOiA2NCB9KTtcbiAgICByZXR1cm4gQnVmZi5yYXcoa2V5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/hd.js":
/*!***********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/hd.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   derive_extkey: () => (/* binding */ derive_extkey),\n/* harmony export */   derive_key: () => (/* binding */ derive_key),\n/* harmony export */   derive_pubkey: () => (/* binding */ derive_pubkey),\n/* harmony export */   derive_seckey: () => (/* binding */ derive_seckey),\n/* harmony export */   derive_seed: () => (/* binding */ derive_seed),\n/* harmony export */   encode_extkey: () => (/* binding */ encode_extkey),\n/* harmony export */   generate_code: () => (/* binding */ generate_code),\n/* harmony export */   parse_extkey: () => (/* binding */ parse_extkey),\n/* harmony export */   parse_tweaks: () => (/* binding */ parse_tweaks)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _ecc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/ecc.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hash.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/hash.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/keys.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/assert.js\");\n\n\n\n\n\nconst INT_REGEX = /^[0-9]{0,10}$/, STR_REGEX = /^[0-9a-zA-Z_&?=]{64}$/;\nfunction derive_seed(path, seed) {\n    return derive_key(path, seed, undefined, true);\n}\nfunction derive_seckey(path, seckey, chaincode) {\n    return derive_key(path, seckey, chaincode, true);\n}\nfunction derive_pubkey(path, pubkey, chaincode) {\n    return derive_key(path, pubkey, chaincode, false);\n}\nfunction derive_key(path, input_key, chain_code, is_private = false) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_4__.valid_chain(path, chain_code);\n    const key = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(input_key);\n    let code = (chain_code !== undefined)\n        ? _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(chain_code)\n        : _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.str('Bitcoin seed');\n    let prev = null, seckey = null, pubkey;\n    if (path.startsWith('m')) {\n        const root = generate_code(code, key);\n        code = root[1];\n        seckey = root[0];\n        pubkey = (0,_keys_js__WEBPACK_IMPORTED_MODULE_3__.get_pubkey)(seckey, false);\n    }\n    else if (is_private) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_4__.size(input_key, 32);\n        seckey = key;\n        pubkey = (0,_keys_js__WEBPACK_IMPORTED_MODULE_3__.get_pubkey)(seckey, false);\n    }\n    else {\n        _assert_js__WEBPACK_IMPORTED_MODULE_4__.size(key, 33);\n        pubkey = key;\n    }\n    const tweaks = parse_tweaks(path);\n    for (const [tweak, is_hardened] of tweaks) {\n        const bytes = (is_hardened && seckey !== null)\n            ? _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([0x00, seckey, tweak])\n            : _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([pubkey, tweak]);\n        const [next_key, next_code] = generate_code(code, bytes);\n        code = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(next_code);\n        prev = pubkey;\n        if (seckey !== null) {\n            seckey = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(seckey).add(next_key).buff;\n            pubkey = (0,_keys_js__WEBPACK_IMPORTED_MODULE_3__.get_pubkey)(seckey, false);\n            _assert_js__WEBPACK_IMPORTED_MODULE_4__.in_field(seckey.big, true);\n        }\n        else {\n            pubkey = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Point.from_x(pubkey).add(next_key).buff;\n            _assert_js__WEBPACK_IMPORTED_MODULE_4__.on_curve(pubkey.slice(1).big, true);\n        }\n    }\n    return { seckey, pubkey, code, path, prev };\n}\nfunction parse_tweaks(keypath) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_4__.valid_path(keypath);\n    const tweaks = [];\n    let paths = keypath.split('/');\n    if (paths[0] === 'm' || paths[0] === '') {\n        paths = paths.slice(1);\n    }\n    for (let path of paths) {\n        let is_hardened = false;\n        if (path.slice(-1) === '\\'') {\n            is_hardened = true;\n            path = path.slice(0, -1);\n        }\n        if (path.match(INT_REGEX) !== null) {\n            let index = parseInt(path, 10);\n            _assert_js__WEBPACK_IMPORTED_MODULE_4__.valid_index(index);\n            if (is_hardened)\n                index += 0x80000000;\n            tweaks.push([_cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.num(index, 4), is_hardened]);\n        }\n        else if (path.match(STR_REGEX) !== null) {\n            let index = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.str(path);\n            if (is_hardened)\n                index = index.prepend(0x80);\n            tweaks.push([index.digest, is_hardened]);\n        }\n        else {\n            throw new Error('Invalid path segment:' + path);\n        }\n    }\n    return tweaks;\n}\nfunction generate_code(chain_code, chain_data) {\n    const I = (0,_hash_js__WEBPACK_IMPORTED_MODULE_2__.hmac512)(chain_code, chain_data), IL = I.slice(0, 32), IR = I.slice(32);\n    return [IL, IR];\n}\nfunction encode_extkey(key_link, key_prefix) {\n    const { seckey, pubkey, code, prev, path } = key_link;\n    const prefix = (typeof key_prefix === 'number')\n        ? _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.num(key_prefix, 4)\n        : (seckey !== null) ? 0x0488ade4 : 0x0488b21e;\n    const tweaks = parse_tweaks(path);\n    const tprev = tweaks.at(-1);\n    const depth = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.num(tweaks.length, 1);\n    const fprint = (prev !== null) ? (0,_hash_js__WEBPACK_IMPORTED_MODULE_2__.hash160)(prev).slice(0, 4) : _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.num(0, 4);\n    const index = (tprev !== undefined) ? tprev[0].slice(-4, 4) : _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.num(0, 4);\n    const key = (seckey !== null) ? seckey.prepend(0x00) : pubkey;\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([prefix, depth, fprint, index, code, key]).to_b58chk();\n}\nfunction derive_extkey(keyhex, path = '') {\n    const { code, type, key } = parse_extkey(keyhex);\n    const is_private = (type === 0);\n    const input_key = (is_private) ? key : _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([type, key]);\n    return derive_key(path, input_key, code, is_private);\n}\nfunction parse_extkey(keyhex) {\n    const buffer = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.b58chk(keyhex).stream;\n    const prefix = buffer.read(4).num, depth = buffer.read(1).num, fprint = buffer.read(4).num, index = buffer.read(4).num, code = buffer.read(32).hex, type = buffer.read(1).num, key = buffer.read(32).hex, seckey = (type === 0) ? key : undefined, pubkey = (type === 0) ? (0,_keys_js__WEBPACK_IMPORTED_MODULE_3__.get_pubkey)(key).hex : _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([type, key]).hex;\n    if (buffer.size > 0) {\n        throw new TypeError('Unparsed data remaining in buffer!');\n    }\n    return { prefix, depth, fprint, index, code, type, key, seckey, pubkey };\n}\n//# sourceMappingURL=hd.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL2hkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0c7QUFDSztBQUNOO0FBQ0E7QUFDdkMsMEJBQTBCLEtBQUssa0NBQWtDLEdBQUc7QUFDN0Q7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUCxJQUFJLG1EQUFrQjtBQUN0QixnQkFBZ0IsK0NBQUk7QUFDcEI7QUFDQSxVQUFVLCtDQUFJO0FBQ2QsVUFBVSwrQ0FBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQVU7QUFDM0I7QUFDQTtBQUNBLFFBQVEsNENBQVc7QUFDbkI7QUFDQSxpQkFBaUIsb0RBQVU7QUFDM0I7QUFDQTtBQUNBLFFBQVEsNENBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQUk7QUFDbEIsY0FBYywrQ0FBSTtBQUNsQjtBQUNBLGVBQWUsK0NBQUk7QUFDbkI7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBSztBQUMxQixxQkFBcUIsb0RBQVU7QUFDL0IsWUFBWSxnREFBZTtBQUMzQjtBQUNBO0FBQ0EscUJBQXFCLDBDQUFLO0FBQzFCLFlBQVksZ0RBQWU7QUFDM0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsSUFBSSxrREFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFrQjtBQUM5QjtBQUNBO0FBQ0EseUJBQXlCLCtDQUFJO0FBQzdCO0FBQ0E7QUFDQSx3QkFBd0IsK0NBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGNBQWMsaURBQU87QUFDckI7QUFDQTtBQUNPO0FBQ1AsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQSxVQUFVLCtDQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtDQUFJO0FBQ3RCLHFDQUFxQyxpREFBTyxxQkFBcUIsK0NBQUk7QUFDckUsa0VBQWtFLCtDQUFJO0FBQ3RFO0FBQ0EsV0FBVywrQ0FBSTtBQUNmO0FBQ087QUFDUCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBLDJDQUEyQywrQ0FBSTtBQUMvQztBQUNBO0FBQ087QUFDUCxtQkFBbUIsK0NBQUk7QUFDdkIsK1FBQStRLG9EQUFVLFlBQVksK0NBQUk7QUFDelM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdG9vbHMvZGlzdC9saWIvaGQuanM/MDc5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmIH0gZnJvbSAnQGNtZGNvZGUvYnVmZic7XG5pbXBvcnQgeyBGaWVsZCwgUG9pbnQgfSBmcm9tICcuL2VjYy5qcyc7XG5pbXBvcnQgeyBoYXNoMTYwLCBobWFjNTEyIH0gZnJvbSAnLi9oYXNoLmpzJztcbmltcG9ydCB7IGdldF9wdWJrZXkgfSBmcm9tICcuL2tleXMuanMnO1xuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJy4uL2Fzc2VydC5qcyc7XG5jb25zdCBJTlRfUkVHRVggPSAvXlswLTldezAsMTB9JC8sIFNUUl9SRUdFWCA9IC9eWzAtOWEtekEtWl8mPz1dezY0fSQvO1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZV9zZWVkKHBhdGgsIHNlZWQpIHtcbiAgICByZXR1cm4gZGVyaXZlX2tleShwYXRoLCBzZWVkLCB1bmRlZmluZWQsIHRydWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZV9zZWNrZXkocGF0aCwgc2Vja2V5LCBjaGFpbmNvZGUpIHtcbiAgICByZXR1cm4gZGVyaXZlX2tleShwYXRoLCBzZWNrZXksIGNoYWluY29kZSwgdHJ1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlX3B1YmtleShwYXRoLCBwdWJrZXksIGNoYWluY29kZSkge1xuICAgIHJldHVybiBkZXJpdmVfa2V5KHBhdGgsIHB1YmtleSwgY2hhaW5jb2RlLCBmYWxzZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlX2tleShwYXRoLCBpbnB1dF9rZXksIGNoYWluX2NvZGUsIGlzX3ByaXZhdGUgPSBmYWxzZSkge1xuICAgIGFzc2VydC52YWxpZF9jaGFpbihwYXRoLCBjaGFpbl9jb2RlKTtcbiAgICBjb25zdCBrZXkgPSBCdWZmLmJ5dGVzKGlucHV0X2tleSk7XG4gICAgbGV0IGNvZGUgPSAoY2hhaW5fY29kZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IEJ1ZmYuYnl0ZXMoY2hhaW5fY29kZSlcbiAgICAgICAgOiBCdWZmLnN0cignQml0Y29pbiBzZWVkJyk7XG4gICAgbGV0IHByZXYgPSBudWxsLCBzZWNrZXkgPSBudWxsLCBwdWJrZXk7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnbScpKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBnZW5lcmF0ZV9jb2RlKGNvZGUsIGtleSk7XG4gICAgICAgIGNvZGUgPSByb290WzFdO1xuICAgICAgICBzZWNrZXkgPSByb290WzBdO1xuICAgICAgICBwdWJrZXkgPSBnZXRfcHVia2V5KHNlY2tleSwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc19wcml2YXRlKSB7XG4gICAgICAgIGFzc2VydC5zaXplKGlucHV0X2tleSwgMzIpO1xuICAgICAgICBzZWNrZXkgPSBrZXk7XG4gICAgICAgIHB1YmtleSA9IGdldF9wdWJrZXkoc2Vja2V5LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnQuc2l6ZShrZXksIDMzKTtcbiAgICAgICAgcHVia2V5ID0ga2V5O1xuICAgIH1cbiAgICBjb25zdCB0d2Vha3MgPSBwYXJzZV90d2Vha3MocGF0aCk7XG4gICAgZm9yIChjb25zdCBbdHdlYWssIGlzX2hhcmRlbmVkXSBvZiB0d2Vha3MpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSAoaXNfaGFyZGVuZWQgJiYgc2Vja2V5ICE9PSBudWxsKVxuICAgICAgICAgICAgPyBCdWZmLmpvaW4oWzB4MDAsIHNlY2tleSwgdHdlYWtdKVxuICAgICAgICAgICAgOiBCdWZmLmpvaW4oW3B1YmtleSwgdHdlYWtdKTtcbiAgICAgICAgY29uc3QgW25leHRfa2V5LCBuZXh0X2NvZGVdID0gZ2VuZXJhdGVfY29kZShjb2RlLCBieXRlcyk7XG4gICAgICAgIGNvZGUgPSBCdWZmLnJhdyhuZXh0X2NvZGUpO1xuICAgICAgICBwcmV2ID0gcHVia2V5O1xuICAgICAgICBpZiAoc2Vja2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZWNrZXkgPSBGaWVsZC5tb2Qoc2Vja2V5KS5hZGQobmV4dF9rZXkpLmJ1ZmY7XG4gICAgICAgICAgICBwdWJrZXkgPSBnZXRfcHVia2V5KHNlY2tleSwgZmFsc2UpO1xuICAgICAgICAgICAgYXNzZXJ0LmluX2ZpZWxkKHNlY2tleS5iaWcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHVia2V5ID0gUG9pbnQuZnJvbV94KHB1YmtleSkuYWRkKG5leHRfa2V5KS5idWZmO1xuICAgICAgICAgICAgYXNzZXJ0Lm9uX2N1cnZlKHB1YmtleS5zbGljZSgxKS5iaWcsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHNlY2tleSwgcHVia2V5LCBjb2RlLCBwYXRoLCBwcmV2IH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VfdHdlYWtzKGtleXBhdGgpIHtcbiAgICBhc3NlcnQudmFsaWRfcGF0aChrZXlwYXRoKTtcbiAgICBjb25zdCB0d2Vha3MgPSBbXTtcbiAgICBsZXQgcGF0aHMgPSBrZXlwYXRoLnNwbGl0KCcvJyk7XG4gICAgaWYgKHBhdGhzWzBdID09PSAnbScgfHwgcGF0aHNbMF0gPT09ICcnKSB7XG4gICAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfVxuICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgbGV0IGlzX2hhcmRlbmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAgIGlzX2hhcmRlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5tYXRjaChJTlRfUkVHRVgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJzZUludChwYXRoLCAxMCk7XG4gICAgICAgICAgICBhc3NlcnQudmFsaWRfaW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGlzX2hhcmRlbmVkKVxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDB4ODAwMDAwMDA7XG4gICAgICAgICAgICB0d2Vha3MucHVzaChbQnVmZi5udW0oaW5kZXgsIDQpLCBpc19oYXJkZW5lZF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGgubWF0Y2goU1RSX1JFR0VYKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gQnVmZi5zdHIocGF0aCk7XG4gICAgICAgICAgICBpZiAoaXNfaGFyZGVuZWQpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleC5wcmVwZW5kKDB4ODApO1xuICAgICAgICAgICAgdHdlYWtzLnB1c2goW2luZGV4LmRpZ2VzdCwgaXNfaGFyZGVuZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRoIHNlZ21lbnQ6JyArIHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0d2Vha3M7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVfY29kZShjaGFpbl9jb2RlLCBjaGFpbl9kYXRhKSB7XG4gICAgY29uc3QgSSA9IGhtYWM1MTIoY2hhaW5fY29kZSwgY2hhaW5fZGF0YSksIElMID0gSS5zbGljZSgwLCAzMiksIElSID0gSS5zbGljZSgzMik7XG4gICAgcmV0dXJuIFtJTCwgSVJdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZV9leHRrZXkoa2V5X2xpbmssIGtleV9wcmVmaXgpIHtcbiAgICBjb25zdCB7IHNlY2tleSwgcHVia2V5LCBjb2RlLCBwcmV2LCBwYXRoIH0gPSBrZXlfbGluaztcbiAgICBjb25zdCBwcmVmaXggPSAodHlwZW9mIGtleV9wcmVmaXggPT09ICdudW1iZXInKVxuICAgICAgICA/IEJ1ZmYubnVtKGtleV9wcmVmaXgsIDQpXG4gICAgICAgIDogKHNlY2tleSAhPT0gbnVsbCkgPyAweDA0ODhhZGU0IDogMHgwNDg4YjIxZTtcbiAgICBjb25zdCB0d2Vha3MgPSBwYXJzZV90d2Vha3MocGF0aCk7XG4gICAgY29uc3QgdHByZXYgPSB0d2Vha3MuYXQoLTEpO1xuICAgIGNvbnN0IGRlcHRoID0gQnVmZi5udW0odHdlYWtzLmxlbmd0aCwgMSk7XG4gICAgY29uc3QgZnByaW50ID0gKHByZXYgIT09IG51bGwpID8gaGFzaDE2MChwcmV2KS5zbGljZSgwLCA0KSA6IEJ1ZmYubnVtKDAsIDQpO1xuICAgIGNvbnN0IGluZGV4ID0gKHRwcmV2ICE9PSB1bmRlZmluZWQpID8gdHByZXZbMF0uc2xpY2UoLTQsIDQpIDogQnVmZi5udW0oMCwgNCk7XG4gICAgY29uc3Qga2V5ID0gKHNlY2tleSAhPT0gbnVsbCkgPyBzZWNrZXkucHJlcGVuZCgweDAwKSA6IHB1YmtleTtcbiAgICByZXR1cm4gQnVmZi5qb2luKFtwcmVmaXgsIGRlcHRoLCBmcHJpbnQsIGluZGV4LCBjb2RlLCBrZXldKS50b19iNThjaGsoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVfZXh0a2V5KGtleWhleCwgcGF0aCA9ICcnKSB7XG4gICAgY29uc3QgeyBjb2RlLCB0eXBlLCBrZXkgfSA9IHBhcnNlX2V4dGtleShrZXloZXgpO1xuICAgIGNvbnN0IGlzX3ByaXZhdGUgPSAodHlwZSA9PT0gMCk7XG4gICAgY29uc3QgaW5wdXRfa2V5ID0gKGlzX3ByaXZhdGUpID8ga2V5IDogQnVmZi5qb2luKFt0eXBlLCBrZXldKTtcbiAgICByZXR1cm4gZGVyaXZlX2tleShwYXRoLCBpbnB1dF9rZXksIGNvZGUsIGlzX3ByaXZhdGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlX2V4dGtleShrZXloZXgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmLmI1OGNoayhrZXloZXgpLnN0cmVhbTtcbiAgICBjb25zdCBwcmVmaXggPSBidWZmZXIucmVhZCg0KS5udW0sIGRlcHRoID0gYnVmZmVyLnJlYWQoMSkubnVtLCBmcHJpbnQgPSBidWZmZXIucmVhZCg0KS5udW0sIGluZGV4ID0gYnVmZmVyLnJlYWQoNCkubnVtLCBjb2RlID0gYnVmZmVyLnJlYWQoMzIpLmhleCwgdHlwZSA9IGJ1ZmZlci5yZWFkKDEpLm51bSwga2V5ID0gYnVmZmVyLnJlYWQoMzIpLmhleCwgc2Vja2V5ID0gKHR5cGUgPT09IDApID8ga2V5IDogdW5kZWZpbmVkLCBwdWJrZXkgPSAodHlwZSA9PT0gMCkgPyBnZXRfcHVia2V5KGtleSkuaGV4IDogQnVmZi5qb2luKFt0eXBlLCBrZXldKS5oZXg7XG4gICAgaWYgKGJ1ZmZlci5zaXplID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnBhcnNlZCBkYXRhIHJlbWFpbmluZyBpbiBidWZmZXIhJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHByZWZpeCwgZGVwdGgsIGZwcmludCwgaW5kZXgsIGNvZGUsIHR5cGUsIGtleSwgc2Vja2V5LCBwdWJrZXkgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/hd.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/keys.js":
/*!*************************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/keys.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convert_32b: () => (/* binding */ convert_32b),\n/* harmony export */   convert_33b: () => (/* binding */ convert_33b),\n/* harmony export */   gen_keypair: () => (/* binding */ gen_keypair),\n/* harmony export */   gen_seckey: () => (/* binding */ gen_seckey),\n/* harmony export */   get_keypair: () => (/* binding */ get_keypair),\n/* harmony export */   get_pubkey: () => (/* binding */ get_pubkey),\n/* harmony export */   get_seckey: () => (/* binding */ get_seckey),\n/* harmony export */   has_key: () => (/* binding */ has_key),\n/* harmony export */   is_even_pub: () => (/* binding */ is_even_pub),\n/* harmony export */   parse_pubkey: () => (/* binding */ parse_pubkey),\n/* harmony export */   sort_keys: () => (/* binding */ sort_keys),\n/* harmony export */   tweak_pubkey: () => (/* binding */ tweak_pubkey),\n/* harmony export */   tweak_seckey: () => (/* binding */ tweak_seckey)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _ecc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/ecc.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/util.js\");\n\n\n\nfunction is_even_pub(pubkey) {\n    const pub = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pubkey);\n    switch (true) {\n        case (pub.length === 32):\n            return true;\n        case (pub.length === 33 && pub[0] === 0x02):\n            return true;\n        case (pub.length === 33 && pub[0] === 0x03):\n            return false;\n        default:\n            throw new TypeError(`Invalid public key: ${pub.hex}`);\n    }\n}\nfunction gen_seckey(even_y) {\n    return get_seckey((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.random)(32), even_y);\n}\nfunction get_seckey(secret, even_y = false) {\n    const sec = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(secret);\n    return (even_y) ? sec.negated.buff : sec.buff;\n}\nfunction get_pubkey(seckey, x_only = false) {\n    const p = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(seckey).point;\n    return (x_only) ? p.x : p.buff;\n}\nfunction tweak_seckey(seckey, tweaks = [], even_y = false) {\n    let sec = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(seckey);\n    for (const twk of tweaks) {\n        sec = sec.add(twk);\n        if (even_y)\n            sec = sec.negated;\n    }\n    return sec.buff;\n}\nfunction tweak_pubkey(pubkey, tweaks = [], x_only = false) {\n    let pub = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Point.from_x(pubkey, x_only);\n    for (const twk of tweaks) {\n        pub = pub.add(twk);\n        if (x_only)\n            pub = pub.negated;\n    }\n    return (x_only) ? pub.x : pub.buff;\n}\nfunction parse_pubkey(pubkey, xonly) {\n    return (xonly)\n        ? convert_32b(pubkey)\n        : convert_33b(pubkey);\n}\nfunction get_keypair(secret, x_only, even_y) {\n    const sec = get_seckey(secret, even_y);\n    const pub = get_pubkey(sec, x_only);\n    return [sec, pub];\n}\nfunction gen_keypair(x_only, even_y) {\n    const sec = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.random)(32);\n    return get_keypair(sec, x_only, even_y);\n}\nfunction convert_32b(pubkey) {\n    const key = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pubkey);\n    if (key.length === 32)\n        return key;\n    if (key.length === 33)\n        return key.slice(1, 33);\n    throw new TypeError(`Invalid key length: ${key.length}`);\n}\nfunction convert_33b(pubkey, even_y = false) {\n    const key = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pubkey);\n    if (key.length === 32) {\n        return key.prepend(0x02);\n    }\n    else if (key.length === 33) {\n        if (even_y)\n            key[0] = 0x02;\n        return key;\n    }\n    throw new TypeError(`Invalid key size: ${key.length}`);\n}\nfunction has_key(key, keys) {\n    const str = keys.map(e => _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(e).hex);\n    return str.includes(_cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(key).hex);\n}\nfunction sort_keys(keys) {\n    return keys\n        .map(e => _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(e).hex)\n        .sort()\n        .map(e => _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.hex(e));\n}\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL2tleXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNHO0FBQ0o7QUFDN0I7QUFDUCxnQkFBZ0IsK0NBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDTztBQUNQLHNCQUFzQixnREFBTTtBQUM1QjtBQUNPO0FBQ1AsZ0JBQWdCLDBDQUFLO0FBQ3JCO0FBQ0E7QUFDTztBQUNQLGNBQWMsMENBQUs7QUFDbkI7QUFDQTtBQUNPO0FBQ1AsY0FBYywwQ0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsY0FBYywwQ0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IsZ0RBQU07QUFDdEI7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLCtDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDTztBQUNQLGdCQUFnQiwrQ0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDTztBQUNQLDhCQUE4QiwrQ0FBSTtBQUNsQyx3QkFBd0IsK0NBQUk7QUFDNUI7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLCtDQUFJO0FBQ3RCO0FBQ0Esa0JBQWtCLCtDQUFJO0FBQ3RCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdG9vbHMvZGlzdC9saWIva2V5cy5qcz83ZDdiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmJztcbmltcG9ydCB7IEZpZWxkLCBQb2ludCB9IGZyb20gJy4vZWNjLmpzJztcbmltcG9ydCB7IHJhbmRvbSB9IGZyb20gJy4uL3V0aWwuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2V2ZW5fcHViKHB1YmtleSkge1xuICAgIGNvbnN0IHB1YiA9IEJ1ZmYuYnl0ZXMocHVia2V5KTtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSAocHViLmxlbmd0aCA9PT0gMzIpOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgKHB1Yi5sZW5ndGggPT09IDMzICYmIHB1YlswXSA9PT0gMHgwMik6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAocHViLmxlbmd0aCA9PT0gMzMgJiYgcHViWzBdID09PSAweDAzKTpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcHVibGljIGtleTogJHtwdWIuaGV4fWApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5fc2Vja2V5KGV2ZW5feSkge1xuICAgIHJldHVybiBnZXRfc2Vja2V5KHJhbmRvbSgzMiksIGV2ZW5feSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0X3NlY2tleShzZWNyZXQsIGV2ZW5feSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VjID0gRmllbGQubW9kKHNlY3JldCk7XG4gICAgcmV0dXJuIChldmVuX3kpID8gc2VjLm5lZ2F0ZWQuYnVmZiA6IHNlYy5idWZmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldF9wdWJrZXkoc2Vja2V5LCB4X29ubHkgPSBmYWxzZSkge1xuICAgIGNvbnN0IHAgPSBGaWVsZC5tb2Qoc2Vja2V5KS5wb2ludDtcbiAgICByZXR1cm4gKHhfb25seSkgPyBwLnggOiBwLmJ1ZmY7XG59XG5leHBvcnQgZnVuY3Rpb24gdHdlYWtfc2Vja2V5KHNlY2tleSwgdHdlYWtzID0gW10sIGV2ZW5feSA9IGZhbHNlKSB7XG4gICAgbGV0IHNlYyA9IEZpZWxkLm1vZChzZWNrZXkpO1xuICAgIGZvciAoY29uc3QgdHdrIG9mIHR3ZWFrcykge1xuICAgICAgICBzZWMgPSBzZWMuYWRkKHR3ayk7XG4gICAgICAgIGlmIChldmVuX3kpXG4gICAgICAgICAgICBzZWMgPSBzZWMubmVnYXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHNlYy5idWZmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR3ZWFrX3B1YmtleShwdWJrZXksIHR3ZWFrcyA9IFtdLCB4X29ubHkgPSBmYWxzZSkge1xuICAgIGxldCBwdWIgPSBQb2ludC5mcm9tX3gocHVia2V5LCB4X29ubHkpO1xuICAgIGZvciAoY29uc3QgdHdrIG9mIHR3ZWFrcykge1xuICAgICAgICBwdWIgPSBwdWIuYWRkKHR3ayk7XG4gICAgICAgIGlmICh4X29ubHkpXG4gICAgICAgICAgICBwdWIgPSBwdWIubmVnYXRlZDtcbiAgICB9XG4gICAgcmV0dXJuICh4X29ubHkpID8gcHViLnggOiBwdWIuYnVmZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZV9wdWJrZXkocHVia2V5LCB4b25seSkge1xuICAgIHJldHVybiAoeG9ubHkpXG4gICAgICAgID8gY29udmVydF8zMmIocHVia2V5KVxuICAgICAgICA6IGNvbnZlcnRfMzNiKHB1YmtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0X2tleXBhaXIoc2VjcmV0LCB4X29ubHksIGV2ZW5feSkge1xuICAgIGNvbnN0IHNlYyA9IGdldF9zZWNrZXkoc2VjcmV0LCBldmVuX3kpO1xuICAgIGNvbnN0IHB1YiA9IGdldF9wdWJrZXkoc2VjLCB4X29ubHkpO1xuICAgIHJldHVybiBbc2VjLCBwdWJdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbl9rZXlwYWlyKHhfb25seSwgZXZlbl95KSB7XG4gICAgY29uc3Qgc2VjID0gcmFuZG9tKDMyKTtcbiAgICByZXR1cm4gZ2V0X2tleXBhaXIoc2VjLCB4X29ubHksIGV2ZW5feSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydF8zMmIocHVia2V5KSB7XG4gICAgY29uc3Qga2V5ID0gQnVmZi5ieXRlcyhwdWJrZXkpO1xuICAgIGlmIChrZXkubGVuZ3RoID09PSAzMilcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMzMpXG4gICAgICAgIHJldHVybiBrZXkuc2xpY2UoMSwgMzMpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQga2V5IGxlbmd0aDogJHtrZXkubGVuZ3RofWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRfMzNiKHB1YmtleSwgZXZlbl95ID0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmLmJ5dGVzKHB1YmtleSk7XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgIHJldHVybiBrZXkucHJlcGVuZCgweDAyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgICAgaWYgKGV2ZW5feSlcbiAgICAgICAgICAgIGtleVswXSA9IDB4MDI7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQga2V5IHNpemU6ICR7a2V5Lmxlbmd0aH1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNfa2V5KGtleSwga2V5cykge1xuICAgIGNvbnN0IHN0ciA9IGtleXMubWFwKGUgPT4gQnVmZi5ieXRlcyhlKS5oZXgpO1xuICAgIHJldHVybiBzdHIuaW5jbHVkZXMoQnVmZi5ieXRlcyhrZXkpLmhleCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc29ydF9rZXlzKGtleXMpIHtcbiAgICByZXR1cm4ga2V5c1xuICAgICAgICAubWFwKGUgPT4gQnVmZi5ieXRlcyhlKS5oZXgpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcChlID0+IEJ1ZmYuaGV4KGUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/math.js":
/*!*************************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/math.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GF: () => (/* binding */ GF),\n/* harmony export */   fd: () => (/* binding */ fd),\n/* harmony export */   in_field: () => (/* binding */ in_field),\n/* harmony export */   invert: () => (/* reexport safe */ _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.invert),\n/* harmony export */   mod: () => (/* reexport safe */ _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod),\n/* harmony export */   mod_bytes: () => (/* binding */ mod_bytes),\n/* harmony export */   mod_n: () => (/* binding */ mod_n),\n/* harmony export */   mod_p: () => (/* binding */ mod_p),\n/* harmony export */   on_curve: () => (/* binding */ on_curve),\n/* harmony export */   pow: () => (/* reexport safe */ _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.pow),\n/* harmony export */   pow2: () => (/* reexport safe */ _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.pow2),\n/* harmony export */   pow_n: () => (/* binding */ pow_n),\n/* harmony export */   pt: () => (/* reexport module object */ _point_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   sqrt_n: () => (/* binding */ sqrt_n),\n/* harmony export */   sqrt_p: () => (/* binding */ sqrt_p)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/const.js\");\n/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/point.js\");\n\n\n\n\n\n\nconst fd = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(_const_js__WEBPACK_IMPORTED_MODULE_1__._N, 32, true);\nconst GF = _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field;\nconst mod_n = (x) => (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(x, _const_js__WEBPACK_IMPORTED_MODULE_1__._N);\nconst mod_p = (x) => (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(x, _const_js__WEBPACK_IMPORTED_MODULE_1__._P);\nconst pow_n = (x, exp) => (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.pow)(x, exp, _const_js__WEBPACK_IMPORTED_MODULE_1__._N);\nconst sqrt_n = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.FpSqrt)(_const_js__WEBPACK_IMPORTED_MODULE_1__._N);\nconst sqrt_p = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.FpSqrt)(_const_js__WEBPACK_IMPORTED_MODULE_1__._P);\nconst on_curve = (x) => {\n    return typeof x === 'bigint' && _const_js__WEBPACK_IMPORTED_MODULE_1__._0n < x && x < _const_js__WEBPACK_IMPORTED_MODULE_1__._P;\n};\nconst in_field = (x) => {\n    return typeof x === 'bigint' && _const_js__WEBPACK_IMPORTED_MODULE_1__._0n < x && x < _const_js__WEBPACK_IMPORTED_MODULE_1__._N;\n};\nfunction mod_bytes(bytes) {\n    const b = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(bytes).big;\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.big(mod_n(b), 32);\n}\n//# sourceMappingURL=math.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL21hdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUMwQjtBQUNMO0FBQ2hCO0FBQytCO0FBQ3hDO0FBQzFCLFdBQVcscUVBQUssQ0FBQyx5Q0FBRTtBQUNuQixXQUFXLGlFQUFLO0FBQ2hCLHFCQUFxQixtRUFBRyxJQUFJLHlDQUFFO0FBQzlCLHFCQUFxQixtRUFBRyxJQUFJLHlDQUFFO0FBQzlCLDBCQUEwQixtRUFBRyxTQUFTLHlDQUFFO0FBQ3hDLGVBQWUsc0VBQU0sQ0FBQyx5Q0FBRTtBQUN4QixlQUFlLHNFQUFNLENBQUMseUNBQUU7QUFDeEI7QUFDUCxvQ0FBb0MsMENBQUcsWUFBWSx5Q0FBRTtBQUNyRDtBQUNPO0FBQ1Asb0NBQW9DLDBDQUFHLFlBQVkseUNBQUU7QUFDckQ7QUFDTztBQUNQLGNBQWMsK0NBQUk7QUFDbEIsV0FBVywrQ0FBSTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdG9vbHMvZGlzdC9saWIvbWF0aC5qcz9kZTUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmJztcbmltcG9ydCB7IEZpZWxkLCBGcFNxcnQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuaW1wb3J0IHsgbW9kLCBwb3cgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuaW1wb3J0IHsgX04sIF9QLCBfMG4gfSBmcm9tICcuLi9jb25zdC5qcyc7XG5leHBvcnQgeyBtb2QsIHBvdywgcG93MiwgaW52ZXJ0LCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG5leHBvcnQgKiBhcyBwdCBmcm9tICcuL3BvaW50LmpzJztcbmV4cG9ydCBjb25zdCBmZCA9IEZpZWxkKF9OLCAzMiwgdHJ1ZSk7XG5leHBvcnQgY29uc3QgR0YgPSBGaWVsZDtcbmV4cG9ydCBjb25zdCBtb2RfbiA9ICh4KSA9PiBtb2QoeCwgX04pO1xuZXhwb3J0IGNvbnN0IG1vZF9wID0gKHgpID0+IG1vZCh4LCBfUCk7XG5leHBvcnQgY29uc3QgcG93X24gPSAoeCwgZXhwKSA9PiBwb3coeCwgZXhwLCBfTik7XG5leHBvcnQgY29uc3Qgc3FydF9uID0gRnBTcXJ0KF9OKTtcbmV4cG9ydCBjb25zdCBzcXJ0X3AgPSBGcFNxcnQoX1ApO1xuZXhwb3J0IGNvbnN0IG9uX2N1cnZlID0gKHgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IF9QO1xufTtcbmV4cG9ydCBjb25zdCBpbl9maWVsZCA9ICh4KSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBfTjtcbn07XG5leHBvcnQgZnVuY3Rpb24gbW9kX2J5dGVzKGJ5dGVzKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmYuYnl0ZXMoYnl0ZXMpLmJpZztcbiAgICByZXR1cm4gQnVmZi5iaWcobW9kX24oYiksIDMyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/merkle.js":
/*!***************************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/merkle.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create_merkle_proof: () => (/* binding */ create_merkle_proof),\n/* harmony export */   encode_branch: () => (/* binding */ encode_branch),\n/* harmony export */   merkleize_tree: () => (/* binding */ merkleize_tree),\n/* harmony export */   verify_merkle_proof: () => (/* binding */ verify_merkle_proof)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hash.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/hash.js\");\n\n\nfunction create_merkle_proof(leaves, target, encoder = encode_branch) {\n    const l = leaves.map(e => _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(e).hex);\n    const t = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(target).hex;\n    const [root, _, path] = merkleize_tree(l, t, [], encoder);\n    return {\n        root: _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.hex(root),\n        path: path.map(e => _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.hex(e))\n    };\n}\nfunction verify_merkle_proof(path, target, root, encoder = encode_branch) {\n    const p = path.map(e => _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(e).hex);\n    let t = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(target).hex;\n    for (const branch of p) {\n        t = encoder(t, branch);\n    }\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.is_equal(root, t);\n}\nfunction merkleize_tree(tree, target = null, path = [], encoder = encode_branch) {\n    const leaves = [];\n    const branches = [];\n    if (tree.length < 1) {\n        throw new Error('Tree is empty!');\n    }\n    for (let i = 0; i < tree.length; i++) {\n        const leaf = tree[i];\n        if (Array.isArray(leaf)) {\n            const [r, t, p] = merkleize_tree(leaf, target);\n            target = t;\n            leaves.push(r);\n            for (const e of p) {\n                path.push(e);\n            }\n        }\n        else {\n            leaves.push(leaf);\n        }\n    }\n    if (leaves.length === 1) {\n        return [leaves[0], target, path];\n    }\n    leaves.sort();\n    if (leaves.length % 2 !== 0) {\n        leaves.push(leaves[leaves.length - 1]);\n    }\n    for (let i = 0; i < leaves.length - 1; i += 2) {\n        const branch = encoder(leaves[i], leaves[i + 1]);\n        branches.push(branch);\n        if (typeof target === 'string') {\n            if (target === leaves[i]) {\n                path.push(leaves[i + 1]);\n                target = branch;\n            }\n            else if (target === leaves[i + 1]) {\n                path.push(leaves[i]);\n                target = branch;\n            }\n        }\n    }\n    return merkleize_tree(branches, target, path);\n}\nfunction encode_branch(a, b) {\n    if (b < a) {\n        [a, b] = [b, a];\n    }\n    return (0,_hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256)(a, b).hex;\n}\n//# sourceMappingURL=merkle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL21lcmtsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUM7QUFDRjtBQUM1QjtBQUNQLDhCQUE4QiwrQ0FBSTtBQUNsQyxjQUFjLCtDQUFJO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjLCtDQUFJO0FBQ2xCLDRCQUE0QiwrQ0FBSTtBQUNoQztBQUNBO0FBQ087QUFDUCw0QkFBNEIsK0NBQUk7QUFDaEMsWUFBWSwrQ0FBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUFJO0FBQ2Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBTTtBQUNqQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL21lcmtsZS5qcz9hYzYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJy4vaGFzaC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX21lcmtsZV9wcm9vZihsZWF2ZXMsIHRhcmdldCwgZW5jb2RlciA9IGVuY29kZV9icmFuY2gpIHtcbiAgICBjb25zdCBsID0gbGVhdmVzLm1hcChlID0+IEJ1ZmYuYnl0ZXMoZSkuaGV4KTtcbiAgICBjb25zdCB0ID0gQnVmZi5ieXRlcyh0YXJnZXQpLmhleDtcbiAgICBjb25zdCBbcm9vdCwgXywgcGF0aF0gPSBtZXJrbGVpemVfdHJlZShsLCB0LCBbXSwgZW5jb2Rlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9vdDogQnVmZi5oZXgocm9vdCksXG4gICAgICAgIHBhdGg6IHBhdGgubWFwKGUgPT4gQnVmZi5oZXgoZSkpXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlfbWVya2xlX3Byb29mKHBhdGgsIHRhcmdldCwgcm9vdCwgZW5jb2RlciA9IGVuY29kZV9icmFuY2gpIHtcbiAgICBjb25zdCBwID0gcGF0aC5tYXAoZSA9PiBCdWZmLmJ5dGVzKGUpLmhleCk7XG4gICAgbGV0IHQgPSBCdWZmLmJ5dGVzKHRhcmdldCkuaGV4O1xuICAgIGZvciAoY29uc3QgYnJhbmNoIG9mIHApIHtcbiAgICAgICAgdCA9IGVuY29kZXIodCwgYnJhbmNoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmYuaXNfZXF1YWwocm9vdCwgdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVya2xlaXplX3RyZWUodHJlZSwgdGFyZ2V0ID0gbnVsbCwgcGF0aCA9IFtdLCBlbmNvZGVyID0gZW5jb2RlX2JyYW5jaCkge1xuICAgIGNvbnN0IGxlYXZlcyA9IFtdO1xuICAgIGNvbnN0IGJyYW5jaGVzID0gW107XG4gICAgaWYgKHRyZWUubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyZWUgaXMgZW1wdHkhJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsZWFmID0gdHJlZVtpXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGVhZikpIHtcbiAgICAgICAgICAgIGNvbnN0IFtyLCB0LCBwXSA9IG1lcmtsZWl6ZV90cmVlKGxlYWYsIHRhcmdldCk7XG4gICAgICAgICAgICB0YXJnZXQgPSB0O1xuICAgICAgICAgICAgbGVhdmVzLnB1c2gocik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgcCkge1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlYXZlcy5wdXNoKGxlYWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbbGVhdmVzWzBdLCB0YXJnZXQsIHBhdGhdO1xuICAgIH1cbiAgICBsZWF2ZXMuc29ydCgpO1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBsZWF2ZXMucHVzaChsZWF2ZXNbbGVhdmVzLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IGJyYW5jaCA9IGVuY29kZXIobGVhdmVzW2ldLCBsZWF2ZXNbaSArIDFdKTtcbiAgICAgICAgYnJhbmNoZXMucHVzaChicmFuY2gpO1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGxlYXZlc1tpXSkge1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaChsZWF2ZXNbaSArIDFdKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBicmFuY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IGxlYXZlc1tpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobGVhdmVzW2ldKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBicmFuY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmtsZWl6ZV90cmVlKGJyYW5jaGVzLCB0YXJnZXQsIHBhdGgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZV9icmFuY2goYSwgYikge1xuICAgIGlmIChiIDwgYSkge1xuICAgICAgICBbYSwgYl0gPSBbYiwgYV07XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoYSwgYikuaGV4O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVya2xlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/merkle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/point.js":
/*!**************************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/point.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Noble: () => (/* binding */ Noble),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   assert_valid: () => (/* binding */ assert_valid),\n/* harmony export */   eq: () => (/* binding */ eq),\n/* harmony export */   gen: () => (/* binding */ gen),\n/* harmony export */   is_even: () => (/* binding */ is_even),\n/* harmony export */   is_point: () => (/* binding */ is_point),\n/* harmony export */   is_valid: () => (/* binding */ is_valid),\n/* harmony export */   lift_x: () => (/* binding */ lift_x),\n/* harmony export */   mul: () => (/* binding */ mul),\n/* harmony export */   negate: () => (/* binding */ negate),\n/* harmony export */   sub: () => (/* binding */ sub),\n/* harmony export */   to_bytes: () => (/* binding */ to_bytes)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/const.js\");\n\n\n\nconst ECPoint = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint;\nconst Noble = ECPoint;\nfunction is_even(p) {\n    const pa = new ECPoint(p.x, p.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    return pa.hasEvenY();\n}\nfunction is_point(point) {\n    const p = point;\n    return ((typeof p === 'object' && p !== null) &&\n        (typeof p.x === 'bigint' && typeof p.y === 'bigint'));\n}\nfunction is_valid(point) {\n    if (!is_point(point))\n        return false;\n    const pt = new ECPoint(point.x, point.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    try {\n        pt.assertValidity();\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction assert_valid(p) {\n    if (!is_valid(p)) {\n        throw new Error('ECC point is invalid: ' + String(p));\n    }\n}\nfunction negate(a) {\n    const pa = new ECPoint(a.x, a.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    try {\n        const pc = pa.negate();\n        pc.assertValidity();\n        return { x: pc.x, y: pc.y };\n    }\n    catch {\n        return null;\n    }\n}\nfunction add(a, b) {\n    if (a === null)\n        return b;\n    if (b === null)\n        return a;\n    const pa = new ECPoint(a.x, a.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    const pb = new ECPoint(b.x, b.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    try {\n        const pc = pa.add(pb);\n        pc.assertValidity();\n        return { x: pc.x, y: pc.y };\n    }\n    catch {\n        return null;\n    }\n}\nfunction sub(a, b) {\n    if (a === null)\n        return b;\n    if (b === null)\n        return a;\n    const pa = new ECPoint(a.x, a.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    const pb = new ECPoint(b.x, b.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    try {\n        const pc = pa.subtract(pb);\n        pc.assertValidity();\n        return { x: pc.x, y: pc.y };\n    }\n    catch {\n        return null;\n    }\n}\nfunction eq(a, b) {\n    if (a === null && b === null) {\n        return true;\n    }\n    if (a !== null && b !== null) {\n        return (a.x === b.x && a.y === b.y);\n    }\n    return false;\n}\nfunction mul(a, b) {\n    if (a === null)\n        return null;\n    try {\n        const buff = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(b);\n        const pa = new ECPoint(a.x, a.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n        const pc = pa.multiply(buff.big);\n        pc.assertValidity();\n        return { x: pc.x, y: pc.y };\n    }\n    catch {\n        return null;\n    }\n}\nfunction gen(b) {\n    const buff = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(b);\n    const base = ECPoint.BASE;\n    const pt = base.multiply(buff.big);\n    pt.assertValidity();\n    return { x: pt.x, y: pt.y };\n}\nfunction lift_x(bytes, xonly = false) {\n    let key = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(bytes);\n    if (key.length === 32) {\n        key = key.prepend(0x02);\n    }\n    if (xonly && key[0] !== 0x02) {\n        key[0] = 0x02;\n    }\n    const point = ECPoint.fromHex(key.hex);\n    point.assertValidity();\n    return { x: point.x, y: point.y };\n}\nfunction to_bytes(p) {\n    const bytes = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.big(p.x, 32);\n    const parity = is_even(p) ? 0x02 : 0x03;\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([parity, bytes]);\n}\n//# sourceMappingURL=point.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL3BvaW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDZTtBQUNsQjtBQUNsQyxnQkFBZ0IsOERBQVM7QUFDbEI7QUFDQTtBQUNQLHFDQUFxQywwQ0FBRztBQUN4QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2QywwQ0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUNBQXFDLDBDQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQ0FBRztBQUN4QyxxQ0FBcUMsMENBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBDQUFHO0FBQ3hDLHFDQUFxQywwQ0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtDQUFJO0FBQ3pCLHlDQUF5QywwQ0FBRztBQUM1QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQiwrQ0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLGNBQWMsK0NBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1Asa0JBQWtCLCtDQUFJO0FBQ3RCO0FBQ0EsV0FBVywrQ0FBSTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdG9vbHMvZGlzdC9saWIvcG9pbnQuanM/OTY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmIH0gZnJvbSAnQGNtZGNvZGUvYnVmZic7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgeyBfMW4gfSBmcm9tICcuLi9jb25zdC5qcyc7XG5jb25zdCBFQ1BvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmV4cG9ydCBjb25zdCBOb2JsZSA9IEVDUG9pbnQ7XG5leHBvcnQgZnVuY3Rpb24gaXNfZXZlbihwKSB7XG4gICAgY29uc3QgcGEgPSBuZXcgRUNQb2ludChwLngsIHAueSwgXzFuKTtcbiAgICByZXR1cm4gcGEuaGFzRXZlblkoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc19wb2ludChwb2ludCkge1xuICAgIGNvbnN0IHAgPSBwb2ludDtcbiAgICByZXR1cm4gKCh0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiYgcCAhPT0gbnVsbCkgJiZcbiAgICAgICAgKHR5cGVvZiBwLnggPT09ICdiaWdpbnQnICYmIHR5cGVvZiBwLnkgPT09ICdiaWdpbnQnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNfdmFsaWQocG9pbnQpIHtcbiAgICBpZiAoIWlzX3BvaW50KHBvaW50KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHB0ID0gbmV3IEVDUG9pbnQocG9pbnQueCwgcG9pbnQueSwgXzFuKTtcbiAgICB0cnkge1xuICAgICAgICBwdC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydF92YWxpZChwKSB7XG4gICAgaWYgKCFpc192YWxpZChwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VDQyBwb2ludCBpcyBpbnZhbGlkOiAnICsgU3RyaW5nKHApKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKGEpIHtcbiAgICBjb25zdCBwYSA9IG5ldyBFQ1BvaW50KGEueCwgYS55LCBfMW4pO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBjID0gcGEubmVnYXRlKCk7XG4gICAgICAgIHBjLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiB7IHg6IHBjLngsIHk6IHBjLnkgfTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgaWYgKGIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBhO1xuICAgIGNvbnN0IHBhID0gbmV3IEVDUG9pbnQoYS54LCBhLnksIF8xbik7XG4gICAgY29uc3QgcGIgPSBuZXcgRUNQb2ludChiLngsIGIueSwgXzFuKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYyA9IHBhLmFkZChwYik7XG4gICAgICAgIHBjLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiB7IHg6IHBjLngsIHk6IHBjLnkgfTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgaWYgKGIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBhO1xuICAgIGNvbnN0IHBhID0gbmV3IEVDUG9pbnQoYS54LCBhLnksIF8xbik7XG4gICAgY29uc3QgcGIgPSBuZXcgRUNQb2ludChiLngsIGIueSwgXzFuKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYyA9IHBhLnN1YnRyYWN0KHBiKTtcbiAgICAgICAgcGMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHsgeDogcGMueCwgeTogcGMueSB9O1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBlcShhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBCdWZmLmJ5dGVzKGIpO1xuICAgICAgICBjb25zdCBwYSA9IG5ldyBFQ1BvaW50KGEueCwgYS55LCBfMW4pO1xuICAgICAgICBjb25zdCBwYyA9IHBhLm11bHRpcGx5KGJ1ZmYuYmlnKTtcbiAgICAgICAgcGMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHsgeDogcGMueCwgeTogcGMueSB9O1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW4oYikge1xuICAgIGNvbnN0IGJ1ZmYgPSBCdWZmLmJ5dGVzKGIpO1xuICAgIGNvbnN0IGJhc2UgPSBFQ1BvaW50LkJBU0U7XG4gICAgY29uc3QgcHQgPSBiYXNlLm11bHRpcGx5KGJ1ZmYuYmlnKTtcbiAgICBwdC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiB7IHg6IHB0LngsIHk6IHB0LnkgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsaWZ0X3goYnl0ZXMsIHhvbmx5ID0gZmFsc2UpIHtcbiAgICBsZXQga2V5ID0gQnVmZi5ieXRlcyhieXRlcyk7XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgIGtleSA9IGtleS5wcmVwZW5kKDB4MDIpO1xuICAgIH1cbiAgICBpZiAoeG9ubHkgJiYga2V5WzBdICE9PSAweDAyKSB7XG4gICAgICAgIGtleVswXSA9IDB4MDI7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ID0gRUNQb2ludC5mcm9tSGV4KGtleS5oZXgpO1xuICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHsgeDogcG9pbnQueCwgeTogcG9pbnQueSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvX2J5dGVzKHApIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmYuYmlnKHAueCwgMzIpO1xuICAgIGNvbnN0IHBhcml0eSA9IGlzX2V2ZW4ocCkgPyAweDAyIDogMHgwMztcbiAgICByZXR1cm4gQnVmZi5qb2luKFtwYXJpdHksIGJ5dGVzXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2ludC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/point.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/shamir.js":
/*!***************************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/shamir.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   combine_shares: () => (/* binding */ combine_shares),\n/* harmony export */   create_shares: () => (/* binding */ create_shares)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/const.js\");\n/* harmony import */ var _ecc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/ecc.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/math.js\");\n\n\n\n\nfunction create_shares(secret, thold, total) {\n    const coeffs = [_ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(secret).big];\n    for (let i = 1; i < thold; i++) {\n        const rand = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.random(32).big;\n        coeffs.push((0,_math_js__WEBPACK_IMPORTED_MODULE_3__.mod_n)(rand));\n    }\n    const shares = [];\n    for (let i = 1; i <= total; i++) {\n        let result = _const_js__WEBPACK_IMPORTED_MODULE_1__._0n;\n        coeffs.forEach((coeff, index) => {\n            const idx = BigInt(i) ** BigInt(index);\n            result += _math_js__WEBPACK_IMPORTED_MODULE_3__.fd.mul(coeff, idx);\n        });\n        const index = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.num(i, 4);\n        const value = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.big(result, 33);\n        const share = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([index, value]);\n        shares.push(share);\n    }\n    return shares;\n}\nfunction combine_shares(shares) {\n    const entries = shares.map(e => {\n        const bytes = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(e);\n        const index = bytes.subarray(0, 4).big;\n        const value = bytes.subarray(4).big;\n        return [index, value];\n    });\n    let secret = _const_js__WEBPACK_IMPORTED_MODULE_1__._0n;\n    for (let i = 0; i < entries.length; i++) {\n        let numer = _const_js__WEBPACK_IMPORTED_MODULE_1__._1n;\n        let denom = _const_js__WEBPACK_IMPORTED_MODULE_1__._1n;\n        for (let j = 0; j < entries.length; j++) {\n            if (i !== j) {\n                numer = (numer * -entries[j][0]) % _const_js__WEBPACK_IMPORTED_MODULE_1__._N;\n                denom = (denom * (entries[i][0] - entries[j][0])) % _const_js__WEBPACK_IMPORTED_MODULE_1__._N;\n            }\n        }\n        if (numer < _const_js__WEBPACK_IMPORTED_MODULE_1__._0n)\n            numer += _const_js__WEBPACK_IMPORTED_MODULE_1__._N;\n        if (denom < _const_js__WEBPACK_IMPORTED_MODULE_1__._0n)\n            denom += _const_js__WEBPACK_IMPORTED_MODULE_1__._N;\n        const coeff = (entries[i][1] * numer * (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.invert)(denom, _const_js__WEBPACK_IMPORTED_MODULE_1__._N)) % _const_js__WEBPACK_IMPORTED_MODULE_1__._N;\n        secret = (secret + coeff) % _const_js__WEBPACK_IMPORTED_MODULE_1__._N;\n    }\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.big(secret, 32);\n}\n//# sourceMappingURL=shamir.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL3NoYW1pci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUM7QUFDTTtBQUNWO0FBQ2E7QUFDdkM7QUFDUCxvQkFBb0IsMENBQUs7QUFDekIsb0JBQW9CLFdBQVc7QUFDL0IscUJBQXFCLCtDQUFJO0FBQ3pCLG9CQUFvQiwrQ0FBSztBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMscUJBQXFCLDBDQUFHO0FBQ3hCO0FBQ0E7QUFDQSxzQkFBc0Isd0NBQUU7QUFDeEIsU0FBUztBQUNULHNCQUFzQiwrQ0FBSTtBQUMxQixzQkFBc0IsK0NBQUk7QUFDMUIsc0JBQXNCLCtDQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNCQUFzQiwrQ0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDBDQUFHO0FBQ3BCLG9CQUFvQixvQkFBb0I7QUFDeEMsb0JBQW9CLDBDQUFHO0FBQ3ZCLG9CQUFvQiwwQ0FBRztBQUN2Qix3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0EsbURBQW1ELHlDQUFFO0FBQ3JELG9FQUFvRSx5Q0FBRTtBQUN0RTtBQUNBO0FBQ0Esb0JBQW9CLDBDQUFHO0FBQ3ZCLHFCQUFxQix5Q0FBRTtBQUN2QixvQkFBb0IsMENBQUc7QUFDdkIscUJBQXFCLHlDQUFFO0FBQ3ZCLCtDQUErQyxnREFBTSxRQUFRLHlDQUFFLEtBQUsseUNBQUU7QUFDdEUsb0NBQW9DLHlDQUFFO0FBQ3RDO0FBQ0EsV0FBVywrQ0FBSTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdG9vbHMvZGlzdC9saWIvc2hhbWlyLmpzPzYwMWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZiB9IGZyb20gJ0BjbWRjb2RlL2J1ZmYnO1xuaW1wb3J0IHsgXzBuLCBfMW4sIF9OIH0gZnJvbSAnLi4vY29uc3QuanMnO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tICcuL2VjYy5qcyc7XG5pbXBvcnQgeyBmZCwgaW52ZXJ0LCBtb2RfbiB9IGZyb20gJy4vbWF0aC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3NoYXJlcyhzZWNyZXQsIHRob2xkLCB0b3RhbCkge1xuICAgIGNvbnN0IGNvZWZmcyA9IFtGaWVsZC5tb2Qoc2VjcmV0KS5iaWddO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhvbGQ7IGkrKykge1xuICAgICAgICBjb25zdCByYW5kID0gQnVmZi5yYW5kb20oMzIpLmJpZztcbiAgICAgICAgY29lZmZzLnB1c2gobW9kX24ocmFuZCkpO1xuICAgIH1cbiAgICBjb25zdCBzaGFyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0b3RhbDsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBfMG47XG4gICAgICAgIGNvZWZmcy5mb3JFYWNoKChjb2VmZiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IEJpZ0ludChpKSAqKiBCaWdJbnQoaW5kZXgpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGZkLm11bChjb2VmZiwgaWR4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gQnVmZi5udW0oaSwgNCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQnVmZi5iaWcocmVzdWx0LCAzMyk7XG4gICAgICAgIGNvbnN0IHNoYXJlID0gQnVmZi5qb2luKFtpbmRleCwgdmFsdWVdKTtcbiAgICAgICAgc2hhcmVzLnB1c2goc2hhcmUpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVfc2hhcmVzKHNoYXJlcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBzaGFyZXMubWFwKGUgPT4ge1xuICAgICAgICBjb25zdCBieXRlcyA9IEJ1ZmYuYnl0ZXMoZSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYnl0ZXMuc3ViYXJyYXkoMCwgNCkuYmlnO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGJ5dGVzLnN1YmFycmF5KDQpLmJpZztcbiAgICAgICAgcmV0dXJuIFtpbmRleCwgdmFsdWVdO1xuICAgIH0pO1xuICAgIGxldCBzZWNyZXQgPSBfMG47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBudW1lciA9IF8xbjtcbiAgICAgICAgbGV0IGRlbm9tID0gXzFuO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVudHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgbnVtZXIgPSAobnVtZXIgKiAtZW50cmllc1tqXVswXSkgJSBfTjtcbiAgICAgICAgICAgICAgICBkZW5vbSA9IChkZW5vbSAqIChlbnRyaWVzW2ldWzBdIC0gZW50cmllc1tqXVswXSkpICUgX047XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWVyIDwgXzBuKVxuICAgICAgICAgICAgbnVtZXIgKz0gX047XG4gICAgICAgIGlmIChkZW5vbSA8IF8wbilcbiAgICAgICAgICAgIGRlbm9tICs9IF9OO1xuICAgICAgICBjb25zdCBjb2VmZiA9IChlbnRyaWVzW2ldWzFdICogbnVtZXIgKiBpbnZlcnQoZGVub20sIF9OKSkgJSBfTjtcbiAgICAgICAgc2VjcmV0ID0gKHNlY3JldCArIGNvZWZmKSAlIF9OO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZi5iaWcoc2VjcmV0LCAzMik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFtaXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/shamir.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/sig.js":
/*!************************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/lib/sig.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gen_nonce: () => (/* binding */ gen_nonce),\n/* harmony export */   recover_key: () => (/* binding */ recover_key),\n/* harmony export */   sign_msg: () => (/* binding */ sign_msg),\n/* harmony export */   verify_sig: () => (/* binding */ verify_sig)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/const.js\");\n/* harmony import */ var _ecc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/ecc.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hash.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/hash.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/keys.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-tools/dist/assert.js\");\n\n\n\n\n\n\nfunction sign_msg(message, secret, options = {}) {\n    const { adaptor, key_tweak } = options;\n    const m = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(message);\n    let dp = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(secret);\n    if (key_tweak !== undefined) {\n        dp = dp.negated.add(key_tweak);\n    }\n    const P = dp.point;\n    const d = dp.negated;\n    const n = gen_nonce(m, d, options);\n    let kp = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(n);\n    if (adaptor !== undefined) {\n        kp = kp.negated.add(adaptor);\n    }\n    const R = kp.point;\n    const k = kp.negated.big;\n    const ch = (0,_hash_js__WEBPACK_IMPORTED_MODULE_3__.hash340)('BIP0340/challenge', R.x, P.x, m);\n    const c = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(ch);\n    const s = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(k + (c.big * d.big));\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([R.x, s.raw]);\n}\nfunction verify_sig(signature, message, pubkey, options = {}) {\n    const { throws = false } = options;\n    const msg = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(message);\n    const sig = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(signature);\n    if (sig.length < 64) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_5__.fail('Signature length is too small: ' + String(sig.length), throws);\n    }\n    _assert_js__WEBPACK_IMPORTED_MODULE_5__.size(pubkey, 32);\n    const P = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Point.from_x(pubkey);\n    const rx = sig.subarray(0, 32);\n    const R = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Point.from_x(rx);\n    const s = sig.subarray(32, 64);\n    const sG = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(s).point;\n    const ch = (0,_hash_js__WEBPACK_IMPORTED_MODULE_3__.hash340)('BIP0340/challenge', R.x, P.x, msg);\n    const c = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(ch);\n    const eP = P.mul(c.big);\n    const r = sG.sub(eP);\n    if (R.hasOddY) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_5__.fail('Signature R value has odd Y coordinate!', throws);\n    }\n    if (R.x.big === _const_js__WEBPACK_IMPORTED_MODULE_1__._0n) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_5__.fail('Signature R value is infinite!', throws);\n    }\n    if (R.x.big !== r.x.big) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_5__.fail(`Signature is invalid! R: ${R.x.hex} r:${r.x.hex}`, throws);\n    }\n    return R.x.big === r.x.big;\n}\nfunction gen_nonce(message, secret, options = {}) {\n    const { aux, nonce_seed, nonce_tweak, sec_nonce } = options;\n    let nonce;\n    if (nonce_seed !== undefined) {\n        nonce = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(nonce_seed);\n    }\n    else {\n        const seed = (aux === null) ? _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.num(0, 32) : aux;\n        const a = (0,_hash_js__WEBPACK_IMPORTED_MODULE_3__.hash340)('BIP0340/aux', seed ?? _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.random(32));\n        const t = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(secret).big ^ a.big;\n        nonce = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.join([t, (0,_keys_js__WEBPACK_IMPORTED_MODULE_4__.get_pubkey)(secret, true)]);\n    }\n    let sn = (sec_nonce !== undefined)\n        ? _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(sec_nonce)\n        : _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod((0,_hash_js__WEBPACK_IMPORTED_MODULE_3__.hash340)('BIP0340/nonce', nonce, message));\n    if (nonce_tweak !== undefined) {\n        sn = sn.negated.add(nonce_tweak);\n    }\n    return sn.buff;\n}\nfunction recover_key(message, pubkey, seed, signature) {\n    const pub = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pubkey);\n    const sig = _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(signature);\n    const s_val = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(sig.slice(32, 64));\n    const nonce = (0,_hash_js__WEBPACK_IMPORTED_MODULE_3__.hash340)('BIP0340/nonce', seed, message);\n    const chal = (0,_hash_js__WEBPACK_IMPORTED_MODULE_3__.hash340)('BIP0340/challenge', sig.slice(0, 32), pub, message);\n    const k = (0,_keys_js__WEBPACK_IMPORTED_MODULE_4__.get_seckey)(nonce, true);\n    return s_val.sub(k).div(chal).buff;\n}\n//# sourceMappingURL=sig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL3NpZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0g7QUFDTTtBQUNKO0FBQ2U7QUFDWjtBQUNoQywrQ0FBK0M7QUFDdEQsWUFBWSxxQkFBcUI7QUFDakMsY0FBYywrQ0FBSTtBQUNsQixhQUFhLDBDQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMENBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQU87QUFDdEIsY0FBYywwQ0FBSztBQUNuQixjQUFjLDBDQUFLO0FBQ25CLFdBQVcsK0NBQUk7QUFDZjtBQUNPLDREQUE0RDtBQUNuRSxZQUFZLGlCQUFpQjtBQUM3QixnQkFBZ0IsK0NBQUk7QUFDcEIsZ0JBQWdCLCtDQUFJO0FBQ3BCO0FBQ0EsZUFBZSw0Q0FBVztBQUMxQjtBQUNBLElBQUksNENBQVc7QUFDZixjQUFjLDBDQUFLO0FBQ25CO0FBQ0EsY0FBYywwQ0FBSztBQUNuQjtBQUNBLGVBQWUsMENBQUs7QUFDcEIsZUFBZSxpREFBTztBQUN0QixjQUFjLDBDQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVc7QUFDMUI7QUFDQSxvQkFBb0IsMENBQUc7QUFDdkIsZUFBZSw0Q0FBVztBQUMxQjtBQUNBO0FBQ0EsZUFBZSw0Q0FBVyw2QkFBNkIsU0FBUyxJQUFJLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ08sZ0RBQWdEO0FBQ3ZELFlBQVksMENBQTBDO0FBQ3REO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQUk7QUFDcEI7QUFDQTtBQUNBLHNDQUFzQywrQ0FBSTtBQUMxQyxrQkFBa0IsaURBQU8sd0JBQXdCLCtDQUFJO0FBQ3JELGtCQUFrQiwrQ0FBSTtBQUN0QixnQkFBZ0IsK0NBQUksVUFBVSxvREFBVTtBQUN4QztBQUNBO0FBQ0EsVUFBVSwwQ0FBSztBQUNmLFVBQVUsMENBQUssS0FBSyxpREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IsK0NBQUk7QUFDcEIsZ0JBQWdCLCtDQUFJO0FBQ3BCLGtCQUFrQiwwQ0FBSztBQUN2QixrQkFBa0IsaURBQU87QUFDekIsaUJBQWlCLGlEQUFPO0FBQ3hCLGNBQWMsb0RBQVU7QUFDeEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvbGliL3NpZy5qcz8xNGMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmJztcbmltcG9ydCB7IF8wbiB9IGZyb20gJy4uL2NvbnN0LmpzJztcbmltcG9ydCB7IEZpZWxkLCBQb2ludCB9IGZyb20gJy4vZWNjLmpzJztcbmltcG9ydCB7IGhhc2gzNDAgfSBmcm9tICcuL2hhc2guanMnO1xuaW1wb3J0IHsgZ2V0X3B1YmtleSwgZ2V0X3NlY2tleSB9IGZyb20gJy4va2V5cy5qcyc7XG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSAnLi4vYXNzZXJ0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBzaWduX21zZyhtZXNzYWdlLCBzZWNyZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYWRhcHRvciwga2V5X3R3ZWFrIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG0gPSBCdWZmLmJ5dGVzKG1lc3NhZ2UpO1xuICAgIGxldCBkcCA9IEZpZWxkLm1vZChzZWNyZXQpO1xuICAgIGlmIChrZXlfdHdlYWsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkcCA9IGRwLm5lZ2F0ZWQuYWRkKGtleV90d2Vhayk7XG4gICAgfVxuICAgIGNvbnN0IFAgPSBkcC5wb2ludDtcbiAgICBjb25zdCBkID0gZHAubmVnYXRlZDtcbiAgICBjb25zdCBuID0gZ2VuX25vbmNlKG0sIGQsIG9wdGlvbnMpO1xuICAgIGxldCBrcCA9IEZpZWxkLm1vZChuKTtcbiAgICBpZiAoYWRhcHRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtwID0ga3AubmVnYXRlZC5hZGQoYWRhcHRvcik7XG4gICAgfVxuICAgIGNvbnN0IFIgPSBrcC5wb2ludDtcbiAgICBjb25zdCBrID0ga3AubmVnYXRlZC5iaWc7XG4gICAgY29uc3QgY2ggPSBoYXNoMzQwKCdCSVAwMzQwL2NoYWxsZW5nZScsIFIueCwgUC54LCBtKTtcbiAgICBjb25zdCBjID0gRmllbGQubW9kKGNoKTtcbiAgICBjb25zdCBzID0gRmllbGQubW9kKGsgKyAoYy5iaWcgKiBkLmJpZykpO1xuICAgIHJldHVybiBCdWZmLmpvaW4oW1IueCwgcy5yYXddKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlfc2lnKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVia2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHRocm93cyA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG1zZyA9IEJ1ZmYuYnl0ZXMobWVzc2FnZSk7XG4gICAgY29uc3Qgc2lnID0gQnVmZi5ieXRlcyhzaWduYXR1cmUpO1xuICAgIGlmIChzaWcubGVuZ3RoIDwgNjQpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydC5mYWlsKCdTaWduYXR1cmUgbGVuZ3RoIGlzIHRvbyBzbWFsbDogJyArIFN0cmluZyhzaWcubGVuZ3RoKSwgdGhyb3dzKTtcbiAgICB9XG4gICAgYXNzZXJ0LnNpemUocHVia2V5LCAzMik7XG4gICAgY29uc3QgUCA9IFBvaW50LmZyb21feChwdWJrZXkpO1xuICAgIGNvbnN0IHJ4ID0gc2lnLnN1YmFycmF5KDAsIDMyKTtcbiAgICBjb25zdCBSID0gUG9pbnQuZnJvbV94KHJ4KTtcbiAgICBjb25zdCBzID0gc2lnLnN1YmFycmF5KDMyLCA2NCk7XG4gICAgY29uc3Qgc0cgPSBGaWVsZC5tb2QocykucG9pbnQ7XG4gICAgY29uc3QgY2ggPSBoYXNoMzQwKCdCSVAwMzQwL2NoYWxsZW5nZScsIFIueCwgUC54LCBtc2cpO1xuICAgIGNvbnN0IGMgPSBGaWVsZC5tb2QoY2gpO1xuICAgIGNvbnN0IGVQID0gUC5tdWwoYy5iaWcpO1xuICAgIGNvbnN0IHIgPSBzRy5zdWIoZVApO1xuICAgIGlmIChSLmhhc09kZFkpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydC5mYWlsKCdTaWduYXR1cmUgUiB2YWx1ZSBoYXMgb2RkIFkgY29vcmRpbmF0ZSEnLCB0aHJvd3MpO1xuICAgIH1cbiAgICBpZiAoUi54LmJpZyA9PT0gXzBuKSB7XG4gICAgICAgIHJldHVybiBhc3NlcnQuZmFpbCgnU2lnbmF0dXJlIFIgdmFsdWUgaXMgaW5maW5pdGUhJywgdGhyb3dzKTtcbiAgICB9XG4gICAgaWYgKFIueC5iaWcgIT09IHIueC5iaWcpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydC5mYWlsKGBTaWduYXR1cmUgaXMgaW52YWxpZCEgUjogJHtSLnguaGV4fSByOiR7ci54LmhleH1gLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gUi54LmJpZyA9PT0gci54LmJpZztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5fbm9uY2UobWVzc2FnZSwgc2VjcmV0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGF1eCwgbm9uY2Vfc2VlZCwgbm9uY2VfdHdlYWssIHNlY19ub25jZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgbm9uY2U7XG4gICAgaWYgKG5vbmNlX3NlZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub25jZSA9IEJ1ZmYuYnl0ZXMobm9uY2Vfc2VlZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzZWVkID0gKGF1eCA9PT0gbnVsbCkgPyBCdWZmLm51bSgwLCAzMikgOiBhdXg7XG4gICAgICAgIGNvbnN0IGEgPSBoYXNoMzQwKCdCSVAwMzQwL2F1eCcsIHNlZWQgPz8gQnVmZi5yYW5kb20oMzIpKTtcbiAgICAgICAgY29uc3QgdCA9IEJ1ZmYuYnl0ZXMoc2VjcmV0KS5iaWcgXiBhLmJpZztcbiAgICAgICAgbm9uY2UgPSBCdWZmLmpvaW4oW3QsIGdldF9wdWJrZXkoc2VjcmV0LCB0cnVlKV0pO1xuICAgIH1cbiAgICBsZXQgc24gPSAoc2VjX25vbmNlICE9PSB1bmRlZmluZWQpXG4gICAgICAgID8gRmllbGQubW9kKHNlY19ub25jZSlcbiAgICAgICAgOiBGaWVsZC5tb2QoaGFzaDM0MCgnQklQMDM0MC9ub25jZScsIG5vbmNlLCBtZXNzYWdlKSk7XG4gICAgaWYgKG5vbmNlX3R3ZWFrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc24gPSBzbi5uZWdhdGVkLmFkZChub25jZV90d2Vhayk7XG4gICAgfVxuICAgIHJldHVybiBzbi5idWZmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJfa2V5KG1lc3NhZ2UsIHB1YmtleSwgc2VlZCwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgcHViID0gQnVmZi5ieXRlcyhwdWJrZXkpO1xuICAgIGNvbnN0IHNpZyA9IEJ1ZmYuYnl0ZXMoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzX3ZhbCA9IEZpZWxkLm1vZChzaWcuc2xpY2UoMzIsIDY0KSk7XG4gICAgY29uc3Qgbm9uY2UgPSBoYXNoMzQwKCdCSVAwMzQwL25vbmNlJywgc2VlZCwgbWVzc2FnZSk7XG4gICAgY29uc3QgY2hhbCA9IGhhc2gzNDAoJ0JJUDAzNDAvY2hhbGxlbmdlJywgc2lnLnNsaWNlKDAsIDMyKSwgcHViLCBtZXNzYWdlKTtcbiAgICBjb25zdCBrID0gZ2V0X3NlY2tleShub25jZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHNfdmFsLnN1YihrKS5kaXYoY2hhbCkuYnVmZjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/lib/sig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdG9vbHMvZGlzdC90eXBlcy5qcz85MjVjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-tools/dist/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-tools/dist/util.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   increment_buffer: () => (/* binding */ increment_buffer),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff */ \"(ssr)/./node_modules/@cmdcode/buff/dist/index.js\");\n\nfunction random(size) {\n    return _cmdcode_buff__WEBPACK_IMPORTED_MODULE_0__.Buff.random(size);\n}\nfunction increment_buffer(buffer) {\n    let i = buffer.length - 1;\n    for (i; i >= 0; i--) {\n        if (buffer[i] < 255) {\n            buffer.set([buffer[i] + 1], i);\n            return buffer;\n        }\n    }\n    throw TypeError('Unable to increment buffer: ' + buffer.toString());\n}\nfunction stringify(content) {\n    switch (typeof content) {\n        case 'object':\n            return JSON.stringify(content);\n        case 'string':\n            return content;\n        case 'bigint':\n            return content.toString();\n        case 'number':\n            return content.toString();\n        case 'boolean':\n            return String(content);\n        default:\n            throw new TypeError('Content type not supported: ' + typeof content);\n    }\n}\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXRvb2xzL2Rpc3QvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFDO0FBQzlCO0FBQ1AsV0FBVywrQ0FBSTtBQUNmO0FBQ087QUFDUDtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdG9vbHMvZGlzdC91dGlsLmpzP2I3OGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZiB9IGZyb20gJ0BjbWRjb2RlL2J1ZmYnO1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShzaXplKSB7XG4gICAgcmV0dXJuIEJ1ZmYucmFuZG9tKHNpemUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudF9idWZmZXIoYnVmZmVyKSB7XG4gICAgbGV0IGkgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChidWZmZXJbaV0gPCAyNTUpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoW2J1ZmZlcltpXSArIDFdLCBpKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgVHlwZUVycm9yKCdVbmFibGUgdG8gaW5jcmVtZW50IGJ1ZmZlcjogJyArIGJ1ZmZlci50b1N0cmluZygpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkoY29udGVudCkge1xuICAgIHN3aXRjaCAodHlwZW9mIGNvbnRlbnQpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjb250ZW50KTtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhjb250ZW50KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnRlbnQgdHlwZSBub3Qgc3VwcG9ydGVkOiAnICsgdHlwZW9mIGNvbnRlbnQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-tools/dist/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/assert.js":
/*!***********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/assert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   fail: () => (/* binding */ fail),\n/* harmony export */   in_field: () => (/* binding */ in_field),\n/* harmony export */   ok: () => (/* binding */ ok),\n/* harmony export */   on_curve: () => (/* binding */ on_curve),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   valid_chain: () => (/* binding */ valid_chain),\n/* harmony export */   valid_derive_state: () => (/* binding */ valid_derive_state),\n/* harmony export */   valid_hash: () => (/* binding */ valid_hash),\n/* harmony export */   valid_index: () => (/* binding */ valid_index),\n/* harmony export */   valid_path: () => (/* binding */ valid_path),\n/* harmony export */   valid_pubkey: () => (/* binding */ valid_pubkey)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/const.js\");\n\n\nfunction ok(value, message) {\n    if (value === false)\n        throw new Error(message ?? 'Assertion failed!');\n}\nfunction fail(error, throws = false) {\n    if (!throws)\n        return false;\n    throw new Error(error);\n}\nfunction size(input, size, throws) {\n    const bytes = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(input);\n    if (bytes.length !== size) {\n        return fail(`Invalid byte size: ${bytes.hex} !== ${size}`, throws);\n    }\n    return true;\n}\nfunction exists(input) {\n    if (typeof input === 'undefined') {\n        throw new TypeError('Input is undefined!');\n    }\n    if (input === null) {\n        throw new TypeError('Input is null!');\n    }\n}\nfunction on_curve(x, throws) {\n    if (!(typeof x === 'bigint' && _const_js__WEBPACK_IMPORTED_MODULE_1__._0n < x && x < _const_js__WEBPACK_IMPORTED_MODULE_1__._P)) {\n        fail('x value is not on the curve!', throws);\n    }\n    return true;\n}\nfunction in_field(x, throws) {\n    if (!(typeof x === 'bigint' && _const_js__WEBPACK_IMPORTED_MODULE_1__._0n < x && x < _const_js__WEBPACK_IMPORTED_MODULE_1__._N)) {\n        fail('x value is not in the field!', throws);\n    }\n    return true;\n}\nfunction valid_chain(path, code) {\n    if (code === undefined) {\n        if (!path.startsWith('m')) {\n            throw new Error('You need to specify a chain-code for a non-root path.');\n        }\n    }\n    else {\n        if (_cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(code).length !== 32) {\n            throw new Error('Chain code must be 32 bytes!');\n        }\n    }\n}\nfunction valid_path(path) {\n    const regex = /^(m)?(\\/)?(\\w+'?\\/)*\\w+'?$/;\n    if (path !== '' && path.match(regex) === null) {\n        throw new Error('Provided path string is invalid: ' + path);\n    }\n}\nfunction valid_hash(hash) {\n    const regex = /^[0-9a-fA-F]{64}$/;\n    if (hash.match(regex) === null) {\n        throw new Error('Provided hash string is invalid: ' + hash);\n    }\n}\nfunction valid_index(index) {\n    if (index > 0x80000000) {\n        throw new TypeError('Index value must not exceed 31 bits.');\n    }\n}\nfunction valid_pubkey(pubkey) {\n    const key = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pubkey);\n    if (key.length !== 33) {\n        throw new TypeError('Index value must not exceed 31 bits.');\n    }\n}\nfunction valid_derive_state(hardened, is_private) {\n    if (hardened && !is_private) {\n        throw new Error('Cannot derive hardedened paths when is_private is false!');\n    }\n}\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ0Y7QUFDbEM7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0IscURBQUk7QUFDdEI7QUFDQSwwQ0FBMEMsV0FBVyxNQUFNLEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUNBQW1DLDBDQUFHLFlBQVkseUNBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1DQUFtQywwQ0FBRyxZQUFZLHlDQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQ0FBZ0MsR0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdCQUFnQixxREFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2NyeXB0by11dGlscy9kaXN0L2Fzc2VydC5qcz9kMWNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmLXV0aWxzJztcbmltcG9ydCB7IF9OLCBfUCwgXzBuIH0gZnJvbSAnLi9jb25zdC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSA/PyAnQXNzZXJ0aW9uIGZhaWxlZCEnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmYWlsKGVycm9yLCB0aHJvd3MgPSBmYWxzZSkge1xuICAgIGlmICghdGhyb3dzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaXplKGlucHV0LCBzaXplLCB0aHJvd3MpIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmYuYnl0ZXMoaW5wdXQpO1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoYEludmFsaWQgYnl0ZSBzaXplOiAke2J5dGVzLmhleH0gIT09ICR7c2l6ZX1gLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHMoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBpcyB1bmRlZmluZWQhJyk7XG4gICAgfVxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBpcyBudWxsIScpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBvbl9jdXJ2ZSh4LCB0aHJvd3MpIHtcbiAgICBpZiAoISh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgX1ApKSB7XG4gICAgICAgIGZhaWwoJ3ggdmFsdWUgaXMgbm90IG9uIHRoZSBjdXJ2ZSEnLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbl9maWVsZCh4LCB0aHJvd3MpIHtcbiAgICBpZiAoISh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgX04pKSB7XG4gICAgICAgIGZhaWwoJ3ggdmFsdWUgaXMgbm90IGluIHRoZSBmaWVsZCEnLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZF9jaGFpbihwYXRoLCBjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnbScpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHNwZWNpZnkgYSBjaGFpbi1jb2RlIGZvciBhIG5vbi1yb290IHBhdGguJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCdWZmLmJ5dGVzKGNvZGUpLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhaW4gY29kZSBtdXN0IGJlIDMyIGJ5dGVzIScpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkX3BhdGgocGF0aCkge1xuICAgIGNvbnN0IHJlZ2V4ID0gL14obSk/KFxcLyk/KFxcdysnP1xcLykqXFx3Kyc/JC87XG4gICAgaWYgKHBhdGggIT09ICcnICYmIHBhdGgubWF0Y2gocmVnZXgpID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgcGF0aCBzdHJpbmcgaXMgaW52YWxpZDogJyArIHBhdGgpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZF9oYXNoKGhhc2gpIHtcbiAgICBjb25zdCByZWdleCA9IC9eWzAtOWEtZkEtRl17NjR9JC87XG4gICAgaWYgKGhhc2gubWF0Y2gocmVnZXgpID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgaGFzaCBzdHJpbmcgaXMgaW52YWxpZDogJyArIGhhc2gpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZF9pbmRleChpbmRleCkge1xuICAgIGlmIChpbmRleCA+IDB4ODAwMDAwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXggdmFsdWUgbXVzdCBub3QgZXhjZWVkIDMxIGJpdHMuJyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkX3B1YmtleShwdWJrZXkpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmLmJ5dGVzKHB1YmtleSk7XG4gICAgaWYgKGtleS5sZW5ndGggIT09IDMzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luZGV4IHZhbHVlIG11c3Qgbm90IGV4Y2VlZCAzMSBiaXRzLicpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZF9kZXJpdmVfc3RhdGUoaGFyZGVuZWQsIGlzX3ByaXZhdGUpIHtcbiAgICBpZiAoaGFyZGVuZWQgJiYgIWlzX3ByaXZhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVyaXZlIGhhcmRlZGVuZWQgcGF0aHMgd2hlbiBpc19wcml2YXRlIGlzIGZhbHNlIScpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/config.js":
/*!***********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/config.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sign_config: () => (/* binding */ sign_config)\n/* harmony export */ });\nconst SIGN_DEFAULTS = {\n    throws: false,\n    xonly: true\n};\nfunction sign_config(config = {}) {\n    return { ...SIGN_DEFAULTS, ...config };\n}\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvY29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQztBQUN2QyxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2NyeXB0by11dGlscy9kaXN0L2NvbmZpZy5qcz81ZGMxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNJR05fREVGQVVMVFMgPSB7XG4gICAgdGhyb3dzOiBmYWxzZSxcbiAgICB4b25seTogdHJ1ZVxufTtcbmV4cG9ydCBmdW5jdGlvbiBzaWduX2NvbmZpZyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiB7IC4uLlNJR05fREVGQVVMVFMsIC4uLmNvbmZpZyB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/const.js":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/const.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _0n: () => (/* binding */ _0n),\n/* harmony export */   _1n: () => (/* binding */ _1n),\n/* harmony export */   _2n: () => (/* binding */ _2n),\n/* harmony export */   _3n: () => (/* binding */ _3n),\n/* harmony export */   _4n: () => (/* binding */ _4n),\n/* harmony export */   _G: () => (/* binding */ _G),\n/* harmony export */   _N: () => (/* binding */ _N),\n/* harmony export */   _P: () => (/* binding */ _P)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n\nconst curve = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.CURVE;\nconst _N = curve.n;\nconst _P = curve.p;\nconst _G = { x: curve.Gx, y: curve.Gy };\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _4n = BigInt(4);\n//# sourceMappingURL=const.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvY29uc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ3BELGNBQWMsOERBQVM7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdXRpbHMvZGlzdC9jb25zdC5qcz81MWVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmNvbnN0IGN1cnZlID0gc2VjcDI1NmsxLkNVUlZFO1xuZXhwb3J0IGNvbnN0IF9OID0gY3VydmUubjtcbmV4cG9ydCBjb25zdCBfUCA9IGN1cnZlLnA7XG5leHBvcnQgY29uc3QgX0cgPSB7IHg6IGN1cnZlLkd4LCB5OiBjdXJ2ZS5HeSB9O1xuZXhwb3J0IGNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmV4cG9ydCBjb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5leHBvcnQgY29uc3QgXzJuID0gQmlnSW50KDIpO1xuZXhwb3J0IGNvbnN0IF8zbiA9IEJpZ0ludCgzKTtcbmV4cG9ydCBjb25zdCBfNG4gPSBCaWdJbnQoNCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/const.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecc.js":
/*!********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/ecc.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   fd: () => (/* binding */ fd)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/const.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/math.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/assert.js\");\n\n\n\n\n\n\nconst NobleField = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_4__.Field)(_const_js__WEBPACK_IMPORTED_MODULE_1__._N, 32, true);\nconst NoblePoint = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.secp256k1.ProjectivePoint;\nconst fd = NobleField;\nclass Field extends Uint8Array {\n    static { this.N = _const_js__WEBPACK_IMPORTED_MODULE_1__._N; }\n    static add(x) {\n        return x.map(e => Field.mod(e)).reduce((p, n) => p.add(n));\n    }\n    static mod(x) {\n        return new Field(x);\n    }\n    static mul(x) {\n        return x.map(e => Field.mod(e)).reduce((p, n) => p.mul(n));\n    }\n    static is_valid(value, throws) {\n        const big = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(value, 32).big;\n        return _assert_js__WEBPACK_IMPORTED_MODULE_3__.in_field(big, throws);\n    }\n    constructor(x) {\n        const b = _math_js__WEBPACK_IMPORTED_MODULE_2__.modN(normalizeField(x));\n        Field.is_valid(b, true);\n        super(_cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.big(b, 32), 32);\n    }\n    get buff() {\n        return new _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff(this);\n    }\n    get raw() {\n        return this.buff.raw;\n    }\n    get big() {\n        return this.buff.big;\n    }\n    get hex() {\n        return this.buff.hex;\n    }\n    get point() {\n        return this.generate();\n    }\n    get hasOddY() {\n        return this.point.hasOddY;\n    }\n    get negated() {\n        return (this.hasOddY)\n            ? this.negate()\n            : this;\n    }\n    gt(value) {\n        const x = new Field(value);\n        return x.big > this.big;\n    }\n    lt(value) {\n        const x = new Field(value);\n        return x.big < this.big;\n    }\n    eq(value) {\n        const x = new Field(value);\n        return x.big === this.big;\n    }\n    ne(value) {\n        const x = new Field(value);\n        return x.big !== this.big;\n    }\n    add(value) {\n        const x = Field.mod(value);\n        const a = fd.add(this.big, x.big);\n        return new Field(a);\n    }\n    sub(value) {\n        const x = Field.mod(value);\n        const a = fd.sub(this.big, x.big);\n        return new Field(a);\n    }\n    mul(value) {\n        const x = Field.mod(value);\n        const a = fd.mul(this.big, x.big);\n        return new Field(a);\n    }\n    pow(value) {\n        const x = Field.mod(value);\n        const a = fd.pow(this.big, x.big);\n        return new Field(a);\n    }\n    div(value) {\n        const x = Field.mod(value);\n        const a = fd.div(this.big, x.big);\n        return new Field(a);\n    }\n    negate() {\n        return new Field(Field.N - this.big);\n    }\n    generate() {\n        const base = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.secp256k1.ProjectivePoint.BASE;\n        const point = base.multiply(this.big);\n        return Point.import(point);\n    }\n}\nclass Point {\n    static { this.P = _const_js__WEBPACK_IMPORTED_MODULE_1__._P; }\n    static { this.G = new Point(_const_js__WEBPACK_IMPORTED_MODULE_1__._G.x, _const_js__WEBPACK_IMPORTED_MODULE_1__._G.y); }\n    static { this.curve = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.secp256k1.CURVE; }\n    static { this.base = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.secp256k1.ProjectivePoint.BASE; }\n    static from_x(bytes, even_y = false) {\n        let cp = normalizePoint(bytes);\n        if (cp.length === 32) {\n            cp = cp.prepend(0x02);\n        }\n        else if (even_y) {\n            cp[0] = 0x02;\n        }\n        _assert_js__WEBPACK_IMPORTED_MODULE_3__.size(cp, 33);\n        const point = NoblePoint.fromHex(cp.hex);\n        point.assertValidity();\n        return new Point(point.x, point.y);\n    }\n    static generate(value) {\n        const field = Field.mod(value);\n        const point = Point.base.multiply(field.big);\n        return Point.import(point);\n    }\n    static { this.mul = Point.generate; }\n    static import(point) {\n        const p = (point instanceof Point)\n            ? { x: point.x.big, y: point.y.big }\n            : { x: point.x, y: point.y };\n        return new Point(p.x, p.y);\n    }\n    constructor(x, y) {\n        this._p = new NoblePoint(x, y, 1n);\n        this.p.assertValidity();\n    }\n    get p() {\n        return this._p;\n    }\n    get x() {\n        return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.big(this.p.x, 32);\n    }\n    get y() {\n        return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.big(this.p.y, 32);\n    }\n    get buff() {\n        return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(this.p.toRawBytes(true));\n    }\n    get raw() {\n        return this.buff.raw;\n    }\n    get hex() {\n        return this.buff.hex;\n    }\n    get hasEvenY() {\n        return this.p.hasEvenY();\n    }\n    get hasOddY() {\n        return !this.p.hasEvenY();\n    }\n    get negated() {\n        return (this.hasOddY)\n            ? this.negate()\n            : this;\n    }\n    eq(value) {\n        const p = (value instanceof Point) ? value : Point.from_x(value);\n        return this.x.big === p.x.big && this.y.big === p.y.big;\n    }\n    add(x) {\n        return (x instanceof Point)\n            ? Point.import(this.p.add(x.p))\n            : Point.import(this.p.add(Point.generate(x).p));\n    }\n    sub(x) {\n        return (x instanceof Point)\n            ? Point.import(this.p.subtract(x.p))\n            : Point.import(this.p.subtract(Point.generate(x).p));\n    }\n    mul(value) {\n        return (value instanceof Point)\n            ? Point.import(this.p.multiply(value.x.big))\n            : Point.import(this.p.multiply(Field.mod(value).big));\n    }\n    negate() {\n        return Point.import(this.p.negate());\n    }\n}\nfunction normalizeField(value) {\n    if (value instanceof Field) {\n        return value.big;\n    }\n    if (value instanceof Point) {\n        return value.x.big;\n    }\n    if (value instanceof Uint8Array) {\n        return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(value).big;\n    }\n    if (typeof value === 'string') {\n        return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.hex(value).big;\n    }\n    if (typeof value === 'number') {\n        return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.num(value).big;\n    }\n    if (typeof value === 'bigint') {\n        return BigInt(value);\n    }\n    throw TypeError('Invalid input type:' + typeof value);\n}\nfunction normalizePoint(value) {\n    if (value instanceof Field) {\n        return value.point.buff;\n    }\n    if (value instanceof Point) {\n        return value.buff;\n    }\n    if (value instanceof Uint8Array ||\n        typeof value === 'string') {\n        return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(value);\n    }\n    if (typeof value === 'number' ||\n        typeof value === 'bigint') {\n        return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(value, 32);\n    }\n    throw new TypeError(`Unknown type: ${typeof value}`);\n}\n//# sourceMappingURL=ecc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvZWNjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEyQztBQUNTO0FBQ1U7QUFDdEI7QUFDTjtBQUNJO0FBQ3RDLG1CQUFtQixxRUFBRyxDQUFDLHlDQUFFO0FBQ3pCLG1CQUFtQiw4REFBUztBQUNyQjtBQUNBO0FBQ1AsYUFBYSxTQUFTLHlDQUFFO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFJO0FBQ3hCLGVBQWUsZ0RBQWU7QUFDOUI7QUFDQTtBQUNBLGtCQUFrQiwwQ0FBUztBQUMzQjtBQUNBLGNBQWMscURBQUk7QUFDbEI7QUFDQTtBQUNBLG1CQUFtQixxREFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGFBQWEsU0FBUyx5Q0FBRTtBQUN4QixhQUFhLG1CQUFtQix5Q0FBRSxJQUFJLHlDQUFFO0FBQ3hDLGFBQWEsYUFBYSw4REFBUztBQUNuQyxhQUFhLFlBQVksOERBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBSTtBQUNuQjtBQUNBO0FBQ0EsZUFBZSxxREFBSTtBQUNuQjtBQUNBO0FBQ0EsZUFBZSxxREFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUk7QUFDbkI7QUFDQTtBQUNBLGVBQWUscURBQUk7QUFDbkI7QUFDQTtBQUNBLGVBQWUscURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFJO0FBQ25CO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2NyeXB0by11dGlscy9kaXN0L2VjYy5qcz9kZDdhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmLXV0aWxzJztcbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmltcG9ydCB7IEZpZWxkIGFzIE5GRCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG5pbXBvcnQgeyBfTiwgX1AsIF9HIH0gZnJvbSAnLi9jb25zdC5qcyc7XG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSAnLi9hc3NlcnQuanMnO1xuY29uc3QgTm9ibGVGaWVsZCA9IE5GRChfTiwgMzIsIHRydWUpO1xuY29uc3QgTm9ibGVQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5leHBvcnQgY29uc3QgZmQgPSBOb2JsZUZpZWxkO1xuZXhwb3J0IGNsYXNzIEZpZWxkIGV4dGVuZHMgVWludDhBcnJheSB7XG4gICAgc3RhdGljIHsgdGhpcy5OID0gX047IH1cbiAgICBzdGF0aWMgYWRkKHgpIHtcbiAgICAgICAgcmV0dXJuIHgubWFwKGUgPT4gRmllbGQubW9kKGUpKS5yZWR1Y2UoKHAsIG4pID0+IHAuYWRkKG4pKTtcbiAgICB9XG4gICAgc3RhdGljIG1vZCh4KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoeCk7XG4gICAgfVxuICAgIHN0YXRpYyBtdWwoeCkge1xuICAgICAgICByZXR1cm4geC5tYXAoZSA9PiBGaWVsZC5tb2QoZSkpLnJlZHVjZSgocCwgbikgPT4gcC5tdWwobikpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNfdmFsaWQodmFsdWUsIHRocm93cykge1xuICAgICAgICBjb25zdCBiaWcgPSBCdWZmLmJ5dGVzKHZhbHVlLCAzMikuYmlnO1xuICAgICAgICByZXR1cm4gYXNzZXJ0LmluX2ZpZWxkKGJpZywgdGhyb3dzKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeCkge1xuICAgICAgICBjb25zdCBiID0gbWF0aC5tb2ROKG5vcm1hbGl6ZUZpZWxkKHgpKTtcbiAgICAgICAgRmllbGQuaXNfdmFsaWQoYiwgdHJ1ZSk7XG4gICAgICAgIHN1cGVyKEJ1ZmYuYmlnKGIsIDMyKSwgMzIpO1xuICAgIH1cbiAgICBnZXQgYnVmZigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgcmF3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmLnJhdztcbiAgICB9XG4gICAgZ2V0IGJpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZi5iaWc7XG4gICAgfVxuICAgIGdldCBoZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmYuaGV4O1xuICAgIH1cbiAgICBnZXQgcG9pbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlKCk7XG4gICAgfVxuICAgIGdldCBoYXNPZGRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludC5oYXNPZGRZO1xuICAgIH1cbiAgICBnZXQgbmVnYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhhc09kZFkpXG4gICAgICAgICAgICA/IHRoaXMubmVnYXRlKClcbiAgICAgICAgICAgIDogdGhpcztcbiAgICB9XG4gICAgZ3QodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeCA9IG5ldyBGaWVsZCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB4LmJpZyA+IHRoaXMuYmlnO1xuICAgIH1cbiAgICBsdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gbmV3IEZpZWxkKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHguYmlnIDwgdGhpcy5iaWc7XG4gICAgfVxuICAgIGVxKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHggPSBuZXcgRmllbGQodmFsdWUpO1xuICAgICAgICByZXR1cm4geC5iaWcgPT09IHRoaXMuYmlnO1xuICAgIH1cbiAgICBuZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gbmV3IEZpZWxkKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHguYmlnICE9PSB0aGlzLmJpZztcbiAgICB9XG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHggPSBGaWVsZC5tb2QodmFsdWUpO1xuICAgICAgICBjb25zdCBhID0gZmQuYWRkKHRoaXMuYmlnLCB4LmJpZyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoYSk7XG4gICAgfVxuICAgIHN1Yih2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYSA9IGZkLnN1Yih0aGlzLmJpZywgeC5iaWcpO1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkKGEpO1xuICAgIH1cbiAgICBtdWwodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeCA9IEZpZWxkLm1vZCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGEgPSBmZC5tdWwodGhpcy5iaWcsIHguYmlnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZChhKTtcbiAgICB9XG4gICAgcG93KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHggPSBGaWVsZC5tb2QodmFsdWUpO1xuICAgICAgICBjb25zdCBhID0gZmQucG93KHRoaXMuYmlnLCB4LmJpZyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoYSk7XG4gICAgfVxuICAgIGRpdih2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYSA9IGZkLmRpdih0aGlzLmJpZywgeC5iaWcpO1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkKGEpO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoRmllbGQuTiAtIHRoaXMuYmlnKTtcbiAgICB9XG4gICAgZ2VuZXJhdGUoKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gYmFzZS5tdWx0aXBseSh0aGlzLmJpZyk7XG4gICAgICAgIHJldHVybiBQb2ludC5pbXBvcnQocG9pbnQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQb2ludCB7XG4gICAgc3RhdGljIHsgdGhpcy5QID0gX1A7IH1cbiAgICBzdGF0aWMgeyB0aGlzLkcgPSBuZXcgUG9pbnQoX0cueCwgX0cueSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmN1cnZlID0gc2VjcDI1NmsxLkNVUlZFOyB9XG4gICAgc3RhdGljIHsgdGhpcy5iYXNlID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5CQVNFOyB9XG4gICAgc3RhdGljIGZyb21feChieXRlcywgZXZlbl95ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGNwID0gbm9ybWFsaXplUG9pbnQoYnl0ZXMpO1xuICAgICAgICBpZiAoY3AubGVuZ3RoID09PSAzMikge1xuICAgICAgICAgICAgY3AgPSBjcC5wcmVwZW5kKDB4MDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW5feSkge1xuICAgICAgICAgICAgY3BbMF0gPSAweDAyO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydC5zaXplKGNwLCAzMyk7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gTm9ibGVQb2ludC5mcm9tSGV4KGNwLmhleCk7XG4gICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IEZpZWxkLm1vZCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuYmFzZS5tdWx0aXBseShmaWVsZC5iaWcpO1xuICAgICAgICByZXR1cm4gUG9pbnQuaW1wb3J0KHBvaW50KTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy5tdWwgPSBQb2ludC5nZW5lcmF0ZTsgfVxuICAgIHN0YXRpYyBpbXBvcnQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgcCA9IChwb2ludCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgPyB7IHg6IHBvaW50LnguYmlnLCB5OiBwb2ludC55LmJpZyB9XG4gICAgICAgICAgICA6IHsgeDogcG9pbnQueCwgeTogcG9pbnQueSB9O1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHAueCwgcC55KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLl9wID0gbmV3IE5vYmxlUG9pbnQoeCwgeSwgMW4pO1xuICAgICAgICB0aGlzLnAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICB9XG4gICAgZ2V0IHAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wO1xuICAgIH1cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYuYmlnKHRoaXMucC54LCAzMik7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gQnVmZi5iaWcodGhpcy5wLnksIDMyKTtcbiAgICB9XG4gICAgZ2V0IGJ1ZmYoKSB7XG4gICAgICAgIHJldHVybiBCdWZmLnJhdyh0aGlzLnAudG9SYXdCeXRlcyh0cnVlKSk7XG4gICAgfVxuICAgIGdldCByYXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmYucmF3O1xuICAgIH1cbiAgICBnZXQgaGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmLmhleDtcbiAgICB9XG4gICAgZ2V0IGhhc0V2ZW5ZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wLmhhc0V2ZW5ZKCk7XG4gICAgfVxuICAgIGdldCBoYXNPZGRZKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucC5oYXNFdmVuWSgpO1xuICAgIH1cbiAgICBnZXQgbmVnYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhhc09kZFkpXG4gICAgICAgICAgICA/IHRoaXMubmVnYXRlKClcbiAgICAgICAgICAgIDogdGhpcztcbiAgICB9XG4gICAgZXEodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcCA9ICh2YWx1ZSBpbnN0YW5jZW9mIFBvaW50KSA/IHZhbHVlIDogUG9pbnQuZnJvbV94KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueC5iaWcgPT09IHAueC5iaWcgJiYgdGhpcy55LmJpZyA9PT0gcC55LmJpZztcbiAgICB9XG4gICAgYWRkKHgpIHtcbiAgICAgICAgcmV0dXJuICh4IGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICA/IFBvaW50LmltcG9ydCh0aGlzLnAuYWRkKHgucCkpXG4gICAgICAgICAgICA6IFBvaW50LmltcG9ydCh0aGlzLnAuYWRkKFBvaW50LmdlbmVyYXRlKHgpLnApKTtcbiAgICB9XG4gICAgc3ViKHgpIHtcbiAgICAgICAgcmV0dXJuICh4IGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICA/IFBvaW50LmltcG9ydCh0aGlzLnAuc3VidHJhY3QoeC5wKSlcbiAgICAgICAgICAgIDogUG9pbnQuaW1wb3J0KHRoaXMucC5zdWJ0cmFjdChQb2ludC5nZW5lcmF0ZSh4KS5wKSk7XG4gICAgfVxuICAgIG11bCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICA/IFBvaW50LmltcG9ydCh0aGlzLnAubXVsdGlwbHkodmFsdWUueC5iaWcpKVxuICAgICAgICAgICAgOiBQb2ludC5pbXBvcnQodGhpcy5wLm11bHRpcGx5KEZpZWxkLm1vZCh2YWx1ZSkuYmlnKSk7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmltcG9ydCh0aGlzLnAubmVnYXRlKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUZpZWxkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmJpZztcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnguYmlnO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmLnJhdyh2YWx1ZSkuYmlnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQnVmZi5oZXgodmFsdWUpLmJpZztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYubnVtKHZhbHVlKS5iaWc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZTonICsgdHlwZW9mIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvaW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnBvaW50LmJ1ZmY7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5idWZmO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYuYnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBCdWZmLmJ5dGVzKHZhbHVlLCAzMik7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gdHlwZTogJHt0eXBlb2YgdmFsdWV9YCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lY2MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecdh.js":
/*!*********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/ecdh.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   get_shared_code: () => (/* binding */ get_shared_code),\n/* harmony export */   get_shared_key: () => (/* binding */ get_shared_key)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n/* harmony import */ var _ecc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecc.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hash.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/hash.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/keys.js\");\n\n\n\n\nfunction get_shared_key(self_sec, peer_pub) {\n    const P = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Point.from_x(peer_pub);\n    const sp = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(self_sec);\n    const sh = P.mul(sp);\n    return sh.buff;\n}\nfunction get_shared_code(self_sec, peer_pub, message, prefix = 'ecdh/hmac512') {\n    const sec = (0,_keys_js__WEBPACK_IMPORTED_MODULE_3__.get_seckey)(self_sec);\n    const pub = (0,_keys_js__WEBPACK_IMPORTED_MODULE_3__.get_pubkey)(sec);\n    const peer = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(peer_pub);\n    const tag = (0,_hash_js__WEBPACK_IMPORTED_MODULE_2__.taghash)(prefix);\n    const shared = get_shared_key(sec, peer_pub);\n    const pubs = [pub.hex, peer.hex].sort();\n    return (0,_hash_js__WEBPACK_IMPORTED_MODULE_2__.hmac512)(shared, _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([...tag, ...pubs, message]));\n}\n//# sourceMappingURL=ecdh.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvZWNkaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkM7QUFDSDtBQUNLO0FBQ007QUFDNUM7QUFDUCxjQUFjLDBDQUFLO0FBQ25CLGVBQWUsMENBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0Isb0RBQVU7QUFDMUIsZ0JBQWdCLG9EQUFVO0FBQzFCLGlCQUFpQixxREFBSTtBQUNyQixnQkFBZ0IsaURBQU87QUFDdkI7QUFDQTtBQUNBLFdBQVcsaURBQU8sU0FBUyxxREFBSTtBQUMvQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvZWNkaC5qcz80Y2Q5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmLXV0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBQb2ludCB9IGZyb20gJy4vZWNjLmpzJztcbmltcG9ydCB7IHRhZ2hhc2gsIGhtYWM1MTIgfSBmcm9tICcuL2hhc2guanMnO1xuaW1wb3J0IHsgZ2V0X3NlY2tleSwgZ2V0X3B1YmtleSB9IGZyb20gJy4va2V5cy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0X3NoYXJlZF9rZXkoc2VsZl9zZWMsIHBlZXJfcHViKSB7XG4gICAgY29uc3QgUCA9IFBvaW50LmZyb21feChwZWVyX3B1Yik7XG4gICAgY29uc3Qgc3AgPSBGaWVsZC5tb2Qoc2VsZl9zZWMpO1xuICAgIGNvbnN0IHNoID0gUC5tdWwoc3ApO1xuICAgIHJldHVybiBzaC5idWZmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldF9zaGFyZWRfY29kZShzZWxmX3NlYywgcGVlcl9wdWIsIG1lc3NhZ2UsIHByZWZpeCA9ICdlY2RoL2htYWM1MTInKSB7XG4gICAgY29uc3Qgc2VjID0gZ2V0X3NlY2tleShzZWxmX3NlYyk7XG4gICAgY29uc3QgcHViID0gZ2V0X3B1YmtleShzZWMpO1xuICAgIGNvbnN0IHBlZXIgPSBCdWZmLmJ5dGVzKHBlZXJfcHViKTtcbiAgICBjb25zdCB0YWcgPSB0YWdoYXNoKHByZWZpeCk7XG4gICAgY29uc3Qgc2hhcmVkID0gZ2V0X3NoYXJlZF9rZXkoc2VjLCBwZWVyX3B1Yik7XG4gICAgY29uc3QgcHVicyA9IFtwdWIuaGV4LCBwZWVyLmhleF0uc29ydCgpO1xuICAgIHJldHVybiBobWFjNTEyKHNoYXJlZCwgQnVmZi5qb2luKFsuLi50YWcsIC4uLnB1YnMsIG1lc3NhZ2VdKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lY2RoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecdh.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/hash.js":
/*!*********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/hash.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   digest: () => (/* binding */ digest),\n/* harmony export */   hash160: () => (/* binding */ hash160),\n/* harmony export */   hash256: () => (/* binding */ hash256),\n/* harmony export */   hmac256: () => (/* binding */ hmac256),\n/* harmony export */   hmac512: () => (/* binding */ hmac512),\n/* harmony export */   ripe160: () => (/* binding */ ripe160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   taghash: () => (/* binding */ taghash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n\n\n\n\n\nfunction sha256(msg) {\n    const b = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(msg);\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(b));\n}\nfunction sha512(msg) {\n    const b = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(msg);\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_2__.sha512)(b));\n}\nfunction ripe160(msg) {\n    const b = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(msg);\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_2__.sha512)(b));\n}\nfunction hash256(msg) {\n    const b = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(msg);\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(b)));\n}\nfunction hash160(msg) {\n    const b = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(msg);\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(b)));\n}\nfunction hmac256(key, msg) {\n    const k = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(key);\n    const b = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(msg);\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_4__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, k, b));\n}\nfunction hmac512(key, msg) {\n    const k = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(key);\n    const b = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(msg);\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw((0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_4__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_2__.sha512, k, b));\n}\nfunction taghash(tag) {\n    const hash = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.str(tag).digest;\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([hash, hash]);\n}\nfunction digest(tag, ...data) {\n    const hash = taghash(tag);\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([hash, ...data]).digest;\n}\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvaGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUNBO0FBQ007QUFDVjtBQUNQO0FBQ3BDO0FBQ1AsY0FBYyxxREFBSTtBQUNsQixXQUFXLHFEQUFJLEtBQUssNERBQUk7QUFDeEI7QUFDTztBQUNQLGNBQWMscURBQUk7QUFDbEIsV0FBVyxxREFBSSxLQUFLLDREQUFJO0FBQ3hCO0FBQ087QUFDUCxjQUFjLHFEQUFJO0FBQ2xCLFdBQVcscURBQUksS0FBSyw0REFBSTtBQUN4QjtBQUNPO0FBQ1AsY0FBYyxxREFBSTtBQUNsQixXQUFXLHFEQUFJLEtBQUssNERBQUksQ0FBQyw0REFBSTtBQUM3QjtBQUNPO0FBQ1AsY0FBYyxxREFBSTtBQUNsQixXQUFXLHFEQUFJLEtBQUssa0VBQUksQ0FBQyw0REFBSTtBQUM3QjtBQUNPO0FBQ1AsY0FBYyxxREFBSTtBQUNsQixjQUFjLHFEQUFJO0FBQ2xCLFdBQVcscURBQUksS0FBSyx3REFBSSxDQUFDLHdEQUFJO0FBQzdCO0FBQ087QUFDUCxjQUFjLHFEQUFJO0FBQ2xCLGNBQWMscURBQUk7QUFDbEIsV0FBVyxxREFBSSxLQUFLLHdEQUFJLENBQUMsd0RBQUk7QUFDN0I7QUFDTztBQUNQLGlCQUFpQixxREFBSTtBQUNyQixXQUFXLHFEQUFJO0FBQ2Y7QUFDTztBQUNQO0FBQ0EsV0FBVyxxREFBSTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdXRpbHMvZGlzdC9oYXNoLmpzPzI2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hhMjU2IGFzIHMyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyBzaGE1MTIgYXMgczUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhNTEyJztcbmltcG9ydCB7IHJpcGVtZDE2MCBhcyByMTYwIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAnO1xuaW1wb3J0IHsgaG1hYyBhcyBITUFDIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IEJ1ZmYgfSBmcm9tICdAY21kY29kZS9idWZmLXV0aWxzJztcbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTYobXNnKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmYuYnl0ZXMobXNnKTtcbiAgICByZXR1cm4gQnVmZi5yYXcoczI1NihiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhNTEyKG1zZykge1xuICAgIGNvbnN0IGIgPSBCdWZmLmJ5dGVzKG1zZyk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KHM1MTIoYikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJpcGUxNjAobXNnKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmYuYnl0ZXMobXNnKTtcbiAgICByZXR1cm4gQnVmZi5yYXcoczUxMihiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaDI1Nihtc2cpIHtcbiAgICBjb25zdCBiID0gQnVmZi5ieXRlcyhtc2cpO1xuICAgIHJldHVybiBCdWZmLnJhdyhzMjU2KHMyNTYoYikpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNoMTYwKG1zZykge1xuICAgIGNvbnN0IGIgPSBCdWZmLmJ5dGVzKG1zZyk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KHIxNjAoczI1NihiKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhtYWMyNTYoa2V5LCBtc2cpIHtcbiAgICBjb25zdCBrID0gQnVmZi5ieXRlcyhrZXkpO1xuICAgIGNvbnN0IGIgPSBCdWZmLmJ5dGVzKG1zZyk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KEhNQUMoczI1NiwgaywgYikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhtYWM1MTIoa2V5LCBtc2cpIHtcbiAgICBjb25zdCBrID0gQnVmZi5ieXRlcyhrZXkpO1xuICAgIGNvbnN0IGIgPSBCdWZmLmJ5dGVzKG1zZyk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KEhNQUMoczUxMiwgaywgYikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRhZ2hhc2godGFnKSB7XG4gICAgY29uc3QgaGFzaCA9IEJ1ZmYuc3RyKHRhZykuZGlnZXN0O1xuICAgIHJldHVybiBCdWZmLmpvaW4oW2hhc2gsIGhhc2hdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaWdlc3QodGFnLCAuLi5kYXRhKSB7XG4gICAgY29uc3QgaGFzaCA9IHRhZ2hhc2godGFnKTtcbiAgICByZXR1cm4gQnVmZi5qb2luKFtoYXNoLCAuLi5kYXRhXSkuZGlnZXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/hd.js":
/*!*******************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/hd.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode_extkey: () => (/* binding */ decode_extkey),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   encode_extkey: () => (/* binding */ encode_extkey),\n/* harmony export */   generate_code: () => (/* binding */ generate_code),\n/* harmony export */   parse_extkey: () => (/* binding */ parse_extkey),\n/* harmony export */   parse_tweaks: () => (/* binding */ parse_tweaks)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n/* harmony import */ var _ecc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecc.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/keys.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hash.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/hash.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/assert.js\");\n\n\n\n\n\nconst INT_REGEX = /^[0-9]{0,10}$/, STR_REGEX = /^[0-9a-zA-Z_&?=]{64}$/;\nfunction derive(path, input_key, chain_code, is_private = false) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_4__.valid_chain(path, chain_code);\n    const key = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(input_key);\n    let code = (chain_code !== undefined)\n        ? _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(chain_code)\n        : _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.str('Bitcoin seed');\n    let prev = null, seckey = null, pubkey;\n    if (path.startsWith('m')) {\n        const root = generate_code(code, key);\n        code = root[1];\n        seckey = root[0];\n        pubkey = (0,_keys_js__WEBPACK_IMPORTED_MODULE_2__.get_pubkey)(seckey, false);\n    }\n    else if (is_private) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_4__.size(input_key, 32);\n        seckey = key;\n        pubkey = (0,_keys_js__WEBPACK_IMPORTED_MODULE_2__.get_pubkey)(seckey, false);\n    }\n    else {\n        _assert_js__WEBPACK_IMPORTED_MODULE_4__.size(key, 33);\n        pubkey = key;\n    }\n    const tweaks = parse_tweaks(path);\n    for (const [tweak, is_hardened] of tweaks) {\n        const bytes = (is_hardened && seckey !== null)\n            ? _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([0x00, seckey, tweak])\n            : _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([pubkey, tweak]);\n        const [next_key, next_code] = generate_code(code, bytes);\n        code = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.raw(next_code);\n        prev = pubkey;\n        if (seckey !== null) {\n            seckey = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(seckey).add(next_key).buff;\n            pubkey = (0,_keys_js__WEBPACK_IMPORTED_MODULE_2__.get_pubkey)(seckey, false);\n            _assert_js__WEBPACK_IMPORTED_MODULE_4__.in_field(seckey.big, true);\n        }\n        else {\n            pubkey = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Point.from_x(pubkey).add(next_key).buff;\n            _assert_js__WEBPACK_IMPORTED_MODULE_4__.on_curve(pubkey.slice(1).big, true);\n        }\n    }\n    return { seckey, pubkey, code, path, prev };\n}\nfunction parse_tweaks(keypath) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_4__.valid_path(keypath);\n    const tweaks = [];\n    let paths = keypath.split('/');\n    if (paths[0] === 'm' || paths[0] === '') {\n        paths = paths.slice(1);\n    }\n    for (let path of paths) {\n        let is_hardened = false;\n        if (path.slice(-1) === '\\'') {\n            is_hardened = true;\n            path = path.slice(0, -1);\n        }\n        if (path.match(INT_REGEX) !== null) {\n            let index = parseInt(path, 10);\n            _assert_js__WEBPACK_IMPORTED_MODULE_4__.valid_index(index);\n            if (is_hardened)\n                index += 0x80000000;\n            tweaks.push([_cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.num(index, 4), is_hardened]);\n        }\n        else if (path.match(STR_REGEX) !== null) {\n            let index = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.str(path);\n            if (is_hardened)\n                index = index.prepend(0x80);\n            tweaks.push([index.digest, is_hardened]);\n        }\n        else {\n            throw new Error('Invalid path segment:' + path);\n        }\n    }\n    return tweaks;\n}\nfunction generate_code(chain, data) {\n    const I = (0,_hash_js__WEBPACK_IMPORTED_MODULE_3__.hmac512)(chain, data), IL = I.slice(0, 32), IR = I.slice(32);\n    return [IL, IR];\n}\nfunction encode_extkey(hdkey, key_prefix) {\n    const { seckey, pubkey, code, prev, path } = hdkey;\n    const prefix = (typeof key_prefix === 'number')\n        ? _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.num(key_prefix, 4)\n        : (seckey !== null) ? 0x0488ade4 : 0x0488b21e;\n    const tweaks = parse_tweaks(path);\n    const tprev = tweaks.at(-1);\n    const depth = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.num(tweaks.length, 1);\n    const fprint = (prev !== null) ? (0,_hash_js__WEBPACK_IMPORTED_MODULE_3__.hash160)(prev).slice(0, 4) : _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.num(0, 4);\n    const index = (tprev !== undefined) ? tprev[0].slice(-4, 4) : _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.num(0, 4);\n    const key = (seckey !== null) ? seckey.prepend(0x00) : pubkey;\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([prefix, depth, fprint, index, code, key]).to_b58chk();\n}\nfunction parse_extkey(keystr, path = '') {\n    const { code, type, key } = decode_extkey(keystr);\n    const is_private = (type === 0);\n    const input_key = (is_private) ? key : _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([type, key]);\n    return derive(path, input_key, code, is_private);\n}\nfunction decode_extkey(keystr) {\n    const buffer = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.b58chk(keystr).stream;\n    const prefix = buffer.read(4).num, depth = buffer.read(1).num, fprint = buffer.read(4).num, index = buffer.read(4).num, code = buffer.read(32).hex, type = buffer.read(1).num, key = buffer.read(32).hex, seckey = (type === 0) ? key : undefined, pubkey = (type === 0) ? (0,_keys_js__WEBPACK_IMPORTED_MODULE_2__.get_pubkey)(key).hex : _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([type, key]).hex;\n    if (buffer.size > 0) {\n        throw new TypeError('Unparsed data remaining in buffer!');\n    }\n    return { prefix, depth, fprint, index, code, type, key, seckey, pubkey };\n}\n//# sourceMappingURL=hd.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvaGQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDSDtBQUNEO0FBQ007QUFDUDtBQUN0QywwQkFBMEIsS0FBSyxrQ0FBa0MsR0FBRztBQUM3RDtBQUNQLElBQUksbURBQWtCO0FBQ3RCLGdCQUFnQixxREFBSTtBQUNwQjtBQUNBLFVBQVUscURBQUk7QUFDZCxVQUFVLHFEQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBVTtBQUMzQjtBQUNBO0FBQ0EsUUFBUSw0Q0FBVztBQUNuQjtBQUNBLGlCQUFpQixvREFBVTtBQUMzQjtBQUNBO0FBQ0EsUUFBUSw0Q0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBSTtBQUNsQixjQUFjLHFEQUFJO0FBQ2xCO0FBQ0EsZUFBZSxxREFBSTtBQUNuQjtBQUNBO0FBQ0EscUJBQXFCLDBDQUFLO0FBQzFCLHFCQUFxQixvREFBVTtBQUMvQixZQUFZLGdEQUFlO0FBQzNCO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUs7QUFDMUIsWUFBWSxnREFBZTtBQUMzQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCxJQUFJLGtEQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQWtCO0FBQzlCO0FBQ0E7QUFDQSx5QkFBeUIscURBQUk7QUFDN0I7QUFDQTtBQUNBLHdCQUF3QixxREFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsY0FBYyxpREFBTztBQUNyQjtBQUNBO0FBQ087QUFDUCxZQUFZLG1DQUFtQztBQUMvQztBQUNBLFVBQVUscURBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQUk7QUFDdEIscUNBQXFDLGlEQUFPLHFCQUFxQixxREFBSTtBQUNyRSxrRUFBa0UscURBQUk7QUFDdEU7QUFDQSxXQUFXLHFEQUFJO0FBQ2Y7QUFDTztBQUNQLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsMkNBQTJDLHFEQUFJO0FBQy9DO0FBQ0E7QUFDTztBQUNQLG1CQUFtQixxREFBSTtBQUN2QiwrUUFBK1Esb0RBQVUsWUFBWSxxREFBSTtBQUN6UztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2NyeXB0by11dGlscy9kaXN0L2hkLmpzPzZmOTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZiB9IGZyb20gJ0BjbWRjb2RlL2J1ZmYtdXRpbHMnO1xuaW1wb3J0IHsgRmllbGQsIFBvaW50IH0gZnJvbSAnLi9lY2MuanMnO1xuaW1wb3J0IHsgZ2V0X3B1YmtleSB9IGZyb20gJy4va2V5cy5qcyc7XG5pbXBvcnQgeyBoYXNoMTYwLCBobWFjNTEyIH0gZnJvbSAnLi9oYXNoLmpzJztcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tICcuL2Fzc2VydC5qcyc7XG5jb25zdCBJTlRfUkVHRVggPSAvXlswLTldezAsMTB9JC8sIFNUUl9SRUdFWCA9IC9eWzAtOWEtekEtWl8mPz1dezY0fSQvO1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZShwYXRoLCBpbnB1dF9rZXksIGNoYWluX2NvZGUsIGlzX3ByaXZhdGUgPSBmYWxzZSkge1xuICAgIGFzc2VydC52YWxpZF9jaGFpbihwYXRoLCBjaGFpbl9jb2RlKTtcbiAgICBjb25zdCBrZXkgPSBCdWZmLmJ5dGVzKGlucHV0X2tleSk7XG4gICAgbGV0IGNvZGUgPSAoY2hhaW5fY29kZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IEJ1ZmYuYnl0ZXMoY2hhaW5fY29kZSlcbiAgICAgICAgOiBCdWZmLnN0cignQml0Y29pbiBzZWVkJyk7XG4gICAgbGV0IHByZXYgPSBudWxsLCBzZWNrZXkgPSBudWxsLCBwdWJrZXk7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnbScpKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBnZW5lcmF0ZV9jb2RlKGNvZGUsIGtleSk7XG4gICAgICAgIGNvZGUgPSByb290WzFdO1xuICAgICAgICBzZWNrZXkgPSByb290WzBdO1xuICAgICAgICBwdWJrZXkgPSBnZXRfcHVia2V5KHNlY2tleSwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc19wcml2YXRlKSB7XG4gICAgICAgIGFzc2VydC5zaXplKGlucHV0X2tleSwgMzIpO1xuICAgICAgICBzZWNrZXkgPSBrZXk7XG4gICAgICAgIHB1YmtleSA9IGdldF9wdWJrZXkoc2Vja2V5LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnQuc2l6ZShrZXksIDMzKTtcbiAgICAgICAgcHVia2V5ID0ga2V5O1xuICAgIH1cbiAgICBjb25zdCB0d2Vha3MgPSBwYXJzZV90d2Vha3MocGF0aCk7XG4gICAgZm9yIChjb25zdCBbdHdlYWssIGlzX2hhcmRlbmVkXSBvZiB0d2Vha3MpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSAoaXNfaGFyZGVuZWQgJiYgc2Vja2V5ICE9PSBudWxsKVxuICAgICAgICAgICAgPyBCdWZmLmpvaW4oWzB4MDAsIHNlY2tleSwgdHdlYWtdKVxuICAgICAgICAgICAgOiBCdWZmLmpvaW4oW3B1YmtleSwgdHdlYWtdKTtcbiAgICAgICAgY29uc3QgW25leHRfa2V5LCBuZXh0X2NvZGVdID0gZ2VuZXJhdGVfY29kZShjb2RlLCBieXRlcyk7XG4gICAgICAgIGNvZGUgPSBCdWZmLnJhdyhuZXh0X2NvZGUpO1xuICAgICAgICBwcmV2ID0gcHVia2V5O1xuICAgICAgICBpZiAoc2Vja2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZWNrZXkgPSBGaWVsZC5tb2Qoc2Vja2V5KS5hZGQobmV4dF9rZXkpLmJ1ZmY7XG4gICAgICAgICAgICBwdWJrZXkgPSBnZXRfcHVia2V5KHNlY2tleSwgZmFsc2UpO1xuICAgICAgICAgICAgYXNzZXJ0LmluX2ZpZWxkKHNlY2tleS5iaWcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHVia2V5ID0gUG9pbnQuZnJvbV94KHB1YmtleSkuYWRkKG5leHRfa2V5KS5idWZmO1xuICAgICAgICAgICAgYXNzZXJ0Lm9uX2N1cnZlKHB1YmtleS5zbGljZSgxKS5iaWcsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHNlY2tleSwgcHVia2V5LCBjb2RlLCBwYXRoLCBwcmV2IH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VfdHdlYWtzKGtleXBhdGgpIHtcbiAgICBhc3NlcnQudmFsaWRfcGF0aChrZXlwYXRoKTtcbiAgICBjb25zdCB0d2Vha3MgPSBbXTtcbiAgICBsZXQgcGF0aHMgPSBrZXlwYXRoLnNwbGl0KCcvJyk7XG4gICAgaWYgKHBhdGhzWzBdID09PSAnbScgfHwgcGF0aHNbMF0gPT09ICcnKSB7XG4gICAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfVxuICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgbGV0IGlzX2hhcmRlbmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAgIGlzX2hhcmRlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5tYXRjaChJTlRfUkVHRVgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJzZUludChwYXRoLCAxMCk7XG4gICAgICAgICAgICBhc3NlcnQudmFsaWRfaW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGlzX2hhcmRlbmVkKVxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDB4ODAwMDAwMDA7XG4gICAgICAgICAgICB0d2Vha3MucHVzaChbQnVmZi5udW0oaW5kZXgsIDQpLCBpc19oYXJkZW5lZF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGgubWF0Y2goU1RSX1JFR0VYKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gQnVmZi5zdHIocGF0aCk7XG4gICAgICAgICAgICBpZiAoaXNfaGFyZGVuZWQpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleC5wcmVwZW5kKDB4ODApO1xuICAgICAgICAgICAgdHdlYWtzLnB1c2goW2luZGV4LmRpZ2VzdCwgaXNfaGFyZGVuZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRoIHNlZ21lbnQ6JyArIHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0d2Vha3M7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVfY29kZShjaGFpbiwgZGF0YSkge1xuICAgIGNvbnN0IEkgPSBobWFjNTEyKGNoYWluLCBkYXRhKSwgSUwgPSBJLnNsaWNlKDAsIDMyKSwgSVIgPSBJLnNsaWNlKDMyKTtcbiAgICByZXR1cm4gW0lMLCBJUl07XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlX2V4dGtleShoZGtleSwga2V5X3ByZWZpeCkge1xuICAgIGNvbnN0IHsgc2Vja2V5LCBwdWJrZXksIGNvZGUsIHByZXYsIHBhdGggfSA9IGhka2V5O1xuICAgIGNvbnN0IHByZWZpeCA9ICh0eXBlb2Yga2V5X3ByZWZpeCA9PT0gJ251bWJlcicpXG4gICAgICAgID8gQnVmZi5udW0oa2V5X3ByZWZpeCwgNClcbiAgICAgICAgOiAoc2Vja2V5ICE9PSBudWxsKSA/IDB4MDQ4OGFkZTQgOiAweDA0ODhiMjFlO1xuICAgIGNvbnN0IHR3ZWFrcyA9IHBhcnNlX3R3ZWFrcyhwYXRoKTtcbiAgICBjb25zdCB0cHJldiA9IHR3ZWFrcy5hdCgtMSk7XG4gICAgY29uc3QgZGVwdGggPSBCdWZmLm51bSh0d2Vha3MubGVuZ3RoLCAxKTtcbiAgICBjb25zdCBmcHJpbnQgPSAocHJldiAhPT0gbnVsbCkgPyBoYXNoMTYwKHByZXYpLnNsaWNlKDAsIDQpIDogQnVmZi5udW0oMCwgNCk7XG4gICAgY29uc3QgaW5kZXggPSAodHByZXYgIT09IHVuZGVmaW5lZCkgPyB0cHJldlswXS5zbGljZSgtNCwgNCkgOiBCdWZmLm51bSgwLCA0KTtcbiAgICBjb25zdCBrZXkgPSAoc2Vja2V5ICE9PSBudWxsKSA/IHNlY2tleS5wcmVwZW5kKDB4MDApIDogcHVia2V5O1xuICAgIHJldHVybiBCdWZmLmpvaW4oW3ByZWZpeCwgZGVwdGgsIGZwcmludCwgaW5kZXgsIGNvZGUsIGtleV0pLnRvX2I1OGNoaygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlX2V4dGtleShrZXlzdHIsIHBhdGggPSAnJykge1xuICAgIGNvbnN0IHsgY29kZSwgdHlwZSwga2V5IH0gPSBkZWNvZGVfZXh0a2V5KGtleXN0cik7XG4gICAgY29uc3QgaXNfcHJpdmF0ZSA9ICh0eXBlID09PSAwKTtcbiAgICBjb25zdCBpbnB1dF9rZXkgPSAoaXNfcHJpdmF0ZSkgPyBrZXkgOiBCdWZmLmpvaW4oW3R5cGUsIGtleV0pO1xuICAgIHJldHVybiBkZXJpdmUocGF0aCwgaW5wdXRfa2V5LCBjb2RlLCBpc19wcml2YXRlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVfZXh0a2V5KGtleXN0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmYuYjU4Y2hrKGtleXN0cikuc3RyZWFtO1xuICAgIGNvbnN0IHByZWZpeCA9IGJ1ZmZlci5yZWFkKDQpLm51bSwgZGVwdGggPSBidWZmZXIucmVhZCgxKS5udW0sIGZwcmludCA9IGJ1ZmZlci5yZWFkKDQpLm51bSwgaW5kZXggPSBidWZmZXIucmVhZCg0KS5udW0sIGNvZGUgPSBidWZmZXIucmVhZCgzMikuaGV4LCB0eXBlID0gYnVmZmVyLnJlYWQoMSkubnVtLCBrZXkgPSBidWZmZXIucmVhZCgzMikuaGV4LCBzZWNrZXkgPSAodHlwZSA9PT0gMCkgPyBrZXkgOiB1bmRlZmluZWQsIHB1YmtleSA9ICh0eXBlID09PSAwKSA/IGdldF9wdWJrZXkoa2V5KS5oZXggOiBCdWZmLmpvaW4oW3R5cGUsIGtleV0pLmhleDtcbiAgICBpZiAoYnVmZmVyLnNpemUgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucGFyc2VkIGRhdGEgcmVtYWluaW5nIGluIGJ1ZmZlciEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcHJlZml4LCBkZXB0aCwgZnByaW50LCBpbmRleCwgY29kZSwgdHlwZSwga2V5LCBzZWNrZXksIHB1YmtleSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/hd.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONST: () => (/* reexport module object */ _const_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   Field: () => (/* reexport safe */ _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field),\n/* harmony export */   Point: () => (/* reexport safe */ _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Point),\n/* harmony export */   assert: () => (/* reexport module object */ _assert_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   ecdh: () => (/* reexport module object */ _ecdh_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   fd: () => (/* reexport safe */ _ecc_js__WEBPACK_IMPORTED_MODULE_2__.fd),\n/* harmony export */   hash: () => (/* reexport module object */ _hash_js__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   hd: () => (/* reexport module object */ _hd_js__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   keys: () => (/* reexport module object */ _keys_js__WEBPACK_IMPORTED_MODULE_9__),\n/* harmony export */   math: () => (/* reexport module object */ _math_js__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   proof: () => (/* reexport module object */ _proof_js__WEBPACK_IMPORTED_MODULE_11__),\n/* harmony export */   pt: () => (/* reexport module object */ _point_js__WEBPACK_IMPORTED_MODULE_12__),\n/* harmony export */   sign_config: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_1__.sign_config),\n/* harmony export */   signer: () => (/* reexport module object */ _sig_js__WEBPACK_IMPORTED_MODULE_13__),\n/* harmony export */   util: () => (/* reexport module object */ _util_js__WEBPACK_IMPORTED_MODULE_14__)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/config.js\");\n/* harmony import */ var _ecc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecc.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/types.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/assert.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/const.js\");\n/* harmony import */ var _ecdh_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ecdh.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecdh.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hash.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/hash.js\");\n/* harmony import */ var _hd_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./hd.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/hd.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/keys.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/math.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./proof.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/proof.js\");\n/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./point.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/point.js\");\n/* harmony import */ var _sig_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sig.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/sig.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/util.js\");\n\nconst noble = { secp: _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1, schnorr: _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr };\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUM5RCxnQkFBZ0IsSUFBSSx5RUFBUztBQUNSO0FBQ0g7QUFDRTtBQUNXO0FBQ0Y7QUFDRjtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0U7QUFDSDtBQUNFO0FBQ0Q7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdXRpbHMvZGlzdC9pbmRleC5qcz9jZGE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlY3AyNTZrMSBhcyBzZWNwLCBzY2hub3JyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuZXhwb3J0IGNvbnN0IG5vYmxlID0geyBzZWNwLCBzY2hub3JyIH07XG5leHBvcnQgKiBmcm9tICcuL2NvbmZpZy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2VjYy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzLmpzJztcbmV4cG9ydCAqIGFzIGFzc2VydCBmcm9tICcuL2Fzc2VydC5qcyc7XG5leHBvcnQgKiBhcyBDT05TVCBmcm9tICcuL2NvbnN0LmpzJztcbmV4cG9ydCAqIGFzIGVjZGggZnJvbSAnLi9lY2RoLmpzJztcbmV4cG9ydCAqIGFzIGhhc2ggZnJvbSAnLi9oYXNoLmpzJztcbmV4cG9ydCAqIGFzIGhkIGZyb20gJy4vaGQuanMnO1xuZXhwb3J0ICogYXMga2V5cyBmcm9tICcuL2tleXMuanMnO1xuZXhwb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnO1xuZXhwb3J0ICogYXMgcHJvb2YgZnJvbSAnLi9wcm9vZi5qcyc7XG5leHBvcnQgKiBhcyBwdCBmcm9tICcuL3BvaW50LmpzJztcbmV4cG9ydCAqIGFzIHNpZ25lciBmcm9tICcuL3NpZy5qcyc7XG5leHBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbC5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/keys.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convert_32: () => (/* binding */ convert_32),\n/* harmony export */   convert_33: () => (/* binding */ convert_33),\n/* harmony export */   gen_keypair: () => (/* binding */ gen_keypair),\n/* harmony export */   gen_seckey: () => (/* binding */ gen_seckey),\n/* harmony export */   get_keypair: () => (/* binding */ get_keypair),\n/* harmony export */   get_pubkey: () => (/* binding */ get_pubkey),\n/* harmony export */   get_seckey: () => (/* binding */ get_seckey),\n/* harmony export */   is_even_pub: () => (/* binding */ is_even_pub),\n/* harmony export */   negate_seckey: () => (/* binding */ negate_seckey),\n/* harmony export */   tweak_pubkey: () => (/* binding */ tweak_pubkey),\n/* harmony export */   tweak_seckey: () => (/* binding */ tweak_seckey)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n/* harmony import */ var _ecc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecc.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/util.js\");\n\n\n\nfunction is_even_pub(pubkey) {\n    const pub = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pubkey);\n    switch (true) {\n        case (pub.length === 32):\n            return true;\n        case (pub.length === 33 && pub[0] === 0x02):\n            return true;\n        case (pub.length === 33 && pub[0] === 0x03):\n            return false;\n        default:\n            throw new TypeError(`Invalid public key: ${pub.hex}`);\n    }\n}\nfunction gen_seckey(even_y) {\n    return get_seckey((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.random)(32), even_y);\n}\nfunction get_seckey(secret, even_y = false) {\n    const sec = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(secret);\n    return (even_y) ? sec.negated.buff : sec.buff;\n}\nfunction get_pubkey(seckey, x_only = false) {\n    const p = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(seckey).point;\n    return (x_only) ? p.x : p.buff;\n}\nfunction tweak_seckey(seckey, tweaks = [], even_y = false) {\n    let sec = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(seckey);\n    for (const twk of tweaks) {\n        sec = sec.add(twk);\n        if (even_y)\n            sec = sec.negated;\n    }\n    return sec.buff;\n}\nfunction tweak_pubkey(pubkey, tweaks = [], x_only = false) {\n    let pub = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Point.from_x(pubkey, x_only);\n    for (const twk of tweaks) {\n        pub = pub.add(twk);\n        if (x_only)\n            pub = pub.negated;\n    }\n    return (x_only) ? pub.x : pub.buff;\n}\nfunction negate_seckey(seckey, negate) {\n    const s = _ecc_js__WEBPACK_IMPORTED_MODULE_1__.Field.mod(seckey);\n    return (negate) ? s.negate().buff : s.buff;\n}\nfunction get_keypair(secret, x_only, even_y) {\n    const sec = get_seckey(secret, even_y);\n    const pub = get_pubkey(sec, x_only);\n    return [sec, pub];\n}\nfunction gen_keypair(x_only, even_y) {\n    const sec = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.random)(32);\n    return get_keypair(sec, x_only, even_y);\n}\nfunction convert_32(pubkey) {\n    const key = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pubkey);\n    if (key.length === 32)\n        return key;\n    if (key.length === 33)\n        return key.slice(1, 33);\n    throw new TypeError(`Invalid key length: ${key.length}`);\n}\nfunction convert_33(pubkey, even_y = false) {\n    const key = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pubkey);\n    if (key.length === 32) {\n        return key.prepend(0x02);\n    }\n    else if (key.length === 33) {\n        if (even_y)\n            key[0] = 0x02;\n        return key;\n    }\n    throw new TypeError(`Invalid key size: ${key.length}`);\n}\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3Qva2V5cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQztBQUNIO0FBQ0w7QUFDNUI7QUFDUCxnQkFBZ0IscURBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDTztBQUNQLHNCQUFzQixnREFBTTtBQUM1QjtBQUNPO0FBQ1AsZ0JBQWdCLDBDQUFLO0FBQ3JCO0FBQ0E7QUFDTztBQUNQLGNBQWMsMENBQUs7QUFDbkI7QUFDQTtBQUNPO0FBQ1AsY0FBYywwQ0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsY0FBYywwQ0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsY0FBYywwQ0FBSztBQUNuQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLGdEQUFNO0FBQ3RCO0FBQ0E7QUFDTztBQUNQLGdCQUFnQixxREFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ087QUFDUCxnQkFBZ0IscURBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdXRpbHMvZGlzdC9rZXlzLmpzP2VkYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZiB9IGZyb20gJ0BjbWRjb2RlL2J1ZmYtdXRpbHMnO1xuaW1wb3J0IHsgRmllbGQsIFBvaW50IH0gZnJvbSAnLi9lY2MuanMnO1xuaW1wb3J0IHsgcmFuZG9tIH0gZnJvbSAnLi91dGlsLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpc19ldmVuX3B1YihwdWJrZXkpIHtcbiAgICBjb25zdCBwdWIgPSBCdWZmLmJ5dGVzKHB1YmtleSk7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgKHB1Yi5sZW5ndGggPT09IDMyKTpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIChwdWIubGVuZ3RoID09PSAzMyAmJiBwdWJbMF0gPT09IDB4MDIpOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgKHB1Yi5sZW5ndGggPT09IDMzICYmIHB1YlswXSA9PT0gMHgwMyk6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHB1YmxpYyBrZXk6ICR7cHViLmhleH1gKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuX3NlY2tleShldmVuX3kpIHtcbiAgICByZXR1cm4gZ2V0X3NlY2tleShyYW5kb20oMzIpLCBldmVuX3kpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldF9zZWNrZXkoc2VjcmV0LCBldmVuX3kgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlYyA9IEZpZWxkLm1vZChzZWNyZXQpO1xuICAgIHJldHVybiAoZXZlbl95KSA/IHNlYy5uZWdhdGVkLmJ1ZmYgOiBzZWMuYnVmZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRfcHVia2V5KHNlY2tleSwgeF9vbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBwID0gRmllbGQubW9kKHNlY2tleSkucG9pbnQ7XG4gICAgcmV0dXJuICh4X29ubHkpID8gcC54IDogcC5idWZmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR3ZWFrX3NlY2tleShzZWNrZXksIHR3ZWFrcyA9IFtdLCBldmVuX3kgPSBmYWxzZSkge1xuICAgIGxldCBzZWMgPSBGaWVsZC5tb2Qoc2Vja2V5KTtcbiAgICBmb3IgKGNvbnN0IHR3ayBvZiB0d2Vha3MpIHtcbiAgICAgICAgc2VjID0gc2VjLmFkZCh0d2spO1xuICAgICAgICBpZiAoZXZlbl95KVxuICAgICAgICAgICAgc2VjID0gc2VjLm5lZ2F0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBzZWMuYnVmZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0d2Vha19wdWJrZXkocHVia2V5LCB0d2Vha3MgPSBbXSwgeF9vbmx5ID0gZmFsc2UpIHtcbiAgICBsZXQgcHViID0gUG9pbnQuZnJvbV94KHB1YmtleSwgeF9vbmx5KTtcbiAgICBmb3IgKGNvbnN0IHR3ayBvZiB0d2Vha3MpIHtcbiAgICAgICAgcHViID0gcHViLmFkZCh0d2spO1xuICAgICAgICBpZiAoeF9vbmx5KVxuICAgICAgICAgICAgcHViID0gcHViLm5lZ2F0ZWQ7XG4gICAgfVxuICAgIHJldHVybiAoeF9vbmx5KSA/IHB1Yi54IDogcHViLmJ1ZmY7XG59XG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlX3NlY2tleShzZWNrZXksIG5lZ2F0ZSkge1xuICAgIGNvbnN0IHMgPSBGaWVsZC5tb2Qoc2Vja2V5KTtcbiAgICByZXR1cm4gKG5lZ2F0ZSkgPyBzLm5lZ2F0ZSgpLmJ1ZmYgOiBzLmJ1ZmY7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0X2tleXBhaXIoc2VjcmV0LCB4X29ubHksIGV2ZW5feSkge1xuICAgIGNvbnN0IHNlYyA9IGdldF9zZWNrZXkoc2VjcmV0LCBldmVuX3kpO1xuICAgIGNvbnN0IHB1YiA9IGdldF9wdWJrZXkoc2VjLCB4X29ubHkpO1xuICAgIHJldHVybiBbc2VjLCBwdWJdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbl9rZXlwYWlyKHhfb25seSwgZXZlbl95KSB7XG4gICAgY29uc3Qgc2VjID0gcmFuZG9tKDMyKTtcbiAgICByZXR1cm4gZ2V0X2tleXBhaXIoc2VjLCB4X29ubHksIGV2ZW5feSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydF8zMihwdWJrZXkpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmLmJ5dGVzKHB1YmtleSk7XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDMyKVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIGlmIChrZXkubGVuZ3RoID09PSAzMylcbiAgICAgICAgcmV0dXJuIGtleS5zbGljZSgxLCAzMyk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBrZXkgbGVuZ3RoOiAke2tleS5sZW5ndGh9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydF8zMyhwdWJrZXksIGV2ZW5feSA9IGZhbHNlKSB7XG4gICAgY29uc3Qga2V5ID0gQnVmZi5ieXRlcyhwdWJrZXkpO1xuICAgIGlmIChrZXkubGVuZ3RoID09PSAzMikge1xuICAgICAgICByZXR1cm4ga2V5LnByZXBlbmQoMHgwMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleS5sZW5ndGggPT09IDMzKSB7XG4gICAgICAgIGlmIChldmVuX3kpXG4gICAgICAgICAgICBrZXlbMF0gPSAweDAyO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGtleSBzaXplOiAke2tleS5sZW5ndGh9YCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/math.js":
/*!*********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/math.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   in_field: () => (/* binding */ in_field),\n/* harmony export */   invert: () => (/* reexport safe */ _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.invert),\n/* harmony export */   mod: () => (/* reexport safe */ _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod),\n/* harmony export */   modN: () => (/* binding */ modN),\n/* harmony export */   modP: () => (/* binding */ modP),\n/* harmony export */   mod_bytes: () => (/* binding */ mod_bytes),\n/* harmony export */   on_curve: () => (/* binding */ on_curve),\n/* harmony export */   pow: () => (/* reexport safe */ _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.pow),\n/* harmony export */   pow2: () => (/* reexport safe */ _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.pow2),\n/* harmony export */   powN: () => (/* binding */ powN)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/const.js\");\n\n\n\n\nconst modN = (x) => (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(x, _const_js__WEBPACK_IMPORTED_MODULE_1__._N);\nconst modP = (x) => (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(x, _const_js__WEBPACK_IMPORTED_MODULE_1__._P);\nconst powN = (x, exp) => (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.pow)(x, exp, _const_js__WEBPACK_IMPORTED_MODULE_1__._N);\nconst on_curve = (x) => {\n    return typeof x === 'bigint' && _const_js__WEBPACK_IMPORTED_MODULE_1__._0n < x && x < _const_js__WEBPACK_IMPORTED_MODULE_1__._P;\n};\nconst in_field = (x) => {\n    return typeof x === 'bigint' && _const_js__WEBPACK_IMPORTED_MODULE_1__._0n < x && x < _const_js__WEBPACK_IMPORTED_MODULE_1__._N;\n};\nfunction mod_bytes(bytes) {\n    const b = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(bytes).big;\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.big(modN(b), 32);\n}\n//# sourceMappingURL=math.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvbWF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ2U7QUFDakI7QUFDK0I7QUFDakUsb0JBQW9CLG1FQUFHLElBQUkseUNBQUU7QUFDN0Isb0JBQW9CLG1FQUFHLElBQUkseUNBQUU7QUFDN0IseUJBQXlCLG1FQUFHLFNBQVMseUNBQUU7QUFDdkM7QUFDUCxvQ0FBb0MsMENBQUcsWUFBWSx5Q0FBRTtBQUNyRDtBQUNPO0FBQ1Asb0NBQW9DLDBDQUFHLFlBQVkseUNBQUU7QUFDckQ7QUFDTztBQUNQLGNBQWMscURBQUk7QUFDbEIsV0FBVyxxREFBSTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdXRpbHMvZGlzdC9tYXRoLmpzP2U3NzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZiB9IGZyb20gJ0BjbWRjb2RlL2J1ZmYtdXRpbHMnO1xuaW1wb3J0IHsgbW9kLCBwb3cgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuaW1wb3J0IHsgX04sIF9QLCBfMG4gfSBmcm9tICcuL2NvbnN0LmpzJztcbmV4cG9ydCB7IG1vZCwgcG93LCBwb3cyLCBpbnZlcnQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuZXhwb3J0IGNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIF9OKTtcbmV4cG9ydCBjb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBfUCk7XG5leHBvcnQgY29uc3QgcG93TiA9ICh4LCBleHApID0+IHBvdyh4LCBleHAsIF9OKTtcbmV4cG9ydCBjb25zdCBvbl9jdXJ2ZSA9ICh4KSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBfUDtcbn07XG5leHBvcnQgY29uc3QgaW5fZmllbGQgPSAoeCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgX047XG59O1xuZXhwb3J0IGZ1bmN0aW9uIG1vZF9ieXRlcyhieXRlcykge1xuICAgIGNvbnN0IGIgPSBCdWZmLmJ5dGVzKGJ5dGVzKS5iaWc7XG4gICAgcmV0dXJuIEJ1ZmYuYmlnKG1vZE4oYiksIDMyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/point.js":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/point.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Noble: () => (/* binding */ Noble),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   assert_valid: () => (/* binding */ assert_valid),\n/* harmony export */   eq: () => (/* binding */ eq),\n/* harmony export */   gen: () => (/* binding */ gen),\n/* harmony export */   is_even: () => (/* binding */ is_even),\n/* harmony export */   is_point: () => (/* binding */ is_point),\n/* harmony export */   is_valid: () => (/* binding */ is_valid),\n/* harmony export */   lift_x: () => (/* binding */ lift_x),\n/* harmony export */   mul: () => (/* binding */ mul),\n/* harmony export */   negate: () => (/* binding */ negate),\n/* harmony export */   sub: () => (/* binding */ sub),\n/* harmony export */   to_bytes: () => (/* binding */ to_bytes)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/const.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/keys.js\");\n\n\n\n\nconst ECPoint = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__.secp256k1.ProjectivePoint;\nconst Noble = ECPoint;\nfunction is_even(p) {\n    const pa = new ECPoint(p.x, p.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    return pa.hasEvenY();\n}\nfunction is_point(point) {\n    const p = point;\n    return ((typeof p === 'object' && p !== null) &&\n        (typeof p.x === 'bigint' && typeof p.y === 'bigint'));\n}\nfunction is_valid(point) {\n    if (!is_point(point))\n        return false;\n    const pt = new ECPoint(point.x, point.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    try {\n        pt.assertValidity();\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction assert_valid(p) {\n    if (!is_valid(p)) {\n        throw new Error('ECC point is invalid: ' + String(p));\n    }\n}\nfunction negate(a) {\n    const pa = new ECPoint(a.x, a.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    try {\n        const pc = pa.negate();\n        pc.assertValidity();\n        return { x: pc.x, y: pc.y };\n    }\n    catch {\n        return null;\n    }\n}\nfunction add(a, b) {\n    if (a === null)\n        return b;\n    if (b === null)\n        return a;\n    const pa = new ECPoint(a.x, a.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    const pb = new ECPoint(b.x, b.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    try {\n        const pc = pa.add(pb);\n        pc.assertValidity();\n        return { x: pc.x, y: pc.y };\n    }\n    catch {\n        return null;\n    }\n}\nfunction sub(a, b) {\n    if (a === null)\n        return b;\n    if (b === null)\n        return a;\n    const pa = new ECPoint(a.x, a.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    const pb = new ECPoint(b.x, b.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n    try {\n        const pc = pa.subtract(pb);\n        pc.assertValidity();\n        return { x: pc.x, y: pc.y };\n    }\n    catch {\n        return null;\n    }\n}\nfunction eq(a, b) {\n    if (a === null && b === null) {\n        return true;\n    }\n    if (a !== null && b !== null) {\n        return (a.x === b.x && a.y === b.y);\n    }\n    return false;\n}\nfunction mul(a, b) {\n    if (a === null)\n        return null;\n    try {\n        const buff = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(b);\n        const pa = new ECPoint(a.x, a.y, _const_js__WEBPACK_IMPORTED_MODULE_1__._1n);\n        const pc = pa.multiply(buff.big);\n        pc.assertValidity();\n        return { x: pc.x, y: pc.y };\n    }\n    catch {\n        return null;\n    }\n}\nfunction gen(b) {\n    const buff = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(b);\n    const base = ECPoint.BASE;\n    const pt = base.multiply(buff.big);\n    pt.assertValidity();\n    return { x: pt.x, y: pt.y };\n}\nfunction lift_x(bytes, xonly = false) {\n    const buff = (0,_keys_js__WEBPACK_IMPORTED_MODULE_2__.convert_33)(bytes, xonly);\n    const point = ECPoint.fromHex(buff.hex);\n    point.assertValidity();\n    return { x: point.x, y: point.y };\n}\nfunction to_bytes(p) {\n    const bytes = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.big(p.x, 32);\n    const parity = is_even(p) ? 0x02 : 0x03;\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([parity, bytes]);\n}\n//# sourceMappingURL=point.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvcG9pbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDUztBQUNuQjtBQUNNO0FBQ3ZDLGdCQUFnQiw4REFBUztBQUNsQjtBQUNBO0FBQ1AscUNBQXFDLDBDQUFHO0FBQ3hDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsNkNBQTZDLDBDQUFHO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQ0FBcUMsMENBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBDQUFHO0FBQ3hDLHFDQUFxQywwQ0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMENBQUc7QUFDeEMscUNBQXFDLDBDQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscURBQUk7QUFDekIseUNBQXlDLDBDQUFHO0FBQzVDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLHFEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsaUJBQWlCLG9EQUFVO0FBQzNCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLGtCQUFrQixxREFBSTtBQUN0QjtBQUNBLFdBQVcscURBQUk7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvcG9pbnQuanM/ZjIyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmIH0gZnJvbSAnQGNtZGNvZGUvYnVmZi11dGlscyc7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgeyBfMW4gfSBmcm9tICcuL2NvbnN0LmpzJztcbmltcG9ydCB7IGNvbnZlcnRfMzMgfSBmcm9tICcuL2tleXMuanMnO1xuY29uc3QgRUNQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5leHBvcnQgY29uc3QgTm9ibGUgPSBFQ1BvaW50O1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2V2ZW4ocCkge1xuICAgIGNvbnN0IHBhID0gbmV3IEVDUG9pbnQocC54LCBwLnksIF8xbik7XG4gICAgcmV0dXJuIHBhLmhhc0V2ZW5ZKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNfcG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCBwID0gcG9pbnQ7XG4gICAgcmV0dXJuICgodHlwZW9mIHAgPT09ICdvYmplY3QnICYmIHAgIT09IG51bGwpICYmXG4gICAgICAgICh0eXBlb2YgcC54ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgcC55ID09PSAnYmlnaW50JykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzX3ZhbGlkKHBvaW50KSB7XG4gICAgaWYgKCFpc19wb2ludChwb2ludCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwdCA9IG5ldyBFQ1BvaW50KHBvaW50LngsIHBvaW50LnksIF8xbik7XG4gICAgdHJ5IHtcbiAgICAgICAgcHQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRfdmFsaWQocCkge1xuICAgIGlmICghaXNfdmFsaWQocCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFQ0MgcG9pbnQgaXMgaW52YWxpZDogJyArIFN0cmluZyhwKSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShhKSB7XG4gICAgY29uc3QgcGEgPSBuZXcgRUNQb2ludChhLngsIGEueSwgXzFuKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYyA9IHBhLm5lZ2F0ZSgpO1xuICAgICAgICBwYy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4geyB4OiBwYy54LCB5OiBwYy55IH07XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBiO1xuICAgIGlmIChiID09PSBudWxsKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBjb25zdCBwYSA9IG5ldyBFQ1BvaW50KGEueCwgYS55LCBfMW4pO1xuICAgIGNvbnN0IHBiID0gbmV3IEVDUG9pbnQoYi54LCBiLnksIF8xbik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGMgPSBwYS5hZGQocGIpO1xuICAgICAgICBwYy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4geyB4OiBwYy54LCB5OiBwYy55IH07XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBiO1xuICAgIGlmIChiID09PSBudWxsKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBjb25zdCBwYSA9IG5ldyBFQ1BvaW50KGEueCwgYS55LCBfMW4pO1xuICAgIGNvbnN0IHBiID0gbmV3IEVDUG9pbnQoYi54LCBiLnksIF8xbik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGMgPSBwYS5zdWJ0cmFjdChwYik7XG4gICAgICAgIHBjLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiB7IHg6IHBjLngsIHk6IHBjLnkgfTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZXEoYSwgYikge1xuICAgIGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhICE9PSBudWxsICYmIGIgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIChhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtdWwoYSwgYikge1xuICAgIGlmIChhID09PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBidWZmID0gQnVmZi5ieXRlcyhiKTtcbiAgICAgICAgY29uc3QgcGEgPSBuZXcgRUNQb2ludChhLngsIGEueSwgXzFuKTtcbiAgICAgICAgY29uc3QgcGMgPSBwYS5tdWx0aXBseShidWZmLmJpZyk7XG4gICAgICAgIHBjLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiB7IHg6IHBjLngsIHk6IHBjLnkgfTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuKGIpIHtcbiAgICBjb25zdCBidWZmID0gQnVmZi5ieXRlcyhiKTtcbiAgICBjb25zdCBiYXNlID0gRUNQb2ludC5CQVNFO1xuICAgIGNvbnN0IHB0ID0gYmFzZS5tdWx0aXBseShidWZmLmJpZyk7XG4gICAgcHQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4geyB4OiBwdC54LCB5OiBwdC55IH07XG59XG5leHBvcnQgZnVuY3Rpb24gbGlmdF94KGJ5dGVzLCB4b25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgYnVmZiA9IGNvbnZlcnRfMzMoYnl0ZXMsIHhvbmx5KTtcbiAgICBjb25zdCBwb2ludCA9IEVDUG9pbnQuZnJvbUhleChidWZmLmhleCk7XG4gICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4geyB4OiBwb2ludC54LCB5OiBwb2ludC55IH07XG59XG5leHBvcnQgZnVuY3Rpb24gdG9fYnl0ZXMocCkge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZi5iaWcocC54LCAzMik7XG4gICAgY29uc3QgcGFyaXR5ID0gaXNfZXZlbihwKSA/IDB4MDIgOiAweDAzO1xuICAgIHJldHVybiBCdWZmLmpvaW4oW3Bhcml0eSwgYnl0ZXNdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvaW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/point.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/proof.js":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/proof.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create_event: () => (/* binding */ create_event),\n/* harmony export */   create_proof: () => (/* binding */ create_proof),\n/* harmony export */   decode_params: () => (/* binding */ decode_params),\n/* harmony export */   encode_params: () => (/* binding */ encode_params),\n/* harmony export */   parse_config: () => (/* binding */ parse_config),\n/* harmony export */   parse_proof: () => (/* binding */ parse_proof),\n/* harmony export */   parse_proofs: () => (/* binding */ parse_proofs),\n/* harmony export */   validate_proof: () => (/* binding */ validate_proof),\n/* harmony export */   verify_proof: () => (/* binding */ verify_proof)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/keys.js\");\n/* harmony import */ var _sig_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sig.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/sig.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/assert.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/util.js\");\n\n\n\n\n\nconst PROOF_DEFAULTS = {\n    kind: 20000,\n    stamp: 0x00000000,\n    tags: []\n};\nfunction create_proof(seckey, data, params, options) {\n    const { kind, stamp, tags } = parse_config(params ?? []);\n    const content = _util_js__WEBPACK_IMPORTED_MODULE_4__.stringify(data);\n    const pub = (0,_keys_js__WEBPACK_IMPORTED_MODULE_1__.get_pubkey)(seckey, true).hex;\n    const ref = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.str(content).digest;\n    const img = [0, pub, stamp, kind, tags, content];\n    const pid = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.json(img).digest;\n    const sig = (0,_sig_js__WEBPACK_IMPORTED_MODULE_2__.sign)(pid, seckey, options);\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([ref, pub, pid, sig]).hex + encode_params(params);\n}\nfunction parse_proof(proof) {\n    const [hexstr, query] = proof.split('?');\n    const stream = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.hex(hexstr).stream;\n    _assert_js__WEBPACK_IMPORTED_MODULE_3__.ok(stream.size === 160);\n    return {\n        ref: stream.read(32).hex,\n        pub: stream.read(32).hex,\n        pid: stream.read(32).hex,\n        sig: stream.read(64).hex,\n        params: decode_params(query)\n    };\n}\nfunction parse_proofs(proofs) {\n    return proofs.map(e => parse_proof(e));\n}\nfunction validate_proof(proof) {\n    const regex = /^[0-9a-fA-F]{320}(?:\\?[A-Za-z0-9_]+=[A-Za-z0-9_]+(?:&[A-Za-z0-9_]+=[A-Za-z0-9_]+)*)?$/;\n    return regex.test(proof);\n}\nfunction verify_proof(proof, data, options) {\n    const { throws = false } = options ?? {};\n    const { ref, pub, pid, sig, params } = parse_proof(proof);\n    const { kind, stamp, tags } = parse_config(params);\n    const content = _util_js__WEBPACK_IMPORTED_MODULE_4__.stringify(data);\n    const content_ref = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.str(content).digest.hex;\n    if (content_ref !== ref) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_3__.fail('Content hash does not match reference hash!', throws);\n    }\n    const img = [0, pub, stamp, kind, tags, content];\n    const proof_hash = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.json(img).digest;\n    if (proof_hash.hex !== pid) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_3__.fail('Proof hash does not equal proof id!', throws);\n    }\n    if (!(0,_sig_js__WEBPACK_IMPORTED_MODULE_2__.verify)(sig, pid, pub)) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_3__.fail('Proof signature is invalid!', throws);\n    }\n    return true;\n}\nfunction create_event(proof, data) {\n    const content = _util_js__WEBPACK_IMPORTED_MODULE_4__.stringify(data);\n    const { pub, pid, sig, params } = parse_proof(proof);\n    const { kind, stamp, tags } = parse_config(params);\n    return { kind, content, tags, pubkey: pub, id: pid, sig, created_at: stamp };\n}\nfunction encode_params(params = []) {\n    const strings = params.map(e => [String(e[0]), String(e[1])]);\n    return (params.length !== 0)\n        ? '?' + new URLSearchParams(strings).toString()\n        : '';\n}\nfunction decode_params(str) {\n    return (typeof str === 'string')\n        ? [...new URLSearchParams(str)]\n        : [];\n}\nfunction parse_config(params = []) {\n    const { kind, stamp, ...rest } = Object.fromEntries(params);\n    return {\n        tags: Object.entries(rest).map(([k, v]) => [k, String(v)]),\n        kind: (kind !== undefined) ? Number(kind) : PROOF_DEFAULTS.kind,\n        stamp: (stamp !== undefined) ? Number(stamp) : PROOF_DEFAULTS.stamp\n    };\n}\n//# sourceMappingURL=proof.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvcHJvb2YuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDSjtBQUNDO0FBQ0Y7QUFDSjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLG9CQUFvQjtBQUNoQyxvQkFBb0IsK0NBQWM7QUFDbEMsZ0JBQWdCLG9EQUFVO0FBQzFCLGdCQUFnQixxREFBSTtBQUNwQjtBQUNBLGdCQUFnQixxREFBSTtBQUNwQixnQkFBZ0IsNkNBQUk7QUFDcEIsV0FBVyxxREFBSTtBQUNmO0FBQ087QUFDUDtBQUNBLG1CQUFtQixxREFBSTtBQUN2QixJQUFJLDBDQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNPO0FBQ1AsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSw2QkFBNkI7QUFDekMsWUFBWSxvQkFBb0I7QUFDaEMsb0JBQW9CLCtDQUFjO0FBQ2xDLHdCQUF3QixxREFBSTtBQUM1QjtBQUNBLGVBQWUsNENBQVc7QUFDMUI7QUFDQTtBQUNBLHVCQUF1QixxREFBSTtBQUMzQjtBQUNBLGVBQWUsNENBQVc7QUFDMUI7QUFDQSxTQUFTLCtDQUFNO0FBQ2YsZUFBZSw0Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQiwrQ0FBYztBQUNsQyxZQUFZLHdCQUF3QjtBQUNwQyxZQUFZLG9CQUFvQjtBQUNoQyxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BjbWRjb2RlL2NyeXB0by11dGlscy9kaXN0L3Byb29mLmpzPzI5NjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZiB9IGZyb20gJ0BjbWRjb2RlL2J1ZmYtdXRpbHMnO1xuaW1wb3J0IHsgZ2V0X3B1YmtleSB9IGZyb20gJy4va2V5cy5qcyc7XG5pbXBvcnQgeyBzaWduLCB2ZXJpZnkgfSBmcm9tICcuL3NpZy5qcyc7XG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSAnLi9hc3NlcnQuanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwuanMnO1xuY29uc3QgUFJPT0ZfREVGQVVMVFMgPSB7XG4gICAga2luZDogMjAwMDAsXG4gICAgc3RhbXA6IDB4MDAwMDAwMDAsXG4gICAgdGFnczogW11cbn07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3Byb29mKHNlY2tleSwgZGF0YSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBraW5kLCBzdGFtcCwgdGFncyB9ID0gcGFyc2VfY29uZmlnKHBhcmFtcyA/PyBbXSk7XG4gICAgY29uc3QgY29udGVudCA9IHV0aWwuc3RyaW5naWZ5KGRhdGEpO1xuICAgIGNvbnN0IHB1YiA9IGdldF9wdWJrZXkoc2Vja2V5LCB0cnVlKS5oZXg7XG4gICAgY29uc3QgcmVmID0gQnVmZi5zdHIoY29udGVudCkuZGlnZXN0O1xuICAgIGNvbnN0IGltZyA9IFswLCBwdWIsIHN0YW1wLCBraW5kLCB0YWdzLCBjb250ZW50XTtcbiAgICBjb25zdCBwaWQgPSBCdWZmLmpzb24oaW1nKS5kaWdlc3Q7XG4gICAgY29uc3Qgc2lnID0gc2lnbihwaWQsIHNlY2tleSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEJ1ZmYuam9pbihbcmVmLCBwdWIsIHBpZCwgc2lnXSkuaGV4ICsgZW5jb2RlX3BhcmFtcyhwYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlX3Byb29mKHByb29mKSB7XG4gICAgY29uc3QgW2hleHN0ciwgcXVlcnldID0gcHJvb2Yuc3BsaXQoJz8nKTtcbiAgICBjb25zdCBzdHJlYW0gPSBCdWZmLmhleChoZXhzdHIpLnN0cmVhbTtcbiAgICBhc3NlcnQub2soc3RyZWFtLnNpemUgPT09IDE2MCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmOiBzdHJlYW0ucmVhZCgzMikuaGV4LFxuICAgICAgICBwdWI6IHN0cmVhbS5yZWFkKDMyKS5oZXgsXG4gICAgICAgIHBpZDogc3RyZWFtLnJlYWQoMzIpLmhleCxcbiAgICAgICAgc2lnOiBzdHJlYW0ucmVhZCg2NCkuaGV4LFxuICAgICAgICBwYXJhbXM6IGRlY29kZV9wYXJhbXMocXVlcnkpXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZV9wcm9vZnMocHJvb2ZzKSB7XG4gICAgcmV0dXJuIHByb29mcy5tYXAoZSA9PiBwYXJzZV9wcm9vZihlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfcHJvb2YocHJvb2YpIHtcbiAgICBjb25zdCByZWdleCA9IC9eWzAtOWEtZkEtRl17MzIwfSg/OlxcP1tBLVphLXowLTlfXSs9W0EtWmEtejAtOV9dKyg/OiZbQS1aYS16MC05X10rPVtBLVphLXowLTlfXSspKik/JC87XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QocHJvb2YpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeV9wcm9vZihwcm9vZiwgZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGhyb3dzID0gZmFsc2UgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgY29uc3QgeyByZWYsIHB1YiwgcGlkLCBzaWcsIHBhcmFtcyB9ID0gcGFyc2VfcHJvb2YocHJvb2YpO1xuICAgIGNvbnN0IHsga2luZCwgc3RhbXAsIHRhZ3MgfSA9IHBhcnNlX2NvbmZpZyhwYXJhbXMpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB1dGlsLnN0cmluZ2lmeShkYXRhKTtcbiAgICBjb25zdCBjb250ZW50X3JlZiA9IEJ1ZmYuc3RyKGNvbnRlbnQpLmRpZ2VzdC5oZXg7XG4gICAgaWYgKGNvbnRlbnRfcmVmICE9PSByZWYpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydC5mYWlsKCdDb250ZW50IGhhc2ggZG9lcyBub3QgbWF0Y2ggcmVmZXJlbmNlIGhhc2ghJywgdGhyb3dzKTtcbiAgICB9XG4gICAgY29uc3QgaW1nID0gWzAsIHB1Yiwgc3RhbXAsIGtpbmQsIHRhZ3MsIGNvbnRlbnRdO1xuICAgIGNvbnN0IHByb29mX2hhc2ggPSBCdWZmLmpzb24oaW1nKS5kaWdlc3Q7XG4gICAgaWYgKHByb29mX2hhc2guaGV4ICE9PSBwaWQpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydC5mYWlsKCdQcm9vZiBoYXNoIGRvZXMgbm90IGVxdWFsIHByb29mIGlkIScsIHRocm93cyk7XG4gICAgfVxuICAgIGlmICghdmVyaWZ5KHNpZywgcGlkLCBwdWIpKSB7XG4gICAgICAgIHJldHVybiBhc3NlcnQuZmFpbCgnUHJvb2Ygc2lnbmF0dXJlIGlzIGludmFsaWQhJywgdGhyb3dzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2V2ZW50KHByb29mLCBkYXRhKSB7XG4gICAgY29uc3QgY29udGVudCA9IHV0aWwuc3RyaW5naWZ5KGRhdGEpO1xuICAgIGNvbnN0IHsgcHViLCBwaWQsIHNpZywgcGFyYW1zIH0gPSBwYXJzZV9wcm9vZihwcm9vZik7XG4gICAgY29uc3QgeyBraW5kLCBzdGFtcCwgdGFncyB9ID0gcGFyc2VfY29uZmlnKHBhcmFtcyk7XG4gICAgcmV0dXJuIHsga2luZCwgY29udGVudCwgdGFncywgcHVia2V5OiBwdWIsIGlkOiBwaWQsIHNpZywgY3JlYXRlZF9hdDogc3RhbXAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVfcGFyYW1zKHBhcmFtcyA9IFtdKSB7XG4gICAgY29uc3Qgc3RyaW5ncyA9IHBhcmFtcy5tYXAoZSA9PiBbU3RyaW5nKGVbMF0pLCBTdHJpbmcoZVsxXSldKTtcbiAgICByZXR1cm4gKHBhcmFtcy5sZW5ndGggIT09IDApXG4gICAgICAgID8gJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhzdHJpbmdzKS50b1N0cmluZygpXG4gICAgICAgIDogJyc7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlX3BhcmFtcyhzdHIpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKVxuICAgICAgICA/IFsuLi5uZXcgVVJMU2VhcmNoUGFyYW1zKHN0cildXG4gICAgICAgIDogW107XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VfY29uZmlnKHBhcmFtcyA9IFtdKSB7XG4gICAgY29uc3QgeyBraW5kLCBzdGFtcCwgLi4ucmVzdCB9ID0gT2JqZWN0LmZyb21FbnRyaWVzKHBhcmFtcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFnczogT2JqZWN0LmVudHJpZXMocmVzdCkubWFwKChbaywgdl0pID0+IFtrLCBTdHJpbmcodildKSxcbiAgICAgICAga2luZDogKGtpbmQgIT09IHVuZGVmaW5lZCkgPyBOdW1iZXIoa2luZCkgOiBQUk9PRl9ERUZBVUxUUy5raW5kLFxuICAgICAgICBzdGFtcDogKHN0YW1wICE9PSB1bmRlZmluZWQpID8gTnVtYmVyKHN0YW1wKSA6IFBST09GX0RFRkFVTFRTLnN0YW1wXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb29mLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/proof.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/sig.js":
/*!********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/sig.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gen_nonce: () => (/* binding */ gen_nonce),\n/* harmony export */   recover: () => (/* binding */ recover),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/const.js\");\n/* harmony import */ var _ecc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ecc.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecc.js\");\n/* harmony import */ var _ecdh_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ecdh.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/ecdh.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hash.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/hash.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/keys.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./config.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/config.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./assert.js */ \"(ssr)/./node_modules/@cmdcode/crypto-utils/dist/assert.js\");\n\n\n\n\n\n\n\n\nfunction sign(message, secret, options) {\n    const opt = (0,_config_js__WEBPACK_IMPORTED_MODULE_6__.sign_config)(options);\n    const { adaptor, tweak, xonly } = opt;\n    const m = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(message);\n    let dp = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(secret);\n    if (tweak !== undefined) {\n        if (xonly)\n            dp = dp.negated;\n        dp = dp.add(tweak);\n    }\n    const P = dp.point;\n    const d = (xonly) ? dp.negated : dp;\n    const n = gen_nonce(m, d, opt);\n    let kp = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(n);\n    if (adaptor !== undefined) {\n        if (xonly)\n            kp = kp.negated;\n        kp = kp.add(adaptor);\n    }\n    const R = kp.point;\n    const k = (xonly) ? kp.negated.big : kp.big;\n    const ch = (0,_hash_js__WEBPACK_IMPORTED_MODULE_4__.digest)('BIP0340/challenge', R.x.raw, P.x.raw, m);\n    const c = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(ch);\n    const s = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(k + (c.big * d.big));\n    const rx = (xonly) ? R.x.raw : R.raw;\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([rx, s.raw]);\n}\nfunction verify(signature, message, pubkey, options) {\n    const { throws } = (0,_config_js__WEBPACK_IMPORTED_MODULE_6__.sign_config)(options);\n    const msg = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(message);\n    const sig = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(signature);\n    if (sig.length < 64) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_7__.fail('Signature length is too small: ' + String(sig.length), throws);\n    }\n    _assert_js__WEBPACK_IMPORTED_MODULE_7__.size(pubkey, 32);\n    const P = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Point.from_x(pubkey);\n    const rx = sig.subarray(0, 32);\n    const R = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Point.from_x(rx);\n    const s = sig.subarray(32, 64);\n    const sG = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(s).point;\n    const ch = (0,_hash_js__WEBPACK_IMPORTED_MODULE_4__.digest)('BIP0340/challenge', R.x, P.x, msg);\n    const c = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod(ch);\n    const eP = P.mul(c.big);\n    const r = sG.sub(eP);\n    if (R.hasOddY) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_7__.fail('Signature R value has odd Y coordinate!', throws);\n    }\n    if (R.x.big === _const_js__WEBPACK_IMPORTED_MODULE_1__._0n) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_7__.fail('Signature R value is infinite!', throws);\n    }\n    if (R.x.big !== r.x.big) {\n        return _assert_js__WEBPACK_IMPORTED_MODULE_7__.fail(`Signature is invalid! R: ${R.x.hex} r:${r.x.hex}`, throws);\n    }\n    return R.x.big === r.x.big;\n}\nfunction recover(signature, message, pub_key, rec_key) {\n    const sig = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(signature);\n    const msg = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(message);\n    const pub = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(pub_key);\n    const seed = (0,_ecdh_js__WEBPACK_IMPORTED_MODULE_3__.get_shared_key)(rec_key, pub_key);\n    const nonce = (0,_hash_js__WEBPACK_IMPORTED_MODULE_4__.digest)('BIP0340/nonce', seed, message);\n    const chal = (0,_hash_js__WEBPACK_IMPORTED_MODULE_4__.digest)('BIP0340/challenge', sig.slice(0, 32), (0,_keys_js__WEBPACK_IMPORTED_MODULE_5__.convert_32)(pub), msg);\n    const c = new _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field(chal);\n    const k = new _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field(nonce).negated;\n    const s = new _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field(sig.slice(32, 64));\n    return s.sub(k).div(c).buff;\n}\nfunction gen_nonce(message, secret, options) {\n    const { aux, nonce, nonce_tweaks = [], recovery, xonly } = (0,_config_js__WEBPACK_IMPORTED_MODULE_6__.sign_config)(options);\n    let n;\n    if (nonce !== undefined) {\n        n = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(nonce);\n    }\n    else if (recovery !== undefined) {\n        n = (0,_ecdh_js__WEBPACK_IMPORTED_MODULE_3__.get_shared_key)(secret, recovery);\n    }\n    else {\n        const seed = (aux === null) ? _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.num(0, 32) : aux;\n        const a = (0,_hash_js__WEBPACK_IMPORTED_MODULE_4__.digest)('BIP0340/aux', seed ?? _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.random(32));\n        const t = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(secret).big ^ a.big;\n        n = _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.join([t, (0,_keys_js__WEBPACK_IMPORTED_MODULE_5__.get_pubkey)(secret, xonly)]);\n    }\n    let sn = _ecc_js__WEBPACK_IMPORTED_MODULE_2__.Field.mod((0,_hash_js__WEBPACK_IMPORTED_MODULE_4__.digest)('BIP0340/nonce', n, _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.bytes(message)));\n    nonce_tweaks.forEach(e => { sn = sn.add(e).negated; });\n    return sn.buff;\n}\n//# sourceMappingURL=sig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3Qvc2lnLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUEyQztBQUNWO0FBQ087QUFDRztBQUNSO0FBQ2dCO0FBQ1Q7QUFDSjtBQUMvQjtBQUNQLGdCQUFnQix1REFBVztBQUMzQixZQUFZLHdCQUF3QjtBQUNwQyxjQUFjLHFEQUFJO0FBQ2xCLGFBQWEsMENBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMENBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFNO0FBQ3JCLGNBQWMsMENBQUs7QUFDbkIsY0FBYywwQ0FBSztBQUNuQjtBQUNBLFdBQVcscURBQUk7QUFDZjtBQUNPO0FBQ1AsWUFBWSxTQUFTLEVBQUUsdURBQVc7QUFDbEMsZ0JBQWdCLHFEQUFJO0FBQ3BCLGdCQUFnQixxREFBSTtBQUNwQjtBQUNBLGVBQWUsNENBQVc7QUFDMUI7QUFDQSxJQUFJLDRDQUFXO0FBQ2YsY0FBYywwQ0FBSztBQUNuQjtBQUNBLGNBQWMsMENBQUs7QUFDbkI7QUFDQSxlQUFlLDBDQUFLO0FBQ3BCLGVBQWUsZ0RBQU07QUFDckIsY0FBYywwQ0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFXO0FBQzFCO0FBQ0Esb0JBQW9CLDBDQUFHO0FBQ3ZCLGVBQWUsNENBQVc7QUFDMUI7QUFDQTtBQUNBLGVBQWUsNENBQVcsNkJBQTZCLFNBQVMsSUFBSSxRQUFRO0FBQzVFO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLHFEQUFJO0FBQ3BCLGdCQUFnQixxREFBSTtBQUNwQixnQkFBZ0IscURBQUk7QUFDcEIsaUJBQWlCLHdEQUFjO0FBQy9CLGtCQUFrQixnREFBTTtBQUN4QixpQkFBaUIsZ0RBQU0sd0NBQXdDLG9EQUFVO0FBQ3pFLGtCQUFrQiwwQ0FBSztBQUN2QixrQkFBa0IsMENBQUs7QUFDdkIsa0JBQWtCLDBDQUFLO0FBQ3ZCO0FBQ0E7QUFDTztBQUNQLFlBQVksaURBQWlELEVBQUUsdURBQVc7QUFDMUU7QUFDQTtBQUNBLFlBQVkscURBQUk7QUFDaEI7QUFDQTtBQUNBLFlBQVksd0RBQWM7QUFDMUI7QUFDQTtBQUNBLHNDQUFzQyxxREFBSTtBQUMxQyxrQkFBa0IsZ0RBQU0sd0JBQXdCLHFEQUFJO0FBQ3BELGtCQUFrQixxREFBSTtBQUN0QixZQUFZLHFEQUFJLFVBQVUsb0RBQVU7QUFDcEM7QUFDQSxhQUFhLDBDQUFLLEtBQUssZ0RBQU0scUJBQXFCLHFEQUFJO0FBQ3RELGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3Qvc2lnLmpzPzIzYmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZiB9IGZyb20gJ0BjbWRjb2RlL2J1ZmYtdXRpbHMnO1xuaW1wb3J0IHsgXzBuIH0gZnJvbSAnLi9jb25zdC5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgUG9pbnQgfSBmcm9tICcuL2VjYy5qcyc7XG5pbXBvcnQgeyBnZXRfc2hhcmVkX2tleSB9IGZyb20gJy4vZWNkaC5qcyc7XG5pbXBvcnQgeyBkaWdlc3QgfSBmcm9tICcuL2hhc2guanMnO1xuaW1wb3J0IHsgZ2V0X3B1YmtleSwgY29udmVydF8zMiB9IGZyb20gJy4va2V5cy5qcyc7XG5pbXBvcnQgeyBzaWduX2NvbmZpZyB9IGZyb20gJy4vY29uZmlnLmpzJztcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tICcuL2Fzc2VydC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBzZWNyZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHQgPSBzaWduX2NvbmZpZyhvcHRpb25zKTtcbiAgICBjb25zdCB7IGFkYXB0b3IsIHR3ZWFrLCB4b25seSB9ID0gb3B0O1xuICAgIGNvbnN0IG0gPSBCdWZmLmJ5dGVzKG1lc3NhZ2UpO1xuICAgIGxldCBkcCA9IEZpZWxkLm1vZChzZWNyZXQpO1xuICAgIGlmICh0d2VhayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh4b25seSlcbiAgICAgICAgICAgIGRwID0gZHAubmVnYXRlZDtcbiAgICAgICAgZHAgPSBkcC5hZGQodHdlYWspO1xuICAgIH1cbiAgICBjb25zdCBQID0gZHAucG9pbnQ7XG4gICAgY29uc3QgZCA9ICh4b25seSkgPyBkcC5uZWdhdGVkIDogZHA7XG4gICAgY29uc3QgbiA9IGdlbl9ub25jZShtLCBkLCBvcHQpO1xuICAgIGxldCBrcCA9IEZpZWxkLm1vZChuKTtcbiAgICBpZiAoYWRhcHRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh4b25seSlcbiAgICAgICAgICAgIGtwID0ga3AubmVnYXRlZDtcbiAgICAgICAga3AgPSBrcC5hZGQoYWRhcHRvcik7XG4gICAgfVxuICAgIGNvbnN0IFIgPSBrcC5wb2ludDtcbiAgICBjb25zdCBrID0gKHhvbmx5KSA/IGtwLm5lZ2F0ZWQuYmlnIDoga3AuYmlnO1xuICAgIGNvbnN0IGNoID0gZGlnZXN0KCdCSVAwMzQwL2NoYWxsZW5nZScsIFIueC5yYXcsIFAueC5yYXcsIG0pO1xuICAgIGNvbnN0IGMgPSBGaWVsZC5tb2QoY2gpO1xuICAgIGNvbnN0IHMgPSBGaWVsZC5tb2QoayArIChjLmJpZyAqIGQuYmlnKSk7XG4gICAgY29uc3QgcnggPSAoeG9ubHkpID8gUi54LnJhdyA6IFIucmF3O1xuICAgIHJldHVybiBCdWZmLmpvaW4oW3J4LCBzLnJhd10pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmtleSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGhyb3dzIH0gPSBzaWduX2NvbmZpZyhvcHRpb25zKTtcbiAgICBjb25zdCBtc2cgPSBCdWZmLmJ5dGVzKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZyA9IEJ1ZmYuYnl0ZXMoc2lnbmF0dXJlKTtcbiAgICBpZiAoc2lnLmxlbmd0aCA8IDY0KSB7XG4gICAgICAgIHJldHVybiBhc3NlcnQuZmFpbCgnU2lnbmF0dXJlIGxlbmd0aCBpcyB0b28gc21hbGw6ICcgKyBTdHJpbmcoc2lnLmxlbmd0aCksIHRocm93cyk7XG4gICAgfVxuICAgIGFzc2VydC5zaXplKHB1YmtleSwgMzIpO1xuICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tX3gocHVia2V5KTtcbiAgICBjb25zdCByeCA9IHNpZy5zdWJhcnJheSgwLCAzMik7XG4gICAgY29uc3QgUiA9IFBvaW50LmZyb21feChyeCk7XG4gICAgY29uc3QgcyA9IHNpZy5zdWJhcnJheSgzMiwgNjQpO1xuICAgIGNvbnN0IHNHID0gRmllbGQubW9kKHMpLnBvaW50O1xuICAgIGNvbnN0IGNoID0gZGlnZXN0KCdCSVAwMzQwL2NoYWxsZW5nZScsIFIueCwgUC54LCBtc2cpO1xuICAgIGNvbnN0IGMgPSBGaWVsZC5tb2QoY2gpO1xuICAgIGNvbnN0IGVQID0gUC5tdWwoYy5iaWcpO1xuICAgIGNvbnN0IHIgPSBzRy5zdWIoZVApO1xuICAgIGlmIChSLmhhc09kZFkpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydC5mYWlsKCdTaWduYXR1cmUgUiB2YWx1ZSBoYXMgb2RkIFkgY29vcmRpbmF0ZSEnLCB0aHJvd3MpO1xuICAgIH1cbiAgICBpZiAoUi54LmJpZyA9PT0gXzBuKSB7XG4gICAgICAgIHJldHVybiBhc3NlcnQuZmFpbCgnU2lnbmF0dXJlIFIgdmFsdWUgaXMgaW5maW5pdGUhJywgdGhyb3dzKTtcbiAgICB9XG4gICAgaWYgKFIueC5iaWcgIT09IHIueC5iaWcpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydC5mYWlsKGBTaWduYXR1cmUgaXMgaW52YWxpZCEgUjogJHtSLnguaGV4fSByOiR7ci54LmhleH1gLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gUi54LmJpZyA9PT0gci54LmJpZztcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHViX2tleSwgcmVjX2tleSkge1xuICAgIGNvbnN0IHNpZyA9IEJ1ZmYuYnl0ZXMoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBtc2cgPSBCdWZmLmJ5dGVzKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9IEJ1ZmYuYnl0ZXMocHViX2tleSk7XG4gICAgY29uc3Qgc2VlZCA9IGdldF9zaGFyZWRfa2V5KHJlY19rZXksIHB1Yl9rZXkpO1xuICAgIGNvbnN0IG5vbmNlID0gZGlnZXN0KCdCSVAwMzQwL25vbmNlJywgc2VlZCwgbWVzc2FnZSk7XG4gICAgY29uc3QgY2hhbCA9IGRpZ2VzdCgnQklQMDM0MC9jaGFsbGVuZ2UnLCBzaWcuc2xpY2UoMCwgMzIpLCBjb252ZXJ0XzMyKHB1YiksIG1zZyk7XG4gICAgY29uc3QgYyA9IG5ldyBGaWVsZChjaGFsKTtcbiAgICBjb25zdCBrID0gbmV3IEZpZWxkKG5vbmNlKS5uZWdhdGVkO1xuICAgIGNvbnN0IHMgPSBuZXcgRmllbGQoc2lnLnNsaWNlKDMyLCA2NCkpO1xuICAgIHJldHVybiBzLnN1YihrKS5kaXYoYykuYnVmZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5fbm9uY2UobWVzc2FnZSwgc2VjcmV0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhdXgsIG5vbmNlLCBub25jZV90d2Vha3MgPSBbXSwgcmVjb3ZlcnksIHhvbmx5IH0gPSBzaWduX2NvbmZpZyhvcHRpb25zKTtcbiAgICBsZXQgbjtcbiAgICBpZiAobm9uY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuID0gQnVmZi5ieXRlcyhub25jZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlY292ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbiA9IGdldF9zaGFyZWRfa2V5KHNlY3JldCwgcmVjb3ZlcnkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2VlZCA9IChhdXggPT09IG51bGwpID8gQnVmZi5udW0oMCwgMzIpIDogYXV4O1xuICAgICAgICBjb25zdCBhID0gZGlnZXN0KCdCSVAwMzQwL2F1eCcsIHNlZWQgPz8gQnVmZi5yYW5kb20oMzIpKTtcbiAgICAgICAgY29uc3QgdCA9IEJ1ZmYuYnl0ZXMoc2VjcmV0KS5iaWcgXiBhLmJpZztcbiAgICAgICAgbiA9IEJ1ZmYuam9pbihbdCwgZ2V0X3B1YmtleShzZWNyZXQsIHhvbmx5KV0pO1xuICAgIH1cbiAgICBsZXQgc24gPSBGaWVsZC5tb2QoZGlnZXN0KCdCSVAwMzQwL25vbmNlJywgbiwgQnVmZi5ieXRlcyhtZXNzYWdlKSkpO1xuICAgIG5vbmNlX3R3ZWFrcy5mb3JFYWNoKGUgPT4geyBzbiA9IHNuLmFkZChlKS5uZWdhdGVkOyB9KTtcbiAgICByZXR1cm4gc24uYnVmZjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/sig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdXRpbHMvZGlzdC90eXBlcy5qcz9jOTQ3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/crypto-utils/dist/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/@cmdcode/crypto-utils/dist/util.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   increment_buffer: () => (/* binding */ increment_buffer),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cmdcode/buff-utils */ \"(ssr)/./node_modules/@cmdcode/buff-utils/dist/module.mjs\");\n\nfunction random(size) {\n    return _cmdcode_buff_utils__WEBPACK_IMPORTED_MODULE_0__.Buff.random(size);\n}\nfunction increment_buffer(buffer) {\n    let i = buffer.length - 1;\n    for (i; i >= 0; i--) {\n        if (buffer[i] < 255) {\n            buffer.set([buffer[i] + 1], i);\n            return buffer;\n        }\n    }\n    throw TypeError('Unable to increment buffer: ' + buffer.toString());\n}\nfunction stringify(content) {\n    switch (typeof content) {\n        case 'object':\n            return JSON.stringify(content);\n        case 'string':\n            return content;\n        case 'bigint':\n            return content.toString();\n        case 'number':\n            return content.toString();\n        case 'boolean':\n            return String(content);\n        default:\n            throw new TypeError('Content type not supported: ' + typeof content);\n    }\n}\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvY3J5cHRvLXV0aWxzL2Rpc3QvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJDO0FBQ3BDO0FBQ1AsV0FBVyxxREFBSTtBQUNmO0FBQ087QUFDUDtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AY21kY29kZS9jcnlwdG8tdXRpbHMvZGlzdC91dGlsLmpzP2NkMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZiB9IGZyb20gJ0BjbWRjb2RlL2J1ZmYtdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShzaXplKSB7XG4gICAgcmV0dXJuIEJ1ZmYucmFuZG9tKHNpemUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudF9idWZmZXIoYnVmZmVyKSB7XG4gICAgbGV0IGkgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChidWZmZXJbaV0gPCAyNTUpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoW2J1ZmZlcltpXSArIDFdLCBpKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgVHlwZUVycm9yKCdVbmFibGUgdG8gaW5jcmVtZW50IGJ1ZmZlcjogJyArIGJ1ZmZlci50b1N0cmluZygpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkoY29udGVudCkge1xuICAgIHN3aXRjaCAodHlwZW9mIGNvbnRlbnQpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjb250ZW50KTtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhjb250ZW50KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnRlbnQgdHlwZSBub3Qgc3VwcG9ydGVkOiAnICsgdHlwZW9mIGNvbnRlbnQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/crypto-utils/dist/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cmdcode/tapscript/dist/module.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@cmdcode/tapscript/dist/module.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Address: () => (/* binding */ Address),\n/* harmony export */   Input: () => (/* binding */ TxInput$1),\n/* harmony export */   Output: () => (/* binding */ TxOutput$1),\n/* harmony export */   Script: () => (/* binding */ Script),\n/* harmony export */   Sequence: () => (/* binding */ TxSequence),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   Tap: () => (/* binding */ Tap),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   Tx: () => (/* binding */ Tx),\n/* harmony export */   Witness: () => (/* binding */ TxWitness)\n/* harmony export */ });\nfunction number$3(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool$3(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes$3(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new TypeError('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash$4(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number$3(hash.outputLen);\n    number$3(hash.blockLen);\n}\nfunction exists$3(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output$3(out, instance) {\n    bytes$3(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert$1$2 = {\n    number: number$3,\n    bool: bool$3,\n    bytes: bytes$3,\n    hash: hash$4,\n    exists: exists$3,\n    output: output$3,\n};\nvar assert$2$1 = assert$1$2;\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Cast array to view\nconst createView$3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr$3 = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE$3 = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE$3)\n    throw new Error('Non little-endian hardware is not supported');\nArray.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction utf8ToBytes$4(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nfunction toBytes$5(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes$4(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n// For runtime check if class implements interface\nlet Hash$3 = class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n};\nfunction wrapConstructor$3(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes$5(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\n\n// Polyfill for Safari 14\nfunction setBigUint64$3(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nlet SHA2$3 = class SHA2 extends Hash$3 {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView$3(this.buffer);\n    }\n    update(data) {\n        assert$2$1.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes$5(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView$3(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        assert$2$1.exists(this);\n        assert$2$1.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64$3(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView$3(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n};\n\n// Choice: a ? b : c\nconst Chi$3 = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj$3 = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K$3 = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV$3 = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W$3 = new Uint32Array(64);\nlet SHA256$3 = class SHA256 extends SHA2$3 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV$3[0] | 0;\n        this.B = IV$3[1] | 0;\n        this.C = IV$3[2] | 0;\n        this.D = IV$3[3] | 0;\n        this.E = IV$3[4] | 0;\n        this.F = IV$3[5] | 0;\n        this.G = IV$3[6] | 0;\n        this.H = IV$3[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W$3[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W$3[i - 15];\n            const W2 = SHA256_W$3[i - 2];\n            const s0 = rotr$3(W15, 7) ^ rotr$3(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr$3(W2, 17) ^ rotr$3(W2, 19) ^ (W2 >>> 10);\n            SHA256_W$3[i] = (s1 + SHA256_W$3[i - 7] + s0 + SHA256_W$3[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr$3(E, 6) ^ rotr$3(E, 11) ^ rotr$3(E, 25);\n            const T1 = (H + sigma1 + Chi$3(E, F, G) + SHA256_K$3[i] + SHA256_W$3[i]) | 0;\n            const sigma0 = rotr$3(A, 2) ^ rotr$3(A, 13) ^ rotr$3(A, 22);\n            const T2 = (sigma0 + Maj$3(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W$3.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n};\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nlet SHA224$3 = class SHA224 extends SHA256$3 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n};\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256$4 = wrapConstructor$3(() => new SHA256$3());\nwrapConstructor$3(() => new SHA224$3());\n\nfunction within_size$1(data, size) {\n    if (data.length > size) {\n        throw new TypeError(`Data is larger than array size: ${data.length} > ${size}`);\n    }\n}\nfunction is_hex$1(hex) {\n    if (hex.match(/[^a-fA-f0-9]/) !== null) {\n        throw new TypeError('Invalid characters in hex string: ' + hex);\n    }\n    if (hex.length % 2 !== 0) {\n        throw new Error(`Length of hex string is invalid: ${hex.length}`);\n    }\n}\nfunction is_safe_num$1(num) {\n    if (num > Number.MAX_SAFE_INTEGER) {\n        throw new TypeError('Number exceeds safe bounds!');\n    }\n}\n\nconst { getRandomValues: getRandomValues$1 } = crypto ?? globalThis.crypto ?? window.crypto;\nfunction random$2(size = 32) {\n    if (typeof getRandomValues$1 === 'function') {\n        return crypto.getRandomValues(new Uint8Array(size));\n    }\n    throw new Error('Crypto module missing getRandomValues!');\n}\nfunction set_buffer$1(data, size, endian = 'be') {\n    if (size === undefined)\n        size = data.length;\n    within_size$1(data, size);\n    const buffer = new Uint8Array(size).fill(0);\n    const offset = (endian === 'be') ? 0 : size - data.length;\n    buffer.set(data, offset);\n    return buffer;\n}\nfunction join_array$1(arr) {\n    let i, offset = 0;\n    const size = arr.reduce((len, arr) => len + arr.length, 0);\n    const buff = new Uint8Array(size);\n    for (i = 0; i < arr.length; i++) {\n        const a = arr[i];\n        buff.set(a, offset);\n        offset += a.length;\n    }\n    return buff;\n}\n\nconst ec$2$1 = new TextEncoder();\nconst ALPHABETS$1 = [\n    {\n        name: 'base58',\n        charset: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n    }\n];\nfunction getAlphabet$1(name) {\n    for (const alpha of ALPHABETS$1) {\n        if (alpha.name === name) {\n            return alpha.charset;\n        }\n    }\n    throw TypeError('Charset does not exist: ' + name);\n}\nfunction encode$1$2(data, charset, padding = false) {\n    if (typeof data === 'string')\n        data = ec$2$1.encode(data);\n    const alphabet = getAlphabet$1(charset);\n    const len = alphabet.length;\n    const d = [];\n    let s = '', i, j = 0, c, n;\n    for (i = 0; i < data.length; i++) {\n        j = 0;\n        c = data[i];\n        s += (c > 0 || (s.length ^ i) > 0) ? '' : '1';\n        while (j in d || c > 0) {\n            n = d[j];\n            n = n > 0 ? n * 256 + c : c;\n            c = n / len | 0;\n            d[j] = n % len;\n            j++;\n        }\n    }\n    while (j-- > 0) {\n        s += alphabet[d[j]];\n    }\n    return (padding && s.length % 4 > 0)\n        ? s + '='.repeat(4 - s.length % 4)\n        : s;\n}\nfunction decode$1$2(encoded, charset) {\n    const alphabet = getAlphabet$1(charset);\n    const len = alphabet.length, d = [], b = [];\n    encoded = encoded.replace('=', '');\n    let i, j = 0, c, n;\n    for (i = 0; i < encoded.length; i++) {\n        j = 0;\n        c = alphabet.indexOf(encoded[i]);\n        if (c < 0) {\n            throw new Error(`Character range out of bounds: ${c}`);\n        }\n        if (!(c > 0 || (b.length ^ i) > 0))\n            b.push(0);\n        while (j in d || c > 0) {\n            n = d[j];\n            n = n > 0 ? n * len + c : c;\n            c = n >> 8;\n            d[j] = n % 256;\n            j++;\n        }\n    }\n    while (j-- > 0) {\n        b.push(d[j]);\n    }\n    return new Uint8Array(b);\n}\nfunction hash256$2(data) {\n    return sha256$4(sha256$4(data));\n}\nfunction addChecksum$1(data) {\n    const sum = hash256$2(data);\n    return join_array$1([data, sum.slice(0, 4)]);\n}\nfunction checkTheSum$1(data) {\n    const ret = data.slice(0, -4);\n    const chk = data.slice(-4);\n    const sum = hash256$2(ret).slice(0, 4);\n    if (sum.toString() !== chk.toString()) {\n        throw new Error('Invalid checksum!');\n    }\n    return ret;\n}\nconst BaseX$1 = {\n    encode: encode$1$2,\n    decode: decode$1$2\n};\nconst Base58C$1 = {\n    encode: (data) => {\n        const withSum = addChecksum$1(data);\n        return BaseX$1.encode(withSum, 'base58');\n    },\n    decode: (data) => {\n        const decoded = BaseX$1.decode(data, 'base58');\n        return checkTheSum$1(decoded);\n    }\n};\n\nconst CHARSET$1 = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst GENERATOR$1 = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nconst ENCODINGS$1 = [\n    { version: 0, name: 'bech32', const: 1 },\n    { version: 1, name: 'bech32m', const: 0x2bc830a3 }\n];\nfunction polymod$1(values) {\n    let chk = 1;\n    for (let p = 0; p < values.length; ++p) {\n        const top = chk >> 25;\n        chk = (chk & 0x1ffffff) << 5 ^ values[p];\n        for (let i = 0; i < 5; ++i) {\n            if (((top >> i) & 1) !== 0) {\n                chk ^= GENERATOR$1[i];\n            }\n        }\n    }\n    return chk;\n}\nfunction hrpExpand$1(hrp) {\n    const ret = [];\n    let p;\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) >> 5);\n    }\n    ret.push(0);\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) & 31);\n    }\n    return ret;\n}\nfunction verifyChecksum$1(hrp, data, enc) {\n    const combined = hrpExpand$1(hrp).concat(data);\n    return polymod$1(combined) === enc.const;\n}\nfunction createChecksum$1(hrp, data, enc) {\n    const values = hrpExpand$1(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n    const mod = polymod$1(values) ^ enc.const;\n    const ret = [];\n    for (let p = 0; p < 6; ++p) {\n        ret.push((mod >> 5 * (5 - p)) & 31);\n    }\n    return ret;\n}\nfunction convertBits$1(data, fromBits, toBits, pad = true) {\n    const ret = [];\n    let acc = 0;\n    let bits = 0;\n    const maxVal = (1 << toBits) - 1;\n    const maxAcc = (1 << (fromBits + toBits - 1)) - 1;\n    for (const val of data) {\n        if (val < 0 || (val >> fromBits) > 0) {\n            throw new Error('Failed to perform base conversion. Invalid value: ' + String(val));\n        }\n        acc = ((acc << fromBits) | val) & maxAcc;\n        bits += fromBits;\n        while (bits >= toBits) {\n            bits -= toBits;\n            ret.push((acc >> bits) & maxVal);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            ret.push((acc << (toBits - bits)) & maxVal);\n        }\n    }\n    else if (bits >= fromBits || ((acc << (toBits - bits)) & maxVal) > 0) {\n        throw new Error('Failed to perform base conversion. Invalid Size!');\n    }\n    return ret;\n}\nfunction encode$6(hrp, data, enc) {\n    const combined = data.concat(createChecksum$1(hrp, data, enc));\n    let ret = hrp + '1';\n    for (let p = 0; p < combined.length; ++p) {\n        ret += CHARSET$1.charAt(combined[p]);\n    }\n    return ret;\n}\nfunction decode$6(bechstr) {\n    if (!checkBounds$1(bechstr)) {\n        throw new Error('Encoded string goes out of bounds!');\n    }\n    bechstr = bechstr.toLowerCase();\n    if (!checkSeparatorPos$1(bechstr)) {\n        throw new Error('Encoded string has invalid separator!');\n    }\n    const data = [];\n    const pos = bechstr.lastIndexOf('1');\n    const hrp = bechstr.substring(0, pos);\n    for (let p = pos + 1; p < bechstr.length; ++p) {\n        const d = CHARSET$1.indexOf(bechstr.charAt(p));\n        if (d === -1) {\n            throw new Error('Character idx out of bounds: ' + String(p));\n        }\n        data.push(d);\n    }\n    const enc = ENCODINGS$1.find(e => e.version === data[0]) ?? ENCODINGS$1[0];\n    if (!verifyChecksum$1(hrp, data, enc)) {\n        throw new Error('Checksum verification failed!');\n    }\n    return [hrp, data.slice(0, data.length - 6)];\n}\nfunction checkBounds$1(bechstr) {\n    let p;\n    let char;\n    let hasLower = false;\n    let hasUpper = false;\n    for (p = 0; p < bechstr.length; ++p) {\n        char = bechstr.charCodeAt(p);\n        if (char < 33 || char > 126) {\n            return false;\n        }\n        if (char >= 97 && char <= 122) {\n            hasLower = true;\n        }\n        if (char >= 65 && char <= 90) {\n            hasUpper = true;\n        }\n    }\n    if (hasLower && hasUpper)\n        return false;\n    return true;\n}\nfunction checkSeparatorPos$1(bechstr) {\n    const pos = bechstr.lastIndexOf('1');\n    return !(pos < 1 ||\n        pos + 7 > bechstr.length ||\n        bechstr.length > 90);\n}\nfunction b32encode$1(data, hrp = 'bc', version = 0) {\n    const dat = [version, ...convertBits$1([...data], 8, 5)];\n    const enc = ENCODINGS$1.find(e => e.version === version) ?? ENCODINGS$1[0];\n    const str = encode$6(hrp, dat, enc);\n    b32decode$1(str);\n    return str;\n}\nfunction b32decode$1(str) {\n    str = str.toLowerCase();\n    const hrp = str.split('1', 1)[0];\n    const [hrpgot, data] = decode$6(str);\n    const decoded = convertBits$1(data.slice(1), 5, 8, false);\n    const length = decoded.length;\n    switch (true) {\n        case (hrp !== hrpgot):\n            throw new Error('Returned hrp string is invalid.');\n        case (decoded === null || length < 2 || length > 40):\n            throw new Error('Decoded string is invalid or out of spec.');\n        case (data[0] > 16):\n            throw new Error('Returned version bit is out of range.');\n        default:\n            return Uint8Array.from(decoded);\n    }\n}\nfunction getVersion$2(str) {\n    str = str.toLowerCase();\n    const [_, data] = decode$6(str);\n    return data[0];\n}\nconst Bech32$1 = {\n    encode: b32encode$1,\n    decode: b32decode$1,\n    version: getVersion$2\n};\n\nconst BASE64_MAP$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst B64URL_MAP$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\nconst ec$1$1 = new TextEncoder();\nfunction b64encode$1(input, urlSafe = false, padding = true) {\n    if (typeof input === 'string')\n        input = ec$1$1.encode(input);\n    const map = urlSafe ? B64URL_MAP$1 : BASE64_MAP$1;\n    let output = '';\n    let bits = 0;\n    let buffer = 0;\n    for (let i = 0; i < input.length; i++) {\n        buffer = (buffer << 8) | input[i];\n        bits += 8;\n        while (bits >= 6) {\n            bits -= 6;\n            output += map[(buffer >> bits) & 0x3f];\n        }\n    }\n    if (bits > 0) {\n        buffer <<= 6 - bits;\n        output += map[buffer & 0x3f];\n        while (bits < 6) {\n            output += padding ? '=' : '';\n            bits += 2;\n        }\n    }\n    return output;\n}\nfunction b64decode$1(input, urlSafe = false) {\n    const map = (urlSafe || input.includes('-') || input.includes('_'))\n        ? B64URL_MAP$1.split('')\n        : BASE64_MAP$1.split('');\n    input = input.replace(/=+$/, '');\n    const chars = input.split('');\n    let bits = 0;\n    let value = 0;\n    const bytes = [];\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars[i];\n        const index = map.indexOf(c);\n        if (index === -1) {\n            throw new Error('Invalid character: ' + c);\n        }\n        bits += 6;\n        value <<= 6;\n        value |= index;\n        if (bits >= 8) {\n            bits -= 8;\n            bytes.push((value >>> bits) & 0xff);\n        }\n    }\n    return new Uint8Array(bytes);\n}\nconst Base64$1 = {\n    encode: b64encode$1,\n    decode: b64decode$1\n};\nconst B64URL$1 = {\n    encode: (data) => b64encode$1(data, true, false),\n    decode: (data) => b64decode$1(data, true)\n};\n\nconst _0n = BigInt(0);\nconst _255n$1 = BigInt(255);\nconst _256n$1 = BigInt(256);\nfunction big_size$1(big) {\n    if (big <= 0xffn)\n        return 1;\n    if (big <= 0xffffn)\n        return 2;\n    if (big <= 0xffffffffn)\n        return 4;\n    if (big <= 0xffffffffffffffffn)\n        return 8;\n    if (big <= 0xffffffffffffffffffffffffffffffffn)\n        return 16;\n    if (big <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) {\n        return 32;\n    }\n    throw new TypeError('Must specify a fixed buffer size for bigints greater than 32 bytes.');\n}\nfunction bigToBytes$1(big, size, endian = 'be') {\n    if (size === undefined)\n        size = big_size$1(big);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (big > _0n) {\n        const byte = big & _255n$1;\n        const num = Number(byte);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        big = (big - byte) / _256n$1;\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToBig$1(bytes) {\n    let num = BigInt(0);\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * _256n$1) + BigInt(bytes[i]);\n    }\n    return BigInt(num);\n}\n\nfunction binToBytes$1(binary) {\n    const bins = binary.split('').map(Number);\n    if (bins.length % 8 !== 0) {\n        throw new Error(`Binary array is invalid length: ${binary.length}`);\n    }\n    const bytes = new Uint8Array(bins.length / 8);\n    for (let i = 0, ct = 0; i < bins.length; i += 8, ct++) {\n        let byte = 0;\n        for (let j = 0; j < 8; j++) {\n            byte |= (bins[i + j] << (7 - j));\n        }\n        bytes[ct] = byte;\n    }\n    return bytes;\n}\nfunction bytesToBin$1(bytes) {\n    const bin = new Array(bytes.length * 8);\n    let count = 0;\n    for (const num of bytes) {\n        if (num > 255) {\n            throw new Error(`Invalid byte value: ${num}. Byte values must be between 0 and 255.`);\n        }\n        for (let i = 7; i >= 0; i--, count++) {\n            bin[count] = (num >> i) & 1;\n        }\n    }\n    return bin.join('');\n}\n\nfunction num_size$1(num) {\n    if (num <= 0xFF)\n        return 1;\n    if (num <= 0xFFFF)\n        return 2;\n    if (num <= 0xFFFFFFFF)\n        return 4;\n    throw new TypeError('Numbers larger than 4 bytes must specify a fixed size!');\n}\nfunction numToBytes$1(num, size, endian = 'be') {\n    if (size === undefined)\n        size = num_size$1(num);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (num > 0) {\n        const byte = num & 255;\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        num = (num - byte) / 256;\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToNum$1(bytes) {\n    let num = 0;\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * 256) + bytes[i];\n        is_safe_num$1(num);\n    }\n    return num;\n}\n\nconst ec$3 = new TextEncoder();\nconst dc$1 = new TextDecoder();\nfunction strToBytes$1(str) {\n    return ec$3.encode(str);\n}\nfunction bytesToStr$1(bytes) {\n    return dc$1.decode(bytes);\n}\nfunction hex_size$1(hexstr, size) {\n    is_hex$1(hexstr);\n    const len = hexstr.length / 2;\n    if (size === undefined)\n        size = len;\n    if (len > size) {\n        throw new TypeError(`Hex string is larger than array size: ${len} > ${size}`);\n    }\n    return size;\n}\nfunction hexToBytes$2(hexstr, size, endian = 'le') {\n    size = hex_size$1(hexstr, size);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    for (let i = 0; i < hexstr.length; i += 2) {\n        const char = hexstr.substring(i, i + 2);\n        const num = parseInt(char, 16);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToHex$2(bytes) {\n    let chars = '';\n    for (let i = 0; i < bytes.length; i++) {\n        chars += bytes[i].toString(16).padStart(2, '0');\n    }\n    return chars;\n}\nfunction jsonToBytes$1(obj) {\n    const str = JSON.stringify(obj, (_, v) => {\n        return typeof v === 'bigint'\n            ? `${v}n`\n            : v;\n    });\n    return strToBytes$1(str);\n}\n\nfunction buffer$1(data, size, endian) {\n    if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    if (data instanceof Uint8Array) {\n        return set_buffer$1(data, size, endian);\n    }\n    if (typeof data === 'string') {\n        return hexToBytes$2(data, size, endian);\n    }\n    if (typeof data === 'bigint') {\n        return bigToBytes$1(data, size, endian);\n    }\n    if (typeof data === 'number') {\n        return numToBytes$1(data, size, endian);\n    }\n    if (typeof data === 'boolean') {\n        return Uint8Array.of(data ? 1 : 0);\n    }\n    throw TypeError('Unsupported format:' + String(typeof data));\n}\n\nlet Buff$1 = class Buff extends Uint8Array {\n    static { this.num = numToBuff$1; }\n    static { this.big = bigToBuff$1; }\n    static { this.bin = binToBuff$1; }\n    static { this.raw = rawToBuff$1; }\n    static { this.str = strToBuff$1; }\n    static { this.hex = hexToBuff$1; }\n    static { this.bytes = bytesToBuff$1; }\n    static { this.json = jsonToBuff$1; }\n    static { this.base64 = base64ToBuff$1; }\n    static { this.b64url = b64urlToBuff$1; }\n    static { this.bech32 = bech32ToBuff$1; }\n    static { this.b58chk = b58chkToBuff$1; }\n    static { this.encode = strToBytes$1; }\n    static { this.decode = bytesToStr$1; }\n    static random(size = 32) {\n        const rand = random$2(size);\n        return new Buff(rand, size);\n    }\n    constructor(data, size, endian) {\n        const buffer$1$1 = buffer$1(data, size, endian);\n        super(buffer$1$1);\n    }\n    get arr() {\n        return [...this];\n    }\n    get num() {\n        return this.toNum();\n    }\n    get big() {\n        return this.toBig();\n    }\n    get str() {\n        return this.toStr();\n    }\n    get hex() {\n        return this.toHex();\n    }\n    get raw() {\n        return new Uint8Array(this);\n    }\n    get bin() {\n        return this.toBin();\n    }\n    get b58chk() {\n        return this.tob58chk();\n    }\n    get base64() {\n        return this.toBase64();\n    }\n    get b64url() {\n        return this.toB64url();\n    }\n    get digest() {\n        return this.toHash();\n    }\n    get id() {\n        return this.toHash().hex;\n    }\n    get stream() {\n        return new Stream$1(this);\n    }\n    toNum(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return bytesToNum$1(bytes);\n    }\n    toBin() {\n        return bytesToBin$1(this);\n    }\n    toBig(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return bytesToBig$1(bytes);\n    }\n    toHash() {\n        const digest = sha256$4(this);\n        return new Buff(digest);\n    }\n    toJson() {\n        const str = bytesToStr$1(this);\n        return JSON.parse(str);\n    }\n    toBech32(hrp, version = 0) {\n        return Bech32$1.encode(this, hrp, version);\n    }\n    toStr() { return bytesToStr$1(this); }\n    toHex() { return bytesToHex$2(this); }\n    toBytes() { return new Uint8Array(this); }\n    tob58chk() { return Base58C$1.encode(this); }\n    toBase64() { return Base64$1.encode(this); }\n    toB64url() { return B64URL$1.encode(this); }\n    prepend(data) {\n        return Buff.join([Buff.bytes(data), this]);\n    }\n    append(data) {\n        return Buff.join([this, Buff.bytes(data)]);\n    }\n    slice(start, end) {\n        const arr = new Uint8Array(this).slice(start, end);\n        return new Buff(arr);\n    }\n    subarray(begin, end) {\n        const arr = new Uint8Array(this).subarray(begin, end);\n        return new Buff(arr);\n    }\n    reverse() {\n        const arr = new Uint8Array(this).reverse();\n        return new Buff(arr);\n    }\n    write(bytes, offset) {\n        const b = Buff.bytes(bytes);\n        this.set(b, offset);\n    }\n    prefixSize(endian) {\n        const size = Buff.varInt(this.length, endian);\n        return Buff.join([size, this]);\n    }\n    static from(data) {\n        return new Buff(Uint8Array.from(data));\n    }\n    static of(...args) {\n        return new Buff(Uint8Array.of(...args));\n    }\n    static join(arr) {\n        const bytes = arr.map(e => Buff.bytes(e));\n        const joined = join_array$1(bytes);\n        return new Buff(joined);\n    }\n    static varInt(num, endian) {\n        if (num < 0xFD) {\n            return Buff.num(num, 1);\n        }\n        else if (num < 0x10000) {\n            return Buff.of(0xFD, ...Buff.num(num, 2, endian));\n        }\n        else if (num < 0x100000000) {\n            return Buff.of(0xFE, ...Buff.num(num, 4, endian));\n        }\n        else if (BigInt(num) < 0x10000000000000000n) {\n            return Buff.of(0xFF, ...Buff.num(num, 8, endian));\n        }\n        else {\n            throw new Error(`Value is too large: ${num}`);\n        }\n    }\n};\nfunction numToBuff$1(number, size, endian) {\n    return new Buff$1(number, size, endian);\n}\nfunction binToBuff$1(data, size, endian) {\n    return new Buff$1(binToBytes$1(data), size, endian);\n}\nfunction bigToBuff$1(bigint, size, endian) {\n    return new Buff$1(bigint, size, endian);\n}\nfunction rawToBuff$1(data, size, endian) {\n    return new Buff$1(data, size, endian);\n}\nfunction strToBuff$1(data, size, endian) {\n    return new Buff$1(strToBytes$1(data), size, endian);\n}\nfunction hexToBuff$1(data, size, endian) {\n    return new Buff$1(data, size, endian);\n}\nfunction bytesToBuff$1(data, size, endian) {\n    return new Buff$1(data, size, endian);\n}\nfunction jsonToBuff$1(data) {\n    return new Buff$1(jsonToBytes$1(data));\n}\nfunction base64ToBuff$1(data) {\n    return new Buff$1(Base64$1.decode(data));\n}\nfunction b64urlToBuff$1(data) {\n    return new Buff$1(B64URL$1.decode(data));\n}\nfunction bech32ToBuff$1(data) {\n    return new Buff$1(Bech32$1.decode(data));\n}\nfunction b58chkToBuff$1(data) {\n    return new Buff$1(Base58C$1.decode(data));\n}\nlet Stream$1 = class Stream {\n    constructor(data) {\n        this.data = Buff$1.bytes(data);\n        this.size = this.data.length;\n    }\n    peek(size) {\n        if (size > this.size) {\n            throw new Error(`Size greater than stream: ${size} > ${this.size}`);\n        }\n        return new Buff$1(this.data.slice(0, size));\n    }\n    read(size) {\n        size = size ?? this.readSize();\n        const chunk = this.peek(size);\n        this.data = this.data.slice(size);\n        this.size = this.data.length;\n        return chunk;\n    }\n    readSize(endian) {\n        const num = this.read(1).num;\n        switch (true) {\n            case (num >= 0 && num < 0xFD):\n                return num;\n            case (num === 0xFD):\n                return this.read(2).toNum(endian);\n            case (num === 0xFE):\n                return this.read(4).toNum(endian);\n            case (num === 0xFF):\n                return this.read(8).toNum(endian);\n            default:\n                throw new Error(`Varint is out of range: ${num}`);\n        }\n    }\n};\n\nfunction checkSize(input, size) {\n    const bytes = Buff$1.bytes(input);\n    if (bytes.length !== size) {\n        throw new Error(`Invalid input size: ${bytes.hex} !== ${size}`);\n    }\n}\nfunction safeThrow(errorMsg, shouldThrow) {\n    if (shouldThrow) {\n        throw new Error(errorMsg);\n    }\n    else {\n        return false;\n    }\n}\nfunction hashTag(tag, ...data) {\n    const htag = Buff$1.str(tag).digest.raw;\n    const buff = data.map(e => Buff$1.bytes(e));\n    return Buff$1.join([htag, htag, Buff$1.join(buff)]).digest;\n}\n\nconst OPCODE_MAP = {\n    OP_0: 0,\n    OP_PUSHDATA1: 76,\n    OP_PUSHDATA2: 77,\n    OP_PUSHDATA4: 78,\n    OP_1NEGATE: 79,\n    OP_SUCCESS80: 80,\n    OP_1: 81,\n    OP_2: 82,\n    OP_3: 83,\n    OP_4: 84,\n    OP_5: 85,\n    OP_6: 86,\n    OP_7: 87,\n    OP_8: 88,\n    OP_9: 89,\n    OP_10: 90,\n    OP_11: 91,\n    OP_12: 92,\n    OP_13: 93,\n    OP_14: 94,\n    OP_15: 95,\n    OP_16: 96,\n    OP_NOP: 97,\n    OP_SUCCESS98: 98,\n    OP_IF: 99,\n    OP_NOTIF: 100,\n    OP_ELSE: 103,\n    OP_ENDIF: 104,\n    OP_VERIFY: 105,\n    OP_RETURN: 106,\n    OP_TOALTSTACK: 107,\n    OP_FROMALTSTACK: 108,\n    OP_2DROP: 109,\n    OP_2DUP: 110,\n    OP_3DUP: 111,\n    OP_2OVER: 112,\n    OP_2ROT: 113,\n    OP_2SWAP: 114,\n    OP_IFDUP: 115,\n    OP_DEPTH: 116,\n    OP_DROP: 117,\n    OP_DUP: 118,\n    OP_NIP: 119,\n    OP_OVER: 120,\n    OP_PICK: 121,\n    OP_ROLL: 122,\n    OP_ROT: 123,\n    OP_SWAP: 124,\n    OP_TUCK: 125,\n    OP_SUCCESS126: 126,\n    OP_SUCCESS127: 127,\n    OP_SUCCESS128: 128,\n    OP_SUCCESS129: 129,\n    OP_SIZE: 130,\n    OP_SUCCESS131: 131,\n    OP_SUCCESS132: 132,\n    OP_SUCCESS133: 133,\n    OP_SUCCESS134: 134,\n    OP_EQUAL: 135,\n    OP_EQUALVERIFY: 136,\n    OP_SUCCESS137: 137,\n    OP_SUCCESS138: 138,\n    OP_1ADD: 139,\n    OP_1SUB: 140,\n    OP_SUCCESS141: 141,\n    OP_SUCCESS142: 142,\n    OP_NEGATE: 143,\n    OP_ABS: 144,\n    OP_NOT: 145,\n    OP_0NOTEQUAL: 146,\n    OP_ADD: 147,\n    OP_SUB: 148,\n    OP_SUCCESS149: 149,\n    OP_SUCCESS150: 150,\n    OP_SUCCESS151: 151,\n    OP_SUCCESS152: 152,\n    OP_SUCCESS153: 153,\n    OP_BOOLAND: 154,\n    OP_BOOLOR: 155,\n    OP_NUMEQUAL: 156,\n    OP_NUMEQUALVERIFY: 157,\n    OP_NUMNOTEQUAL: 158,\n    OP_LESSTHAN: 159,\n    OP_GREATERTHAN: 160,\n    OP_LESSTHANOREQUAL: 161,\n    OP_GREATERTHANOREQUAL: 162,\n    OP_MIN: 163,\n    OP_MAX: 164,\n    OP_WITHIN: 165,\n    OP_RIPEMD160: 166,\n    OP_SHA1: 167,\n    OP_SHA256: 168,\n    OP_HASH160: 169,\n    OP_HASH256: 170,\n    OP_CODESEPARATOR: 171,\n    OP_CHECKSIG: 172,\n    OP_CHECKSIGVERIFY: 173,\n    OP_CHECKMULTISIG: 174,\n    OP_CHECKMULTISIGVERIFY: 175,\n    OP_NOP1: 176,\n    OP_CHECKLOCKTIMEVERIFY: 177,\n    OP_CHECKSEQUENCEVERIFY: 178,\n    OP_NOP4: 179,\n    OP_NOP5: 180,\n    OP_NOP6: 181,\n    OP_NOP7: 182,\n    OP_NOP8: 183,\n    OP_NOP9: 184,\n    OP_NOP10: 185,\n    OP_CHECKSIGADD: 186,\n    OP_SUCCESS187: 187,\n    OP_SUCCESS188: 188,\n    OP_SUCCESS189: 189,\n    OP_SUCCESS190: 190,\n    OP_SUCCESS191: 191,\n    OP_SUCCESS192: 192,\n    OP_SUCCESS193: 193,\n    OP_SUCCESS194: 194,\n    OP_SUCCESS195: 195,\n    OP_SUCCESS196: 196,\n    OP_SUCCESS197: 197,\n    OP_SUCCESS198: 198,\n    OP_SUCCESS199: 199,\n    OP_SUCCESS200: 200,\n    OP_SUCCESS201: 201,\n    OP_SUCCESS202: 202,\n    OP_SUCCESS203: 203,\n    OP_SUCCESS204: 204,\n    OP_SUCCESS205: 205,\n    OP_SUCCESS206: 206,\n    OP_SUCCESS207: 207,\n    OP_SUCCESS208: 208,\n    OP_SUCCESS209: 209,\n    OP_SUCCESS210: 210,\n    OP_SUCCESS211: 211,\n    OP_SUCCESS212: 212,\n    OP_SUCCESS213: 213,\n    OP_SUCCESS214: 214,\n    OP_SUCCESS215: 215,\n    OP_SUCCESS216: 216,\n    OP_SUCCESS217: 217,\n    OP_SUCCESS218: 218,\n    OP_SUCCESS219: 219,\n    OP_SUCCESS220: 220,\n    OP_SUCCESS221: 221,\n    OP_SUCCESS222: 222,\n    OP_SUCCESS223: 223,\n    OP_SUCCESS224: 224,\n    OP_SUCCESS225: 225,\n    OP_SUCCESS226: 226,\n    OP_SUCCESS227: 227,\n    OP_SUCCESS228: 228,\n    OP_SUCCESS229: 229,\n    OP_SUCCESS230: 230,\n    OP_SUCCESS231: 231,\n    OP_SUCCESS232: 232,\n    OP_SUCCESS233: 233,\n    OP_SUCCESS234: 234,\n    OP_SUCCESS235: 235,\n    OP_SUCCESS236: 236,\n    OP_SUCCESS237: 237,\n    OP_SUCCESS238: 238,\n    OP_SUCCESS239: 239,\n    OP_SUCCESS240: 240,\n    OP_SUCCESS241: 241,\n    OP_SUCCESS242: 242,\n    OP_SUCCESS243: 243,\n    OP_SUCCESS244: 244,\n    OP_SUCCESS245: 245,\n    OP_SUCCESS246: 246,\n    OP_SUCCESS247: 247,\n    OP_SUCCESS248: 248,\n    OP_SUCCESS249: 249,\n    OP_SUCCESS250: 250,\n    OP_SUCCESS251: 251,\n    OP_SUCCESS252: 252,\n    OP_SUCCESS253: 253,\n    OP_SUCCESS254: 254\n};\nfunction getOpLabel(num) {\n    if (num > 186 && num < 255) {\n        return 'OP_SUCCESS' + String(num);\n    }\n    for (const [k, v] of Object.entries(OPCODE_MAP)) {\n        if (v === num)\n            return k;\n    }\n    throw new Error('OPCODE not found:' + String(num));\n}\nfunction getOpCode(string) {\n    for (const [k, v] of Object.entries(OPCODE_MAP)) {\n        if (k === string)\n            return Number(v);\n    }\n    throw new Error('OPCODE not found:' + string);\n}\nfunction getWordType(word) {\n    switch (true) {\n        case (word === 0):\n            return 'opcode';\n        case (word >= 1 && word <= 75):\n            return 'varint';\n        case (word === 76):\n            return 'pushdata1';\n        case (word === 77):\n            return 'pushdata2';\n        case (word === 78):\n            return 'pushdata4';\n        case (word <= 254):\n            return 'opcode';\n        default:\n            throw new Error(`Invalid word range: ${word}`);\n    }\n}\nfunction isValidWord(word) {\n    const MIN_RANGE = 75;\n    const MAX_RANGE = 254;\n    const DISABLED_OPCODES = [];\n    switch (true) {\n        case (typeof (word) !== 'number'):\n            return false;\n        case (word === 0):\n            return true;\n        case (DISABLED_OPCODES.includes(word)):\n            return false;\n        case (MIN_RANGE < word && word < MAX_RANGE):\n            return true;\n        default:\n            return false;\n    }\n}\n\nfunction isHex(value) {\n    return (typeof value === 'string' &&\n        value.length % 2 === 0 &&\n        /[0-9a-fA-F]/.test(value));\n}\nfunction isBytes$1(value) {\n    return (isHex(value) || value instanceof Uint8Array);\n}\n\nconst MAX_WORD_SIZE = 0x208;\nfunction encodeScript(script = [], varint = true) {\n    let buff = Buff$1.num(0);\n    if (Array.isArray(script)) {\n        buff = Buff$1.raw(encodeWords(script));\n    }\n    if (isHex(script)) {\n        buff = Buff$1.hex(script);\n    }\n    if (script instanceof Uint8Array) {\n        buff = Buff$1.raw(script);\n    }\n    if (varint) {\n        buff = buff.prefixSize('le');\n    }\n    return buff;\n}\nfunction encodeWords(wordArray) {\n    const words = [];\n    for (const word of wordArray) {\n        words.push(encodeWord(word));\n    }\n    return (words.length > 0)\n        ? Buff$1.join(words)\n        : new Uint8Array();\n}\nfunction encodeWord(word) {\n    let buff = new Uint8Array();\n    if (typeof (word) === 'string') {\n        if (word.startsWith('OP_')) {\n            return Buff$1.num(getOpCode(word), 1);\n        }\n        else if (isHex(word)) {\n            buff = Buff$1.hex(word);\n        }\n        else {\n            buff = Buff$1.str(word);\n        }\n    }\n    else {\n        buff = Buff$1.bytes(word);\n    }\n    if (buff.length === 1) {\n        if (buff[0] !== 0 && buff[0] <= 16) {\n            buff[0] += 0x50;\n            return buff;\n        }\n        else if (buff[0] > 128 && buff[0] <= 255) {\n            buff = new Uint8Array([buff[0], 0]);\n        }\n        return Buff$1.join([encodeSize(buff.length), buff]);\n    }\n    else if (buff.length > MAX_WORD_SIZE) {\n        const words = splitWord(buff);\n        return encodeWords(words);\n    }\n    else {\n        return Buff$1.join([encodeSize(buff.length), buff]);\n    }\n}\nfunction encodeSize(size) {\n    const OP_DATAPUSH1 = Buff$1.num(0x4c, 1);\n    const OP_DATAPUSH2 = Buff$1.num(0x4d, 1);\n    switch (true) {\n        case (size <= 0x4b):\n            return Buff$1.num(size);\n        case (size > 0x4b && size < 0x100):\n            return Buff$1.join([OP_DATAPUSH1, Buff$1.num(size, 1, 'le')]);\n        case (size >= 0x100 && size <= MAX_WORD_SIZE):\n            return Buff$1.join([OP_DATAPUSH2, Buff$1.num(size, 2, 'le')]);\n        default:\n            throw new Error('Invalid word size:' + size.toString());\n    }\n}\nfunction splitWord(word) {\n    const words = [];\n    const buff = new Stream$1(word);\n    while (buff.size > MAX_WORD_SIZE) {\n        words.push(buff.read(MAX_WORD_SIZE));\n    }\n    words.push(buff.read(buff.size));\n    return words;\n}\n\nfunction decodeScript(script, varint = false) {\n    let buff = Buff$1.bytes(script);\n    if (varint) {\n        const stream = buff.stream;\n        const len = stream.readSize('le');\n        buff = buff.slice(1);\n        if (buff.length !== len) {\n            throw new Error(`Varint does not match stream size: ${len} !== ${buff.length}`);\n        }\n    }\n    return decodeWords(buff);\n}\nfunction decodeWords(words) {\n    const stream = new Stream$1(words);\n    const stack = [];\n    const stackSize = stream.size;\n    let word;\n    let wordType;\n    let wordSize;\n    let count = 0;\n    while (count < stackSize) {\n        word = stream.read(1).num;\n        wordType = getWordType(word);\n        count++;\n        switch (wordType) {\n            case 'varint':\n                stack.push(stream.read(word).hex);\n                count += word;\n                break;\n            case 'pushdata1':\n                wordSize = stream.read(1).reverse().num;\n                stack.push(stream.read(wordSize).hex);\n                count += wordSize + 1;\n                break;\n            case 'pushdata2':\n                wordSize = stream.read(2).reverse().num;\n                stack.push(stream.read(wordSize).hex);\n                count += wordSize + 2;\n                break;\n            case 'pushdata4':\n                wordSize = stream.read(4).reverse().num;\n                stack.push(stream.read(wordSize).hex);\n                count += wordSize + 4;\n                break;\n            case 'opcode':\n                if (!isValidWord(word)) {\n                    throw new Error(`Invalid OPCODE: ${word}`);\n                }\n                stack.push(getOpLabel(word));\n                break;\n            default:\n                throw new Error(`Word type undefined: ${word}`);\n        }\n    }\n    return stack;\n}\n\nfunction toAsm(script, varint) {\n    if (Array.isArray(script)) {\n        script = encodeScript(script, varint);\n    }\n    if (script instanceof Uint8Array ||\n        isHex(script)) {\n        return decodeScript(script, varint);\n    }\n    throw new Error('Invalid format: ' + String(typeof script));\n}\nfunction toBytes$4(script, varint) {\n    if (script instanceof Uint8Array ||\n        isHex(script)) {\n        script = decodeScript(script, varint);\n    }\n    if (Array.isArray(script)) {\n        return encodeScript(script, varint);\n    }\n    throw new Error('Invalid format: ' + String(typeof script));\n}\nfunction toParam(script) {\n    if (!Array.isArray(script)) {\n        return Buff$1.bytes(script);\n    }\n    throw new Error('Invalid format: ' + String(typeof script));\n}\nconst FmtScript = {\n    toAsm,\n    toBytes: toBytes$4,\n    toParam\n};\n\nconst Script = {\n    encode: encodeScript,\n    decode: decodeScript,\n    fmt: FmtScript\n};\n\nfunction number$2(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool$2(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes$2(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new TypeError('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash$3(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number$2(hash.outputLen);\n    number$2(hash.blockLen);\n}\nfunction exists$2(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output$2(out, instance) {\n    bytes$2(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert$3 = {\n    number: number$2,\n    bool: bool$2,\n    bytes: bytes$2,\n    hash: hash$3,\n    exists: exists$2,\n    output: output$2,\n};\nvar assert$4 = assert$3;\n\nconst crypto$1 = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use `globalThis.crypto`, but node.js versions earlier than v19 don't\n// declare it in global scope. For node.js, package.json#exports field mapping\n// rewrites import from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n// Cast array to view\nconst createView$2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr$2 = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE$2 = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE$2)\n    throw new Error('Non little-endian hardware is not supported');\nArray.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction utf8ToBytes$3(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nfunction toBytes$2(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes$3(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nfunction concatBytes$1(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\n// For runtime check if class implements interface\nlet Hash$2 = class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n};\nfunction wrapConstructor$2(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes$2(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `globalThis.crypto` or node.js crypto module.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto$1 && typeof crypto$1.getRandomValues === 'function') {\n        return crypto$1.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n\n// Polyfill for Safari 14\nfunction setBigUint64$2(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nlet SHA2$2 = class SHA2 extends Hash$2 {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView$2(this.buffer);\n    }\n    update(data) {\n        assert$4.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes$2(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView$2(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        assert$4.exists(this);\n        assert$4.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64$2(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView$2(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n};\n\n// Choice: a ? b : c\nconst Chi$2 = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj$2 = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K$2 = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV$2 = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W$2 = new Uint32Array(64);\nlet SHA256$2 = class SHA256 extends SHA2$2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV$2[0] | 0;\n        this.B = IV$2[1] | 0;\n        this.C = IV$2[2] | 0;\n        this.D = IV$2[3] | 0;\n        this.E = IV$2[4] | 0;\n        this.F = IV$2[5] | 0;\n        this.G = IV$2[6] | 0;\n        this.H = IV$2[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W$2[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W$2[i - 15];\n            const W2 = SHA256_W$2[i - 2];\n            const s0 = rotr$2(W15, 7) ^ rotr$2(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr$2(W2, 17) ^ rotr$2(W2, 19) ^ (W2 >>> 10);\n            SHA256_W$2[i] = (s1 + SHA256_W$2[i - 7] + s0 + SHA256_W$2[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr$2(E, 6) ^ rotr$2(E, 11) ^ rotr$2(E, 25);\n            const T1 = (H + sigma1 + Chi$2(E, F, G) + SHA256_K$2[i] + SHA256_W$2[i]) | 0;\n            const sigma0 = rotr$2(A, 2) ^ rotr$2(A, 13) ^ rotr$2(A, 22);\n            const T2 = (sigma0 + Maj$2(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W$2.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n};\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nlet SHA224$2 = class SHA224 extends SHA256$2 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n};\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256$3 = wrapConstructor$2(() => new SHA256$2());\nwrapConstructor$2(() => new SHA224$2());\n\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst _0n$8 = BigInt(0);\nconst _1n$5 = BigInt(1);\nconst _2n$4 = BigInt(2);\nconst u8a$1 = (a) => a instanceof Uint8Array;\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex$1(bytes) {\n    if (!u8a$1(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// Caching slows it down 2-3x\nfunction hexToBytes$1(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    if (hex.length % 2)\n        throw new Error('hex string is invalid: unpadded ' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// Big Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex$1(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a$1(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex$1(Uint8Array.from(bytes).reverse()));\n}\nconst numberToBytesBE = (n, len) => hexToBytes$1(n.toString(16).padStart(len * 2, '0'));\nconst numberToBytesLE = (n, len) => numberToBytesBE(n, len).reverse();\n// Returns variable number bytes (minimal bigint encoding?)\nconst numberToVarBytesBE = (n) => hexToBytes$1(numberToHexUnpadded(n));\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes$1(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a$1(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n// Copies several Uint8Arrays into one.\nfunction concatBytes(...arrs) {\n    const r = new Uint8Array(arrs.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrs.forEach((a) => {\n        if (!u8a$1(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\nfunction utf8ToBytes$2(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\n// Bit operations\n// Amount of bits inside bigint (Same as n.toString(2).length)\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > 0n; n >>= _1n$5, len += 1)\n        ;\n    return len;\n}\n// Gets single bit at position. NOTE: first bit position is 0 (same as arrays)\n// Same as !!+Array.from(n.toString(2)).reverse()[pos]\nconst bitGet = (n, pos) => (n >> BigInt(pos)) & 1n;\n// Sets single bit at position\nconst bitSet = (n, pos, value) => n | ((value ? _1n$5 : _0n$8) << BigInt(pos));\n// Return mask for N bits (Same as BigInt(`0b${Array(i).fill('1').join('')}`))\n// Not using ** operator with bigints for old engines.\nconst bitMask = (n) => (_2n$4 << BigInt(n - 1)) - _1n$5;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\nvar ut = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    bitGet: bitGet,\n    bitLen: bitLen,\n    bitMask: bitMask,\n    bitSet: bitSet,\n    bytesToHex: bytesToHex$1,\n    bytesToNumberBE: bytesToNumberBE,\n    bytesToNumberLE: bytesToNumberLE,\n    concatBytes: concatBytes,\n    createHmacDrbg: createHmacDrbg,\n    ensureBytes: ensureBytes,\n    equalBytes: equalBytes,\n    hexToBytes: hexToBytes$1,\n    hexToNumber: hexToNumber,\n    numberToBytesBE: numberToBytesBE,\n    numberToBytesLE: numberToBytesLE,\n    numberToHexUnpadded: numberToHexUnpadded,\n    numberToVarBytesBE: numberToVarBytesBE,\n    utf8ToBytes: utf8ToBytes$2,\n    validateObject: validateObject\n});\n\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n// prettier-ignore\nconst _0n$7 = BigInt(0), _1n$4 = BigInt(1), _2n$3 = BigInt(2), _3n$2 = BigInt(3);\n// prettier-ignore\nconst _4n$2 = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nBigInt(9); BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n$7 ? result : b + result;\n}\n/**\n * Efficiently exponentiate num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * powMod(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n$7 || power < _0n$7)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n$4)\n        return _0n$7;\n    let res = _1n$4;\n    while (power > _0n$7) {\n        if (power & _1n$4)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n$4;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n$7) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n$7 || modulo <= _0n$7) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Eucledian GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n$7, u = _1n$4;\n    while (a !== _0n$7) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        // prettier-ignore\n        b = a, a = r, x = u, u = m;\n    }\n    const gcd = b;\n    if (gcd !== _1n$4)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n// Tonelli-Shanks algorithm\n// Paper 1: https://eprint.iacr.org/2012/685.pdf (page 12)\n// Paper 2: Square Roots from 1; 24, 51, 10 to Dan Shanks\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n$4) / _2n$3;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n$4, S = 0; Q % _2n$3 === _0n$7; Q /= _2n$3, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n$3; Z < P && pow(Z, legendreC, P) !== P - _1n$4; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n$4) / _4n$2;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n$4) / _2n$3;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n$4 << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n$2 === _3n$2) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n$4) / _4n$2;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n$3);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n$3), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n$7)\n        throw new Error('Expected power > 0');\n    if (power === _0n$7)\n        return f.ONE;\n    if (power === _1n$4)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n$7) {\n        if (power & _1n$4)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n$4;\n    }\n    return p;\n}\n// 0 is non-invertible: non-batched version will throw on 0\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a galois field over prime. Non-primes are not supported for now.\n * Do not init in loop: slow. Very fragile: always run a benchmark on change.\n * Major performance gains:\n * a) non-normalized operations like mulN instead of mul\n * b) `Object.freeze`\n * c) Same object shape: never add or remove keys\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field$1(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n$7)\n        throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n$7,\n        ONE: _1n$4,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n$7 <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n$7,\n        isOdd: (num) => (num & _1n$4) === _1n$4,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\n/**\n * FIPS 186 B.4.1-compliant \"constant-time\" private key generation utility.\n * Can take (n+8) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being neglible.\n * Needs at least 40 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * @param hash hash output from SHA3 or a similar function\n * @returns valid private scalar\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n$4) + _1n$4;\n}\n\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nconst _0n$6 = BigInt(0);\nconst _1n$3 = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n$6) {\n                if (n & _1n$3)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n$3;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n$3;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        if (res[0] === 0x00 && res[1] <= 0x7f)\n            throw new E('Invalid signature integer: trailing length');\n        // ^ Weird condition: not about length, but about first bytes of number.\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        const slice = (s) => (Number.parseInt(s[0], 16) >= 8 ? '00' + s : s); // slice DER\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n$5 = BigInt(0), _1n$2 = BigInt(1), _2n$2 = BigInt(2), _3n$1 = BigInt(3), _4n$1 = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((c, point, isCompressed) => {\n            const a = point.toAffine();\n            return concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n$5 < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = bytesToHex$1(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            // Zero is valid point too!\n            if (this.is0()) {\n                if (CURVE.allowInfinityPoint)\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n$1);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n$1);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n$5)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n$2)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n$5 || k2 > _0n$5) {\n                if (k1 & _1n$2)\n                    k1p = k1p.add(d);\n                if (k2 & _1n$2)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n$2;\n                k2 >>= _1n$2;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n$5 || a === _1n$2 || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n$2)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n$2)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return bytesToHex$1(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n$5 < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n$2) === _1n$2;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => bytesToHex$1(numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n$2;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return hexToBytes$1(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return hexToBytes$1(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size (nBitLength+64)\n         * as per FIPS 186 B.4.1 with modulo bias being neglible.\n         */\n        randomPrivateKey: () => {\n            const rand = CURVE.randomBytes(Fp.BYTES + 8);\n            const num = hashToPrivateScalar(rand, CURVE_ORDER);\n            return numberToBytesBE(num, CURVE.nByteLength);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n$5 <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e, Fp.BYTES)); // check for being of size BYTES\n        }\n        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n$5)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n$5)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$2); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash (not message: you need to hash it by yourself).\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param opts `lowS, extraEntropy, prehash`\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = createHmacDrbg(CURVE.hash.outputLen, CURVE.nByteLength, CURVE.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n// Implementation of the Shallue and van de Woestijne method for any Weierstrass curve\n// TODO: check if there is a way to merge this with uvRatio in Edwards && move to modular?\n// b = True and y = sqrt(u / v) if (u / v) is square in F, and\n// b = False and y = sqrt(Z * (u / v)) otherwise.\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n$5;\n    for (let o = q - _1n$2; o % _2n$2 === _0n$5; o /= _2n$2)\n        l += _1n$2;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    const c2 = (q - _1n$2) / _2n$2 ** c1; // 2. c2 = (q - 1) / (2^c1)        # Integer arithmetic\n    const c3 = (c2 - _1n$2) / _2n$2; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n$2 ** c1 - _1n$2; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n$2 ** (c1 - _1n$2); // 5. c5 = 2^(c1 - 1)              # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n$2) / _2n$2); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > 1; i--) {\n            let tv5 = _2n$2 ** (i - _2n$2); // 18.    tv5 = i - 2;    19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n$1 === _3n$1) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n$1) / _4n$1; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n// From draft-irtf-cfrg-hash-to-curve-16\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return utf8ToBytes$2(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.4.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    if (DST.length > 255)\n        DST = H(concatBytes(utf8ToBytes$2('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H(concatBytes(...args));\n    }\n    const pseudo_random_bytes = concatBytes(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update(utf8ToBytes$2('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.3\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    validateObject(options, {\n        DST: 'string',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === undefined) {\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\", \"xof\" or undefined');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = mod(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n\n// HMAC (RFC 2104)\nlet HMAC$1 = class HMAC extends Hash$2 {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assert$4.hash(hash);\n        const key = toBytes$2(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new TypeError('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assert$4.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assert$4.exists(this);\n        assert$4.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n};\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac$2 = (hash, key, message) => new HMAC$1(hash, key).update(message).digest();\nhmac$2.create = (hash, key) => new HMAC$1(hash, key);\n\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac$2(hash, key, concatBytes$1(...msgs)),\n        randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n$1 = BigInt(1);\nconst _2n$1 = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n$1) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n$1, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n$1, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = Field$1(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = createCurve({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n$1 * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256$3);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n$4 = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n$4 < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n$4 < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256$3(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256$3(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP$1 = (x) => mod(x, secp256k1P);\nconst modN$1 = (x) => mod(x, secp256k1N);\nconst Point$2 = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point$2.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point$2.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN$1(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP$1(x * x);\n    const c = modP$1(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n$1 !== _0n$4)\n        y = modP$1(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point$2(x, y, _1n$1); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN$1(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN$1(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n$4)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN$1(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN$1(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = {\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n};\nconst isoMap = isogenyMap(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j))));\nconst mapSWU = mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n});\ncreateHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256$3,\n});\n\nfunction number$1(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool$1(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes$1(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new TypeError('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash$2(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number$1(hash.outputLen);\n    number$1(hash.blockLen);\n}\nfunction exists$1(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output$1(out, instance) {\n    bytes$1(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert$1$1 = {\n    number: number$1,\n    bool: bool$1,\n    bytes: bytes$1,\n    hash: hash$2,\n    exists: exists$1,\n    output: output$1,\n};\nvar assert$2 = assert$1$1;\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Cast array to view\nconst createView$1 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr$1 = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE$1 = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE$1)\n    throw new Error('Non little-endian hardware is not supported');\nArray.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction utf8ToBytes$1(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nfunction toBytes$1(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes$1(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n// For runtime check if class implements interface\nlet Hash$1 = class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n};\nfunction wrapConstructor$1(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes$1(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\n\n// Polyfill for Safari 14\nfunction setBigUint64$1(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nlet SHA2$1 = class SHA2 extends Hash$1 {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView$1(this.buffer);\n    }\n    update(data) {\n        assert$2.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes$1(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView$1(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        assert$2.exists(this);\n        assert$2.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView$1(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n};\n\n// Choice: a ? b : c\nconst Chi$1 = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj$1 = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K$1 = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV$1 = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W$1 = new Uint32Array(64);\nlet SHA256$1 = class SHA256 extends SHA2$1 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV$1[0] | 0;\n        this.B = IV$1[1] | 0;\n        this.C = IV$1[2] | 0;\n        this.D = IV$1[3] | 0;\n        this.E = IV$1[4] | 0;\n        this.F = IV$1[5] | 0;\n        this.G = IV$1[6] | 0;\n        this.H = IV$1[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W$1[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W$1[i - 15];\n            const W2 = SHA256_W$1[i - 2];\n            const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr$1(W2, 17) ^ rotr$1(W2, 19) ^ (W2 >>> 10);\n            SHA256_W$1[i] = (s1 + SHA256_W$1[i - 7] + s0 + SHA256_W$1[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr$1(E, 6) ^ rotr$1(E, 11) ^ rotr$1(E, 25);\n            const T1 = (H + sigma1 + Chi$1(E, F, G) + SHA256_K$1[i] + SHA256_W$1[i]) | 0;\n            const sigma0 = rotr$1(A, 2) ^ rotr$1(A, 13) ^ rotr$1(A, 22);\n            const T2 = (sigma0 + Maj$1(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W$1.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n};\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nlet SHA224$1 = class SHA224 extends SHA256$1 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n};\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256$2 = wrapConstructor$1(() => new SHA256$1());\nwrapConstructor$1(() => new SHA224$1());\n\nfunction within_size(data, size) {\n    if (data.length > size) {\n        throw new TypeError(`Data is larger than array size: ${data.length} > ${size}`);\n    }\n}\nfunction is_hex(hex) {\n    if (hex.match(/[^a-fA-f0-9]/) !== null) {\n        throw new TypeError('Invalid characters in hex string: ' + hex);\n    }\n    if (hex.length % 2 !== 0) {\n        throw new Error(`Length of hex string is invalid: ${hex.length}`);\n    }\n}\nfunction is_safe_num(num) {\n    if (num > Number.MAX_SAFE_INTEGER) {\n        throw new TypeError('Number exceeds safe bounds!');\n    }\n}\n\nconst { getRandomValues } = crypto ?? globalThis.crypto ?? window.crypto;\nfunction random$1(size = 32) {\n    if (typeof getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(size));\n    }\n    throw new Error('Crypto module missing getRandomValues!');\n}\nfunction set_buffer(data, size, endian = 'be') {\n    if (size === undefined)\n        size = data.length;\n    within_size(data, size);\n    const buffer = new Uint8Array(size).fill(0);\n    const offset = (endian === 'be') ? 0 : size - data.length;\n    buffer.set(data, offset);\n    return buffer;\n}\nfunction join_array(arr) {\n    let i, offset = 0;\n    const size = arr.reduce((len, arr) => len + arr.length, 0);\n    const buff = new Uint8Array(size);\n    for (i = 0; i < arr.length; i++) {\n        const a = arr[i];\n        buff.set(a, offset);\n        offset += a.length;\n    }\n    return buff;\n}\n\nconst ec$2 = new TextEncoder();\nconst ALPHABETS = [\n    {\n        name: 'base58',\n        charset: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n    }\n];\nfunction getAlphabet(name) {\n    for (const alpha of ALPHABETS) {\n        if (alpha.name === name) {\n            return alpha.charset;\n        }\n    }\n    throw TypeError('Charset does not exist: ' + name);\n}\nfunction encode$1$1(data, charset, padding = false) {\n    if (typeof data === 'string')\n        data = ec$2.encode(data);\n    const alphabet = getAlphabet(charset);\n    const len = alphabet.length;\n    const d = [];\n    let s = '', i, j = 0, c, n;\n    for (i = 0; i < data.length; i++) {\n        j = 0;\n        c = data[i];\n        s += (c > 0 || (s.length ^ i) > 0) ? '' : '1';\n        while (j in d || c > 0) {\n            n = d[j];\n            n = n > 0 ? n * 256 + c : c;\n            c = n / len | 0;\n            d[j] = n % len;\n            j++;\n        }\n    }\n    while (j-- > 0) {\n        s += alphabet[d[j]];\n    }\n    return (padding && s.length % 4 > 0)\n        ? s + '='.repeat(4 - s.length % 4)\n        : s;\n}\nfunction decode$1$1(encoded, charset) {\n    const alphabet = getAlphabet(charset);\n    const len = alphabet.length, d = [], b = [];\n    encoded = encoded.replace('=', '');\n    let i, j = 0, c, n;\n    for (i = 0; i < encoded.length; i++) {\n        j = 0;\n        c = alphabet.indexOf(encoded[i]);\n        if (c < 0) {\n            throw new Error(`Character range out of bounds: ${c}`);\n        }\n        if (!(c > 0 || (b.length ^ i) > 0))\n            b.push(0);\n        while (j in d || c > 0) {\n            n = d[j];\n            n = n > 0 ? n * len + c : c;\n            c = n >> 8;\n            d[j] = n % 256;\n            j++;\n        }\n    }\n    while (j-- > 0) {\n        b.push(d[j]);\n    }\n    return new Uint8Array(b);\n}\nfunction hash256$1(data) {\n    return sha256$2(sha256$2(data));\n}\nfunction addChecksum(data) {\n    const sum = hash256$1(data);\n    return join_array([data, sum.slice(0, 4)]);\n}\nfunction checkTheSum(data) {\n    const ret = data.slice(0, -4);\n    const chk = data.slice(-4);\n    const sum = hash256$1(ret).slice(0, 4);\n    if (sum.toString() !== chk.toString()) {\n        throw new Error('Invalid checksum!');\n    }\n    return ret;\n}\nconst BaseX = {\n    encode: encode$1$1,\n    decode: decode$1$1\n};\nconst Base58C = {\n    encode: (data) => {\n        const withSum = addChecksum(data);\n        return BaseX.encode(withSum, 'base58');\n    },\n    decode: (data) => {\n        const decoded = BaseX.decode(data, 'base58');\n        return checkTheSum(decoded);\n    }\n};\n\nconst CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nconst ENCODINGS = [\n    { version: 0, name: 'bech32', const: 1 },\n    { version: 1, name: 'bech32m', const: 0x2bc830a3 }\n];\nfunction polymod(values) {\n    let chk = 1;\n    for (let p = 0; p < values.length; ++p) {\n        const top = chk >> 25;\n        chk = (chk & 0x1ffffff) << 5 ^ values[p];\n        for (let i = 0; i < 5; ++i) {\n            if (((top >> i) & 1) !== 0) {\n                chk ^= GENERATOR[i];\n            }\n        }\n    }\n    return chk;\n}\nfunction hrpExpand(hrp) {\n    const ret = [];\n    let p;\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) >> 5);\n    }\n    ret.push(0);\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) & 31);\n    }\n    return ret;\n}\nfunction verifyChecksum(hrp, data, enc) {\n    const combined = hrpExpand(hrp).concat(data);\n    return polymod(combined) === enc.const;\n}\nfunction createChecksum(hrp, data, enc) {\n    const values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n    const mod = polymod(values) ^ enc.const;\n    const ret = [];\n    for (let p = 0; p < 6; ++p) {\n        ret.push((mod >> 5 * (5 - p)) & 31);\n    }\n    return ret;\n}\nfunction convertBits(data, fromBits, toBits, pad = true) {\n    const ret = [];\n    let acc = 0;\n    let bits = 0;\n    const maxVal = (1 << toBits) - 1;\n    const maxAcc = (1 << (fromBits + toBits - 1)) - 1;\n    for (const val of data) {\n        if (val < 0 || (val >> fromBits) > 0) {\n            throw new Error('Failed to perform base conversion. Invalid value: ' + String(val));\n        }\n        acc = ((acc << fromBits) | val) & maxAcc;\n        bits += fromBits;\n        while (bits >= toBits) {\n            bits -= toBits;\n            ret.push((acc >> bits) & maxVal);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            ret.push((acc << (toBits - bits)) & maxVal);\n        }\n    }\n    else if (bits >= fromBits || ((acc << (toBits - bits)) & maxVal) > 0) {\n        throw new Error('Failed to perform base conversion. Invalid Size!');\n    }\n    return ret;\n}\nfunction encode$5(hrp, data, enc) {\n    const combined = data.concat(createChecksum(hrp, data, enc));\n    let ret = hrp + '1';\n    for (let p = 0; p < combined.length; ++p) {\n        ret += CHARSET.charAt(combined[p]);\n    }\n    return ret;\n}\nfunction decode$5(bechstr) {\n    if (!checkBounds(bechstr)) {\n        throw new Error('Encoded string goes out of bounds!');\n    }\n    bechstr = bechstr.toLowerCase();\n    if (!checkSeparatorPos(bechstr)) {\n        throw new Error('Encoded string has invalid separator!');\n    }\n    const data = [];\n    const pos = bechstr.lastIndexOf('1');\n    const hrp = bechstr.substring(0, pos);\n    for (let p = pos + 1; p < bechstr.length; ++p) {\n        const d = CHARSET.indexOf(bechstr.charAt(p));\n        if (d === -1) {\n            throw new Error('Character idx out of bounds: ' + String(p));\n        }\n        data.push(d);\n    }\n    const enc = ENCODINGS.find(e => e.version === data[0]) ?? ENCODINGS[0];\n    if (!verifyChecksum(hrp, data, enc)) {\n        throw new Error('Checksum verification failed!');\n    }\n    return [hrp, data.slice(0, data.length - 6)];\n}\nfunction checkBounds(bechstr) {\n    let p;\n    let char;\n    let hasLower = false;\n    let hasUpper = false;\n    for (p = 0; p < bechstr.length; ++p) {\n        char = bechstr.charCodeAt(p);\n        if (char < 33 || char > 126) {\n            return false;\n        }\n        if (char >= 97 && char <= 122) {\n            hasLower = true;\n        }\n        if (char >= 65 && char <= 90) {\n            hasUpper = true;\n        }\n    }\n    if (hasLower && hasUpper)\n        return false;\n    return true;\n}\nfunction checkSeparatorPos(bechstr) {\n    const pos = bechstr.lastIndexOf('1');\n    return !(pos < 1 ||\n        pos + 7 > bechstr.length ||\n        bechstr.length > 90);\n}\nfunction b32encode(data, hrp = 'bc', version = 0) {\n    const dat = [version, ...convertBits([...data], 8, 5)];\n    const enc = ENCODINGS.find(e => e.version === version) ?? ENCODINGS[0];\n    const str = encode$5(hrp, dat, enc);\n    b32decode(str);\n    return str;\n}\nfunction b32decode(str) {\n    str = str.toLowerCase();\n    const hrp = str.split('1', 1)[0];\n    const [hrpgot, data] = decode$5(str);\n    const decoded = convertBits(data.slice(1), 5, 8, false);\n    const length = decoded.length;\n    switch (true) {\n        case (hrp !== hrpgot):\n            throw new Error('Returned hrp string is invalid.');\n        case (decoded === null || length < 2 || length > 40):\n            throw new Error('Decoded string is invalid or out of spec.');\n        case (data[0] > 16):\n            throw new Error('Returned version bit is out of range.');\n        default:\n            return Uint8Array.from(decoded);\n    }\n}\nfunction getVersion$1(str) {\n    str = str.toLowerCase();\n    const [_, data] = decode$5(str);\n    return data[0];\n}\nconst Bech32 = {\n    encode: b32encode,\n    decode: b32decode,\n    version: getVersion$1\n};\n\nconst BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst B64URL_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\nconst ec$1 = new TextEncoder();\nfunction b64encode(input, urlSafe = false, padding = true) {\n    if (typeof input === 'string')\n        input = ec$1.encode(input);\n    const map = urlSafe ? B64URL_MAP : BASE64_MAP;\n    let output = '';\n    let bits = 0;\n    let buffer = 0;\n    for (let i = 0; i < input.length; i++) {\n        buffer = (buffer << 8) | input[i];\n        bits += 8;\n        while (bits >= 6) {\n            bits -= 6;\n            output += map[(buffer >> bits) & 0x3f];\n        }\n    }\n    if (bits > 0) {\n        buffer <<= 6 - bits;\n        output += map[buffer & 0x3f];\n        while (bits < 6) {\n            output += padding ? '=' : '';\n            bits += 2;\n        }\n    }\n    return output;\n}\nfunction b64decode(input, urlSafe = false) {\n    const map = (urlSafe || input.includes('-') || input.includes('_'))\n        ? B64URL_MAP.split('')\n        : BASE64_MAP.split('');\n    input = input.replace(/=+$/, '');\n    const chars = input.split('');\n    let bits = 0;\n    let value = 0;\n    const bytes = [];\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars[i];\n        const index = map.indexOf(c);\n        if (index === -1) {\n            throw new Error('Invalid character: ' + c);\n        }\n        bits += 6;\n        value <<= 6;\n        value |= index;\n        if (bits >= 8) {\n            bits -= 8;\n            bytes.push((value >>> bits) & 0xff);\n        }\n    }\n    return new Uint8Array(bytes);\n}\nconst Base64 = {\n    encode: b64encode,\n    decode: b64decode\n};\nconst B64URL = {\n    encode: (data) => b64encode(data, true, false),\n    decode: (data) => b64decode(data, true)\n};\n\nconst _0n$3 = BigInt(0);\nconst _255n = BigInt(255);\nconst _256n = BigInt(256);\nfunction big_size(big) {\n    if (big <= 0xffn)\n        return 1;\n    if (big <= 0xffffn)\n        return 2;\n    if (big <= 0xffffffffn)\n        return 4;\n    if (big <= 0xffffffffffffffffn)\n        return 8;\n    if (big <= 0xffffffffffffffffffffffffffffffffn)\n        return 16;\n    if (big <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) {\n        return 32;\n    }\n    throw new TypeError('Must specify a fixed buffer size for bigints greater than 32 bytes.');\n}\nfunction bigToBytes(big, size, endian = 'be') {\n    if (size === undefined)\n        size = big_size(big);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (big > _0n$3) {\n        const byte = big & _255n;\n        const num = Number(byte);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        big = (big - byte) / _256n;\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToBig(bytes) {\n    let num = BigInt(0);\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * _256n) + BigInt(bytes[i]);\n    }\n    return BigInt(num);\n}\n\nfunction binToBytes(binary) {\n    const bins = binary.split('').map(Number);\n    if (bins.length % 8 !== 0) {\n        throw new Error(`Binary array is invalid length: ${binary.length}`);\n    }\n    const bytes = new Uint8Array(bins.length / 8);\n    for (let i = 0, ct = 0; i < bins.length; i += 8, ct++) {\n        let byte = 0;\n        for (let j = 0; j < 8; j++) {\n            byte |= (bins[i + j] << (7 - j));\n        }\n        bytes[ct] = byte;\n    }\n    return bytes;\n}\nfunction bytesToBin(bytes) {\n    const bin = new Array(bytes.length * 8);\n    let count = 0;\n    for (const num of bytes) {\n        if (num > 255) {\n            throw new Error(`Invalid byte value: ${num}. Byte values must be between 0 and 255.`);\n        }\n        for (let i = 7; i >= 0; i--, count++) {\n            bin[count] = (num >> i) & 1;\n        }\n    }\n    return bin.join('');\n}\n\nfunction num_size(num) {\n    if (num <= 0xFF)\n        return 1;\n    if (num <= 0xFFFF)\n        return 2;\n    if (num <= 0xFFFFFFFF)\n        return 4;\n    throw new TypeError('Numbers larger than 4 bytes must specify a fixed size!');\n}\nfunction numToBytes(num, size, endian = 'be') {\n    if (size === undefined)\n        size = num_size(num);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (num > 0) {\n        const byte = num & 255;\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        num = (num - byte) / 256;\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToNum(bytes) {\n    let num = 0;\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * 256) + bytes[i];\n        is_safe_num(num);\n    }\n    return num;\n}\n\nconst ec = new TextEncoder();\nconst dc = new TextDecoder();\nfunction strToBytes(str) {\n    return ec.encode(str);\n}\nfunction bytesToStr(bytes) {\n    return dc.decode(bytes);\n}\nfunction hex_size(hexstr, size) {\n    is_hex(hexstr);\n    const len = hexstr.length / 2;\n    if (size === undefined)\n        size = len;\n    if (len > size) {\n        throw new TypeError(`Hex string is larger than array size: ${len} > ${size}`);\n    }\n    return size;\n}\nfunction hexToBytes(hexstr, size, endian = 'le') {\n    size = hex_size(hexstr, size);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    for (let i = 0; i < hexstr.length; i += 2) {\n        const char = hexstr.substring(i, i + 2);\n        const num = parseInt(char, 16);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n    }\n    return new Uint8Array(buffer);\n}\nfunction bytesToHex(bytes) {\n    let chars = '';\n    for (let i = 0; i < bytes.length; i++) {\n        chars += bytes[i].toString(16).padStart(2, '0');\n    }\n    return chars;\n}\nfunction jsonToBytes(obj) {\n    const str = JSON.stringify(obj, (_, v) => {\n        return typeof v === 'bigint'\n            ? `${v}n`\n            : v;\n    });\n    return strToBytes(str);\n}\n\nfunction buffer(data, size, endian) {\n    if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    if (data instanceof Uint8Array) {\n        return set_buffer(data, size, endian);\n    }\n    if (typeof data === 'string') {\n        return hexToBytes(data, size, endian);\n    }\n    if (typeof data === 'bigint') {\n        return bigToBytes(data, size, endian);\n    }\n    if (typeof data === 'number') {\n        return numToBytes(data, size, endian);\n    }\n    if (typeof data === 'boolean') {\n        return Uint8Array.of(data ? 1 : 0);\n    }\n    throw TypeError('Unsupported format:' + String(typeof data));\n}\n\nclass Buff extends Uint8Array {\n    static { this.num = numToBuff; }\n    static { this.big = bigToBuff; }\n    static { this.bin = binToBuff; }\n    static { this.raw = rawToBuff; }\n    static { this.str = strToBuff; }\n    static { this.hex = hexToBuff; }\n    static { this.bytes = bytesToBuff; }\n    static { this.json = jsonToBuff; }\n    static { this.base64 = base64ToBuff; }\n    static { this.b64url = b64urlToBuff; }\n    static { this.bech32 = bech32ToBuff; }\n    static { this.b58chk = b58chkToBuff; }\n    static { this.encode = strToBytes; }\n    static { this.decode = bytesToStr; }\n    static random(size = 32) {\n        const rand = random$1(size);\n        return new Buff(rand, size);\n    }\n    constructor(data, size, endian) {\n        const buffer$1 = buffer(data, size, endian);\n        super(buffer$1);\n    }\n    get arr() {\n        return [...this];\n    }\n    get num() {\n        return this.toNum();\n    }\n    get big() {\n        return this.toBig();\n    }\n    get str() {\n        return this.toStr();\n    }\n    get hex() {\n        return this.toHex();\n    }\n    get raw() {\n        return new Uint8Array(this);\n    }\n    get bin() {\n        return this.toBin();\n    }\n    get b58chk() {\n        return this.tob58chk();\n    }\n    get base64() {\n        return this.toBase64();\n    }\n    get b64url() {\n        return this.toB64url();\n    }\n    get digest() {\n        return this.toHash();\n    }\n    get id() {\n        return this.toHash().hex;\n    }\n    get stream() {\n        return new Stream(this);\n    }\n    toNum(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return bytesToNum(bytes);\n    }\n    toBin() {\n        return bytesToBin(this);\n    }\n    toBig(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return bytesToBig(bytes);\n    }\n    toHash() {\n        const digest = sha256$2(this);\n        return new Buff(digest);\n    }\n    toJson() {\n        const str = bytesToStr(this);\n        return JSON.parse(str);\n    }\n    toBech32(hrp, version = 0) {\n        return Bech32.encode(this, hrp, version);\n    }\n    toStr() { return bytesToStr(this); }\n    toHex() { return bytesToHex(this); }\n    toBytes() { return new Uint8Array(this); }\n    tob58chk() { return Base58C.encode(this); }\n    toBase64() { return Base64.encode(this); }\n    toB64url() { return B64URL.encode(this); }\n    prepend(data) {\n        return Buff.join([Buff.bytes(data), this]);\n    }\n    append(data) {\n        return Buff.join([this, Buff.bytes(data)]);\n    }\n    slice(start, end) {\n        const arr = new Uint8Array(this).slice(start, end);\n        return new Buff(arr);\n    }\n    subarray(begin, end) {\n        const arr = new Uint8Array(this).subarray(begin, end);\n        return new Buff(arr);\n    }\n    reverse() {\n        const arr = new Uint8Array(this).reverse();\n        return new Buff(arr);\n    }\n    write(bytes, offset) {\n        const b = Buff.bytes(bytes);\n        this.set(b, offset);\n    }\n    prefixSize(endian) {\n        const size = Buff.varInt(this.length, endian);\n        return Buff.join([size, this]);\n    }\n    static from(data) {\n        return new Buff(Uint8Array.from(data));\n    }\n    static of(...args) {\n        return new Buff(Uint8Array.of(...args));\n    }\n    static join(arr) {\n        const bytes = arr.map(e => Buff.bytes(e));\n        const joined = join_array(bytes);\n        return new Buff(joined);\n    }\n    static varInt(num, endian) {\n        if (num < 0xFD) {\n            return Buff.num(num, 1);\n        }\n        else if (num < 0x10000) {\n            return Buff.of(0xFD, ...Buff.num(num, 2, endian));\n        }\n        else if (num < 0x100000000) {\n            return Buff.of(0xFE, ...Buff.num(num, 4, endian));\n        }\n        else if (BigInt(num) < 0x10000000000000000n) {\n            return Buff.of(0xFF, ...Buff.num(num, 8, endian));\n        }\n        else {\n            throw new Error(`Value is too large: ${num}`);\n        }\n    }\n}\nfunction numToBuff(number, size, endian) {\n    return new Buff(number, size, endian);\n}\nfunction binToBuff(data, size, endian) {\n    return new Buff(binToBytes(data), size, endian);\n}\nfunction bigToBuff(bigint, size, endian) {\n    return new Buff(bigint, size, endian);\n}\nfunction rawToBuff(data, size, endian) {\n    return new Buff(data, size, endian);\n}\nfunction strToBuff(data, size, endian) {\n    return new Buff(strToBytes(data), size, endian);\n}\nfunction hexToBuff(data, size, endian) {\n    return new Buff(data, size, endian);\n}\nfunction bytesToBuff(data, size, endian) {\n    return new Buff(data, size, endian);\n}\nfunction jsonToBuff(data) {\n    return new Buff(jsonToBytes(data));\n}\nfunction base64ToBuff(data) {\n    return new Buff(Base64.decode(data));\n}\nfunction b64urlToBuff(data) {\n    return new Buff(B64URL.decode(data));\n}\nfunction bech32ToBuff(data) {\n    return new Buff(Bech32.decode(data));\n}\nfunction b58chkToBuff(data) {\n    return new Buff(Base58C.decode(data));\n}\nclass Stream {\n    constructor(data) {\n        this.data = Buff.bytes(data);\n        this.size = this.data.length;\n    }\n    peek(size) {\n        if (size > this.size) {\n            throw new Error(`Size greater than stream: ${size} > ${this.size}`);\n        }\n        return new Buff(this.data.slice(0, size));\n    }\n    read(size) {\n        size = size ?? this.readSize();\n        const chunk = this.peek(size);\n        this.data = this.data.slice(size);\n        this.size = this.data.length;\n        return chunk;\n    }\n    readSize(endian) {\n        const num = this.read(1).num;\n        switch (true) {\n            case (num >= 0 && num < 0xFD):\n                return num;\n            case (num === 0xFD):\n                return this.read(2).toNum(endian);\n            case (num === 0xFE):\n                return this.read(4).toNum(endian);\n            case (num === 0xFF):\n                return this.read(8).toNum(endian);\n            default:\n                throw new Error(`Varint is out of range: ${num}`);\n        }\n    }\n}\n\nconst curve = secp256k1.CURVE;\nconst N$1 = curve.n;\nconst P$1 = curve.p;\nconst G = { x: curve.Gx, y: curve.Gy };\nconst _0n$2 = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _4n = BigInt(4);\nconst CONST = { N: N$1, P: P$1, G, _0n: _0n$2, _1n, _2n, _3n, _4n };\nconst ecc = Field$1(N$1, 32, true);\nconst modN = (x) => mod(x, N$1);\n\nfunction fail(error, throws = false) {\n    if (throws) {\n        throw new Error(error);\n    }\n    else {\n        return false;\n    }\n}\nfunction random(size) {\n    return Buff.random(size);\n}\nfunction mod_bytes(bytes) {\n    const b = Buff.bytes(bytes).big;\n    return Buff.big(modN(b), 32);\n}\n\nvar utl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    fail: fail,\n    mod_bytes: mod_bytes,\n    random: random\n});\n\nconst { N, P, _0n: _0n$1 } = CONST;\nfunction size(input, size, throws) {\n    const bytes = Buff.bytes(input);\n    if (bytes.length !== size) {\n        return fail(`Invalid byte size: ${bytes.hex} !== ${size}`, throws);\n    }\n    return true;\n}\nfunction in_field(x, throws) {\n    if (!(typeof x === 'bigint' && _0n$1 < x && x < N)) {\n        fail('x value is not in the field!', throws);\n    }\n    return true;\n}\n\nconst NoblePoint = secp256k1.ProjectivePoint;\nclass Field extends Uint8Array {\n    static { this.N = secp256k1.CURVE.n; }\n    static mod(x) {\n        return new Field(x);\n    }\n    static is_valid(value, throws) {\n        const big = Buff.bytes(value, 32).big;\n        return in_field(big, throws);\n    }\n    constructor(x) {\n        let b = normalizeField(x);\n        b = modN(b);\n        Field.is_valid(b, true);\n        super(Buff.big(b, 32), 32);\n    }\n    get buff() {\n        return new Buff(this);\n    }\n    get raw() {\n        return this.buff.raw;\n    }\n    get big() {\n        return this.buff.big;\n    }\n    get hex() {\n        return this.buff.hex;\n    }\n    get point() {\n        return this.generate();\n    }\n    get hasOddY() {\n        return this.point.hasOddY;\n    }\n    get negated() {\n        return (this.hasOddY)\n            ? this.negate()\n            : this;\n    }\n    gt(value) {\n        const x = new Field(value);\n        return x.big > this.big;\n    }\n    lt(value) {\n        const x = new Field(value);\n        return x.big < this.big;\n    }\n    eq(value) {\n        const x = new Field(value);\n        return x.big === this.big;\n    }\n    ne(value) {\n        const x = new Field(value);\n        return x.big !== this.big;\n    }\n    add(value) {\n        const x = Field.mod(value);\n        const a = ecc.add(this.big, x.big);\n        return new Field(a);\n    }\n    sub(value) {\n        const x = Field.mod(value);\n        const a = ecc.sub(this.big, x.big);\n        return new Field(a);\n    }\n    mul(value) {\n        const x = Field.mod(value);\n        const a = ecc.mul(this.big, x.big);\n        return new Field(a);\n    }\n    pow(value) {\n        const x = Field.mod(value);\n        const a = ecc.pow(this.big, x.big);\n        return new Field(a);\n    }\n    div(value) {\n        const x = Field.mod(value);\n        const a = ecc.div(this.big, x.big);\n        return new Field(a);\n    }\n    negate() {\n        return new Field(Field.N - this.big);\n    }\n    generate() {\n        const base = secp256k1.ProjectivePoint.BASE;\n        const point = base.multiply(this.big);\n        return Point.import(point);\n    }\n}\nclass Point {\n    static { this.P = CONST.P; }\n    static { this.G = CONST.G; }\n    static { this.base = secp256k1.ProjectivePoint.BASE; }\n    static from_x(bytes) {\n        let cp = normalizePoint(bytes);\n        if (cp.length === 32) {\n            cp = cp.prepend(0x02);\n        }\n        size(cp, 33);\n        const point = NoblePoint.fromHex(cp.hex);\n        point.assertValidity();\n        return new Point(point.x, point.y);\n    }\n    static generate(value) {\n        const field = Field.mod(value);\n        const point = Point.base.multiply(field.big);\n        return Point.import(point);\n    }\n    static import(point) {\n        const p = (point instanceof Point)\n            ? { x: point.x.big, y: point.y.big }\n            : { x: point.x, y: point.y };\n        return new Point(p.x, p.y);\n    }\n    constructor(x, y) {\n        this._p = new NoblePoint(x, y, 1n);\n        this.p.assertValidity();\n    }\n    get p() {\n        return this._p;\n    }\n    get x() {\n        return Buff.big(this.p.x, 32);\n    }\n    get y() {\n        return Buff.big(this.p.y, 32);\n    }\n    get buff() {\n        return Buff.raw(this.p.toRawBytes(true));\n    }\n    get raw() {\n        return this.buff.raw;\n    }\n    get hex() {\n        return this.buff.hex;\n    }\n    get hasEvenY() {\n        return this.p.hasEvenY();\n    }\n    get hasOddY() {\n        return !this.p.hasEvenY();\n    }\n    eq(value) {\n        const p = (value instanceof Point) ? value : Point.from_x(value);\n        return this.x.big === p.x.big && this.y.big === p.y.big;\n    }\n    add(x) {\n        return (x instanceof Point)\n            ? Point.import(this.p.add(x.p))\n            : Point.import(this.p.add(Point.generate(x).p));\n    }\n    sub(x) {\n        return (x instanceof Point)\n            ? Point.import(this.p.subtract(x.p))\n            : Point.import(this.p.subtract(Point.generate(x).p));\n    }\n    mul(value) {\n        return (value instanceof Point)\n            ? Point.import(this.p.multiply(value.x.big))\n            : Point.import(this.p.multiply(Field.mod(value).big));\n    }\n    negate() {\n        return Point.import(this.p.negate());\n    }\n}\nfunction normalizeField(value) {\n    if (value instanceof Field) {\n        return value.big;\n    }\n    if (value instanceof Point) {\n        return value.x.big;\n    }\n    if (value instanceof Uint8Array) {\n        return Buff.raw(value).big;\n    }\n    if (typeof value === 'string') {\n        return Buff.hex(value).big;\n    }\n    if (typeof value === 'number') {\n        return Buff.num(value).big;\n    }\n    if (typeof value === 'bigint') {\n        return BigInt(value);\n    }\n    throw TypeError('Invalid input type:' + typeof value);\n}\nfunction normalizePoint(value) {\n    if (value instanceof Field) {\n        return value.point.buff;\n    }\n    if (value instanceof Point) {\n        return value.buff;\n    }\n    if (value instanceof Uint8Array ||\n        typeof value === 'string') {\n        return Buff.bytes(value);\n    }\n    if (typeof value === 'number' ||\n        typeof value === 'bigint') {\n        return Buff.bytes(value, 32);\n    }\n    throw new TypeError(`Unknown type: ${typeof value}`);\n}\n\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash$1(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash: hash$1,\n    exists,\n    output,\n};\nvar assert$1 = assert;\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nArray.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes$3(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes$3(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        assert$1.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes$3(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        assert$1.exists(this);\n        assert$1.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256$1 = wrapConstructor(() => new SHA256());\nwrapConstructor(() => new SHA224());\n\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l) => l;\nconst rotr32L = (h, l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nvar u64$1 = u64;\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = u64$1.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n)));\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nclass SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64$1.rotrSH(W15h, W15l, 1) ^ u64$1.rotrSH(W15h, W15l, 8) ^ u64$1.shrSH(W15h, W15l, 7);\n            const s0l = u64$1.rotrSL(W15h, W15l, 1) ^ u64$1.rotrSL(W15h, W15l, 8) ^ u64$1.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64$1.rotrSH(W2h, W2l, 19) ^ u64$1.rotrBH(W2h, W2l, 61) ^ u64$1.shrSH(W2h, W2l, 6);\n            const s1l = u64$1.rotrSL(W2h, W2l, 19) ^ u64$1.rotrBL(W2h, W2l, 61) ^ u64$1.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64$1.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64$1.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64$1.rotrSH(Eh, El, 14) ^ u64$1.rotrSH(Eh, El, 18) ^ u64$1.rotrBH(Eh, El, 41);\n            const sigma1l = u64$1.rotrSL(Eh, El, 14) ^ u64$1.rotrSL(Eh, El, 18) ^ u64$1.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64$1.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64$1.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64$1.rotrSH(Ah, Al, 28) ^ u64$1.rotrBH(Ah, Al, 34) ^ u64$1.rotrBH(Ah, Al, 39);\n            const sigma0l = u64$1.rotrSL(Ah, Al, 28) ^ u64$1.rotrBL(Ah, Al, 34) ^ u64$1.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64$1.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64$1.add3L(T1l, sigma0l, MAJl);\n            Ah = u64$1.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64$1.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64$1.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64$1.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64$1.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64$1.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64$1.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64$1.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64$1.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512$1 = wrapConstructor(() => new SHA512());\nwrapConstructor(() => new SHA512_224());\nwrapConstructor(() => new SHA512_256());\nwrapConstructor(() => new SHA384());\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\nconst Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = new Uint32Array(16);\nclass RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nconst ripemd160 = wrapConstructor(() => new RIPEMD160());\n\n// HMAC (RFC 2104)\nclass HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assert$1.hash(hash);\n        const key = toBytes$3(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assert$1.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assert$1.exists(this);\n        assert$1.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac$1 = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac$1.create = (hash, key) => new HMAC(hash, key);\n\nfunction sha256(msg) {\n    const b = Buff.bytes(msg);\n    return Buff.raw(sha256$1(b));\n}\nfunction hash256(msg) {\n    const b = Buff.bytes(msg);\n    return Buff.raw(sha256$1(sha256$1(b)));\n}\nfunction hash160(msg) {\n    const b = Buff.bytes(msg);\n    return Buff.raw(ripemd160(sha256$1(b)));\n}\nfunction hmac512(key, msg) {\n    const k = Buff.bytes(key);\n    const b = Buff.bytes(msg);\n    return Buff.raw(hmac$1(sha512$1, k, b));\n}\nfunction hashtag(tag) {\n    const hash = Buff.str(tag).digest;\n    return Buff.join([hash, hash]);\n}\n\nfunction genSecretKey(size = 32) {\n    return getSecretKey(random(size));\n}\nfunction getSecretKey(secret) {\n    return Field.mod(secret).buff;\n}\nfunction getPublicKey(seckey, xonly = false) {\n    const p = Field.mod(seckey).point;\n    return (xonly) ? p.x : p.buff;\n}\nfunction getSharedKey(seckey, pubkey) {\n    const P = Point.from_x(pubkey);\n    const sp = Field.mod(seckey);\n    const sh = P.mul(sp);\n    return sh.buff;\n}\nfunction getSharedCode(self_sec, peer_pub, tag = 'ecdh/code') {\n    const hash = hashtag(tag);\n    const sec = getSecretKey(self_sec);\n    const pub = getPublicKey(sec);\n    const peer = Buff.bytes(peer_pub);\n    const link = getSharedKey(sec, peer);\n    const keys = [pub.hex, peer.hex];\n    keys.sort();\n    return hmac512(link, Buff.join([hash, ...keys]));\n}\nfunction is_even_pub(pubkey) {\n    const pub = Buff.bytes(pubkey);\n    switch (true) {\n        case (pub.length === 32):\n            return true;\n        case (pub.length === 33 && pub[0] === 0x02):\n            return true;\n        case (pub.length === 33 && pub[0] === 0x03):\n            return false;\n        default:\n            throw new TypeError(`Invalid public key: ${pub.hex}`);\n    }\n}\nfunction xonly_pub(pubkey) {\n    const key = Buff.bytes(pubkey);\n    switch (key.length) {\n        case 32:\n            return key;\n        case 33:\n            return key.slice(1, 33);\n        default:\n            throw new Error(`Invalid key length: ${key.length}`);\n    }\n}\n\nvar key = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    genSecretKey: genSecretKey,\n    getPublicKey: getPublicKey,\n    getSecretKey: getSecretKey,\n    getSharedCode: getSharedCode,\n    getSharedKey: getSharedKey,\n    is_even_pub: is_even_pub,\n    xonly_pub: xonly_pub\n});\n\n({\n    aux: Buff.random(32),\n    throws: false,\n    xonly: true\n});\n\nconst noble = { secp: secp256k1, schnorr };\nconst util$1 = { ...key, ...utl };\n\nfunction hash160pkh(pubkey) {\n    const bytes = Buff$1.bytes(pubkey);\n    checkSize(bytes, 33);\n    return hash160(bytes);\n}\nfunction hash160sh(script) {\n    const bytes = Script.fmt.toBytes(script, false);\n    return hash160(bytes);\n}\nfunction sha256sh(script) {\n    const bytes = Script.fmt.toBytes(script, false);\n    return sha256(bytes);\n}\n\nfunction check$4(address, network = 'main') {\n    const prefixes = (network === 'main') ? ['1'] : ['m', 'n'];\n    for (const prefix of prefixes) {\n        if (address.startsWith(prefix)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction encode$4(input, network = 'main') {\n    const bytes = Buff$1.bytes(input);\n    const prefix = (network === 'main') ? Buff$1.num(0x00) : Buff$1.num(0x6F);\n    checkSize(input, 20);\n    return bytes.prepend(prefix).tob58chk();\n}\nfunction decode$4(address, network = 'main') {\n    if (!check$4(address, network)) {\n        throw new TypeError('Invalid p2pkh address!');\n    }\n    return Buff$1.b58chk(address).slice(1);\n}\nfunction scriptPubKey$4(input) {\n    const bytes = Buff$1.bytes(input);\n    checkSize(bytes, 20);\n    return ['OP_DUP', 'OP_HASH160', bytes.hex, 'OP_EQUALVERIFY', 'OP_CHECKSIG'];\n}\nfunction fromPubKey$2(pubkey, network) {\n    const pkh = hash160pkh(pubkey);\n    return encode$4(pkh, network);\n}\nconst P2PKH = { check: check$4, encode: encode$4, decode: decode$4, hash: hash160pkh, scriptPubKey: scriptPubKey$4, fromPubKey: fromPubKey$2 };\n\nfunction check$3(address, network = 'main') {\n    const prefixes = (network === 'main') ? ['3'] : ['2'];\n    for (const prefix of prefixes) {\n        if (address.startsWith(prefix)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction encode$3(input, network = 'main') {\n    const prefix = (network === 'main') ? Buff$1.num(0x05) : Buff$1.num(0xC4);\n    const bytes = Buff$1.bytes(input);\n    checkSize(bytes, 20);\n    return bytes.prepend(prefix).tob58chk();\n}\nfunction decode$3(address, network = 'main') {\n    if (!check$3(address, network)) {\n        throw new TypeError(`Invalid p2sh address for network ${network}:` + address);\n    }\n    return Buff$1.b58chk(address).slice(1);\n}\nfunction scriptPubKey$3(input) {\n    const bytes = Buff$1.bytes(input);\n    return ['OP_HASH160', bytes.hex, 'OP_EQUAL'];\n}\nfunction fromScript$1(script, network) {\n    const scriptHash = hash160sh(script);\n    return encode$3(scriptHash, network);\n}\nconst P2SH = { check: check$3, encode: encode$3, decode: decode$3, hash: hash160sh, scriptPubKey: scriptPubKey$3, fromScript: fromScript$1 };\n\nconst BECH32_PREFIXES = {\n    main: 'bc',\n    testnet: 'tb',\n    signet: 'tb',\n    regtest: 'bcrt'\n};\n\nconst VALID_PREFIXES$2 = ['bc1q', 'tb1q', 'bcrt1q'];\nfunction check$2(address) {\n    for (const prefix of VALID_PREFIXES$2) {\n        if (address.startsWith(prefix)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction encode$2(input, network = 'main') {\n    const prefix = BECH32_PREFIXES[network];\n    const bytes = Buff$1.bytes(input);\n    checkSize(bytes, 20);\n    return bytes.toBech32(prefix, 0);\n}\nfunction decode$2(address) {\n    if (!check$2(address)) {\n        throw new TypeError('Invalid segwit address!');\n    }\n    return Buff$1.bech32(address);\n}\nfunction scriptPubKey$2(input) {\n    const bytes = Buff$1.bytes(input);\n    checkSize(bytes, 20);\n    return ['OP_0', bytes.hex];\n}\nfunction fromPubKey$1(pubkey, network) {\n    const pkh = hash160pkh(pubkey);\n    return encode$2(pkh, network);\n}\nconst P2WPKH = { check: check$2, encode: encode$2, decode: decode$2, hash: hash160pkh, scriptPubKey: scriptPubKey$2, fromPubKey: fromPubKey$1 };\n\nconst VALID_PREFIXES$1 = ['bc1q', 'tb1q', 'bcrt1q'];\nfunction check$1(address) {\n    for (const prefix of VALID_PREFIXES$1) {\n        if (address.startsWith(prefix)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction encode$1(input, network = 'main') {\n    const prefix = BECH32_PREFIXES[network];\n    const bytes = Buff$1.bytes(input);\n    checkSize(bytes, 32);\n    return bytes.toBech32(prefix, 0);\n}\nfunction decode$1(address) {\n    if (!check$1(address)) {\n        throw new TypeError('Invalid segwit address!');\n    }\n    return Buff$1.bech32(address);\n}\nfunction scriptPubKey$1(input) {\n    const bytes = Buff$1.bytes(input);\n    checkSize(bytes, 32);\n    return ['OP_0', bytes.hex];\n}\nfunction fromScript(script, network) {\n    const sh = sha256sh(script);\n    return encode$1(sh, network);\n}\nconst P2WSH = { check: check$1, encode: encode$1, decode: decode$1, hash: sha256sh, scriptPubKey: scriptPubKey$1, fromScript };\n\nfunction xOnlyPub(key) {\n    const bytes = Buff$1.bytes(key);\n    return (bytes.length > 32) ? bytes.slice(1, 33) : bytes;\n}\n\nconst VALID_PREFIXES = ['bc1p', 'tb1p', 'bcrt1p'];\nfunction check(address) {\n    for (const prefix of VALID_PREFIXES) {\n        if (address.startsWith(prefix)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction encode(input, network = 'main') {\n    const prefix = BECH32_PREFIXES[network];\n    const bytes = Buff$1.bytes(input);\n    checkSize(bytes, 32);\n    return bytes.toBech32(prefix, 1);\n}\nfunction decode(address) {\n    if (!check(address)) {\n        throw new TypeError('Invalid taproot address!');\n    }\n    return Buff$1.bech32(address);\n}\nfunction scriptPubKey(input) {\n    const bytes = Buff$1.bytes(input);\n    checkSize(bytes, 32);\n    return ['OP_1', bytes.hex];\n}\nfunction fromPubKey(pubkey, network) {\n    const bytes = xOnlyPub(pubkey);\n    return encode(bytes, network);\n}\nconst P2TR = { check, encode, decode, scriptPubKey, fromPubKey };\n\nconst DEFAULT_TX = {\n    version: 2,\n    vin: [],\n    vout: [],\n    locktime: 0\n};\nconst DEFAULT_VIN = {\n    scriptSig: [],\n    sequence: 4294967293,\n    witness: []\n};\nconst DEFAULT_VOUT = {\n    value: 0n,\n    scriptPubKey: []\n};\nfunction createTx(template) {\n    const tx = { ...DEFAULT_TX, ...template };\n    tx.vin = tx.vin.map(txin => { return { ...DEFAULT_VIN, ...txin }; });\n    tx.vout = tx.vout.map(txout => { return { ...DEFAULT_VOUT, ...txout }; });\n    return tx;\n}\n\nfunction encodeTx(txdata, omitWitness) {\n    const { version, vin, vout, locktime } = createTx(txdata);\n    const useWitness = (omitWitness !== true && checkForWitness(vin));\n    const raw = [encodeVersion(version)];\n    if (useWitness) {\n        raw.push(Buff$1.hex('0001'));\n    }\n    raw.push(encodeInputs(vin));\n    raw.push(encodeOutputs(vout));\n    for (const txin of vin) {\n        if (useWitness) {\n            raw.push(encodeWitness(txin.witness));\n        }\n    }\n    raw.push(encodeLocktime(locktime));\n    return Buff$1.join(raw);\n}\nfunction checkForWitness(vin) {\n    for (const txin of vin) {\n        const { witness } = txin;\n        if (typeof witness === 'string' ||\n            witness instanceof Uint8Array ||\n            (Array.isArray(witness) && witness.length > 0)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction encodeVersion(num) {\n    return Buff$1.num(num, 4).reverse();\n}\nfunction encodeTxid(txid) {\n    return Buff$1.hex(txid, 32).reverse();\n}\nfunction encodePrevOut(vout) {\n    return Buff$1.num(vout, 4).reverse();\n}\nfunction encodeSequence(sequence) {\n    if (typeof sequence === 'string') {\n        return Buff$1.hex(sequence, 4).reverse();\n    }\n    if (typeof sequence === 'number') {\n        return Buff$1.num(sequence, 4).reverse();\n    }\n    throw new Error('Unrecognized format: ' + String(sequence));\n}\nfunction encodeInputs(arr) {\n    const raw = [Buff$1.varInt(arr.length, 'le')];\n    for (const vin of arr) {\n        const { txid, vout, scriptSig, sequence } = vin;\n        raw.push(encodeTxid(txid));\n        raw.push(encodePrevOut(vout));\n        raw.push(encodeScript(scriptSig, true));\n        raw.push(encodeSequence(sequence));\n    }\n    return Buff$1.join(raw);\n}\nfunction encodeValue(value) {\n    if (typeof value === 'number') {\n        if (value % 1 !== 0) {\n            throw new Error('Value must be an integer:' + String(value));\n        }\n        return Buff$1.num(value, 8).reverse();\n    }\n    return Buff$1.big(value, 8).reverse();\n}\nfunction encodeOutputs(arr) {\n    const raw = [Buff$1.varInt(arr.length, 'le')];\n    for (const vout of arr) {\n        raw.push(encodeOutput(vout));\n    }\n    return Buff$1.join(raw);\n}\nfunction encodeOutput(vout) {\n    const { value, scriptPubKey } = vout;\n    const raw = [];\n    raw.push(encodeValue(value));\n    raw.push(encodeScript(scriptPubKey, true));\n    return Buff$1.join(raw);\n}\nfunction encodeWitness(data = []) {\n    const buffer = [];\n    if (Array.isArray(data)) {\n        const count = Buff$1.varInt(data.length);\n        buffer.push(count);\n        for (const entry of data) {\n            buffer.push(encodeData(entry));\n        }\n        return Buff$1.join(buffer);\n    }\n    else {\n        return Buff$1.bytes(data);\n    }\n}\nfunction encodeData(data) {\n    return (!isEmpty(data))\n        ? encodeScript(data, true)\n        : new Buff$1(0);\n}\nfunction isEmpty(data) {\n    if (Array.isArray(data)) {\n        return data.length === 0;\n    }\n    if (typeof data === 'string') {\n        if (data === '')\n            return true;\n    }\n    const bytes = Buff$1.bytes(data);\n    return bytes.length === 1 && bytes[0] === 0;\n}\nfunction encodeLocktime(locktime) {\n    if (typeof locktime === 'string') {\n        return Buff$1.hex(locktime, 4);\n    }\n    if (typeof locktime === 'number') {\n        return Buff$1.num(locktime, 4).reverse();\n    }\n    throw new Error('Unrecognized format: ' + String(locktime));\n}\n\nfunction decodeTx(bytes) {\n    if (typeof bytes === 'string') {\n        bytes = Buff$1.hex(bytes).raw;\n    }\n    const stream = new Stream$1(bytes);\n    const version = readVersion(stream);\n    const hasWitness = checkWitnessFlag(stream);\n    const vin = readInputs(stream);\n    const vout = readOutputs(stream);\n    if (hasWitness) {\n        for (const txin of vin) {\n            txin.witness = readWitness$1(stream);\n        }\n    }\n    const locktime = readLocktime(stream);\n    return { version, vin, vout, locktime };\n}\nfunction readVersion(stream) {\n    return stream.read(4).reverse().toNum();\n}\nfunction checkWitnessFlag(stream) {\n    const [marker, flag] = [...stream.peek(2)];\n    if (marker === 0) {\n        stream.read(2);\n        if (flag === 1) {\n            return true;\n        }\n        else {\n            throw new Error(`Invalid witness flag: ${flag}`);\n        }\n    }\n    return false;\n}\nfunction readInputs(stream) {\n    const inputs = [];\n    const vinCount = stream.readSize('le');\n    for (let i = 0; i < vinCount; i++) {\n        inputs.push(readInput(stream));\n    }\n    return inputs;\n}\nfunction readInput(stream) {\n    const txin = {\n        txid: stream.read(32).reverse().toHex(),\n        vout: stream.read(4).reverse().toNum(),\n        scriptSig: readScript(stream, true),\n        sequence: stream.read(4).reverse().toHex(),\n        witness: []\n    };\n    return txin;\n}\nfunction readOutputs(stream) {\n    const outputs = [];\n    const outcount = stream.readSize('le');\n    for (let i = 0; i < outcount; i++) {\n        outputs.push(readOutput(stream));\n    }\n    return outputs;\n}\nfunction readOutput(stream) {\n    const txout = {\n        value: stream.read(8).reverse().big,\n        scriptPubKey: readScript(stream, true)\n    };\n    return txout;\n}\nfunction readWitness$1(stream) {\n    const stack = [];\n    const count = stream.readSize();\n    for (let i = 0; i < count; i++) {\n        const word = readData(stream, true);\n        stack.push(word ?? '');\n    }\n    return stack;\n}\nfunction readData(stream, varint) {\n    const size = (varint === true)\n        ? stream.readSize('le')\n        : stream.size;\n    return size > 0\n        ? stream.read(size).hex\n        : null;\n}\nfunction readScript(stream, varint) {\n    const data = readData(stream, varint);\n    return (data !== null) ? data : [];\n}\nfunction readLocktime(stream) {\n    return stream.read(4).reverse().toNum();\n}\n\nfunction toJson(txdata) {\n    if (isBytes$1(txdata)) {\n        return decodeTx(txdata);\n    }\n    if (typeof txdata === 'object' &&\n        !(txdata instanceof Uint8Array)) {\n        encodeTx(txdata);\n        return createTx(txdata);\n    }\n    throw new Error('Invalid format: ' + String(typeof txdata));\n}\nfunction toBytes(txdata) {\n    if (isBytes$1(txdata)) {\n        decodeTx(txdata);\n        return Buff$1.bytes(txdata);\n    }\n    if (typeof txdata === 'object') {\n        return encodeTx(txdata);\n    }\n    throw new Error('Invalid format: ' + String(typeof txdata));\n}\nconst TxFmt = {\n    toBytes,\n    toJson\n};\n\nconst OUTPUT_TYPES = [\n    ['p2pkh', /^76a914(?<hash>\\w{40})88ac$/],\n    ['p2sh', /^a914(?<hash>\\w{40})87$/],\n    ['p2w-pkh', /^0014(?<hash>\\w{40})$/],\n    ['p2w-sh', /^0020(?<hash>\\w{64})$/],\n    ['p2tr', /^5120(?<hash>\\w{64})$/]\n];\nconst LEAF_VERSIONS = [\n    0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce,\n    0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,\n    0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee,\n    0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,\n    0x66, 0x7e, 0x80, 0x84, 0x96, 0x98, 0xba, 0xbc,\n    0xbe\n];\nfunction parseAnnex(data) {\n    let item = data.at(-1);\n    if (isHex(item)) {\n        item = Buff$1.hex(item);\n    }\n    if (data.length > 1 &&\n        item instanceof Uint8Array &&\n        item[0] === 0x50) {\n        data.pop();\n        return Buff$1.raw(item);\n    }\n    return null;\n}\nfunction parseBlock(data) {\n    let item = data.at(-1);\n    if (isHex(item)) {\n        item = Buff$1.hex(item);\n    }\n    if (data.length > 1 &&\n        item instanceof Uint8Array &&\n        item.length > 32 &&\n        LEAF_VERSIONS.includes(item[0] & 0xfe)) {\n        data.pop();\n        return Buff$1.raw(item);\n    }\n    return null;\n}\nfunction parseWitScript(data) {\n    if (data.length > 1) {\n        const item = data.at(-1);\n        try {\n            const script = Script.fmt.toBytes(item);\n            data.pop();\n            return script;\n        }\n        catch (err) {\n            return null;\n        }\n    }\n    return null;\n}\nfunction parseParams(data) {\n    const params = [];\n    for (const d of data) {\n        if (isHex(d) ||\n            d instanceof Uint8Array ||\n            typeof d === 'number') {\n            params.push(Buff$1.bytes(d));\n        }\n        else {\n            throw new Error('unrecognized value: ' + String(d));\n        }\n    }\n    return params;\n}\nfunction readWitness(data = []) {\n    const items = [...data];\n    const annex = parseAnnex(items);\n    const cblock = parseBlock(items);\n    const script = parseWitScript(items);\n    const params = parseParams(items);\n    return { annex, cblock, script, params };\n}\nfunction readScriptPubKey(script) {\n    const hex = Script.fmt.toBytes(script, false).hex;\n    for (const [keytype, pattern] of OUTPUT_TYPES) {\n        const type = keytype;\n        const { groups } = pattern.exec(hex) ?? {};\n        const { hash } = groups ?? {};\n        if (isHex(hash)) {\n            return { type, data: Buff$1.hex(hash) };\n        }\n    }\n    return { type: 'raw', data: Buff$1.hex(hex) };\n}\nfunction getTxid(txdata) {\n    const json = TxFmt.toJson(txdata);\n    const data = encodeTx(json, true);\n    return hash256(data).reverse().hex;\n}\nfunction getTxSize(txdata) {\n    const json = TxFmt.toJson(txdata);\n    const bsize = encodeTx(json, true).length;\n    const fsize = encodeTx(json, false).length;\n    const weight = bsize * 3 + fsize;\n    const remain = (weight % 4 > 0) ? 1 : 0;\n    const vsize = Math.floor(weight / 4) + remain;\n    return { size: fsize, bsize, vsize, weight };\n}\n\nconst Tx = {\n    create: createTx,\n    encode: encodeTx,\n    decode: decodeTx,\n    fmt: TxFmt,\n    util: {\n        getTxSize,\n        getTxid,\n        readScriptPubKey,\n        readWitness\n    }\n};\n\nconst ADDRESS_TYPES = [\n    ['1', 'p2pkh', 'main', 20, 'base58'],\n    ['3', 'p2sh', 'main', 20, 'base58'],\n    ['m', 'p2pkh', 'testnet', 20, 'base58'],\n    ['n', 'p2pkh', 'testnet', 20, 'base58'],\n    ['2', 'p2sh', 'testnet', 20, 'base58'],\n    ['bc1q', 'p2w-pkh', 'main', 20, 'bech32'],\n    ['tb1q', 'p2w-pkh', 'testnet', 20, 'bech32'],\n    ['bcrt1q', 'p2w-pkh', 'regtest', 20, 'bech32'],\n    ['bc1q', 'p2w-sh', 'main', 32, 'bech32'],\n    ['tb1q', 'p2w-sh', 'testnet', 32, 'bech32'],\n    ['bcrt1q', 'p2w-sh', 'regtest', 32, 'bech32'],\n    ['bc1p', 'p2tr', 'main', 32, 'bech32m'],\n    ['tb1p', 'p2tr', 'testnet', 32, 'bech32m'],\n    ['bcrt1p', 'p2tr', 'regtest', 32, 'bech32m']\n];\nfunction decodeFormat(address, format) {\n    switch (format) {\n        case 'base58': return Buff$1.b58chk(address).slice(1);\n        case 'bech32': return Buff$1.bech32(address);\n        case 'bech32m': return Buff$1.bech32(address);\n        default: throw new Error('Invalid address format: ' + format);\n    }\n}\nfunction getData(address) {\n    for (const row of ADDRESS_TYPES) {\n        const [prefix, _type, _network, size, format] = row;\n        if (address.startsWith(prefix)) {\n            const bytes = decodeFormat(address, format);\n            if (bytes.length === size)\n                return row;\n        }\n    }\n    throw new Error('Invalid address: ' + address);\n}\nfunction getTool(type) {\n    switch (type) {\n        case 'p2pkh': return P2PKH;\n        case 'p2sh': return P2SH;\n        case 'p2w-pkh': return P2WPKH;\n        case 'p2w-sh': return P2WSH;\n        case 'p2tr': return P2TR;\n        default: throw new Error('Invalid address type: ' + type);\n    }\n}\nfunction decodeAddress(address) {\n    const [prefix, type, network] = getData(address);\n    const tool = getTool(type);\n    const data = tool.decode(address, network);\n    const script = tool.scriptPubKey(data);\n    return { prefix, type, network, data, script };\n}\nfunction fromScriptPubKey(script, network) {\n    const { type, data } = Tx.util.readScriptPubKey(script);\n    const tool = getTool(type);\n    return tool.encode(data, network);\n}\nfunction toScriptPubKey(address) {\n    const { script } = decodeAddress(address);\n    return Script.fmt.toAsm(script, false);\n}\n\nconst Address = {\n    p2pkh: P2PKH,\n    p2sh: P2SH,\n    p2wpkh: P2WPKH,\n    p2wsh: P2WSH,\n    p2tr: P2TR,\n    decode: decodeAddress,\n    fromScriptPubKey,\n    toScriptPubKey\n};\n\nconst VALID_HASH_TYPES$1 = [0x01, 0x02, 0x03];\nfunction hashTx$1(txdata, idx, config = {}) {\n    const { sigflag = 0x01 } = config;\n    const isAnypay = (sigflag & 0x80) === 0x80;\n    const flag = sigflag % 0x80;\n    if (!VALID_HASH_TYPES$1.includes(flag)) {\n        throw new Error('Invalid hash type: ' + String(sigflag));\n    }\n    const tx = Tx.fmt.toJson(txdata);\n    const { version, vin, vout, locktime } = tx;\n    const { txid, vout: prevIdx, prevout, sequence } = vin[idx];\n    const { value } = prevout ?? {};\n    if (value === undefined) {\n        throw new Error('Prevout value is empty!');\n    }\n    let script = config.script;\n    if (script === undefined &&\n        config.pubkey !== undefined) {\n        const pkhash = hash160(config.pubkey);\n        script = `76a914${pkhash.hex}88ac`;\n    }\n    if (script === undefined) {\n        throw new Error('No pubkey / script has been set!');\n    }\n    if (Script.fmt.toAsm(script).includes('OP_CODESEPARATOR')) {\n        throw new Error('This library does not currently support the use of OP_CODESEPARATOR in segwit scripts.');\n    }\n    const sighash = [\n        encodeVersion(version),\n        hashPrevouts(vin, isAnypay),\n        hashSequence$1(vin, flag, isAnypay),\n        encodeTxid(txid),\n        encodePrevOut(prevIdx),\n        Script.encode(script, true),\n        encodeValue(value),\n        encodeSequence(sequence),\n        hashOutputs$1(vout, idx, flag),\n        encodeLocktime(locktime),\n        Buff$1.num(sigflag, 4).reverse()\n    ];\n    return hash256(Buff$1.join(sighash));\n}\nfunction hashPrevouts(vin, isAnypay) {\n    if (isAnypay === true) {\n        return Buff$1.num(0, 32);\n    }\n    const stack = [];\n    for (const { txid, vout } of vin) {\n        stack.push(encodeTxid(txid));\n        stack.push(encodePrevOut(vout));\n    }\n    return hash256(Buff$1.join(stack));\n}\nfunction hashSequence$1(vin, sigflag, isAnyPay) {\n    if (isAnyPay || sigflag !== 0x01) {\n        return Buff$1.num(0, 32);\n    }\n    const stack = [];\n    for (const { sequence } of vin) {\n        stack.push(encodeSequence(sequence));\n    }\n    return hash256(Buff$1.join(stack));\n}\nfunction hashOutputs$1(vout, idx, sigflag) {\n    const stack = [];\n    if (sigflag === 0x01) {\n        for (const { value, scriptPubKey } of vout) {\n            stack.push(encodeValue(value));\n            stack.push(Script.encode(scriptPubKey, true));\n        }\n        return hash256(Buff$1.join(stack));\n    }\n    if (sigflag === 0x03 && idx < vout.length) {\n        const { value, scriptPubKey } = vout[idx];\n        stack.push(encodeValue(value));\n        stack.push(Script.encode(scriptPubKey, true));\n        return hash256(Buff$1.join(stack));\n    }\n    return Buff$1.num(0, 32);\n}\n\nfunction signTx$1(seckey, txdata, index, config = {}) {\n    const { sigflag = 0x01 } = config;\n    const hash = hashTx$1(txdata, index, config);\n    const sig = noble.secp.sign(hash, seckey).toDERRawBytes(true);\n    return Buff$1.join([sig, sigflag]);\n}\n\nfunction verifyTx$1(txdata, index, config = {}) {\n    const tx = Tx.fmt.toJson(txdata);\n    const { throws = false } = config;\n    const { witness = [] } = tx.vin[index];\n    const witnessData = Tx.util.readWitness(witness);\n    const { script, params } = witnessData;\n    let pub = null;\n    if (params.length < 1) {\n        return safeThrow('Invalid witness data: ' + String(witness), throws);\n    }\n    if (config.script === undefined &&\n        script !== null) {\n        config.script = script;\n    }\n    if (config.pubkey !== undefined) {\n        pub = Buff$1.bytes(config.pubkey);\n    }\n    else if (params.length > 1 &&\n        params[1].length === 33) {\n        pub = Buff$1.bytes(params[1]);\n    }\n    else {\n        return safeThrow('No pubkey provided!', throws);\n    }\n    const rawsig = Script.fmt.toParam(params[0]);\n    const signature = rawsig.slice(0, -1);\n    const sigflag = rawsig.slice(-1)[0];\n    const hash = hashTx$1(tx, index, { ...config, sigflag });\n    if (!noble.secp.verify(signature, hash, pub)) {\n        return safeThrow('Invalid signature!', throws);\n    }\n    return true;\n}\n\nconst SWSigner = {\n    hash: hashTx$1,\n    sign: signTx$1,\n    verify: verifyTx$1\n};\n\nconst VALID_HASH_TYPES = [0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83];\nfunction hashTx(template, index, config = {}) {\n    const { extension, sigflag = 0x00, extflag = 0x00, key_version = 0x00, separator_pos = 0xFFFFFFFF } = config;\n    const txdata = Tx.fmt.toJson(template);\n    const { version, vin: input, vout: output, locktime } = txdata;\n    if (index >= input.length) {\n        throw new Error('Index out of bounds: ' + String(index));\n    }\n    if (!VALID_HASH_TYPES.includes(sigflag)) {\n        throw new Error('Invalid hash type: ' + String(sigflag));\n    }\n    if (extflag < 0 || extflag > 127) {\n        throw new Error('Extention flag out of range: ' + String(extflag));\n    }\n    const { txid, vout, sequence, witness = [] } = input[index];\n    const isAnyPay = (sigflag & 0x80) === 0x80;\n    const annex = getAnnexData(witness);\n    const annexBit = (annex !== undefined) ? 1 : 0;\n    const extendBit = (extension !== undefined) ? 1 : 0;\n    const spendType = ((extflag + extendBit) * 2) + annexBit;\n    const hashtag = Buff$1.str('TapSighash').digest;\n    const preimage = [\n        hashtag,\n        hashtag,\n        Buff$1.num(0x00, 1),\n        Buff$1.num(sigflag, 1),\n        encodeVersion(version),\n        encodeLocktime(locktime)\n    ];\n    if (!isAnyPay) {\n        const prevouts = input.map(e => getPrevout(e));\n        preimage.push(hashOutpoints(input), hashAmounts(prevouts), hashScripts(prevouts), hashSequence(input));\n    }\n    if ((sigflag & 0x03) < 2 || (sigflag & 0x03) > 3) {\n        preimage.push(hashOutputs(output));\n    }\n    preimage.push(Buff$1.num(spendType, 1));\n    if (isAnyPay) {\n        const { value, scriptPubKey } = getPrevout(input[index]);\n        preimage.push(encodeTxid(txid), encodePrevOut(vout), encodeValue(value), Script.encode(scriptPubKey, true), encodeSequence(sequence));\n    }\n    else {\n        preimage.push(Buff$1.num(index, 4).reverse());\n    }\n    if (annex !== undefined) {\n        preimage.push(annex);\n    }\n    if ((sigflag & 0x03) === 0x03) {\n        preimage.push(hashOutput(output[index]));\n    }\n    if (extension !== undefined) {\n        preimage.push(Buff$1.bytes(extension), Buff$1.num(key_version), Buff$1.num(separator_pos, 4, 'le'));\n    }\n    return Buff$1.join(preimage).digest;\n}\nfunction hashOutpoints(vin) {\n    const stack = [];\n    for (const { txid, vout } of vin) {\n        stack.push(encodeTxid(txid));\n        stack.push(encodePrevOut(vout));\n    }\n    return Buff$1.join(stack).digest;\n}\nfunction hashSequence(vin) {\n    const stack = [];\n    for (const { sequence } of vin) {\n        stack.push(encodeSequence(sequence));\n    }\n    return Buff$1.join(stack).digest;\n}\nfunction hashAmounts(prevouts) {\n    const stack = [];\n    for (const { value } of prevouts) {\n        stack.push(encodeValue(value));\n    }\n    return Buff$1.join(stack).digest;\n}\nfunction hashScripts(prevouts) {\n    const stack = [];\n    for (const { scriptPubKey } of prevouts) {\n        stack.push(encodeScript(scriptPubKey, true));\n    }\n    return Buff$1.join(stack).digest;\n}\nfunction hashOutputs(vout) {\n    const stack = [];\n    for (const { value, scriptPubKey } of vout) {\n        stack.push(encodeValue(value));\n        stack.push(Script.encode(scriptPubKey, true));\n    }\n    return Buff$1.join(stack).digest;\n}\nfunction hashOutput(vout) {\n    return Buff$1.join([\n        encodeValue(vout.value),\n        Script.encode(vout.scriptPubKey, true)\n    ]).digest;\n}\nfunction getAnnexData(witness) {\n    if (witness === undefined)\n        return;\n    if (witness.length < 2)\n        return;\n    let annex = witness.at(-1);\n    if (typeof annex === 'string') {\n        annex = Buff$1.hex(annex);\n    }\n    if (annex instanceof Uint8Array &&\n        annex[0] === 0x50) {\n        return Buff$1.raw(annex).prefixSize('be').digest;\n    }\n    return undefined;\n}\nfunction getPrevout(vin) {\n    if (vin.prevout === undefined) {\n        throw new Error('Prevout data missing for input: ' + String(vin.txid));\n    }\n    return vin.prevout;\n}\n\nconst FIELD_SIZE = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;\nconst CURVE_ORDER = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;\nfunction signTx(seckey, txdata, index, config = {}) {\n    const { sigflag = 0x00 } = config;\n    const hash = hashTx(txdata, index, config);\n    const sig = sign(seckey, hash);\n    return (sigflag === 0x00)\n        ? Buff$1.raw(sig)\n        : Buff$1.join([sig, sigflag]);\n}\nfunction sign(secret, message, rand = Buff$1.random(32)) {\n    const m = Buff$1.bytes(message);\n    const dp = new Field(secret);\n    const P = dp.point;\n    const d = (P.hasEvenY) ? dp.big : dp.negated.big;\n    const a = hashTag('BIP0340/aux', Buff$1.bytes(rand));\n    const t = d ^ a.big;\n    const n = hashTag('BIP0340/nonce', t, P.x.raw, m);\n    const kp = new Field(n);\n    const R = kp.point;\n    const k = (R.hasEvenY) ? kp.big : kp.negated.big;\n    const e = new Field(hashTag('BIP0340/challenge', R.x.raw, P.x.raw, m));\n    const s = new Field(k + (e.big * d));\n    return Buff$1.join([R.x.raw, s.raw]);\n}\nfunction verify(signature, message, pubkey, shouldThrow = false) {\n    const P = Point.from_x(xOnlyPub(pubkey));\n    const m = Buff$1.bytes(message);\n    const stream = Buff$1.bytes(signature).stream;\n    if (stream.size < 64) {\n        safeThrow('Signature length is too small: ' + String(stream.size), shouldThrow);\n    }\n    const r = stream.read(32);\n    if (r.big > FIELD_SIZE) {\n        safeThrow('Signature r value greater than field size!', shouldThrow);\n    }\n    const s = stream.read(32);\n    if (s.big > CURVE_ORDER) {\n        safeThrow('Signature s value greater than curve order!', shouldThrow);\n    }\n    const e = new Field(hashTag('BIP0340/challenge', r.raw, P.x.raw, m));\n    const sG = new Field(s).point;\n    const eP = P.mul(e.big);\n    const R = sG.sub(eP);\n    if (R.hasOddY) {\n        safeThrow('Signature R value has odd Y coordinate!', shouldThrow);\n    }\n    if (R.x.big === 0n) {\n        safeThrow('Signature R value is infinite!', shouldThrow);\n    }\n    return R.x.big === r.big;\n}\n\nconst DEFAULT_VERSION$1 = 0xc0;\nfunction getTapTag(tag) {\n    const htag = Buff$1.str(tag).digest;\n    return Buff$1.join([htag, htag]);\n}\nfunction getTapLeaf(data, version = DEFAULT_VERSION$1) {\n    return Buff$1.join([\n        getTapTag('TapLeaf'),\n        getVersion(version),\n        Buff$1.bytes(data)\n    ]).digest.hex;\n}\nfunction getTapScript(script, version) {\n    return getTapLeaf(Script.fmt.toBytes(script), version);\n}\nfunction getTapBranch(leafA, leafB) {\n    if (leafB < leafA) {\n        [leafA, leafB] = [leafB, leafA];\n    }\n    return Buff$1.join([\n        getTapTag('TapBranch'),\n        Buff$1.hex(leafA).raw,\n        Buff$1.hex(leafB).raw\n    ]).digest.hex;\n}\nfunction getTapRoot(leaves) {\n    return Buff$1.hex(merkleize(leaves)[0]);\n}\nfunction merkleize(taptree, target, path = []) {\n    const leaves = [];\n    const tree = [];\n    if (taptree.length < 1) {\n        throw new Error('Tree is empty!');\n    }\n    for (let i = 0; i < taptree.length; i++) {\n        const leaf = taptree[i];\n        if (Array.isArray(leaf)) {\n            const [r, t, p] = merkleize(leaf, target);\n            target = t;\n            leaves.push(r);\n            for (const e of p) {\n                path.push(e);\n            }\n        }\n        else {\n            leaves.push(leaf);\n        }\n    }\n    if (leaves.length === 1) {\n        return [leaves[0], target, path];\n    }\n    leaves.sort();\n    if (leaves.length % 2 !== 0) {\n        leaves.push(leaves[leaves.length - 1]);\n    }\n    for (let i = 0; i < leaves.length - 1; i += 2) {\n        const branch = getTapBranch(leaves[i], leaves[i + 1]);\n        tree.push(branch);\n        if (typeof target === 'string') {\n            if (target === leaves[i]) {\n                path.push(leaves[i + 1]);\n                target = branch;\n            }\n            else if (target === leaves[i + 1]) {\n                path.push(leaves[i]);\n                target = branch;\n            }\n        }\n    }\n    return merkleize(tree, target, path);\n}\nfunction getVersion(version = 0xc0) {\n    return version & 0xfe;\n}\n\nfunction getTapTweak(key, data = new Uint8Array(), isPrivate = false) {\n    const pub = (isPrivate)\n        ? new Field(key).point.x.raw\n        : xOnlyPub(key);\n    return Buff$1.join([getTapTag('TapTweak'), pub, Buff$1.bytes(data)]).digest;\n}\nfunction getTweakedKey(intkey, data, isPrivate = false) {\n    if (data === undefined)\n        data = new Uint8Array();\n    const k = Buff$1.bytes(intkey);\n    const t = getTapTweak(intkey, data, isPrivate);\n    if (isPrivate) {\n        return tweakSecKey(k, t);\n    }\n    else {\n        return tweakPubKey(k, t);\n    }\n}\nfunction getTweakedPub(pubkey, data) {\n    return getTweakedKey(pubkey, data);\n}\nfunction getTweakedSec(seckey, data) {\n    return getTweakedKey(seckey, data, true);\n}\nfunction tweakSecKey(seckey, tweak) {\n    let sec = new Field(seckey);\n    if (sec.point.hasOddY) {\n        sec = sec.negate();\n    }\n    return Buff$1.raw(sec.add(tweak).raw);\n}\nfunction tweakPubKey(pubkey, tweak) {\n    pubkey = xOnlyPub(pubkey);\n    const P = Point.from_x(pubkey);\n    const Q = P.add(tweak);\n    return Buff$1.raw(Q.raw);\n}\nfunction getScriptOnlyPubkey() {\n    const G = Buff$1.hex('0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8');\n    return Point.from_x(G.digest).x;\n}\nconst SCRIPT_PUBKEY = getScriptOnlyPubkey();\n\nconst DEFAULT_VERSION = 0xc0;\nfunction getTapSecKey(seckey, config = {}) {\n    return getTapKey(seckey, { ...config, isPrivate: true });\n}\nfunction getTapPubKey(pubkey, config = {}) {\n    return getTapKey(pubkey, { ...config, isPrivate: false });\n}\nfunction getTapKey(intkey, config = {}) {\n    const { isPrivate = false, tree = [], version = DEFAULT_VERSION } = config;\n    const pubkey = (isPrivate)\n        ? util$1.getPublicKey(intkey, true)\n        : xOnlyPub(intkey);\n    let { target } = config;\n    if (target !== undefined)\n        target = Buff$1.bytes(target).hex;\n    let tapkey, ctrlpath = [];\n    if (tree.length > 0) {\n        const [root, _t, path] = merkleize(tree, target);\n        ctrlpath = path;\n        tapkey = getTweakedKey(intkey, root, isPrivate);\n    }\n    else {\n        if (target !== undefined) {\n            tapkey = getTweakedKey(intkey, target, isPrivate);\n        }\n        else {\n            tapkey = getTweakedKey(intkey, undefined, isPrivate);\n        }\n    }\n    const parity = (isPrivate)\n        ? util$1.getPublicKey(tapkey)[0]\n        : tapkey[0];\n    const cbit = Buff$1.num(version + readParityBit(parity));\n    const block = [cbit, pubkey];\n    if (ctrlpath.length > 0) {\n        ctrlpath.forEach(e => block.push(Buff$1.hex(e)));\n    }\n    const cblock = Buff$1.join(block);\n    if (target !== undefined) {\n        if (!checkPath(tapkey, target, cblock, config)) {\n            throw new Error('Path checking failed! Unable to generate path.');\n        }\n    }\n    return [xOnlyPub(tapkey).hex, cblock.hex];\n}\nfunction checkPath(tapkey, target, cblock, config = {}) {\n    const { isPrivate = false, throws = false } = config;\n    const { parity, paths, intkey } = readCtrlBlock(cblock);\n    const pub = (isPrivate)\n        ? util$1.getPublicKey(tapkey, true)\n        : xOnlyPub(tapkey);\n    const extkey = Buff$1.join([parity, pub]);\n    if (extkey.length !== 33) {\n        return safeThrow('Invalid tapkey: ' + extkey.hex, throws);\n    }\n    let branch = Buff$1.bytes(target).hex;\n    for (const path of paths) {\n        branch = getTapBranch(branch, path);\n    }\n    const k = getTweakedKey(intkey, branch);\n    return (Buff$1.raw(k).hex === Buff$1.raw(extkey).hex);\n}\nfunction readCtrlBlock(cblock) {\n    const buffer = new Stream$1(Buff$1.bytes(cblock));\n    const cbyte = buffer.read(1).num;\n    const intkey = buffer.read(32);\n    const [version, parity] = (cbyte % 2 === 0)\n        ? [cbyte, 0x02]\n        : [cbyte - 1, 0x03];\n    const paths = [];\n    while (buffer.size >= 32) {\n        paths.push(buffer.read(32).hex);\n    }\n    if (buffer.size !== 0) {\n        throw new Error('Non-empty buffer on control block: ' + String(buffer));\n    }\n    return { intkey, paths, parity, version };\n}\nfunction readParityBit(parity = 0x02) {\n    if (parity === 0 || parity === 1)\n        return parity;\n    if (parity === 0x02 || parity === '02')\n        return 0;\n    if (parity === 0x03 || parity === '03')\n        return 1;\n    throw new Error('Invalid parity bit: ' + String(parity));\n}\n\nfunction verifyTx(txdata, index, config = {}) {\n    const tx = Tx.fmt.toJson(txdata);\n    const { throws = false } = config;\n    const { prevout, witness = [] } = tx.vin[index];\n    const witnessData = Tx.util.readWitness(witness);\n    const { cblock, script, params } = witnessData;\n    let pub;\n    if (params.length < 1) {\n        return safeThrow('Invalid witness data: ' + String(witness), throws);\n    }\n    const { scriptPubKey } = prevout ?? {};\n    if (scriptPubKey === undefined) {\n        return safeThrow('Prevout scriptPubKey is empty!', throws);\n    }\n    const { type, data: tapkey } = Tx.util.readScriptPubKey(scriptPubKey);\n    if (type !== 'p2tr') {\n        return safeThrow('Prevout script is not a valid taproot output:' + tapkey.hex, throws);\n    }\n    if (tapkey.length !== 32) {\n        return safeThrow('Invalid tapkey length: ' + String(tapkey.length), throws);\n    }\n    if (cblock !== null &&\n        script !== null) {\n        const version = cblock[0] & 0xfe;\n        const target = getTapLeaf(script, version);\n        config.extension = target;\n        if (!checkPath(tapkey, target, cblock, { throws })) {\n            return safeThrow('cblock verification failed!', throws);\n        }\n    }\n    if (config.pubkey !== undefined) {\n        pub = Buff$1.bytes(config.pubkey);\n    }\n    else if (params.length > 1 && params[1].length === 32) {\n        pub = Buff$1.bytes(params[1]);\n    }\n    else {\n        pub = Buff$1.bytes(tapkey);\n    }\n    const rawsig = Script.fmt.toParam(params[0]);\n    const stream = new Stream$1(rawsig);\n    const signature = stream.read(64).raw;\n    if (stream.size === 1) {\n        config.sigflag = stream.read(1).num;\n        if (config.sigflag === 0x00) {\n            return safeThrow('0x00 is not a valid appended sigflag!', throws);\n        }\n    }\n    const hash = hashTx(tx, index, config);\n    if (!verify(signature, hash, pub, throws)) {\n        return safeThrow('Invalid signature!', throws);\n    }\n    return true;\n}\n\nconst TRSigner = {\n    hash: hashTx,\n    sign: signTx,\n    verify: verifyTx\n};\n\nconst Signer = {\n    segwit: SWSigner,\n    taproot: TRSigner\n};\n\nconst TapTree = {\n    getTag: getTapTag,\n    getLeaf: getTapLeaf,\n    getBranch: getTapBranch,\n    getRoot: getTapRoot\n};\nconst TapUtil = {\n    readCtrlBlock: readCtrlBlock,\n    readParityBit: readParityBit\n};\nconst TapTweak = {\n    getPubKey: getTweakedPub,\n    getSecKey: getTweakedSec,\n    getTweak: getTapTweak,\n    tweakSecKey: tweakSecKey,\n    tweakPubKey: tweakPubKey\n};\nconst Tap = {\n    getPubKey: getTapPubKey,\n    getSecKey: getTapSecKey,\n    encodeScript: getTapScript,\n    checkPath: checkPath,\n    tree: TapTree,\n    tweak: TapTweak,\n    util: TapUtil,\n    SCRIPT_PUBKEY: SCRIPT_PUBKEY\n};\n\nclass TxScript {\n    constructor(script) {\n        this._buff = Buff$1.raw(encodeScript(script));\n    }\n    get raw() {\n        return this._buff.raw;\n    }\n    get hex() {\n        return this._buff.hex;\n    }\n    get asm() {\n        return decodeScript(this._buff);\n    }\n    getHash(format, version) {\n        switch (format) {\n            case 'p2w':\n                return hash256(this._buff).hex;\n            case 'p2sh':\n                return hash160(this._buff).hex;\n            case 'p2tr':\n                return TapTree.getLeaf(this._buff, version);\n            default:\n                throw new Error('Unrecognized format: ' + format);\n        }\n    }\n    toJSON() {\n        return this.asm ?? [];\n    }\n}\n\nconst MAX_VAL = 0xFFFFFFFF;\nconst NO_LOCK = (1 << 31);\nconst TIME_MOD = 512;\nconst LOCK_TYPE = (1 << 22);\nclass TxSequence {\n    constructor(value) {\n        if (typeof value === 'string') {\n            this.value = parseInt(value, 16);\n        }\n        else {\n            this.value = value;\n        }\n    }\n    get isReplaceable() {\n        return this.value < MAX_VAL;\n    }\n    get isLocked() {\n        return !(this.value !== MAX_VAL || (this.value & NO_LOCK) !== 0);\n    }\n    get isTimelock() {\n        return (this.value & LOCK_TYPE) !== 0;\n    }\n    get timestamp() {\n        return this.isLocked\n            ? this.isTimelock\n                ? this.value * TIME_MOD\n                : this.value * TIME_MOD * 600\n            : 0;\n    }\n    set timestamp(value) {\n        this.value = Math.ceil(value / TIME_MOD);\n    }\n    get blockheight() {\n        return this.isLocked\n            ? !this.isTimelock\n                ? this.value\n                : Math.ceil((this.value * TIME_MOD) / 600)\n            : 0;\n    }\n    set blockheight(value) {\n        this.value = value;\n    }\n    get estDate() {\n        return this.isTimelock\n            ? new Date(Date.now() + (this.value * TIME_MOD * 1000))\n            : new Date(Date.now() + (this.value * 600 * 1000));\n    }\n    set estDate(date) {\n        const delta = date.getTime() - Date.now();\n        this.value = (delta > (TIME_MOD * 1000))\n            ? Math.ceil(delta / 1000 / TIME_MOD)\n            : 1;\n    }\n    toJSON() {\n        return this.value;\n    }\n}\n\nlet TxOutput$1 = class TxOutput {\n    constructor(txout) {\n        this.value = BigInt(txout.value);\n        this.scriptPubKey = new TxScript(txout.scriptPubKey);\n    }\n    get type() {\n        const { type } = readScriptPubKey(this.scriptPubKey.raw);\n        return type;\n    }\n};\n\nclass TxWitness {\n    constructor(data, format) {\n        this._data = data;\n        this._meta = readWitness(data);\n        this.format = format;\n    }\n    get length() {\n        return this._data.length;\n    }\n    get annex() {\n        const annex = this._meta.annex;\n        return (annex !== null)\n            ? Buff$1.raw(annex).hex\n            : undefined;\n    }\n    get cblock() {\n        const cblock = this._meta.cblock;\n        return (cblock !== null)\n            ? Buff$1.raw(cblock).hex\n            : undefined;\n    }\n    get script() {\n        const script = this._meta.script;\n        return (script !== null)\n            ? Script.decode(script)\n            : undefined;\n    }\n    get params() {\n        return this._meta.params;\n    }\n    toJSON() {\n        return this._data;\n    }\n}\n\nlet TxInput$1 = class TxInput {\n    constructor(txdata, index) {\n        this._tx = txdata;\n        this.idx = index;\n    }\n    get data() {\n        return this._tx.vin[this.idx];\n    }\n    get txid() {\n        return this.data.txid;\n    }\n    get vout() {\n        return this.data.vout;\n    }\n    get prevout() {\n        return (this.data.prevout !== undefined)\n            ? new TxOutput$1(this.data.prevout)\n            : undefined;\n    }\n    get scriptSig() {\n        return new TxScript(this.data.scriptSig);\n    }\n    get sequence() {\n        return new TxSequence(this.data.sequence);\n    }\n    get witness() {\n        return new TxWitness(this.data.witness);\n    }\n    get type() {\n        if (this.prevout !== undefined) {\n            const script = this.prevout.scriptPubKey.raw;\n            const { type } = readScriptPubKey(script);\n            if (type === 'p2sh') {\n                const asm = this.scriptSig.asm;\n                if (asm[0] === 'OP_0') {\n                    if (asm[1].length === 20) {\n                        return 'p2w-p2pkh';\n                    }\n                    if (asm[1].length === 32) {\n                        return 'p2w-p2sh';\n                    }\n                }\n                return 'p2sh';\n            }\n            return type;\n        }\n        return 'raw';\n    }\n    sign(seckey, config) {\n        if (this.type.startsWith('p2w')) {\n            return Signer.segwit.sign(seckey, this._tx, this.idx, config);\n        }\n        if (this.type.startsWith('p2tr')) {\n            return Signer.taproot.sign(seckey, this._tx, this.idx, config);\n        }\n        if (this.type.startsWith('p2pkh') ||\n            this.type.startsWith('p2sh')) {\n            throw new Error('This library does not support signing legacy transactions.');\n        }\n        throw new Error('Unable to sign this input type:' + String(this.type));\n    }\n};\n\nconst LOCKTIME_THRESHOLD = 500000000;\nclass TxLocktime {\n    constructor(value = 0) {\n        this.value = Buff$1.bytes(value).num;\n    }\n    get isTimelock() {\n        return this.value > LOCKTIME_THRESHOLD;\n    }\n    get timestamp() {\n        return this.isTimelock\n            ? this.value\n            : this.value * 600;\n    }\n    set timestamp(value) {\n        this.value = value;\n    }\n    get blockheight() {\n        return !this.isTimelock\n            ? this.value\n            : Math.floor(this.value / 600);\n    }\n    set blockheight(value) {\n        this.value = value;\n    }\n    get estDate() {\n        return this.isTimelock\n            ? new Date(Date.now() + (this.value * 1000))\n            : new Date(Date.now() + (this.value * 600 * 1000));\n    }\n    set estDate(date) {\n        this.value = Math.floor((date.getTime() - Date.now()) / 1000);\n    }\n    toJSON() {\n        return this.value;\n    }\n}\n\nvar util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\n\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: issueData.message || errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            getErrorMap(),\n            errorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            syncPairs.push({\n                key: await pair.key,\n                value: await pair.value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (typeof value.value !== \"undefined\" || pair.alwaysSet) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\n\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        if (typeof ctx.data === \"undefined\") {\n            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n        }\n        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[a-z][a-z0-9]*$/;\nconst ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;\nconst uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\nconst emailRegex = /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst emojiRegex = /^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$/u;\nconst ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n// Adapted from https://stackoverflow.com/a/3143231\nconst datetimeRegex = (args) => {\n    if (args.precision) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n        }\n    }\n    else if (args.precision === 0) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n        }\n    }\n    else {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n        }\n    }\n};\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n        /**\n         * @deprecated Use z.string().min(1) instead.\n         * @see {@link ZodString.min}\n         */\n        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));\n        this.trim = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n        this.toLowerCase = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n        this.toUpperCase = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            }\n            //\n            );\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        var _a;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" ||\n                ch.kind === \"int\" ||\n                ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    syncPairs.push({\n                        key,\n                        value: await pair.value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key) => {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return Object.keys(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else {\n        return null;\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date &&\n        bType === ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            return OK(async (...args) => {\n                const error = new ZodError([]);\n                const parsedArgs = await this._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await fn(...parsedArgs);\n                const parsedReturns = await this._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            return OK((...args) => {\n                const parsedArgs = this._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = fn(...parsedArgs.data);\n                const parsedReturns = this._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (this._def.values.indexOf(input.data) === -1) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values) {\n        return ZodEnum.create(values);\n    }\n    exclude(values) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));\n    }\n}\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string &&\n            ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (nativeEnumValues.indexOf(input.data) === -1) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise &&\n            ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then((processed) => {\n                    return this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                });\n            }\n            else {\n                return this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc\n            // effect: RefinementEffect<any>\n            ) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!isValid(base))\n                        return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nconst custom = (check, params = {}, \n/*\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) => {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            var _a, _b;\n            if (!check(data)) {\n                const p = typeof params === \"function\"\n                    ? params(data)\n                    : typeof params === \"string\"\n                        ? { message: params }\n                        : params;\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                const p2 = typeof p === \"string\" ? { message: p } : p;\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n            }\n        });\n    return ZodAny.create();\n};\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nconst NEVER = INVALID;\n\nvar z = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () { return util; },\n    get objectUtil () { return objectUtil; },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    'enum': enumType,\n    'function': functionType,\n    'instanceof': instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    'null': nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    'undefined': undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    'void': voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\nconst hexstr = z.string().regex(/^[a-fA-F0-9]$/);\nconst hash = z.string().regex(/^[a-fA-F0-9]{64}$/);\nconst uint32 = z.number().min(0).max(0xFFFFFFFF);\nconst uint64 = z.bigint();\nconst byteArr = z.instanceof(Uint8Array);\nconst asmcode = z.union([hexstr, uint32, z.string(), byteArr]).array();\nconst script = z.union([asmcode, hexstr, byteArr]);\nconst witness = z.array(script);\nconst TxOutput = z.object({\n    value: z.union([uint32, uint64]),\n    scriptPubKey: script\n});\nconst TxInput = z.object({\n    txid: hash,\n    vout: uint32,\n    scriptSig: script,\n    sequence: uint32,\n    prevout: TxOutput.optional(),\n    witness\n});\nconst TxData = z.object({\n    version: uint32,\n    vin: z.array(TxInput),\n    vout: z.array(TxOutput),\n    locktime: uint32\n});\nconst Schema = {\n    TxData,\n    TxInput,\n    TxOutput,\n    witness,\n    script,\n    hexstr,\n    hash,\n    uint32,\n    uint64\n};\n\nclass Transaction {\n    constructor(txdata) {\n        if (typeof txdata === 'string') {\n            txdata = Buff$1.hex(txdata);\n        }\n        if (txdata instanceof Uint8Array) {\n            txdata = Tx.decode(txdata);\n        }\n        const schema = Schema.TxData;\n        this._data = schema.parse(Tx.create(txdata));\n    }\n    get data() {\n        return this._data;\n    }\n    get version() {\n        return this.data.version;\n    }\n    get vin() {\n        return this.data.vin.map((_e, i) => new TxInput$1(this.data, i));\n    }\n    get vout() {\n        return this.data.vout.map((e) => new TxOutput$1(e));\n    }\n    get locktime() {\n        return new TxLocktime(this.data.locktime);\n    }\n    get base() {\n        return Tx.encode(this.data, true);\n    }\n    get buff() {\n        return Tx.encode(this.data);\n    }\n    get raw() {\n        return this.buff.raw;\n    }\n    get hex() {\n        return this.buff.hex;\n    }\n    get size() {\n        return this.raw.length;\n    }\n    get bsize() {\n        return this.base.length;\n    }\n    get weight() {\n        return this.bsize * 3 + this.size;\n    }\n    get vsize() {\n        const remainder = (this.weight % 4 > 0) ? 1 : 0;\n        return Math.floor(this.weight / 4) + remainder;\n    }\n    get hash() {\n        const hash = hash256(this.buff);\n        return hash.reverse().hex;\n    }\n    get txid() {\n        const hash = hash256(this.base);\n        return hash.reverse().hex;\n    }\n    async export() {\n        const { size, weight, vsize, hex } = this;\n        const txid = this.txid;\n        const hash = this.hash;\n        return { txid, hash, ...this.data, size, weight, vsize, hex };\n    }\n}\n\n\n//# sourceMappingURL=module.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvdGFwc2NyaXB0L2Rpc3QvbW9kdWxlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsUUFBUSxrQkFBa0IsU0FBUztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsWUFBWTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELGFBQWEsSUFBSSxLQUFLO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxxQ0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsOERBQThELEVBQUU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVyxNQUFNLEtBQUs7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsS0FBSyxJQUFJLEtBQUs7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNLElBQUksVUFBVTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVyxNQUFNLEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFpRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNs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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QywrQkFBK0IsNEJBQTRCO0FBQzNEO0FBQ0EseUNBQXlDO0FBQ3pDLCtCQUErQiw2QkFBNkI7QUFDNUQ7QUFDQSxzQ0FBc0M7QUFDdEMsWUFBWSwwREFBMEQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsWUFBWSxvQ0FBb0M7QUFDaEQsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFELFNBQVM7QUFDVDtBQUNBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpREFBaUQ7QUFDdkY7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5QkFBeUI7QUFDL0Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQStDO0FBQy9FO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQStDO0FBQy9FO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDO0FBQzlFO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDO0FBQzlFO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQStDO0FBQy9FO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDO0FBQzlFO0FBQ0E7QUFDQSxnQ0FBZ0MsNENBQTRDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQSxtQ0FBbUMsNkNBQTZDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FB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Qzs7QUFFRDtBQUNBLDRDQUE0QyxHQUFHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRWlKO0FBQ2pKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGNtZGNvZGUvdGFwc2NyaXB0L2Rpc3QvbW9kdWxlLm1qcz9iNGNmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlciQzKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2wkMyhiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzJDMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoJDQoaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIkMyhoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyJDMoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMkMyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0JDMob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzJDMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQkMSQyID0ge1xuICAgIG51bWJlcjogbnVtYmVyJDMsXG4gICAgYm9vbDogYm9vbCQzLFxuICAgIGJ5dGVzOiBieXRlcyQzLFxuICAgIGhhc2g6IGhhc2gkNCxcbiAgICBleGlzdHM6IGV4aXN0cyQzLFxuICAgIG91dHB1dDogb3V0cHV0JDMsXG59O1xudmFyIGFzc2VydCQyJDEgPSBhc3NlcnQkMSQyO1xuXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXckMyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyJDMgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuY29uc3QgaXNMRSQzID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSQzKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzJDQoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xufVxuZnVuY3Rpb24gdG9CeXRlcyQ1KGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMkNChkYXRhKTtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHR5cGUgaXMgVWludDhBcnJheSAoZ290ICR7dHlwZW9mIGRhdGF9KWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmxldCBIYXNoJDMgPSBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn07XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IkMyhoYXNoQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtZXNzYWdlKSA9PiBoYXNoQ29uc3RydWN0b3IoKS51cGRhdGUodG9CeXRlcyQ1KG1lc3NhZ2UpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIHJldHVybiBoYXNoQztcbn1cblxuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0JDModmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmxldCBTSEEyJDMgPSBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCQzIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3JDModGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQkMiQxLmV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyQ1KGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyQzKGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydCQyJDEuZXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnQkMiQxLm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0JDModmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3JDMob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59O1xuXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpJDMgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqJDMgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0skMyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViQzID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyQzID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmxldCBTSEEyNTYkMyA9IGNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIkMyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVYkM1swXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWJDNbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJViQzWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVYkM1szXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWJDNbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJViQzWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVYkM1s2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWJDNbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XJDNbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1ckM1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfVyQzW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90ciQzKFcxNSwgNykgXiByb3RyJDMoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90ciQzKFcyLCAxNykgXiByb3RyJDMoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1ckM1tpXSA9IChzMSArIFNIQTI1Nl9XJDNbaSAtIDddICsgczAgKyBTSEEyNTZfVyQzW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIkMyhFLCA2KSBeIHJvdHIkMyhFLCAxMSkgXiByb3RyJDMoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaSQzKEUsIEYsIEcpICsgU0hBMjU2X0skM1tpXSArIFNIQTI1Nl9XJDNbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIkMyhBLCAyKSBeIHJvdHIkMyhBLCAxMykgXiByb3RyJDMoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqJDMoQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVyQzLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn07XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5sZXQgU0hBMjI0JDMgPSBjbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYkMyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59O1xuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuY29uc3Qgc2hhMjU2JDQgPSB3cmFwQ29uc3RydWN0b3IkMygoKSA9PiBuZXcgU0hBMjU2JDMoKSk7XG53cmFwQ29uc3RydWN0b3IkMygoKSA9PiBuZXcgU0hBMjI0JDMoKSk7XG5cbmZ1bmN0aW9uIHdpdGhpbl9zaXplJDEoZGF0YSwgc2l6ZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IHNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRGF0YSBpcyBsYXJnZXIgdGhhbiBhcnJheSBzaXplOiAke2RhdGEubGVuZ3RofSA+ICR7c2l6ZX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc19oZXgkMShoZXgpIHtcbiAgICBpZiAoaGV4Lm1hdGNoKC9bXmEtZkEtZjAtOV0vKSAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlcnMgaW4gaGV4IHN0cmluZzogJyArIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExlbmd0aCBvZiBoZXggc3RyaW5nIGlzIGludmFsaWQ6ICR7aGV4Lmxlbmd0aH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc19zYWZlX251bSQxKG51bSkge1xuICAgIGlmIChudW0gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOdW1iZXIgZXhjZWVkcyBzYWZlIGJvdW5kcyEnKTtcbiAgICB9XG59XG5cbmNvbnN0IHsgZ2V0UmFuZG9tVmFsdWVzOiBnZXRSYW5kb21WYWx1ZXMkMSB9ID0gY3J5cHRvID8/IGdsb2JhbFRoaXMuY3J5cHRvID8/IHdpbmRvdy5jcnlwdG87XG5mdW5jdGlvbiByYW5kb20kMihzaXplID0gMzIpIHtcbiAgICBpZiAodHlwZW9mIGdldFJhbmRvbVZhbHVlcyQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDcnlwdG8gbW9kdWxlIG1pc3NpbmcgZ2V0UmFuZG9tVmFsdWVzIScpO1xufVxuZnVuY3Rpb24gc2V0X2J1ZmZlciQxKGRhdGEsIHNpemUsIGVuZGlhbiA9ICdiZScpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzaXplID0gZGF0YS5sZW5ndGg7XG4gICAgd2l0aGluX3NpemUkMShkYXRhLCBzaXplKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzaXplKS5maWxsKDApO1xuICAgIGNvbnN0IG9mZnNldCA9IChlbmRpYW4gPT09ICdiZScpID8gMCA6IHNpemUgLSBkYXRhLmxlbmd0aDtcbiAgICBidWZmZXIuc2V0KGRhdGEsIG9mZnNldCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGpvaW5fYXJyYXkkMShhcnIpIHtcbiAgICBsZXQgaSwgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBzaXplID0gYXJyLnJlZHVjZSgobGVuLCBhcnIpID0+IGxlbiArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJbaV07XG4gICAgICAgIGJ1ZmYuc2V0KGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmNvbnN0IGVjJDIkMSA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgQUxQSEFCRVRTJDEgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnYmFzZTU4JyxcbiAgICAgICAgY2hhcnNldDogJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG4gICAgfVxuXTtcbmZ1bmN0aW9uIGdldEFscGhhYmV0JDEobmFtZSkge1xuICAgIGZvciAoY29uc3QgYWxwaGEgb2YgQUxQSEFCRVRTJDEpIHtcbiAgICAgICAgaWYgKGFscGhhLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhbHBoYS5jaGFyc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IFR5cGVFcnJvcignQ2hhcnNldCBkb2VzIG5vdCBleGlzdDogJyArIG5hbWUpO1xufVxuZnVuY3Rpb24gZW5jb2RlJDEkMihkYXRhLCBjaGFyc2V0LCBwYWRkaW5nID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gZWMkMiQxLmVuY29kZShkYXRhKTtcbiAgICBjb25zdCBhbHBoYWJldCA9IGdldEFscGhhYmV0JDEoY2hhcnNldCk7XG4gICAgY29uc3QgbGVuID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIGNvbnN0IGQgPSBbXTtcbiAgICBsZXQgcyA9ICcnLCBpLCBqID0gMCwgYywgbjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBqID0gMDtcbiAgICAgICAgYyA9IGRhdGFbaV07XG4gICAgICAgIHMgKz0gKGMgPiAwIHx8IChzLmxlbmd0aCBeIGkpID4gMCkgPyAnJyA6ICcxJztcbiAgICAgICAgd2hpbGUgKGogaW4gZCB8fCBjID4gMCkge1xuICAgICAgICAgICAgbiA9IGRbal07XG4gICAgICAgICAgICBuID0gbiA+IDAgPyBuICogMjU2ICsgYyA6IGM7XG4gICAgICAgICAgICBjID0gbiAvIGxlbiB8IDA7XG4gICAgICAgICAgICBkW2pdID0gbiAlIGxlbjtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICBzICs9IGFscGhhYmV0W2Rbal1dO1xuICAgIH1cbiAgICByZXR1cm4gKHBhZGRpbmcgJiYgcy5sZW5ndGggJSA0ID4gMClcbiAgICAgICAgPyBzICsgJz0nLnJlcGVhdCg0IC0gcy5sZW5ndGggJSA0KVxuICAgICAgICA6IHM7XG59XG5mdW5jdGlvbiBkZWNvZGUkMSQyKGVuY29kZWQsIGNoYXJzZXQpIHtcbiAgICBjb25zdCBhbHBoYWJldCA9IGdldEFscGhhYmV0JDEoY2hhcnNldCk7XG4gICAgY29uc3QgbGVuID0gYWxwaGFiZXQubGVuZ3RoLCBkID0gW10sIGIgPSBbXTtcbiAgICBlbmNvZGVkID0gZW5jb2RlZC5yZXBsYWNlKCc9JywgJycpO1xuICAgIGxldCBpLCBqID0gMCwgYywgbjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBqID0gMDtcbiAgICAgICAgYyA9IGFscGhhYmV0LmluZGV4T2YoZW5jb2RlZFtpXSk7XG4gICAgICAgIGlmIChjIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGFyYWN0ZXIgcmFuZ2Ugb3V0IG9mIGJvdW5kczogJHtjfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGMgPiAwIHx8IChiLmxlbmd0aCBeIGkpID4gMCkpXG4gICAgICAgICAgICBiLnB1c2goMCk7XG4gICAgICAgIHdoaWxlIChqIGluIGQgfHwgYyA+IDApIHtcbiAgICAgICAgICAgIG4gPSBkW2pdO1xuICAgICAgICAgICAgbiA9IG4gPiAwID8gbiAqIGxlbiArIGMgOiBjO1xuICAgICAgICAgICAgYyA9IG4gPj4gODtcbiAgICAgICAgICAgIGRbal0gPSBuICUgMjU2O1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgIGIucHVzaChkW2pdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGIpO1xufVxuZnVuY3Rpb24gaGFzaDI1NiQyKGRhdGEpIHtcbiAgICByZXR1cm4gc2hhMjU2JDQoc2hhMjU2JDQoZGF0YSkpO1xufVxuZnVuY3Rpb24gYWRkQ2hlY2tzdW0kMShkYXRhKSB7XG4gICAgY29uc3Qgc3VtID0gaGFzaDI1NiQyKGRhdGEpO1xuICAgIHJldHVybiBqb2luX2FycmF5JDEoW2RhdGEsIHN1bS5zbGljZSgwLCA0KV0pO1xufVxuZnVuY3Rpb24gY2hlY2tUaGVTdW0kMShkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gZGF0YS5zbGljZSgwLCAtNCk7XG4gICAgY29uc3QgY2hrID0gZGF0YS5zbGljZSgtNCk7XG4gICAgY29uc3Qgc3VtID0gaGFzaDI1NiQyKHJldCkuc2xpY2UoMCwgNCk7XG4gICAgaWYgKHN1bS50b1N0cmluZygpICE9PSBjaGsudG9TdHJpbmcoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0hJyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5jb25zdCBCYXNlWCQxID0ge1xuICAgIGVuY29kZTogZW5jb2RlJDEkMixcbiAgICBkZWNvZGU6IGRlY29kZSQxJDJcbn07XG5jb25zdCBCYXNlNThDJDEgPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCB3aXRoU3VtID0gYWRkQ2hlY2tzdW0kMShkYXRhKTtcbiAgICAgICAgcmV0dXJuIEJhc2VYJDEuZW5jb2RlKHdpdGhTdW0sICdiYXNlNTgnKTtcbiAgICB9LFxuICAgIGRlY29kZTogKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEJhc2VYJDEuZGVjb2RlKGRhdGEsICdiYXNlNTgnKTtcbiAgICAgICAgcmV0dXJuIGNoZWNrVGhlU3VtJDEoZGVjb2RlZCk7XG4gICAgfVxufTtcblxuY29uc3QgQ0hBUlNFVCQxID0gJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJztcbmNvbnN0IEdFTkVSQVRPUiQxID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuY29uc3QgRU5DT0RJTkdTJDEgPSBbXG4gICAgeyB2ZXJzaW9uOiAwLCBuYW1lOiAnYmVjaDMyJywgY29uc3Q6IDEgfSxcbiAgICB7IHZlcnNpb246IDEsIG5hbWU6ICdiZWNoMzJtJywgY29uc3Q6IDB4MmJjODMwYTMgfVxuXTtcbmZ1bmN0aW9uIHBvbHltb2QkMSh2YWx1ZXMpIHtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8IHZhbHVlcy5sZW5ndGg7ICsrcCkge1xuICAgICAgICBjb25zdCB0b3AgPSBjaGsgPj4gMjU7XG4gICAgICAgIGNoayA9IChjaGsgJiAweDFmZmZmZmYpIDw8IDUgXiB2YWx1ZXNbcF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoKCh0b3AgPj4gaSkgJiAxKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNoayBePSBHRU5FUkFUT1IkMVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gaHJwRXhwYW5kJDEoaHJwKSB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgbGV0IHA7XG4gICAgZm9yIChwID0gMDsgcCA8IGhycC5sZW5ndGg7ICsrcCkge1xuICAgICAgICByZXQucHVzaChocnAuY2hhckNvZGVBdChwKSA+PiA1KTtcbiAgICB9XG4gICAgcmV0LnB1c2goMCk7XG4gICAgZm9yIChwID0gMDsgcCA8IGhycC5sZW5ndGg7ICsrcCkge1xuICAgICAgICByZXQucHVzaChocnAuY2hhckNvZGVBdChwKSAmIDMxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHZlcmlmeUNoZWNrc3VtJDEoaHJwLCBkYXRhLCBlbmMpIHtcbiAgICBjb25zdCBjb21iaW5lZCA9IGhycEV4cGFuZCQxKGhycCkuY29uY2F0KGRhdGEpO1xuICAgIHJldHVybiBwb2x5bW9kJDEoY29tYmluZWQpID09PSBlbmMuY29uc3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDaGVja3N1bSQxKGhycCwgZGF0YSwgZW5jKSB7XG4gICAgY29uc3QgdmFsdWVzID0gaHJwRXhwYW5kJDEoaHJwKS5jb25jYXQoZGF0YSkuY29uY2F0KFswLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgY29uc3QgbW9kID0gcG9seW1vZCQxKHZhbHVlcykgXiBlbmMuY29uc3Q7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPCA2OyArK3ApIHtcbiAgICAgICAgcmV0LnB1c2goKG1vZCA+PiA1ICogKDUgLSBwKSkgJiAzMSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0Qml0cyQxKGRhdGEsIGZyb21CaXRzLCB0b0JpdHMsIHBhZCA9IHRydWUpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBsZXQgYWNjID0gMDtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgY29uc3QgbWF4VmFsID0gKDEgPDwgdG9CaXRzKSAtIDE7XG4gICAgY29uc3QgbWF4QWNjID0gKDEgPDwgKGZyb21CaXRzICsgdG9CaXRzIC0gMSkpIC0gMTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBkYXRhKSB7XG4gICAgICAgIGlmICh2YWwgPCAwIHx8ICh2YWwgPj4gZnJvbUJpdHMpID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGVyZm9ybSBiYXNlIGNvbnZlcnNpb24uIEludmFsaWQgdmFsdWU6ICcgKyBTdHJpbmcodmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWNjID0gKChhY2MgPDwgZnJvbUJpdHMpIHwgdmFsKSAmIG1heEFjYztcbiAgICAgICAgYml0cyArPSBmcm9tQml0cztcbiAgICAgICAgd2hpbGUgKGJpdHMgPj0gdG9CaXRzKSB7XG4gICAgICAgICAgICBiaXRzIC09IHRvQml0cztcbiAgICAgICAgICAgIHJldC5wdXNoKChhY2MgPj4gYml0cykgJiBtYXhWYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYWQpIHtcbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICByZXQucHVzaCgoYWNjIDw8ICh0b0JpdHMgLSBiaXRzKSkgJiBtYXhWYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpdHMgPj0gZnJvbUJpdHMgfHwgKChhY2MgPDwgKHRvQml0cyAtIGJpdHMpKSAmIG1heFZhbCkgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBlcmZvcm0gYmFzZSBjb252ZXJzaW9uLiBJbnZhbGlkIFNpemUhJyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBlbmNvZGUkNihocnAsIGRhdGEsIGVuYykge1xuICAgIGNvbnN0IGNvbWJpbmVkID0gZGF0YS5jb25jYXQoY3JlYXRlQ2hlY2tzdW0kMShocnAsIGRhdGEsIGVuYykpO1xuICAgIGxldCByZXQgPSBocnAgKyAnMSc7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPCBjb21iaW5lZC5sZW5ndGg7ICsrcCkge1xuICAgICAgICByZXQgKz0gQ0hBUlNFVCQxLmNoYXJBdChjb21iaW5lZFtwXSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBkZWNvZGUkNihiZWNoc3RyKSB7XG4gICAgaWYgKCFjaGVja0JvdW5kcyQxKGJlY2hzdHIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb2RlZCBzdHJpbmcgZ29lcyBvdXQgb2YgYm91bmRzIScpO1xuICAgIH1cbiAgICBiZWNoc3RyID0gYmVjaHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghY2hlY2tTZXBhcmF0b3JQb3MkMShiZWNoc3RyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kZWQgc3RyaW5nIGhhcyBpbnZhbGlkIHNlcGFyYXRvciEnKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGNvbnN0IHBvcyA9IGJlY2hzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICBjb25zdCBocnAgPSBiZWNoc3RyLnN1YnN0cmluZygwLCBwb3MpO1xuICAgIGZvciAobGV0IHAgPSBwb3MgKyAxOyBwIDwgYmVjaHN0ci5sZW5ndGg7ICsrcCkge1xuICAgICAgICBjb25zdCBkID0gQ0hBUlNFVCQxLmluZGV4T2YoYmVjaHN0ci5jaGFyQXQocCkpO1xuICAgICAgICBpZiAoZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhcmFjdGVyIGlkeCBvdXQgb2YgYm91bmRzOiAnICsgU3RyaW5nKHApKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnB1c2goZCk7XG4gICAgfVxuICAgIGNvbnN0IGVuYyA9IEVOQ09ESU5HUyQxLmZpbmQoZSA9PiBlLnZlcnNpb24gPT09IGRhdGFbMF0pID8/IEVOQ09ESU5HUyQxWzBdO1xuICAgIGlmICghdmVyaWZ5Q2hlY2tzdW0kMShocnAsIGRhdGEsIGVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGVja3N1bSB2ZXJpZmljYXRpb24gZmFpbGVkIScpO1xuICAgIH1cbiAgICByZXR1cm4gW2hycCwgZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIDYpXTtcbn1cbmZ1bmN0aW9uIGNoZWNrQm91bmRzJDEoYmVjaHN0cikge1xuICAgIGxldCBwO1xuICAgIGxldCBjaGFyO1xuICAgIGxldCBoYXNMb3dlciA9IGZhbHNlO1xuICAgIGxldCBoYXNVcHBlciA9IGZhbHNlO1xuICAgIGZvciAocCA9IDA7IHAgPCBiZWNoc3RyLmxlbmd0aDsgKytwKSB7XG4gICAgICAgIGNoYXIgPSBiZWNoc3RyLmNoYXJDb2RlQXQocCk7XG4gICAgICAgIGlmIChjaGFyIDwgMzMgfHwgY2hhciA+IDEyNikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID49IDk3ICYmIGNoYXIgPD0gMTIyKSB7XG4gICAgICAgICAgICBoYXNMb3dlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPj0gNjUgJiYgY2hhciA8PSA5MCkge1xuICAgICAgICAgICAgaGFzVXBwZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNMb3dlciAmJiBoYXNVcHBlcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2hlY2tTZXBhcmF0b3JQb3MkMShiZWNoc3RyKSB7XG4gICAgY29uc3QgcG9zID0gYmVjaHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgIHJldHVybiAhKHBvcyA8IDEgfHxcbiAgICAgICAgcG9zICsgNyA+IGJlY2hzdHIubGVuZ3RoIHx8XG4gICAgICAgIGJlY2hzdHIubGVuZ3RoID4gOTApO1xufVxuZnVuY3Rpb24gYjMyZW5jb2RlJDEoZGF0YSwgaHJwID0gJ2JjJywgdmVyc2lvbiA9IDApIHtcbiAgICBjb25zdCBkYXQgPSBbdmVyc2lvbiwgLi4uY29udmVydEJpdHMkMShbLi4uZGF0YV0sIDgsIDUpXTtcbiAgICBjb25zdCBlbmMgPSBFTkNPRElOR1MkMS5maW5kKGUgPT4gZS52ZXJzaW9uID09PSB2ZXJzaW9uKSA/PyBFTkNPRElOR1MkMVswXTtcbiAgICBjb25zdCBzdHIgPSBlbmNvZGUkNihocnAsIGRhdCwgZW5jKTtcbiAgICBiMzJkZWNvZGUkMShzdHIpO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBiMzJkZWNvZGUkMShzdHIpIHtcbiAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBocnAgPSBzdHIuc3BsaXQoJzEnLCAxKVswXTtcbiAgICBjb25zdCBbaHJwZ290LCBkYXRhXSA9IGRlY29kZSQ2KHN0cik7XG4gICAgY29uc3QgZGVjb2RlZCA9IGNvbnZlcnRCaXRzJDEoZGF0YS5zbGljZSgxKSwgNSwgOCwgZmFsc2UpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGRlY29kZWQubGVuZ3RoO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIChocnAgIT09IGhycGdvdCk6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JldHVybmVkIGhycCBzdHJpbmcgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgY2FzZSAoZGVjb2RlZCA9PT0gbnVsbCB8fCBsZW5ndGggPCAyIHx8IGxlbmd0aCA+IDQwKTpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlZCBzdHJpbmcgaXMgaW52YWxpZCBvciBvdXQgb2Ygc3BlYy4nKTtcbiAgICAgICAgY2FzZSAoZGF0YVswXSA+IDE2KTpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmV0dXJuZWQgdmVyc2lvbiBiaXQgaXMgb3V0IG9mIHJhbmdlLicpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShkZWNvZGVkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRWZXJzaW9uJDIoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgW18sIGRhdGFdID0gZGVjb2RlJDYoc3RyKTtcbiAgICByZXR1cm4gZGF0YVswXTtcbn1cbmNvbnN0IEJlY2gzMiQxID0ge1xuICAgIGVuY29kZTogYjMyZW5jb2RlJDEsXG4gICAgZGVjb2RlOiBiMzJkZWNvZGUkMSxcbiAgICB2ZXJzaW9uOiBnZXRWZXJzaW9uJDJcbn07XG5cbmNvbnN0IEJBU0U2NF9NQVAkMSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbmNvbnN0IEI2NFVSTF9NQVAkMSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJztcbmNvbnN0IGVjJDEkMSA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gYjY0ZW5jb2RlJDEoaW5wdXQsIHVybFNhZmUgPSBmYWxzZSwgcGFkZGluZyA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJylcbiAgICAgICAgaW5wdXQgPSBlYyQxJDEuZW5jb2RlKGlucHV0KTtcbiAgICBjb25zdCBtYXAgPSB1cmxTYWZlID8gQjY0VVJMX01BUCQxIDogQkFTRTY0X01BUCQxO1xuICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgbGV0IGJ1ZmZlciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgaW5wdXRbaV07XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgd2hpbGUgKGJpdHMgPj0gNikge1xuICAgICAgICAgICAgYml0cyAtPSA2O1xuICAgICAgICAgICAgb3V0cHV0ICs9IG1hcFsoYnVmZmVyID4+IGJpdHMpICYgMHgzZl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgIGJ1ZmZlciA8PD0gNiAtIGJpdHM7XG4gICAgICAgIG91dHB1dCArPSBtYXBbYnVmZmVyICYgMHgzZl07XG4gICAgICAgIHdoaWxlIChiaXRzIDwgNikge1xuICAgICAgICAgICAgb3V0cHV0ICs9IHBhZGRpbmcgPyAnPScgOiAnJztcbiAgICAgICAgICAgIGJpdHMgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gYjY0ZGVjb2RlJDEoaW5wdXQsIHVybFNhZmUgPSBmYWxzZSkge1xuICAgIGNvbnN0IG1hcCA9ICh1cmxTYWZlIHx8IGlucHV0LmluY2x1ZGVzKCctJykgfHwgaW5wdXQuaW5jbHVkZXMoJ18nKSlcbiAgICAgICAgPyBCNjRVUkxfTUFQJDEuc3BsaXQoJycpXG4gICAgICAgIDogQkFTRTY0X01BUCQxLnNwbGl0KCcnKTtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBjb25zdCBjaGFycyA9IGlucHV0LnNwbGl0KCcnKTtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGNoYXJzW2ldO1xuICAgICAgICBjb25zdCBpbmRleCA9IG1hcC5pbmRleE9mKGMpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyOiAnICsgYyk7XG4gICAgICAgIH1cbiAgICAgICAgYml0cyArPSA2O1xuICAgICAgICB2YWx1ZSA8PD0gNjtcbiAgICAgICAgdmFsdWUgfD0gaW5kZXg7XG4gICAgICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgICAgICAgIGJpdHMgLT0gODtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlID4+PiBiaXRzKSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG59XG5jb25zdCBCYXNlNjQkMSA9IHtcbiAgICBlbmNvZGU6IGI2NGVuY29kZSQxLFxuICAgIGRlY29kZTogYjY0ZGVjb2RlJDFcbn07XG5jb25zdCBCNjRVUkwkMSA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBiNjRlbmNvZGUkMShkYXRhLCB0cnVlLCBmYWxzZSksXG4gICAgZGVjb2RlOiAoZGF0YSkgPT4gYjY0ZGVjb2RlJDEoZGF0YSwgdHJ1ZSlcbn07XG5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8yNTVuJDEgPSBCaWdJbnQoMjU1KTtcbmNvbnN0IF8yNTZuJDEgPSBCaWdJbnQoMjU2KTtcbmZ1bmN0aW9uIGJpZ19zaXplJDEoYmlnKSB7XG4gICAgaWYgKGJpZyA8PSAweGZmbilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGJpZyA8PSAweGZmZmZuKVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAoYmlnIDw9IDB4ZmZmZmZmZmZuKVxuICAgICAgICByZXR1cm4gNDtcbiAgICBpZiAoYmlnIDw9IDB4ZmZmZmZmZmZmZmZmZmZmZm4pXG4gICAgICAgIHJldHVybiA4O1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm4pXG4gICAgICAgIHJldHVybiAxNjtcbiAgICBpZiAoYmlnIDw9IDB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm4pIHtcbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHNwZWNpZnkgYSBmaXhlZCBidWZmZXIgc2l6ZSBmb3IgYmlnaW50cyBncmVhdGVyIHRoYW4gMzIgYnl0ZXMuJyk7XG59XG5mdW5jdGlvbiBiaWdUb0J5dGVzJDEoYmlnLCBzaXplLCBlbmRpYW4gPSAnYmUnKSB7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2l6ZSA9IGJpZ19zaXplJDEoYmlnKTtcbiAgICBjb25zdCB1c2VfbGUgPSAoZW5kaWFuID09PSAnbGUnKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBsZXQgb2Zmc2V0ID0gKHVzZV9sZSkgPyAwIDogc2l6ZSAtIDE7XG4gICAgd2hpbGUgKGJpZyA+IF8wbikge1xuICAgICAgICBjb25zdCBieXRlID0gYmlnICYgXzI1NW4kMTtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKGJ5dGUpO1xuICAgICAgICBpZiAodXNlX2xlKSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQrKywgbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KG9mZnNldC0tLCBudW0pO1xuICAgICAgICB9XG4gICAgICAgIGJpZyA9IChiaWcgLSBieXRlKSAvIF8yNTZuJDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb0JpZyQxKGJ5dGVzKSB7XG4gICAgbGV0IG51bSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gYnl0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbnVtID0gKG51bSAqIF8yNTZuJDEpICsgQmlnSW50KGJ5dGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChudW0pO1xufVxuXG5mdW5jdGlvbiBiaW5Ub0J5dGVzJDEoYmluYXJ5KSB7XG4gICAgY29uc3QgYmlucyA9IGJpbmFyeS5zcGxpdCgnJykubWFwKE51bWJlcik7XG4gICAgaWYgKGJpbnMubGVuZ3RoICUgOCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpbmFyeSBhcnJheSBpcyBpbnZhbGlkIGxlbmd0aDogJHtiaW5hcnkubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbnMubGVuZ3RoIC8gOCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGN0ID0gMDsgaSA8IGJpbnMubGVuZ3RoOyBpICs9IDgsIGN0KyspIHtcbiAgICAgICAgbGV0IGJ5dGUgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgICAgICAgYnl0ZSB8PSAoYmluc1tpICsgal0gPDwgKDcgLSBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXNbY3RdID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gYnl0ZXNUb0JpbiQxKGJ5dGVzKSB7XG4gICAgY29uc3QgYmluID0gbmV3IEFycmF5KGJ5dGVzLmxlbmd0aCAqIDgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBudW0gb2YgYnl0ZXMpIHtcbiAgICAgICAgaWYgKG51bSA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ5dGUgdmFsdWU6ICR7bnVtfS4gQnl0ZSB2YWx1ZXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS5gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gNzsgaSA+PSAwOyBpLS0sIGNvdW50KyspIHtcbiAgICAgICAgICAgIGJpbltjb3VudF0gPSAobnVtID4+IGkpICYgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmluLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBudW1fc2l6ZSQxKG51bSkge1xuICAgIGlmIChudW0gPD0gMHhGRilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKG51bSA8PSAweEZGRkYpXG4gICAgICAgIHJldHVybiAyO1xuICAgIGlmIChudW0gPD0gMHhGRkZGRkZGRilcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTnVtYmVycyBsYXJnZXIgdGhhbiA0IGJ5dGVzIG11c3Qgc3BlY2lmeSBhIGZpeGVkIHNpemUhJyk7XG59XG5mdW5jdGlvbiBudW1Ub0J5dGVzJDEobnVtLCBzaXplLCBlbmRpYW4gPSAnYmUnKSB7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2l6ZSA9IG51bV9zaXplJDEobnVtKTtcbiAgICBjb25zdCB1c2VfbGUgPSAoZW5kaWFuID09PSAnbGUnKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBsZXQgb2Zmc2V0ID0gKHVzZV9sZSkgPyAwIDogc2l6ZSAtIDE7XG4gICAgd2hpbGUgKG51bSA+IDApIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IG51bSAmIDI1NTtcbiAgICAgICAgaWYgKHVzZV9sZSkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0KyssIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQtLSwgbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSAobnVtIC0gYnl0ZSkgLyAyNTY7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb051bSQxKGJ5dGVzKSB7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG51bSA9IChudW0gKiAyNTYpICsgYnl0ZXNbaV07XG4gICAgICAgIGlzX3NhZmVfbnVtJDEobnVtKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbn1cblxuY29uc3QgZWMkMyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgZGMkMSA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZnVuY3Rpb24gc3RyVG9CeXRlcyQxKHN0cikge1xuICAgIHJldHVybiBlYyQzLmVuY29kZShzdHIpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb1N0ciQxKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGRjJDEuZGVjb2RlKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGhleF9zaXplJDEoaGV4c3RyLCBzaXplKSB7XG4gICAgaXNfaGV4JDEoaGV4c3RyKTtcbiAgICBjb25zdCBsZW4gPSBoZXhzdHIubGVuZ3RoIC8gMjtcbiAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzaXplID0gbGVuO1xuICAgIGlmIChsZW4gPiBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEhleCBzdHJpbmcgaXMgbGFyZ2VyIHRoYW4gYXJyYXkgc2l6ZTogJHtsZW59ID4gJHtzaXplfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZXMkMihoZXhzdHIsIHNpemUsIGVuZGlhbiA9ICdsZScpIHtcbiAgICBzaXplID0gaGV4X3NpemUkMShoZXhzdHIsIHNpemUpO1xuICAgIGNvbnN0IHVzZV9sZSA9IChlbmRpYW4gPT09ICdsZScpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAodXNlX2xlKSA/IDAgOiBzaXplIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhleHN0ci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBjaGFyID0gaGV4c3RyLnN1YnN0cmluZyhpLCBpICsgMik7XG4gICAgICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KGNoYXIsIDE2KTtcbiAgICAgICAgaWYgKHVzZV9sZSkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0KyssIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQtLSwgbnVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgkMihieXRlcykge1xuICAgIGxldCBjaGFycyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hhcnMgKz0gYnl0ZXNbaV0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbn1cbmZ1bmN0aW9uIGpzb25Ub0J5dGVzJDEob2JqKSB7XG4gICAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCAoXywgdikgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IGAke3Z9bmBcbiAgICAgICAgICAgIDogdjtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyVG9CeXRlcyQxKHN0cik7XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlciQxKGRhdGEsIHNpemUsIGVuZGlhbikge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHNldF9idWZmZXIkMShkYXRhLCBzaXplLCBlbmRpYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzJDIoZGF0YSwgc2l6ZSwgZW5kaWFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYmlnVG9CeXRlcyQxKGRhdGEsIHNpemUsIGVuZGlhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvQnl0ZXMkMShkYXRhLCBzaXplLCBlbmRpYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5vZihkYXRhID8gMSA6IDApO1xuICAgIH1cbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIGZvcm1hdDonICsgU3RyaW5nKHR5cGVvZiBkYXRhKSk7XG59XG5cbmxldCBCdWZmJDEgPSBjbGFzcyBCdWZmIGV4dGVuZHMgVWludDhBcnJheSB7XG4gICAgc3RhdGljIHsgdGhpcy5udW0gPSBudW1Ub0J1ZmYkMTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYmlnID0gYmlnVG9CdWZmJDE7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJpbiA9IGJpblRvQnVmZiQxOyB9XG4gICAgc3RhdGljIHsgdGhpcy5yYXcgPSByYXdUb0J1ZmYkMTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuc3RyID0gc3RyVG9CdWZmJDE7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmhleCA9IGhleFRvQnVmZiQxOyB9XG4gICAgc3RhdGljIHsgdGhpcy5ieXRlcyA9IGJ5dGVzVG9CdWZmJDE7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmpzb24gPSBqc29uVG9CdWZmJDE7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJhc2U2NCA9IGJhc2U2NFRvQnVmZiQxOyB9XG4gICAgc3RhdGljIHsgdGhpcy5iNjR1cmwgPSBiNjR1cmxUb0J1ZmYkMTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYmVjaDMyID0gYmVjaDMyVG9CdWZmJDE7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmI1OGNoayA9IGI1OGNoa1RvQnVmZiQxOyB9XG4gICAgc3RhdGljIHsgdGhpcy5lbmNvZGUgPSBzdHJUb0J5dGVzJDE7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmRlY29kZSA9IGJ5dGVzVG9TdHIkMTsgfVxuICAgIHN0YXRpYyByYW5kb20oc2l6ZSA9IDMyKSB7XG4gICAgICAgIGNvbnN0IHJhbmQgPSByYW5kb20kMihzaXplKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKHJhbmQsIHNpemUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBzaXplLCBlbmRpYW4pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyJDEkMSA9IGJ1ZmZlciQxKGRhdGEsIHNpemUsIGVuZGlhbik7XG4gICAgICAgIHN1cGVyKGJ1ZmZlciQxJDEpO1xuICAgIH1cbiAgICBnZXQgYXJyKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXNdO1xuICAgIH1cbiAgICBnZXQgbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b051bSgpO1xuICAgIH1cbiAgICBnZXQgYmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0JpZygpO1xuICAgIH1cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cigpO1xuICAgIH1cbiAgICBnZXQgaGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgIH1cbiAgICBnZXQgcmF3KCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcyk7XG4gICAgfVxuICAgIGdldCBiaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQmluKCk7XG4gICAgfVxuICAgIGdldCBiNThjaGsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYjU4Y2hrKCk7XG4gICAgfVxuICAgIGdldCBiYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQmFzZTY0KCk7XG4gICAgfVxuICAgIGdldCBiNjR1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQjY0dXJsKCk7XG4gICAgfVxuICAgIGdldCBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGFzaCgpO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGFzaCgpLmhleDtcbiAgICB9XG4gICAgZ2V0IHN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0kMSh0aGlzKTtcbiAgICB9XG4gICAgdG9OdW0oZW5kaWFuID0gJ2JlJykge1xuICAgICAgICBjb25zdCBieXRlcyA9IChlbmRpYW4gPT09ICdiZScpXG4gICAgICAgICAgICA/IHRoaXMucmV2ZXJzZSgpXG4gICAgICAgICAgICA6IHRoaXM7XG4gICAgICAgIHJldHVybiBieXRlc1RvTnVtJDEoYnl0ZXMpO1xuICAgIH1cbiAgICB0b0JpbigpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9CaW4kMSh0aGlzKTtcbiAgICB9XG4gICAgdG9CaWcoZW5kaWFuID0gJ2JlJykge1xuICAgICAgICBjb25zdCBieXRlcyA9IChlbmRpYW4gPT09ICdiZScpXG4gICAgICAgICAgICA/IHRoaXMucmV2ZXJzZSgpXG4gICAgICAgICAgICA6IHRoaXM7XG4gICAgICAgIHJldHVybiBieXRlc1RvQmlnJDEoYnl0ZXMpO1xuICAgIH1cbiAgICB0b0hhc2goKSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IHNoYTI1NiQ0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYoZGlnZXN0KTtcbiAgICB9XG4gICAgdG9Kc29uKCkge1xuICAgICAgICBjb25zdCBzdHIgPSBieXRlc1RvU3RyJDEodGhpcyk7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG4gICAgfVxuICAgIHRvQmVjaDMyKGhycCwgdmVyc2lvbiA9IDApIHtcbiAgICAgICAgcmV0dXJuIEJlY2gzMiQxLmVuY29kZSh0aGlzLCBocnAsIHZlcnNpb24pO1xuICAgIH1cbiAgICB0b1N0cigpIHsgcmV0dXJuIGJ5dGVzVG9TdHIkMSh0aGlzKTsgfVxuICAgIHRvSGV4KCkgeyByZXR1cm4gYnl0ZXNUb0hleCQyKHRoaXMpOyB9XG4gICAgdG9CeXRlcygpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMpOyB9XG4gICAgdG9iNThjaGsoKSB7IHJldHVybiBCYXNlNThDJDEuZW5jb2RlKHRoaXMpOyB9XG4gICAgdG9CYXNlNjQoKSB7IHJldHVybiBCYXNlNjQkMS5lbmNvZGUodGhpcyk7IH1cbiAgICB0b0I2NHVybCgpIHsgcmV0dXJuIEI2NFVSTCQxLmVuY29kZSh0aGlzKTsgfVxuICAgIHByZXBlbmQoZGF0YSkge1xuICAgICAgICByZXR1cm4gQnVmZi5qb2luKFtCdWZmLmJ5dGVzKGRhdGEpLCB0aGlzXSk7XG4gICAgfVxuICAgIGFwcGVuZChkYXRhKSB7XG4gICAgICAgIHJldHVybiBCdWZmLmpvaW4oW3RoaXMsIEJ1ZmYuYnl0ZXMoZGF0YSldKTtcbiAgICB9XG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSh0aGlzKS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGFycik7XG4gICAgfVxuICAgIHN1YmFycmF5KGJlZ2luLCBlbmQpIHtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcykuc3ViYXJyYXkoYmVnaW4sIGVuZCk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZihhcnIpO1xuICAgIH1cbiAgICByZXZlcnNlKCkge1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSh0aGlzKS5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZihhcnIpO1xuICAgIH1cbiAgICB3cml0ZShieXRlcywgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGIgPSBCdWZmLmJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgdGhpcy5zZXQoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcHJlZml4U2l6ZShlbmRpYW4pIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IEJ1ZmYudmFySW50KHRoaXMubGVuZ3RoLCBlbmRpYW4pO1xuICAgICAgICByZXR1cm4gQnVmZi5qb2luKFtzaXplLCB0aGlzXSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKFVpbnQ4QXJyYXkuZnJvbShkYXRhKSk7XG4gICAgfVxuICAgIHN0YXRpYyBvZiguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZihVaW50OEFycmF5Lm9mKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgc3RhdGljIGpvaW4oYXJyKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyLm1hcChlID0+IEJ1ZmYuYnl0ZXMoZSkpO1xuICAgICAgICBjb25zdCBqb2luZWQgPSBqb2luX2FycmF5JDEoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYoam9pbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIHZhckludChudW0sIGVuZGlhbikge1xuICAgICAgICBpZiAobnVtIDwgMHhGRCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmYubnVtKG51bSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobnVtIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmYub2YoMHhGRCwgLi4uQnVmZi5udW0obnVtLCAyLCBlbmRpYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW0gPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmYub2YoMHhGRSwgLi4uQnVmZi5udW0obnVtLCA0LCBlbmRpYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCaWdJbnQobnVtKSA8IDB4MTAwMDAwMDAwMDAwMDAwMDBuKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZi5vZigweEZGLCAuLi5CdWZmLm51bShudW0sIDgsIGVuZGlhbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBpcyB0b28gbGFyZ2U6ICR7bnVtfWApO1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIG51bVRvQnVmZiQxKG51bWJlciwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmJDEobnVtYmVyLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24gYmluVG9CdWZmJDEoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmJDEoYmluVG9CeXRlcyQxKGRhdGEpLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24gYmlnVG9CdWZmJDEoYmlnaW50LCBzaXplLCBlbmRpYW4pIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYkMShiaWdpbnQsIHNpemUsIGVuZGlhbik7XG59XG5mdW5jdGlvbiByYXdUb0J1ZmYkMShkYXRhLCBzaXplLCBlbmRpYW4pIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYkMShkYXRhLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24gc3RyVG9CdWZmJDEoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmJDEoc3RyVG9CeXRlcyQxKGRhdGEpLCBzaXplLCBlbmRpYW4pO1xufVxuZnVuY3Rpb24gaGV4VG9CdWZmJDEoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmJDEoZGF0YSwgc2l6ZSwgZW5kaWFuKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9CdWZmJDEoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmJDEoZGF0YSwgc2l6ZSwgZW5kaWFuKTtcbn1cbmZ1bmN0aW9uIGpzb25Ub0J1ZmYkMShkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmJDEoanNvblRvQnl0ZXMkMShkYXRhKSk7XG59XG5mdW5jdGlvbiBiYXNlNjRUb0J1ZmYkMShkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmJDEoQmFzZTY0JDEuZGVjb2RlKGRhdGEpKTtcbn1cbmZ1bmN0aW9uIGI2NHVybFRvQnVmZiQxKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYkMShCNjRVUkwkMS5kZWNvZGUoZGF0YSkpO1xufVxuZnVuY3Rpb24gYmVjaDMyVG9CdWZmJDEoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQnVmZiQxKEJlY2gzMiQxLmRlY29kZShkYXRhKSk7XG59XG5mdW5jdGlvbiBiNThjaGtUb0J1ZmYkMShkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmJDEoQmFzZTU4QyQxLmRlY29kZShkYXRhKSk7XG59XG5sZXQgU3RyZWFtJDEgPSBjbGFzcyBTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZiQxLmJ5dGVzKGRhdGEpO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBwZWVrKHNpemUpIHtcbiAgICAgICAgaWYgKHNpemUgPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2l6ZSBncmVhdGVyIHRoYW4gc3RyZWFtOiAke3NpemV9ID4gJHt0aGlzLnNpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmJDEodGhpcy5kYXRhLnNsaWNlKDAsIHNpemUpKTtcbiAgICB9XG4gICAgcmVhZChzaXplKSB7XG4gICAgICAgIHNpemUgPSBzaXplID8/IHRoaXMucmVhZFNpemUoKTtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLnBlZWsoc2l6ZSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zbGljZShzaXplKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICByZWFkU2l6ZShlbmRpYW4pIHtcbiAgICAgICAgY29uc3QgbnVtID0gdGhpcy5yZWFkKDEpLm51bTtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIChudW0gPj0gMCAmJiBudW0gPCAweEZEKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgICAgY2FzZSAobnVtID09PSAweEZEKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkKDIpLnRvTnVtKGVuZGlhbik7XG4gICAgICAgICAgICBjYXNlIChudW0gPT09IDB4RkUpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQoNCkudG9OdW0oZW5kaWFuKTtcbiAgICAgICAgICAgIGNhc2UgKG51bSA9PT0gMHhGRik6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZCg4KS50b051bShlbmRpYW4pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhcmludCBpcyBvdXQgb2YgcmFuZ2U6ICR7bnVtfWApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY2hlY2tTaXplKGlucHV0LCBzaXplKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmJDEuYnl0ZXMoaW5wdXQpO1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlucHV0IHNpemU6ICR7Ynl0ZXMuaGV4fSAhPT0gJHtzaXplfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhZmVUaHJvdyhlcnJvck1zZywgc2hvdWxkVGhyb3cpIHtcbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNoVGFnKHRhZywgLi4uZGF0YSkge1xuICAgIGNvbnN0IGh0YWcgPSBCdWZmJDEuc3RyKHRhZykuZGlnZXN0LnJhdztcbiAgICBjb25zdCBidWZmID0gZGF0YS5tYXAoZSA9PiBCdWZmJDEuYnl0ZXMoZSkpO1xuICAgIHJldHVybiBCdWZmJDEuam9pbihbaHRhZywgaHRhZywgQnVmZiQxLmpvaW4oYnVmZildKS5kaWdlc3Q7XG59XG5cbmNvbnN0IE9QQ09ERV9NQVAgPSB7XG4gICAgT1BfMDogMCxcbiAgICBPUF9QVVNIREFUQTE6IDc2LFxuICAgIE9QX1BVU0hEQVRBMjogNzcsXG4gICAgT1BfUFVTSERBVEE0OiA3OCxcbiAgICBPUF8xTkVHQVRFOiA3OSxcbiAgICBPUF9TVUNDRVNTODA6IDgwLFxuICAgIE9QXzE6IDgxLFxuICAgIE9QXzI6IDgyLFxuICAgIE9QXzM6IDgzLFxuICAgIE9QXzQ6IDg0LFxuICAgIE9QXzU6IDg1LFxuICAgIE9QXzY6IDg2LFxuICAgIE9QXzc6IDg3LFxuICAgIE9QXzg6IDg4LFxuICAgIE9QXzk6IDg5LFxuICAgIE9QXzEwOiA5MCxcbiAgICBPUF8xMTogOTEsXG4gICAgT1BfMTI6IDkyLFxuICAgIE9QXzEzOiA5MyxcbiAgICBPUF8xNDogOTQsXG4gICAgT1BfMTU6IDk1LFxuICAgIE9QXzE2OiA5NixcbiAgICBPUF9OT1A6IDk3LFxuICAgIE9QX1NVQ0NFU1M5ODogOTgsXG4gICAgT1BfSUY6IDk5LFxuICAgIE9QX05PVElGOiAxMDAsXG4gICAgT1BfRUxTRTogMTAzLFxuICAgIE9QX0VORElGOiAxMDQsXG4gICAgT1BfVkVSSUZZOiAxMDUsXG4gICAgT1BfUkVUVVJOOiAxMDYsXG4gICAgT1BfVE9BTFRTVEFDSzogMTA3LFxuICAgIE9QX0ZST01BTFRTVEFDSzogMTA4LFxuICAgIE9QXzJEUk9QOiAxMDksXG4gICAgT1BfMkRVUDogMTEwLFxuICAgIE9QXzNEVVA6IDExMSxcbiAgICBPUF8yT1ZFUjogMTEyLFxuICAgIE9QXzJST1Q6IDExMyxcbiAgICBPUF8yU1dBUDogMTE0LFxuICAgIE9QX0lGRFVQOiAxMTUsXG4gICAgT1BfREVQVEg6IDExNixcbiAgICBPUF9EUk9QOiAxMTcsXG4gICAgT1BfRFVQOiAxMTgsXG4gICAgT1BfTklQOiAxMTksXG4gICAgT1BfT1ZFUjogMTIwLFxuICAgIE9QX1BJQ0s6IDEyMSxcbiAgICBPUF9ST0xMOiAxMjIsXG4gICAgT1BfUk9UOiAxMjMsXG4gICAgT1BfU1dBUDogMTI0LFxuICAgIE9QX1RVQ0s6IDEyNSxcbiAgICBPUF9TVUNDRVNTMTI2OiAxMjYsXG4gICAgT1BfU1VDQ0VTUzEyNzogMTI3LFxuICAgIE9QX1NVQ0NFU1MxMjg6IDEyOCxcbiAgICBPUF9TVUNDRVNTMTI5OiAxMjksXG4gICAgT1BfU0laRTogMTMwLFxuICAgIE9QX1NVQ0NFU1MxMzE6IDEzMSxcbiAgICBPUF9TVUNDRVNTMTMyOiAxMzIsXG4gICAgT1BfU1VDQ0VTUzEzMzogMTMzLFxuICAgIE9QX1NVQ0NFU1MxMzQ6IDEzNCxcbiAgICBPUF9FUVVBTDogMTM1LFxuICAgIE9QX0VRVUFMVkVSSUZZOiAxMzYsXG4gICAgT1BfU1VDQ0VTUzEzNzogMTM3LFxuICAgIE9QX1NVQ0NFU1MxMzg6IDEzOCxcbiAgICBPUF8xQUREOiAxMzksXG4gICAgT1BfMVNVQjogMTQwLFxuICAgIE9QX1NVQ0NFU1MxNDE6IDE0MSxcbiAgICBPUF9TVUNDRVNTMTQyOiAxNDIsXG4gICAgT1BfTkVHQVRFOiAxNDMsXG4gICAgT1BfQUJTOiAxNDQsXG4gICAgT1BfTk9UOiAxNDUsXG4gICAgT1BfME5PVEVRVUFMOiAxNDYsXG4gICAgT1BfQUREOiAxNDcsXG4gICAgT1BfU1VCOiAxNDgsXG4gICAgT1BfU1VDQ0VTUzE0OTogMTQ5LFxuICAgIE9QX1NVQ0NFU1MxNTA6IDE1MCxcbiAgICBPUF9TVUNDRVNTMTUxOiAxNTEsXG4gICAgT1BfU1VDQ0VTUzE1MjogMTUyLFxuICAgIE9QX1NVQ0NFU1MxNTM6IDE1MyxcbiAgICBPUF9CT09MQU5EOiAxNTQsXG4gICAgT1BfQk9PTE9SOiAxNTUsXG4gICAgT1BfTlVNRVFVQUw6IDE1NixcbiAgICBPUF9OVU1FUVVBTFZFUklGWTogMTU3LFxuICAgIE9QX05VTU5PVEVRVUFMOiAxNTgsXG4gICAgT1BfTEVTU1RIQU46IDE1OSxcbiAgICBPUF9HUkVBVEVSVEhBTjogMTYwLFxuICAgIE9QX0xFU1NUSEFOT1JFUVVBTDogMTYxLFxuICAgIE9QX0dSRUFURVJUSEFOT1JFUVVBTDogMTYyLFxuICAgIE9QX01JTjogMTYzLFxuICAgIE9QX01BWDogMTY0LFxuICAgIE9QX1dJVEhJTjogMTY1LFxuICAgIE9QX1JJUEVNRDE2MDogMTY2LFxuICAgIE9QX1NIQTE6IDE2NyxcbiAgICBPUF9TSEEyNTY6IDE2OCxcbiAgICBPUF9IQVNIMTYwOiAxNjksXG4gICAgT1BfSEFTSDI1NjogMTcwLFxuICAgIE9QX0NPREVTRVBBUkFUT1I6IDE3MSxcbiAgICBPUF9DSEVDS1NJRzogMTcyLFxuICAgIE9QX0NIRUNLU0lHVkVSSUZZOiAxNzMsXG4gICAgT1BfQ0hFQ0tNVUxUSVNJRzogMTc0LFxuICAgIE9QX0NIRUNLTVVMVElTSUdWRVJJRlk6IDE3NSxcbiAgICBPUF9OT1AxOiAxNzYsXG4gICAgT1BfQ0hFQ0tMT0NLVElNRVZFUklGWTogMTc3LFxuICAgIE9QX0NIRUNLU0VRVUVOQ0VWRVJJRlk6IDE3OCxcbiAgICBPUF9OT1A0OiAxNzksXG4gICAgT1BfTk9QNTogMTgwLFxuICAgIE9QX05PUDY6IDE4MSxcbiAgICBPUF9OT1A3OiAxODIsXG4gICAgT1BfTk9QODogMTgzLFxuICAgIE9QX05PUDk6IDE4NCxcbiAgICBPUF9OT1AxMDogMTg1LFxuICAgIE9QX0NIRUNLU0lHQUREOiAxODYsXG4gICAgT1BfU1VDQ0VTUzE4NzogMTg3LFxuICAgIE9QX1NVQ0NFU1MxODg6IDE4OCxcbiAgICBPUF9TVUNDRVNTMTg5OiAxODksXG4gICAgT1BfU1VDQ0VTUzE5MDogMTkwLFxuICAgIE9QX1NVQ0NFU1MxOTE6IDE5MSxcbiAgICBPUF9TVUNDRVNTMTkyOiAxOTIsXG4gICAgT1BfU1VDQ0VTUzE5MzogMTkzLFxuICAgIE9QX1NVQ0NFU1MxOTQ6IDE5NCxcbiAgICBPUF9TVUNDRVNTMTk1OiAxOTUsXG4gICAgT1BfU1VDQ0VTUzE5NjogMTk2LFxuICAgIE9QX1NVQ0NFU1MxOTc6IDE5NyxcbiAgICBPUF9TVUNDRVNTMTk4OiAxOTgsXG4gICAgT1BfU1VDQ0VTUzE5OTogMTk5LFxuICAgIE9QX1NVQ0NFU1MyMDA6IDIwMCxcbiAgICBPUF9TVUNDRVNTMjAxOiAyMDEsXG4gICAgT1BfU1VDQ0VTUzIwMjogMjAyLFxuICAgIE9QX1NVQ0NFU1MyMDM6IDIwMyxcbiAgICBPUF9TVUNDRVNTMjA0OiAyMDQsXG4gICAgT1BfU1VDQ0VTUzIwNTogMjA1LFxuICAgIE9QX1NVQ0NFU1MyMDY6IDIwNixcbiAgICBPUF9TVUNDRVNTMjA3OiAyMDcsXG4gICAgT1BfU1VDQ0VTUzIwODogMjA4LFxuICAgIE9QX1NVQ0NFU1MyMDk6IDIwOSxcbiAgICBPUF9TVUNDRVNTMjEwOiAyMTAsXG4gICAgT1BfU1VDQ0VTUzIxMTogMjExLFxuICAgIE9QX1NVQ0NFU1MyMTI6IDIxMixcbiAgICBPUF9TVUNDRVNTMjEzOiAyMTMsXG4gICAgT1BfU1VDQ0VTUzIxNDogMjE0LFxuICAgIE9QX1NVQ0NFU1MyMTU6IDIxNSxcbiAgICBPUF9TVUNDRVNTMjE2OiAyMTYsXG4gICAgT1BfU1VDQ0VTUzIxNzogMjE3LFxuICAgIE9QX1NVQ0NFU1MyMTg6IDIxOCxcbiAgICBPUF9TVUNDRVNTMjE5OiAyMTksXG4gICAgT1BfU1VDQ0VTUzIyMDogMjIwLFxuICAgIE9QX1NVQ0NFU1MyMjE6IDIyMSxcbiAgICBPUF9TVUNDRVNTMjIyOiAyMjIsXG4gICAgT1BfU1VDQ0VTUzIyMzogMjIzLFxuICAgIE9QX1NVQ0NFU1MyMjQ6IDIyNCxcbiAgICBPUF9TVUNDRVNTMjI1OiAyMjUsXG4gICAgT1BfU1VDQ0VTUzIyNjogMjI2LFxuICAgIE9QX1NVQ0NFU1MyMjc6IDIyNyxcbiAgICBPUF9TVUNDRVNTMjI4OiAyMjgsXG4gICAgT1BfU1VDQ0VTUzIyOTogMjI5LFxuICAgIE9QX1NVQ0NFU1MyMzA6IDIzMCxcbiAgICBPUF9TVUNDRVNTMjMxOiAyMzEsXG4gICAgT1BfU1VDQ0VTUzIzMjogMjMyLFxuICAgIE9QX1NVQ0NFU1MyMzM6IDIzMyxcbiAgICBPUF9TVUNDRVNTMjM0OiAyMzQsXG4gICAgT1BfU1VDQ0VTUzIzNTogMjM1LFxuICAgIE9QX1NVQ0NFU1MyMzY6IDIzNixcbiAgICBPUF9TVUNDRVNTMjM3OiAyMzcsXG4gICAgT1BfU1VDQ0VTUzIzODogMjM4LFxuICAgIE9QX1NVQ0NFU1MyMzk6IDIzOSxcbiAgICBPUF9TVUNDRVNTMjQwOiAyNDAsXG4gICAgT1BfU1VDQ0VTUzI0MTogMjQxLFxuICAgIE9QX1NVQ0NFU1MyNDI6IDI0MixcbiAgICBPUF9TVUNDRVNTMjQzOiAyNDMsXG4gICAgT1BfU1VDQ0VTUzI0NDogMjQ0LFxuICAgIE9QX1NVQ0NFU1MyNDU6IDI0NSxcbiAgICBPUF9TVUNDRVNTMjQ2OiAyNDYsXG4gICAgT1BfU1VDQ0VTUzI0NzogMjQ3LFxuICAgIE9QX1NVQ0NFU1MyNDg6IDI0OCxcbiAgICBPUF9TVUNDRVNTMjQ5OiAyNDksXG4gICAgT1BfU1VDQ0VTUzI1MDogMjUwLFxuICAgIE9QX1NVQ0NFU1MyNTE6IDI1MSxcbiAgICBPUF9TVUNDRVNTMjUyOiAyNTIsXG4gICAgT1BfU1VDQ0VTUzI1MzogMjUzLFxuICAgIE9QX1NVQ0NFU1MyNTQ6IDI1NFxufTtcbmZ1bmN0aW9uIGdldE9wTGFiZWwobnVtKSB7XG4gICAgaWYgKG51bSA+IDE4NiAmJiBudW0gPCAyNTUpIHtcbiAgICAgICAgcmV0dXJuICdPUF9TVUNDRVNTJyArIFN0cmluZyhudW0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhPUENPREVfTUFQKSkge1xuICAgICAgICBpZiAodiA9PT0gbnVtKVxuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignT1BDT0RFIG5vdCBmb3VuZDonICsgU3RyaW5nKG51bSkpO1xufVxuZnVuY3Rpb24gZ2V0T3BDb2RlKHN0cmluZykge1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKE9QQ09ERV9NQVApKSB7XG4gICAgICAgIGlmIChrID09PSBzdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHYpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09QQ09ERSBub3QgZm91bmQ6JyArIHN0cmluZyk7XG59XG5mdW5jdGlvbiBnZXRXb3JkVHlwZSh3b3JkKSB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgKHdvcmQgPT09IDApOlxuICAgICAgICAgICAgcmV0dXJuICdvcGNvZGUnO1xuICAgICAgICBjYXNlICh3b3JkID49IDEgJiYgd29yZCA8PSA3NSk6XG4gICAgICAgICAgICByZXR1cm4gJ3ZhcmludCc7XG4gICAgICAgIGNhc2UgKHdvcmQgPT09IDc2KTpcbiAgICAgICAgICAgIHJldHVybiAncHVzaGRhdGExJztcbiAgICAgICAgY2FzZSAod29yZCA9PT0gNzcpOlxuICAgICAgICAgICAgcmV0dXJuICdwdXNoZGF0YTInO1xuICAgICAgICBjYXNlICh3b3JkID09PSA3OCk6XG4gICAgICAgICAgICByZXR1cm4gJ3B1c2hkYXRhNCc7XG4gICAgICAgIGNhc2UgKHdvcmQgPD0gMjU0KTpcbiAgICAgICAgICAgIHJldHVybiAnb3Bjb2RlJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3b3JkIHJhbmdlOiAke3dvcmR9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZFdvcmQod29yZCkge1xuICAgIGNvbnN0IE1JTl9SQU5HRSA9IDc1O1xuICAgIGNvbnN0IE1BWF9SQU5HRSA9IDI1NDtcbiAgICBjb25zdCBESVNBQkxFRF9PUENPREVTID0gW107XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgKHR5cGVvZiAod29yZCkgIT09ICdudW1iZXInKTpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAod29yZCA9PT0gMCk6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAoRElTQUJMRURfT1BDT0RFUy5pbmNsdWRlcyh3b3JkKSk6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgKE1JTl9SQU5HRSA8IHdvcmQgJiYgd29yZCA8IE1BWF9SQU5HRSk6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHZhbHVlLmxlbmd0aCAlIDIgPT09IDAgJiZcbiAgICAgICAgL1swLTlhLWZBLUZdLy50ZXN0KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBpc0J5dGVzJDEodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzSGV4KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xufVxuXG5jb25zdCBNQVhfV09SRF9TSVpFID0gMHgyMDg7XG5mdW5jdGlvbiBlbmNvZGVTY3JpcHQoc2NyaXB0ID0gW10sIHZhcmludCA9IHRydWUpIHtcbiAgICBsZXQgYnVmZiA9IEJ1ZmYkMS5udW0oMCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NyaXB0KSkge1xuICAgICAgICBidWZmID0gQnVmZiQxLnJhdyhlbmNvZGVXb3JkcyhzY3JpcHQpKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4KHNjcmlwdCkpIHtcbiAgICAgICAgYnVmZiA9IEJ1ZmYkMS5oZXgoc2NyaXB0KTtcbiAgICB9XG4gICAgaWYgKHNjcmlwdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgYnVmZiA9IEJ1ZmYkMS5yYXcoc2NyaXB0KTtcbiAgICB9XG4gICAgaWYgKHZhcmludCkge1xuICAgICAgICBidWZmID0gYnVmZi5wcmVmaXhTaXplKCdsZScpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZjtcbn1cbmZ1bmN0aW9uIGVuY29kZVdvcmRzKHdvcmRBcnJheSkge1xuICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgZm9yIChjb25zdCB3b3JkIG9mIHdvcmRBcnJheSkge1xuICAgICAgICB3b3Jkcy5wdXNoKGVuY29kZVdvcmQod29yZCkpO1xuICAgIH1cbiAgICByZXR1cm4gKHdvcmRzLmxlbmd0aCA+IDApXG4gICAgICAgID8gQnVmZiQxLmpvaW4od29yZHMpXG4gICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVdvcmQod29yZCkge1xuICAgIGxldCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICBpZiAodHlwZW9mICh3b3JkKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHdvcmQuc3RhcnRzV2l0aCgnT1BfJykpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmJDEubnVtKGdldE9wQ29kZSh3b3JkKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNIZXgod29yZCkpIHtcbiAgICAgICAgICAgIGJ1ZmYgPSBCdWZmJDEuaGV4KHdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmZiA9IEJ1ZmYkMS5zdHIod29yZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1ZmYgPSBCdWZmJDEuYnl0ZXMod29yZCk7XG4gICAgfVxuICAgIGlmIChidWZmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoYnVmZlswXSAhPT0gMCAmJiBidWZmWzBdIDw9IDE2KSB7XG4gICAgICAgICAgICBidWZmWzBdICs9IDB4NTA7XG4gICAgICAgICAgICByZXR1cm4gYnVmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChidWZmWzBdID4gMTI4ICYmIGJ1ZmZbMF0gPD0gMjU1KSB7XG4gICAgICAgICAgICBidWZmID0gbmV3IFVpbnQ4QXJyYXkoW2J1ZmZbMF0sIDBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZiQxLmpvaW4oW2VuY29kZVNpemUoYnVmZi5sZW5ndGgpLCBidWZmXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ1ZmYubGVuZ3RoID4gTUFYX1dPUkRfU0laRSkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IHNwbGl0V29yZChidWZmKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZVdvcmRzKHdvcmRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBCdWZmJDEuam9pbihbZW5jb2RlU2l6ZShidWZmLmxlbmd0aCksIGJ1ZmZdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmNvZGVTaXplKHNpemUpIHtcbiAgICBjb25zdCBPUF9EQVRBUFVTSDEgPSBCdWZmJDEubnVtKDB4NGMsIDEpO1xuICAgIGNvbnN0IE9QX0RBVEFQVVNIMiA9IEJ1ZmYkMS5udW0oMHg0ZCwgMSk7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgKHNpemUgPD0gMHg0Yik6XG4gICAgICAgICAgICByZXR1cm4gQnVmZiQxLm51bShzaXplKTtcbiAgICAgICAgY2FzZSAoc2l6ZSA+IDB4NGIgJiYgc2l6ZSA8IDB4MTAwKTpcbiAgICAgICAgICAgIHJldHVybiBCdWZmJDEuam9pbihbT1BfREFUQVBVU0gxLCBCdWZmJDEubnVtKHNpemUsIDEsICdsZScpXSk7XG4gICAgICAgIGNhc2UgKHNpemUgPj0gMHgxMDAgJiYgc2l6ZSA8PSBNQVhfV09SRF9TSVpFKTpcbiAgICAgICAgICAgIHJldHVybiBCdWZmJDEuam9pbihbT1BfREFUQVBVU0gyLCBCdWZmJDEubnVtKHNpemUsIDIsICdsZScpXSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgd29yZCBzaXplOicgKyBzaXplLnRvU3RyaW5nKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNwbGl0V29yZCh3b3JkKSB7XG4gICAgY29uc3Qgd29yZHMgPSBbXTtcbiAgICBjb25zdCBidWZmID0gbmV3IFN0cmVhbSQxKHdvcmQpO1xuICAgIHdoaWxlIChidWZmLnNpemUgPiBNQVhfV09SRF9TSVpFKSB7XG4gICAgICAgIHdvcmRzLnB1c2goYnVmZi5yZWFkKE1BWF9XT1JEX1NJWkUpKTtcbiAgICB9XG4gICAgd29yZHMucHVzaChidWZmLnJlYWQoYnVmZi5zaXplKSk7XG4gICAgcmV0dXJuIHdvcmRzO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVTY3JpcHQoc2NyaXB0LCB2YXJpbnQgPSBmYWxzZSkge1xuICAgIGxldCBidWZmID0gQnVmZiQxLmJ5dGVzKHNjcmlwdCk7XG4gICAgaWYgKHZhcmludCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBidWZmLnN0cmVhbTtcbiAgICAgICAgY29uc3QgbGVuID0gc3RyZWFtLnJlYWRTaXplKCdsZScpO1xuICAgICAgICBidWZmID0gYnVmZi5zbGljZSgxKTtcbiAgICAgICAgaWYgKGJ1ZmYubGVuZ3RoICE9PSBsZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFyaW50IGRvZXMgbm90IG1hdGNoIHN0cmVhbSBzaXplOiAke2xlbn0gIT09ICR7YnVmZi5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVdvcmRzKGJ1ZmYpO1xufVxuZnVuY3Rpb24gZGVjb2RlV29yZHMod29yZHMpIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtJDEod29yZHMpO1xuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgY29uc3Qgc3RhY2tTaXplID0gc3RyZWFtLnNpemU7XG4gICAgbGV0IHdvcmQ7XG4gICAgbGV0IHdvcmRUeXBlO1xuICAgIGxldCB3b3JkU2l6ZTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHdoaWxlIChjb3VudCA8IHN0YWNrU2l6ZSkge1xuICAgICAgICB3b3JkID0gc3RyZWFtLnJlYWQoMSkubnVtO1xuICAgICAgICB3b3JkVHlwZSA9IGdldFdvcmRUeXBlKHdvcmQpO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBzd2l0Y2ggKHdvcmRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICd2YXJpbnQnOlxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goc3RyZWFtLnJlYWQod29yZCkuaGV4KTtcbiAgICAgICAgICAgICAgICBjb3VudCArPSB3b3JkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHVzaGRhdGExJzpcbiAgICAgICAgICAgICAgICB3b3JkU2l6ZSA9IHN0cmVhbS5yZWFkKDEpLnJldmVyc2UoKS5udW07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChzdHJlYW0ucmVhZCh3b3JkU2l6ZSkuaGV4KTtcbiAgICAgICAgICAgICAgICBjb3VudCArPSB3b3JkU2l6ZSArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZGF0YTInOlxuICAgICAgICAgICAgICAgIHdvcmRTaXplID0gc3RyZWFtLnJlYWQoMikucmV2ZXJzZSgpLm51bTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN0cmVhbS5yZWFkKHdvcmRTaXplKS5oZXgpO1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IHdvcmRTaXplICsgMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hkYXRhNCc6XG4gICAgICAgICAgICAgICAgd29yZFNpemUgPSBzdHJlYW0ucmVhZCg0KS5yZXZlcnNlKCkubnVtO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goc3RyZWFtLnJlYWQod29yZFNpemUpLmhleCk7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gd29yZFNpemUgKyA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb3Bjb2RlJzpcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRXb3JkKHdvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPUENPREU6ICR7d29yZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChnZXRPcExhYmVsKHdvcmQpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXb3JkIHR5cGUgdW5kZWZpbmVkOiAke3dvcmR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuXG5mdW5jdGlvbiB0b0FzbShzY3JpcHQsIHZhcmludCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjcmlwdCkpIHtcbiAgICAgICAgc2NyaXB0ID0gZW5jb2RlU2NyaXB0KHNjcmlwdCwgdmFyaW50KTtcbiAgICB9XG4gICAgaWYgKHNjcmlwdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgaXNIZXgoc2NyaXB0KSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlU2NyaXB0KHNjcmlwdCwgdmFyaW50KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZvcm1hdDogJyArIFN0cmluZyh0eXBlb2Ygc2NyaXB0KSk7XG59XG5mdW5jdGlvbiB0b0J5dGVzJDQoc2NyaXB0LCB2YXJpbnQpIHtcbiAgICBpZiAoc2NyaXB0IGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICBpc0hleChzY3JpcHQpKSB7XG4gICAgICAgIHNjcmlwdCA9IGRlY29kZVNjcmlwdChzY3JpcHQsIHZhcmludCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjcmlwdCkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVNjcmlwdChzY3JpcHQsIHZhcmludCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQ6ICcgKyBTdHJpbmcodHlwZW9mIHNjcmlwdCkpO1xufVxuZnVuY3Rpb24gdG9QYXJhbShzY3JpcHQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NyaXB0KSkge1xuICAgICAgICByZXR1cm4gQnVmZiQxLmJ5dGVzKHNjcmlwdCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQ6ICcgKyBTdHJpbmcodHlwZW9mIHNjcmlwdCkpO1xufVxuY29uc3QgRm10U2NyaXB0ID0ge1xuICAgIHRvQXNtLFxuICAgIHRvQnl0ZXM6IHRvQnl0ZXMkNCxcbiAgICB0b1BhcmFtXG59O1xuXG5jb25zdCBTY3JpcHQgPSB7XG4gICAgZW5jb2RlOiBlbmNvZGVTY3JpcHQsXG4gICAgZGVjb2RlOiBkZWNvZGVTY3JpcHQsXG4gICAgZm10OiBGbXRTY3JpcHRcbn07XG5cbmZ1bmN0aW9uIG51bWJlciQyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2wkMihiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzJDIoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoJDMoaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIkMihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyJDIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMkMihpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0JDIob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzJDIob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQkMyA9IHtcbiAgICBudW1iZXI6IG51bWJlciQyLFxuICAgIGJvb2w6IGJvb2wkMixcbiAgICBieXRlczogYnl0ZXMkMixcbiAgICBoYXNoOiBoYXNoJDMsXG4gICAgZXhpc3RzOiBleGlzdHMkMixcbiAgICBvdXRwdXQ6IG91dHB1dCQyLFxufTtcbnZhciBhc3NlcnQkNCA9IGFzc2VydCQzO1xuXG5jb25zdCBjcnlwdG8kMSA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG5cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBgZ2xvYmFsVGhpcy5jcnlwdG9gLCBidXQgbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0XG4vLyBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS4gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmdcbi8vIHJld3JpdGVzIGltcG9ydCBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3JDIgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90ciQyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmNvbnN0IGlzTEUkMiA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUkMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbkFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5mdW5jdGlvbiB1dGY4VG9CeXRlcyQzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIHRvQnl0ZXMkMihkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzJDMoZGF0YSk7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0eXBlIGlzIFVpbnQ4QXJyYXkgKGdvdCAke3R5cGVvZiBkYXRhfSlgKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29uY2F0cyBVaW50OEFycmF5LXMgaW50byBvbmU7IGxpa2UgYEJ1ZmZlci5jb25jYXQoW2J1ZjEsIGJ1ZjJdKWBcbiAqIEBleGFtcGxlIGNvbmNhdEJ5dGVzKGJ1ZjEsIGJ1ZjIpXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzJDEoLi4uYXJyYXlzKSB7XG4gICAgaWYgKCFhcnJheXMuZXZlcnkoKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGxpc3QgZXhwZWN0ZWQnKTtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmxldCBIYXNoJDIgPSBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn07XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IkMihoYXNoQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtZXNzYWdlKSA9PiBoYXNoQ29uc3RydWN0b3IoKS51cGRhdGUodG9CeXRlcyQyKG1lc3NhZ2UpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGdsb2JhbFRoaXMuY3J5cHRvYCBvciBub2RlLmpzIGNyeXB0byBtb2R1bGUuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvJDEgJiYgdHlwZW9mIGNyeXB0byQxLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvJDEuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cblxuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0JDIodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmxldCBTSEEyJDIgPSBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCQyIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3JDIodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQkNC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMkMihkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXckMihkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQkNC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydCQ0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0JDIodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3JDIob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59O1xuXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpJDIgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqJDIgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0skMiA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViQyID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyQyID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmxldCBTSEEyNTYkMiA9IGNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIkMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVYkMlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWJDJbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJViQyWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVYkMlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWJDJbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJViQyWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVYkMls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWJDJbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XJDJbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1ckMltpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfVyQyW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90ciQyKFcxNSwgNykgXiByb3RyJDIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90ciQyKFcyLCAxNykgXiByb3RyJDIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1ckMltpXSA9IChzMSArIFNIQTI1Nl9XJDJbaSAtIDddICsgczAgKyBTSEEyNTZfVyQyW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIkMihFLCA2KSBeIHJvdHIkMihFLCAxMSkgXiByb3RyJDIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaSQyKEUsIEYsIEcpICsgU0hBMjU2X0skMltpXSArIFNIQTI1Nl9XJDJbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIkMihBLCAyKSBeIHJvdHIkMihBLCAxMykgXiByb3RyJDIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqJDIoQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVyQyLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn07XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5sZXQgU0hBMjI0JDIgPSBjbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYkMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59O1xuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuY29uc3Qgc2hhMjU2JDMgPSB3cmFwQ29uc3RydWN0b3IkMigoKSA9PiBuZXcgU0hBMjU2JDIoKSk7XG53cmFwQ29uc3RydWN0b3IkMigoKSA9PiBuZXcgU0hBMjI0JDIoKSk7XG5cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IF8wbiQ4ID0gQmlnSW50KDApO1xuY29uc3QgXzFuJDUgPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4kNCA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSQxID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleCQxKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEkMShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQmlnIEVuZGlhblxuICAgIHJldHVybiBCaWdJbnQoaGV4ID09PSAnJyA/ICcwJyA6IGAweCR7aGV4fWApO1xufVxuLy8gQ2FjaGluZyBzbG93cyBpdCBkb3duIDItM3hcbmZ1bmN0aW9uIGhleFRvQnl0ZXMkMShoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBpcyBpbnZhbGlkOiB1bnBhZGRlZCAnICsgaGV4Lmxlbmd0aCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQmlnIEVuZGlhblxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgkMShieXRlcykpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEkMShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4JDEoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmNvbnN0IG51bWJlclRvQnl0ZXNCRSA9IChuLCBsZW4pID0+IGhleFRvQnl0ZXMkMShuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbmNvbnN0IG51bWJlclRvQnl0ZXNMRSA9IChuLCBsZW4pID0+IG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbi8vIFJldHVybnMgdmFyaWFibGUgbnVtYmVyIGJ5dGVzIChtaW5pbWFsIGJpZ2ludCBlbmNvZGluZz8pXG5jb25zdCBudW1iZXJUb1ZhckJ5dGVzQkUgPSAobikgPT4gaGV4VG9CeXRlcyQxKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xuZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyQxKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEkMShoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJycykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJycy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhJDEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZnVuY3Rpb24gZXF1YWxCeXRlcyhiMSwgYjIpIHtcbiAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRpbWluZyBhdHRhY2tzIGhlcmVcbiAgICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMkMihzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vLyBBbW91bnQgb2YgYml0cyBpbnNpZGUgYmlnaW50IChTYW1lIGFzIG4udG9TdHJpbmcoMikubGVuZ3RoKVxuZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IDBuOyBuID4+PSBfMW4kNSwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLy8gR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4vLyBTYW1lIGFzICEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11cbmNvbnN0IGJpdEdldCA9IChuLCBwb3MpID0+IChuID4+IEJpZ0ludChwb3MpKSAmIDFuO1xuLy8gU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uXG5jb25zdCBiaXRTZXQgPSAobiwgcG9zLCB2YWx1ZSkgPT4gbiB8ICgodmFsdWUgPyBfMW4kNSA6IF8wbiQ4KSA8PCBCaWdJbnQocG9zKSk7XG4vLyBSZXR1cm4gbWFzayBmb3IgTiBiaXRzIChTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKSlcbi8vIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgZm9yIG9sZCBlbmdpbmVzLlxuY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuJDQgPDwgQmlnSW50KG4gLSAxKSkgLSBfMW4kNTtcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuXG52YXIgdXQgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGJpdEdldDogYml0R2V0LFxuICAgIGJpdExlbjogYml0TGVuLFxuICAgIGJpdE1hc2s6IGJpdE1hc2ssXG4gICAgYml0U2V0OiBiaXRTZXQsXG4gICAgYnl0ZXNUb0hleDogYnl0ZXNUb0hleCQxLFxuICAgIGJ5dGVzVG9OdW1iZXJCRTogYnl0ZXNUb051bWJlckJFLFxuICAgIGJ5dGVzVG9OdW1iZXJMRTogYnl0ZXNUb051bWJlckxFLFxuICAgIGNvbmNhdEJ5dGVzOiBjb25jYXRCeXRlcyxcbiAgICBjcmVhdGVIbWFjRHJiZzogY3JlYXRlSG1hY0RyYmcsXG4gICAgZW5zdXJlQnl0ZXM6IGVuc3VyZUJ5dGVzLFxuICAgIGVxdWFsQnl0ZXM6IGVxdWFsQnl0ZXMsXG4gICAgaGV4VG9CeXRlczogaGV4VG9CeXRlcyQxLFxuICAgIGhleFRvTnVtYmVyOiBoZXhUb051bWJlcixcbiAgICBudW1iZXJUb0J5dGVzQkU6IG51bWJlclRvQnl0ZXNCRSxcbiAgICBudW1iZXJUb0J5dGVzTEU6IG51bWJlclRvQnl0ZXNMRSxcbiAgICBudW1iZXJUb0hleFVucGFkZGVkOiBudW1iZXJUb0hleFVucGFkZGVkLFxuICAgIG51bWJlclRvVmFyQnl0ZXNCRTogbnVtYmVyVG9WYXJCeXRlc0JFLFxuICAgIHV0ZjhUb0J5dGVzOiB1dGY4VG9CeXRlcyQyLFxuICAgIHZhbGlkYXRlT2JqZWN0OiB2YWxpZGF0ZU9iamVjdFxufSk7XG5cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4kNyA9IEJpZ0ludCgwKSwgXzFuJDQgPSBCaWdJbnQoMSksIF8ybiQzID0gQmlnSW50KDIpLCBfM24kMiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuJDIgPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5CaWdJbnQoOSk7IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4kNyA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGV4cG9uZW50aWF0ZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93TW9kKDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5mdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4kNyB8fCBwb3dlciA8IF8wbiQ3KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4kNClcbiAgICAgICAgcmV0dXJuIF8wbiQ3O1xuICAgIGxldCByZXMgPSBfMW4kNDtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4kNykge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4kNClcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbiQ0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4kNykge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5mdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4kNyB8fCBtb2R1bG8gPD0gXzBuJDcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsZWRpYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuJDcsIHUgPSBfMW4kNDtcbiAgICB3aGlsZSAoYSAhPT0gXzBuJDcpIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHUgPSBtO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbiQ0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbi8vIFBhcGVyIDE6IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbi8vIFBhcGVyIDI6IFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuJDQpIC8gXzJuJDM7XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4kNCwgUyA9IDA7IFEgJSBfMm4kMyA9PT0gXzBuJDc7IFEgLz0gXzJuJDMsIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuJDM7IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuJDQ7IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuJDQpIC8gXzRuJDI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4kNCkgLyBfMm4kMztcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuJDQgPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4kMiA9PT0gXzNuJDIpIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbiQ0KSAvIF80biQyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuJDMpO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuJDMpLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4kNylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbiQ3KVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4kNClcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbiQ3KSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbiQ0KVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW4kNDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vLyAwIGlzIG5vbi1pbnZlcnRpYmxlOiBub24tYmF0Y2hlZCB2ZXJzaW9uIHdpbGwgdGhyb3cgb24gMFxuZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZ2Fsb2lzIGZpZWxkIG92ZXIgcHJpbWUuIE5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdy5cbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBnYWluczpcbiAqIGEpIG5vbi1ub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiBiKSBgT2JqZWN0LmZyZWV6ZWBcbiAqIGMpIFNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBGaWVsZCQxKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4kNylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGcCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbiQ3LFxuICAgICAgICBPTkU6IF8xbiQ0LFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuJDcgPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4kNyxcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4kNCkgPT09IF8xbiQ0LFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbi8qKlxuICogRklQUyAxODYgQi40LjEtY29tcGxpYW50IFwiY29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuKzgpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQwIGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5mdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbiQ0KSArIF8xbiQ0O1xufVxuXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuY29uc3QgXzBuJDYgPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4kMyA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbiQ2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4kMylcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbiQzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbiQzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG5cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5jb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgcmVzWzFdIDw9IDB4N2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdHJhaWxpbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIF4gV2VpcmQgY29uZGl0aW9uOiBub3QgYWJvdXQgbGVuZ3RoLCBidXQgYWJvdXQgZmlyc3QgYnl0ZXMgb2YgbnVtYmVyLlxuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndWk4YSBleHBlY3RlZCcpO1xuICAgICAgICBsZXQgbCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCA8IDIgfHwgZGF0YVswXSAhPSAweDMwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIHRhZycpO1xuICAgICAgICBpZiAoZGF0YVsxXSAhPT0gbCAtIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICAgICAgY29uc3QgeyBkOiByLCBsOiBzQnl0ZXMgfSA9IERFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgICAgIGNvbnN0IHsgZDogcywgbDogckJ5dGVzTGVmdCB9ID0gREVSLl9wYXJzZUludChzQnl0ZXMpO1xuICAgICAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByLCBzIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSA+PSA4ID8gJzAwJyArIHMgOiBzKTsgLy8gc2xpY2UgREVSXG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiQ1ID0gQmlnSW50KDApLCBfMW4kMiA9IEJpZ0ludCgxKSwgXzJuJDIgPSBCaWdJbnQoMiksIF8zbiQxID0gQmlnSW50KDMpLCBfNG4kMSA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKGMsIHBvaW50LCBpc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiQ1IDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgIGtleSA9IGJ5dGVzVG9IZXgkMShrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiBieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBaZXJvIGlzIHZhbGlkIHBvaW50IHRvbyFcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbiQxKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbiQxKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShuKSB7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4kNSlcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4kMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4kNSB8fCBrMiA+IF8wbiQ1KSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuJDIpXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuJDIpXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbiQyO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW4kMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuJDUgfHwgYSA9PT0gXzFuJDIgfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4kMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuJDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCQxKHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuJDUgPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIGludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhjLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSBjb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbiQyKSA9PT0gXzFuJDI7XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IGJ5dGVzVG9IZXgkMShudW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbiQyO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIC8vIGNhbiB1c2UgYXNzZXJ0R0UgaGVyZVxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAwIDwgciA8IENVUlZFLm4nKTtcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzIG11c3QgYmUgMCA8IHMgPCBDVVJWRS5uJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzJDEodGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMkMSh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZSAobkJpdExlbmd0aCs2NClcbiAgICAgICAgICogYXMgcGVyIEZJUFMgMTg2IEIuNC4xIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlibGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5kID0gQ1VSVkUucmFuZG9tQnl0ZXMoRnAuQllURVMgKyA4KTtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9IGhhc2hUb1ByaXZhdGVTY2FsYXIocmFuZCwgQ1VSVkVfT1JERVIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiQ1IDw9IG51bSAmJiBudW0gPCBPUkRFUl9NQVNLKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmlnaW50IGV4cGVjdGVkIDwgMl4ke0NVUlZFLm5CaXRMZW5ndGh9YCk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLCB0aGlzIHdpbGwgYmUgd3JvbmcgYXQgbGVhc3QgZm9yIFA1MjEuXG4gICAgLy8gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSwgRnAuQllURVMpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9mIHNpemUgQllURVNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4kNSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4kNSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbiQyKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggKG5vdCBtZXNzYWdlOiB5b3UgbmVlZCB0byBoYXNoIGl0IGJ5IHlvdXJzZWxmKS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBvcHRzIGBsb3dTLCBleHRyYUVudHJvcHksIHByZWhhc2hgXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEcmJnKENVUlZFLmhhc2gub3V0cHV0TGVuLCBDVVJWRS5uQnl0ZUxlbmd0aCwgQ1VSVkUuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHNnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLy8gSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgV2VpZXJzdHJhc3MgY3VydmVcbi8vIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHMgJiYgbW92ZSB0byBtb2R1bGFyP1xuLy8gYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbi8vIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbmZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbiQ1O1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuJDI7IG8gJSBfMm4kMiA9PT0gXzBuJDU7IG8gLz0gXzJuJDIpXG4gICAgICAgIGwgKz0gXzFuJDI7XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4kMikgLyBfMm4kMiAqKiBjMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuJDIpIC8gXzJuJDI7IC8vIDMuIGMzID0gKGMyIC0gMSkgLyAyICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNCA9IF8ybiQyICoqIGMxIC0gXzFuJDI7IC8vIDQuIGM0ID0gMl5jMSAtIDEgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNSA9IF8ybiQyICoqIChjMSAtIF8xbiQyKTsgLy8gNS4gYzUgPSAyXihjMSAtIDEpICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuJDIpIC8gXzJuJDIpOyAvLyA3LiBjNyA9IFpeKChjMiArIDEpIC8gMilcbiAgICBsZXQgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgbGV0IHR2MSA9IGM2OyAvLyAxLiB0djEgPSBjNlxuICAgICAgICBsZXQgdHYyID0gRnAucG93KHYsIGM0KTsgLy8gMi4gdHYyID0gdl5jNFxuICAgICAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIHYpOyAvLyA0LiB0djMgPSB0djMgKiB2XG4gICAgICAgIGxldCB0djUgPSBGcC5tdWwodSwgdHYzKTsgLy8gNS4gdHY1ID0gdSAqIHR2M1xuICAgICAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xuICAgICAgICB0djUgPSBGcC5tdWwodHY1LCB0djIpOyAvLyA3LiB0djUgPSB0djUgKiB0djJcbiAgICAgICAgdHYyID0gRnAubXVsKHR2NSwgdik7IC8vIDguIHR2MiA9IHR2NSAqIHZcbiAgICAgICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcbiAgICAgICAgbGV0IHR2NCA9IEZwLm11bCh0djMsIHR2Mik7IC8vIDEwLiB0djQgPSB0djMgKiB0djJcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NCwgYzUpOyAvLyAxMS4gdHY1ID0gdHY0XmM1XG4gICAgICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxuICAgICAgICB0djIgPSBGcC5tdWwodHYzLCBjNyk7IC8vIDEzLiB0djIgPSB0djMgKiBjN1xuICAgICAgICB0djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAxNC4gdHY1ID0gdHY0ICogdHYxXG4gICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcbiAgICAgICAgdHY0ID0gRnAuY21vdih0djUsIHR2NCwgaXNRUik7IC8vIDE2LiB0djQgPSBDTU9WKHR2NSwgdHY0LCBpc1FSKVxuICAgICAgICAvLyAxNy4gZm9yIGkgaW4gKGMxLCBjMSAtIDEsIC4uLiwgMik6XG4gICAgICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IDE7IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IF8ybiQyICoqIChpIC0gXzJuJDIpOyAvLyAxOC4gICAgdHY1ID0gaSAtIDI7ICAgIDE5LiAgICB0djUgPSAyXnR2NVxuICAgICAgICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxuICAgICAgICAgICAgY29uc3QgZTEgPSBGcC5lcWwodHZ2NSwgRnAuT05FKTsgLy8gMjEuICAgIGUxID0gdHY1ID09IDFcbiAgICAgICAgICAgIHR2MiA9IEZwLm11bCh0djMsIHR2MSk7IC8vIDIyLiAgICB0djIgPSB0djMgKiB0djFcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcbiAgICAgICAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAyNC4gICAgdHY1ID0gdHY0ICogdHYxXG4gICAgICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBlMSk7IC8vIDI1LiAgICB0djMgPSBDTU9WKHR2MiwgdHYzLCBlMSlcbiAgICAgICAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogdHYzIH07XG4gICAgfTtcbiAgICBpZiAoRnAuT1JERVIgJSBfNG4kMSA9PT0gXzNuJDEpIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbiQxKSAvIF80biQxOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vLyBGcm9tIGRyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTE2XG5mdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgdmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEU1QoZHN0KSB7XG4gICAgaWYgKGRzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgaWYgKHR5cGVvZiBkc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMkMihkc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbn1cbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhpdGVtKSB7XG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGlzTnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xMSNzZWN0aW9uLTUuNC4xXG5mdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTYjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzJDIoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gY29uY2F0Qnl0ZXMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKGNvbmNhdEJ5dGVzKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKGNvbmNhdEJ5dGVzKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTE2I3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzJDIoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG4vKipcbiAqIEhhc2hlcyBhcmJpdHJhcnktbGVuZ3RoIGJ5dGUgc3RyaW5ncyB0byBhIGxpc3Qgb2Ygb25lIG9yIG1vcmUgZWxlbWVudHMgb2YgYSBmaW5pdGUgZmllbGQgRlxuICogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xMSNzZWN0aW9uLTUuM1xuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmcnLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc051bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdmFsaWRhdGVEU1QoX0RTVCk7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiwgXCJ4b2ZcIiBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlXG4gICAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTYjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTYjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vLyBITUFDIChSRkMgMjEwNClcbmxldCBITUFDJDEgPSBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCQyIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0JDQuaGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyQyKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnQkNC5leGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQkNC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydCQ0LmJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn07XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuY29uc3QgaG1hYyQyID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMkMShoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMkMi5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyQxKGhhc2gsIGtleSk7XG5cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMkMihoYXNoLCBrZXksIGNvbmNhdEJ5dGVzJDEoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuJDEgPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4kMSA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuJDEpIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybiQxLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4kMSwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSBGaWVsZCQxKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5jb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4kMSAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1NiQzKTtcbi8vIFNjaG5vcnIgc2lnbmF0dXJlcyBhcmUgc3VwZXJpb3IgdG8gRUNEU0EgZnJvbSBhYm92ZS4gQmVsb3cgaXMgU2Nobm9yci1zcGVjaWZpYyBCSVAwMzQwIGNvZGUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuY29uc3QgXzBuJDQgPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuJDQgPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiQ0IDwgeCAmJiB4IDwgc2VjcDI1NmsxTjtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2JDMoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2JDMoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAkMSA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROJDEgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQkMiA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50JDIuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgbGV0IGRfID0gc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludCQyLmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTiQxKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQJDEoeCAqIHgpO1xuICAgIGNvbnN0IGMgPSBtb2RQJDEoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4kMSAhPT0gXzBuJDQpXG4gICAgICAgIHkgPSBtb2RQJDEoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50JDIoeCwgeSwgXzFuJDEpOyAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cbiAgICBwLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIENyZWF0ZSB0YWdnZWQgaGFzaCwgY29udmVydCBpdCB0byBiaWdpbnQsIHJlZHVjZSBtb2R1bG8tbi5cbiAqL1xuZnVuY3Rpb24gY2hhbGxlbmdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbW9kTiQxKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTiQxKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuJDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGsgaXMgemVybycpOyAvLyBGYWlsIGlmIGsnID0gMC5cbiAgICBjb25zdCB7IGJ5dGVzOiByeCwgc2NhbGFyOiBrIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KGtfKTsgLy8gTGV0IFIgPSBrJ+KLhUcuXG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICAgIHNpZy5zZXQocngsIDApO1xuICAgIHNpZy5zZXQobnVtVG8zMmIobW9kTiQxKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4kMSgtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBzY2hub3JyID0ge1xuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgdXRpbHM6IHtcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkUsXG4gICAgICAgIGJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kLFxuICAgIH0sXG59O1xuY29uc3QgaXNvTWFwID0gaXNvZ2VueU1hcChGcCwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxuICAgICAgICAnMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyJyxcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICAnMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliJyxcbiAgICAgICAgJzB4ZWRhZGM2ZjY0MzgzZGMxZGY3YzRiMmQ1MWI1NDIyNTQwNmQzNmI2NDFmNWU0MWJiYzUyYTU2NjEyYThjNmQxNCcsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxuICAgICAgICAnMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzJyxcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxuICAgIF0sXG4gICAgLy8geURlblxuICAgIFtcbiAgICAgICAgJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYicsXG4gICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxuICAgICAgICAnMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpKTtcbmNvbnN0IG1hcFNXVSA9IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pO1xuY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1NiQzLFxufSk7XG5cbmZ1bmN0aW9uIG51bWJlciQxKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2wkMShiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzJDEoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoJDIoaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIkMShoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyJDEoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMkMShpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0JDEob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzJDEob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQkMSQxID0ge1xuICAgIG51bWJlcjogbnVtYmVyJDEsXG4gICAgYm9vbDogYm9vbCQxLFxuICAgIGJ5dGVzOiBieXRlcyQxLFxuICAgIGhhc2g6IGhhc2gkMixcbiAgICBleGlzdHM6IGV4aXN0cyQxLFxuICAgIG91dHB1dDogb3V0cHV0JDEsXG59O1xudmFyIGFzc2VydCQyID0gYXNzZXJ0JDEkMTtcblxuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3JDEgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90ciQxID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmNvbnN0IGlzTEUkMSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUkMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbkFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5mdW5jdGlvbiB1dGY4VG9CeXRlcyQxKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIHRvQnl0ZXMkMShkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzJDEoZGF0YSk7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0eXBlIGlzIFVpbnQ4QXJyYXkgKGdvdCAke3R5cGVvZiBkYXRhfSlgKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5sZXQgSGFzaCQxID0gY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yJDEoaGFzaENvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobWVzc2FnZSkgPT4gaGFzaENvbnN0cnVjdG9yKCkudXBkYXRlKHRvQnl0ZXMkMShtZXNzYWdlKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5cbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCQxKHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5sZXQgU0hBMiQxID0gY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gkMSB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyQxKHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0JDIuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzJDEoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3JDEoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0JDIuZXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnQkMi5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCQxKHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyQxKG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufTtcblxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSQxID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiQxID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LJDEgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYkMSA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1ckMSA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5sZXQgU0hBMjU2JDEgPSBjbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyJDEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWJDFbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJViQxWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVYkMVsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWJDFbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJViQxWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVYkMVs1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWJDFbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJViQxWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfVyQxW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XJDFbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1ckMVtpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIkMShXMTUsIDcpIF4gcm90ciQxKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIkMShXMiwgMTcpIF4gcm90ciQxKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XJDFbaV0gPSAoczEgKyBTSEEyNTZfVyQxW2kgLSA3XSArIHMwICsgU0hBMjU2X1ckMVtpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyJDEoRSwgNikgXiByb3RyJDEoRSwgMTEpIF4gcm90ciQxKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkkMShFLCBGLCBHKSArIFNIQTI1Nl9LJDFbaV0gKyBTSEEyNTZfVyQxW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyJDEoQSwgMikgXiByb3RyJDEoQSwgMTMpIF4gcm90ciQxKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haiQxKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1ckMS5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59O1xuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxubGV0IFNIQTIyNCQxID0gY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2JDEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufTtcbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmNvbnN0IHNoYTI1NiQyID0gd3JhcENvbnN0cnVjdG9yJDEoKCkgPT4gbmV3IFNIQTI1NiQxKCkpO1xud3JhcENvbnN0cnVjdG9yJDEoKCkgPT4gbmV3IFNIQTIyNCQxKCkpO1xuXG5mdW5jdGlvbiB3aXRoaW5fc2l6ZShkYXRhLCBzaXplKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBEYXRhIGlzIGxhcmdlciB0aGFuIGFycmF5IHNpemU6ICR7ZGF0YS5sZW5ndGh9ID4gJHtzaXplfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzX2hleChoZXgpIHtcbiAgICBpZiAoaGV4Lm1hdGNoKC9bXmEtZkEtZjAtOV0vKSAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlcnMgaW4gaGV4IHN0cmluZzogJyArIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExlbmd0aCBvZiBoZXggc3RyaW5nIGlzIGludmFsaWQ6ICR7aGV4Lmxlbmd0aH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc19zYWZlX251bShudW0pIHtcbiAgICBpZiAobnVtID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTnVtYmVyIGV4Y2VlZHMgc2FmZSBib3VuZHMhJyk7XG4gICAgfVxufVxuXG5jb25zdCB7IGdldFJhbmRvbVZhbHVlcyB9ID0gY3J5cHRvID8/IGdsb2JhbFRoaXMuY3J5cHRvID8/IHdpbmRvdy5jcnlwdG87XG5mdW5jdGlvbiByYW5kb20kMShzaXplID0gMzIpIHtcbiAgICBpZiAodHlwZW9mIGdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQ3J5cHRvIG1vZHVsZSBtaXNzaW5nIGdldFJhbmRvbVZhbHVlcyEnKTtcbn1cbmZ1bmN0aW9uIHNldF9idWZmZXIoZGF0YSwgc2l6ZSwgZW5kaWFuID0gJ2JlJykge1xuICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpXG4gICAgICAgIHNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICB3aXRoaW5fc2l6ZShkYXRhLCBzaXplKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzaXplKS5maWxsKDApO1xuICAgIGNvbnN0IG9mZnNldCA9IChlbmRpYW4gPT09ICdiZScpID8gMCA6IHNpemUgLSBkYXRhLmxlbmd0aDtcbiAgICBidWZmZXIuc2V0KGRhdGEsIG9mZnNldCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGpvaW5fYXJyYXkoYXJyKSB7XG4gICAgbGV0IGksIG9mZnNldCA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IGFyci5yZWR1Y2UoKGxlbiwgYXJyKSA9PiBsZW4gKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyW2ldO1xuICAgICAgICBidWZmLnNldChhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWZmO1xufVxuXG5jb25zdCBlYyQyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBBTFBIQUJFVFMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnYmFzZTU4JyxcbiAgICAgICAgY2hhcnNldDogJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG4gICAgfVxuXTtcbmZ1bmN0aW9uIGdldEFscGhhYmV0KG5hbWUpIHtcbiAgICBmb3IgKGNvbnN0IGFscGhhIG9mIEFMUEhBQkVUUykge1xuICAgICAgICBpZiAoYWxwaGEubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFscGhhLmNoYXJzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgVHlwZUVycm9yKCdDaGFyc2V0IGRvZXMgbm90IGV4aXN0OiAnICsgbmFtZSk7XG59XG5mdW5jdGlvbiBlbmNvZGUkMSQxKGRhdGEsIGNoYXJzZXQsIHBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSBlYyQyLmVuY29kZShkYXRhKTtcbiAgICBjb25zdCBhbHBoYWJldCA9IGdldEFscGhhYmV0KGNoYXJzZXQpO1xuICAgIGNvbnN0IGxlbiA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgICBjb25zdCBkID0gW107XG4gICAgbGV0IHMgPSAnJywgaSwgaiA9IDAsIGMsIG47XG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGMgPSBkYXRhW2ldO1xuICAgICAgICBzICs9IChjID4gMCB8fCAocy5sZW5ndGggXiBpKSA+IDApID8gJycgOiAnMSc7XG4gICAgICAgIHdoaWxlIChqIGluIGQgfHwgYyA+IDApIHtcbiAgICAgICAgICAgIG4gPSBkW2pdO1xuICAgICAgICAgICAgbiA9IG4gPiAwID8gbiAqIDI1NiArIGMgOiBjO1xuICAgICAgICAgICAgYyA9IG4gLyBsZW4gfCAwO1xuICAgICAgICAgICAgZFtqXSA9IG4gJSBsZW47XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgcyArPSBhbHBoYWJldFtkW2pdXTtcbiAgICB9XG4gICAgcmV0dXJuIChwYWRkaW5nICYmIHMubGVuZ3RoICUgNCA+IDApXG4gICAgICAgID8gcyArICc9Jy5yZXBlYXQoNCAtIHMubGVuZ3RoICUgNClcbiAgICAgICAgOiBzO1xufVxuZnVuY3Rpb24gZGVjb2RlJDEkMShlbmNvZGVkLCBjaGFyc2V0KSB7XG4gICAgY29uc3QgYWxwaGFiZXQgPSBnZXRBbHBoYWJldChjaGFyc2V0KTtcbiAgICBjb25zdCBsZW4gPSBhbHBoYWJldC5sZW5ndGgsIGQgPSBbXSwgYiA9IFtdO1xuICAgIGVuY29kZWQgPSBlbmNvZGVkLnJlcGxhY2UoJz0nLCAnJyk7XG4gICAgbGV0IGksIGogPSAwLCBjLCBuO1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGogPSAwO1xuICAgICAgICBjID0gYWxwaGFiZXQuaW5kZXhPZihlbmNvZGVkW2ldKTtcbiAgICAgICAgaWYgKGMgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYXJhY3RlciByYW5nZSBvdXQgb2YgYm91bmRzOiAke2N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoYyA+IDAgfHwgKGIubGVuZ3RoIF4gaSkgPiAwKSlcbiAgICAgICAgICAgIGIucHVzaCgwKTtcbiAgICAgICAgd2hpbGUgKGogaW4gZCB8fCBjID4gMCkge1xuICAgICAgICAgICAgbiA9IGRbal07XG4gICAgICAgICAgICBuID0gbiA+IDAgPyBuICogbGVuICsgYyA6IGM7XG4gICAgICAgICAgICBjID0gbiA+PiA4O1xuICAgICAgICAgICAgZFtqXSA9IG4gJSAyNTY7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgYi5wdXNoKGRbal0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYik7XG59XG5mdW5jdGlvbiBoYXNoMjU2JDEoZGF0YSkge1xuICAgIHJldHVybiBzaGEyNTYkMihzaGEyNTYkMihkYXRhKSk7XG59XG5mdW5jdGlvbiBhZGRDaGVja3N1bShkYXRhKSB7XG4gICAgY29uc3Qgc3VtID0gaGFzaDI1NiQxKGRhdGEpO1xuICAgIHJldHVybiBqb2luX2FycmF5KFtkYXRhLCBzdW0uc2xpY2UoMCwgNCldKTtcbn1cbmZ1bmN0aW9uIGNoZWNrVGhlU3VtKGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBkYXRhLnNsaWNlKDAsIC00KTtcbiAgICBjb25zdCBjaGsgPSBkYXRhLnNsaWNlKC00KTtcbiAgICBjb25zdCBzdW0gPSBoYXNoMjU2JDEocmV0KS5zbGljZSgwLCA0KTtcbiAgICBpZiAoc3VtLnRvU3RyaW5nKCkgIT09IGNoay50b1N0cmluZygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bSEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IEJhc2VYID0ge1xuICAgIGVuY29kZTogZW5jb2RlJDEkMSxcbiAgICBkZWNvZGU6IGRlY29kZSQxJDFcbn07XG5jb25zdCBCYXNlNThDID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3Qgd2l0aFN1bSA9IGFkZENoZWNrc3VtKGRhdGEpO1xuICAgICAgICByZXR1cm4gQmFzZVguZW5jb2RlKHdpdGhTdW0sICdiYXNlNTgnKTtcbiAgICB9LFxuICAgIGRlY29kZTogKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEJhc2VYLmRlY29kZShkYXRhLCAnYmFzZTU4Jyk7XG4gICAgICAgIHJldHVybiBjaGVja1RoZVN1bShkZWNvZGVkKTtcbiAgICB9XG59O1xuXG5jb25zdCBDSEFSU0VUID0gJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJztcbmNvbnN0IEdFTkVSQVRPUiA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmNvbnN0IEVOQ09ESU5HUyA9IFtcbiAgICB7IHZlcnNpb246IDAsIG5hbWU6ICdiZWNoMzInLCBjb25zdDogMSB9LFxuICAgIHsgdmVyc2lvbjogMSwgbmFtZTogJ2JlY2gzMm0nLCBjb25zdDogMHgyYmM4MzBhMyB9XG5dO1xuZnVuY3Rpb24gcG9seW1vZCh2YWx1ZXMpIHtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8IHZhbHVlcy5sZW5ndGg7ICsrcCkge1xuICAgICAgICBjb25zdCB0b3AgPSBjaGsgPj4gMjU7XG4gICAgICAgIGNoayA9IChjaGsgJiAweDFmZmZmZmYpIDw8IDUgXiB2YWx1ZXNbcF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoKCh0b3AgPj4gaSkgJiAxKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNoayBePSBHRU5FUkFUT1JbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGhycEV4cGFuZChocnApIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBsZXQgcDtcbiAgICBmb3IgKHAgPSAwOyBwIDwgaHJwLmxlbmd0aDsgKytwKSB7XG4gICAgICAgIHJldC5wdXNoKGhycC5jaGFyQ29kZUF0KHApID4+IDUpO1xuICAgIH1cbiAgICByZXQucHVzaCgwKTtcbiAgICBmb3IgKHAgPSAwOyBwIDwgaHJwLmxlbmd0aDsgKytwKSB7XG4gICAgICAgIHJldC5wdXNoKGhycC5jaGFyQ29kZUF0KHApICYgMzEpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdmVyaWZ5Q2hlY2tzdW0oaHJwLCBkYXRhLCBlbmMpIHtcbiAgICBjb25zdCBjb21iaW5lZCA9IGhycEV4cGFuZChocnApLmNvbmNhdChkYXRhKTtcbiAgICByZXR1cm4gcG9seW1vZChjb21iaW5lZCkgPT09IGVuYy5jb25zdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoZWNrc3VtKGhycCwgZGF0YSwgZW5jKSB7XG4gICAgY29uc3QgdmFsdWVzID0gaHJwRXhwYW5kKGhycCkuY29uY2F0KGRhdGEpLmNvbmNhdChbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgIGNvbnN0IG1vZCA9IHBvbHltb2QodmFsdWVzKSBeIGVuYy5jb25zdDtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8IDY7ICsrcCkge1xuICAgICAgICByZXQucHVzaCgobW9kID4+IDUgKiAoNSAtIHApKSAmIDMxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCaXRzKGRhdGEsIGZyb21CaXRzLCB0b0JpdHMsIHBhZCA9IHRydWUpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBsZXQgYWNjID0gMDtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgY29uc3QgbWF4VmFsID0gKDEgPDwgdG9CaXRzKSAtIDE7XG4gICAgY29uc3QgbWF4QWNjID0gKDEgPDwgKGZyb21CaXRzICsgdG9CaXRzIC0gMSkpIC0gMTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBkYXRhKSB7XG4gICAgICAgIGlmICh2YWwgPCAwIHx8ICh2YWwgPj4gZnJvbUJpdHMpID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGVyZm9ybSBiYXNlIGNvbnZlcnNpb24uIEludmFsaWQgdmFsdWU6ICcgKyBTdHJpbmcodmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWNjID0gKChhY2MgPDwgZnJvbUJpdHMpIHwgdmFsKSAmIG1heEFjYztcbiAgICAgICAgYml0cyArPSBmcm9tQml0cztcbiAgICAgICAgd2hpbGUgKGJpdHMgPj0gdG9CaXRzKSB7XG4gICAgICAgICAgICBiaXRzIC09IHRvQml0cztcbiAgICAgICAgICAgIHJldC5wdXNoKChhY2MgPj4gYml0cykgJiBtYXhWYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYWQpIHtcbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICByZXQucHVzaCgoYWNjIDw8ICh0b0JpdHMgLSBiaXRzKSkgJiBtYXhWYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpdHMgPj0gZnJvbUJpdHMgfHwgKChhY2MgPDwgKHRvQml0cyAtIGJpdHMpKSAmIG1heFZhbCkgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBlcmZvcm0gYmFzZSBjb252ZXJzaW9uLiBJbnZhbGlkIFNpemUhJyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBlbmNvZGUkNShocnAsIGRhdGEsIGVuYykge1xuICAgIGNvbnN0IGNvbWJpbmVkID0gZGF0YS5jb25jYXQoY3JlYXRlQ2hlY2tzdW0oaHJwLCBkYXRhLCBlbmMpKTtcbiAgICBsZXQgcmV0ID0gaHJwICsgJzEnO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDwgY29tYmluZWQubGVuZ3RoOyArK3ApIHtcbiAgICAgICAgcmV0ICs9IENIQVJTRVQuY2hhckF0KGNvbWJpbmVkW3BdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGRlY29kZSQ1KGJlY2hzdHIpIHtcbiAgICBpZiAoIWNoZWNrQm91bmRzKGJlY2hzdHIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb2RlZCBzdHJpbmcgZ29lcyBvdXQgb2YgYm91bmRzIScpO1xuICAgIH1cbiAgICBiZWNoc3RyID0gYmVjaHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghY2hlY2tTZXBhcmF0b3JQb3MoYmVjaHN0cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGVkIHN0cmluZyBoYXMgaW52YWxpZCBzZXBhcmF0b3IhJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBjb25zdCBwb3MgPSBiZWNoc3RyLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgY29uc3QgaHJwID0gYmVjaHN0ci5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICBmb3IgKGxldCBwID0gcG9zICsgMTsgcCA8IGJlY2hzdHIubGVuZ3RoOyArK3ApIHtcbiAgICAgICAgY29uc3QgZCA9IENIQVJTRVQuaW5kZXhPZihiZWNoc3RyLmNoYXJBdChwKSk7XG4gICAgICAgIGlmIChkID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFyYWN0ZXIgaWR4IG91dCBvZiBib3VuZHM6ICcgKyBTdHJpbmcocCkpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucHVzaChkKTtcbiAgICB9XG4gICAgY29uc3QgZW5jID0gRU5DT0RJTkdTLmZpbmQoZSA9PiBlLnZlcnNpb24gPT09IGRhdGFbMF0pID8/IEVOQ09ESU5HU1swXTtcbiAgICBpZiAoIXZlcmlmeUNoZWNrc3VtKGhycCwgZGF0YSwgZW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoZWNrc3VtIHZlcmlmaWNhdGlvbiBmYWlsZWQhJyk7XG4gICAgfVxuICAgIHJldHVybiBbaHJwLCBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gNildO1xufVxuZnVuY3Rpb24gY2hlY2tCb3VuZHMoYmVjaHN0cikge1xuICAgIGxldCBwO1xuICAgIGxldCBjaGFyO1xuICAgIGxldCBoYXNMb3dlciA9IGZhbHNlO1xuICAgIGxldCBoYXNVcHBlciA9IGZhbHNlO1xuICAgIGZvciAocCA9IDA7IHAgPCBiZWNoc3RyLmxlbmd0aDsgKytwKSB7XG4gICAgICAgIGNoYXIgPSBiZWNoc3RyLmNoYXJDb2RlQXQocCk7XG4gICAgICAgIGlmIChjaGFyIDwgMzMgfHwgY2hhciA+IDEyNikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID49IDk3ICYmIGNoYXIgPD0gMTIyKSB7XG4gICAgICAgICAgICBoYXNMb3dlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPj0gNjUgJiYgY2hhciA8PSA5MCkge1xuICAgICAgICAgICAgaGFzVXBwZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNMb3dlciAmJiBoYXNVcHBlcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2hlY2tTZXBhcmF0b3JQb3MoYmVjaHN0cikge1xuICAgIGNvbnN0IHBvcyA9IGJlY2hzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICByZXR1cm4gIShwb3MgPCAxIHx8XG4gICAgICAgIHBvcyArIDcgPiBiZWNoc3RyLmxlbmd0aCB8fFxuICAgICAgICBiZWNoc3RyLmxlbmd0aCA+IDkwKTtcbn1cbmZ1bmN0aW9uIGIzMmVuY29kZShkYXRhLCBocnAgPSAnYmMnLCB2ZXJzaW9uID0gMCkge1xuICAgIGNvbnN0IGRhdCA9IFt2ZXJzaW9uLCAuLi5jb252ZXJ0Qml0cyhbLi4uZGF0YV0sIDgsIDUpXTtcbiAgICBjb25zdCBlbmMgPSBFTkNPRElOR1MuZmluZChlID0+IGUudmVyc2lvbiA9PT0gdmVyc2lvbikgPz8gRU5DT0RJTkdTWzBdO1xuICAgIGNvbnN0IHN0ciA9IGVuY29kZSQ1KGhycCwgZGF0LCBlbmMpO1xuICAgIGIzMmRlY29kZShzdHIpO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBiMzJkZWNvZGUoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaHJwID0gc3RyLnNwbGl0KCcxJywgMSlbMF07XG4gICAgY29uc3QgW2hycGdvdCwgZGF0YV0gPSBkZWNvZGUkNShzdHIpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBjb252ZXJ0Qml0cyhkYXRhLnNsaWNlKDEpLCA1LCA4LCBmYWxzZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gZGVjb2RlZC5sZW5ndGg7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgKGhycCAhPT0gaHJwZ290KTpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmV0dXJuZWQgaHJwIHN0cmluZyBpcyBpbnZhbGlkLicpO1xuICAgICAgICBjYXNlIChkZWNvZGVkID09PSBudWxsIHx8IGxlbmd0aCA8IDIgfHwgbGVuZ3RoID4gNDApOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIHN0cmluZyBpcyBpbnZhbGlkIG9yIG91dCBvZiBzcGVjLicpO1xuICAgICAgICBjYXNlIChkYXRhWzBdID4gMTYpOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXR1cm5lZCB2ZXJzaW9uIGJpdCBpcyBvdXQgb2YgcmFuZ2UuJyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGRlY29kZWQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFZlcnNpb24kMShzdHIpIHtcbiAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBbXywgZGF0YV0gPSBkZWNvZGUkNShzdHIpO1xuICAgIHJldHVybiBkYXRhWzBdO1xufVxuY29uc3QgQmVjaDMyID0ge1xuICAgIGVuY29kZTogYjMyZW5jb2RlLFxuICAgIGRlY29kZTogYjMyZGVjb2RlLFxuICAgIHZlcnNpb246IGdldFZlcnNpb24kMVxufTtcblxuY29uc3QgQkFTRTY0X01BUCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbmNvbnN0IEI2NFVSTF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXyc7XG5jb25zdCBlYyQxID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBiNjRlbmNvZGUoaW5wdXQsIHVybFNhZmUgPSBmYWxzZSwgcGFkZGluZyA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJylcbiAgICAgICAgaW5wdXQgPSBlYyQxLmVuY29kZShpbnB1dCk7XG4gICAgY29uc3QgbWFwID0gdXJsU2FmZSA/IEI2NFVSTF9NQVAgOiBCQVNFNjRfTUFQO1xuICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgbGV0IGJ1ZmZlciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgaW5wdXRbaV07XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgd2hpbGUgKGJpdHMgPj0gNikge1xuICAgICAgICAgICAgYml0cyAtPSA2O1xuICAgICAgICAgICAgb3V0cHV0ICs9IG1hcFsoYnVmZmVyID4+IGJpdHMpICYgMHgzZl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgIGJ1ZmZlciA8PD0gNiAtIGJpdHM7XG4gICAgICAgIG91dHB1dCArPSBtYXBbYnVmZmVyICYgMHgzZl07XG4gICAgICAgIHdoaWxlIChiaXRzIDwgNikge1xuICAgICAgICAgICAgb3V0cHV0ICs9IHBhZGRpbmcgPyAnPScgOiAnJztcbiAgICAgICAgICAgIGJpdHMgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gYjY0ZGVjb2RlKGlucHV0LCB1cmxTYWZlID0gZmFsc2UpIHtcbiAgICBjb25zdCBtYXAgPSAodXJsU2FmZSB8fCBpbnB1dC5pbmNsdWRlcygnLScpIHx8IGlucHV0LmluY2x1ZGVzKCdfJykpXG4gICAgICAgID8gQjY0VVJMX01BUC5zcGxpdCgnJylcbiAgICAgICAgOiBCQVNFNjRfTUFQLnNwbGl0KCcnKTtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBjb25zdCBjaGFycyA9IGlucHV0LnNwbGl0KCcnKTtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGNoYXJzW2ldO1xuICAgICAgICBjb25zdCBpbmRleCA9IG1hcC5pbmRleE9mKGMpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyOiAnICsgYyk7XG4gICAgICAgIH1cbiAgICAgICAgYml0cyArPSA2O1xuICAgICAgICB2YWx1ZSA8PD0gNjtcbiAgICAgICAgdmFsdWUgfD0gaW5kZXg7XG4gICAgICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgICAgICAgIGJpdHMgLT0gODtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlID4+PiBiaXRzKSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG59XG5jb25zdCBCYXNlNjQgPSB7XG4gICAgZW5jb2RlOiBiNjRlbmNvZGUsXG4gICAgZGVjb2RlOiBiNjRkZWNvZGVcbn07XG5jb25zdCBCNjRVUkwgPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gYjY0ZW5jb2RlKGRhdGEsIHRydWUsIGZhbHNlKSxcbiAgICBkZWNvZGU6IChkYXRhKSA9PiBiNjRkZWNvZGUoZGF0YSwgdHJ1ZSlcbn07XG5cbmNvbnN0IF8wbiQzID0gQmlnSW50KDApO1xuY29uc3QgXzI1NW4gPSBCaWdJbnQoMjU1KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5mdW5jdGlvbiBiaWdfc2l6ZShiaWcpIHtcbiAgICBpZiAoYmlnIDw9IDB4ZmZuKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAoYmlnIDw9IDB4ZmZmZm4pXG4gICAgICAgIHJldHVybiAyO1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZm4pXG4gICAgICAgIHJldHVybiA0O1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZmZmZmZmZmZmbilcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgaWYgKGJpZyA8PSAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbilcbiAgICAgICAgcmV0dXJuIDE2O1xuICAgIGlmIChiaWcgPD0gMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmbikge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3Qgc3BlY2lmeSBhIGZpeGVkIGJ1ZmZlciBzaXplIGZvciBiaWdpbnRzIGdyZWF0ZXIgdGhhbiAzMiBieXRlcy4nKTtcbn1cbmZ1bmN0aW9uIGJpZ1RvQnl0ZXMoYmlnLCBzaXplLCBlbmRpYW4gPSAnYmUnKSB7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2l6ZSA9IGJpZ19zaXplKGJpZyk7XG4gICAgY29uc3QgdXNlX2xlID0gKGVuZGlhbiA9PT0gJ2xlJyk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgbGV0IG9mZnNldCA9ICh1c2VfbGUpID8gMCA6IHNpemUgLSAxO1xuICAgIHdoaWxlIChiaWcgPiBfMG4kMykge1xuICAgICAgICBjb25zdCBieXRlID0gYmlnICYgXzI1NW47XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihieXRlKTtcbiAgICAgICAgaWYgKHVzZV9sZSkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0KyssIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQtLSwgbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBiaWcgPSAoYmlnIC0gYnl0ZSkgLyBfMjU2bjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG59XG5mdW5jdGlvbiBieXRlc1RvQmlnKGJ5dGVzKSB7XG4gICAgbGV0IG51bSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gYnl0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbnVtID0gKG51bSAqIF8yNTZuKSArIEJpZ0ludChieXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQobnVtKTtcbn1cblxuZnVuY3Rpb24gYmluVG9CeXRlcyhiaW5hcnkpIHtcbiAgICBjb25zdCBiaW5zID0gYmluYXJ5LnNwbGl0KCcnKS5tYXAoTnVtYmVyKTtcbiAgICBpZiAoYmlucy5sZW5ndGggJSA4ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluYXJ5IGFycmF5IGlzIGludmFsaWQgbGVuZ3RoOiAke2JpbmFyeS5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmlucy5sZW5ndGggLyA4KTtcbiAgICBmb3IgKGxldCBpID0gMCwgY3QgPSAwOyBpIDwgYmlucy5sZW5ndGg7IGkgKz0gOCwgY3QrKykge1xuICAgICAgICBsZXQgYnl0ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgICAgICBieXRlIHw9IChiaW5zW2kgKyBqXSA8PCAoNyAtIGopKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1tjdF0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBieXRlc1RvQmluKGJ5dGVzKSB7XG4gICAgY29uc3QgYmluID0gbmV3IEFycmF5KGJ5dGVzLmxlbmd0aCAqIDgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBudW0gb2YgYnl0ZXMpIHtcbiAgICAgICAgaWYgKG51bSA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ5dGUgdmFsdWU6ICR7bnVtfS4gQnl0ZSB2YWx1ZXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS5gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gNzsgaSA+PSAwOyBpLS0sIGNvdW50KyspIHtcbiAgICAgICAgICAgIGJpbltjb3VudF0gPSAobnVtID4+IGkpICYgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmluLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBudW1fc2l6ZShudW0pIHtcbiAgICBpZiAobnVtIDw9IDB4RkYpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChudW0gPD0gMHhGRkZGKVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAobnVtIDw9IDB4RkZGRkZGRkYpXG4gICAgICAgIHJldHVybiA0O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ051bWJlcnMgbGFyZ2VyIHRoYW4gNCBieXRlcyBtdXN0IHNwZWNpZnkgYSBmaXhlZCBzaXplIScpO1xufVxuZnVuY3Rpb24gbnVtVG9CeXRlcyhudW0sIHNpemUsIGVuZGlhbiA9ICdiZScpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzaXplID0gbnVtX3NpemUobnVtKTtcbiAgICBjb25zdCB1c2VfbGUgPSAoZW5kaWFuID09PSAnbGUnKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBsZXQgb2Zmc2V0ID0gKHVzZV9sZSkgPyAwIDogc2l6ZSAtIDE7XG4gICAgd2hpbGUgKG51bSA+IDApIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IG51bSAmIDI1NTtcbiAgICAgICAgaWYgKHVzZV9sZSkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0KyssIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQtLSwgbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSAobnVtIC0gYnl0ZSkgLyAyNTY7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb051bShieXRlcykge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBieXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBudW0gPSAobnVtICogMjU2KSArIGJ5dGVzW2ldO1xuICAgICAgICBpc19zYWZlX251bShudW0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xufVxuXG5jb25zdCBlYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgZGMgPSBuZXcgVGV4dERlY29kZXIoKTtcbmZ1bmN0aW9uIHN0clRvQnl0ZXMoc3RyKSB7XG4gICAgcmV0dXJuIGVjLmVuY29kZShzdHIpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb1N0cihieXRlcykge1xuICAgIHJldHVybiBkYy5kZWNvZGUoYnl0ZXMpO1xufVxuZnVuY3Rpb24gaGV4X3NpemUoaGV4c3RyLCBzaXplKSB7XG4gICAgaXNfaGV4KGhleHN0cik7XG4gICAgY29uc3QgbGVuID0gaGV4c3RyLmxlbmd0aCAvIDI7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2l6ZSA9IGxlbjtcbiAgICBpZiAobGVuID4gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBIZXggc3RyaW5nIGlzIGxhcmdlciB0aGFuIGFycmF5IHNpemU6ICR7bGVufSA+ICR7c2l6ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleHN0ciwgc2l6ZSwgZW5kaWFuID0gJ2xlJykge1xuICAgIHNpemUgPSBoZXhfc2l6ZShoZXhzdHIsIHNpemUpO1xuICAgIGNvbnN0IHVzZV9sZSA9IChlbmRpYW4gPT09ICdsZScpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAodXNlX2xlKSA/IDAgOiBzaXplIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhleHN0ci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBjaGFyID0gaGV4c3RyLnN1YnN0cmluZyhpLCBpICsgMik7XG4gICAgICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KGNoYXIsIDE2KTtcbiAgICAgICAgaWYgKHVzZV9sZSkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0KyssIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50OChvZmZzZXQtLSwgbnVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBsZXQgY2hhcnMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoYXJzICs9IGJ5dGVzW2ldLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG59XG5mdW5jdGlvbiBqc29uVG9CeXRlcyhvYmopIHtcbiAgICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmosIChfLCB2KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8gYCR7dn1uYFxuICAgICAgICAgICAgOiB2O1xuICAgIH0pO1xuICAgIHJldHVybiBzdHJUb0J5dGVzKHN0cik7XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlcihkYXRhLCBzaXplLCBlbmRpYW4pIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBzZXRfYnVmZmVyKGRhdGEsIHNpemUsIGVuZGlhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMoZGF0YSwgc2l6ZSwgZW5kaWFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYmlnVG9CeXRlcyhkYXRhLCBzaXplLCBlbmRpYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBudW1Ub0J5dGVzKGRhdGEsIHNpemUsIGVuZGlhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5Lm9mKGRhdGEgPyAxIDogMCk7XG4gICAgfVxuICAgIHRocm93IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgZm9ybWF0OicgKyBTdHJpbmcodHlwZW9mIGRhdGEpKTtcbn1cblxuY2xhc3MgQnVmZiBleHRlbmRzIFVpbnQ4QXJyYXkge1xuICAgIHN0YXRpYyB7IHRoaXMubnVtID0gbnVtVG9CdWZmOyB9XG4gICAgc3RhdGljIHsgdGhpcy5iaWcgPSBiaWdUb0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJpbiA9IGJpblRvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMucmF3ID0gcmF3VG9CdWZmOyB9XG4gICAgc3RhdGljIHsgdGhpcy5zdHIgPSBzdHJUb0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmhleCA9IGhleFRvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYnl0ZXMgPSBieXRlc1RvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuanNvbiA9IGpzb25Ub0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmJhc2U2NCA9IGJhc2U2NFRvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYjY0dXJsID0gYjY0dXJsVG9CdWZmOyB9XG4gICAgc3RhdGljIHsgdGhpcy5iZWNoMzIgPSBiZWNoMzJUb0J1ZmY7IH1cbiAgICBzdGF0aWMgeyB0aGlzLmI1OGNoayA9IGI1OGNoa1RvQnVmZjsgfVxuICAgIHN0YXRpYyB7IHRoaXMuZW5jb2RlID0gc3RyVG9CeXRlczsgfVxuICAgIHN0YXRpYyB7IHRoaXMuZGVjb2RlID0gYnl0ZXNUb1N0cjsgfVxuICAgIHN0YXRpYyByYW5kb20oc2l6ZSA9IDMyKSB7XG4gICAgICAgIGNvbnN0IHJhbmQgPSByYW5kb20kMShzaXplKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKHJhbmQsIHNpemUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBzaXplLCBlbmRpYW4pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyJDEgPSBidWZmZXIoZGF0YSwgc2l6ZSwgZW5kaWFuKTtcbiAgICAgICAgc3VwZXIoYnVmZmVyJDEpO1xuICAgIH1cbiAgICBnZXQgYXJyKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXNdO1xuICAgIH1cbiAgICBnZXQgbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b051bSgpO1xuICAgIH1cbiAgICBnZXQgYmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0JpZygpO1xuICAgIH1cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cigpO1xuICAgIH1cbiAgICBnZXQgaGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgIH1cbiAgICBnZXQgcmF3KCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcyk7XG4gICAgfVxuICAgIGdldCBiaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQmluKCk7XG4gICAgfVxuICAgIGdldCBiNThjaGsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYjU4Y2hrKCk7XG4gICAgfVxuICAgIGdldCBiYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQmFzZTY0KCk7XG4gICAgfVxuICAgIGdldCBiNjR1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQjY0dXJsKCk7XG4gICAgfVxuICAgIGdldCBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGFzaCgpO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGFzaCgpLmhleDtcbiAgICB9XG4gICAgZ2V0IHN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0odGhpcyk7XG4gICAgfVxuICAgIHRvTnVtKGVuZGlhbiA9ICdiZScpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSAoZW5kaWFuID09PSAnYmUnKVxuICAgICAgICAgICAgPyB0aGlzLnJldmVyc2UoKVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgICAgICByZXR1cm4gYnl0ZXNUb051bShieXRlcyk7XG4gICAgfVxuICAgIHRvQmluKCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0Jpbih0aGlzKTtcbiAgICB9XG4gICAgdG9CaWcoZW5kaWFuID0gJ2JlJykge1xuICAgICAgICBjb25zdCBieXRlcyA9IChlbmRpYW4gPT09ICdiZScpXG4gICAgICAgICAgICA/IHRoaXMucmV2ZXJzZSgpXG4gICAgICAgICAgICA6IHRoaXM7XG4gICAgICAgIHJldHVybiBieXRlc1RvQmlnKGJ5dGVzKTtcbiAgICB9XG4gICAgdG9IYXNoKCkge1xuICAgICAgICBjb25zdCBkaWdlc3QgPSBzaGEyNTYkMih0aGlzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGRpZ2VzdCk7XG4gICAgfVxuICAgIHRvSnNvbigpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cih0aGlzKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbiAgICB9XG4gICAgdG9CZWNoMzIoaHJwLCB2ZXJzaW9uID0gMCkge1xuICAgICAgICByZXR1cm4gQmVjaDMyLmVuY29kZSh0aGlzLCBocnAsIHZlcnNpb24pO1xuICAgIH1cbiAgICB0b1N0cigpIHsgcmV0dXJuIGJ5dGVzVG9TdHIodGhpcyk7IH1cbiAgICB0b0hleCgpIHsgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcyk7IH1cbiAgICB0b0J5dGVzKCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcyk7IH1cbiAgICB0b2I1OGNoaygpIHsgcmV0dXJuIEJhc2U1OEMuZW5jb2RlKHRoaXMpOyB9XG4gICAgdG9CYXNlNjQoKSB7IHJldHVybiBCYXNlNjQuZW5jb2RlKHRoaXMpOyB9XG4gICAgdG9CNjR1cmwoKSB7IHJldHVybiBCNjRVUkwuZW5jb2RlKHRoaXMpOyB9XG4gICAgcHJlcGVuZChkYXRhKSB7XG4gICAgICAgIHJldHVybiBCdWZmLmpvaW4oW0J1ZmYuYnl0ZXMoZGF0YSksIHRoaXNdKTtcbiAgICB9XG4gICAgYXBwZW5kKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYuam9pbihbdGhpcywgQnVmZi5ieXRlcyhkYXRhKV0pO1xuICAgIH1cbiAgICBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMpLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYoYXJyKTtcbiAgICB9XG4gICAgc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSh0aGlzKS5zdWJhcnJheShiZWdpbiwgZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGFycik7XG4gICAgfVxuICAgIHJldmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMpLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKGFycik7XG4gICAgfVxuICAgIHdyaXRlKGJ5dGVzLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYiA9IEJ1ZmYuYnl0ZXMoYnl0ZXMpO1xuICAgICAgICB0aGlzLnNldChiLCBvZmZzZXQpO1xuICAgIH1cbiAgICBwcmVmaXhTaXplKGVuZGlhbikge1xuICAgICAgICBjb25zdCBzaXplID0gQnVmZi52YXJJbnQodGhpcy5sZW5ndGgsIGVuZGlhbik7XG4gICAgICAgIHJldHVybiBCdWZmLmpvaW4oW3NpemUsIHRoaXNdKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYoVWludDhBcnJheS5mcm9tKGRhdGEpKTtcbiAgICB9XG4gICAgc3RhdGljIG9mKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmKFVpbnQ4QXJyYXkub2YoLi4uYXJncykpO1xuICAgIH1cbiAgICBzdGF0aWMgam9pbihhcnIpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnIubWFwKGUgPT4gQnVmZi5ieXRlcyhlKSk7XG4gICAgICAgIGNvbnN0IGpvaW5lZCA9IGpvaW5fYXJyYXkoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmYoam9pbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIHZhckludChudW0sIGVuZGlhbikge1xuICAgICAgICBpZiAobnVtIDwgMHhGRCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmYubnVtKG51bSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobnVtIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmYub2YoMHhGRCwgLi4uQnVmZi5udW0obnVtLCAyLCBlbmRpYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW0gPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmYub2YoMHhGRSwgLi4uQnVmZi5udW0obnVtLCA0LCBlbmRpYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCaWdJbnQobnVtKSA8IDB4MTAwMDAwMDAwMDAwMDAwMDBuKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZi5vZigweEZGLCAuLi5CdWZmLm51bShudW0sIDgsIGVuZGlhbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBpcyB0b28gbGFyZ2U6ICR7bnVtfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbnVtVG9CdWZmKG51bWJlciwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKG51bWJlciwgc2l6ZSwgZW5kaWFuKTtcbn1cbmZ1bmN0aW9uIGJpblRvQnVmZihkYXRhLCBzaXplLCBlbmRpYW4pIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYoYmluVG9CeXRlcyhkYXRhKSwgc2l6ZSwgZW5kaWFuKTtcbn1cbmZ1bmN0aW9uIGJpZ1RvQnVmZihiaWdpbnQsIHNpemUsIGVuZGlhbikge1xuICAgIHJldHVybiBuZXcgQnVmZihiaWdpbnQsIHNpemUsIGVuZGlhbik7XG59XG5mdW5jdGlvbiByYXdUb0J1ZmYoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKGRhdGEsIHNpemUsIGVuZGlhbik7XG59XG5mdW5jdGlvbiBzdHJUb0J1ZmYoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKHN0clRvQnl0ZXMoZGF0YSksIHNpemUsIGVuZGlhbik7XG59XG5mdW5jdGlvbiBoZXhUb0J1ZmYoZGF0YSwgc2l6ZSwgZW5kaWFuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKGRhdGEsIHNpemUsIGVuZGlhbik7XG59XG5mdW5jdGlvbiBieXRlc1RvQnVmZihkYXRhLCBzaXplLCBlbmRpYW4pIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYoZGF0YSwgc2l6ZSwgZW5kaWFuKTtcbn1cbmZ1bmN0aW9uIGpzb25Ub0J1ZmYoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQnVmZihqc29uVG9CeXRlcyhkYXRhKSk7XG59XG5mdW5jdGlvbiBiYXNlNjRUb0J1ZmYoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQnVmZihCYXNlNjQuZGVjb2RlKGRhdGEpKTtcbn1cbmZ1bmN0aW9uIGI2NHVybFRvQnVmZihkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmKEI2NFVSTC5kZWNvZGUoZGF0YSkpO1xufVxuZnVuY3Rpb24gYmVjaDMyVG9CdWZmKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmYoQmVjaDMyLmRlY29kZShkYXRhKSk7XG59XG5mdW5jdGlvbiBiNThjaGtUb0J1ZmYoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQnVmZihCYXNlNThDLmRlY29kZShkYXRhKSk7XG59XG5jbGFzcyBTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZi5ieXRlcyhkYXRhKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgcGVlayhzaXplKSB7XG4gICAgICAgIGlmIChzaXplID4gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpemUgZ3JlYXRlciB0aGFuIHN0cmVhbTogJHtzaXplfSA+ICR7dGhpcy5zaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnVmZih0aGlzLmRhdGEuc2xpY2UoMCwgc2l6ZSkpO1xuICAgIH1cbiAgICByZWFkKHNpemUpIHtcbiAgICAgICAgc2l6ZSA9IHNpemUgPz8gdGhpcy5yZWFkU2l6ZSgpO1xuICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMucGVlayhzaXplKTtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnNsaWNlKHNpemUpO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIHJlYWRTaXplKGVuZGlhbikge1xuICAgICAgICBjb25zdCBudW0gPSB0aGlzLnJlYWQoMSkubnVtO1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgKG51bSA+PSAwICYmIG51bSA8IDB4RkQpOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgICAgICBjYXNlIChudW0gPT09IDB4RkQpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQoMikudG9OdW0oZW5kaWFuKTtcbiAgICAgICAgICAgIGNhc2UgKG51bSA9PT0gMHhGRSk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZCg0KS50b051bShlbmRpYW4pO1xuICAgICAgICAgICAgY2FzZSAobnVtID09PSAweEZGKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkKDgpLnRvTnVtKGVuZGlhbik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFyaW50IGlzIG91dCBvZiByYW5nZTogJHtudW19YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IGN1cnZlID0gc2VjcDI1NmsxLkNVUlZFO1xuY29uc3QgTiQxID0gY3VydmUubjtcbmNvbnN0IFAkMSA9IGN1cnZlLnA7XG5jb25zdCBHID0geyB4OiBjdXJ2ZS5HeCwgeTogY3VydmUuR3kgfTtcbmNvbnN0IF8wbiQyID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgXzNuID0gQmlnSW50KDMpO1xuY29uc3QgXzRuID0gQmlnSW50KDQpO1xuY29uc3QgQ09OU1QgPSB7IE46IE4kMSwgUDogUCQxLCBHLCBfMG46IF8wbiQyLCBfMW4sIF8ybiwgXzNuLCBfNG4gfTtcbmNvbnN0IGVjYyA9IEZpZWxkJDEoTiQxLCAzMiwgdHJ1ZSk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBOJDEpO1xuXG5mdW5jdGlvbiBmYWlsKGVycm9yLCB0aHJvd3MgPSBmYWxzZSkge1xuICAgIGlmICh0aHJvd3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiByYW5kb20oc2l6ZSkge1xuICAgIHJldHVybiBCdWZmLnJhbmRvbShzaXplKTtcbn1cbmZ1bmN0aW9uIG1vZF9ieXRlcyhieXRlcykge1xuICAgIGNvbnN0IGIgPSBCdWZmLmJ5dGVzKGJ5dGVzKS5iaWc7XG4gICAgcmV0dXJuIEJ1ZmYuYmlnKG1vZE4oYiksIDMyKTtcbn1cblxudmFyIHV0bCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZmFpbDogZmFpbCxcbiAgICBtb2RfYnl0ZXM6IG1vZF9ieXRlcyxcbiAgICByYW5kb206IHJhbmRvbVxufSk7XG5cbmNvbnN0IHsgTiwgUCwgXzBuOiBfMG4kMSB9ID0gQ09OU1Q7XG5mdW5jdGlvbiBzaXplKGlucHV0LCBzaXplLCB0aHJvd3MpIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmYuYnl0ZXMoaW5wdXQpO1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoYEludmFsaWQgYnl0ZSBzaXplOiAke2J5dGVzLmhleH0gIT09ICR7c2l6ZX1gLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGluX2ZpZWxkKHgsIHRocm93cykge1xuICAgIGlmICghKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4kMSA8IHggJiYgeCA8IE4pKSB7XG4gICAgICAgIGZhaWwoJ3ggdmFsdWUgaXMgbm90IGluIHRoZSBmaWVsZCEnLCB0aHJvd3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgTm9ibGVQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jbGFzcyBGaWVsZCBleHRlbmRzIFVpbnQ4QXJyYXkge1xuICAgIHN0YXRpYyB7IHRoaXMuTiA9IHNlY3AyNTZrMS5DVVJWRS5uOyB9XG4gICAgc3RhdGljIG1vZCh4KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc192YWxpZCh2YWx1ZSwgdGhyb3dzKSB7XG4gICAgICAgIGNvbnN0IGJpZyA9IEJ1ZmYuYnl0ZXModmFsdWUsIDMyKS5iaWc7XG4gICAgICAgIHJldHVybiBpbl9maWVsZChiaWcsIHRocm93cyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHgpIHtcbiAgICAgICAgbGV0IGIgPSBub3JtYWxpemVGaWVsZCh4KTtcbiAgICAgICAgYiA9IG1vZE4oYik7XG4gICAgICAgIEZpZWxkLmlzX3ZhbGlkKGIsIHRydWUpO1xuICAgICAgICBzdXBlcihCdWZmLmJpZyhiLCAzMiksIDMyKTtcbiAgICB9XG4gICAgZ2V0IGJ1ZmYoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZih0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHJhdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZi5yYXc7XG4gICAgfVxuICAgIGdldCBiaWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmYuYmlnO1xuICAgIH1cbiAgICBnZXQgaGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmLmhleDtcbiAgICB9XG4gICAgZ2V0IHBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpO1xuICAgIH1cbiAgICBnZXQgaGFzT2RkWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnQuaGFzT2RkWTtcbiAgICB9XG4gICAgZ2V0IG5lZ2F0ZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5oYXNPZGRZKVxuICAgICAgICAgICAgPyB0aGlzLm5lZ2F0ZSgpXG4gICAgICAgICAgICA6IHRoaXM7XG4gICAgfVxuICAgIGd0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHggPSBuZXcgRmllbGQodmFsdWUpO1xuICAgICAgICByZXR1cm4geC5iaWcgPiB0aGlzLmJpZztcbiAgICB9XG4gICAgbHQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeCA9IG5ldyBGaWVsZCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB4LmJpZyA8IHRoaXMuYmlnO1xuICAgIH1cbiAgICBlcSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gbmV3IEZpZWxkKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHguYmlnID09PSB0aGlzLmJpZztcbiAgICB9XG4gICAgbmUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeCA9IG5ldyBGaWVsZCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB4LmJpZyAhPT0gdGhpcy5iaWc7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYSA9IGVjYy5hZGQodGhpcy5iaWcsIHguYmlnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZChhKTtcbiAgICB9XG4gICAgc3ViKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHggPSBGaWVsZC5tb2QodmFsdWUpO1xuICAgICAgICBjb25zdCBhID0gZWNjLnN1Yih0aGlzLmJpZywgeC5iaWcpO1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkKGEpO1xuICAgIH1cbiAgICBtdWwodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeCA9IEZpZWxkLm1vZCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGEgPSBlY2MubXVsKHRoaXMuYmlnLCB4LmJpZyk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoYSk7XG4gICAgfVxuICAgIHBvdyh2YWx1ZSkge1xuICAgICAgICBjb25zdCB4ID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYSA9IGVjYy5wb3codGhpcy5iaWcsIHguYmlnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZChhKTtcbiAgICB9XG4gICAgZGl2KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHggPSBGaWVsZC5tb2QodmFsdWUpO1xuICAgICAgICBjb25zdCBhID0gZWNjLmRpdih0aGlzLmJpZywgeC5iaWcpO1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkKGEpO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGQoRmllbGQuTiAtIHRoaXMuYmlnKTtcbiAgICB9XG4gICAgZ2VuZXJhdGUoKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gYmFzZS5tdWx0aXBseSh0aGlzLmJpZyk7XG4gICAgICAgIHJldHVybiBQb2ludC5pbXBvcnQocG9pbnQpO1xuICAgIH1cbn1cbmNsYXNzIFBvaW50IHtcbiAgICBzdGF0aWMgeyB0aGlzLlAgPSBDT05TVC5QOyB9XG4gICAgc3RhdGljIHsgdGhpcy5HID0gQ09OU1QuRzsgfVxuICAgIHN0YXRpYyB7IHRoaXMuYmFzZSA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuQkFTRTsgfVxuICAgIHN0YXRpYyBmcm9tX3goYnl0ZXMpIHtcbiAgICAgICAgbGV0IGNwID0gbm9ybWFsaXplUG9pbnQoYnl0ZXMpO1xuICAgICAgICBpZiAoY3AubGVuZ3RoID09PSAzMikge1xuICAgICAgICAgICAgY3AgPSBjcC5wcmVwZW5kKDB4MDIpO1xuICAgICAgICB9XG4gICAgICAgIHNpemUoY3AsIDMzKTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBOb2JsZVBvaW50LmZyb21IZXgoY3AuaGV4KTtcbiAgICAgICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gRmllbGQubW9kKHZhbHVlKTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBQb2ludC5iYXNlLm11bHRpcGx5KGZpZWxkLmJpZyk7XG4gICAgICAgIHJldHVybiBQb2ludC5pbXBvcnQocG9pbnQpO1xuICAgIH1cbiAgICBzdGF0aWMgaW1wb3J0KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHAgPSAocG9pbnQgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgID8geyB4OiBwb2ludC54LmJpZywgeTogcG9pbnQueS5iaWcgfVxuICAgICAgICAgICAgOiB7IHg6IHBvaW50LngsIHk6IHBvaW50LnkgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLngsIHAueSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy5fcCA9IG5ldyBOb2JsZVBvaW50KHgsIHksIDFuKTtcbiAgICAgICAgdGhpcy5wLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIGdldCBwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcDtcbiAgICB9XG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiBCdWZmLmJpZyh0aGlzLnAueCwgMzIpO1xuICAgIH1cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYuYmlnKHRoaXMucC55LCAzMik7XG4gICAgfVxuICAgIGdldCBidWZmKCkge1xuICAgICAgICByZXR1cm4gQnVmZi5yYXcodGhpcy5wLnRvUmF3Qnl0ZXModHJ1ZSkpO1xuICAgIH1cbiAgICBnZXQgcmF3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmLnJhdztcbiAgICB9XG4gICAgZ2V0IGhleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZi5oZXg7XG4gICAgfVxuICAgIGdldCBoYXNFdmVuWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucC5oYXNFdmVuWSgpO1xuICAgIH1cbiAgICBnZXQgaGFzT2RkWSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnAuaGFzRXZlblkoKTtcbiAgICB9XG4gICAgZXEodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcCA9ICh2YWx1ZSBpbnN0YW5jZW9mIFBvaW50KSA/IHZhbHVlIDogUG9pbnQuZnJvbV94KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueC5iaWcgPT09IHAueC5iaWcgJiYgdGhpcy55LmJpZyA9PT0gcC55LmJpZztcbiAgICB9XG4gICAgYWRkKHgpIHtcbiAgICAgICAgcmV0dXJuICh4IGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICA/IFBvaW50LmltcG9ydCh0aGlzLnAuYWRkKHgucCkpXG4gICAgICAgICAgICA6IFBvaW50LmltcG9ydCh0aGlzLnAuYWRkKFBvaW50LmdlbmVyYXRlKHgpLnApKTtcbiAgICB9XG4gICAgc3ViKHgpIHtcbiAgICAgICAgcmV0dXJuICh4IGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICA/IFBvaW50LmltcG9ydCh0aGlzLnAuc3VidHJhY3QoeC5wKSlcbiAgICAgICAgICAgIDogUG9pbnQuaW1wb3J0KHRoaXMucC5zdWJ0cmFjdChQb2ludC5nZW5lcmF0ZSh4KS5wKSk7XG4gICAgfVxuICAgIG11bCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICA/IFBvaW50LmltcG9ydCh0aGlzLnAubXVsdGlwbHkodmFsdWUueC5iaWcpKVxuICAgICAgICAgICAgOiBQb2ludC5pbXBvcnQodGhpcy5wLm11bHRpcGx5KEZpZWxkLm1vZCh2YWx1ZSkuYmlnKSk7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmltcG9ydCh0aGlzLnAubmVnYXRlKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUZpZWxkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmJpZztcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnguYmlnO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmLnJhdyh2YWx1ZSkuYmlnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQnVmZi5oZXgodmFsdWUpLmJpZztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYubnVtKHZhbHVlKS5iaWc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZTonICsgdHlwZW9mIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvaW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnBvaW50LmJ1ZmY7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5idWZmO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYuYnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBCdWZmLmJ5dGVzKHZhbHVlLCAzMik7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gdHlwZTogJHt0eXBlb2YgdmFsdWV9YCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaCQxKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaDogaGFzaCQxLFxuICAgIGV4aXN0cyxcbiAgICBvdXRwdXQsXG59O1xudmFyIGFzc2VydCQxID0gYXNzZXJ0O1xuXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyQzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMkMyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5cbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQkMS5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMkMyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0JDEuZXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnQkMS5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuY29uc3Qgc2hhMjU2JDEgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbndyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuXG5jb25zdCBVMzJfTUFTSzY0ID0gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBsLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBsKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbnZhciB1NjQkMSA9IHU2NDtcblxuLy8gUm91bmQgY29udGFudHMgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBbU0hBNTEyX0toLCBTSEE1MTJfS2xdID0gdTY0JDEuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBTSEE1MTJfV19IID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSBuZXcgVWludDMyQXJyYXkoODApO1xuY2xhc3MgU0hBNTEyIGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDEyOCwgNjQsIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGUgd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBBbHNvIGxvb2tzIGNsZWFuZXIgYW5kIGVhc2llciB0byB2ZXJpZnkgd2l0aCBzcGVjLlxuICAgICAgICAvLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4NmEwOWU2NjcgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmM2JjYzkwOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweGJiNjdhZTg1IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODRjYWE3M2IgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgzYzZlZjM3MiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweGZlOTRmODJiIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4YTU0ZmY1M2EgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ZjFkMzZmMSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDUxMGU1MjdmIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YWRlNjgyZDEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg5YjA1Njg4YyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDJiM2U2YzFmIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MWY4M2Q5YWIgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHhmYjQxYmQ2YiB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDViZTBjZDE5IHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4MTM3ZTIxNzkgfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NCQxLnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NCQxLnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NCQxLnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0JDEucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0JDEucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0JDEuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0JDEucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQkMS5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NCQxLnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NCQxLnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0JDEucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQkMS5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NCQxLmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQkMS5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NCQxLnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NCQxLnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NCQxLnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQkMS5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQkMS5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQkMS5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0JDEuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQkMS5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NCQxLnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NCQxLnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NCQxLnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQkMS5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQkMS5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQkMS5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0JDEuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQkMS5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQkMS5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQkMS5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NCQxLmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0JDEuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQkMS5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NCQxLmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0JDEuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQkMS5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NCQxLmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBNTEyX1dfSC5maWxsKDApO1xuICAgICAgICBTSEE1MTJfV19MLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg4YzNkMzdjOCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweDE5NTQ0ZGEyIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NzNlMTk5NjYgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4OWRjZDRkNiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDFkZmFiN2FlIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzJmZjljODIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg2NzlkZDUxNCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU4MmY5ZmNmIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4MGY2ZDJiNjkgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHg3YmQ0NGRhOCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDc3ZTM2ZjczIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MDRjNDg5NDIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgzZjlkODVhOCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDZhMWQzNmM4IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MTExMmU2YWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg5MWQ2OTJhMSB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDIyMzEyMTk0IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZmMyYmY3MmMgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweGM4NGM2NGMyIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MjM5M2I4NmIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDk2Mzg3NzE5IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTk0MGVhYmQgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGE4OGVmZmUzIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4YmU1ZTFlMjUgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDJiMDE5OWZjIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4MmM4NWI4YWEgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDgxYzUyY2EyIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAzMjtcbiAgICB9XG59XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHhjYmJiOWQ1ZCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDkxNTkwMTVhIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHgxNTJmZWNkOCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDhlYjQ0YTg3IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHhkYjBjMmUwZCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gNDg7XG4gICAgfVxufVxuY29uc3Qgc2hhNTEyJDEgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMigpKTtcbndyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbndyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbndyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuXG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuY29uc3QgUmhvID0gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKTtcbmNvbnN0IElkID0gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XG5jb25zdCBQaSA9IElkLm1hcCgoaSkgPT4gKDkgKiBpICsgNSkgJSAxNik7XG5sZXQgaWR4TCA9IFtJZF07XG5sZXQgaWR4UiA9IFtQaV07XG5mb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKGxldCBqIG9mIFtpZHhMLCBpZHhSXSlcbiAgICAgICAgai5wdXNoKGpbaV0ubWFwKChrKSA9PiBSaG9ba10pKTtcbmNvbnN0IHNoaWZ0cyA9IFtcbiAgICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcbiAgICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgICBbMTMsIDE1LCAxNCwgMTEsIDcsIDcsIDYsIDgsIDEzLCAxNCwgMTMsIDEyLCA1LCA1LCA2LCA5XSxcbiAgICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcbiAgICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XSxcbl0ubWFwKChpKSA9PiBuZXcgVWludDhBcnJheShpKSk7XG5jb25zdCBzaGlmdHNMID0gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSID0gaWR4Ui5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBLbCA9IG5ldyBVaW50MzJBcnJheShbMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZV0pO1xuY29uc3QgS3IgPSBuZXcgVWludDMyQXJyYXkoWzB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDBdKTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICh3b3JkID4+PiAoMzIgLSBzaGlmdCkpO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiBmKGdyb3VwLCB4LCB5LCB6KSB7XG4gICAgaWYgKGdyb3VwID09PSAwKVxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAzKVxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgQlVGID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMSB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5IHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IDB4OThiYWRjZmUgfCAwO1xuICAgICAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NiB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IGgwLCBoMSwgaDIsIGgzLCBoNCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtoMCwgaDEsIGgyLCBoMywgaDRdO1xuICAgIH1cbiAgICBzZXQoaDAsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgIHRoaXMuaDAgPSBoMCB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSBoMSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSBoMiB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSBoMyB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSBoNCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBCVUZbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IGFsID0gdGhpcy5oMCB8IDAsIGFyID0gYWwsIGJsID0gdGhpcy5oMSB8IDAsIGJyID0gYmwsIGNsID0gdGhpcy5oMiB8IDAsIGNyID0gY2wsIGRsID0gdGhpcy5oMyB8IDAsIGRyID0gZGwsIGVsID0gdGhpcy5oNCB8IDAsIGVyID0gZWw7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgaXRlcmF0aW5nIDAgdG8gODAsIHdlIHNwbGl0IGl0IGludG8gNSBncm91cHNcbiAgICAgICAgLy8gQW5kIHVzZSB0aGUgZ3JvdXBzIGluIGNvbnN0YW50cywgZnVuY3Rpb25zLCBldGMuIE11Y2ggc2ltcGxlclxuICAgICAgICBmb3IgKGxldCBncm91cCA9IDA7IGdyb3VwIDwgNTsgZ3JvdXArKykge1xuICAgICAgICAgICAgY29uc3Qgckdyb3VwID0gNCAtIGdyb3VwO1xuICAgICAgICAgICAgY29uc3QgaGJsID0gS2xbZ3JvdXBdLCBoYnIgPSBLcltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmwgPSBpZHhMW2dyb3VwXSwgcnIgPSBpZHhSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzbCA9IHNoaWZ0c0xbZ3JvdXBdLCBzciA9IHNoaWZ0c1JbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRsID0gKHJvdGwoYWwgKyBmKGdyb3VwLCBibCwgY2wsIGRsKSArIEJVRltybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSByb3RsKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKHJvdGwoYXIgKyBmKHJHcm91cCwgYnIsIGNyLCBkcikgKyBCVUZbcnJbaV1dICsgaGJyLCBzcltpXSkgKyBlcikgfCAwO1xuICAgICAgICAgICAgICAgIGFyID0gZXIsIGVyID0gZHIsIGRyID0gcm90bChjciwgMTApIHwgMCwgY3IgPSBiciwgYnIgPSB0cjsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgdGhpcy5zZXQoKHRoaXMuaDEgKyBjbCArIGRyKSB8IDAsICh0aGlzLmgyICsgZGwgKyBlcikgfCAwLCAodGhpcy5oMyArIGVsICsgYXIpIHwgMCwgKHRoaXMuaDQgKyBhbCArIGJyKSB8IDAsICh0aGlzLmgwICsgYmwgKyBjcikgfCAwKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgQlVGLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuLyoqXG4gKiBSSVBFTUQtMTYwIC0gYSBoYXNoIGZ1bmN0aW9uIGZyb20gMTk5MHMuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1zZyB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5jb25zdCByaXBlbWQxNjAgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFJJUEVNRDE2MCgpKTtcblxuLy8gSE1BQyAoUkZDIDIxMDQpXG5jbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydCQxLmhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMkMyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnQkMS5leGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQkMS5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydCQxLmJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5jb25zdCBobWFjJDEgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMkMS5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuXG5mdW5jdGlvbiBzaGEyNTYobXNnKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmYuYnl0ZXMobXNnKTtcbiAgICByZXR1cm4gQnVmZi5yYXcoc2hhMjU2JDEoYikpO1xufVxuZnVuY3Rpb24gaGFzaDI1Nihtc2cpIHtcbiAgICBjb25zdCBiID0gQnVmZi5ieXRlcyhtc2cpO1xuICAgIHJldHVybiBCdWZmLnJhdyhzaGEyNTYkMShzaGEyNTYkMShiKSkpO1xufVxuZnVuY3Rpb24gaGFzaDE2MChtc2cpIHtcbiAgICBjb25zdCBiID0gQnVmZi5ieXRlcyhtc2cpO1xuICAgIHJldHVybiBCdWZmLnJhdyhyaXBlbWQxNjAoc2hhMjU2JDEoYikpKTtcbn1cbmZ1bmN0aW9uIGhtYWM1MTIoa2V5LCBtc2cpIHtcbiAgICBjb25zdCBrID0gQnVmZi5ieXRlcyhrZXkpO1xuICAgIGNvbnN0IGIgPSBCdWZmLmJ5dGVzKG1zZyk7XG4gICAgcmV0dXJuIEJ1ZmYucmF3KGhtYWMkMShzaGE1MTIkMSwgaywgYikpO1xufVxuZnVuY3Rpb24gaGFzaHRhZyh0YWcpIHtcbiAgICBjb25zdCBoYXNoID0gQnVmZi5zdHIodGFnKS5kaWdlc3Q7XG4gICAgcmV0dXJuIEJ1ZmYuam9pbihbaGFzaCwgaGFzaF0pO1xufVxuXG5mdW5jdGlvbiBnZW5TZWNyZXRLZXkoc2l6ZSA9IDMyKSB7XG4gICAgcmV0dXJuIGdldFNlY3JldEtleShyYW5kb20oc2l6ZSkpO1xufVxuZnVuY3Rpb24gZ2V0U2VjcmV0S2V5KHNlY3JldCkge1xuICAgIHJldHVybiBGaWVsZC5tb2Qoc2VjcmV0KS5idWZmO1xufVxuZnVuY3Rpb24gZ2V0UHVibGljS2V5KHNlY2tleSwgeG9ubHkgPSBmYWxzZSkge1xuICAgIGNvbnN0IHAgPSBGaWVsZC5tb2Qoc2Vja2V5KS5wb2ludDtcbiAgICByZXR1cm4gKHhvbmx5KSA/IHAueCA6IHAuYnVmZjtcbn1cbmZ1bmN0aW9uIGdldFNoYXJlZEtleShzZWNrZXksIHB1YmtleSkge1xuICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tX3gocHVia2V5KTtcbiAgICBjb25zdCBzcCA9IEZpZWxkLm1vZChzZWNrZXkpO1xuICAgIGNvbnN0IHNoID0gUC5tdWwoc3ApO1xuICAgIHJldHVybiBzaC5idWZmO1xufVxuZnVuY3Rpb24gZ2V0U2hhcmVkQ29kZShzZWxmX3NlYywgcGVlcl9wdWIsIHRhZyA9ICdlY2RoL2NvZGUnKSB7XG4gICAgY29uc3QgaGFzaCA9IGhhc2h0YWcodGFnKTtcbiAgICBjb25zdCBzZWMgPSBnZXRTZWNyZXRLZXkoc2VsZl9zZWMpO1xuICAgIGNvbnN0IHB1YiA9IGdldFB1YmxpY0tleShzZWMpO1xuICAgIGNvbnN0IHBlZXIgPSBCdWZmLmJ5dGVzKHBlZXJfcHViKTtcbiAgICBjb25zdCBsaW5rID0gZ2V0U2hhcmVkS2V5KHNlYywgcGVlcik7XG4gICAgY29uc3Qga2V5cyA9IFtwdWIuaGV4LCBwZWVyLmhleF07XG4gICAga2V5cy5zb3J0KCk7XG4gICAgcmV0dXJuIGhtYWM1MTIobGluaywgQnVmZi5qb2luKFtoYXNoLCAuLi5rZXlzXSkpO1xufVxuZnVuY3Rpb24gaXNfZXZlbl9wdWIocHVia2V5KSB7XG4gICAgY29uc3QgcHViID0gQnVmZi5ieXRlcyhwdWJrZXkpO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIChwdWIubGVuZ3RoID09PSAzMik6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAocHViLmxlbmd0aCA9PT0gMzMgJiYgcHViWzBdID09PSAweDAyKTpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIChwdWIubGVuZ3RoID09PSAzMyAmJiBwdWJbMF0gPT09IDB4MDMpOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwdWJsaWMga2V5OiAke3B1Yi5oZXh9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24geG9ubHlfcHViKHB1YmtleSkge1xuICAgIGNvbnN0IGtleSA9IEJ1ZmYuYnl0ZXMocHVia2V5KTtcbiAgICBzd2l0Y2ggKGtleS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICByZXR1cm4ga2V5LnNsaWNlKDEsIDMzKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBrZXkgbGVuZ3RoOiAke2tleS5sZW5ndGh9YCk7XG4gICAgfVxufVxuXG52YXIga2V5ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZW5TZWNyZXRLZXk6IGdlblNlY3JldEtleSxcbiAgICBnZXRQdWJsaWNLZXk6IGdldFB1YmxpY0tleSxcbiAgICBnZXRTZWNyZXRLZXk6IGdldFNlY3JldEtleSxcbiAgICBnZXRTaGFyZWRDb2RlOiBnZXRTaGFyZWRDb2RlLFxuICAgIGdldFNoYXJlZEtleTogZ2V0U2hhcmVkS2V5LFxuICAgIGlzX2V2ZW5fcHViOiBpc19ldmVuX3B1YixcbiAgICB4b25seV9wdWI6IHhvbmx5X3B1YlxufSk7XG5cbih7XG4gICAgYXV4OiBCdWZmLnJhbmRvbSgzMiksXG4gICAgdGhyb3dzOiBmYWxzZSxcbiAgICB4b25seTogdHJ1ZVxufSk7XG5cbmNvbnN0IG5vYmxlID0geyBzZWNwOiBzZWNwMjU2azEsIHNjaG5vcnIgfTtcbmNvbnN0IHV0aWwkMSA9IHsgLi4ua2V5LCAuLi51dGwgfTtcblxuZnVuY3Rpb24gaGFzaDE2MHBraChwdWJrZXkpIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmYkMS5ieXRlcyhwdWJrZXkpO1xuICAgIGNoZWNrU2l6ZShieXRlcywgMzMpO1xuICAgIHJldHVybiBoYXNoMTYwKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGhhc2gxNjBzaChzY3JpcHQpIHtcbiAgICBjb25zdCBieXRlcyA9IFNjcmlwdC5mbXQudG9CeXRlcyhzY3JpcHQsIGZhbHNlKTtcbiAgICByZXR1cm4gaGFzaDE2MChieXRlcyk7XG59XG5mdW5jdGlvbiBzaGEyNTZzaChzY3JpcHQpIHtcbiAgICBjb25zdCBieXRlcyA9IFNjcmlwdC5mbXQudG9CeXRlcyhzY3JpcHQsIGZhbHNlKTtcbiAgICByZXR1cm4gc2hhMjU2KGJ5dGVzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2skNChhZGRyZXNzLCBuZXR3b3JrID0gJ21haW4nKSB7XG4gICAgY29uc3QgcHJlZml4ZXMgPSAobmV0d29yayA9PT0gJ21haW4nKSA/IFsnMSddIDogWydtJywgJ24nXTtcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgICAgICBpZiAoYWRkcmVzcy5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVuY29kZSQ0KGlucHV0LCBuZXR3b3JrID0gJ21haW4nKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmJDEuYnl0ZXMoaW5wdXQpO1xuICAgIGNvbnN0IHByZWZpeCA9IChuZXR3b3JrID09PSAnbWFpbicpID8gQnVmZiQxLm51bSgweDAwKSA6IEJ1ZmYkMS5udW0oMHg2Rik7XG4gICAgY2hlY2tTaXplKGlucHV0LCAyMCk7XG4gICAgcmV0dXJuIGJ5dGVzLnByZXBlbmQocHJlZml4KS50b2I1OGNoaygpO1xufVxuZnVuY3Rpb24gZGVjb2RlJDQoYWRkcmVzcywgbmV0d29yayA9ICdtYWluJykge1xuICAgIGlmICghY2hlY2skNChhZGRyZXNzLCBuZXR3b3JrKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHAycGtoIGFkZHJlc3MhJyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmJDEuYjU4Y2hrKGFkZHJlc3MpLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gc2NyaXB0UHViS2V5JDQoaW5wdXQpIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmYkMS5ieXRlcyhpbnB1dCk7XG4gICAgY2hlY2tTaXplKGJ5dGVzLCAyMCk7XG4gICAgcmV0dXJuIFsnT1BfRFVQJywgJ09QX0hBU0gxNjAnLCBieXRlcy5oZXgsICdPUF9FUVVBTFZFUklGWScsICdPUF9DSEVDS1NJRyddO1xufVxuZnVuY3Rpb24gZnJvbVB1YktleSQyKHB1YmtleSwgbmV0d29yaykge1xuICAgIGNvbnN0IHBraCA9IGhhc2gxNjBwa2gocHVia2V5KTtcbiAgICByZXR1cm4gZW5jb2RlJDQocGtoLCBuZXR3b3JrKTtcbn1cbmNvbnN0IFAyUEtIID0geyBjaGVjazogY2hlY2skNCwgZW5jb2RlOiBlbmNvZGUkNCwgZGVjb2RlOiBkZWNvZGUkNCwgaGFzaDogaGFzaDE2MHBraCwgc2NyaXB0UHViS2V5OiBzY3JpcHRQdWJLZXkkNCwgZnJvbVB1YktleTogZnJvbVB1YktleSQyIH07XG5cbmZ1bmN0aW9uIGNoZWNrJDMoYWRkcmVzcywgbmV0d29yayA9ICdtYWluJykge1xuICAgIGNvbnN0IHByZWZpeGVzID0gKG5ldHdvcmsgPT09ICdtYWluJykgPyBbJzMnXSA6IFsnMiddO1xuICAgIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW5jb2RlJDMoaW5wdXQsIG5ldHdvcmsgPSAnbWFpbicpIHtcbiAgICBjb25zdCBwcmVmaXggPSAobmV0d29yayA9PT0gJ21haW4nKSA/IEJ1ZmYkMS5udW0oMHgwNSkgOiBCdWZmJDEubnVtKDB4QzQpO1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZiQxLmJ5dGVzKGlucHV0KTtcbiAgICBjaGVja1NpemUoYnl0ZXMsIDIwKTtcbiAgICByZXR1cm4gYnl0ZXMucHJlcGVuZChwcmVmaXgpLnRvYjU4Y2hrKCk7XG59XG5mdW5jdGlvbiBkZWNvZGUkMyhhZGRyZXNzLCBuZXR3b3JrID0gJ21haW4nKSB7XG4gICAgaWYgKCFjaGVjayQzKGFkZHJlc3MsIG5ldHdvcmspKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcDJzaCBhZGRyZXNzIGZvciBuZXR3b3JrICR7bmV0d29ya306YCArIGFkZHJlc3MpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZiQxLmI1OGNoayhhZGRyZXNzKS5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIHNjcmlwdFB1YktleSQzKGlucHV0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmJDEuYnl0ZXMoaW5wdXQpO1xuICAgIHJldHVybiBbJ09QX0hBU0gxNjAnLCBieXRlcy5oZXgsICdPUF9FUVVBTCddO1xufVxuZnVuY3Rpb24gZnJvbVNjcmlwdCQxKHNjcmlwdCwgbmV0d29yaykge1xuICAgIGNvbnN0IHNjcmlwdEhhc2ggPSBoYXNoMTYwc2goc2NyaXB0KTtcbiAgICByZXR1cm4gZW5jb2RlJDMoc2NyaXB0SGFzaCwgbmV0d29yayk7XG59XG5jb25zdCBQMlNIID0geyBjaGVjazogY2hlY2skMywgZW5jb2RlOiBlbmNvZGUkMywgZGVjb2RlOiBkZWNvZGUkMywgaGFzaDogaGFzaDE2MHNoLCBzY3JpcHRQdWJLZXk6IHNjcmlwdFB1YktleSQzLCBmcm9tU2NyaXB0OiBmcm9tU2NyaXB0JDEgfTtcblxuY29uc3QgQkVDSDMyX1BSRUZJWEVTID0ge1xuICAgIG1haW46ICdiYycsXG4gICAgdGVzdG5ldDogJ3RiJyxcbiAgICBzaWduZXQ6ICd0YicsXG4gICAgcmVndGVzdDogJ2JjcnQnXG59O1xuXG5jb25zdCBWQUxJRF9QUkVGSVhFUyQyID0gWydiYzFxJywgJ3RiMXEnLCAnYmNydDFxJ107XG5mdW5jdGlvbiBjaGVjayQyKGFkZHJlc3MpIHtcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBWQUxJRF9QUkVGSVhFUyQyKSB7XG4gICAgICAgIGlmIChhZGRyZXNzLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW5jb2RlJDIoaW5wdXQsIG5ldHdvcmsgPSAnbWFpbicpIHtcbiAgICBjb25zdCBwcmVmaXggPSBCRUNIMzJfUFJFRklYRVNbbmV0d29ya107XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmJDEuYnl0ZXMoaW5wdXQpO1xuICAgIGNoZWNrU2l6ZShieXRlcywgMjApO1xuICAgIHJldHVybiBieXRlcy50b0JlY2gzMihwcmVmaXgsIDApO1xufVxuZnVuY3Rpb24gZGVjb2RlJDIoYWRkcmVzcykge1xuICAgIGlmICghY2hlY2skMihhZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNlZ3dpdCBhZGRyZXNzIScpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZiQxLmJlY2gzMihhZGRyZXNzKTtcbn1cbmZ1bmN0aW9uIHNjcmlwdFB1YktleSQyKGlucHV0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmJDEuYnl0ZXMoaW5wdXQpO1xuICAgIGNoZWNrU2l6ZShieXRlcywgMjApO1xuICAgIHJldHVybiBbJ09QXzAnLCBieXRlcy5oZXhdO1xufVxuZnVuY3Rpb24gZnJvbVB1YktleSQxKHB1YmtleSwgbmV0d29yaykge1xuICAgIGNvbnN0IHBraCA9IGhhc2gxNjBwa2gocHVia2V5KTtcbiAgICByZXR1cm4gZW5jb2RlJDIocGtoLCBuZXR3b3JrKTtcbn1cbmNvbnN0IFAyV1BLSCA9IHsgY2hlY2s6IGNoZWNrJDIsIGVuY29kZTogZW5jb2RlJDIsIGRlY29kZTogZGVjb2RlJDIsIGhhc2g6IGhhc2gxNjBwa2gsIHNjcmlwdFB1YktleTogc2NyaXB0UHViS2V5JDIsIGZyb21QdWJLZXk6IGZyb21QdWJLZXkkMSB9O1xuXG5jb25zdCBWQUxJRF9QUkVGSVhFUyQxID0gWydiYzFxJywgJ3RiMXEnLCAnYmNydDFxJ107XG5mdW5jdGlvbiBjaGVjayQxKGFkZHJlc3MpIHtcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBWQUxJRF9QUkVGSVhFUyQxKSB7XG4gICAgICAgIGlmIChhZGRyZXNzLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW5jb2RlJDEoaW5wdXQsIG5ldHdvcmsgPSAnbWFpbicpIHtcbiAgICBjb25zdCBwcmVmaXggPSBCRUNIMzJfUFJFRklYRVNbbmV0d29ya107XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmJDEuYnl0ZXMoaW5wdXQpO1xuICAgIGNoZWNrU2l6ZShieXRlcywgMzIpO1xuICAgIHJldHVybiBieXRlcy50b0JlY2gzMihwcmVmaXgsIDApO1xufVxuZnVuY3Rpb24gZGVjb2RlJDEoYWRkcmVzcykge1xuICAgIGlmICghY2hlY2skMShhZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNlZ3dpdCBhZGRyZXNzIScpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZiQxLmJlY2gzMihhZGRyZXNzKTtcbn1cbmZ1bmN0aW9uIHNjcmlwdFB1YktleSQxKGlucHV0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmJDEuYnl0ZXMoaW5wdXQpO1xuICAgIGNoZWNrU2l6ZShieXRlcywgMzIpO1xuICAgIHJldHVybiBbJ09QXzAnLCBieXRlcy5oZXhdO1xufVxuZnVuY3Rpb24gZnJvbVNjcmlwdChzY3JpcHQsIG5ldHdvcmspIHtcbiAgICBjb25zdCBzaCA9IHNoYTI1NnNoKHNjcmlwdCk7XG4gICAgcmV0dXJuIGVuY29kZSQxKHNoLCBuZXR3b3JrKTtcbn1cbmNvbnN0IFAyV1NIID0geyBjaGVjazogY2hlY2skMSwgZW5jb2RlOiBlbmNvZGUkMSwgZGVjb2RlOiBkZWNvZGUkMSwgaGFzaDogc2hhMjU2c2gsIHNjcmlwdFB1YktleTogc2NyaXB0UHViS2V5JDEsIGZyb21TY3JpcHQgfTtcblxuZnVuY3Rpb24geE9ubHlQdWIoa2V5KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmJDEuYnl0ZXMoa2V5KTtcbiAgICByZXR1cm4gKGJ5dGVzLmxlbmd0aCA+IDMyKSA/IGJ5dGVzLnNsaWNlKDEsIDMzKSA6IGJ5dGVzO1xufVxuXG5jb25zdCBWQUxJRF9QUkVGSVhFUyA9IFsnYmMxcCcsICd0YjFwJywgJ2JjcnQxcCddO1xuZnVuY3Rpb24gY2hlY2soYWRkcmVzcykge1xuICAgIGZvciAoY29uc3QgcHJlZml4IG9mIFZBTElEX1BSRUZJWEVTKSB7XG4gICAgICAgIGlmIChhZGRyZXNzLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW5jb2RlKGlucHV0LCBuZXR3b3JrID0gJ21haW4nKSB7XG4gICAgY29uc3QgcHJlZml4ID0gQkVDSDMyX1BSRUZJWEVTW25ldHdvcmtdO1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZiQxLmJ5dGVzKGlucHV0KTtcbiAgICBjaGVja1NpemUoYnl0ZXMsIDMyKTtcbiAgICByZXR1cm4gYnl0ZXMudG9CZWNoMzIocHJlZml4LCAxKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShhZGRyZXNzKSB7XG4gICAgaWYgKCFjaGVjayhhZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRhcHJvb3QgYWRkcmVzcyEnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmYkMS5iZWNoMzIoYWRkcmVzcyk7XG59XG5mdW5jdGlvbiBzY3JpcHRQdWJLZXkoaW5wdXQpIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmYkMS5ieXRlcyhpbnB1dCk7XG4gICAgY2hlY2tTaXplKGJ5dGVzLCAzMik7XG4gICAgcmV0dXJuIFsnT1BfMScsIGJ5dGVzLmhleF07XG59XG5mdW5jdGlvbiBmcm9tUHViS2V5KHB1YmtleSwgbmV0d29yaykge1xuICAgIGNvbnN0IGJ5dGVzID0geE9ubHlQdWIocHVia2V5KTtcbiAgICByZXR1cm4gZW5jb2RlKGJ5dGVzLCBuZXR3b3JrKTtcbn1cbmNvbnN0IFAyVFIgPSB7IGNoZWNrLCBlbmNvZGUsIGRlY29kZSwgc2NyaXB0UHViS2V5LCBmcm9tUHViS2V5IH07XG5cbmNvbnN0IERFRkFVTFRfVFggPSB7XG4gICAgdmVyc2lvbjogMixcbiAgICB2aW46IFtdLFxuICAgIHZvdXQ6IFtdLFxuICAgIGxvY2t0aW1lOiAwXG59O1xuY29uc3QgREVGQVVMVF9WSU4gPSB7XG4gICAgc2NyaXB0U2lnOiBbXSxcbiAgICBzZXF1ZW5jZTogNDI5NDk2NzI5MyxcbiAgICB3aXRuZXNzOiBbXVxufTtcbmNvbnN0IERFRkFVTFRfVk9VVCA9IHtcbiAgICB2YWx1ZTogMG4sXG4gICAgc2NyaXB0UHViS2V5OiBbXVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVR4KHRlbXBsYXRlKSB7XG4gICAgY29uc3QgdHggPSB7IC4uLkRFRkFVTFRfVFgsIC4uLnRlbXBsYXRlIH07XG4gICAgdHgudmluID0gdHgudmluLm1hcCh0eGluID0+IHsgcmV0dXJuIHsgLi4uREVGQVVMVF9WSU4sIC4uLnR4aW4gfTsgfSk7XG4gICAgdHgudm91dCA9IHR4LnZvdXQubWFwKHR4b3V0ID0+IHsgcmV0dXJuIHsgLi4uREVGQVVMVF9WT1VULCAuLi50eG91dCB9OyB9KTtcbiAgICByZXR1cm4gdHg7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4KHR4ZGF0YSwgb21pdFdpdG5lc3MpIHtcbiAgICBjb25zdCB7IHZlcnNpb24sIHZpbiwgdm91dCwgbG9ja3RpbWUgfSA9IGNyZWF0ZVR4KHR4ZGF0YSk7XG4gICAgY29uc3QgdXNlV2l0bmVzcyA9IChvbWl0V2l0bmVzcyAhPT0gdHJ1ZSAmJiBjaGVja0ZvcldpdG5lc3ModmluKSk7XG4gICAgY29uc3QgcmF3ID0gW2VuY29kZVZlcnNpb24odmVyc2lvbildO1xuICAgIGlmICh1c2VXaXRuZXNzKSB7XG4gICAgICAgIHJhdy5wdXNoKEJ1ZmYkMS5oZXgoJzAwMDEnKSk7XG4gICAgfVxuICAgIHJhdy5wdXNoKGVuY29kZUlucHV0cyh2aW4pKTtcbiAgICByYXcucHVzaChlbmNvZGVPdXRwdXRzKHZvdXQpKTtcbiAgICBmb3IgKGNvbnN0IHR4aW4gb2YgdmluKSB7XG4gICAgICAgIGlmICh1c2VXaXRuZXNzKSB7XG4gICAgICAgICAgICByYXcucHVzaChlbmNvZGVXaXRuZXNzKHR4aW4ud2l0bmVzcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJhdy5wdXNoKGVuY29kZUxvY2t0aW1lKGxvY2t0aW1lKSk7XG4gICAgcmV0dXJuIEJ1ZmYkMS5qb2luKHJhdyk7XG59XG5mdW5jdGlvbiBjaGVja0ZvcldpdG5lc3ModmluKSB7XG4gICAgZm9yIChjb25zdCB0eGluIG9mIHZpbikge1xuICAgICAgICBjb25zdCB7IHdpdG5lc3MgfSA9IHR4aW47XG4gICAgICAgIGlmICh0eXBlb2Ygd2l0bmVzcyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHdpdG5lc3MgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh3aXRuZXNzKSAmJiB3aXRuZXNzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBlbmNvZGVWZXJzaW9uKG51bSkge1xuICAgIHJldHVybiBCdWZmJDEubnVtKG51bSwgNCkucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gZW5jb2RlVHhpZCh0eGlkKSB7XG4gICAgcmV0dXJuIEJ1ZmYkMS5oZXgodHhpZCwgMzIpLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVByZXZPdXQodm91dCkge1xuICAgIHJldHVybiBCdWZmJDEubnVtKHZvdXQsIDQpLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNlcXVlbmNlKHNlcXVlbmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzZXF1ZW5jZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYkMS5oZXgoc2VxdWVuY2UsIDQpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXF1ZW5jZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYkMS5udW0oc2VxdWVuY2UsIDQpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgZm9ybWF0OiAnICsgU3RyaW5nKHNlcXVlbmNlKSk7XG59XG5mdW5jdGlvbiBlbmNvZGVJbnB1dHMoYXJyKSB7XG4gICAgY29uc3QgcmF3ID0gW0J1ZmYkMS52YXJJbnQoYXJyLmxlbmd0aCwgJ2xlJyldO1xuICAgIGZvciAoY29uc3QgdmluIG9mIGFycikge1xuICAgICAgICBjb25zdCB7IHR4aWQsIHZvdXQsIHNjcmlwdFNpZywgc2VxdWVuY2UgfSA9IHZpbjtcbiAgICAgICAgcmF3LnB1c2goZW5jb2RlVHhpZCh0eGlkKSk7XG4gICAgICAgIHJhdy5wdXNoKGVuY29kZVByZXZPdXQodm91dCkpO1xuICAgICAgICByYXcucHVzaChlbmNvZGVTY3JpcHQoc2NyaXB0U2lnLCB0cnVlKSk7XG4gICAgICAgIHJhdy5wdXNoKGVuY29kZVNlcXVlbmNlKHNlcXVlbmNlKSk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmJDEuam9pbihyYXcpO1xufVxuZnVuY3Rpb24gZW5jb2RlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAodmFsdWUgJSAxICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG11c3QgYmUgYW4gaW50ZWdlcjonICsgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmYkMS5udW0odmFsdWUsIDgpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmYkMS5iaWcodmFsdWUsIDgpLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZU91dHB1dHMoYXJyKSB7XG4gICAgY29uc3QgcmF3ID0gW0J1ZmYkMS52YXJJbnQoYXJyLmxlbmd0aCwgJ2xlJyldO1xuICAgIGZvciAoY29uc3Qgdm91dCBvZiBhcnIpIHtcbiAgICAgICAgcmF3LnB1c2goZW5jb2RlT3V0cHV0KHZvdXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmYkMS5qb2luKHJhdyk7XG59XG5mdW5jdGlvbiBlbmNvZGVPdXRwdXQodm91dCkge1xuICAgIGNvbnN0IHsgdmFsdWUsIHNjcmlwdFB1YktleSB9ID0gdm91dDtcbiAgICBjb25zdCByYXcgPSBbXTtcbiAgICByYXcucHVzaChlbmNvZGVWYWx1ZSh2YWx1ZSkpO1xuICAgIHJhdy5wdXNoKGVuY29kZVNjcmlwdChzY3JpcHRQdWJLZXksIHRydWUpKTtcbiAgICByZXR1cm4gQnVmZiQxLmpvaW4ocmF3KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVdpdG5lc3MoZGF0YSA9IFtdKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBCdWZmJDEudmFySW50KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgYnVmZmVyLnB1c2goY291bnQpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGVuY29kZURhdGEoZW50cnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZiQxLmpvaW4oYnVmZmVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBCdWZmJDEuYnl0ZXMoZGF0YSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5jb2RlRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuICghaXNFbXB0eShkYXRhKSlcbiAgICAgICAgPyBlbmNvZGVTY3JpcHQoZGF0YSwgdHJ1ZSlcbiAgICAgICAgOiBuZXcgQnVmZiQxKDApO1xufVxuZnVuY3Rpb24gaXNFbXB0eShkYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkYXRhID09PSAnJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IEJ1ZmYkMS5ieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdID09PSAwO1xufVxuZnVuY3Rpb24gZW5jb2RlTG9ja3RpbWUobG9ja3RpbWUpIHtcbiAgICBpZiAodHlwZW9mIGxvY2t0aW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQnVmZiQxLmhleChsb2NrdGltZSwgNCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbG9ja3RpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBCdWZmJDEubnVtKGxvY2t0aW1lLCA0KS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGZvcm1hdDogJyArIFN0cmluZyhsb2NrdGltZSkpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeChieXRlcykge1xuICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ5dGVzID0gQnVmZiQxLmhleChieXRlcykucmF3O1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtJDEoYnl0ZXMpO1xuICAgIGNvbnN0IHZlcnNpb24gPSByZWFkVmVyc2lvbihzdHJlYW0pO1xuICAgIGNvbnN0IGhhc1dpdG5lc3MgPSBjaGVja1dpdG5lc3NGbGFnKHN0cmVhbSk7XG4gICAgY29uc3QgdmluID0gcmVhZElucHV0cyhzdHJlYW0pO1xuICAgIGNvbnN0IHZvdXQgPSByZWFkT3V0cHV0cyhzdHJlYW0pO1xuICAgIGlmIChoYXNXaXRuZXNzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdHhpbiBvZiB2aW4pIHtcbiAgICAgICAgICAgIHR4aW4ud2l0bmVzcyA9IHJlYWRXaXRuZXNzJDEoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsb2NrdGltZSA9IHJlYWRMb2NrdGltZShzdHJlYW0pO1xuICAgIHJldHVybiB7IHZlcnNpb24sIHZpbiwgdm91dCwgbG9ja3RpbWUgfTtcbn1cbmZ1bmN0aW9uIHJlYWRWZXJzaW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBzdHJlYW0ucmVhZCg0KS5yZXZlcnNlKCkudG9OdW0oKTtcbn1cbmZ1bmN0aW9uIGNoZWNrV2l0bmVzc0ZsYWcoc3RyZWFtKSB7XG4gICAgY29uc3QgW21hcmtlciwgZmxhZ10gPSBbLi4uc3RyZWFtLnBlZWsoMildO1xuICAgIGlmIChtYXJrZXIgPT09IDApIHtcbiAgICAgICAgc3RyZWFtLnJlYWQoMik7XG4gICAgICAgIGlmIChmbGFnID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aXRuZXNzIGZsYWc6ICR7ZmxhZ31gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWFkSW5wdXRzKHN0cmVhbSkge1xuICAgIGNvbnN0IGlucHV0cyA9IFtdO1xuICAgIGNvbnN0IHZpbkNvdW50ID0gc3RyZWFtLnJlYWRTaXplKCdsZScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmluQ291bnQ7IGkrKykge1xuICAgICAgICBpbnB1dHMucHVzaChyZWFkSW5wdXQoc3RyZWFtKSk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dHM7XG59XG5mdW5jdGlvbiByZWFkSW5wdXQoc3RyZWFtKSB7XG4gICAgY29uc3QgdHhpbiA9IHtcbiAgICAgICAgdHhpZDogc3RyZWFtLnJlYWQoMzIpLnJldmVyc2UoKS50b0hleCgpLFxuICAgICAgICB2b3V0OiBzdHJlYW0ucmVhZCg0KS5yZXZlcnNlKCkudG9OdW0oKSxcbiAgICAgICAgc2NyaXB0U2lnOiByZWFkU2NyaXB0KHN0cmVhbSwgdHJ1ZSksXG4gICAgICAgIHNlcXVlbmNlOiBzdHJlYW0ucmVhZCg0KS5yZXZlcnNlKCkudG9IZXgoKSxcbiAgICAgICAgd2l0bmVzczogW11cbiAgICB9O1xuICAgIHJldHVybiB0eGluO1xufVxuZnVuY3Rpb24gcmVhZE91dHB1dHMoc3RyZWFtKSB7XG4gICAgY29uc3Qgb3V0cHV0cyA9IFtdO1xuICAgIGNvbnN0IG91dGNvdW50ID0gc3RyZWFtLnJlYWRTaXplKCdsZScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Y291bnQ7IGkrKykge1xuICAgICAgICBvdXRwdXRzLnB1c2gocmVhZE91dHB1dChzdHJlYW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dHM7XG59XG5mdW5jdGlvbiByZWFkT3V0cHV0KHN0cmVhbSkge1xuICAgIGNvbnN0IHR4b3V0ID0ge1xuICAgICAgICB2YWx1ZTogc3RyZWFtLnJlYWQoOCkucmV2ZXJzZSgpLmJpZyxcbiAgICAgICAgc2NyaXB0UHViS2V5OiByZWFkU2NyaXB0KHN0cmVhbSwgdHJ1ZSlcbiAgICB9O1xuICAgIHJldHVybiB0eG91dDtcbn1cbmZ1bmN0aW9uIHJlYWRXaXRuZXNzJDEoc3RyZWFtKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBjb25zdCBjb3VudCA9IHN0cmVhbS5yZWFkU2l6ZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCB3b3JkID0gcmVhZERhdGEoc3RyZWFtLCB0cnVlKTtcbiAgICAgICAgc3RhY2sucHVzaCh3b3JkID8/ICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuZnVuY3Rpb24gcmVhZERhdGEoc3RyZWFtLCB2YXJpbnQpIHtcbiAgICBjb25zdCBzaXplID0gKHZhcmludCA9PT0gdHJ1ZSlcbiAgICAgICAgPyBzdHJlYW0ucmVhZFNpemUoJ2xlJylcbiAgICAgICAgOiBzdHJlYW0uc2l6ZTtcbiAgICByZXR1cm4gc2l6ZSA+IDBcbiAgICAgICAgPyBzdHJlYW0ucmVhZChzaXplKS5oZXhcbiAgICAgICAgOiBudWxsO1xufVxuZnVuY3Rpb24gcmVhZFNjcmlwdChzdHJlYW0sIHZhcmludCkge1xuICAgIGNvbnN0IGRhdGEgPSByZWFkRGF0YShzdHJlYW0sIHZhcmludCk7XG4gICAgcmV0dXJuIChkYXRhICE9PSBudWxsKSA/IGRhdGEgOiBbXTtcbn1cbmZ1bmN0aW9uIHJlYWRMb2NrdGltZShzdHJlYW0pIHtcbiAgICByZXR1cm4gc3RyZWFtLnJlYWQoNCkucmV2ZXJzZSgpLnRvTnVtKCk7XG59XG5cbmZ1bmN0aW9uIHRvSnNvbih0eGRhdGEpIHtcbiAgICBpZiAoaXNCeXRlcyQxKHR4ZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVR4KHR4ZGF0YSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHhkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhKHR4ZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIGVuY29kZVR4KHR4ZGF0YSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVUeCh0eGRhdGEpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZm9ybWF0OiAnICsgU3RyaW5nKHR5cGVvZiB0eGRhdGEpKTtcbn1cbmZ1bmN0aW9uIHRvQnl0ZXModHhkYXRhKSB7XG4gICAgaWYgKGlzQnl0ZXMkMSh0eGRhdGEpKSB7XG4gICAgICAgIGRlY29kZVR4KHR4ZGF0YSk7XG4gICAgICAgIHJldHVybiBCdWZmJDEuYnl0ZXModHhkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0eGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVUeCh0eGRhdGEpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZm9ybWF0OiAnICsgU3RyaW5nKHR5cGVvZiB0eGRhdGEpKTtcbn1cbmNvbnN0IFR4Rm10ID0ge1xuICAgIHRvQnl0ZXMsXG4gICAgdG9Kc29uXG59O1xuXG5jb25zdCBPVVRQVVRfVFlQRVMgPSBbXG4gICAgWydwMnBraCcsIC9eNzZhOTE0KD88aGFzaD5cXHd7NDB9KTg4YWMkL10sXG4gICAgWydwMnNoJywgL15hOTE0KD88aGFzaD5cXHd7NDB9KTg3JC9dLFxuICAgIFsncDJ3LXBraCcsIC9eMDAxNCg/PGhhc2g+XFx3ezQwfSkkL10sXG4gICAgWydwMnctc2gnLCAvXjAwMjAoPzxoYXNoPlxcd3s2NH0pJC9dLFxuICAgIFsncDJ0cicsIC9eNTEyMCg/PGhhc2g+XFx3ezY0fSkkL11cbl07XG5jb25zdCBMRUFGX1ZFUlNJT05TID0gW1xuICAgIDB4YzAsIDB4YzIsIDB4YzQsIDB4YzYsIDB4YzgsIDB4Y2EsIDB4Y2MsIDB4Y2UsXG4gICAgMHhkMCwgMHhkMiwgMHhkNCwgMHhkNiwgMHhkOCwgMHhkYSwgMHhkYywgMHhkZSxcbiAgICAweGUwLCAweGUyLCAweGU0LCAweGU2LCAweGU4LCAweGVhLCAweGVjLCAweGVlLFxuICAgIDB4ZjAsIDB4ZjIsIDB4ZjQsIDB4ZjYsIDB4ZjgsIDB4ZmEsIDB4ZmMsIDB4ZmUsXG4gICAgMHg2NiwgMHg3ZSwgMHg4MCwgMHg4NCwgMHg5NiwgMHg5OCwgMHhiYSwgMHhiYyxcbiAgICAweGJlXG5dO1xuZnVuY3Rpb24gcGFyc2VBbm5leChkYXRhKSB7XG4gICAgbGV0IGl0ZW0gPSBkYXRhLmF0KC0xKTtcbiAgICBpZiAoaXNIZXgoaXRlbSkpIHtcbiAgICAgICAgaXRlbSA9IEJ1ZmYkMS5oZXgoaXRlbSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiZcbiAgICAgICAgaXRlbVswXSA9PT0gMHg1MCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgICByZXR1cm4gQnVmZiQxLnJhdyhpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrKGRhdGEpIHtcbiAgICBsZXQgaXRlbSA9IGRhdGEuYXQoLTEpO1xuICAgIGlmIChpc0hleChpdGVtKSkge1xuICAgICAgICBpdGVtID0gQnVmZiQxLmhleChpdGVtKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSAmJlxuICAgICAgICBpdGVtIGluc3RhbmNlb2YgVWludDhBcnJheSAmJlxuICAgICAgICBpdGVtLmxlbmd0aCA+IDMyICYmXG4gICAgICAgIExFQUZfVkVSU0lPTlMuaW5jbHVkZXMoaXRlbVswXSAmIDB4ZmUpKSB7XG4gICAgICAgIGRhdGEucG9wKCk7XG4gICAgICAgIHJldHVybiBCdWZmJDEucmF3KGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlV2l0U2NyaXB0KGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhLmF0KC0xKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IFNjcmlwdC5mbXQudG9CeXRlcyhpdGVtKTtcbiAgICAgICAgICAgIGRhdGEucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VQYXJhbXMoZGF0YSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZCBvZiBkYXRhKSB7XG4gICAgICAgIGlmIChpc0hleChkKSB8fFxuICAgICAgICAgICAgZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgICAgIHR5cGVvZiBkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goQnVmZiQxLmJ5dGVzKGQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHZhbHVlOiAnICsgU3RyaW5nKGQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gcmVhZFdpdG5lc3MoZGF0YSA9IFtdKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbLi4uZGF0YV07XG4gICAgY29uc3QgYW5uZXggPSBwYXJzZUFubmV4KGl0ZW1zKTtcbiAgICBjb25zdCBjYmxvY2sgPSBwYXJzZUJsb2NrKGl0ZW1zKTtcbiAgICBjb25zdCBzY3JpcHQgPSBwYXJzZVdpdFNjcmlwdChpdGVtcyk7XG4gICAgY29uc3QgcGFyYW1zID0gcGFyc2VQYXJhbXMoaXRlbXMpO1xuICAgIHJldHVybiB7IGFubmV4LCBjYmxvY2ssIHNjcmlwdCwgcGFyYW1zIH07XG59XG5mdW5jdGlvbiByZWFkU2NyaXB0UHViS2V5KHNjcmlwdCkge1xuICAgIGNvbnN0IGhleCA9IFNjcmlwdC5mbXQudG9CeXRlcyhzY3JpcHQsIGZhbHNlKS5oZXg7XG4gICAgZm9yIChjb25zdCBba2V5dHlwZSwgcGF0dGVybl0gb2YgT1VUUFVUX1RZUEVTKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBrZXl0eXBlO1xuICAgICAgICBjb25zdCB7IGdyb3VwcyB9ID0gcGF0dGVybi5leGVjKGhleCkgPz8ge307XG4gICAgICAgIGNvbnN0IHsgaGFzaCB9ID0gZ3JvdXBzID8/IHt9O1xuICAgICAgICBpZiAoaXNIZXgoaGFzaCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGUsIGRhdGE6IEJ1ZmYkMS5oZXgoaGFzaCkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAncmF3JywgZGF0YTogQnVmZiQxLmhleChoZXgpIH07XG59XG5mdW5jdGlvbiBnZXRUeGlkKHR4ZGF0YSkge1xuICAgIGNvbnN0IGpzb24gPSBUeEZtdC50b0pzb24odHhkYXRhKTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlVHgoanNvbiwgdHJ1ZSk7XG4gICAgcmV0dXJuIGhhc2gyNTYoZGF0YSkucmV2ZXJzZSgpLmhleDtcbn1cbmZ1bmN0aW9uIGdldFR4U2l6ZSh0eGRhdGEpIHtcbiAgICBjb25zdCBqc29uID0gVHhGbXQudG9Kc29uKHR4ZGF0YSk7XG4gICAgY29uc3QgYnNpemUgPSBlbmNvZGVUeChqc29uLCB0cnVlKS5sZW5ndGg7XG4gICAgY29uc3QgZnNpemUgPSBlbmNvZGVUeChqc29uLCBmYWxzZSkubGVuZ3RoO1xuICAgIGNvbnN0IHdlaWdodCA9IGJzaXplICogMyArIGZzaXplO1xuICAgIGNvbnN0IHJlbWFpbiA9ICh3ZWlnaHQgJSA0ID4gMCkgPyAxIDogMDtcbiAgICBjb25zdCB2c2l6ZSA9IE1hdGguZmxvb3Iod2VpZ2h0IC8gNCkgKyByZW1haW47XG4gICAgcmV0dXJuIHsgc2l6ZTogZnNpemUsIGJzaXplLCB2c2l6ZSwgd2VpZ2h0IH07XG59XG5cbmNvbnN0IFR4ID0ge1xuICAgIGNyZWF0ZTogY3JlYXRlVHgsXG4gICAgZW5jb2RlOiBlbmNvZGVUeCxcbiAgICBkZWNvZGU6IGRlY29kZVR4LFxuICAgIGZtdDogVHhGbXQsXG4gICAgdXRpbDoge1xuICAgICAgICBnZXRUeFNpemUsXG4gICAgICAgIGdldFR4aWQsXG4gICAgICAgIHJlYWRTY3JpcHRQdWJLZXksXG4gICAgICAgIHJlYWRXaXRuZXNzXG4gICAgfVxufTtcblxuY29uc3QgQUREUkVTU19UWVBFUyA9IFtcbiAgICBbJzEnLCAncDJwa2gnLCAnbWFpbicsIDIwLCAnYmFzZTU4J10sXG4gICAgWyczJywgJ3Ayc2gnLCAnbWFpbicsIDIwLCAnYmFzZTU4J10sXG4gICAgWydtJywgJ3AycGtoJywgJ3Rlc3RuZXQnLCAyMCwgJ2Jhc2U1OCddLFxuICAgIFsnbicsICdwMnBraCcsICd0ZXN0bmV0JywgMjAsICdiYXNlNTgnXSxcbiAgICBbJzInLCAncDJzaCcsICd0ZXN0bmV0JywgMjAsICdiYXNlNTgnXSxcbiAgICBbJ2JjMXEnLCAncDJ3LXBraCcsICdtYWluJywgMjAsICdiZWNoMzInXSxcbiAgICBbJ3RiMXEnLCAncDJ3LXBraCcsICd0ZXN0bmV0JywgMjAsICdiZWNoMzInXSxcbiAgICBbJ2JjcnQxcScsICdwMnctcGtoJywgJ3JlZ3Rlc3QnLCAyMCwgJ2JlY2gzMiddLFxuICAgIFsnYmMxcScsICdwMnctc2gnLCAnbWFpbicsIDMyLCAnYmVjaDMyJ10sXG4gICAgWyd0YjFxJywgJ3Aydy1zaCcsICd0ZXN0bmV0JywgMzIsICdiZWNoMzInXSxcbiAgICBbJ2JjcnQxcScsICdwMnctc2gnLCAncmVndGVzdCcsIDMyLCAnYmVjaDMyJ10sXG4gICAgWydiYzFwJywgJ3AydHInLCAnbWFpbicsIDMyLCAnYmVjaDMybSddLFxuICAgIFsndGIxcCcsICdwMnRyJywgJ3Rlc3RuZXQnLCAzMiwgJ2JlY2gzMm0nXSxcbiAgICBbJ2JjcnQxcCcsICdwMnRyJywgJ3JlZ3Rlc3QnLCAzMiwgJ2JlY2gzMm0nXVxuXTtcbmZ1bmN0aW9uIGRlY29kZUZvcm1hdChhZGRyZXNzLCBmb3JtYXQpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICBjYXNlICdiYXNlNTgnOiByZXR1cm4gQnVmZiQxLmI1OGNoayhhZGRyZXNzKS5zbGljZSgxKTtcbiAgICAgICAgY2FzZSAnYmVjaDMyJzogcmV0dXJuIEJ1ZmYkMS5iZWNoMzIoYWRkcmVzcyk7XG4gICAgICAgIGNhc2UgJ2JlY2gzMm0nOiByZXR1cm4gQnVmZiQxLmJlY2gzMihhZGRyZXNzKTtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MgZm9ybWF0OiAnICsgZm9ybWF0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXREYXRhKGFkZHJlc3MpIHtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiBBRERSRVNTX1RZUEVTKSB7XG4gICAgICAgIGNvbnN0IFtwcmVmaXgsIF90eXBlLCBfbmV0d29yaywgc2l6ZSwgZm9ybWF0XSA9IHJvdztcbiAgICAgICAgaWYgKGFkZHJlc3Muc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGRlY29kZUZvcm1hdChhZGRyZXNzLCBmb3JtYXQpO1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzOiAnICsgYWRkcmVzcyk7XG59XG5mdW5jdGlvbiBnZXRUb29sKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncDJwa2gnOiByZXR1cm4gUDJQS0g7XG4gICAgICAgIGNhc2UgJ3Ayc2gnOiByZXR1cm4gUDJTSDtcbiAgICAgICAgY2FzZSAncDJ3LXBraCc6IHJldHVybiBQMldQS0g7XG4gICAgICAgIGNhc2UgJ3Aydy1zaCc6IHJldHVybiBQMldTSDtcbiAgICAgICAgY2FzZSAncDJ0cic6IHJldHVybiBQMlRSO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjb2RlQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgW3ByZWZpeCwgdHlwZSwgbmV0d29ya10gPSBnZXREYXRhKGFkZHJlc3MpO1xuICAgIGNvbnN0IHRvb2wgPSBnZXRUb29sKHR5cGUpO1xuICAgIGNvbnN0IGRhdGEgPSB0b29sLmRlY29kZShhZGRyZXNzLCBuZXR3b3JrKTtcbiAgICBjb25zdCBzY3JpcHQgPSB0b29sLnNjcmlwdFB1YktleShkYXRhKTtcbiAgICByZXR1cm4geyBwcmVmaXgsIHR5cGUsIG5ldHdvcmssIGRhdGEsIHNjcmlwdCB9O1xufVxuZnVuY3Rpb24gZnJvbVNjcmlwdFB1YktleShzY3JpcHQsIG5ldHdvcmspIHtcbiAgICBjb25zdCB7IHR5cGUsIGRhdGEgfSA9IFR4LnV0aWwucmVhZFNjcmlwdFB1YktleShzY3JpcHQpO1xuICAgIGNvbnN0IHRvb2wgPSBnZXRUb29sKHR5cGUpO1xuICAgIHJldHVybiB0b29sLmVuY29kZShkYXRhLCBuZXR3b3JrKTtcbn1cbmZ1bmN0aW9uIHRvU2NyaXB0UHViS2V5KGFkZHJlc3MpIHtcbiAgICBjb25zdCB7IHNjcmlwdCB9ID0gZGVjb2RlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICByZXR1cm4gU2NyaXB0LmZtdC50b0FzbShzY3JpcHQsIGZhbHNlKTtcbn1cblxuY29uc3QgQWRkcmVzcyA9IHtcbiAgICBwMnBraDogUDJQS0gsXG4gICAgcDJzaDogUDJTSCxcbiAgICBwMndwa2g6IFAyV1BLSCxcbiAgICBwMndzaDogUDJXU0gsXG4gICAgcDJ0cjogUDJUUixcbiAgICBkZWNvZGU6IGRlY29kZUFkZHJlc3MsXG4gICAgZnJvbVNjcmlwdFB1YktleSxcbiAgICB0b1NjcmlwdFB1YktleVxufTtcblxuY29uc3QgVkFMSURfSEFTSF9UWVBFUyQxID0gWzB4MDEsIDB4MDIsIDB4MDNdO1xuZnVuY3Rpb24gaGFzaFR4JDEodHhkYXRhLCBpZHgsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWdmbGFnID0gMHgwMSB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGlzQW55cGF5ID0gKHNpZ2ZsYWcgJiAweDgwKSA9PT0gMHg4MDtcbiAgICBjb25zdCBmbGFnID0gc2lnZmxhZyAlIDB4ODA7XG4gICAgaWYgKCFWQUxJRF9IQVNIX1RZUEVTJDEuaW5jbHVkZXMoZmxhZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhhc2ggdHlwZTogJyArIFN0cmluZyhzaWdmbGFnKSk7XG4gICAgfVxuICAgIGNvbnN0IHR4ID0gVHguZm10LnRvSnNvbih0eGRhdGEpO1xuICAgIGNvbnN0IHsgdmVyc2lvbiwgdmluLCB2b3V0LCBsb2NrdGltZSB9ID0gdHg7XG4gICAgY29uc3QgeyB0eGlkLCB2b3V0OiBwcmV2SWR4LCBwcmV2b3V0LCBzZXF1ZW5jZSB9ID0gdmluW2lkeF07XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gcHJldm91dCA/PyB7fTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByZXZvdXQgdmFsdWUgaXMgZW1wdHkhJyk7XG4gICAgfVxuICAgIGxldCBzY3JpcHQgPSBjb25maWcuc2NyaXB0O1xuICAgIGlmIChzY3JpcHQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBjb25maWcucHVia2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcGtoYXNoID0gaGFzaDE2MChjb25maWcucHVia2V5KTtcbiAgICAgICAgc2NyaXB0ID0gYDc2YTkxNCR7cGtoYXNoLmhleH04OGFjYDtcbiAgICB9XG4gICAgaWYgKHNjcmlwdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHVia2V5IC8gc2NyaXB0IGhhcyBiZWVuIHNldCEnKTtcbiAgICB9XG4gICAgaWYgKFNjcmlwdC5mbXQudG9Bc20oc2NyaXB0KS5pbmNsdWRlcygnT1BfQ09ERVNFUEFSQVRPUicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBsaWJyYXJ5IGRvZXMgbm90IGN1cnJlbnRseSBzdXBwb3J0IHRoZSB1c2Ugb2YgT1BfQ09ERVNFUEFSQVRPUiBpbiBzZWd3aXQgc2NyaXB0cy4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnaGFzaCA9IFtcbiAgICAgICAgZW5jb2RlVmVyc2lvbih2ZXJzaW9uKSxcbiAgICAgICAgaGFzaFByZXZvdXRzKHZpbiwgaXNBbnlwYXkpLFxuICAgICAgICBoYXNoU2VxdWVuY2UkMSh2aW4sIGZsYWcsIGlzQW55cGF5KSxcbiAgICAgICAgZW5jb2RlVHhpZCh0eGlkKSxcbiAgICAgICAgZW5jb2RlUHJldk91dChwcmV2SWR4KSxcbiAgICAgICAgU2NyaXB0LmVuY29kZShzY3JpcHQsIHRydWUpLFxuICAgICAgICBlbmNvZGVWYWx1ZSh2YWx1ZSksXG4gICAgICAgIGVuY29kZVNlcXVlbmNlKHNlcXVlbmNlKSxcbiAgICAgICAgaGFzaE91dHB1dHMkMSh2b3V0LCBpZHgsIGZsYWcpLFxuICAgICAgICBlbmNvZGVMb2NrdGltZShsb2NrdGltZSksXG4gICAgICAgIEJ1ZmYkMS5udW0oc2lnZmxhZywgNCkucmV2ZXJzZSgpXG4gICAgXTtcbiAgICByZXR1cm4gaGFzaDI1NihCdWZmJDEuam9pbihzaWdoYXNoKSk7XG59XG5mdW5jdGlvbiBoYXNoUHJldm91dHModmluLCBpc0FueXBheSkge1xuICAgIGlmIChpc0FueXBheSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gQnVmZiQxLm51bSgwLCAzMik7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgZm9yIChjb25zdCB7IHR4aWQsIHZvdXQgfSBvZiB2aW4pIHtcbiAgICAgICAgc3RhY2sucHVzaChlbmNvZGVUeGlkKHR4aWQpKTtcbiAgICAgICAgc3RhY2sucHVzaChlbmNvZGVQcmV2T3V0KHZvdXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2gyNTYoQnVmZiQxLmpvaW4oc3RhY2spKTtcbn1cbmZ1bmN0aW9uIGhhc2hTZXF1ZW5jZSQxKHZpbiwgc2lnZmxhZywgaXNBbnlQYXkpIHtcbiAgICBpZiAoaXNBbnlQYXkgfHwgc2lnZmxhZyAhPT0gMHgwMSkge1xuICAgICAgICByZXR1cm4gQnVmZiQxLm51bSgwLCAzMik7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgZm9yIChjb25zdCB7IHNlcXVlbmNlIH0gb2YgdmluKSB7XG4gICAgICAgIHN0YWNrLnB1c2goZW5jb2RlU2VxdWVuY2Uoc2VxdWVuY2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2gyNTYoQnVmZiQxLmpvaW4oc3RhY2spKTtcbn1cbmZ1bmN0aW9uIGhhc2hPdXRwdXRzJDEodm91dCwgaWR4LCBzaWdmbGFnKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBpZiAoc2lnZmxhZyA9PT0gMHgwMSkge1xuICAgICAgICBmb3IgKGNvbnN0IHsgdmFsdWUsIHNjcmlwdFB1YktleSB9IG9mIHZvdXQpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZW5jb2RlVmFsdWUodmFsdWUpKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goU2NyaXB0LmVuY29kZShzY3JpcHRQdWJLZXksIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzaDI1NihCdWZmJDEuam9pbihzdGFjaykpO1xuICAgIH1cbiAgICBpZiAoc2lnZmxhZyA9PT0gMHgwMyAmJiBpZHggPCB2b3V0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBzY3JpcHRQdWJLZXkgfSA9IHZvdXRbaWR4XTtcbiAgICAgICAgc3RhY2sucHVzaChlbmNvZGVWYWx1ZSh2YWx1ZSkpO1xuICAgICAgICBzdGFjay5wdXNoKFNjcmlwdC5lbmNvZGUoc2NyaXB0UHViS2V5LCB0cnVlKSk7XG4gICAgICAgIHJldHVybiBoYXNoMjU2KEJ1ZmYkMS5qb2luKHN0YWNrKSk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmJDEubnVtKDAsIDMyKTtcbn1cblxuZnVuY3Rpb24gc2lnblR4JDEoc2Vja2V5LCB0eGRhdGEsIGluZGV4LCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnZmxhZyA9IDB4MDEgfSA9IGNvbmZpZztcbiAgICBjb25zdCBoYXNoID0gaGFzaFR4JDEodHhkYXRhLCBpbmRleCwgY29uZmlnKTtcbiAgICBjb25zdCBzaWcgPSBub2JsZS5zZWNwLnNpZ24oaGFzaCwgc2Vja2V5KS50b0RFUlJhd0J5dGVzKHRydWUpO1xuICAgIHJldHVybiBCdWZmJDEuam9pbihbc2lnLCBzaWdmbGFnXSk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVR4JDEodHhkYXRhLCBpbmRleCwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCB0eCA9IFR4LmZtdC50b0pzb24odHhkYXRhKTtcbiAgICBjb25zdCB7IHRocm93cyA9IGZhbHNlIH0gPSBjb25maWc7XG4gICAgY29uc3QgeyB3aXRuZXNzID0gW10gfSA9IHR4LnZpbltpbmRleF07XG4gICAgY29uc3Qgd2l0bmVzc0RhdGEgPSBUeC51dGlsLnJlYWRXaXRuZXNzKHdpdG5lc3MpO1xuICAgIGNvbnN0IHsgc2NyaXB0LCBwYXJhbXMgfSA9IHdpdG5lc3NEYXRhO1xuICAgIGxldCBwdWIgPSBudWxsO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoIDwgMSkge1xuICAgICAgICByZXR1cm4gc2FmZVRocm93KCdJbnZhbGlkIHdpdG5lc3MgZGF0YTogJyArIFN0cmluZyh3aXRuZXNzKSwgdGhyb3dzKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5zY3JpcHQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBzY3JpcHQgIT09IG51bGwpIHtcbiAgICAgICAgY29uZmlnLnNjcmlwdCA9IHNjcmlwdDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wdWJrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwdWIgPSBCdWZmJDEuYnl0ZXMoY29uZmlnLnB1YmtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmFtcy5sZW5ndGggPiAxICYmXG4gICAgICAgIHBhcmFtc1sxXS5sZW5ndGggPT09IDMzKSB7XG4gICAgICAgIHB1YiA9IEJ1ZmYkMS5ieXRlcyhwYXJhbXNbMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNhZmVUaHJvdygnTm8gcHVia2V5IHByb3ZpZGVkIScsIHRocm93cyk7XG4gICAgfVxuICAgIGNvbnN0IHJhd3NpZyA9IFNjcmlwdC5mbXQudG9QYXJhbShwYXJhbXNbMF0pO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHJhd3NpZy5zbGljZSgwLCAtMSk7XG4gICAgY29uc3Qgc2lnZmxhZyA9IHJhd3NpZy5zbGljZSgtMSlbMF07XG4gICAgY29uc3QgaGFzaCA9IGhhc2hUeCQxKHR4LCBpbmRleCwgeyAuLi5jb25maWcsIHNpZ2ZsYWcgfSk7XG4gICAgaWYgKCFub2JsZS5zZWNwLnZlcmlmeShzaWduYXR1cmUsIGhhc2gsIHB1YikpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVUaHJvdygnSW52YWxpZCBzaWduYXR1cmUhJywgdGhyb3dzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IFNXU2lnbmVyID0ge1xuICAgIGhhc2g6IGhhc2hUeCQxLFxuICAgIHNpZ246IHNpZ25UeCQxLFxuICAgIHZlcmlmeTogdmVyaWZ5VHgkMVxufTtcblxuY29uc3QgVkFMSURfSEFTSF9UWVBFUyA9IFsweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDgxLCAweDgyLCAweDgzXTtcbmZ1bmN0aW9uIGhhc2hUeCh0ZW1wbGF0ZSwgaW5kZXgsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgeyBleHRlbnNpb24sIHNpZ2ZsYWcgPSAweDAwLCBleHRmbGFnID0gMHgwMCwga2V5X3ZlcnNpb24gPSAweDAwLCBzZXBhcmF0b3JfcG9zID0gMHhGRkZGRkZGRiB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHR4ZGF0YSA9IFR4LmZtdC50b0pzb24odGVtcGxhdGUpO1xuICAgIGNvbnN0IHsgdmVyc2lvbiwgdmluOiBpbnB1dCwgdm91dDogb3V0cHV0LCBsb2NrdGltZSB9ID0gdHhkYXRhO1xuICAgIGlmIChpbmRleCA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgYm91bmRzOiAnICsgU3RyaW5nKGluZGV4KSk7XG4gICAgfVxuICAgIGlmICghVkFMSURfSEFTSF9UWVBFUy5pbmNsdWRlcyhzaWdmbGFnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGFzaCB0eXBlOiAnICsgU3RyaW5nKHNpZ2ZsYWcpKTtcbiAgICB9XG4gICAgaWYgKGV4dGZsYWcgPCAwIHx8IGV4dGZsYWcgPiAxMjcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbnRpb24gZmxhZyBvdXQgb2YgcmFuZ2U6ICcgKyBTdHJpbmcoZXh0ZmxhZykpO1xuICAgIH1cbiAgICBjb25zdCB7IHR4aWQsIHZvdXQsIHNlcXVlbmNlLCB3aXRuZXNzID0gW10gfSA9IGlucHV0W2luZGV4XTtcbiAgICBjb25zdCBpc0FueVBheSA9IChzaWdmbGFnICYgMHg4MCkgPT09IDB4ODA7XG4gICAgY29uc3QgYW5uZXggPSBnZXRBbm5leERhdGEod2l0bmVzcyk7XG4gICAgY29uc3QgYW5uZXhCaXQgPSAoYW5uZXggIT09IHVuZGVmaW5lZCkgPyAxIDogMDtcbiAgICBjb25zdCBleHRlbmRCaXQgPSAoZXh0ZW5zaW9uICE9PSB1bmRlZmluZWQpID8gMSA6IDA7XG4gICAgY29uc3Qgc3BlbmRUeXBlID0gKChleHRmbGFnICsgZXh0ZW5kQml0KSAqIDIpICsgYW5uZXhCaXQ7XG4gICAgY29uc3QgaGFzaHRhZyA9IEJ1ZmYkMS5zdHIoJ1RhcFNpZ2hhc2gnKS5kaWdlc3Q7XG4gICAgY29uc3QgcHJlaW1hZ2UgPSBbXG4gICAgICAgIGhhc2h0YWcsXG4gICAgICAgIGhhc2h0YWcsXG4gICAgICAgIEJ1ZmYkMS5udW0oMHgwMCwgMSksXG4gICAgICAgIEJ1ZmYkMS5udW0oc2lnZmxhZywgMSksXG4gICAgICAgIGVuY29kZVZlcnNpb24odmVyc2lvbiksXG4gICAgICAgIGVuY29kZUxvY2t0aW1lKGxvY2t0aW1lKVxuICAgIF07XG4gICAgaWYgKCFpc0FueVBheSkge1xuICAgICAgICBjb25zdCBwcmV2b3V0cyA9IGlucHV0Lm1hcChlID0+IGdldFByZXZvdXQoZSkpO1xuICAgICAgICBwcmVpbWFnZS5wdXNoKGhhc2hPdXRwb2ludHMoaW5wdXQpLCBoYXNoQW1vdW50cyhwcmV2b3V0cyksIGhhc2hTY3JpcHRzKHByZXZvdXRzKSwgaGFzaFNlcXVlbmNlKGlucHV0KSk7XG4gICAgfVxuICAgIGlmICgoc2lnZmxhZyAmIDB4MDMpIDwgMiB8fCAoc2lnZmxhZyAmIDB4MDMpID4gMykge1xuICAgICAgICBwcmVpbWFnZS5wdXNoKGhhc2hPdXRwdXRzKG91dHB1dCkpO1xuICAgIH1cbiAgICBwcmVpbWFnZS5wdXNoKEJ1ZmYkMS5udW0oc3BlbmRUeXBlLCAxKSk7XG4gICAgaWYgKGlzQW55UGF5KSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIHNjcmlwdFB1YktleSB9ID0gZ2V0UHJldm91dChpbnB1dFtpbmRleF0pO1xuICAgICAgICBwcmVpbWFnZS5wdXNoKGVuY29kZVR4aWQodHhpZCksIGVuY29kZVByZXZPdXQodm91dCksIGVuY29kZVZhbHVlKHZhbHVlKSwgU2NyaXB0LmVuY29kZShzY3JpcHRQdWJLZXksIHRydWUpLCBlbmNvZGVTZXF1ZW5jZShzZXF1ZW5jZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJlaW1hZ2UucHVzaChCdWZmJDEubnVtKGluZGV4LCA0KS5yZXZlcnNlKCkpO1xuICAgIH1cbiAgICBpZiAoYW5uZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmVpbWFnZS5wdXNoKGFubmV4KTtcbiAgICB9XG4gICAgaWYgKChzaWdmbGFnICYgMHgwMykgPT09IDB4MDMpIHtcbiAgICAgICAgcHJlaW1hZ2UucHVzaChoYXNoT3V0cHV0KG91dHB1dFtpbmRleF0pKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZWltYWdlLnB1c2goQnVmZiQxLmJ5dGVzKGV4dGVuc2lvbiksIEJ1ZmYkMS5udW0oa2V5X3ZlcnNpb24pLCBCdWZmJDEubnVtKHNlcGFyYXRvcl9wb3MsIDQsICdsZScpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmYkMS5qb2luKHByZWltYWdlKS5kaWdlc3Q7XG59XG5mdW5jdGlvbiBoYXNoT3V0cG9pbnRzKHZpbikge1xuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgZm9yIChjb25zdCB7IHR4aWQsIHZvdXQgfSBvZiB2aW4pIHtcbiAgICAgICAgc3RhY2sucHVzaChlbmNvZGVUeGlkKHR4aWQpKTtcbiAgICAgICAgc3RhY2sucHVzaChlbmNvZGVQcmV2T3V0KHZvdXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmYkMS5qb2luKHN0YWNrKS5kaWdlc3Q7XG59XG5mdW5jdGlvbiBoYXNoU2VxdWVuY2UodmluKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgc2VxdWVuY2UgfSBvZiB2aW4pIHtcbiAgICAgICAgc3RhY2sucHVzaChlbmNvZGVTZXF1ZW5jZShzZXF1ZW5jZSkpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZiQxLmpvaW4oc3RhY2spLmRpZ2VzdDtcbn1cbmZ1bmN0aW9uIGhhc2hBbW91bnRzKHByZXZvdXRzKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgdmFsdWUgfSBvZiBwcmV2b3V0cykge1xuICAgICAgICBzdGFjay5wdXNoKGVuY29kZVZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmJDEuam9pbihzdGFjaykuZGlnZXN0O1xufVxuZnVuY3Rpb24gaGFzaFNjcmlwdHMocHJldm91dHMpIHtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGZvciAoY29uc3QgeyBzY3JpcHRQdWJLZXkgfSBvZiBwcmV2b3V0cykge1xuICAgICAgICBzdGFjay5wdXNoKGVuY29kZVNjcmlwdChzY3JpcHRQdWJLZXksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmYkMS5qb2luKHN0YWNrKS5kaWdlc3Q7XG59XG5mdW5jdGlvbiBoYXNoT3V0cHV0cyh2b3V0KSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgdmFsdWUsIHNjcmlwdFB1YktleSB9IG9mIHZvdXQpIHtcbiAgICAgICAgc3RhY2sucHVzaChlbmNvZGVWYWx1ZSh2YWx1ZSkpO1xuICAgICAgICBzdGFjay5wdXNoKFNjcmlwdC5lbmNvZGUoc2NyaXB0UHViS2V5LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmJDEuam9pbihzdGFjaykuZGlnZXN0O1xufVxuZnVuY3Rpb24gaGFzaE91dHB1dCh2b3V0KSB7XG4gICAgcmV0dXJuIEJ1ZmYkMS5qb2luKFtcbiAgICAgICAgZW5jb2RlVmFsdWUodm91dC52YWx1ZSksXG4gICAgICAgIFNjcmlwdC5lbmNvZGUodm91dC5zY3JpcHRQdWJLZXksIHRydWUpXG4gICAgXSkuZGlnZXN0O1xufVxuZnVuY3Rpb24gZ2V0QW5uZXhEYXRhKHdpdG5lc3MpIHtcbiAgICBpZiAod2l0bmVzcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHdpdG5lc3MubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBhbm5leCA9IHdpdG5lc3MuYXQoLTEpO1xuICAgIGlmICh0eXBlb2YgYW5uZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFubmV4ID0gQnVmZiQxLmhleChhbm5leCk7XG4gICAgfVxuICAgIGlmIChhbm5leCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiZcbiAgICAgICAgYW5uZXhbMF0gPT09IDB4NTApIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmYkMS5yYXcoYW5uZXgpLnByZWZpeFNpemUoJ2JlJykuZGlnZXN0O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0UHJldm91dCh2aW4pIHtcbiAgICBpZiAodmluLnByZXZvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByZXZvdXQgZGF0YSBtaXNzaW5nIGZvciBpbnB1dDogJyArIFN0cmluZyh2aW4udHhpZCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmluLnByZXZvdXQ7XG59XG5cbmNvbnN0IEZJRUxEX1NJWkUgPSAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmZuO1xuY29uc3QgQ1VSVkVfT1JERVIgPSAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFuO1xuZnVuY3Rpb24gc2lnblR4KHNlY2tleSwgdHhkYXRhLCBpbmRleCwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ2ZsYWcgPSAweDAwIH0gPSBjb25maWc7XG4gICAgY29uc3QgaGFzaCA9IGhhc2hUeCh0eGRhdGEsIGluZGV4LCBjb25maWcpO1xuICAgIGNvbnN0IHNpZyA9IHNpZ24oc2Vja2V5LCBoYXNoKTtcbiAgICByZXR1cm4gKHNpZ2ZsYWcgPT09IDB4MDApXG4gICAgICAgID8gQnVmZiQxLnJhdyhzaWcpXG4gICAgICAgIDogQnVmZiQxLmpvaW4oW3NpZywgc2lnZmxhZ10pO1xufVxuZnVuY3Rpb24gc2lnbihzZWNyZXQsIG1lc3NhZ2UsIHJhbmQgPSBCdWZmJDEucmFuZG9tKDMyKSkge1xuICAgIGNvbnN0IG0gPSBCdWZmJDEuYnl0ZXMobWVzc2FnZSk7XG4gICAgY29uc3QgZHAgPSBuZXcgRmllbGQoc2VjcmV0KTtcbiAgICBjb25zdCBQID0gZHAucG9pbnQ7XG4gICAgY29uc3QgZCA9IChQLmhhc0V2ZW5ZKSA/IGRwLmJpZyA6IGRwLm5lZ2F0ZWQuYmlnO1xuICAgIGNvbnN0IGEgPSBoYXNoVGFnKCdCSVAwMzQwL2F1eCcsIEJ1ZmYkMS5ieXRlcyhyYW5kKSk7XG4gICAgY29uc3QgdCA9IGQgXiBhLmJpZztcbiAgICBjb25zdCBuID0gaGFzaFRhZygnQklQMDM0MC9ub25jZScsIHQsIFAueC5yYXcsIG0pO1xuICAgIGNvbnN0IGtwID0gbmV3IEZpZWxkKG4pO1xuICAgIGNvbnN0IFIgPSBrcC5wb2ludDtcbiAgICBjb25zdCBrID0gKFIuaGFzRXZlblkpID8ga3AuYmlnIDoga3AubmVnYXRlZC5iaWc7XG4gICAgY29uc3QgZSA9IG5ldyBGaWVsZChoYXNoVGFnKCdCSVAwMzQwL2NoYWxsZW5nZScsIFIueC5yYXcsIFAueC5yYXcsIG0pKTtcbiAgICBjb25zdCBzID0gbmV3IEZpZWxkKGsgKyAoZS5iaWcgKiBkKSk7XG4gICAgcmV0dXJuIEJ1ZmYkMS5qb2luKFtSLngucmF3LCBzLnJhd10pO1xufVxuZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVia2V5LCBzaG91bGRUaHJvdyA9IGZhbHNlKSB7XG4gICAgY29uc3QgUCA9IFBvaW50LmZyb21feCh4T25seVB1YihwdWJrZXkpKTtcbiAgICBjb25zdCBtID0gQnVmZiQxLmJ5dGVzKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHN0cmVhbSA9IEJ1ZmYkMS5ieXRlcyhzaWduYXR1cmUpLnN0cmVhbTtcbiAgICBpZiAoc3RyZWFtLnNpemUgPCA2NCkge1xuICAgICAgICBzYWZlVGhyb3coJ1NpZ25hdHVyZSBsZW5ndGggaXMgdG9vIHNtYWxsOiAnICsgU3RyaW5nKHN0cmVhbS5zaXplKSwgc2hvdWxkVGhyb3cpO1xuICAgIH1cbiAgICBjb25zdCByID0gc3RyZWFtLnJlYWQoMzIpO1xuICAgIGlmIChyLmJpZyA+IEZJRUxEX1NJWkUpIHtcbiAgICAgICAgc2FmZVRocm93KCdTaWduYXR1cmUgciB2YWx1ZSBncmVhdGVyIHRoYW4gZmllbGQgc2l6ZSEnLCBzaG91bGRUaHJvdyk7XG4gICAgfVxuICAgIGNvbnN0IHMgPSBzdHJlYW0ucmVhZCgzMik7XG4gICAgaWYgKHMuYmlnID4gQ1VSVkVfT1JERVIpIHtcbiAgICAgICAgc2FmZVRocm93KCdTaWduYXR1cmUgcyB2YWx1ZSBncmVhdGVyIHRoYW4gY3VydmUgb3JkZXIhJywgc2hvdWxkVGhyb3cpO1xuICAgIH1cbiAgICBjb25zdCBlID0gbmV3IEZpZWxkKGhhc2hUYWcoJ0JJUDAzNDAvY2hhbGxlbmdlJywgci5yYXcsIFAueC5yYXcsIG0pKTtcbiAgICBjb25zdCBzRyA9IG5ldyBGaWVsZChzKS5wb2ludDtcbiAgICBjb25zdCBlUCA9IFAubXVsKGUuYmlnKTtcbiAgICBjb25zdCBSID0gc0cuc3ViKGVQKTtcbiAgICBpZiAoUi5oYXNPZGRZKSB7XG4gICAgICAgIHNhZmVUaHJvdygnU2lnbmF0dXJlIFIgdmFsdWUgaGFzIG9kZCBZIGNvb3JkaW5hdGUhJywgc2hvdWxkVGhyb3cpO1xuICAgIH1cbiAgICBpZiAoUi54LmJpZyA9PT0gMG4pIHtcbiAgICAgICAgc2FmZVRocm93KCdTaWduYXR1cmUgUiB2YWx1ZSBpcyBpbmZpbml0ZSEnLCBzaG91bGRUaHJvdyk7XG4gICAgfVxuICAgIHJldHVybiBSLnguYmlnID09PSByLmJpZztcbn1cblxuY29uc3QgREVGQVVMVF9WRVJTSU9OJDEgPSAweGMwO1xuZnVuY3Rpb24gZ2V0VGFwVGFnKHRhZykge1xuICAgIGNvbnN0IGh0YWcgPSBCdWZmJDEuc3RyKHRhZykuZGlnZXN0O1xuICAgIHJldHVybiBCdWZmJDEuam9pbihbaHRhZywgaHRhZ10pO1xufVxuZnVuY3Rpb24gZ2V0VGFwTGVhZihkYXRhLCB2ZXJzaW9uID0gREVGQVVMVF9WRVJTSU9OJDEpIHtcbiAgICByZXR1cm4gQnVmZiQxLmpvaW4oW1xuICAgICAgICBnZXRUYXBUYWcoJ1RhcExlYWYnKSxcbiAgICAgICAgZ2V0VmVyc2lvbih2ZXJzaW9uKSxcbiAgICAgICAgQnVmZiQxLmJ5dGVzKGRhdGEpXG4gICAgXSkuZGlnZXN0LmhleDtcbn1cbmZ1bmN0aW9uIGdldFRhcFNjcmlwdChzY3JpcHQsIHZlcnNpb24pIHtcbiAgICByZXR1cm4gZ2V0VGFwTGVhZihTY3JpcHQuZm10LnRvQnl0ZXMoc2NyaXB0KSwgdmVyc2lvbik7XG59XG5mdW5jdGlvbiBnZXRUYXBCcmFuY2gobGVhZkEsIGxlYWZCKSB7XG4gICAgaWYgKGxlYWZCIDwgbGVhZkEpIHtcbiAgICAgICAgW2xlYWZBLCBsZWFmQl0gPSBbbGVhZkIsIGxlYWZBXTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmYkMS5qb2luKFtcbiAgICAgICAgZ2V0VGFwVGFnKCdUYXBCcmFuY2gnKSxcbiAgICAgICAgQnVmZiQxLmhleChsZWFmQSkucmF3LFxuICAgICAgICBCdWZmJDEuaGV4KGxlYWZCKS5yYXdcbiAgICBdKS5kaWdlc3QuaGV4O1xufVxuZnVuY3Rpb24gZ2V0VGFwUm9vdChsZWF2ZXMpIHtcbiAgICByZXR1cm4gQnVmZiQxLmhleChtZXJrbGVpemUobGVhdmVzKVswXSk7XG59XG5mdW5jdGlvbiBtZXJrbGVpemUodGFwdHJlZSwgdGFyZ2V0LCBwYXRoID0gW10pIHtcbiAgICBjb25zdCBsZWF2ZXMgPSBbXTtcbiAgICBjb25zdCB0cmVlID0gW107XG4gICAgaWYgKHRhcHRyZWUubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyZWUgaXMgZW1wdHkhJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFwdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsZWFmID0gdGFwdHJlZVtpXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGVhZikpIHtcbiAgICAgICAgICAgIGNvbnN0IFtyLCB0LCBwXSA9IG1lcmtsZWl6ZShsZWFmLCB0YXJnZXQpO1xuICAgICAgICAgICAgdGFyZ2V0ID0gdDtcbiAgICAgICAgICAgIGxlYXZlcy5wdXNoKHIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIHApIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWF2ZXMucHVzaChsZWFmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gW2xlYXZlc1swXSwgdGFyZ2V0LCBwYXRoXTtcbiAgICB9XG4gICAgbGVhdmVzLnNvcnQoKTtcbiAgICBpZiAobGVhdmVzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgbGVhdmVzLnB1c2gobGVhdmVzW2xlYXZlcy5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVhdmVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBicmFuY2ggPSBnZXRUYXBCcmFuY2gobGVhdmVzW2ldLCBsZWF2ZXNbaSArIDFdKTtcbiAgICAgICAgdHJlZS5wdXNoKGJyYW5jaCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gbGVhdmVzW2ldKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGxlYXZlc1tpICsgMV0pO1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGJyYW5jaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gbGVhdmVzW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaChsZWF2ZXNbaV0pO1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGJyYW5jaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVya2xlaXplKHRyZWUsIHRhcmdldCwgcGF0aCk7XG59XG5mdW5jdGlvbiBnZXRWZXJzaW9uKHZlcnNpb24gPSAweGMwKSB7XG4gICAgcmV0dXJuIHZlcnNpb24gJiAweGZlO1xufVxuXG5mdW5jdGlvbiBnZXRUYXBUd2VhayhrZXksIGRhdGEgPSBuZXcgVWludDhBcnJheSgpLCBpc1ByaXZhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHB1YiA9IChpc1ByaXZhdGUpXG4gICAgICAgID8gbmV3IEZpZWxkKGtleSkucG9pbnQueC5yYXdcbiAgICAgICAgOiB4T25seVB1YihrZXkpO1xuICAgIHJldHVybiBCdWZmJDEuam9pbihbZ2V0VGFwVGFnKCdUYXBUd2VhaycpLCBwdWIsIEJ1ZmYkMS5ieXRlcyhkYXRhKV0pLmRpZ2VzdDtcbn1cbmZ1bmN0aW9uIGdldFR3ZWFrZWRLZXkoaW50a2V5LCBkYXRhLCBpc1ByaXZhdGUgPSBmYWxzZSkge1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpXG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIGNvbnN0IGsgPSBCdWZmJDEuYnl0ZXMoaW50a2V5KTtcbiAgICBjb25zdCB0ID0gZ2V0VGFwVHdlYWsoaW50a2V5LCBkYXRhLCBpc1ByaXZhdGUpO1xuICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgcmV0dXJuIHR3ZWFrU2VjS2V5KGssIHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR3ZWFrUHViS2V5KGssIHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFR3ZWFrZWRQdWIocHVia2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIGdldFR3ZWFrZWRLZXkocHVia2V5LCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGdldFR3ZWFrZWRTZWMoc2Vja2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIGdldFR3ZWFrZWRLZXkoc2Vja2V5LCBkYXRhLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHR3ZWFrU2VjS2V5KHNlY2tleSwgdHdlYWspIHtcbiAgICBsZXQgc2VjID0gbmV3IEZpZWxkKHNlY2tleSk7XG4gICAgaWYgKHNlYy5wb2ludC5oYXNPZGRZKSB7XG4gICAgICAgIHNlYyA9IHNlYy5uZWdhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmYkMS5yYXcoc2VjLmFkZCh0d2VhaykucmF3KTtcbn1cbmZ1bmN0aW9uIHR3ZWFrUHViS2V5KHB1YmtleSwgdHdlYWspIHtcbiAgICBwdWJrZXkgPSB4T25seVB1YihwdWJrZXkpO1xuICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tX3gocHVia2V5KTtcbiAgICBjb25zdCBRID0gUC5hZGQodHdlYWspO1xuICAgIHJldHVybiBCdWZmJDEucmF3KFEucmF3KTtcbn1cbmZ1bmN0aW9uIGdldFNjcmlwdE9ubHlQdWJrZXkoKSB7XG4gICAgY29uc3QgRyA9IEJ1ZmYkMS5oZXgoJzA0NzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5ODQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnKTtcbiAgICByZXR1cm4gUG9pbnQuZnJvbV94KEcuZGlnZXN0KS54O1xufVxuY29uc3QgU0NSSVBUX1BVQktFWSA9IGdldFNjcmlwdE9ubHlQdWJrZXkoKTtcblxuY29uc3QgREVGQVVMVF9WRVJTSU9OID0gMHhjMDtcbmZ1bmN0aW9uIGdldFRhcFNlY0tleShzZWNrZXksIGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIGdldFRhcEtleShzZWNrZXksIHsgLi4uY29uZmlnLCBpc1ByaXZhdGU6IHRydWUgfSk7XG59XG5mdW5jdGlvbiBnZXRUYXBQdWJLZXkocHVia2V5LCBjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBnZXRUYXBLZXkocHVia2V5LCB7IC4uLmNvbmZpZywgaXNQcml2YXRlOiBmYWxzZSB9KTtcbn1cbmZ1bmN0aW9uIGdldFRhcEtleShpbnRrZXksIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgeyBpc1ByaXZhdGUgPSBmYWxzZSwgdHJlZSA9IFtdLCB2ZXJzaW9uID0gREVGQVVMVF9WRVJTSU9OIH0gPSBjb25maWc7XG4gICAgY29uc3QgcHVia2V5ID0gKGlzUHJpdmF0ZSlcbiAgICAgICAgPyB1dGlsJDEuZ2V0UHVibGljS2V5KGludGtleSwgdHJ1ZSlcbiAgICAgICAgOiB4T25seVB1YihpbnRrZXkpO1xuICAgIGxldCB7IHRhcmdldCB9ID0gY29uZmlnO1xuICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgdGFyZ2V0ID0gQnVmZiQxLmJ5dGVzKHRhcmdldCkuaGV4O1xuICAgIGxldCB0YXBrZXksIGN0cmxwYXRoID0gW107XG4gICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBbcm9vdCwgX3QsIHBhdGhdID0gbWVya2xlaXplKHRyZWUsIHRhcmdldCk7XG4gICAgICAgIGN0cmxwYXRoID0gcGF0aDtcbiAgICAgICAgdGFwa2V5ID0gZ2V0VHdlYWtlZEtleShpbnRrZXksIHJvb3QsIGlzUHJpdmF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhcGtleSA9IGdldFR3ZWFrZWRLZXkoaW50a2V5LCB0YXJnZXQsIGlzUHJpdmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXBrZXkgPSBnZXRUd2Vha2VkS2V5KGludGtleSwgdW5kZWZpbmVkLCBpc1ByaXZhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhcml0eSA9IChpc1ByaXZhdGUpXG4gICAgICAgID8gdXRpbCQxLmdldFB1YmxpY0tleSh0YXBrZXkpWzBdXG4gICAgICAgIDogdGFwa2V5WzBdO1xuICAgIGNvbnN0IGNiaXQgPSBCdWZmJDEubnVtKHZlcnNpb24gKyByZWFkUGFyaXR5Qml0KHBhcml0eSkpO1xuICAgIGNvbnN0IGJsb2NrID0gW2NiaXQsIHB1YmtleV07XG4gICAgaWYgKGN0cmxwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY3RybHBhdGguZm9yRWFjaChlID0+IGJsb2NrLnB1c2goQnVmZiQxLmhleChlKSkpO1xuICAgIH1cbiAgICBjb25zdCBjYmxvY2sgPSBCdWZmJDEuam9pbihibG9jayk7XG4gICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghY2hlY2tQYXRoKHRhcGtleSwgdGFyZ2V0LCBjYmxvY2ssIGNvbmZpZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBjaGVja2luZyBmYWlsZWQhIFVuYWJsZSB0byBnZW5lcmF0ZSBwYXRoLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbeE9ubHlQdWIodGFwa2V5KS5oZXgsIGNibG9jay5oZXhdO1xufVxuZnVuY3Rpb24gY2hlY2tQYXRoKHRhcGtleSwgdGFyZ2V0LCBjYmxvY2ssIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgeyBpc1ByaXZhdGUgPSBmYWxzZSwgdGhyb3dzID0gZmFsc2UgfSA9IGNvbmZpZztcbiAgICBjb25zdCB7IHBhcml0eSwgcGF0aHMsIGludGtleSB9ID0gcmVhZEN0cmxCbG9jayhjYmxvY2spO1xuICAgIGNvbnN0IHB1YiA9IChpc1ByaXZhdGUpXG4gICAgICAgID8gdXRpbCQxLmdldFB1YmxpY0tleSh0YXBrZXksIHRydWUpXG4gICAgICAgIDogeE9ubHlQdWIodGFwa2V5KTtcbiAgICBjb25zdCBleHRrZXkgPSBCdWZmJDEuam9pbihbcGFyaXR5LCBwdWJdKTtcbiAgICBpZiAoZXh0a2V5Lmxlbmd0aCAhPT0gMzMpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVUaHJvdygnSW52YWxpZCB0YXBrZXk6ICcgKyBleHRrZXkuaGV4LCB0aHJvd3MpO1xuICAgIH1cbiAgICBsZXQgYnJhbmNoID0gQnVmZiQxLmJ5dGVzKHRhcmdldCkuaGV4O1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICBicmFuY2ggPSBnZXRUYXBCcmFuY2goYnJhbmNoLCBwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgayA9IGdldFR3ZWFrZWRLZXkoaW50a2V5LCBicmFuY2gpO1xuICAgIHJldHVybiAoQnVmZiQxLnJhdyhrKS5oZXggPT09IEJ1ZmYkMS5yYXcoZXh0a2V5KS5oZXgpO1xufVxuZnVuY3Rpb24gcmVhZEN0cmxCbG9jayhjYmxvY2spIHtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgU3RyZWFtJDEoQnVmZiQxLmJ5dGVzKGNibG9jaykpO1xuICAgIGNvbnN0IGNieXRlID0gYnVmZmVyLnJlYWQoMSkubnVtO1xuICAgIGNvbnN0IGludGtleSA9IGJ1ZmZlci5yZWFkKDMyKTtcbiAgICBjb25zdCBbdmVyc2lvbiwgcGFyaXR5XSA9IChjYnl0ZSAlIDIgPT09IDApXG4gICAgICAgID8gW2NieXRlLCAweDAyXVxuICAgICAgICA6IFtjYnl0ZSAtIDEsIDB4MDNdO1xuICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgd2hpbGUgKGJ1ZmZlci5zaXplID49IDMyKSB7XG4gICAgICAgIHBhdGhzLnB1c2goYnVmZmVyLnJlYWQoMzIpLmhleCk7XG4gICAgfVxuICAgIGlmIChidWZmZXIuc2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1lbXB0eSBidWZmZXIgb24gY29udHJvbCBibG9jazogJyArIFN0cmluZyhidWZmZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW50a2V5LCBwYXRocywgcGFyaXR5LCB2ZXJzaW9uIH07XG59XG5mdW5jdGlvbiByZWFkUGFyaXR5Qml0KHBhcml0eSA9IDB4MDIpIHtcbiAgICBpZiAocGFyaXR5ID09PSAwIHx8IHBhcml0eSA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHBhcml0eTtcbiAgICBpZiAocGFyaXR5ID09PSAweDAyIHx8IHBhcml0eSA9PT0gJzAyJylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHBhcml0eSA9PT0gMHgwMyB8fCBwYXJpdHkgPT09ICcwMycpXG4gICAgICAgIHJldHVybiAxO1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJpdHkgYml0OiAnICsgU3RyaW5nKHBhcml0eSkpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlUeCh0eGRhdGEsIGluZGV4LCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IHR4ID0gVHguZm10LnRvSnNvbih0eGRhdGEpO1xuICAgIGNvbnN0IHsgdGhyb3dzID0gZmFsc2UgfSA9IGNvbmZpZztcbiAgICBjb25zdCB7IHByZXZvdXQsIHdpdG5lc3MgPSBbXSB9ID0gdHgudmluW2luZGV4XTtcbiAgICBjb25zdCB3aXRuZXNzRGF0YSA9IFR4LnV0aWwucmVhZFdpdG5lc3Mod2l0bmVzcyk7XG4gICAgY29uc3QgeyBjYmxvY2ssIHNjcmlwdCwgcGFyYW1zIH0gPSB3aXRuZXNzRGF0YTtcbiAgICBsZXQgcHViO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoIDwgMSkge1xuICAgICAgICByZXR1cm4gc2FmZVRocm93KCdJbnZhbGlkIHdpdG5lc3MgZGF0YTogJyArIFN0cmluZyh3aXRuZXNzKSwgdGhyb3dzKTtcbiAgICB9XG4gICAgY29uc3QgeyBzY3JpcHRQdWJLZXkgfSA9IHByZXZvdXQgPz8ge307XG4gICAgaWYgKHNjcmlwdFB1YktleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzYWZlVGhyb3coJ1ByZXZvdXQgc2NyaXB0UHViS2V5IGlzIGVtcHR5IScsIHRocm93cyk7XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgZGF0YTogdGFwa2V5IH0gPSBUeC51dGlsLnJlYWRTY3JpcHRQdWJLZXkoc2NyaXB0UHViS2V5KTtcbiAgICBpZiAodHlwZSAhPT0gJ3AydHInKSB7XG4gICAgICAgIHJldHVybiBzYWZlVGhyb3coJ1ByZXZvdXQgc2NyaXB0IGlzIG5vdCBhIHZhbGlkIHRhcHJvb3Qgb3V0cHV0OicgKyB0YXBrZXkuaGV4LCB0aHJvd3MpO1xuICAgIH1cbiAgICBpZiAodGFwa2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVUaHJvdygnSW52YWxpZCB0YXBrZXkgbGVuZ3RoOiAnICsgU3RyaW5nKHRhcGtleS5sZW5ndGgpLCB0aHJvd3MpO1xuICAgIH1cbiAgICBpZiAoY2Jsb2NrICE9PSBudWxsICYmXG4gICAgICAgIHNjcmlwdCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gY2Jsb2NrWzBdICYgMHhmZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFwTGVhZihzY3JpcHQsIHZlcnNpb24pO1xuICAgICAgICBjb25maWcuZXh0ZW5zaW9uID0gdGFyZ2V0O1xuICAgICAgICBpZiAoIWNoZWNrUGF0aCh0YXBrZXksIHRhcmdldCwgY2Jsb2NrLCB7IHRocm93cyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVUaHJvdygnY2Jsb2NrIHZlcmlmaWNhdGlvbiBmYWlsZWQhJywgdGhyb3dzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uZmlnLnB1YmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHB1YiA9IEJ1ZmYkMS5ieXRlcyhjb25maWcucHVia2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW1zLmxlbmd0aCA+IDEgJiYgcGFyYW1zWzFdLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgcHViID0gQnVmZiQxLmJ5dGVzKHBhcmFtc1sxXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdWIgPSBCdWZmJDEuYnl0ZXModGFwa2V5KTtcbiAgICB9XG4gICAgY29uc3QgcmF3c2lnID0gU2NyaXB0LmZtdC50b1BhcmFtKHBhcmFtc1swXSk7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbSQxKHJhd3NpZyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc3RyZWFtLnJlYWQoNjQpLnJhdztcbiAgICBpZiAoc3RyZWFtLnNpemUgPT09IDEpIHtcbiAgICAgICAgY29uZmlnLnNpZ2ZsYWcgPSBzdHJlYW0ucmVhZCgxKS5udW07XG4gICAgICAgIGlmIChjb25maWcuc2lnZmxhZyA9PT0gMHgwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVUaHJvdygnMHgwMCBpcyBub3QgYSB2YWxpZCBhcHBlbmRlZCBzaWdmbGFnIScsIHRocm93cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFzaCA9IGhhc2hUeCh0eCwgaW5kZXgsIGNvbmZpZyk7XG4gICAgaWYgKCF2ZXJpZnkoc2lnbmF0dXJlLCBoYXNoLCBwdWIsIHRocm93cykpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVUaHJvdygnSW52YWxpZCBzaWduYXR1cmUhJywgdGhyb3dzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IFRSU2lnbmVyID0ge1xuICAgIGhhc2g6IGhhc2hUeCxcbiAgICBzaWduOiBzaWduVHgsXG4gICAgdmVyaWZ5OiB2ZXJpZnlUeFxufTtcblxuY29uc3QgU2lnbmVyID0ge1xuICAgIHNlZ3dpdDogU1dTaWduZXIsXG4gICAgdGFwcm9vdDogVFJTaWduZXJcbn07XG5cbmNvbnN0IFRhcFRyZWUgPSB7XG4gICAgZ2V0VGFnOiBnZXRUYXBUYWcsXG4gICAgZ2V0TGVhZjogZ2V0VGFwTGVhZixcbiAgICBnZXRCcmFuY2g6IGdldFRhcEJyYW5jaCxcbiAgICBnZXRSb290OiBnZXRUYXBSb290XG59O1xuY29uc3QgVGFwVXRpbCA9IHtcbiAgICByZWFkQ3RybEJsb2NrOiByZWFkQ3RybEJsb2NrLFxuICAgIHJlYWRQYXJpdHlCaXQ6IHJlYWRQYXJpdHlCaXRcbn07XG5jb25zdCBUYXBUd2VhayA9IHtcbiAgICBnZXRQdWJLZXk6IGdldFR3ZWFrZWRQdWIsXG4gICAgZ2V0U2VjS2V5OiBnZXRUd2Vha2VkU2VjLFxuICAgIGdldFR3ZWFrOiBnZXRUYXBUd2VhayxcbiAgICB0d2Vha1NlY0tleTogdHdlYWtTZWNLZXksXG4gICAgdHdlYWtQdWJLZXk6IHR3ZWFrUHViS2V5XG59O1xuY29uc3QgVGFwID0ge1xuICAgIGdldFB1YktleTogZ2V0VGFwUHViS2V5LFxuICAgIGdldFNlY0tleTogZ2V0VGFwU2VjS2V5LFxuICAgIGVuY29kZVNjcmlwdDogZ2V0VGFwU2NyaXB0LFxuICAgIGNoZWNrUGF0aDogY2hlY2tQYXRoLFxuICAgIHRyZWU6IFRhcFRyZWUsXG4gICAgdHdlYWs6IFRhcFR3ZWFrLFxuICAgIHV0aWw6IFRhcFV0aWwsXG4gICAgU0NSSVBUX1BVQktFWTogU0NSSVBUX1BVQktFWVxufTtcblxuY2xhc3MgVHhTY3JpcHQge1xuICAgIGNvbnN0cnVjdG9yKHNjcmlwdCkge1xuICAgICAgICB0aGlzLl9idWZmID0gQnVmZiQxLnJhdyhlbmNvZGVTY3JpcHQoc2NyaXB0KSk7XG4gICAgfVxuICAgIGdldCByYXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmLnJhdztcbiAgICB9XG4gICAgZ2V0IGhleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmYuaGV4O1xuICAgIH1cbiAgICBnZXQgYXNtKCkge1xuICAgICAgICByZXR1cm4gZGVjb2RlU2NyaXB0KHRoaXMuX2J1ZmYpO1xuICAgIH1cbiAgICBnZXRIYXNoKGZvcm1hdCwgdmVyc2lvbikge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAncDJ3JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDI1Nih0aGlzLl9idWZmKS5oZXg7XG4gICAgICAgICAgICBjYXNlICdwMnNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDE2MCh0aGlzLl9idWZmKS5oZXg7XG4gICAgICAgICAgICBjYXNlICdwMnRyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVGFwVHJlZS5nZXRMZWFmKHRoaXMuX2J1ZmYsIHZlcnNpb24pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBmb3JtYXQ6ICcgKyBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNtID8/IFtdO1xuICAgIH1cbn1cblxuY29uc3QgTUFYX1ZBTCA9IDB4RkZGRkZGRkY7XG5jb25zdCBOT19MT0NLID0gKDEgPDwgMzEpO1xuY29uc3QgVElNRV9NT0QgPSA1MTI7XG5jb25zdCBMT0NLX1RZUEUgPSAoMSA8PCAyMik7XG5jbGFzcyBUeFNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzUmVwbGFjZWFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlIDwgTUFYX1ZBTDtcbiAgICB9XG4gICAgZ2V0IGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLnZhbHVlICE9PSBNQVhfVkFMIHx8ICh0aGlzLnZhbHVlICYgTk9fTE9DSykgIT09IDApO1xuICAgIH1cbiAgICBnZXQgaXNUaW1lbG9jaygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgTE9DS19UWVBFKSAhPT0gMDtcbiAgICB9XG4gICAgZ2V0IHRpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2NrZWRcbiAgICAgICAgICAgID8gdGhpcy5pc1RpbWVsb2NrXG4gICAgICAgICAgICAgICAgPyB0aGlzLnZhbHVlICogVElNRV9NT0RcbiAgICAgICAgICAgICAgICA6IHRoaXMudmFsdWUgKiBUSU1FX01PRCAqIDYwMFxuICAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICBzZXQgdGltZXN0YW1wKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLmNlaWwodmFsdWUgLyBUSU1FX01PRCk7XG4gICAgfVxuICAgIGdldCBibG9ja2hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2NrZWRcbiAgICAgICAgICAgID8gIXRoaXMuaXNUaW1lbG9ja1xuICAgICAgICAgICAgICAgID8gdGhpcy52YWx1ZVxuICAgICAgICAgICAgICAgIDogTWF0aC5jZWlsKCh0aGlzLnZhbHVlICogVElNRV9NT0QpIC8gNjAwKVxuICAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICBzZXQgYmxvY2toZWlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZXN0RGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNUaW1lbG9ja1xuICAgICAgICAgICAgPyBuZXcgRGF0ZShEYXRlLm5vdygpICsgKHRoaXMudmFsdWUgKiBUSU1FX01PRCAqIDEwMDApKVxuICAgICAgICAgICAgOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgKHRoaXMudmFsdWUgKiA2MDAgKiAxMDAwKSk7XG4gICAgfVxuICAgIHNldCBlc3REYXRlKGRhdGUpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBkYXRlLmdldFRpbWUoKSAtIERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSAoZGVsdGEgPiAoVElNRV9NT0QgKiAxMDAwKSlcbiAgICAgICAgICAgID8gTWF0aC5jZWlsKGRlbHRhIC8gMTAwMCAvIFRJTUVfTU9EKVxuICAgICAgICAgICAgOiAxO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbn1cblxubGV0IFR4T3V0cHV0JDEgPSBjbGFzcyBUeE91dHB1dCB7XG4gICAgY29uc3RydWN0b3IodHhvdXQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IEJpZ0ludCh0eG91dC52YWx1ZSk7XG4gICAgICAgIHRoaXMuc2NyaXB0UHViS2V5ID0gbmV3IFR4U2NyaXB0KHR4b3V0LnNjcmlwdFB1YktleSk7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJlYWRTY3JpcHRQdWJLZXkodGhpcy5zY3JpcHRQdWJLZXkucmF3KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxufTtcblxuY2xhc3MgVHhXaXRuZXNzIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX21ldGEgPSByZWFkV2l0bmVzcyhkYXRhKTtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGFubmV4KCkge1xuICAgICAgICBjb25zdCBhbm5leCA9IHRoaXMuX21ldGEuYW5uZXg7XG4gICAgICAgIHJldHVybiAoYW5uZXggIT09IG51bGwpXG4gICAgICAgICAgICA/IEJ1ZmYkMS5yYXcoYW5uZXgpLmhleFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBjYmxvY2soKSB7XG4gICAgICAgIGNvbnN0IGNibG9jayA9IHRoaXMuX21ldGEuY2Jsb2NrO1xuICAgICAgICByZXR1cm4gKGNibG9jayAhPT0gbnVsbClcbiAgICAgICAgICAgID8gQnVmZiQxLnJhdyhjYmxvY2spLmhleFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBzY3JpcHQoKSB7XG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IHRoaXMuX21ldGEuc2NyaXB0O1xuICAgICAgICByZXR1cm4gKHNjcmlwdCAhPT0gbnVsbClcbiAgICAgICAgICAgID8gU2NyaXB0LmRlY29kZShzY3JpcHQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGEucGFyYW1zO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cbn1cblxubGV0IFR4SW5wdXQkMSA9IGNsYXNzIFR4SW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHR4ZGF0YSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdHggPSB0eGRhdGE7XG4gICAgICAgIHRoaXMuaWR4ID0gaW5kZXg7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHgudmluW3RoaXMuaWR4XTtcbiAgICB9XG4gICAgZ2V0IHR4aWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudHhpZDtcbiAgICB9XG4gICAgZ2V0IHZvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudm91dDtcbiAgICB9XG4gICAgZ2V0IHByZXZvdXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kYXRhLnByZXZvdXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgID8gbmV3IFR4T3V0cHV0JDEodGhpcy5kYXRhLnByZXZvdXQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHNjcmlwdFNpZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeFNjcmlwdCh0aGlzLmRhdGEuc2NyaXB0U2lnKTtcbiAgICB9XG4gICAgZ2V0IHNlcXVlbmNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFR4U2VxdWVuY2UodGhpcy5kYXRhLnNlcXVlbmNlKTtcbiAgICB9XG4gICAgZ2V0IHdpdG5lc3MoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHhXaXRuZXNzKHRoaXMuZGF0YS53aXRuZXNzKTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXZvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gdGhpcy5wcmV2b3V0LnNjcmlwdFB1YktleS5yYXc7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJlYWRTY3JpcHRQdWJLZXkoc2NyaXB0KTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAncDJzaCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhc20gPSB0aGlzLnNjcmlwdFNpZy5hc207XG4gICAgICAgICAgICAgICAgaWYgKGFzbVswXSA9PT0gJ09QXzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc21bMV0ubGVuZ3RoID09PSAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdwMnctcDJwa2gnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc21bMV0ubGVuZ3RoID09PSAzMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdwMnctcDJzaCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwMnNoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAncmF3JztcbiAgICB9XG4gICAgc2lnbihzZWNrZXksIGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy50eXBlLnN0YXJ0c1dpdGgoJ3AydycpKSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmVyLnNlZ3dpdC5zaWduKHNlY2tleSwgdGhpcy5fdHgsIHRoaXMuaWR4LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3RhcnRzV2l0aCgncDJ0cicpKSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmVyLnRhcHJvb3Quc2lnbihzZWNrZXksIHRoaXMuX3R4LCB0aGlzLmlkeCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlLnN0YXJ0c1dpdGgoJ3AycGtoJykgfHxcbiAgICAgICAgICAgIHRoaXMudHlwZS5zdGFydHNXaXRoKCdwMnNoJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBsaWJyYXJ5IGRvZXMgbm90IHN1cHBvcnQgc2lnbmluZyBsZWdhY3kgdHJhbnNhY3Rpb25zLicpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNpZ24gdGhpcyBpbnB1dCB0eXBlOicgKyBTdHJpbmcodGhpcy50eXBlKSk7XG4gICAgfVxufTtcblxuY29uc3QgTE9DS1RJTUVfVEhSRVNIT0xEID0gNTAwMDAwMDAwO1xuY2xhc3MgVHhMb2NrdGltZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUgPSAwKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBCdWZmJDEuYnl0ZXModmFsdWUpLm51bTtcbiAgICB9XG4gICAgZ2V0IGlzVGltZWxvY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID4gTE9DS1RJTUVfVEhSRVNIT0xEO1xuICAgIH1cbiAgICBnZXQgdGltZXN0YW1wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1RpbWVsb2NrXG4gICAgICAgICAgICA/IHRoaXMudmFsdWVcbiAgICAgICAgICAgIDogdGhpcy52YWx1ZSAqIDYwMDtcbiAgICB9XG4gICAgc2V0IHRpbWVzdGFtcCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBibG9ja2hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzVGltZWxvY2tcbiAgICAgICAgICAgID8gdGhpcy52YWx1ZVxuICAgICAgICAgICAgOiBNYXRoLmZsb29yKHRoaXMudmFsdWUgLyA2MDApO1xuICAgIH1cbiAgICBzZXQgYmxvY2toZWlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZXN0RGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNUaW1lbG9ja1xuICAgICAgICAgICAgPyBuZXcgRGF0ZShEYXRlLm5vdygpICsgKHRoaXMudmFsdWUgKiAxMDAwKSlcbiAgICAgICAgICAgIDogbmV3IERhdGUoRGF0ZS5ub3coKSArICh0aGlzLnZhbHVlICogNjAwICogMTAwMCkpO1xuICAgIH1cbiAgICBzZXQgZXN0RGF0ZShkYXRlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIERhdGUubm93KCkpIC8gMTAwMCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuXG52YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAodmFsKSA9PiB2YWw7XG4gICAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykgeyB9XG4gICAgdXRpbC5hc3NlcnRJcyA9IGFzc2VydElzO1xuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG4gICAgdXRpbC5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBvYmpbaXRlbV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcbiAgICB1dGlsLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICAgICAgICAubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cbiAgICB1dGlsLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICAgIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuY29uc3QgWm9kUGFyc2VkVHlwZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwic3RyaW5nXCIsXG4gICAgXCJuYW5cIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcImRhdGVcIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwidW5kZWZpbmVkXCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJhcnJheVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwibWFwXCIsXG4gICAgXCJzZXRcIixcbl0pO1xuY29uc3QgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN0cmluZztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIGRhdGEuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gICAgfVxufTtcblxuY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICBcIm5vdF9maW5pdGVcIixcbl0pO1xuY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbmNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIHN1Yl07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgICB9XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBmb3JtYXQoX21hcHBlcikge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoaXNzdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGVycm9yQXJyYXk6IGFueSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZXJyb3JBcnJheS5fZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgICAgIHJldHVybiBmaWVsZEVycm9ycztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbiAgICB9XG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgICB9XG59XG5ab2RFcnJvci5jcmVhdGUgPSAoaXNzdWVzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoaXNzdWVzKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHkgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBCaWdJbnQgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xufTtcblxubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBlcnJvck1hcDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cblxuY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICEhbSlcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UgfHwgZXJyb3JNZXNzYWdlLFxuICAgIH07XG59O1xuY29uc3QgRU1QVFlfUEFUSCA9IFtdO1xuZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgICAgZXJyb3JNYXAsIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogYXdhaXQgcGFpci5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IHBhaXIudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkge1xuICAgICAgICAgICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gICAgfVxufVxuY29uc3QgSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmNvbnN0IERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG5jb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xuY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcbmNvbnN0IGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcbmNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbmNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XG5cbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLm1lc3NhZ2U7XG59KShlcnJvclV0aWwgfHwgKGVycm9yVXRpbCA9IHt9KSk7XG5cbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2tleSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcbiAgICB9XG59XG5jb25zdCBoYW5kbGVSZXN1bHQgPSAoY3R4LCByZXN1bHQpID0+IHtcbiAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNYXApXG4gICAgICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcCwgZGVzY3JpcHRpb24gfTtcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICBpZiAodHlwZW9mIGN0eC5kYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiByZXF1aXJlZF9lcnJvciAhPT0gbnVsbCAmJiByZXF1aXJlZF9lcnJvciAhPT0gdm9pZCAwID8gcmVxdWlyZWRfZXJyb3IgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogaW52YWxpZF90eXBlX2Vycm9yICE9PSBudWxsICYmIGludmFsaWRfdHlwZV9lcnJvciAhPT0gdm9pZCAwID8gaW52YWxpZF90eXBlX2Vycm9yIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGN1c3RvbU1hcCwgZGVzY3JpcHRpb24gfTtcbn1cbmNsYXNzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGRlZikge1xuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIF9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSB7XG4gICAgICAgIHJldHVybiAoY3R4IHx8IHtcbiAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9wYXJzZVN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmFzeW5jKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChpc0FzeW5jKG1heWJlQXN5bmNSZXN1bHQpXG4gICAgICAgICAgICA/IG1heWJlQXN5bmNSZXN1bHRcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJlZmluZShjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XG4gICAgICAgICAgICBjb25zdCBzZXRFcnJvciA9ICgpID0+IGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAuLi5nZXRJc3N1ZVByb3BlcnRpZXModmFsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZmluZW1lbnQoY2hlY2ssIHJlZmluZW1lbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjaGVjayh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHR5cGVvZiByZWZpbmVtZW50RGF0YSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVmaW5lbWVudERhdGEodmFsLCBjdHgpXG4gICAgICAgICAgICAgICAgICAgIDogcmVmaW5lbWVudERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3JlZmluZW1lbnQocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KHJlZmluZW1lbnQpO1xuICAgIH1cbiAgICBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XG4gICAgfVxuICAgIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBab2RQcm9taXNlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBvcihvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgYW5kKGluY29taW5nKSB7XG4gICAgICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0KGRlZikge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnJhbmQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQnJhbmRlZCh7XG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2goZGVmKSB7XG4gICAgICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGNhdGNoVmFsdWU6IGNhdGNoVmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IFRoaXMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaXBlKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gWm9kUGlwZWxpbmUuY3JlYXRlKHRoaXMsIHRhcmdldCk7XG4gICAgfVxuICAgIGlzT3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGlzTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIH1cbn1cbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eW2Etel1bYS16MC05XSokLztcbmNvbnN0IHVsaWRSZWdleCA9IC9bMC05QS1ISktNTlAtVFYtWl17MjZ9LztcbmNvbnN0IHV1aWRSZWdleCA9IC9eKFthLWYwLTldezh9LVthLWYwLTldezR9LVsxLTVdW2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG4vLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjE4MS8xNTUwMTU1XG4vLyBvbGQgdmVyc2lvbjogdG9vIHNsb3csIGRpZG4ndCBzdXBwb3J0IHVuaWNvZGVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkkL2k7XG4vL29sZCBlbWFpbCByZWdleFxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKChbXjw+KClbXFxdLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF0uLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoPyEtKShbXjw+KClbXFxdLiw7Olxcc0BcIl0rXFwuKStbXjw+KClbXFxdLiw7Olxcc0BcIl17MSx9KVteLTw+KClbXFxdLiw7Olxcc0BcIl0kL2k7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFsoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXF0pfChcXFtJUHY2OigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSlcXF0pfChbQS1aYS16MC05XShbQS1aYS16MC05LV0qW0EtWmEtejAtOV0pKihcXC5bQS1aYS16XXsyLH0pKykpJC87XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IGVtb2ppUmVnZXggPSAvXihcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXHB7RW1vamlfQ29tcG9uZW50fSkrJC91O1xuY29uc3QgaXB2NFJlZ2V4ID0gL14oKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXG5jb25zdCBkYXRldGltZVJlZ2V4ID0gKGFyZ3MpID0+IHtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKGFyZ3Mub2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXlxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9VFxcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX0oKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19WiRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICBpZiAoYXJncy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfVokYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhcmdzLm9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfShcXFxcLlxcXFxkKyk/KChbKy1dXFxcXGR7Mn0oOj9cXFxcZHsyfSk/KXxaKSRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oXFxcXC5cXFxcZCspP1okYCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3JlZ2V4ID0gKHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSA9PiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIHouc3RyaW5nKCkubWluKDEpIGluc3RlYWQuXG4gICAgICAgICAqIEBzZWUge0BsaW5rIFpvZFN0cmluZy5taW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbmVtcHR5ID0gKG1lc3NhZ2UpID0+IHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgICAgIHRoaXMudHJpbSA9ICgpID0+IG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9Mb3dlckNhc2UgPSAoKSA9PiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b0xvd2VyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b1VwcGVyQ2FzZSA9ICgpID0+IG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXVpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInV1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkMlJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidHJpbVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpbmNsdWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogY2hlY2sudmFsdWUsIHBvc2l0aW9uOiBjaGVjay5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuc3RhcnRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBlbmRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpcFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSVAoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkMlwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVsaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBpcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWdleChyZWdleCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJyZWdleFwiLFxuICAgICAgICAgICAgcmVnZXg6IHJlZ2V4LFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jbHVkZXModmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW5jbHVkZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9zaXRpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heExlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICAgICAgICB2YWx1ZTogbGVuLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZXRpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbW9qaSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVTElEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0lQKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICAgIH1cbiAgICBnZXQgbWluTGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RTdHJpbmcuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IHBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IHBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyBNYXRoLnBvdygxMCwgZGVjQ291bnQpO1xufVxuY2xhc3MgWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gTnVtYmVyKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZmluaXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluaXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYWZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgaXNJbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHxcbiAgICAgICAgICAgIChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpKTtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbCwgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fFxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwiaW50XCIgfHxcbiAgICAgICAgICAgICAgICBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgICB9XG59XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5iaWdpbnQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhICUgY2hlY2sudmFsdWUgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhEYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5EYXRlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWF4RGF0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU3ltYm9sIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE51bGwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxufVxuWm9kTmV2ZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjdHguZGF0YS5sZW5ndGggPCBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZElzc3VlQ29kZS50b29fYmlnIDogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogKHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIC8vIGV4dGVuZDxcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT4sXG4gICAgICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PlxuICAgICAgICAvLyA+KFxuICAgICAgICAvLyAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxuICAgICAgICAvLyAgIFVua25vd25LZXlzLFxuICAgICAgICAvLyAgIENhdGNoYWxsLFxuICAgICAgICAvLyAgIE5ld091dHB1dCxcbiAgICAgICAgLy8gICBOZXdJbnB1dFxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIC8vICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgIC8vICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IHBhaXIudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXA6IChpc3N1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0cmlwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFzc3Rocm91Z2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInBhc3N0aHJvdWdoXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjb25zdCBBdWdtZW50RmFjdG9yeSA9XG4gICAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cbiAgICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXG4gICAgLy8gICAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgLy8gICApOiBab2RPYmplY3Q8XG4gICAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxuICAgIC8vICAgICBEZWZbXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyAgID4gPT4ge1xuICAgIC8vICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgICAgLi4uZGVmLFxuICAgIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgIC8vICAgICAgICAgLi4uZGVmLnNoYXBlKCksXG4gICAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgLy8gICAgICAgfSksXG4gICAgLy8gICAgIH0pIGFzIGFueTtcbiAgICAvLyAgIH07XG4gICAgZXh0ZW5kKGF1Z21lbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxuICAgICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgICAqL1xuICAgIG1lcmdlKG1lcmdpbmcpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLm1lcmdpbmcuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuICAgIC8vIG1lcmdlPFxuICAgIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXG4gICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBJbmNvbWluZ1tcInNoYXBlXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfSxcbiAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9XG4gICAgLy8gPihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcbiAgICAvLyAgIE5ld091dHB1dCxcbiAgICAvLyAgIE5ld0lucHV0XG4gICAgLy8gPiB7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgc2V0S2V5KGtleSwgc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1Z21lbnQoeyBba2V5XTogc2NoZW1hIH0pO1xuICAgIH1cbiAgICAvLyBtZXJnZTxJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdD4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XG4gICAgLy8gWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXVxuICAgIC8vID4ge1xuICAgIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxuICAgIC8vICAgLy8gICB0aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAvLyAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcbiAgICAvLyAgIC8vICk7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgY2F0Y2hhbGwoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IGluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGljayhtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyhtYXNrKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXNrW2tleV0gJiYgdGhpcy5zaGFwZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9taXQobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGRlZXBQYXJ0aWFsKCkge1xuICAgICAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XG4gICAgfVxuICAgIHBhcnRpYWwobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVpcmVkKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmllbGQgPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gbmV3RmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlvZigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgICB9XG59XG5ab2RPYmplY3QuY3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2REaXNjcmltaW5hdGVkVW5pb24gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGUub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHR5cGUuZW51bSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2REZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5jbGFzcyBab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gY3R4LmRhdGFbZGlzY3JpbWluYXRvcl07XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsXG4gICAgICAgICAgICAub2JqZWN0S2V5cyhhKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm1hcCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwgW2luZGV4LCBcImtleVwiXSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFNldCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50cykgPT4gZmluYWxpemVTZXQoZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpemUoc2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oc2l6ZSwgbWVzc2FnZSkubWF4KHNpemUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RTZXQuY3JlYXRlID0gKHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIG1pblNpemU6IG51bGwsXG4gICAgICAgIG1heFNpemU6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwLFxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0Vycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZVJldHVybnNJc3N1ZShyZXR1cm5zLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gT0soYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IHRoaXMuX2RlZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbiguLi5wYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgdGhpcy5fZGVmLnJldHVybnMuX2RlZi50eXBlXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKHJlc3VsdCwgcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPSygoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSB0aGlzLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oLi4ucGFyc2VkQXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gdGhpcy5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3NcbiAgICAgICAgICAgICAgICA/IGFyZ3NcbiAgICAgICAgICAgICAgICA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuY2xhc3MgWm9kRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVmLnZhbHVlcy5pbmRleE9mKGlucHV0LmRhdGEpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGV4dHJhY3QodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBleGNsdWRlKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpKTtcbiAgICB9XG59XG5ab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XG5jbGFzcyBab2ROYXRpdmVFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVudW1WYWx1ZXMgPSB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nICYmXG4gICAgICAgICAgICBjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hdGl2ZUVudW1WYWx1ZXMuaW5kZXhPZihpbnB1dC5kYXRhKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxufVxuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hdGl2ZUVudW0oe1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYXRpdmVFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kUHJvbWlzZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmXG4gICAgICAgICAgICBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlXG4gICAgICAgICAgICA/IGN0eC5kYXRhXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGlubmVyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIHNvdXJjZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzXG4gICAgICAgICAgICA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpXG4gICAgICAgICAgICA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbigocHJvY2Vzc2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2NcbiAgICAgICAgICAgIC8vIGVmZmVjdDogUmVmaW5lbWVudEVmZmVjdDxhbnk+XG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcbiAgICAgICAgICAgIDogKCkgPT4gcGFyYW1zLmRlZmF1bHQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY29uc3QgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5jbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5jbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY29uc3QgY3VzdG9tID0gKGNoZWNrLCBwYXJhbXMgPSB7fSwgXG4vKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiBQYXNzIGBmYXRhbGAgaW50byB0aGUgcGFyYW1zIG9iamVjdCBpbnN0ZWFkOlxuICpcbiAqIGBgYHRzXG4gKiB6LnN0cmluZygpLmN1c3RvbSgodmFsKSA9PiB2YWwubGVuZ3RoID4gNSwgeyBmYXRhbDogZmFsc2UgfSlcbiAqIGBgYFxuICpcbiAqL1xuZmF0YWwpID0+IHtcbiAgICBpZiAoY2hlY2spXG4gICAgICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghY2hlY2soZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gcGFyYW1zKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcztcbiAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwMiA9IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBwIH0gOiBwO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnAyLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpO1xufTtcbmNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG52YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKFxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG5jbHMsIHBhcmFtcyA9IHtcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcbmNvbnN0IHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcbmNvbnN0IGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5jb25zdCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuY29uc3QgY29lcmNlID0ge1xuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgbnVtYmVyOiAoKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBib29sZWFuOiAoKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xuICAgICAgICAuLi5hcmcsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICB9KSksXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBkYXRlOiAoKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG59O1xuY29uc3QgTkVWRVIgPSBJTlZBTElEO1xuXG52YXIgeiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZGVmYXVsdEVycm9yTWFwOiBlcnJvck1hcCxcbiAgICBzZXRFcnJvck1hcDogc2V0RXJyb3JNYXAsXG4gICAgZ2V0RXJyb3JNYXA6IGdldEVycm9yTWFwLFxuICAgIG1ha2VJc3N1ZTogbWFrZUlzc3VlLFxuICAgIEVNUFRZX1BBVEg6IEVNUFRZX1BBVEgsXG4gICAgYWRkSXNzdWVUb0NvbnRleHQ6IGFkZElzc3VlVG9Db250ZXh0LFxuICAgIFBhcnNlU3RhdHVzOiBQYXJzZVN0YXR1cyxcbiAgICBJTlZBTElEOiBJTlZBTElELFxuICAgIERJUlRZOiBESVJUWSxcbiAgICBPSzogT0ssXG4gICAgaXNBYm9ydGVkOiBpc0Fib3J0ZWQsXG4gICAgaXNEaXJ0eTogaXNEaXJ0eSxcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgIGlzQXN5bmM6IGlzQXN5bmMsXG4gICAgZ2V0IHV0aWwgKCkgeyByZXR1cm4gdXRpbDsgfSxcbiAgICBnZXQgb2JqZWN0VXRpbCAoKSB7IHJldHVybiBvYmplY3RVdGlsOyB9LFxuICAgIFpvZFBhcnNlZFR5cGU6IFpvZFBhcnNlZFR5cGUsXG4gICAgZ2V0UGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZSxcbiAgICBab2RUeXBlOiBab2RUeXBlLFxuICAgIFpvZFN0cmluZzogWm9kU3RyaW5nLFxuICAgIFpvZE51bWJlcjogWm9kTnVtYmVyLFxuICAgIFpvZEJpZ0ludDogWm9kQmlnSW50LFxuICAgIFpvZEJvb2xlYW46IFpvZEJvb2xlYW4sXG4gICAgWm9kRGF0ZTogWm9kRGF0ZSxcbiAgICBab2RTeW1ib2w6IFpvZFN5bWJvbCxcbiAgICBab2RVbmRlZmluZWQ6IFpvZFVuZGVmaW5lZCxcbiAgICBab2ROdWxsOiBab2ROdWxsLFxuICAgIFpvZEFueTogWm9kQW55LFxuICAgIFpvZFVua25vd246IFpvZFVua25vd24sXG4gICAgWm9kTmV2ZXI6IFpvZE5ldmVyLFxuICAgIFpvZFZvaWQ6IFpvZFZvaWQsXG4gICAgWm9kQXJyYXk6IFpvZEFycmF5LFxuICAgIFpvZE9iamVjdDogWm9kT2JqZWN0LFxuICAgIFpvZFVuaW9uOiBab2RVbmlvbixcbiAgICBab2REaXNjcmltaW5hdGVkVW5pb246IFpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICBab2RJbnRlcnNlY3Rpb246IFpvZEludGVyc2VjdGlvbixcbiAgICBab2RUdXBsZTogWm9kVHVwbGUsXG4gICAgWm9kUmVjb3JkOiBab2RSZWNvcmQsXG4gICAgWm9kTWFwOiBab2RNYXAsXG4gICAgWm9kU2V0OiBab2RTZXQsXG4gICAgWm9kRnVuY3Rpb246IFpvZEZ1bmN0aW9uLFxuICAgIFpvZExhenk6IFpvZExhenksXG4gICAgWm9kTGl0ZXJhbDogWm9kTGl0ZXJhbCxcbiAgICBab2RFbnVtOiBab2RFbnVtLFxuICAgIFpvZE5hdGl2ZUVudW06IFpvZE5hdGl2ZUVudW0sXG4gICAgWm9kUHJvbWlzZTogWm9kUHJvbWlzZSxcbiAgICBab2RFZmZlY3RzOiBab2RFZmZlY3RzLFxuICAgIFpvZFRyYW5zZm9ybWVyOiBab2RFZmZlY3RzLFxuICAgIFpvZE9wdGlvbmFsOiBab2RPcHRpb25hbCxcbiAgICBab2ROdWxsYWJsZTogWm9kTnVsbGFibGUsXG4gICAgWm9kRGVmYXVsdDogWm9kRGVmYXVsdCxcbiAgICBab2RDYXRjaDogWm9kQ2F0Y2gsXG4gICAgWm9kTmFOOiBab2ROYU4sXG4gICAgQlJBTkQ6IEJSQU5ELFxuICAgIFpvZEJyYW5kZWQ6IFpvZEJyYW5kZWQsXG4gICAgWm9kUGlwZWxpbmU6IFpvZFBpcGVsaW5lLFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIFNjaGVtYTogWm9kVHlwZSxcbiAgICBab2RTY2hlbWE6IFpvZFR5cGUsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcbiAgICBjb2VyY2U6IGNvZXJjZSxcbiAgICBhbnk6IGFueVR5cGUsXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcbiAgICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXG4gICAgZGF0ZTogZGF0ZVR5cGUsXG4gICAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcbiAgICAnZnVuY3Rpb24nOiBmdW5jdGlvblR5cGUsXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gICAgbGF6eTogbGF6eVR5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXG4gICAgbWFwOiBtYXBUeXBlLFxuICAgIG5hbjogbmFuVHlwZSxcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxuICAgICdudWxsJzogbnVsbFR5cGUsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFR5cGUsXG4gICAgb3N0cmluZzogb3N0cmluZyxcbiAgICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICAgIHByZXByb2Nlc3M6IHByZXByb2Nlc3NUeXBlLFxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxuICAgIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgICBzZXQ6IHNldFR5cGUsXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxuICAgIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXG4gICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZFR5cGUsXG4gICAgdW5pb246IHVuaW9uVHlwZSxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgICAndm9pZCc6IHZvaWRUeXBlLFxuICAgIE5FVkVSOiBORVZFUixcbiAgICBab2RJc3N1ZUNvZGU6IFpvZElzc3VlQ29kZSxcbiAgICBxdW90ZWxlc3NKc29uOiBxdW90ZWxlc3NKc29uLFxuICAgIFpvZEVycm9yOiBab2RFcnJvclxufSk7XG5cbmNvbnN0IGhleHN0ciA9IHouc3RyaW5nKCkucmVnZXgoL15bYS1mQS1GMC05XSQvKTtcbmNvbnN0IGhhc2ggPSB6LnN0cmluZygpLnJlZ2V4KC9eW2EtZkEtRjAtOV17NjR9JC8pO1xuY29uc3QgdWludDMyID0gei5udW1iZXIoKS5taW4oMCkubWF4KDB4RkZGRkZGRkYpO1xuY29uc3QgdWludDY0ID0gei5iaWdpbnQoKTtcbmNvbnN0IGJ5dGVBcnIgPSB6Lmluc3RhbmNlb2YoVWludDhBcnJheSk7XG5jb25zdCBhc21jb2RlID0gei51bmlvbihbaGV4c3RyLCB1aW50MzIsIHouc3RyaW5nKCksIGJ5dGVBcnJdKS5hcnJheSgpO1xuY29uc3Qgc2NyaXB0ID0gei51bmlvbihbYXNtY29kZSwgaGV4c3RyLCBieXRlQXJyXSk7XG5jb25zdCB3aXRuZXNzID0gei5hcnJheShzY3JpcHQpO1xuY29uc3QgVHhPdXRwdXQgPSB6Lm9iamVjdCh7XG4gICAgdmFsdWU6IHoudW5pb24oW3VpbnQzMiwgdWludDY0XSksXG4gICAgc2NyaXB0UHViS2V5OiBzY3JpcHRcbn0pO1xuY29uc3QgVHhJbnB1dCA9IHoub2JqZWN0KHtcbiAgICB0eGlkOiBoYXNoLFxuICAgIHZvdXQ6IHVpbnQzMixcbiAgICBzY3JpcHRTaWc6IHNjcmlwdCxcbiAgICBzZXF1ZW5jZTogdWludDMyLFxuICAgIHByZXZvdXQ6IFR4T3V0cHV0Lm9wdGlvbmFsKCksXG4gICAgd2l0bmVzc1xufSk7XG5jb25zdCBUeERhdGEgPSB6Lm9iamVjdCh7XG4gICAgdmVyc2lvbjogdWludDMyLFxuICAgIHZpbjogei5hcnJheShUeElucHV0KSxcbiAgICB2b3V0OiB6LmFycmF5KFR4T3V0cHV0KSxcbiAgICBsb2NrdGltZTogdWludDMyXG59KTtcbmNvbnN0IFNjaGVtYSA9IHtcbiAgICBUeERhdGEsXG4gICAgVHhJbnB1dCxcbiAgICBUeE91dHB1dCxcbiAgICB3aXRuZXNzLFxuICAgIHNjcmlwdCxcbiAgICBoZXhzdHIsXG4gICAgaGFzaCxcbiAgICB1aW50MzIsXG4gICAgdWludDY0XG59O1xuXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IodHhkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHhkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHhkYXRhID0gQnVmZiQxLmhleCh0eGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB0eGRhdGEgPSBUeC5kZWNvZGUodHhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEuVHhEYXRhO1xuICAgICAgICB0aGlzLl9kYXRhID0gc2NoZW1hLnBhcnNlKFR4LmNyZWF0ZSh0eGRhdGEpKTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cbiAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS52ZXJzaW9uO1xuICAgIH1cbiAgICBnZXQgdmluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnZpbi5tYXAoKF9lLCBpKSA9PiBuZXcgVHhJbnB1dCQxKHRoaXMuZGF0YSwgaSkpO1xuICAgIH1cbiAgICBnZXQgdm91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS52b3V0Lm1hcCgoZSkgPT4gbmV3IFR4T3V0cHV0JDEoZSkpO1xuICAgIH1cbiAgICBnZXQgbG9ja3RpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHhMb2NrdGltZSh0aGlzLmRhdGEubG9ja3RpbWUpO1xuICAgIH1cbiAgICBnZXQgYmFzZSgpIHtcbiAgICAgICAgcmV0dXJuIFR4LmVuY29kZSh0aGlzLmRhdGEsIHRydWUpO1xuICAgIH1cbiAgICBnZXQgYnVmZigpIHtcbiAgICAgICAgcmV0dXJuIFR4LmVuY29kZSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBnZXQgcmF3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmLnJhdztcbiAgICB9XG4gICAgZ2V0IGhleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZi5oZXg7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgYnNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2UubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgd2VpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ic2l6ZSAqIDMgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCB2c2l6ZSgpIHtcbiAgICAgICAgY29uc3QgcmVtYWluZGVyID0gKHRoaXMud2VpZ2h0ICUgNCA+IDApID8gMSA6IDA7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMud2VpZ2h0IC8gNCkgKyByZW1haW5kZXI7XG4gICAgfVxuICAgIGdldCBoYXNoKCkge1xuICAgICAgICBjb25zdCBoYXNoID0gaGFzaDI1Nih0aGlzLmJ1ZmYpO1xuICAgICAgICByZXR1cm4gaGFzaC5yZXZlcnNlKCkuaGV4O1xuICAgIH1cbiAgICBnZXQgdHhpZCgpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGhhc2gyNTYodGhpcy5iYXNlKTtcbiAgICAgICAgcmV0dXJuIGhhc2gucmV2ZXJzZSgpLmhleDtcbiAgICB9XG4gICAgYXN5bmMgZXhwb3J0KCkge1xuICAgICAgICBjb25zdCB7IHNpemUsIHdlaWdodCwgdnNpemUsIGhleCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdHhpZCA9IHRoaXMudHhpZDtcbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuaGFzaDtcbiAgICAgICAgcmV0dXJuIHsgdHhpZCwgaGFzaCwgLi4udGhpcy5kYXRhLCBzaXplLCB3ZWlnaHQsIHZzaXplLCBoZXggfTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFkZHJlc3MsIFR4SW5wdXQkMSBhcyBJbnB1dCwgVHhPdXRwdXQkMSBhcyBPdXRwdXQsIFNjcmlwdCwgVHhTZXF1ZW5jZSBhcyBTZXF1ZW5jZSwgU2lnbmVyLCBUYXAsIFRyYW5zYWN0aW9uLCBUeCwgVHhXaXRuZXNzIGFzIFdpdG5lc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cmdcode/tapscript/dist/module.mjs\n");

/***/ })

};
;
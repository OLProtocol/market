/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bitcore-lib";
exports.ids = ["vendor-chunks/bitcore-lib"];
exports.modules = {

/***/ "(ssr)/./node_modules/bitcore-lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bitcore-lib/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bitcore = module.exports;\n\n// module information\nbitcore.version = 'v' + (__webpack_require__(/*! ./package.json */ \"(ssr)/./node_modules/bitcore-lib/package.json\").version);\nbitcore.versionGuard = function(version) {\n  if (version !== undefined) {\n    var message = 'More than one instance of bitcore-lib found. ' +\n      'Please make sure to require bitcore-lib and check that submodules do' +\n      ' not also include their own bitcore-lib dependency.';\n    throw new Error(message);\n  }\n};\nbitcore.versionGuard(global._bitcore);\nglobal._bitcore = bitcore.version;\n\n// crypto\nbitcore.crypto = {};\nbitcore.crypto.BN = __webpack_require__(/*! ./lib/crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nbitcore.crypto.ECDSA = __webpack_require__(/*! ./lib/crypto/ecdsa */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\");\nbitcore.crypto.Schnorr = __webpack_require__(/*! ./lib/crypto/schnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/schnorr.js\");\nbitcore.crypto.Hash = __webpack_require__(/*! ./lib/crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nbitcore.crypto.Random = __webpack_require__(/*! ./lib/crypto/random */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\");\nbitcore.crypto.Point = __webpack_require__(/*! ./lib/crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nbitcore.crypto.Signature = __webpack_require__(/*! ./lib/crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nbitcore.crypto.TaggedHash = __webpack_require__(/*! ./lib/crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n// encoding\nbitcore.encoding = {};\nbitcore.encoding.Base58 = __webpack_require__(/*! ./lib/encoding/base58 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\");\nbitcore.encoding.Base58Check = __webpack_require__(/*! ./lib/encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nbitcore.encoding.BufferReader = __webpack_require__(/*! ./lib/encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nbitcore.encoding.BufferWriter = __webpack_require__(/*! ./lib/encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nbitcore.encoding.Varint = __webpack_require__(/*! ./lib/encoding/varint */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/varint.js\");\n\n// utilities\nbitcore.util = {};\nbitcore.util.buffer = __webpack_require__(/*! ./lib/util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nbitcore.util.js = __webpack_require__(/*! ./lib/util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nbitcore.util.preconditions = __webpack_require__(/*! ./lib/util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\n// errors thrown by the library\nbitcore.errors = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\n\n// main bitcoin library\nbitcore.Address = __webpack_require__(/*! ./lib/address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nbitcore.Block = __webpack_require__(/*! ./lib/block */ \"(ssr)/./node_modules/bitcore-lib/lib/block/index.js\");\nbitcore.MerkleBlock = __webpack_require__(/*! ./lib/block/merkleblock */ \"(ssr)/./node_modules/bitcore-lib/lib/block/merkleblock.js\");\nbitcore.BlockHeader = __webpack_require__(/*! ./lib/block/blockheader */ \"(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\");\nbitcore.HDPrivateKey = __webpack_require__(/*! ./lib/hdprivatekey.js */ \"(ssr)/./node_modules/bitcore-lib/lib/hdprivatekey.js\");\nbitcore.HDPublicKey = __webpack_require__(/*! ./lib/hdpublickey.js */ \"(ssr)/./node_modules/bitcore-lib/lib/hdpublickey.js\");\nbitcore.Message = __webpack_require__(/*! ./lib/message */ \"(ssr)/./node_modules/bitcore-lib/lib/message.js\");\nbitcore.Networks = __webpack_require__(/*! ./lib/networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nbitcore.Opcode = __webpack_require__(/*! ./lib/opcode */ \"(ssr)/./node_modules/bitcore-lib/lib/opcode.js\");\nbitcore.PrivateKey = __webpack_require__(/*! ./lib/privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\nbitcore.PublicKey = __webpack_require__(/*! ./lib/publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nbitcore.Script = __webpack_require__(/*! ./lib/script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nbitcore.Transaction = __webpack_require__(/*! ./lib/transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\");\nbitcore.URI = __webpack_require__(/*! ./lib/uri */ \"(ssr)/./node_modules/bitcore-lib/lib/uri.js\");\nbitcore.Unit = __webpack_require__(/*! ./lib/unit */ \"(ssr)/./node_modules/bitcore-lib/lib/unit.js\");\n\n// dependencies, subject to change\nbitcore.deps = {};\nbitcore.deps.bnjs = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bitcore-lib/node_modules/bn.js/lib/bn.js\");\nbitcore.deps.bs58 = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bitcore-lib/node_modules/bs58/index.js\");\nbitcore.deps.Buffer = Buffer;\nbitcore.deps.elliptic = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\nbitcore.deps._ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\n// Internal usage, exposed for testing/advanced tweaking\nbitcore.Transaction.sighash = __webpack_require__(/*! ./lib/transaction/sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQSx3QkFBd0Isb0dBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBaUI7QUFDN0MsdUJBQXVCLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ25ELHlCQUF5QixtQkFBTyxDQUFDLG9GQUFzQjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQXFCO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLGdGQUFvQjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyx3RkFBd0I7QUFDM0QsNEJBQTRCLG1CQUFPLENBQUMsMEZBQXlCOztBQUU3RDtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsc0ZBQXVCO0FBQ3pELCtCQUErQixtQkFBTyxDQUFDLGdHQUE0QjtBQUNuRSxnQ0FBZ0MsbUJBQU8sQ0FBQyxrR0FBNkI7QUFDckUsZ0NBQWdDLG1CQUFPLENBQUMsa0dBQTZCO0FBQ3JFLDBCQUEwQixtQkFBTyxDQUFDLHNGQUF1Qjs7QUFFekQ7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLDhFQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBZTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyw0RkFBMEI7O0FBRS9EO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWM7O0FBRXZDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsc0VBQWU7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWE7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsMEZBQXlCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDBGQUF5QjtBQUN2RCx1QkFBdUIsbUJBQU8sQ0FBQyxtRkFBdUI7QUFDdEQsc0JBQXNCLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3BELGtCQUFrQixtQkFBTyxDQUFDLHNFQUFlO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFnQjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBYztBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsMEVBQWlCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFjO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFtQjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsOERBQVc7QUFDakMsZUFBZSxtQkFBTyxDQUFDLGdFQUFZOztBQUVuQztBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsNEVBQU87QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMseUVBQU07QUFDbEM7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQywrREFBVTtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUTs7QUFFakM7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQyw4RkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9pbmRleC5qcz8yYjQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJpdGNvcmUgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8gbW9kdWxlIGluZm9ybWF0aW9uXG5iaXRjb3JlLnZlcnNpb24gPSAndicgKyByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5iaXRjb3JlLnZlcnNpb25HdWFyZCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ01vcmUgdGhhbiBvbmUgaW5zdGFuY2Ugb2YgYml0Y29yZS1saWIgZm91bmQuICcgK1xuICAgICAgJ1BsZWFzZSBtYWtlIHN1cmUgdG8gcmVxdWlyZSBiaXRjb3JlLWxpYiBhbmQgY2hlY2sgdGhhdCBzdWJtb2R1bGVzIGRvJyArXG4gICAgICAnIG5vdCBhbHNvIGluY2x1ZGUgdGhlaXIgb3duIGJpdGNvcmUtbGliIGRlcGVuZGVuY3kuJztcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5iaXRjb3JlLnZlcnNpb25HdWFyZChnbG9iYWwuX2JpdGNvcmUpO1xuZ2xvYmFsLl9iaXRjb3JlID0gYml0Y29yZS52ZXJzaW9uO1xuXG4vLyBjcnlwdG9cbmJpdGNvcmUuY3J5cHRvID0ge307XG5iaXRjb3JlLmNyeXB0by5CTiA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9ibicpO1xuYml0Y29yZS5jcnlwdG8uRUNEU0EgPSByZXF1aXJlKCcuL2xpYi9jcnlwdG8vZWNkc2EnKTtcbmJpdGNvcmUuY3J5cHRvLlNjaG5vcnIgPSByZXF1aXJlKCcuL2xpYi9jcnlwdG8vc2Nobm9ycicpO1xuYml0Y29yZS5jcnlwdG8uSGFzaCA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9oYXNoJyk7XG5iaXRjb3JlLmNyeXB0by5SYW5kb20gPSByZXF1aXJlKCcuL2xpYi9jcnlwdG8vcmFuZG9tJyk7XG5iaXRjb3JlLmNyeXB0by5Qb2ludCA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9wb2ludCcpO1xuYml0Y29yZS5jcnlwdG8uU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9saWIvY3J5cHRvL3NpZ25hdHVyZScpO1xuYml0Y29yZS5jcnlwdG8uVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by90YWdnZWRoYXNoJyk7XG5cbi8vIGVuY29kaW5nXG5iaXRjb3JlLmVuY29kaW5nID0ge307XG5iaXRjb3JlLmVuY29kaW5nLkJhc2U1OCA9IHJlcXVpcmUoJy4vbGliL2VuY29kaW5nL2Jhc2U1OCcpO1xuYml0Y29yZS5lbmNvZGluZy5CYXNlNThDaGVjayA9IHJlcXVpcmUoJy4vbGliL2VuY29kaW5nL2Jhc2U1OGNoZWNrJyk7XG5iaXRjb3JlLmVuY29kaW5nLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4vbGliL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xuYml0Y29yZS5lbmNvZGluZy5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuL2xpYi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcbmJpdGNvcmUuZW5jb2RpbmcuVmFyaW50ID0gcmVxdWlyZSgnLi9saWIvZW5jb2RpbmcvdmFyaW50Jyk7XG5cbi8vIHV0aWxpdGllc1xuYml0Y29yZS51dGlsID0ge307XG5iaXRjb3JlLnV0aWwuYnVmZmVyID0gcmVxdWlyZSgnLi9saWIvdXRpbC9idWZmZXInKTtcbmJpdGNvcmUudXRpbC5qcyA9IHJlcXVpcmUoJy4vbGliL3V0aWwvanMnKTtcbmJpdGNvcmUudXRpbC5wcmVjb25kaXRpb25zID0gcmVxdWlyZSgnLi9saWIvdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbi8vIGVycm9ycyB0aHJvd24gYnkgdGhlIGxpYnJhcnlcbmJpdGNvcmUuZXJyb3JzID0gcmVxdWlyZSgnLi9saWIvZXJyb3JzJyk7XG5cbi8vIG1haW4gYml0Y29pbiBsaWJyYXJ5XG5iaXRjb3JlLkFkZHJlc3MgPSByZXF1aXJlKCcuL2xpYi9hZGRyZXNzJyk7XG5iaXRjb3JlLkJsb2NrID0gcmVxdWlyZSgnLi9saWIvYmxvY2snKTtcbmJpdGNvcmUuTWVya2xlQmxvY2sgPSByZXF1aXJlKCcuL2xpYi9ibG9jay9tZXJrbGVibG9jaycpO1xuYml0Y29yZS5CbG9ja0hlYWRlciA9IHJlcXVpcmUoJy4vbGliL2Jsb2NrL2Jsb2NraGVhZGVyJyk7XG5iaXRjb3JlLkhEUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vbGliL2hkcHJpdmF0ZWtleS5qcycpO1xuYml0Y29yZS5IRFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vbGliL2hkcHVibGlja2V5LmpzJyk7XG5iaXRjb3JlLk1lc3NhZ2UgPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlJyk7XG5iaXRjb3JlLk5ldHdvcmtzID0gcmVxdWlyZSgnLi9saWIvbmV0d29ya3MnKTtcbmJpdGNvcmUuT3Bjb2RlID0gcmVxdWlyZSgnLi9saWIvb3Bjb2RlJyk7XG5iaXRjb3JlLlByaXZhdGVLZXkgPSByZXF1aXJlKCcuL2xpYi9wcml2YXRla2V5Jyk7XG5iaXRjb3JlLlB1YmxpY0tleSA9IHJlcXVpcmUoJy4vbGliL3B1YmxpY2tleScpO1xuYml0Y29yZS5TY3JpcHQgPSByZXF1aXJlKCcuL2xpYi9zY3JpcHQnKTtcbmJpdGNvcmUuVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL2xpYi90cmFuc2FjdGlvbicpO1xuYml0Y29yZS5VUkkgPSByZXF1aXJlKCcuL2xpYi91cmknKTtcbmJpdGNvcmUuVW5pdCA9IHJlcXVpcmUoJy4vbGliL3VuaXQnKTtcblxuLy8gZGVwZW5kZW5jaWVzLCBzdWJqZWN0IHRvIGNoYW5nZVxuYml0Y29yZS5kZXBzID0ge307XG5iaXRjb3JlLmRlcHMuYm5qcyA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5iaXRjb3JlLmRlcHMuYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKTtcbmJpdGNvcmUuZGVwcy5CdWZmZXIgPSBCdWZmZXI7XG5iaXRjb3JlLmRlcHMuZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpO1xuYml0Y29yZS5kZXBzLl8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuLy8gSW50ZXJuYWwgdXNhZ2UsIGV4cG9zZWQgZm9yIHRlc3RpbmcvYWR2YW5jZWQgdHdlYWtpbmdcbmJpdGNvcmUuVHJhbnNhY3Rpb24uc2lnaGFzaCA9IHJlcXVpcmUoJy4vbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2gnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/address.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/address.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar errors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nvar Bech32 = __webpack_require__(/*! ./encoding/bech32 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bech32.js\");\nvar Networks = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is one of\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),\n * `Address.PayToScriptHash` (the string `'scripthash'`),\n * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),\n * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).\n * The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,\n * and `isPayToWitnessScriptHash`.\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash, 'witnesspubkeyhash', or 'taproot'\n * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type, multisigType) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type, false, multisigType);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n\n  if (type && (\n    type !== Address.PayToPublicKeyHash\n    && type !== Address.PayToScriptHash\n    && type !== Address.PayToWitnessPublicKeyHash\n    && type !== Address.PayToWitnessScriptHash\n    && type !== Address.PayToTaproot)) {\n    throw new TypeError('Third argument must be \"pubkeyhash\", \"scripthash\", \"witnesspubkeyhash\", \"witnessscripthash\", or \"taproot\".');\n  }\n\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function(data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {\n    return Address._transformHash(data, network, type);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data, network, type);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof(data) === 'string') {\n    return Address._transformString(data, network, type);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n/** @static */\nAddress.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';\n/** @static */\nAddress.PayToWitnessScriptHash = 'witnessscripthash';\n/** @static */\nAddress.PayToTaproot = 'taproot';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} network - the name of the network associated\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function(hash, network, type) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20 && hash.length !== 32) {\n    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');\n  }\n  info.hashBuffer = hash;\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.type = type;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function(data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function(buffer) {\n  var version = {};\n\n  if (buffer.length > 21) {\n    var info = Bech32.decode(buffer.toString('utf8'));\n    if (info.version !== 0 && info.version !== 1) { // v1 == taproot\n      throw new TypeError('Only witness v0 and v1 addresses are supported.');\n    }\n\n    if (info.version === 0) {\n      if (info.data.length === 20) {\n        version.type = Address.PayToWitnessPublicKeyHash;\n      } else if (info.data.length === 32) {\n        version.type = Address.PayToWitnessScriptHash;\n      } else {\n        throw new TypeError('Witness data must be either 20 or 32 bytes.')\n      }\n    } else if (info.version === 1) {\n      if (info.data.length === 32) {\n        version.type = Address.PayToTaproot;\n      } else {\n        throw new TypeError('Witness data must be 32 bytes for v1');\n      }\n    } else {\n    }\n    version.network = Networks.get(info.prefix, 'bech32prefix');\n  } else {\n\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n    if (pubkeyhashNetwork) {\n      version.network = pubkeyhashNetwork;\n      version.type = Address.PayToPublicKeyHash;\n    } else if (scripthashNetwork) {\n      version.network = scripthashNetwork;\n      version.type = Address.PayToScriptHash;\n    }\n  }\n\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function(buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (buffer.length < 21) {\n    throw new TypeError('Address buffer is incorrect length.');\n  }\n\n  var networkObj = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (!bufferVersion.network || (networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey)) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  if (buffer.length > 21) {\n    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;\n  } else {\n    info.hashBuffer = buffer.slice(1);\n  }\n  info.network = networkObj || bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', 'scripthash', or 'taproot'\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function(pubkey, network, type) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash && type !== Address.PayToTaproot) {\n    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, scripthash, or taproot to transform public key.');\n  }\n  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {\n    throw new TypeError('Witness addresses must use compressed public keys.');\n  }\n  if (type === Address.PayToScriptHash) {\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());\n  } else if (type === Address.PayToTaproot) {\n    info.hashBuffer = pubkey.createTapTweak().tweakedPubKey;\n  } else {\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  }\n  info.type = type || Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored\n * @return {Address}\n */\nAddress.createMultisig = function(publicKeys, threshold, network, nestedWitness, type) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {\n    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');\n  }\n  if (nestedWitness || type === Address.PayToWitnessScriptHash) {\n    publicKeys = _.map(publicKeys, PublicKey);\n    for (var i = 0; i < publicKeys.length; i++) {\n      if (!publicKeys[i].compressed) {\n        throw new TypeError('Witness addresses must use compressed public keys.');\n      }\n    }\n  }\n  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);\n  if (nestedWitness) {\n    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);\n  }\n  return Address.payingTo(redeemScript, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function(data, network, type) {\n  if (typeof(data) !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n\n  if(data.length > 100) {\n    throw new TypeError('address string is too long');\n  }\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Unknown network');\n  }\n\n  data = data.trim();\n\n  try {\n    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);\n    return info;\n  } catch (e) {\n    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash || type === Address.PayToTaproot) {\n      throw e;\n    }\n  }\n\n  var addressBuffer = Base58Check.decode(data);\n  var info = Address._transformBuffer(addressBuffer, network, type);\n  return info;\n};\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function(data, network, type) {\n  var info = Address._transformPublicKey(data, network, type);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function(hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function(hash, network, type) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {\n      throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');\n  }\n  var type = type || Address.PayToScriptHash;\n  return new Address(info.hashBuffer, network, type);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function(script, network, type) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  var hash;\n  if (type === Address.PayToWitnessScriptHash) {\n    hash = Hash.sha256(script.toBuffer());\n  } else {\n    hash = Hash.sha256ripemd160(script.toBuffer());\n  }\n  var type = type || Address.PayToScriptHash;\n  return Address.fromScriptHash(hash, network, type);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function(buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function(str, network, type) {\n  var info = Address._transformString(str, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(\n    JSUtil.isHexa(obj.hash),\n    'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.'\n  );\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function(data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function(data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function() {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function() {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to witness public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessPublicKeyHash = function() {\n  return this.type === Address.PayToWitnessPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to witness script hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessScriptHash = function() {\n  return this.type === Address.PayToWitnessScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to Taproot script hash type\n * @returns {boolean}\n */\nAddress.prototype.isPayToTaproot = function() {\n  return this.type === Address.PayToTaproot;\n}\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\n    return Buffer.from(this.toString(), 'utf8')\n  }\n  var version = Buffer.from([this.network[this.type]]);\n  return Buffer.concat([version, this.hashBuffer]);\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a the string representation of the address\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toString = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash() || this.isPayToTaproot()) {\n    let prefix = this.network.bech32prefix;\n    let version = 0;\n    let encoding = Bech32.encodings.BECH32;\n    if (this.isPayToTaproot()) {\n      version = 1;\n      encoding = Bech32.encodings.BECH32M;\n    }\n    return Bech32.encode(prefix, version, this.hashBuffer, encoding);\n  }\n  return Base58Check.encode(this.toBuffer());\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function() {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\nmodule.exports = Address;\n\nvar Script = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFRO0FBQ3hCLFFBQVEsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLHNFQUFVO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDRGQUF3QjtBQUNsRCxhQUFhLG1CQUFPLENBQUMsa0ZBQW1CO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyxvRUFBWTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsMEVBQWU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFhOztBQUVyQztBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQixJQUFJLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxzRUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9hZGRyZXNzLmpzPzhiODAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyICQgPSByZXF1aXJlKCcuL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgQmFzZTU4Q2hlY2sgPSByZXF1aXJlKCcuL2VuY29kaW5nL2Jhc2U1OGNoZWNrJyk7XG52YXIgQmVjaDMyID0gcmVxdWlyZSgnLi9lbmNvZGluZy9iZWNoMzInKTtcbnZhciBOZXR3b3JrcyA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9jcnlwdG8vaGFzaCcpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9qcycpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vcHVibGlja2V5Jyk7XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYW4gYWRkcmVzcyBmcm9tIGFuIGFkZHJlc3MgU3RyaW5nIG9yIEJ1ZmZlciwgYSBwdWJsaWMga2V5IG9yIHNjcmlwdCBoYXNoIEJ1ZmZlcixcbiAqIG9yIGFuIGluc3RhbmNlIG9mIHtAbGluayBQdWJsaWNLZXl9IG9yIHtAbGluayBTY3JpcHR9LlxuICpcbiAqIFRoaXMgaXMgYW4gaW1tdXRhYmxlIGNsYXNzLCBhbmQgaWYgdGhlIGZpcnN0IHBhcmFtZXRlciBwcm92aWRlZCB0byB0aGlzIGNvbnN0cnVjdG9yIGlzIGFuXG4gKiBgQWRkcmVzc2AgaW5zdGFuY2UsIHRoZSBzYW1lIGFyZ3VtZW50IHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQW4gYWRkcmVzcyBoYXMgdHdvIGtleSBwcm9wZXJ0aWVzOiBgbmV0d29ya2AgYW5kIGB0eXBlYC4gVGhlIHR5cGUgaXMgb25lIG9mXG4gKiBgQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2hgICh2YWx1ZSBpcyB0aGUgYCdwdWJrZXloYXNoJ2Agc3RyaW5nKSxcbiAqIGBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaGAgKHRoZSBzdHJpbmcgYCdzY3JpcHRoYXNoJ2ApLFxuICogYEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaGAgKHRoZSBzdHJpbmcgYCd3aXRuZXNzcHVia2V5aGFzaCdgKSxcbiAqIG9yIGBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2hgICh0aGUgc3RyaW5nIGAnd2l0bmVzc3NjcmlwdGhhc2gnYCkuXG4gKiBUaGUgbmV0d29yayBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgTmV0d29ya30uXG4gKiBZb3UgY2FuIHF1aWNrbHkgY2hlY2sgd2hldGhlciBhbiBhZGRyZXNzIGlzIG9mIGEgZ2l2ZW4ga2luZCBieSB1c2luZyB0aGUgbWV0aG9kc1xuICogYGlzUGF5VG9QdWJsaWNLZXlIYXNoYCwgYGlzUGF5VG9TY3JpcHRIYXNoYCwgYGlzUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaGAsXG4gKiBhbmQgYGlzUGF5VG9XaXRuZXNzU2NyaXB0SGFzaGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIHZhbGlkYXRlIHRoYXQgYW4gaW5wdXQgZmllbGQgaXMgdmFsaWRcbiAqIHZhciBlcnJvciA9IEFkZHJlc3MuZ2V0VmFsaWRhdGlvbkVycm9yKGlucHV0LCAndGVzdG5ldCcpO1xuICogaWYgKCFlcnJvcikge1xuICogICB2YXIgYWRkcmVzcyA9IEFkZHJlc3MoaW5wdXQsICd0ZXN0bmV0Jyk7XG4gKiB9IGVsc2Uge1xuICogICAvLyBpbnZhbGlkIG5ldHdvcmsgb3IgY2hlY2tzdW0gKHR5cG8/KVxuICogICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NzYWdlO1xuICogfVxuICpcbiAqIC8vIGdldCBhbiBhZGRyZXNzIGZyb20gYSBwdWJsaWMga2V5XG4gKiB2YXIgYWRkcmVzcyA9IEFkZHJlc3MocHVibGljS2V5LCAndGVzdG5ldCcpLnRvU3RyaW5nKCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICogQHBhcmFtIHtOZXR3b3JrfFN0cmluZ3xudW1iZXI9fSBuZXR3b3JrIC0gVGhlIG5ldHdvcms6ICdsaXZlbmV0JyBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIFRoZSB0eXBlIG9mIGFkZHJlc3M6ICdzY3JpcHRoYXNoJywgJ3B1YmtleWhhc2gnLCB3aXRuZXNzc2NyaXB0aGFzaCwgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3RhcHJvb3QnXG4gKiBAcGFyYW0ge3N0cmluZz19IG11bHRpc2lnVHlwZSAtIFRoZSB0eXBlIG9mIG11bHRpc2lnOiAnc2NyaXB0aGFzaCcgb3IgJ3dpdG5lc3NzY3JpcHRoYXNoJ1xuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFkZHJlc3MoZGF0YSwgbmV0d29yaywgdHlwZSwgbXVsdGlzaWdUeXBlKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMiAqL1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWRkcmVzcykpIHtcbiAgICByZXR1cm4gbmV3IEFkZHJlc3MoZGF0YSwgbmV0d29yaywgdHlwZSk7XG4gIH1cblxuICBpZiAoXy5pc0FycmF5KGRhdGEpICYmIF8uaXNOdW1iZXIobmV0d29yaykpIHtcbiAgICByZXR1cm4gQWRkcmVzcy5jcmVhdGVNdWx0aXNpZyhkYXRhLCBuZXR3b3JrLCB0eXBlLCBmYWxzZSwgbXVsdGlzaWdUeXBlKTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQWRkcmVzcykge1xuICAgIC8vIEltbXV0YWJsZSBpbnN0YW5jZVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgJC5jaGVja0FyZ3VtZW50KGRhdGEsICdGaXJzdCBhcmd1bWVudCBpcyByZXF1aXJlZCwgcGxlYXNlIGluY2x1ZGUgYWRkcmVzcyBkYXRhLicsICdndWlkZS9hZGRyZXNzLmh0bWwnKTtcblxuICBpZiAobmV0d29yayAmJiAhTmV0d29ya3MuZ2V0KG5ldHdvcmspKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCIuJyk7XG4gIH1cblxuICBpZiAodHlwZSAmJiAoXG4gICAgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2hcbiAgICAmJiB0eXBlICE9PSBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaFxuICAgICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaFxuICAgICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaFxuICAgICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9UYXByb290KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXJkIGFyZ3VtZW50IG11c3QgYmUgXCJwdWJrZXloYXNoXCIsIFwic2NyaXB0aGFzaFwiLCBcIndpdG5lc3NwdWJrZXloYXNoXCIsIFwid2l0bmVzc3NjcmlwdGhhc2hcIiwgb3IgXCJ0YXByb290XCIuJyk7XG4gIH1cblxuICB2YXIgaW5mbyA9IHRoaXMuX2NsYXNzaWZ5QXJndW1lbnRzKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xuXG4gIC8vIHNldCBkZWZhdWx0cyBpZiBub3Qgc2V0XG4gIGluZm8ubmV0d29yayA9IGluZm8ubmV0d29yayB8fCBOZXR3b3Jrcy5nZXQobmV0d29yaykgfHwgTmV0d29ya3MuZGVmYXVsdE5ldHdvcms7XG4gIGluZm8udHlwZSA9IGluZm8udHlwZSB8fCB0eXBlIHx8IEFkZHJlc3MuUGF5VG9QdWJsaWNLZXlIYXNoO1xuXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xuICAgIGhhc2hCdWZmZXI6IGluZm8uaGFzaEJ1ZmZlcixcbiAgICBuZXR3b3JrOiBpbmZvLm5ldHdvcmssXG4gICAgdHlwZTogaW5mby50eXBlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gc3BsaXQgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50cyBvZiB0aGUgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Kn0gZGF0YSAtIFRoZSBlbmNvZGVkIGRhdGEgaW4gdmFyaW91cyBmb3JtYXRzXG4gKiBAcGFyYW0ge05ldHdvcmt8U3RyaW5nfG51bWJlcj19IG5ldHdvcmsgLSBUaGUgbmV0d29yazogJ2xpdmVuZXQnIG9yICd0ZXN0bmV0J1xuICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIFwiaW5mb1wiIG9iamVjdCB3aXRoIFwidHlwZVwiLCBcIm5ldHdvcmtcIiwgYW5kIFwiaGFzaEJ1ZmZlclwiXG4gKi9cbkFkZHJlc3MucHJvdG90eXBlLl9jbGFzc2lmeUFyZ3VtZW50cyA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmssIHR5cGUpIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG4gIC8vIHRyYW5zZm9ybSBhbmQgdmFsaWRhdGUgaW5wdXQgZGF0YVxuICBpZiAoKGRhdGEgaW5zdGFuY2VvZiBCdWZmZXIgfHwgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmIChkYXRhLmxlbmd0aCA9PT0gMjAgfHwgZGF0YS5sZW5ndGggPT09IDMyKSkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1IYXNoKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xuICB9IGVsc2UgaWYgKChkYXRhIGluc3RhbmNlb2YgQnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJiBkYXRhLmxlbmd0aCA+PSAyMSkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1CdWZmZXIoZGF0YSwgbmV0d29yaywgdHlwZSk7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFB1YmxpY0tleSkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1QdWJsaWNLZXkoZGF0YSwgbmV0d29yaywgdHlwZSk7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFNjcmlwdCkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1TY3JpcHQoZGF0YSwgbmV0d29yayk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKGRhdGEpID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1TdHJpbmcoZGF0YSwgbmV0d29yaywgdHlwZSk7XG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChkYXRhKSkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1PYmplY3QoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgaXMgYW4gdW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0LicpO1xuICB9XG59O1xuXG4vKiogQHN0YXRpYyAqL1xuQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2ggPSAncHVia2V5aGFzaCc7XG4vKiogQHN0YXRpYyAqL1xuQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2ggPSAnc2NyaXB0aGFzaCc7XG4vKiogQHN0YXRpYyAqL1xuQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoID0gJ3dpdG5lc3NwdWJrZXloYXNoJztcbi8qKiBAc3RhdGljICovXG5BZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2ggPSAnd2l0bmVzc3NjcmlwdGhhc2gnO1xuLyoqIEBzdGF0aWMgKi9cbkFkZHJlc3MuUGF5VG9UYXByb290ID0gJ3RhcHJvb3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoIC0gQW4gaW5zdGFuY2Ugb2YgYSBoYXNoIEJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBlaXRoZXIgJ3B1YmtleWhhc2gnLCAnc2NyaXB0aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsIG9yICd3aXRuZXNzc2NyaXB0aGFzaCdcbiAqIEBwYXJhbSB7TmV0d29yaz19IG5ldHdvcmsgLSB0aGUgbmFtZSBvZiB0aGUgbmV0d29yayBhc3NvY2lhdGVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyXG4gKiBAcHJpdmF0ZVxuICovXG5BZGRyZXNzLl90cmFuc2Zvcm1IYXNoID0gZnVuY3Rpb24oaGFzaCwgbmV0d29yaywgdHlwZSkge1xuICB2YXIgaW5mbyA9IHt9O1xuICBpZiAoIShoYXNoIGluc3RhbmNlb2YgQnVmZmVyKSAmJiAhKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3Mgc3VwcGxpZWQgaXMgbm90IGEgYnVmZmVyLicpO1xuICB9XG4gIGlmIChoYXNoLmxlbmd0aCAhPT0gMjAgJiYgaGFzaC5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRkcmVzcyBoYXNoYnVmZmVycyBtdXN0IGJlIGVpdGhlciAyMCBvciAzMiBieXRlcy4nKTtcbiAgfVxuICBpbmZvLmhhc2hCdWZmZXIgPSBoYXNoO1xuICBpbmZvLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQobmV0d29yaykgfHwgTmV0d29ya3MuZGVmYXVsdE5ldHdvcms7XG4gIGluZm8udHlwZSA9IHR5cGU7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYW4gYWRkcmVzcyBzZXJpYWxpemVkIHRocm91Z2ggYEFkZHJlc3MjdG9PYmplY3QoKWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YS5oYXNoIC0gdGhlIGhhc2ggdGhhdCB0aGlzIGFkZHJlc3MgZW5jb2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEudHlwZSAtIGVpdGhlciAncHVia2V5aGFzaCcsICdzY3JpcHRoYXNoJywgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3dpdG5lc3NzY3JpcHRoYXNoJ1xuICogQHBhcmFtIHtOZXR3b3JrPX0gZGF0YS5uZXR3b3JrIC0gdGhlIG5hbWUgb2YgdGhlIG5ldHdvcmsgYXNzb2NpYXRlZFxuICogQHJldHVybiB7QWRkcmVzc31cbiAqL1xuQWRkcmVzcy5fdHJhbnNmb3JtT2JqZWN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAkLmNoZWNrQXJndW1lbnQoZGF0YS5oYXNoIHx8IGRhdGEuaGFzaEJ1ZmZlciwgJ011c3QgcHJvdmlkZSBhIGBoYXNoYCBvciBgaGFzaEJ1ZmZlcmAgcHJvcGVydHknKTtcbiAgJC5jaGVja0FyZ3VtZW50KGRhdGEudHlwZSwgJ011c3QgcHJvdmlkZSBhIGB0eXBlYCBwcm9wZXJ0eScpO1xuICByZXR1cm4ge1xuICAgIGhhc2hCdWZmZXI6IGRhdGEuaGFzaCA/IEJ1ZmZlci5mcm9tKGRhdGEuaGFzaCwgJ2hleCcpIDogZGF0YS5oYXNoQnVmZmVyLFxuICAgIG5ldHdvcms6IE5ldHdvcmtzLmdldChkYXRhLm5ldHdvcmspIHx8IE5ldHdvcmtzLmRlZmF1bHROZXR3b3JrLFxuICAgIHR5cGU6IGRhdGEudHlwZVxuICB9O1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBkaXNjb3ZlciB0aGUgbmV0d29yayBhbmQgdHlwZSBiYXNlZCBvbiB0aGUgZmlyc3QgZGF0YSBieXRlXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIEFuIGluc3RhbmNlIG9mIGEgaGV4IGVuY29kZWQgYWRkcmVzcyBCdWZmZXJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IG5ldHdvcmsgYW5kIHR5cGVcbiAqIEBwcml2YXRlXG4gKi9cbkFkZHJlc3MuX2NsYXNzaWZ5RnJvbVZlcnNpb24gPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHZlcnNpb24gPSB7fTtcblxuICBpZiAoYnVmZmVyLmxlbmd0aCA+IDIxKSB7XG4gICAgdmFyIGluZm8gPSBCZWNoMzIuZGVjb2RlKGJ1ZmZlci50b1N0cmluZygndXRmOCcpKTtcbiAgICBpZiAoaW5mby52ZXJzaW9uICE9PSAwICYmIGluZm8udmVyc2lvbiAhPT0gMSkgeyAvLyB2MSA9PSB0YXByb290XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPbmx5IHdpdG5lc3MgdjAgYW5kIHYxIGFkZHJlc3NlcyBhcmUgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIGlmIChpbmZvLnZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmIChpbmZvLmRhdGEubGVuZ3RoID09PSAyMCkge1xuICAgICAgICB2ZXJzaW9uLnR5cGUgPSBBZGRyZXNzLlBheVRvV2l0bmVzc1B1YmxpY0tleUhhc2g7XG4gICAgICB9IGVsc2UgaWYgKGluZm8uZGF0YS5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgIHZlcnNpb24udHlwZSA9IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgZGF0YSBtdXN0IGJlIGVpdGhlciAyMCBvciAzMiBieXRlcy4nKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5mby52ZXJzaW9uID09PSAxKSB7XG4gICAgICBpZiAoaW5mby5kYXRhLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgdmVyc2lvbi50eXBlID0gQWRkcmVzcy5QYXlUb1RhcHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGRhdGEgbXVzdCBiZSAzMiBieXRlcyBmb3IgdjEnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgIH1cbiAgICB2ZXJzaW9uLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQoaW5mby5wcmVmaXgsICdiZWNoMzJwcmVmaXgnKTtcbiAgfSBlbHNlIHtcblxuICAgIHZhciBwdWJrZXloYXNoTmV0d29yayA9IE5ldHdvcmtzLmdldChidWZmZXJbMF0sICdwdWJrZXloYXNoJyk7XG4gICAgdmFyIHNjcmlwdGhhc2hOZXR3b3JrID0gTmV0d29ya3MuZ2V0KGJ1ZmZlclswXSwgJ3NjcmlwdGhhc2gnKTtcblxuICAgIGlmIChwdWJrZXloYXNoTmV0d29yaykge1xuICAgICAgdmVyc2lvbi5uZXR3b3JrID0gcHVia2V5aGFzaE5ldHdvcms7XG4gICAgICB2ZXJzaW9uLnR5cGUgPSBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaDtcbiAgICB9IGVsc2UgaWYgKHNjcmlwdGhhc2hOZXR3b3JrKSB7XG4gICAgICB2ZXJzaW9uLm5ldHdvcmsgPSBzY3JpcHRoYXNoTmV0d29yaztcbiAgICAgIHZlcnNpb24udHlwZSA9IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBiaXRjb2luIGFkZHJlc3MgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIEFuIGluc3RhbmNlIG9mIGEgaGV4IGVuY29kZWQgYWRkcmVzcyBCdWZmZXJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmV0d29yayAtIFRoZSBuZXR3b3JrOiAnbGl2ZW5ldCcgb3IgJ3Rlc3RuZXQnXG4gKiBAcGFyYW0ge3N0cmluZz19IHR5cGUgLSBUaGUgdHlwZTogJ3B1YmtleWhhc2gnLCAnc2NyaXB0aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsIG9yICd3aXRuZXNzc2NyaXB0aGFzaCdcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IGhhc2hCdWZmZXIsIG5ldHdvcmsgYW5kIHR5cGVcbiAqIEBwcml2YXRlXG4gKi9cbkFkZHJlc3MuX3RyYW5zZm9ybUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlciwgbmV0d29yaywgdHlwZSkge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogOSAqL1xuICB2YXIgaW5mbyA9IHt9O1xuICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpICYmICEoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBZGRyZXNzIHN1cHBsaWVkIGlzIG5vdCBhIGJ1ZmZlci4nKTtcbiAgfVxuXG4gIGlmIChidWZmZXIubGVuZ3RoIDwgMjEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBZGRyZXNzIGJ1ZmZlciBpcyBpbmNvcnJlY3QgbGVuZ3RoLicpO1xuICB9XG5cbiAgdmFyIG5ldHdvcmtPYmogPSBOZXR3b3Jrcy5nZXQobmV0d29yayk7XG4gIHZhciBidWZmZXJWZXJzaW9uID0gQWRkcmVzcy5fY2xhc3NpZnlGcm9tVmVyc2lvbihidWZmZXIpO1xuXG4gIGlmIChuZXR3b3JrICYmICFuZXR3b3JrT2JqKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBuZXR3b3JrJyk7XG4gIH1cblxuICBpZiAoIWJ1ZmZlclZlcnNpb24ubmV0d29yayB8fCAobmV0d29ya09iaiAmJiBuZXR3b3JrT2JqLnhwdWJrZXkgIT09IGJ1ZmZlclZlcnNpb24ubmV0d29yay54cHVia2V5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3MgaGFzIG1pc21hdGNoZWQgbmV0d29yayB0eXBlLicpO1xuICB9XG5cbiAgaWYgKCFidWZmZXJWZXJzaW9uLnR5cGUgfHwgKHR5cGUgJiYgdHlwZSAhPT0gYnVmZmVyVmVyc2lvbi50eXBlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3MgaGFzIG1pc21hdGNoZWQgdHlwZS4nKTtcbiAgfVxuXG4gIGlmIChidWZmZXIubGVuZ3RoID4gMjEpIHtcbiAgICBpbmZvLmhhc2hCdWZmZXIgPSBCZWNoMzIuZGVjb2RlKGJ1ZmZlci50b1N0cmluZygndXRmOCcpKS5kYXRhO1xuICB9IGVsc2Uge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgxKTtcbiAgfVxuICBpbmZvLm5ldHdvcmsgPSBuZXR3b3JrT2JqIHx8IGJ1ZmZlclZlcnNpb24ubmV0d29yaztcbiAgaW5mby50eXBlID0gYnVmZmVyVmVyc2lvbi50eXBlO1xuICByZXR1cm4gaW5mbztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGEge0BsaW5rIFB1YmxpY0tleX1cbiAqXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVia2V5IC0gQW4gaW5zdGFuY2Ugb2YgUHVibGljS2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEVpdGhlciAncHVia2V5aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsICdzY3JpcHRoYXNoJywgb3IgJ3RhcHJvb3QnXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyLCB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5BZGRyZXNzLl90cmFuc2Zvcm1QdWJsaWNLZXkgPSBmdW5jdGlvbihwdWJrZXksIG5ldHdvcmssIHR5cGUpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaWYgKCEocHVia2V5IGluc3RhbmNlb2YgUHVibGljS2V5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3MgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQdWJsaWNLZXkuJyk7XG4gIH1cbiAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2ggJiYgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9QdWJsaWNLZXlIYXNoICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9UYXByb290KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHlwZSBtdXN0IGJlIGVpdGhlciBwdWJrZXloYXNoLCB3aXRuZXNzcHVia2V5aGFzaCwgc2NyaXB0aGFzaCwgb3IgdGFwcm9vdCB0byB0cmFuc2Zvcm0gcHVibGljIGtleS4nKTtcbiAgfVxuICBpZiAoIXB1YmtleS5jb21wcmVzc2VkICYmICh0eXBlID09PSBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaCB8fCB0eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1B1YmxpY0tleUhhc2gpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBhZGRyZXNzZXMgbXVzdCB1c2UgY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2gpIHtcbiAgICBpbmZvLmhhc2hCdWZmZXIgPSBIYXNoLnNoYTI1NnJpcGVtZDE2MChTY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQocHVia2V5KS50b0J1ZmZlcigpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBBZGRyZXNzLlBheVRvVGFwcm9vdCkge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHB1YmtleS5jcmVhdGVUYXBUd2VhaygpLnR3ZWFrZWRQdWJLZXk7XG4gIH0gZWxzZSB7XG4gICAgaW5mby5oYXNoQnVmZmVyID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAocHVia2V5LnRvQnVmZmVyKCkpO1xuICB9XG4gIGluZm8udHlwZSA9IHR5cGUgfHwgQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2g7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSB7QGxpbmsgU2NyaXB0fSBpbnRvIGEgYGluZm9gIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1NjcmlwdH0gc2NyaXB0IC0gQW4gaW5zdGFuY2Ugb2YgU2NyaXB0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyLCB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5BZGRyZXNzLl90cmFuc2Zvcm1TY3JpcHQgPSBmdW5jdGlvbihzY3JpcHQsIG5ldHdvcmspIHtcbiAgJC5jaGVja0FyZ3VtZW50KHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCwgJ3NjcmlwdCBtdXN0IGJlIGEgU2NyaXB0IGluc3RhbmNlJyk7XG4gIHZhciBpbmZvID0gc2NyaXB0LmdldEFkZHJlc3NJbmZvKG5ldHdvcmspO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlNjcmlwdC5DYW50RGVyaXZlQWRkcmVzcyhzY3JpcHQpO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUDJTSCBhZGRyZXNzIGZyb20gYSBzZXQgb2YgcHVibGljIGtleXMgYW5kIGEgdGhyZXNob2xkLlxuICpcbiAqIFRoZSBhZGRyZXNzZXMgd2lsbCBiZSBzb3J0ZWQgbGV4aWNvZ3JhcGhpY2FsbHksIGFzIHRoYXQgaXMgdGhlIHRyZW5kIGluIGJpdGNvaW4uXG4gKiBUbyBjcmVhdGUgYW4gYWRkcmVzcyBmcm9tIHVuc29ydGVkIHB1YmxpYyBrZXlzLCB1c2UgdGhlIHtAbGluayBTY3JpcHQjYnVpbGRNdWx0aXNpZ091dH1cbiAqIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwdWJsaWNLZXlzIC0gYSBzZXQgb2YgcHVibGljIGtleXMgdG8gY3JlYXRlIGFuIGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGQgLSB0aGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgbmVlZGVkIHRvIHJlbGVhc2UgdGhlIGZ1bmRzXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5lc3RlZFdpdG5lc3MgLSBpZiB0aGUgYWRkcmVzcyB1c2VzIGEgbmVzdGVkIHAyc2ggd2l0bmVzc1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBFaXRoZXIgJ3NjcmlwdGhhc2gnIG9yICd3aXRuZXNzc2NyaXB0aGFzaCcuIElmIG5lc3RlZFdpdG5lc3MgaXMgc2V0LCB0aGVuIHRoaXMgaXMgaWdub3JlZFxuICogQHJldHVybiB7QWRkcmVzc31cbiAqL1xuQWRkcmVzcy5jcmVhdGVNdWx0aXNpZyA9IGZ1bmN0aW9uKHB1YmxpY0tleXMsIHRocmVzaG9sZCwgbmV0d29yaywgbmVzdGVkV2l0bmVzcywgdHlwZSkge1xuICBuZXR3b3JrID0gbmV0d29yayB8fCBwdWJsaWNLZXlzWzBdLm5ldHdvcmsgfHwgTmV0d29ya3MuZGVmYXVsdE5ldHdvcms7XG4gIGlmICh0eXBlICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGUgbXVzdCBiZSBlaXRoZXIgc2NyaXB0aGFzaCBvciB3aXRuZXNzc2NyaXB0aGFzaCB0byBjcmVhdGUgbXVsdGlzaWcuJyk7XG4gIH1cbiAgaWYgKG5lc3RlZFdpdG5lc3MgfHwgdHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XG4gICAgcHVibGljS2V5cyA9IF8ubWFwKHB1YmxpY0tleXMsIFB1YmxpY0tleSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdWJsaWNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXB1YmxpY0tleXNbaV0uY29tcHJlc3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGFkZHJlc3NlcyBtdXN0IHVzZSBjb21wcmVzc2VkIHB1YmxpYyBrZXlzLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmVkZWVtU2NyaXB0ID0gU2NyaXB0LmJ1aWxkTXVsdGlzaWdPdXQocHVibGljS2V5cywgdGhyZXNob2xkKTtcbiAgaWYgKG5lc3RlZFdpdG5lc3MpIHtcbiAgICByZXR1cm4gQWRkcmVzcy5wYXlpbmdUbyhTY3JpcHQuYnVpbGRXaXRuZXNzTXVsdGlzaWdPdXRGcm9tU2NyaXB0KHJlZGVlbVNjcmlwdCksIG5ldHdvcmspO1xuICB9XG4gIHJldHVybiBBZGRyZXNzLnBheWluZ1RvKHJlZGVlbVNjcmlwdCwgbmV0d29yaywgdHlwZSk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIGJpdGNvaW4gYWRkcmVzcyBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBlaXRoZXIgYSBOZXR3b3JrIGluc3RhbmNlLCAnbGl2ZW5ldCcsIG9yICd0ZXN0bmV0J1xuICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIC0gVGhlIHR5cGU6ICdwdWJrZXloYXNoJywgJ3NjcmlwdGhhc2gnLCAnd2l0bmVzc3B1YmtleWhhc2gnLCBvciAnd2l0bmVzc3NjcmlwdGhhc2gnXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyLCBuZXR3b3JrIGFuZCB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5BZGRyZXNzLl90cmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YoZGF0YSkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBwYXJhbWV0ZXIgc3VwcGxpZWQgaXMgbm90IGEgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYoZGF0YS5sZW5ndGggPiAxMDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhZGRyZXNzIHN0cmluZyBpcyB0b28gbG9uZycpO1xuICB9XG5cbiAgaWYgKG5ldHdvcmsgJiYgIU5ldHdvcmtzLmdldChuZXR3b3JrKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gbmV0d29yaycpO1xuICB9XG5cbiAgZGF0YSA9IGRhdGEudHJpbSgpO1xuXG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1CdWZmZXIoQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKSwgbmV0d29yaywgdHlwZSk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoIHx8IHR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCB8fCB0eXBlID09PSBBZGRyZXNzLlBheVRvVGFwcm9vdCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICB2YXIgYWRkcmVzc0J1ZmZlciA9IEJhc2U1OENoZWNrLmRlY29kZShkYXRhKTtcbiAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1CdWZmZXIoYWRkcmVzc0J1ZmZlciwgbmV0d29yaywgdHlwZSk7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhbiBhZGRyZXNzIGZyb20gYSBQdWJsaWNLZXkgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gZGF0YVxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29ya30gbmV0d29yayAtIGVpdGhlciBhIE5ldHdvcmsgaW5zdGFuY2UsICdsaXZlbmV0Jywgb3IgJ3Rlc3RuZXQnXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEVpdGhlciAncHVia2V5aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsIG9yICdzY3JpcHRoYXNoJ1xuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xuICovXG5BZGRyZXNzLmZyb21QdWJsaWNLZXkgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrLCB0eXBlKSB7XG4gIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtUHVibGljS2V5KGRhdGEsIG5ldHdvcmssIHR5cGUpO1xuICBuZXR3b3JrID0gbmV0d29yayB8fCBOZXR3b3Jrcy5kZWZhdWx0TmV0d29yaztcbiAgcmV0dXJuIG5ldyBBZGRyZXNzKGluZm8uaGFzaEJ1ZmZlciwgbmV0d29yaywgaW5mby50eXBlKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYW4gYWRkcmVzcyBmcm9tIGEgcmlwZW1kMTYwIHB1YmxpYyBrZXkgaGFzaFxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoIC0gQW4gaW5zdGFuY2Ugb2YgYnVmZmVyIG9mIHRoZSBoYXNoXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBIG5ldyB2YWxpZCBhbmQgZnJvemVuIGluc3RhbmNlIG9mIGFuIEFkZHJlc3NcbiAqL1xuQWRkcmVzcy5mcm9tUHVibGljS2V5SGFzaCA9IGZ1bmN0aW9uKGhhc2gsIG5ldHdvcmspIHtcbiAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1IYXNoKGhhc2gpO1xuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mby5oYXNoQnVmZmVyLCBuZXR3b3JrLCBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaCk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhIHJpcGVtZDE2MCBzY3JpcHQgaGFzaFxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoIC0gQW4gaW5zdGFuY2Ugb2YgYnVmZmVyIG9mIHRoZSBoYXNoXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gRWl0aGVyICdzY3JpcHRoYXNoJyBvciAnd2l0bmVzc3NjcmlwdGhhc2gnXG4gKiBAcmV0dXJucyB7QWRkcmVzc30gQSBuZXcgdmFsaWQgYW5kIGZyb3plbiBpbnN0YW5jZSBvZiBhbiBBZGRyZXNzXG4gKi9cbkFkZHJlc3MuZnJvbVNjcmlwdEhhc2ggPSBmdW5jdGlvbihoYXNoLCBuZXR3b3JrLCB0eXBlKSB7XG4gICQuY2hlY2tBcmd1bWVudChoYXNoLCAnaGFzaCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1IYXNoKGhhc2gpO1xuICBpZiAodHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoICYmIGhhc2gubGVuZ3RoICE9PSAzMikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRkcmVzcyBoYXNoYnVmZmVyIG11c3QgYmUgZXhhY3RseSAzMiBieXRlcyBmb3IgdjAgd2l0bmVzcyBzY3JpcHQgaGFzaC4nKTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGUgfHwgQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XG4gIHJldHVybiBuZXcgQWRkcmVzcyhpbmZvLmhhc2hCdWZmZXIsIG5ldHdvcmssIHR5cGUpO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBwMnNoIGFkZHJlc3MgcGF5aW5nIHRvIHNjcmlwdC4gVGhpcyB3aWxsIGhhc2ggdGhlIHNjcmlwdCBhbmRcbiAqIHVzZSB0aGF0IHRvIGNyZWF0ZSB0aGUgYWRkcmVzcy5cbiAqIElmIHlvdSB3YW50IHRvIGV4dHJhY3QgYW4gYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggYSBzY3JpcHQgaW5zdGVhZCxcbiAqIHNlZSB7e0FkZHJlc3MjZnJvbVNjcmlwdH19XG4gKlxuICogQHBhcmFtIHtTY3JpcHR9IHNjcmlwdCAtIEFuIGluc3RhbmNlIG9mIFNjcmlwdFxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29ya30gbmV0d29yayAtIGVpdGhlciBhIE5ldHdvcmsgaW5zdGFuY2UsICdsaXZlbmV0Jywgb3IgJ3Rlc3RuZXQnXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEVpdGhlciAnc2NyaXB0aGFzaCcgb3IgJ3dpdG5lc3NzY3JpcHRoYXNoJ1xuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xuICovXG5BZGRyZXNzLnBheWluZ1RvID0gZnVuY3Rpb24oc2NyaXB0LCBuZXR3b3JrLCB0eXBlKSB7XG4gICQuY2hlY2tBcmd1bWVudChzY3JpcHQsICdzY3JpcHQgaXMgcmVxdWlyZWQnKTtcbiAgJC5jaGVja0FyZ3VtZW50KHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCwgJ3NjcmlwdCBtdXN0IGJlIGluc3RhbmNlIG9mIFNjcmlwdCcpO1xuICB2YXIgaGFzaDtcbiAgaWYgKHR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCkge1xuICAgIGhhc2ggPSBIYXNoLnNoYTI1NihzY3JpcHQudG9CdWZmZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgaGFzaCA9IEhhc2guc2hhMjU2cmlwZW1kMTYwKHNjcmlwdC50b0J1ZmZlcigpKTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGUgfHwgQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XG4gIHJldHVybiBBZGRyZXNzLmZyb21TY3JpcHRIYXNoKGhhc2gsIG5ldHdvcmssIHR5cGUpO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0IGFkZHJlc3MgZnJvbSBhIFNjcmlwdC4gVGhlIHNjcmlwdCBtdXN0IGJlIG9mIG9uZVxuICogb2YgdGhlIGZvbGxvd2luZyB0eXBlczogcDJwa2ggaW5wdXQsIHAycGtoIG91dHB1dCwgcDJzaCBpbnB1dFxuICogb3IgcDJzaCBvdXRwdXQuXG4gKiBUaGlzIHdpbGwgYW5hbHl6ZSB0aGUgc2NyaXB0IGFuZCBleHRyYWN0IGFkZHJlc3MgaW5mb3JtYXRpb24gZnJvbSBpdC5cbiAqIElmIHlvdSB3YW50IHRvIHRyYW5zZm9ybSBhbnkgc2NyaXB0IHRvIGEgcDJzaCBBZGRyZXNzIHBheWluZ1xuICogdG8gdGhhdCBzY3JpcHQncyBoYXNoIGluc3RlYWQsIHVzZSB7e0FkZHJlc3MjcGF5aW5nVG99fVxuICpcbiAqIEBwYXJhbSB7U2NyaXB0fSBzY3JpcHQgLSBBbiBpbnN0YW5jZSBvZiBTY3JpcHRcbiAqIEBwYXJhbSB7U3RyaW5nfE5ldHdvcmt9IG5ldHdvcmsgLSBlaXRoZXIgYSBOZXR3b3JrIGluc3RhbmNlLCAnbGl2ZW5ldCcsIG9yICd0ZXN0bmV0J1xuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xuICovXG5BZGRyZXNzLmZyb21TY3JpcHQgPSBmdW5jdGlvbihzY3JpcHQsIG5ldHdvcmspIHtcbiAgJC5jaGVja0FyZ3VtZW50KHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCwgJ3NjcmlwdCBtdXN0IGJlIGEgU2NyaXB0IGluc3RhbmNlJyk7XG4gIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtU2NyaXB0KHNjcmlwdCwgbmV0d29yayk7XG4gIHJldHVybiBuZXcgQWRkcmVzcyhpbmZvLmhhc2hCdWZmZXIsIG5ldHdvcmssIGluZm8udHlwZSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhIGJ1ZmZlciBvZiB0aGUgYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgLSBBbiBpbnN0YW5jZSBvZiBidWZmZXIgb2YgdGhlIGFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfE5ldHdvcms9fSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIFRoZSB0eXBlIG9mIGFkZHJlc3M6ICdzY3JpcHQnIG9yICdwdWJrZXknXG4gKiBAcmV0dXJucyB7QWRkcmVzc30gQSBuZXcgdmFsaWQgYW5kIGZyb3plbiBpbnN0YW5jZSBvZiBhbiBBZGRyZXNzXG4gKi9cbkFkZHJlc3MuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlciwgbmV0d29yaywgdHlwZSkge1xuICB2YXIgaW5mbyA9IEFkZHJlc3MuX3RyYW5zZm9ybUJ1ZmZlcihidWZmZXIsIG5ldHdvcmssIHR5cGUpO1xuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mby5oYXNoQnVmZmVyLCBpbmZvLm5ldHdvcmssIGluZm8udHlwZSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhbiBhZGRyZXNzIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBBbiBzdHJpbmcgb2YgdGhlIGJpdGNvaW4gYWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBlaXRoZXIgYSBOZXR3b3JrIGluc3RhbmNlLCAnbGl2ZW5ldCcsIG9yICd0ZXN0bmV0J1xuICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBIG5ldyB2YWxpZCBhbmQgZnJvemVuIGluc3RhbmNlIG9mIGFuIEFkZHJlc3NcbiAqL1xuQWRkcmVzcy5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBuZXR3b3JrLCB0eXBlKSB7XG4gIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtU3RyaW5nKHN0ciwgbmV0d29yaywgdHlwZSk7XG4gIHJldHVybiBuZXcgQWRkcmVzcyhpbmZvLmhhc2hCdWZmZXIsIGluZm8ubmV0d29yaywgaW5mby50eXBlKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYW4gYWRkcmVzcyBmcm9tIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc29uIC0gQW4gSlNPTiBzdHJpbmcgb3IgT2JqZWN0IHdpdGgga2V5czogaGFzaCwgbmV0d29yayBhbmQgdHlwZVxuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIGFuIEFkZHJlc3NcbiAqL1xuQWRkcmVzcy5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcbiAgJC5jaGVja1N0YXRlKFxuICAgIEpTVXRpbC5pc0hleGEob2JqLmhhc2gpLFxuICAgICdVbmV4cGVjdGVkIGhhc2ggcHJvcGVydHksIFwiJyArIG9iai5oYXNoICsgJ1wiLCBleHBlY3RlZCB0byBiZSBoZXguJ1xuICApO1xuICB2YXIgaGFzaEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG9iai5oYXNoLCAnaGV4Jyk7XG4gIHJldHVybiBuZXcgQWRkcmVzcyhoYXNoQnVmZmVyLCBvYmoubmV0d29yaywgb2JqLnR5cGUpO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIHZhbGlkYXRpb24gZXJyb3IgaWYgZXhpc3RzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIGEgbmV0d29yayBtaXNtYXRjaCBlcnJvclxuICogdmFyIGVycm9yID0gQWRkcmVzcy5nZXRWYWxpZGF0aW9uRXJyb3IoJzE1dmtjS2Y3Z0IyM3dMQW5aTG1iVnVNaWlWRGMxTm00YTInLCAndGVzdG5ldCcpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcbiAqIEByZXR1cm5zIHtudWxsfEVycm9yfSBUaGUgY29ycmVzcG9uZGluZyBlcnJvciBtZXNzYWdlXG4gKi9cbkFkZHJlc3MuZ2V0VmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaywgdHlwZSkge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgLyoganNoaW50IG5vbmV3OiBmYWxzZSAqL1xuICAgIG5ldyBBZGRyZXNzKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYSBib29sZWFuIGlmIGFuIGFkZHJlc3MgaXMgdmFsaWRcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogYXNzZXJ0KEFkZHJlc3MuaXNWYWxpZCgnMTV2a2NLZjdnQjIzd0xBblpMbWJWdU1paVZEYzFObTRhMicsICdsaXZlbmV0JykpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgY29ycmVzcG9uZGluZyBlcnJvciBtZXNzYWdlXG4gKi9cbkFkZHJlc3MuaXNWYWxpZCA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmssIHR5cGUpIHtcbiAgcmV0dXJuICFBZGRyZXNzLmdldFZhbGlkYXRpb25FcnJvcihkYXRhLCBuZXR3b3JrLCB0eXBlKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGFkZHJlc3MgaXMgb2YgcGF5IHRvIHB1YmxpYyBrZXkgaGFzaCB0eXBlXG4gKiBAcmV0dXJuIGJvb2xlYW5cbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUuaXNQYXlUb1B1YmxpY0tleUhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2g7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhZGRyZXNzIGlzIG9mIHBheSB0byBzY3JpcHQgaGFzaCB0eXBlXG4gKiBAcmV0dXJuIGJvb2xlYW5cbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUuaXNQYXlUb1NjcmlwdEhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhZGRyZXNzIGlzIG9mIHBheSB0byB3aXRuZXNzIHB1YmxpYyBrZXkgaGFzaCB0eXBlXG4gKiBAcmV0dXJuIGJvb2xlYW5cbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUuaXNQYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGFkZHJlc3MgaXMgb2YgcGF5IHRvIHdpdG5lc3Mgc2NyaXB0IGhhc2ggdHlwZVxuICogQHJldHVybiBib29sZWFuXG4gKi9cbkFkZHJlc3MucHJvdG90eXBlLmlzUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2g7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhZGRyZXNzIGlzIG9mIHBheSB0byBUYXByb290IHNjcmlwdCBoYXNoIHR5cGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5BZGRyZXNzLnByb3RvdHlwZS5pc1BheVRvVGFwcm9vdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSBBZGRyZXNzLlBheVRvVGFwcm9vdDtcbn1cblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xuICpcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEJpdGNvaW4gYWRkcmVzcyBidWZmZXJcbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNQYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoKCkgfHwgdGhpcy5pc1BheVRvV2l0bmVzc1NjcmlwdEhhc2goKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLnRvU3RyaW5nKCksICd1dGY4JylcbiAgfVxuICB2YXIgdmVyc2lvbiA9IEJ1ZmZlci5mcm9tKFt0aGlzLm5ldHdvcmtbdGhpcy50eXBlXV0pO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdmVyc2lvbiwgdGhpcy5oYXNoQnVmZmVyXSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcGxhaW4gb2JqZWN0IHdpdGggdGhlIGFkZHJlc3MgaW5mb3JtYXRpb25cbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUudG9PYmplY3QgPSBBZGRyZXNzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBoYXNoOiB0aGlzLmhhc2hCdWZmZXIudG9TdHJpbmcoJ2hleCcpLFxuICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmsudG9TdHJpbmcoKVxuICB9O1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZHJlc3NcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCaXRjb2luIGFkZHJlc3NcbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNQYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoKCkgfHwgdGhpcy5pc1BheVRvV2l0bmVzc1NjcmlwdEhhc2goKSB8fCB0aGlzLmlzUGF5VG9UYXByb290KCkpIHtcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5uZXR3b3JrLmJlY2gzMnByZWZpeDtcbiAgICBsZXQgdmVyc2lvbiA9IDA7XG4gICAgbGV0IGVuY29kaW5nID0gQmVjaDMyLmVuY29kaW5ncy5CRUNIMzI7XG4gICAgaWYgKHRoaXMuaXNQYXlUb1RhcHJvb3QoKSkge1xuICAgICAgdmVyc2lvbiA9IDE7XG4gICAgICBlbmNvZGluZyA9IEJlY2gzMi5lbmNvZGluZ3MuQkVDSDMyTTtcbiAgICB9XG4gICAgcmV0dXJuIEJlY2gzMi5lbmNvZGUocHJlZml4LCB2ZXJzaW9uLCB0aGlzLmhhc2hCdWZmZXIsIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gQmFzZTU4Q2hlY2suZW5jb2RlKHRoaXMudG9CdWZmZXIoKSk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCaXRjb2luIGFkZHJlc3NcbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxBZGRyZXNzOiAnICsgdGhpcy50b1N0cmluZygpICsgJywgdHlwZTogJyArIHRoaXMudHlwZSArICcsIG5ldHdvcms6ICcgKyB0aGlzLm5ldHdvcmsgKyAnPic7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFkZHJlc3M7XG5cbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/block/block.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/block/block.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar BlockHeader = __webpack_require__(/*! ./blockheader */ \"(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Transaction = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\n/**\n * Instantiate a Block from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {Block}\n * @constructor\n */\nfunction Block(arg) {\n  if (!(this instanceof Block)) {\n    return new Block(arg);\n  }\n  _.extend(this, Block._from(arg));\n  return this;\n}\n\n// https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14\nBlock.MAX_BLOCK_SIZE = 1000000;\n\n/**\n * @param {*} - A Buffer, JSON string or Object\n * @returns {Object} - An object representing block data\n * @throws {TypeError} - If the argument was not recognized\n * @private\n */\nBlock._from = function _from(arg) {\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = Block._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    info = Block._fromObject(arg);\n  } else {\n    throw new TypeError('Unrecognized argument for Block');\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Object} - An object representing block data\n * @private\n */\nBlock._fromObject = function _fromObject(data) {\n  var transactions = [];\n  data.transactions.forEach(function(tx) {\n    if (tx instanceof Transaction) {\n      transactions.push(tx);\n    } else {\n      transactions.push(Transaction().fromObject(tx));\n    }\n  });\n  var info = {\n    header: BlockHeader.fromObject(data.header),\n    transactions: transactions\n  };\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nBlock.fromObject = function fromObject(obj) {\n  var info = Block._fromObject(obj);\n  return new Block(info);\n};\n\n/**\n * @param {BufferReader} - Block data\n * @returns {Object} - An object representing the block data\n * @private\n */\nBlock._fromBufferReader = function _fromBufferReader(br) {\n  var info = {};\n  $.checkState(!br.finished(), 'No block data received');\n  info.header = BlockHeader.fromBufferReader(br);\n  var transactions = br.readVarintNum();\n  info.transactions = [];\n  for (var i = 0; i < transactions; i++) {\n    info.transactions.push(Transaction().fromBufferReader(br));\n  }\n  return info;\n};\n\n/**\n * @param {BufferReader} - A buffer reader of the block\n * @returns {Block} - An instance of block\n */\nBlock.fromBufferReader = function fromBufferReader(br) {\n  $.checkArgument(br, 'br is required');\n  var info = Block._fromBufferReader(br);\n  return new Block(info);\n};\n\n/**\n * @param {Buffer} - A buffer of the block\n * @returns {Block} - An instance of block\n */\nBlock.fromBuffer = function fromBuffer(buf) {\n  return Block.fromBufferReader(new BufferReader(buf));\n};\n\n/**\n * @param {string} - str - A hex encoded string of the block\n * @returns {Block} - A hex encoded string of the block\n */\nBlock.fromString = function fromString(str) {\n  var buf = Buffer.from(str, 'hex');\n  return Block.fromBuffer(buf);\n};\n\n/**\n * @param {Binary} - Raw block binary data or buffer\n * @returns {Block} - An instance of block\n */\nBlock.fromRawBlock = function fromRawBlock(data) {\n  if (!BufferUtil.isBuffer(data)) {\n    data = Buffer.from(data, 'binary');\n  }\n  var br = BufferReader(data);\n  br.pos = Block.Values.START_OF_BLOCK;\n  var info = Block._fromBufferReader(br);\n  return new Block(info);\n};\n\n/**\n * @returns {Object} - A plain object with the block properties\n */\nBlock.prototype.toObject = Block.prototype.toJSON = function toObject() {\n  var transactions = [];\n  this.transactions.forEach(function(tx) {\n    transactions.push(tx.toObject());\n  });\n  return {\n    header: this.header.toObject(),\n    transactions: transactions\n  };\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @returns {string} - A hex encoded string of the block\n */\nBlock.prototype.toString = function toString() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the Block\n */\nBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeVarintNum(this.transactions.length);\n  for (var i = 0; i < this.transactions.length; i++) {\n    this.transactions[i].toBufferWriter(bw);\n  }\n  return bw;\n};\n\n/**\n * Will iterate through each transaction and return an array of hashes\n * @returns {Array} - An array with transaction hashes\n */\nBlock.prototype.getTransactionHashes = function getTransactionHashes() {\n  var hashes = [];\n  if (this.transactions.length === 0) {\n    return [Block.Values.NULL_HASH];\n  }\n  for (var t = 0; t < this.transactions.length; t++) {\n    hashes.push(this.transactions[t]._getHash());\n  }\n  return hashes;\n};\n\n/**\n * Will build a merkle tree of all the transactions, ultimately arriving at\n * a single point, the merkle root.\n * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees\n * @returns {Array} - An array with each level of the tree after the other.\n */\nBlock.prototype.getMerkleTree = function getMerkleTree() {\n\n  var tree = this.getTransactionHashes();\n\n  var j = 0;\n  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {\n    for (var i = 0; i < size; i += 2) {\n      var i2 = Math.min(i + 1, size - 1);\n      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);\n      tree.push(Hash.sha256sha256(buf));\n    }\n    j += size;\n  }\n\n  return tree;\n};\n\n/**\n * Calculates the merkleRoot from the transactions.\n * @returns {Buffer} - A buffer of the merkle root hash\n */\nBlock.prototype.getMerkleRoot = function getMerkleRoot() {\n  var tree = this.getMerkleTree();\n  return tree[tree.length - 1];\n};\n\n/**\n * Verifies that the transactions in the block match the header merkle root\n * @returns {Boolean} - If the merkle roots match\n */\nBlock.prototype.validMerkleRoot = function validMerkleRoot() {\n\n  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');\n  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');\n\n  if (h.cmp(c) !== 0) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * @returns {Buffer} - The little endian hash buffer of the header\n */\nBlock.prototype._getHash = function() {\n  return this.header._getHash();\n};\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get: function() {\n    if (!this._id) {\n      this._id = this.header.id;\n    }\n    return this._id;\n  },\n  set: _.noop\n};\nObject.defineProperty(Block.prototype, 'id', idProperty);\nObject.defineProperty(Block.prototype, 'hash', idProperty);\n\n/**\n * @returns {string} - A string formatted for the console\n */\nBlock.prototype.inspect = function inspect() {\n  return '<Block ' + this.id + '>';\n};\n\nBlock.Values = {\n  START_OF_BLOCK: 8, // Start of block in raw block data\n  NULL_HASH: Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\n\nmodule.exports = Block;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL2Jsb2NrLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUN6QyxTQUFTLG1CQUFPLENBQUMsdUVBQWM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDckQsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDMUMsUUFBUSxtQkFBTyxDQUFDLHlGQUF1Qjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3RELG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvYmxvY2svYmxvY2suanM/MjFmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgQmxvY2tIZWFkZXIgPSByZXF1aXJlKCcuL2Jsb2NraGVhZGVyJyk7XG52YXIgQk4gPSByZXF1aXJlKCcuLi9jcnlwdG8vYm4nKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcbnZhciBCdWZmZXJSZWFkZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJyZWFkZXInKTtcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgQmxvY2sgZnJvbSBhIEJ1ZmZlciwgSlNPTiBvYmplY3QsIG9yIE9iamVjdCB3aXRoXG4gKiB0aGUgcHJvcGVydGllcyBvZiB0aGUgQmxvY2tcbiAqXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nLCBvciBPYmplY3RcbiAqIEByZXR1cm5zIHtCbG9ja31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCbG9jayhhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJsb2NrKSkge1xuICAgIHJldHVybiBuZXcgQmxvY2soYXJnKTtcbiAgfVxuICBfLmV4dGVuZCh0aGlzLCBCbG9jay5fZnJvbShhcmcpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpdGNvaW4vYmxvYi9iNWZhMTMyMzI5ZjAzNzdkNzg3YTRhMjFjMTY4NjYwOWMyYmZhZWNlL3NyYy9wcmltaXRpdmVzL2Jsb2NrLmgjTDE0XG5CbG9jay5NQVhfQkxPQ0tfU0laRSA9IDEwMDAwMDA7XG5cbi8qKlxuICogQHBhcmFtIHsqfSAtIEEgQnVmZmVyLCBKU09OIHN0cmluZyBvciBPYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBibG9jayBkYXRhXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IC0gSWYgdGhlIGFyZ3VtZW50IHdhcyBub3QgcmVjb2duaXplZFxuICogQHByaXZhdGVcbiAqL1xuQmxvY2suX2Zyb20gPSBmdW5jdGlvbiBfZnJvbShhcmcpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnKSkge1xuICAgIGluZm8gPSBCbG9jay5fZnJvbUJ1ZmZlclJlYWRlcihCdWZmZXJSZWFkZXIoYXJnKSk7XG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChhcmcpKSB7XG4gICAgaW5mbyA9IEJsb2NrLl9mcm9tT2JqZWN0KGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIGFyZ3VtZW50IGZvciBCbG9jaycpO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gLSBBIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYmxvY2sgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuQmxvY2suX2Zyb21PYmplY3QgPSBmdW5jdGlvbiBfZnJvbU9iamVjdChkYXRhKSB7XG4gIHZhciB0cmFuc2FjdGlvbnMgPSBbXTtcbiAgZGF0YS50cmFuc2FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbih0eCkge1xuICAgIGlmICh0eCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgICB0cmFuc2FjdGlvbnMucHVzaCh0eCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKFRyYW5zYWN0aW9uKCkuZnJvbU9iamVjdCh0eCkpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBpbmZvID0ge1xuICAgIGhlYWRlcjogQmxvY2tIZWFkZXIuZnJvbU9iamVjdChkYXRhLmhlYWRlciksXG4gICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnNcbiAgfTtcbiAgcmV0dXJuIGluZm87XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSAtIEEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RcbiAqIEByZXR1cm5zIHtCbG9ja30gLSBBbiBpbnN0YW5jZSBvZiBibG9ja1xuICovXG5CbG9jay5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcbiAgdmFyIGluZm8gPSBCbG9jay5fZnJvbU9iamVjdChvYmopO1xuICByZXR1cm4gbmV3IEJsb2NrKGluZm8pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlclJlYWRlcn0gLSBCbG9jayBkYXRhXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJsb2NrIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbkJsb2NrLl9mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24gX2Zyb21CdWZmZXJSZWFkZXIoYnIpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgJC5jaGVja1N0YXRlKCFici5maW5pc2hlZCgpLCAnTm8gYmxvY2sgZGF0YSByZWNlaXZlZCcpO1xuICBpbmZvLmhlYWRlciA9IEJsb2NrSGVhZGVyLmZyb21CdWZmZXJSZWFkZXIoYnIpO1xuICB2YXIgdHJhbnNhY3Rpb25zID0gYnIucmVhZFZhcmludE51bSgpO1xuICBpbmZvLnRyYW5zYWN0aW9ucyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zYWN0aW9uczsgaSsrKSB7XG4gICAgaW5mby50cmFuc2FjdGlvbnMucHVzaChUcmFuc2FjdGlvbigpLmZyb21CdWZmZXJSZWFkZXIoYnIpKTtcbiAgfVxuICByZXR1cm4gaW5mbztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJSZWFkZXJ9IC0gQSBidWZmZXIgcmVhZGVyIG9mIHRoZSBibG9ja1xuICogQHJldHVybnMge0Jsb2NrfSAtIEFuIGluc3RhbmNlIG9mIGJsb2NrXG4gKi9cbkJsb2NrLmZyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyUmVhZGVyKGJyKSB7XG4gICQuY2hlY2tBcmd1bWVudChiciwgJ2JyIGlzIHJlcXVpcmVkJyk7XG4gIHZhciBpbmZvID0gQmxvY2suX2Zyb21CdWZmZXJSZWFkZXIoYnIpO1xuICByZXR1cm4gbmV3IEJsb2NrKGluZm8pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgYmxvY2tcbiAqIEByZXR1cm5zIHtCbG9ja30gLSBBbiBpbnN0YW5jZSBvZiBibG9ja1xuICovXG5CbG9jay5mcm9tQnVmZmVyID0gZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgcmV0dXJuIEJsb2NrLmZyb21CdWZmZXJSZWFkZXIobmV3IEJ1ZmZlclJlYWRlcihidWYpKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IC0gc3RyIC0gQSBoZXggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJsb2NrXG4gKiBAcmV0dXJucyB7QmxvY2t9IC0gQSBoZXggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJsb2NrXG4gKi9cbkJsb2NrLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xuICB2YXIgYnVmID0gQnVmZmVyLmZyb20oc3RyLCAnaGV4Jyk7XG4gIHJldHVybiBCbG9jay5mcm9tQnVmZmVyKGJ1Zik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QmluYXJ5fSAtIFJhdyBibG9jayBiaW5hcnkgZGF0YSBvciBidWZmZXJcbiAqIEByZXR1cm5zIHtCbG9ja30gLSBBbiBpbnN0YW5jZSBvZiBibG9ja1xuICovXG5CbG9jay5mcm9tUmF3QmxvY2sgPSBmdW5jdGlvbiBmcm9tUmF3QmxvY2soZGF0YSkge1xuICBpZiAoIUJ1ZmZlclV0aWwuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ2JpbmFyeScpO1xuICB9XG4gIHZhciBiciA9IEJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgYnIucG9zID0gQmxvY2suVmFsdWVzLlNUQVJUX09GX0JMT0NLO1xuICB2YXIgaW5mbyA9IEJsb2NrLl9mcm9tQnVmZmVyUmVhZGVyKGJyKTtcbiAgcmV0dXJuIG5ldyBCbG9jayhpbmZvKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge09iamVjdH0gLSBBIHBsYWluIG9iamVjdCB3aXRoIHRoZSBibG9jayBwcm9wZXJ0aWVzXG4gKi9cbkJsb2NrLnByb3RvdHlwZS50b09iamVjdCA9IEJsb2NrLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgdmFyIHRyYW5zYWN0aW9ucyA9IFtdO1xuICB0aGlzLnRyYW5zYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHR4KSB7XG4gICAgdHJhbnNhY3Rpb25zLnB1c2godHgudG9PYmplY3QoKSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGhlYWRlcjogdGhpcy5oZWFkZXIudG9PYmplY3QoKSxcbiAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9uc1xuICB9O1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIEEgYnVmZmVyIG9mIHRoZSBibG9ja1xuICovXG5CbG9jay5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXJXcml0ZXIoKS5jb25jYXQoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gLSBBIGhleCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYmxvY2tcbiAqL1xuQmxvY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcldyaXRlcn0gLSBBbiBleGlzdGluZyBpbnN0YW5jZSBvZiBCdWZmZXJXcml0ZXJcbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgQnVmZmVyV3JpdGVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCbG9ja1xuICovXG5CbG9jay5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcldyaXRlcihidykge1xuICBpZiAoIWJ3KSB7XG4gICAgYncgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gIH1cbiAgYncud3JpdGUodGhpcy5oZWFkZXIudG9CdWZmZXIoKSk7XG4gIGJ3LndyaXRlVmFyaW50TnVtKHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS50b0J1ZmZlcldyaXRlcihidyk7XG4gIH1cbiAgcmV0dXJuIGJ3O1xufTtcblxuLyoqXG4gKiBXaWxsIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHRyYW5zYWN0aW9uIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgaGFzaGVzXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgd2l0aCB0cmFuc2FjdGlvbiBoYXNoZXNcbiAqL1xuQmxvY2sucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uSGFzaGVzID0gZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25IYXNoZXMoKSB7XG4gIHZhciBoYXNoZXMgPSBbXTtcbiAgaWYgKHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbQmxvY2suVmFsdWVzLk5VTExfSEFTSF07XG4gIH1cbiAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGg7IHQrKykge1xuICAgIGhhc2hlcy5wdXNoKHRoaXMudHJhbnNhY3Rpb25zW3RdLl9nZXRIYXNoKCkpO1xuICB9XG4gIHJldHVybiBoYXNoZXM7XG59O1xuXG4vKipcbiAqIFdpbGwgYnVpbGQgYSBtZXJrbGUgdHJlZSBvZiBhbGwgdGhlIHRyYW5zYWN0aW9ucywgdWx0aW1hdGVseSBhcnJpdmluZyBhdFxuICogYSBzaW5nbGUgcG9pbnQsIHRoZSBtZXJrbGUgcm9vdC5cbiAqIEBsaW5rIGh0dHBzOi8vZW4uYml0Y29pbi5pdC93aWtpL1Byb3RvY29sX3NwZWNpZmljYXRpb24jTWVya2xlX1RyZWVzXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgd2l0aCBlYWNoIGxldmVsIG9mIHRoZSB0cmVlIGFmdGVyIHRoZSBvdGhlci5cbiAqL1xuQmxvY2sucHJvdG90eXBlLmdldE1lcmtsZVRyZWUgPSBmdW5jdGlvbiBnZXRNZXJrbGVUcmVlKCkge1xuXG4gIHZhciB0cmVlID0gdGhpcy5nZXRUcmFuc2FjdGlvbkhhc2hlcygpO1xuXG4gIHZhciBqID0gMDtcbiAgZm9yICh2YXIgc2l6ZSA9IHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aDsgc2l6ZSA+IDE7IHNpemUgPSBNYXRoLmZsb29yKChzaXplICsgMSkgLyAyKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAyKSB7XG4gICAgICB2YXIgaTIgPSBNYXRoLm1pbihpICsgMSwgc2l6ZSAtIDEpO1xuICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3RyZWVbaiArIGldLCB0cmVlW2ogKyBpMl1dKTtcbiAgICAgIHRyZWUucHVzaChIYXNoLnNoYTI1NnNoYTI1NihidWYpKTtcbiAgICB9XG4gICAgaiArPSBzaXplO1xuICB9XG5cbiAgcmV0dXJuIHRyZWU7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1lcmtsZVJvb3QgZnJvbSB0aGUgdHJhbnNhY3Rpb25zLlxuICogQHJldHVybnMge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgbWVya2xlIHJvb3QgaGFzaFxuICovXG5CbG9jay5wcm90b3R5cGUuZ2V0TWVya2xlUm9vdCA9IGZ1bmN0aW9uIGdldE1lcmtsZVJvb3QoKSB7XG4gIHZhciB0cmVlID0gdGhpcy5nZXRNZXJrbGVUcmVlKCk7XG4gIHJldHVybiB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIHRyYW5zYWN0aW9ucyBpbiB0aGUgYmxvY2sgbWF0Y2ggdGhlIGhlYWRlciBtZXJrbGUgcm9vdFxuICogQHJldHVybnMge0Jvb2xlYW59IC0gSWYgdGhlIG1lcmtsZSByb290cyBtYXRjaFxuICovXG5CbG9jay5wcm90b3R5cGUudmFsaWRNZXJrbGVSb290ID0gZnVuY3Rpb24gdmFsaWRNZXJrbGVSb290KCkge1xuXG4gIHZhciBoID0gbmV3IEJOKHRoaXMuaGVhZGVyLm1lcmtsZVJvb3QudG9TdHJpbmcoJ2hleCcpLCAnaGV4Jyk7XG4gIHZhciBjID0gbmV3IEJOKHRoaXMuZ2V0TWVya2xlUm9vdCgpLnRvU3RyaW5nKCdoZXgnKSwgJ2hleCcpO1xuXG4gIGlmIChoLmNtcChjKSAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIFRoZSBsaXR0bGUgZW5kaWFuIGhhc2ggYnVmZmVyIG9mIHRoZSBoZWFkZXJcbiAqL1xuQmxvY2sucHJvdG90eXBlLl9nZXRIYXNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlci5fZ2V0SGFzaCgpO1xufTtcblxudmFyIGlkUHJvcGVydHkgPSB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBiaWcgZW5kaWFuIGhhc2ggYnVmZmVyIG9mIHRoZSBoZWFkZXJcbiAgICovXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pZCkge1xuICAgICAgdGhpcy5faWQgPSB0aGlzLmhlYWRlci5pZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9LFxuICBzZXQ6IF8ubm9vcFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9jay5wcm90b3R5cGUsICdpZCcsIGlkUHJvcGVydHkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrLnByb3RvdHlwZSwgJ2hhc2gnLCBpZFByb3BlcnR5KTtcblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqL1xuQmxvY2sucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICByZXR1cm4gJzxCbG9jayAnICsgdGhpcy5pZCArICc+Jztcbn07XG5cbkJsb2NrLlZhbHVlcyA9IHtcbiAgU1RBUlRfT0ZfQkxPQ0s6IDgsIC8vIFN0YXJ0IG9mIGJsb2NrIGluIHJhdyBibG9jayBkYXRhXG4gIE5VTExfSEFTSDogQnVmZmVyLmZyb20oJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAnaGV4Jylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmxvY2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/block/block.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/block/blockheader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar GENESIS_BITS = 0x1d00ffff;\n\n/**\n * Instantiate a BlockHeader from a Buffer, JSON object, or Object with\n * the properties of the BlockHeader\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {BlockHeader} - An instance of block header\n * @constructor\n */\nvar BlockHeader = function BlockHeader(arg) {\n  if (!(this instanceof BlockHeader)) {\n    return new BlockHeader(arg);\n  }\n  var info = BlockHeader._from(arg);\n  this.version = info.version;\n  this.prevHash = info.prevHash;\n  this.merkleRoot = info.merkleRoot;\n  this.time = info.time;\n  this.timestamp = info.time;\n  this.bits = info.bits;\n  this.nonce = info.nonce;\n\n  if (info.hash) {\n    $.checkState(\n      this.hash === info.hash,\n      'Argument object hash property does not match block hash.'\n    );\n  }\n\n  return this;\n};\n\n/**\n * @param {*} - A Buffer, JSON string or Object\n * @returns {Object} - An object representing block header data\n * @throws {TypeError} - If the argument was not recognized\n * @private\n */\nBlockHeader._from = function _from(arg) {\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = BlockHeader._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    info = BlockHeader._fromObject(arg);\n  } else {\n    throw new TypeError('Unrecognized argument for BlockHeader');\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A JSON string\n * @returns {Object} - An object representing block header data\n * @private\n */\nBlockHeader._fromObject = function _fromObject(data) {\n  $.checkArgument(data, 'data is required');\n  var prevHash = data.prevHash;\n  var merkleRoot = data.merkleRoot;\n  if (_.isString(data.prevHash)) {\n    prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, 'hex'));\n  }\n  if (_.isString(data.merkleRoot)) {\n    merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, 'hex'));\n  }\n  var info = {\n    hash: data.hash,\n    version: data.version,\n    prevHash: prevHash,\n    merkleRoot: merkleRoot,\n    time: data.time,\n    timestamp: data.time,\n    bits: data.bits,\n    nonce: data.nonce\n  };\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromObject = function fromObject(obj) {\n  var info = BlockHeader._fromObject(obj);\n  return new BlockHeader(info);\n};\n\n/**\n * @param {Binary} - Raw block binary data or buffer\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromRawBlock = function fromRawBlock(data) {\n  if (!BufferUtil.isBuffer(data)) {\n    data = Buffer.from(data, 'binary');\n  }\n  var br = BufferReader(data);\n  br.pos = BlockHeader.Constants.START_OF_HEADER;\n  var info = BlockHeader._fromBufferReader(br);\n  return new BlockHeader(info);\n};\n\n/**\n * @param {Buffer} - A buffer of the block header\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromBuffer = function fromBuffer(buf) {\n  var info = BlockHeader._fromBufferReader(BufferReader(buf));\n  return new BlockHeader(info);\n};\n\n/**\n * @param {string} - A hex encoded buffer of the block header\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromString = function fromString(str) {\n  var buf = Buffer.from(str, 'hex');\n  return BlockHeader.fromBuffer(buf);\n};\n\n/**\n * @param {BufferReader} - A BufferReader of the block header\n * @returns {Object} - An object representing block header data\n * @private\n */\nBlockHeader._fromBufferReader = function _fromBufferReader(br) {\n  var info = {};\n  info.version = br.readInt32LE();\n  info.prevHash = br.read(32);\n  info.merkleRoot = br.read(32);\n  info.time = br.readUInt32LE();\n  info.bits = br.readUInt32LE();\n  info.nonce = br.readUInt32LE();\n  return info;\n};\n\n/**\n * @param {BufferReader} - A BufferReader of the block header\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromBufferReader = function fromBufferReader(br) {\n  var info = BlockHeader._fromBufferReader(br);\n  return new BlockHeader(info);\n};\n\n/**\n * @returns {Object} - A plain object of the BlockHeader\n */\nBlockHeader.prototype.toObject = BlockHeader.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hash,\n    version: this.version,\n    prevHash: BufferUtil.reverse(this.prevHash).toString('hex'),\n    merkleRoot: BufferUtil.reverse(this.merkleRoot).toString('hex'),\n    time: this.time,\n    bits: this.bits,\n    nonce: this.nonce\n  };\n};\n\n/**\n * @returns {Buffer} - A Buffer of the BlockHeader\n */\nBlockHeader.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @returns {string} - A hex encoded string of the BlockHeader\n */\nBlockHeader.prototype.toString = function toString() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * @param {BufferWriter} - An existing instance BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader\n */\nBlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.writeInt32LE(this.version);\n  bw.write(this.prevHash);\n  bw.write(this.merkleRoot);\n  bw.writeUInt32LE(this.time);\n  bw.writeUInt32LE(this.bits);\n  bw.writeUInt32LE(this.nonce);\n  return bw;\n};\n\n/**\n * Returns the target difficulty for this block\n * @param {Number} bits\n * @returns {BN} An instance of BN with the decoded difficulty bits\n */\nBlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(bits) {\n  bits = bits || this.bits;\n\n  var target = new BN(bits & 0xffffff);\n  var mov = 8 * ((bits >>> 24) - 3);\n  while (mov-- > 0) {\n    target = target.mul(new BN(2));\n  }\n  return target;\n};\n\n/**\n * @link https://en.bitcoin.it/wiki/Difficulty\n * @return {Number}\n */\nBlockHeader.prototype.getDifficulty = function getDifficulty() {\n  var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(Math.pow(10, 8)));\n  var currentTargetBN = this.getTargetDifficulty();\n\n  var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);\n  var decimalPos = difficultyString.length - 8;\n  difficultyString = difficultyString.slice(0, decimalPos) + '.' + difficultyString.slice(decimalPos);\n\n  return parseFloat(difficultyString);\n};\n\n/**\n * @returns {Buffer} - The little endian hash buffer of the header\n */\nBlockHeader.prototype._getHash = function hash() {\n  var buf = this.toBuffer();\n  return Hash.sha256sha256(buf);\n};\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get: function() {\n    if (!this._id) {\n      this._id = BufferReader(this._getHash()).readReverse().toString('hex');\n    }\n    return this._id;\n  },\n  set: _.noop\n};\nObject.defineProperty(BlockHeader.prototype, 'id', idProperty);\nObject.defineProperty(BlockHeader.prototype, 'hash', idProperty);\n\n/**\n * @returns {Boolean} - If timestamp is not too far in the future\n */\nBlockHeader.prototype.validTimestamp = function validTimestamp() {\n  var currentTime = Math.round(new Date().getTime() / 1000);\n  if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty\n */\nBlockHeader.prototype.validProofOfWork = function validProofOfWork() {\n  var pow = new BN(this.id, 'hex');\n  var target = this.getTargetDifficulty();\n\n  if (pow.cmp(target) > 0) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns {string} - A string formatted for the console\n */\nBlockHeader.prototype.inspect = function inspect() {\n  return '<BlockHeader ' + this.id + '>';\n};\n\nBlockHeader.Constants = {\n  START_OF_HEADER: 8, // Start buffer position in raw block data\n  MAX_TIME_OFFSET: 2 * 60 * 60, // The max a timestamp can be in the future\n  LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\n\nmodule.exports = BlockHeader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL2Jsb2NraGVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixTQUFTLG1CQUFPLENBQUMsdUVBQWM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDckQsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxhQUFhLG1CQUFPLENBQUMsbUVBQVk7QUFDakMsUUFBUSxtQkFBTyxDQUFDLHlGQUF1Qjs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9ibG9jay9ibG9ja2hlYWRlci5qcz9lZjBhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvanMnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbnZhciBHRU5FU0lTX0JJVFMgPSAweDFkMDBmZmZmO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgQmxvY2tIZWFkZXIgZnJvbSBhIEJ1ZmZlciwgSlNPTiBvYmplY3QsIG9yIE9iamVjdCB3aXRoXG4gKiB0aGUgcHJvcGVydGllcyBvZiB0aGUgQmxvY2tIZWFkZXJcbiAqXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nLCBvciBPYmplY3RcbiAqIEByZXR1cm5zIHtCbG9ja0hlYWRlcn0gLSBBbiBpbnN0YW5jZSBvZiBibG9jayBoZWFkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQmxvY2tIZWFkZXIgPSBmdW5jdGlvbiBCbG9ja0hlYWRlcihhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJsb2NrSGVhZGVyKSkge1xuICAgIHJldHVybiBuZXcgQmxvY2tIZWFkZXIoYXJnKTtcbiAgfVxuICB2YXIgaW5mbyA9IEJsb2NrSGVhZGVyLl9mcm9tKGFyZyk7XG4gIHRoaXMudmVyc2lvbiA9IGluZm8udmVyc2lvbjtcbiAgdGhpcy5wcmV2SGFzaCA9IGluZm8ucHJldkhhc2g7XG4gIHRoaXMubWVya2xlUm9vdCA9IGluZm8ubWVya2xlUm9vdDtcbiAgdGhpcy50aW1lID0gaW5mby50aW1lO1xuICB0aGlzLnRpbWVzdGFtcCA9IGluZm8udGltZTtcbiAgdGhpcy5iaXRzID0gaW5mby5iaXRzO1xuICB0aGlzLm5vbmNlID0gaW5mby5ub25jZTtcblxuICBpZiAoaW5mby5oYXNoKSB7XG4gICAgJC5jaGVja1N0YXRlKFxuICAgICAgdGhpcy5oYXNoID09PSBpbmZvLmhhc2gsXG4gICAgICAnQXJndW1lbnQgb2JqZWN0IGhhc2ggcHJvcGVydHkgZG9lcyBub3QgbWF0Y2ggYmxvY2sgaGFzaC4nXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nIG9yIE9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gLSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGJsb2NrIGhlYWRlciBkYXRhXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IC0gSWYgdGhlIGFyZ3VtZW50IHdhcyBub3QgcmVjb2duaXplZFxuICogQHByaXZhdGVcbiAqL1xuQmxvY2tIZWFkZXIuX2Zyb20gPSBmdW5jdGlvbiBfZnJvbShhcmcpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnKSkge1xuICAgIGluZm8gPSBCbG9ja0hlYWRlci5fZnJvbUJ1ZmZlclJlYWRlcihCdWZmZXJSZWFkZXIoYXJnKSk7XG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChhcmcpKSB7XG4gICAgaW5mbyA9IEJsb2NrSGVhZGVyLl9mcm9tT2JqZWN0KGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIGFyZ3VtZW50IGZvciBCbG9ja0hlYWRlcicpO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gLSBBIEpTT04gc3RyaW5nXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYmxvY2sgaGVhZGVyIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbkJsb2NrSGVhZGVyLl9mcm9tT2JqZWN0ID0gZnVuY3Rpb24gX2Zyb21PYmplY3QoZGF0YSkge1xuICAkLmNoZWNrQXJndW1lbnQoZGF0YSwgJ2RhdGEgaXMgcmVxdWlyZWQnKTtcbiAgdmFyIHByZXZIYXNoID0gZGF0YS5wcmV2SGFzaDtcbiAgdmFyIG1lcmtsZVJvb3QgPSBkYXRhLm1lcmtsZVJvb3Q7XG4gIGlmIChfLmlzU3RyaW5nKGRhdGEucHJldkhhc2gpKSB7XG4gICAgcHJldkhhc2ggPSBCdWZmZXJVdGlsLnJldmVyc2UoQnVmZmVyLmZyb20oZGF0YS5wcmV2SGFzaCwgJ2hleCcpKTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhkYXRhLm1lcmtsZVJvb3QpKSB7XG4gICAgbWVya2xlUm9vdCA9IEJ1ZmZlclV0aWwucmV2ZXJzZShCdWZmZXIuZnJvbShkYXRhLm1lcmtsZVJvb3QsICdoZXgnKSk7XG4gIH1cbiAgdmFyIGluZm8gPSB7XG4gICAgaGFzaDogZGF0YS5oYXNoLFxuICAgIHZlcnNpb246IGRhdGEudmVyc2lvbixcbiAgICBwcmV2SGFzaDogcHJldkhhc2gsXG4gICAgbWVya2xlUm9vdDogbWVya2xlUm9vdCxcbiAgICB0aW1lOiBkYXRhLnRpbWUsXG4gICAgdGltZXN0YW1wOiBkYXRhLnRpbWUsXG4gICAgYml0czogZGF0YS5iaXRzLFxuICAgIG5vbmNlOiBkYXRhLm5vbmNlXG4gIH07XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gLSBBIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0XG4gKiBAcmV0dXJucyB7QmxvY2tIZWFkZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2sgaGVhZGVyXG4gKi9cbkJsb2NrSGVhZGVyLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikge1xuICB2YXIgaW5mbyA9IEJsb2NrSGVhZGVyLl9mcm9tT2JqZWN0KG9iaik7XG4gIHJldHVybiBuZXcgQmxvY2tIZWFkZXIoaW5mbyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QmluYXJ5fSAtIFJhdyBibG9jayBiaW5hcnkgZGF0YSBvciBidWZmZXJcbiAqIEByZXR1cm5zIHtCbG9ja0hlYWRlcn0gLSBBbiBpbnN0YW5jZSBvZiBibG9jayBoZWFkZXJcbiAqL1xuQmxvY2tIZWFkZXIuZnJvbVJhd0Jsb2NrID0gZnVuY3Rpb24gZnJvbVJhd0Jsb2NrKGRhdGEpIHtcbiAgaWYgKCFCdWZmZXJVdGlsLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiaW5hcnknKTtcbiAgfVxuICB2YXIgYnIgPSBCdWZmZXJSZWFkZXIoZGF0YSk7XG4gIGJyLnBvcyA9IEJsb2NrSGVhZGVyLkNvbnN0YW50cy5TVEFSVF9PRl9IRUFERVI7XG4gIHZhciBpbmZvID0gQmxvY2tIZWFkZXIuX2Zyb21CdWZmZXJSZWFkZXIoYnIpO1xuICByZXR1cm4gbmV3IEJsb2NrSGVhZGVyKGluZm8pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgYmxvY2sgaGVhZGVyXG4gKiBAcmV0dXJucyB7QmxvY2tIZWFkZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2sgaGVhZGVyXG4gKi9cbkJsb2NrSGVhZGVyLmZyb21CdWZmZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1Zikge1xuICB2YXIgaW5mbyA9IEJsb2NrSGVhZGVyLl9mcm9tQnVmZmVyUmVhZGVyKEJ1ZmZlclJlYWRlcihidWYpKTtcbiAgcmV0dXJuIG5ldyBCbG9ja0hlYWRlcihpbmZvKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IC0gQSBoZXggZW5jb2RlZCBidWZmZXIgb2YgdGhlIGJsb2NrIGhlYWRlclxuICogQHJldHVybnMge0Jsb2NrSGVhZGVyfSAtIEFuIGluc3RhbmNlIG9mIGJsb2NrIGhlYWRlclxuICovXG5CbG9ja0hlYWRlci5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0ciwgJ2hleCcpO1xuICByZXR1cm4gQmxvY2tIZWFkZXIuZnJvbUJ1ZmZlcihidWYpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlclJlYWRlcn0gLSBBIEJ1ZmZlclJlYWRlciBvZiB0aGUgYmxvY2sgaGVhZGVyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYmxvY2sgaGVhZGVyIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbkJsb2NrSGVhZGVyLl9mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24gX2Zyb21CdWZmZXJSZWFkZXIoYnIpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby52ZXJzaW9uID0gYnIucmVhZEludDMyTEUoKTtcbiAgaW5mby5wcmV2SGFzaCA9IGJyLnJlYWQoMzIpO1xuICBpbmZvLm1lcmtsZVJvb3QgPSBici5yZWFkKDMyKTtcbiAgaW5mby50aW1lID0gYnIucmVhZFVJbnQzMkxFKCk7XG4gIGluZm8uYml0cyA9IGJyLnJlYWRVSW50MzJMRSgpO1xuICBpbmZvLm5vbmNlID0gYnIucmVhZFVJbnQzMkxFKCk7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlclJlYWRlcn0gLSBBIEJ1ZmZlclJlYWRlciBvZiB0aGUgYmxvY2sgaGVhZGVyXG4gKiBAcmV0dXJucyB7QmxvY2tIZWFkZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2sgaGVhZGVyXG4gKi9cbkJsb2NrSGVhZGVyLmZyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyUmVhZGVyKGJyKSB7XG4gIHZhciBpbmZvID0gQmxvY2tIZWFkZXIuX2Zyb21CdWZmZXJSZWFkZXIoYnIpO1xuICByZXR1cm4gbmV3IEJsb2NrSGVhZGVyKGluZm8pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEEgcGxhaW4gb2JqZWN0IG9mIHRoZSBCbG9ja0hlYWRlclxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9PYmplY3QgPSBCbG9ja0hlYWRlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICBwcmV2SGFzaDogQnVmZmVyVXRpbC5yZXZlcnNlKHRoaXMucHJldkhhc2gpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICBtZXJrbGVSb290OiBCdWZmZXJVdGlsLnJldmVyc2UodGhpcy5tZXJrbGVSb290KS50b1N0cmluZygnaGV4JyksXG4gICAgdGltZTogdGhpcy50aW1lLFxuICAgIGJpdHM6IHRoaXMuYml0cyxcbiAgICBub25jZTogdGhpcy5ub25jZVxuICB9O1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIEEgQnVmZmVyIG9mIHRoZSBCbG9ja0hlYWRlclxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXJXcml0ZXIoKS5jb25jYXQoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gLSBBIGhleCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgQmxvY2tIZWFkZXJcbiAqL1xuQmxvY2tIZWFkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcldyaXRlcn0gLSBBbiBleGlzdGluZyBpbnN0YW5jZSBCdWZmZXJXcml0ZXJcbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgQnVmZmVyV3JpdGVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCbG9ja0hlYWRlclxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcldyaXRlcihidykge1xuICBpZiAoIWJ3KSB7XG4gICAgYncgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gIH1cbiAgYncud3JpdGVJbnQzMkxFKHRoaXMudmVyc2lvbik7XG4gIGJ3LndyaXRlKHRoaXMucHJldkhhc2gpO1xuICBidy53cml0ZSh0aGlzLm1lcmtsZVJvb3QpO1xuICBidy53cml0ZVVJbnQzMkxFKHRoaXMudGltZSk7XG4gIGJ3LndyaXRlVUludDMyTEUodGhpcy5iaXRzKTtcbiAgYncud3JpdGVVSW50MzJMRSh0aGlzLm5vbmNlKTtcbiAgcmV0dXJuIGJ3O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0YXJnZXQgZGlmZmljdWx0eSBmb3IgdGhpcyBibG9ja1xuICogQHBhcmFtIHtOdW1iZXJ9IGJpdHNcbiAqIEByZXR1cm5zIHtCTn0gQW4gaW5zdGFuY2Ugb2YgQk4gd2l0aCB0aGUgZGVjb2RlZCBkaWZmaWN1bHR5IGJpdHNcbiAqL1xuQmxvY2tIZWFkZXIucHJvdG90eXBlLmdldFRhcmdldERpZmZpY3VsdHkgPSBmdW5jdGlvbiBnZXRUYXJnZXREaWZmaWN1bHR5KGJpdHMpIHtcbiAgYml0cyA9IGJpdHMgfHwgdGhpcy5iaXRzO1xuXG4gIHZhciB0YXJnZXQgPSBuZXcgQk4oYml0cyAmIDB4ZmZmZmZmKTtcbiAgdmFyIG1vdiA9IDggKiAoKGJpdHMgPj4+IDI0KSAtIDMpO1xuICB3aGlsZSAobW92LS0gPiAwKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0Lm11bChuZXcgQk4oMikpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEBsaW5rIGh0dHBzOi8vZW4uYml0Y29pbi5pdC93aWtpL0RpZmZpY3VsdHlcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQmxvY2tIZWFkZXIucHJvdG90eXBlLmdldERpZmZpY3VsdHkgPSBmdW5jdGlvbiBnZXREaWZmaWN1bHR5KCkge1xuICB2YXIgZGlmZmljdWx0eTFUYXJnZXRCTiA9IHRoaXMuZ2V0VGFyZ2V0RGlmZmljdWx0eShHRU5FU0lTX0JJVFMpLm11bChuZXcgQk4oTWF0aC5wb3coMTAsIDgpKSk7XG4gIHZhciBjdXJyZW50VGFyZ2V0Qk4gPSB0aGlzLmdldFRhcmdldERpZmZpY3VsdHkoKTtcblxuICB2YXIgZGlmZmljdWx0eVN0cmluZyA9IGRpZmZpY3VsdHkxVGFyZ2V0Qk4uZGl2KGN1cnJlbnRUYXJnZXRCTikudG9TdHJpbmcoMTApO1xuICB2YXIgZGVjaW1hbFBvcyA9IGRpZmZpY3VsdHlTdHJpbmcubGVuZ3RoIC0gODtcbiAgZGlmZmljdWx0eVN0cmluZyA9IGRpZmZpY3VsdHlTdHJpbmcuc2xpY2UoMCwgZGVjaW1hbFBvcykgKyAnLicgKyBkaWZmaWN1bHR5U3RyaW5nLnNsaWNlKGRlY2ltYWxQb3MpO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KGRpZmZpY3VsdHlTdHJpbmcpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIFRoZSBsaXR0bGUgZW5kaWFuIGhhc2ggYnVmZmVyIG9mIHRoZSBoZWFkZXJcbiAqL1xuQmxvY2tIZWFkZXIucHJvdG90eXBlLl9nZXRIYXNoID0gZnVuY3Rpb24gaGFzaCgpIHtcbiAgdmFyIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgcmV0dXJuIEhhc2guc2hhMjU2c2hhMjU2KGJ1Zik7XG59O1xuXG52YXIgaWRQcm9wZXJ0eSA9IHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGJpZyBlbmRpYW4gaGFzaCBidWZmZXIgb2YgdGhlIGhlYWRlclxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lkKSB7XG4gICAgICB0aGlzLl9pZCA9IEJ1ZmZlclJlYWRlcih0aGlzLl9nZXRIYXNoKCkpLnJlYWRSZXZlcnNlKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH0sXG4gIHNldDogXy5ub29wXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrSGVhZGVyLnByb3RvdHlwZSwgJ2lkJywgaWRQcm9wZXJ0eSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvY2tIZWFkZXIucHJvdG90eXBlLCAnaGFzaCcsIGlkUHJvcGVydHkpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIHRpbWVzdGFtcCBpcyBub3QgdG9vIGZhciBpbiB0aGUgZnV0dXJlXG4gKi9cbkJsb2NrSGVhZGVyLnByb3RvdHlwZS52YWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHZhbGlkVGltZXN0YW1wKCkge1xuICB2YXIgY3VycmVudFRpbWUgPSBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gIGlmICh0aGlzLnRpbWUgPiBjdXJyZW50VGltZSArIEJsb2NrSGVhZGVyLkNvbnN0YW50cy5NQVhfVElNRV9PRkZTRVQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIHRoZSBwcm9vZi1vZi13b3JrIGhhc2ggc2F0aXNmaWVzIHRoZSB0YXJnZXQgZGlmZmljdWx0eVxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudmFsaWRQcm9vZk9mV29yayA9IGZ1bmN0aW9uIHZhbGlkUHJvb2ZPZldvcmsoKSB7XG4gIHZhciBwb3cgPSBuZXcgQk4odGhpcy5pZCwgJ2hleCcpO1xuICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXREaWZmaWN1bHR5KCk7XG5cbiAgaWYgKHBvdy5jbXAodGFyZ2V0KSA+IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQSBzdHJpbmcgZm9ybWF0dGVkIGZvciB0aGUgY29uc29sZVxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAnPEJsb2NrSGVhZGVyICcgKyB0aGlzLmlkICsgJz4nO1xufTtcblxuQmxvY2tIZWFkZXIuQ29uc3RhbnRzID0ge1xuICBTVEFSVF9PRl9IRUFERVI6IDgsIC8vIFN0YXJ0IGJ1ZmZlciBwb3NpdGlvbiBpbiByYXcgYmxvY2sgZGF0YVxuICBNQVhfVElNRV9PRkZTRVQ6IDIgKiA2MCAqIDYwLCAvLyBUaGUgbWF4IGEgdGltZXN0YW1wIGNhbiBiZSBpbiB0aGUgZnV0dXJlXG4gIExBUkdFU1RfSEFTSDogbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsICdoZXgnKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCbG9ja0hlYWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/block/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/block/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./block */ \"(ssr)/./node_modules/bitcore-lib/lib/block/block.js\");\n\nmodule.exports.BlockHeader = __webpack_require__(/*! ./blockheader */ \"(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\");\nmodule.exports.MerkleBlock = __webpack_require__(/*! ./merkleblock */ \"(ssr)/./node_modules/bitcore-lib/lib/block/merkleblock.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDBHQUFtQzs7QUFFbkMsa0lBQXFEO0FBQ3JELGtJQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9ibG9jay9pbmRleC5qcz83ZjhmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ibG9jaycpO1xuXG5tb2R1bGUuZXhwb3J0cy5CbG9ja0hlYWRlciA9IHJlcXVpcmUoJy4vYmxvY2toZWFkZXInKTtcbm1vZHVsZS5leHBvcnRzLk1lcmtsZUJsb2NrID0gcmVxdWlyZSgnLi9tZXJrbGVibG9jaycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/block/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/block/merkleblock.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/block/merkleblock.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar BlockHeader = __webpack_require__(/*! ./blockheader */ \"(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar Transaction = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n    if(arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n  _.extend(this,info);\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n\n  return this;\n}\n\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(Buffer.from(this.hashes[i], 'hex'));\n  }\n  bw.writeVarintNum(this.flags.length);\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n  return bw;\n};\n\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    return false;\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var root = this._traverseMerkleTree(height, 0, opts);\n  if(opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n\n/**\n * Return a list of all the txs hash that match the filter\n * @returns {Array} - txs hash that match the filter\n */\nMerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // If there is only one hash the filter do not match any txs in the block\n  if(this.hashes.length === 1) {\n    return [];\n  };\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var txs = this._traverseMerkleTree(height, 0, opts, true);\n  if(opts.hashesUsed !== this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n  return txs;\n};\n\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @returns {Array} - transactions found during traversal that match the filter\n * @private\n */\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {\n  /* jshint maxcomplexity:  12*/\n  /* jshint maxstatements: 20 */\n\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n  var checkForTxs = checkForTxs || false;\n\n  if(opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;\n  if(depth === 0 || !isParentOfMatch) {\n    if(opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n    var hash = this.hashes[opts.hashesUsed++];\n    if(depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n    return Buffer.from(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth-1, pos*2, opts);\n    var right = left;\n    if(pos*2+1 < this._calcTreeWidth(depth-1)) {\n      right = this._traverseMerkleTree(depth-1, pos*2+1, opts);\n    }\n    if (checkForTxs){\n      return opts.txs;\n    } else {\n      return Hash.sha256sha256(new Buffer.concat([left, right]));\n    };\n  }\n};\n\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return (this.numTransactions + (1 << height) - 1) >> height;\n};\n\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n  return height;\n};\n\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string',\n      'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n\n  var hash = tx;\n  if(tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\n  }\n\n  var txs = [];\n  var height = this._calcTreeHeight();\n  this._traverseMerkleTree(height, 0, { txs: txs });\n  return txs.indexOf(hash) !== -1;\n};\n\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\n\nmodule.exports = MerkleBlock;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL21lcmtsZWJsb2NrLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxXQUFXLG1CQUFPLENBQUMsMkVBQWdCO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxtRUFBWTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLHVFQUFXO0FBQ2hDLFFBQVEsbUJBQU8sQ0FBQyx5RkFBdUI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsYUFBYTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL21lcmtsZWJsb2NrLmpzP2M3NDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIEJsb2NrSGVhZGVyID0gcmVxdWlyZSgnLi9ibG9ja2hlYWRlcicpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvanMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgTWVya2xlQmxvY2sgZnJvbSBhIEJ1ZmZlciwgSlNPTiBvYmplY3QsIG9yIE9iamVjdCB3aXRoXG4gKiB0aGUgcHJvcGVydGllcyBvZiB0aGUgQmxvY2tcbiAqXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nLCBvciBPYmplY3QgcmVwcmVzZW50aW5nIGEgTWVya2xlQmxvY2tcbiAqIEByZXR1cm5zIHtNZXJrbGVCbG9ja31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNZXJrbGVCbG9jayhhcmcpIHtcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDE4ICovXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1lcmtsZUJsb2NrKSkge1xuICAgIHJldHVybiBuZXcgTWVya2xlQmxvY2soYXJnKTtcbiAgfVxuXG4gIHZhciBpbmZvID0ge307XG4gIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZykpIHtcbiAgICBpbmZvID0gTWVya2xlQmxvY2suX2Zyb21CdWZmZXJSZWFkZXIoQnVmZmVyUmVhZGVyKGFyZykpO1xuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoYXJnKSkge1xuICAgIHZhciBoZWFkZXI7XG4gICAgaWYoYXJnLmhlYWRlciBpbnN0YW5jZW9mIEJsb2NrSGVhZGVyKSB7XG4gICAgICBoZWFkZXIgPSBhcmcuaGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgPSBCbG9ja0hlYWRlci5mcm9tT2JqZWN0KGFyZy5oZWFkZXIpO1xuICAgIH1cbiAgICBpbmZvID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBNZXJrbGVCbG9jayNoZWFkZXJcbiAgICAgICAqIEB0eXBlIHtCbG9ja0hlYWRlcn1cbiAgICAgICAqL1xuICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIE1lcmtsZUJsb2NrI251bVRyYW5zYWN0aW9uc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgbnVtVHJhbnNhY3Rpb25zOiBhcmcubnVtVHJhbnNhY3Rpb25zLFxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBNZXJrbGVCbG9jayNoYXNoZXNcbiAgICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgICAqL1xuICAgICAgaGFzaGVzOiBhcmcuaGFzaGVzLFxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBNZXJrbGVCbG9jayNmbGFnc1xuICAgICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAgICovXG4gICAgICBmbGFnczogYXJnLmZsYWdzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlY29nbml6ZWQgYXJndW1lbnQgZm9yIE1lcmtsZUJsb2NrJyk7XG4gIH1cbiAgXy5leHRlbmQodGhpcyxpbmZvKTtcbiAgdGhpcy5fZmxhZ0JpdHNVc2VkID0gMDtcbiAgdGhpcy5faGFzaGVzVXNlZCA9IDA7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IC0gTWVya2xlQmxvY2sgZGF0YSBpbiBhIEJ1ZmZlciBvYmplY3RcbiAqIEByZXR1cm5zIHtNZXJrbGVCbG9ja30gLSBBIE1lcmtsZUJsb2NrIG9iamVjdFxuICovXG5NZXJrbGVCbG9jay5mcm9tQnVmZmVyID0gZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgcmV0dXJuIE1lcmtsZUJsb2NrLmZyb21CdWZmZXJSZWFkZXIoQnVmZmVyUmVhZGVyKGJ1ZikpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlclJlYWRlcn0gLSBNZXJrbGVCbG9jayBkYXRhIGluIGEgQnVmZmVyUmVhZGVyIG9iamVjdFxuICogQHJldHVybnMge01lcmtsZUJsb2NrfSAtIEEgTWVya2xlQmxvY2sgb2JqZWN0XG4gKi9cbk1lcmtsZUJsb2NrLmZyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyUmVhZGVyKGJyKSB7XG4gIHJldHVybiBuZXcgTWVya2xlQmxvY2soTWVya2xlQmxvY2suX2Zyb21CdWZmZXJSZWFkZXIoYnIpKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgYmxvY2tcbiAqL1xuTWVya2xlQmxvY2sucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyV3JpdGVyKCkuY29uY2F0KCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyV3JpdGVyfSAtIEFuIGV4aXN0aW5nIGluc3RhbmNlIG9mIEJ1ZmZlcldyaXRlclxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcn0gLSBBbiBpbnN0YW5jZSBvZiBCdWZmZXJXcml0ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIE1lcmtsZUJsb2NrXG4gKi9cbk1lcmtsZUJsb2NrLnByb3RvdHlwZS50b0J1ZmZlcldyaXRlciA9IGZ1bmN0aW9uIHRvQnVmZmVyV3JpdGVyKGJ3KSB7XG4gIGlmICghYncpIHtcbiAgICBidyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgfVxuICBidy53cml0ZSh0aGlzLmhlYWRlci50b0J1ZmZlcigpKTtcbiAgYncud3JpdGVVSW50MzJMRSh0aGlzLm51bVRyYW5zYWN0aW9ucyk7XG4gIGJ3LndyaXRlVmFyaW50TnVtKHRoaXMuaGFzaGVzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oYXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBidy53cml0ZShCdWZmZXIuZnJvbSh0aGlzLmhhc2hlc1tpXSwgJ2hleCcpKTtcbiAgfVxuICBidy53cml0ZVZhcmludE51bSh0aGlzLmZsYWdzLmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZsYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgYncud3JpdGVVSW50OCh0aGlzLmZsYWdzW2ldKTtcbiAgfVxuICByZXR1cm4gYnc7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgTWVya2xlQmxvY2sgcHJvcGVydGllc1xuICovXG5NZXJrbGVCbG9jay5wcm90b3R5cGUudG9PYmplY3QgPSBNZXJrbGVCbG9jay5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgaGVhZGVyOiB0aGlzLmhlYWRlci50b09iamVjdCgpLFxuICAgIG51bVRyYW5zYWN0aW9uczogdGhpcy5udW1UcmFuc2FjdGlvbnMsXG4gICAgaGFzaGVzOiB0aGlzLmhhc2hlcyxcbiAgICBmbGFnczogdGhpcy5mbGFnc1xuICB9O1xufTtcblxuLyoqXG4gKiBWZXJpZnkgdGhhdCB0aGUgTWVya2xlQmxvY2sgaXMgdmFsaWRcbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIFRydWUvRmFsc2Ugd2hldGhlciB0aGlzIE1lcmtsZUJsb2NrIGlzIFZhbGlkXG4gKi9cbk1lcmtsZUJsb2NrLnByb3RvdHlwZS52YWxpZE1lcmtsZVRyZWUgPSBmdW5jdGlvbiB2YWxpZE1lcmtsZVRyZWUoKSB7XG4gICQuY2hlY2tTdGF0ZShfLmlzQXJyYXkodGhpcy5mbGFncyksICdNZXJrbGVCbG9jayBmbGFncyBpcyBub3QgYW4gYXJyYXknKTtcbiAgJC5jaGVja1N0YXRlKF8uaXNBcnJheSh0aGlzLmhhc2hlcyksICdNZXJrbGVCbG9jayBoYXNoZXMgaXMgbm90IGFuIGFycmF5Jyk7XG5cbiAgLy8gQ2FuJ3QgaGF2ZSBtb3JlIGhhc2hlcyB0aGFuIG51bVRyYW5zYWN0aW9uc1xuICBpZih0aGlzLmhhc2hlcy5sZW5ndGggPiB0aGlzLm51bVRyYW5zYWN0aW9ucykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENhbid0IGhhdmUgbW9yZSBmbGFnIGJpdHMgdGhhbiBudW0gaGFzaGVzXG4gIGlmKHRoaXMuZmxhZ3MubGVuZ3RoICogOCA8IHRoaXMuaGFzaGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBoZWlnaHQgPSB0aGlzLl9jYWxjVHJlZUhlaWdodCgpO1xuICB2YXIgb3B0cyA9IHsgaGFzaGVzVXNlZDogMCwgZmxhZ0JpdHNVc2VkOiAwIH07XG4gIHZhciByb290ID0gdGhpcy5fdHJhdmVyc2VNZXJrbGVUcmVlKGhlaWdodCwgMCwgb3B0cyk7XG4gIGlmKG9wdHMuaGFzaGVzVXNlZCAhPT0gdGhpcy5oYXNoZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBCdWZmZXJVdGlsLmVxdWFscyhyb290LCB0aGlzLmhlYWRlci5tZXJrbGVSb290KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgbGlzdCBvZiBhbGwgdGhlIHR4cyBoYXNoIHRoYXQgbWF0Y2ggdGhlIGZpbHRlclxuICogQHJldHVybnMge0FycmF5fSAtIHR4cyBoYXNoIHRoYXQgbWF0Y2ggdGhlIGZpbHRlclxuICovXG5NZXJrbGVCbG9jay5wcm90b3R5cGUuZmlsdGVyZFR4c0hhc2ggPSBmdW5jdGlvbiBmaWx0ZXJkVHhzSGFzaCgpIHtcbiAgJC5jaGVja1N0YXRlKF8uaXNBcnJheSh0aGlzLmZsYWdzKSwgJ01lcmtsZUJsb2NrIGZsYWdzIGlzIG5vdCBhbiBhcnJheScpO1xuICAkLmNoZWNrU3RhdGUoXy5pc0FycmF5KHRoaXMuaGFzaGVzKSwgJ01lcmtsZUJsb2NrIGhhc2hlcyBpcyBub3QgYW4gYXJyYXknKTtcblxuICAvLyBDYW4ndCBoYXZlIG1vcmUgaGFzaGVzIHRoYW4gbnVtVHJhbnNhY3Rpb25zXG4gIGlmKHRoaXMuaGFzaGVzLmxlbmd0aCA+IHRoaXMubnVtVHJhbnNhY3Rpb25zKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5NZXJrbGVCbG9jay5JbnZhbGlkTWVya2xlVHJlZSgpO1xuICB9XG5cbiAgLy8gQ2FuJ3QgaGF2ZSBtb3JlIGZsYWcgYml0cyB0aGFuIG51bSBoYXNoZXNcbiAgaWYodGhpcy5mbGFncy5sZW5ndGggKiA4IDwgdGhpcy5oYXNoZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5NZXJrbGVCbG9jay5JbnZhbGlkTWVya2xlVHJlZSgpO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgaGFzaCB0aGUgZmlsdGVyIGRvIG5vdCBtYXRjaCBhbnkgdHhzIGluIHRoZSBibG9ja1xuICBpZih0aGlzLmhhc2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgdmFyIGhlaWdodCA9IHRoaXMuX2NhbGNUcmVlSGVpZ2h0KCk7XG4gIHZhciBvcHRzID0geyBoYXNoZXNVc2VkOiAwLCBmbGFnQml0c1VzZWQ6IDAgfTtcbiAgdmFyIHR4cyA9IHRoaXMuX3RyYXZlcnNlTWVya2xlVHJlZShoZWlnaHQsIDAsIG9wdHMsIHRydWUpO1xuICBpZihvcHRzLmhhc2hlc1VzZWQgIT09IHRoaXMuaGFzaGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuTWVya2xlQmxvY2suSW52YWxpZE1lcmtsZVRyZWUoKTtcbiAgfVxuICByZXR1cm4gdHhzO1xufTtcblxuLyoqXG4gKiBUcmF2ZXJzZSBhIHRoZSB0cmVlIGluIHRoaXMgTWVya2xlQmxvY2ssIHZhbGlkYXRpbmcgaXQgYWxvbmcgdGhlIHdheVxuICogTW9kZWxlZCBhZnRlciBCaXRjb2luIENvcmUgbWVya2xlYmxvY2suY3BwIFRyYXZlcnNlQW5kRXh0cmFjdCgpXG4gKiBAcGFyYW0ge051bWJlcn0gLSBkZXB0aCAtIEN1cnJlbnQgaGVpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0gLSBwb3MgLSBDdXJyZW50IHBvc2l0aW9uIGluIHRoZSB0cmVlXG4gKiBAcGFyYW0ge09iamVjdH0gLSBvcHRzIC0gT2JqZWN0IHdpdGggdmFsdWVzIHRoYXQgbmVlZCB0byBiZSBtdXRhdGVkIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogQHBhcmFtIHtCb29sZWFufSAtIGNoZWNrRm9yVHhzIC0gaWYgdHJ1ZSByZXR1cm4gb3B0cy50eHMgZWxzZSByZXR1cm4gdGhlIE1lcmtsZSBIYXNoXG4gKiBAcGFyYW0ge051bWJlcn0gLSBvcHRzLmZsYWdCaXRzVXNlZCAtIE51bWJlciBvZiBmbGFnIGJpdHMgdXNlZCwgc2hvdWxkIHN0YXJ0IGF0IDBcbiAqIEBwYXJhbSB7TnVtYmVyfSAtIG9wdHMuaGFzaGVzVXNlZCAtIE51bWJlciBvZiBoYXNoZXMgdXNlZCwgc2hvdWxkIHN0YXJ0IGF0IDBcbiAqIEBwYXJhbSB7QXJyYXl9IC0gb3B0cy50eHMgLSBXaWxsIGZpbmlzaCBwb3B1bGF0ZWQgYnkgdHJhbnNhY3Rpb25zIGZvdW5kIGR1cmluZyB0cmF2ZXJzYWwgdGhhdCBtYXRjaCB0aGUgZmlsdGVyXG4gKiBAcmV0dXJucyB7QnVmZmVyfG51bGx9IC0gQnVmZmVyIGNvbnRhaW5pbmcgdGhlIE1lcmtsZSBIYXNoIGZvciB0aGF0IGhlaWdodFxuICogQHJldHVybnMge0FycmF5fSAtIHRyYW5zYWN0aW9ucyBmb3VuZCBkdXJpbmcgdHJhdmVyc2FsIHRoYXQgbWF0Y2ggdGhlIGZpbHRlclxuICogQHByaXZhdGVcbiAqL1xuTWVya2xlQmxvY2sucHJvdG90eXBlLl90cmF2ZXJzZU1lcmtsZVRyZWUgPSBmdW5jdGlvbiB0cmF2ZXJzZU1lcmtsZVRyZWUoZGVwdGgsIHBvcywgb3B0cywgY2hlY2tGb3JUeHMpIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6ICAxMiovXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnR4cyA9IG9wdHMudHhzIHx8IFtdO1xuICBvcHRzLmZsYWdCaXRzVXNlZCA9IG9wdHMuZmxhZ0JpdHNVc2VkIHx8IDA7XG4gIG9wdHMuaGFzaGVzVXNlZCA9IG9wdHMuaGFzaGVzVXNlZCB8fCAwO1xuICB2YXIgY2hlY2tGb3JUeHMgPSBjaGVja0ZvclR4cyB8fCBmYWxzZTtcblxuICBpZihvcHRzLmZsYWdCaXRzVXNlZCA+IHRoaXMuZmxhZ3MubGVuZ3RoICogOCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpc1BhcmVudE9mTWF0Y2ggPSAodGhpcy5mbGFnc1tvcHRzLmZsYWdCaXRzVXNlZCA+PiAzXSA+Pj4gKG9wdHMuZmxhZ0JpdHNVc2VkKysgJiA3KSkgJiAxO1xuICBpZihkZXB0aCA9PT0gMCB8fCAhaXNQYXJlbnRPZk1hdGNoKSB7XG4gICAgaWYob3B0cy5oYXNoZXNVc2VkID49IHRoaXMuaGFzaGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBoYXNoID0gdGhpcy5oYXNoZXNbb3B0cy5oYXNoZXNVc2VkKytdO1xuICAgIGlmKGRlcHRoID09PSAwICYmIGlzUGFyZW50T2ZNYXRjaCkge1xuICAgICAgb3B0cy50eHMucHVzaChoYXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhhc2gsICdoZXgnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVmdCA9IHRoaXMuX3RyYXZlcnNlTWVya2xlVHJlZShkZXB0aC0xLCBwb3MqMiwgb3B0cyk7XG4gICAgdmFyIHJpZ2h0ID0gbGVmdDtcbiAgICBpZihwb3MqMisxIDwgdGhpcy5fY2FsY1RyZWVXaWR0aChkZXB0aC0xKSkge1xuICAgICAgcmlnaHQgPSB0aGlzLl90cmF2ZXJzZU1lcmtsZVRyZWUoZGVwdGgtMSwgcG9zKjIrMSwgb3B0cyk7XG4gICAgfVxuICAgIGlmIChjaGVja0ZvclR4cyl7XG4gICAgICByZXR1cm4gb3B0cy50eHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBIYXNoLnNoYTI1NnNoYTI1NihuZXcgQnVmZmVyLmNvbmNhdChbbGVmdCwgcmlnaHRdKSk7XG4gICAgfTtcbiAgfVxufTtcblxuLyoqIENhbGN1bGF0ZXMgdGhlIHdpZHRoIG9mIGEgbWVya2xlIHRyZWUgYXQgYSBnaXZlbiBoZWlnaHQuXG4gKiAgTW9kZWxlZCBhZnRlciBCaXRjb2luIENvcmUgbWVya2xlYmxvY2suaCBDYWxjVHJlZVdpZHRoKClcbiAqIEBwYXJhbSB7TnVtYmVyfSAtIEhlaWdodCBhdCB3aGljaCB3ZSB3YW50IHRoZSB0cmVlIHdpZHRoXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIFdpZHRoIG9mIHRoZSB0cmVlIGF0IGEgZ2l2ZW4gaGVpZ2h0XG4gKiBAcHJpdmF0ZVxuICovXG5NZXJrbGVCbG9jay5wcm90b3R5cGUuX2NhbGNUcmVlV2lkdGggPSBmdW5jdGlvbiBjYWxjVHJlZVdpZHRoKGhlaWdodCkge1xuICByZXR1cm4gKHRoaXMubnVtVHJhbnNhY3Rpb25zICsgKDEgPDwgaGVpZ2h0KSAtIDEpID4+IGhlaWdodDtcbn07XG5cbi8qKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIG1lcmtsZSB0cmVlIGluIHRoaXMgTWVya2xlQmxvY2tcbiAqIEBwYXJhbSB7TnVtYmVyfSAtIEhlaWdodCBhdCB3aGljaCB3ZSB3YW50IHRoZSB0cmVlIHdpZHRoXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIEhlaWdodCBvZiB0aGUgbWVya2xlIHRyZWUgaW4gdGhpcyBNZXJrbGVCbG9ja1xuICogQHByaXZhdGVcbiAqL1xuTWVya2xlQmxvY2sucHJvdG90eXBlLl9jYWxjVHJlZUhlaWdodCA9IGZ1bmN0aW9uIGNhbGNUcmVlSGVpZ2h0KCkge1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgd2hpbGUgKHRoaXMuX2NhbGNUcmVlV2lkdGgoaGVpZ2h0KSA+IDEpIHtcbiAgICBoZWlnaHQrKztcbiAgfVxuICByZXR1cm4gaGVpZ2h0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufFN0cmluZ30gLSBUcmFuc2FjdGlvbiBvciBUcmFuc2FjdGlvbiBJRCBIYXNoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSByZXR1cm4gdHJ1ZS9mYWxzZSBpZiB0aGlzIE1lcmtsZUJsb2NrIGhhcyB0aGUgVFggb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5NZXJrbGVCbG9jay5wcm90b3R5cGUuaGFzVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBoYXNUcmFuc2FjdGlvbih0eCkge1xuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQodHgpLCAndHggY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuICAkLmNoZWNrQXJndW1lbnQodHggaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiB8fCB0eXBlb2YgdHggPT09ICdzdHJpbmcnLFxuICAgICAgJ0ludmFsaWQgdHggZ2l2ZW4sIHR4IG11c3QgYmUgYSBcInN0cmluZ1wiIG9yIFwiVHJhbnNhY3Rpb25cIicpO1xuXG4gIHZhciBoYXNoID0gdHg7XG4gIGlmKHR4IGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pIHtcbiAgICAvLyBXZSBuZWVkIHRvIHJldmVyc2UgdGhlIGlkIGhhc2ggZm9yIHRoZSBsb29rdXBcbiAgICBoYXNoID0gQnVmZmVyVXRpbC5yZXZlcnNlKEJ1ZmZlci5mcm9tKHR4LmlkLCAnaGV4JykpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIHZhciB0eHMgPSBbXTtcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2NhbGNUcmVlSGVpZ2h0KCk7XG4gIHRoaXMuX3RyYXZlcnNlTWVya2xlVHJlZShoZWlnaHQsIDAsIHsgdHhzOiB0eHMgfSk7XG4gIHJldHVybiB0eHMuaW5kZXhPZihoYXNoKSAhPT0gLTE7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSAtIE1lcmtsZUJsb2NrIGRhdGFcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQW4gT2JqZWN0IHJlcHJlc2VudGluZyBtZXJrbGVibG9jayBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5NZXJrbGVCbG9jay5fZnJvbUJ1ZmZlclJlYWRlciA9IGZ1bmN0aW9uIF9mcm9tQnVmZmVyUmVhZGVyKGJyKSB7XG4gICQuY2hlY2tTdGF0ZSghYnIuZmluaXNoZWQoKSwgJ05vIG1lcmtsZWJsb2NrIGRhdGEgcmVjZWl2ZWQnKTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5oZWFkZXIgPSBCbG9ja0hlYWRlci5mcm9tQnVmZmVyUmVhZGVyKGJyKTtcbiAgaW5mby5udW1UcmFuc2FjdGlvbnMgPSBici5yZWFkVUludDMyTEUoKTtcbiAgdmFyIG51bUhhc2hlcyA9IGJyLnJlYWRWYXJpbnROdW0oKTtcbiAgaW5mby5oYXNoZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1IYXNoZXM7IGkrKykge1xuICAgIGluZm8uaGFzaGVzLnB1c2goYnIucmVhZCgzMikudG9TdHJpbmcoJ2hleCcpKTtcbiAgfVxuICB2YXIgbnVtRmxhZ3MgPSBici5yZWFkVmFyaW50TnVtKCk7XG4gIGluZm8uZmxhZ3MgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IG51bUZsYWdzOyBpKyspIHtcbiAgICBpbmZvLmZsYWdzLnB1c2goYnIucmVhZFVJbnQ4KCkpO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gLSBBIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0XG4gKiBAcmV0dXJucyB7QmxvY2t9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2tcbiAqL1xuTWVya2xlQmxvY2suZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7XG4gIHJldHVybiBuZXcgTWVya2xlQmxvY2sob2JqKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVya2xlQmxvY2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/block/merkleblock.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js":
/*!***************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/bn.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bitcore-lib/node_modules/bn.js/lib/bn.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nvar reversebuf = function(buf) {\n  var buf2 = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function(n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function(str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function(buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function(buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\n\n\nBN.prototype.toNumber = function() {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function(opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function() {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n  return buf;\n};\n\nBN.prototype.toSM = function(opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function() {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.trim = function(buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function(buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\n\nmodule.exports = BN;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9ibi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsNEVBQU87QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHlGQUF1QjtBQUN2QyxRQUFRLG1CQUFPLENBQUMscURBQVE7O0FBRXhCO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9jcnlwdG8vYm4uanM/NjMzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIHJldmVyc2VidWYgPSBmdW5jdGlvbihidWYpIHtcbiAgdmFyIGJ1ZjIgPSBCdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmMltpXSA9IGJ1ZltidWYubGVuZ3RoIC0gMSAtIGldO1xuICB9XG4gIHJldHVybiBidWYyO1xufTtcblxuQk4uWmVybyA9IG5ldyBCTigwKTtcbkJOLk9uZSA9IG5ldyBCTigxKTtcbkJOLk1pbnVzMSA9IG5ldyBCTigtMSk7XG5cbkJOLmZyb21OdW1iZXIgPSBmdW5jdGlvbihuKSB7XG4gICQuY2hlY2tBcmd1bWVudChfLmlzTnVtYmVyKG4pKTtcbiAgcmV0dXJuIG5ldyBCTihuKTtcbn07XG5cbkJOLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIsIGJhc2UpIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcoc3RyKSk7XG4gIHJldHVybiBuZXcgQk4oc3RyLCBiYXNlKTtcbn07XG5cbkJOLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWYsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmVuZGlhbiA9PT0gJ2xpdHRsZScpIHtcbiAgICBidWYgPSByZXZlcnNlYnVmKGJ1Zik7XG4gIH1cbiAgdmFyIGhleCA9IGJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gIHZhciBibiA9IG5ldyBCTihoZXgsIDE2KTtcbiAgcmV0dXJuIGJuO1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIEJpZ051bWJlciBmcm9tIGEgXCJzaWduZWQgbWFnbml0dWRlIGJ1ZmZlclwiXG4gKiAoYSBidWZmZXIgd2hlcmUgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IHJlcHJlc2VudHMgdGhlIHNpZ24gKDAgPSBwb3NpdGl2ZSwgLTEgPSBuZWdhdGl2ZSkpXG4gKi9cbkJOLmZyb21TTSA9IGZ1bmN0aW9uKGJ1Ziwgb3B0cykge1xuICB2YXIgcmV0O1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCTi5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKFswXSkpO1xuICB9XG5cbiAgdmFyIGVuZGlhbiA9ICdiaWcnO1xuICBpZiAob3B0cykge1xuICAgIGVuZGlhbiA9IG9wdHMuZW5kaWFuO1xuICB9XG4gIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKSB7XG4gICAgYnVmID0gcmV2ZXJzZWJ1ZihidWYpO1xuICB9XG5cbiAgaWYgKGJ1ZlswXSAmIDB4ODApIHtcbiAgICBidWZbMF0gPSBidWZbMF0gJiAweDdmO1xuICAgIHJldCA9IEJOLmZyb21CdWZmZXIoYnVmKTtcbiAgICByZXQubmVnKCkuY29weShyZXQpO1xuICB9IGVsc2Uge1xuICAgIHJldCA9IEJOLmZyb21CdWZmZXIoYnVmKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5CTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoMTApLCAxMCk7XG59O1xuXG5CTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciBidWYsIGhleDtcbiAgaWYgKG9wdHMgJiYgb3B0cy5zaXplKSB7XG4gICAgaGV4ID0gdGhpcy50b1N0cmluZygxNiwgMik7XG4gICAgdmFyIG5hdGxlbiA9IGhleC5sZW5ndGggLyAyO1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xuXG4gICAgaWYgKG5hdGxlbiA9PT0gb3B0cy5zaXplKSB7XG4gICAgICBidWYgPSBidWY7XG4gICAgfSBlbHNlIGlmIChuYXRsZW4gPiBvcHRzLnNpemUpIHtcbiAgICAgIGJ1ZiA9IEJOLnRyaW0oYnVmLCBuYXRsZW4pO1xuICAgIH0gZWxzZSBpZiAobmF0bGVuIDwgb3B0cy5zaXplKSB7XG4gICAgICBidWYgPSBCTi5wYWQoYnVmLCBuYXRsZW4sIG9wdHMuc2l6ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhleCA9IHRoaXMudG9TdHJpbmcoMTYsIDIpO1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmVuZGlhbiA9PT0gJ2xpdHRsZScpIHtcbiAgICBidWYgPSByZXZlcnNlYnVmKGJ1Zik7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuQk4ucHJvdG90eXBlLnRvU01CaWdFbmRpYW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZjtcbiAgaWYgKHRoaXMuY21wKEJOLlplcm8pID09PSAtMSkge1xuICAgIGJ1ZiA9IHRoaXMubmVnKCkudG9CdWZmZXIoKTtcbiAgICBpZiAoYnVmWzBdICYgMHg4MCkge1xuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzB4ODBdKSwgYnVmXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZlswXSA9IGJ1ZlswXSB8IDB4ODA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICBpZiAoYnVmWzBdICYgMHg4MCkge1xuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzB4MDBdKSwgYnVmXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDEgJiBidWZbMF0gPT09IDApIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShbXSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbkJOLnByb3RvdHlwZS50b1NNID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgZW5kaWFuID0gb3B0cyA/IG9wdHMuZW5kaWFuIDogJ2JpZyc7XG4gIHZhciBidWYgPSB0aGlzLnRvU01CaWdFbmRpYW4oKTtcblxuICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJykge1xuICAgIGJ1ZiA9IHJldmVyc2VidWYoYnVmKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBCTiBmcm9tIGEgXCJTY3JpcHROdW1cIjpcbiAqIFRoaXMgaXMgYW5hbG9nb3VzIHRvIHRoZSBjb25zdHJ1Y3RvciBmb3IgQ1NjcmlwdE51bSBpbiBiaXRjb2luZC4gTWFueSBvcHMgaW5cbiAqIGJpdGNvaW5kJ3Mgc2NyaXB0IGludGVycHJldGVyIHVzZSBDU2NyaXB0TnVtLCB3aGljaCBpcyBub3QgcmVhbGx5IGEgcHJvcGVyXG4gKiBiaWdudW0uIEluc3RlYWQsIGFuIGVycm9yIGlzIHRocm93biBpZiB0cnlpbmcgdG8gaW5wdXQgYSBudW1iZXIgYmlnZ2VyIHRoYW5cbiAqIDQgYnl0ZXMuIFdlIGNvcHkgdGhhdCBiZWhhdmlvciBoZXJlLiBBIHRoaXJkIGFyZ3VtZW50LCBgc2l6ZWAsIGlzIHByb3ZpZGVkIHRvXG4gKiBleHRlbmQgdGhlIGhhcmQgbGltaXQgb2YgNCBieXRlcywgYXMgc29tZSB1c2FnZXMgcmVxdWlyZSBtb3JlIHRoYW4gNCBieXRlcy5cbiAqL1xuQk4uZnJvbVNjcmlwdE51bUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZiwgZlJlcXVpcmVNaW5pbWFsLCBzaXplKSB7XG4gIHZhciBuTWF4TnVtU2l6ZSA9IHNpemUgfHwgNDtcbiAgJC5jaGVja0FyZ3VtZW50KGJ1Zi5sZW5ndGggPD0gbk1heE51bVNpemUsIG5ldyBFcnJvcignc2NyaXB0IG51bWJlciBvdmVyZmxvdycpKTtcbiAgaWYgKGZSZXF1aXJlTWluaW1hbCAmJiBidWYubGVuZ3RoID4gMCkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIG51bWJlciBpcyBlbmNvZGVkIHdpdGggdGhlIG1pbmltdW0gcG9zc2libGVcbiAgICAvLyBudW1iZXIgb2YgYnl0ZXMuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgbW9zdC1zaWduaWZpY2FudC1ieXRlIC0gZXhjbHVkaW5nIHRoZSBzaWduIGJpdCAtIGlzIHplcm9cbiAgICAvLyB0aGVuIHdlJ3JlIG5vdCBtaW5pbWFsLiBOb3RlIGhvdyB0aGlzIHRlc3QgYWxzbyByZWplY3RzIHRoZVxuICAgIC8vIG5lZ2F0aXZlLXplcm8gZW5jb2RpbmcsIDB4ODAuXG4gICAgaWYgKChidWZbYnVmLmxlbmd0aCAtIDFdICYgMHg3ZikgPT09IDApIHtcbiAgICAgIC8vIE9uZSBleGNlcHRpb246IGlmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSBieXRlIGFuZCB0aGUgbW9zdFxuICAgICAgLy8gc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBzZWNvbmQtbW9zdC1zaWduaWZpY2FudC1ieXRlIGlzIHNldFxuICAgICAgLy8gaXQgd291bGQgY29uZmxpY3Qgd2l0aCB0aGUgc2lnbiBiaXQuIEFuIGV4YW1wbGUgb2YgdGhpcyBjYXNlXG4gICAgICAvLyBpcyArLTI1NSwgd2hpY2ggZW5jb2RlIHRvIDB4ZmYwMCBhbmQgMHhmZjgwIHJlc3BlY3RpdmVseS5cbiAgICAgIC8vIChiaWctZW5kaWFuKS5cbiAgICAgIGlmIChidWYubGVuZ3RoIDw9IDEgfHwgKGJ1ZltidWYubGVuZ3RoIC0gMl0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbi1taW5pbWFsbHkgZW5jb2RlZCBzY3JpcHQgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBCTi5mcm9tU00oYnVmLCB7XG4gICAgZW5kaWFuOiAnbGl0dGxlJ1xuICB9KTtcbn07XG5cbi8qKlxuICogVGhlIGNvcm9sbGFyeSB0byB0aGUgYWJvdmUsIHdpdGggdGhlIG5vdGFibGUgZXhjZXB0aW9uIHRoYXQgd2UgZG8gbm90IHRocm93XG4gKiBhbiBlcnJvciBpZiB0aGUgb3V0cHV0IGlzIGxhcmdlciB0aGFuIGZvdXIgYnl0ZXMuIChXaGljaCBjYW4gaGFwcGVuIGlmXG4gKiBwZXJmb3JtaW5nIGEgbnVtZXJpY2FsIG9wZXJhdGlvbiB0aGF0IHJlc3VsdHMgaW4gYW4gb3ZlcmZsb3cgdG8gbW9yZSB0aGFuIDRcbiAqIGJ5dGVzKS5cbiAqL1xuQk4ucHJvdG90eXBlLnRvU2NyaXB0TnVtQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvU00oe1xuICAgIGVuZGlhbjogJ2xpdHRsZSdcbiAgfSk7XG59O1xuXG5CTi50cmltID0gZnVuY3Rpb24oYnVmLCBuYXRsZW4pIHtcbiAgcmV0dXJuIGJ1Zi5zbGljZShuYXRsZW4gLSBidWYubGVuZ3RoLCBidWYubGVuZ3RoKTtcbn07XG5cbkJOLnBhZCA9IGZ1bmN0aW9uKGJ1ZiwgbmF0bGVuLCBzaXplKSB7XG4gIHZhciByYnVmID0gQnVmZmVyLmFsbG9jKHNpemUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgIHJidWZbcmJ1Zi5sZW5ndGggLSAxIC0gaV0gPSBidWZbYnVmLmxlbmd0aCAtIDEgLSBpXTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgc2l6ZSAtIG5hdGxlbjsgaSsrKSB7XG4gICAgcmJ1ZltpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHJidWY7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJOO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/ecdsa.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! ./bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar Point = __webpack_require__(/*! ./point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar PublicKey = __webpack_require__(/*! ../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar Random = __webpack_require__(/*! ./random */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\");\nvar Hash = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar ECDSA = function ECDSA(obj) {\n  if (!(this instanceof ECDSA)) {\n    return new ECDSA(obj);\n  }\n  if (obj) {\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 9 */\nECDSA.prototype.set = function(obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; //the endianness of hashbuf\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.k = obj.k || this.k;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\n\nECDSA.prototype.privkey2pubkey = function() {\n  this.pubkey = this.privkey.toPublicKey();\n};\n\nECDSA.prototype.calci = function() {\n  for (var i = 0; i < 4; i++) {\n    this.sig.i = i;\n    var Qprime;\n    try {\n      Qprime = this.toPublicKey();\n    } catch (e) {\n      console.error(e);\n      continue;\n    }\n\n    if (Qprime.point.eq(this.pubkey.point)) {\n      this.sig.compressed = this.pubkey.compressed;\n      return this;\n    }\n  }\n\n  this.sig.i = undefined;\n  throw new Error('Unable to find valid recovery factor');\n};\n\nECDSA.fromString = function(str) {\n  var obj = JSON.parse(str);\n  return new ECDSA(obj);\n};\n\nECDSA.prototype.randomK = function() {\n  var N = Point.getN();\n  var k;\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n  this.k = k;\n  return this;\n};\n\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nECDSA.prototype.deterministicK = function(badrs) {\n  /* jshint maxstatements: 25 */\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (_.isUndefined(badrs)) {\n    badrs = 0;\n  }\n  var v = Buffer.alloc(32);\n  v.fill(0x01);\n  var k = Buffer.alloc(32);\n  k.fill(0x00);\n  var x = this.privkey.bn.toBuffer({\n    size: 32\n  });\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN();\n\n  // also explained in 3.2, we must ensure T is in the proper range (0, N)\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\n    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n\n  this.k = T;\n  return this;\n};\n\n// Information about public key recovery:\n// https://bitcointalk.org/index.php?topic=6430.0\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\nECDSA.prototype.toPublicKey = function() {\n  /* jshint maxstatements: 25 */\n  var i = this.sig.i;\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\n\n  var e = BN.fromBuffer(this.hashbuf);\n  var r = this.sig.r;\n  var s = this.sig.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n\n  var n = Point.getN();\n  var G = Point.getG();\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.mul(n);\n\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  }\n\n  // Compute -e from e\n  var eNeg = e.neg().umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n  var rInv = r.invm(n);\n\n  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\n\n  return pubkey;\n};\n\nECDSA.prototype.sigError = function() {\n  /* jshint maxstatements: 25 */\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  var r = this.sig.r;\n  var s = this.sig.s;\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).umod(n);\n  var u2 = sinv.mul(r).umod(n);\n\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n\n  if (p.getX().umod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  } else {\n    return false;\n  }\n};\n\nECDSA.toLowS = function(s) {\n  //enforce low s\n  //see BIP 62, \"low S values in signatures\"\n  if (s.gt(BN.fromBuffer(Buffer.from('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {\n    s = Point.getN().sub(s);\n  }\n  return s;\n};\n\nECDSA.prototype._findSignature = function(d, e) {\n  var N = Point.getN();\n  var G = Point.getG();\n  // try different values of k until r, s are valid\n  var badrs = 0;\n  var k, Q, r, s;\n  do {\n    if (!this.k || badrs > 0) {\n      this.deterministicK(badrs);\n    }\n    badrs++;\n    k = this.k;\n    Q = G.mul(k);\n    r = Q.x.umod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n\n  s = ECDSA.toLowS(s);\n  return {\n    s: s,\n    r: r\n  };\n\n};\n\nECDSA.prototype.sign = function() {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\n\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n\n  var obj = this._findSignature(d, e);\n  obj.compressed = this.pubkey.compressed;\n\n  this.sig = new Signature(obj);\n  return this;\n};\n\nECDSA.prototype.signRandomK = function() {\n  this.randomK();\n  return this.sign();\n};\n\nECDSA.prototype.toString = function() {\n  var obj = {};\n  if (this.hashbuf) {\n    obj.hashbuf = this.hashbuf.toString('hex');\n  }\n  if (this.privkey) {\n    obj.privkey = this.privkey.toString();\n  }\n  if (this.pubkey) {\n    obj.pubkey = this.pubkey.toString();\n  }\n  if (this.sig) {\n    obj.sig = this.sig.toString();\n  }\n  if (this.k) {\n    obj.k = this.k.toString();\n  }\n  return JSON.stringify(obj);\n};\n\nECDSA.prototype.verify = function() {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n  return this;\n};\n\nECDSA.sign = function(hashbuf, privkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    privkey: privkey\n  }).sign().sig;\n};\n\nECDSA.verify = function(hashbuf, sig, pubkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    sig: sig,\n    pubkey: pubkey\n  }).verify().verified;\n};\n\nmodule.exports = ECDSA;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9lY2RzYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsK0RBQU07QUFDdkIsWUFBWSxtQkFBTyxDQUFDLHFFQUFTO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLHVFQUFjO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyx1RUFBVTtBQUMvQixXQUFXLG1CQUFPLENBQUMsbUVBQVE7QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3pDLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMseUZBQXVCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDBDQUEwQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9lY2RzYS5qcz81NTIyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnLi9ibicpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgUHVibGljS2V5ID0gcmVxdWlyZSgnLi4vcHVibGlja2V5Jyk7XG52YXIgUmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcblxudmFyIEVDRFNBID0gZnVuY3Rpb24gRUNEU0Eob2JqKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQ0RTQSkpIHtcbiAgICByZXR1cm4gbmV3IEVDRFNBKG9iaik7XG4gIH1cbiAgaWYgKG9iaikge1xuICAgIHRoaXMuc2V0KG9iaik7XG4gIH1cbn07XG5cbi8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA5ICovXG5FQ0RTQS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHRoaXMuaGFzaGJ1ZiA9IG9iai5oYXNoYnVmIHx8IHRoaXMuaGFzaGJ1ZjtcbiAgdGhpcy5lbmRpYW4gPSBvYmouZW5kaWFuIHx8IHRoaXMuZW5kaWFuOyAvL3RoZSBlbmRpYW5uZXNzIG9mIGhhc2hidWZcbiAgdGhpcy5wcml2a2V5ID0gb2JqLnByaXZrZXkgfHwgdGhpcy5wcml2a2V5O1xuICB0aGlzLnB1YmtleSA9IG9iai5wdWJrZXkgfHwgKHRoaXMucHJpdmtleSA/IHRoaXMucHJpdmtleS5wdWJsaWNLZXkgOiB0aGlzLnB1YmtleSk7XG4gIHRoaXMuc2lnID0gb2JqLnNpZyB8fCB0aGlzLnNpZztcbiAgdGhpcy5rID0gb2JqLmsgfHwgdGhpcy5rO1xuICB0aGlzLnZlcmlmaWVkID0gb2JqLnZlcmlmaWVkIHx8IHRoaXMudmVyaWZpZWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRUNEU0EucHJvdG90eXBlLnByaXZrZXkycHVia2V5ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucHVia2V5ID0gdGhpcy5wcml2a2V5LnRvUHVibGljS2V5KCk7XG59O1xuXG5FQ0RTQS5wcm90b3R5cGUuY2FsY2kgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB0aGlzLnNpZy5pID0gaTtcbiAgICB2YXIgUXByaW1lO1xuICAgIHRyeSB7XG4gICAgICBRcHJpbWUgPSB0aGlzLnRvUHVibGljS2V5KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChRcHJpbWUucG9pbnQuZXEodGhpcy5wdWJrZXkucG9pbnQpKSB7XG4gICAgICB0aGlzLnNpZy5jb21wcmVzc2VkID0gdGhpcy5wdWJrZXkuY29tcHJlc3NlZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2lnLmkgPSB1bmRlZmluZWQ7XG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59O1xuXG5FQ0RTQS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBvYmogPSBKU09OLnBhcnNlKHN0cik7XG4gIHJldHVybiBuZXcgRUNEU0Eob2JqKTtcbn07XG5cbkVDRFNBLnByb3RvdHlwZS5yYW5kb21LID0gZnVuY3Rpb24oKSB7XG4gIHZhciBOID0gUG9pbnQuZ2V0TigpO1xuICB2YXIgaztcbiAgZG8ge1xuICAgIGsgPSBCTi5mcm9tQnVmZmVyKFJhbmRvbS5nZXRSYW5kb21CdWZmZXIoMzIpKTtcbiAgfSB3aGlsZSAoIShrLmx0KE4pICYmIGsuZ3QoQk4uWmVybykpKTtcbiAgdGhpcy5rID0gaztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTc5I3NlY3Rpb24tMy4yXG5FQ0RTQS5wcm90b3R5cGUuZGV0ZXJtaW5pc3RpY0sgPSBmdW5jdGlvbihiYWRycykge1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjUgKi9cbiAgLy8gaWYgciBvciBzIHdlcmUgaW52YWxpZCB3aGVuIHRoaXMgZnVuY3Rpb24gd2FzIHVzZWQgaW4gc2lnbmluZyxcbiAgLy8gd2UgZG8gbm90IHdhbnQgdG8gYWN0dWFsbHkgY29tcHV0ZSByLCBzIGhlcmUgZm9yIGVmZmljaWVuY3ksIHNvLFxuICAvLyB3ZSBjYW4gaW5jcmVtZW50IGJhZHJzLiBleHBsYWluZWQgYXQgZW5kIG9mIFJGQyA2OTc5IHNlY3Rpb24gMy4yXG4gIGlmIChfLmlzVW5kZWZpbmVkKGJhZHJzKSkge1xuICAgIGJhZHJzID0gMDtcbiAgfVxuICB2YXIgdiA9IEJ1ZmZlci5hbGxvYygzMik7XG4gIHYuZmlsbCgweDAxKTtcbiAgdmFyIGsgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICBrLmZpbGwoMHgwMCk7XG4gIHZhciB4ID0gdGhpcy5wcml2a2V5LmJuLnRvQnVmZmVyKHtcbiAgICBzaXplOiAzMlxuICB9KTtcbiAgdmFyIGhhc2hidWYgPSB0aGlzLmVuZGlhbiA9PT0gJ2xpdHRsZScgPyBCdWZmZXJVdGlsLnJldmVyc2UodGhpcy5oYXNoYnVmKSA6IHRoaXMuaGFzaGJ1ZlxuICBrID0gSGFzaC5zaGEyNTZobWFjKEJ1ZmZlci5jb25jYXQoW3YsIEJ1ZmZlci5mcm9tKFsweDAwXSksIHgsIGhhc2hidWZdKSwgayk7XG4gIHYgPSBIYXNoLnNoYTI1NmhtYWModiwgayk7XG4gIGsgPSBIYXNoLnNoYTI1NmhtYWMoQnVmZmVyLmNvbmNhdChbdiwgQnVmZmVyLmZyb20oWzB4MDFdKSwgeCwgaGFzaGJ1Zl0pLCBrKTtcbiAgdiA9IEhhc2guc2hhMjU2aG1hYyh2LCBrKTtcbiAgdiA9IEhhc2guc2hhMjU2aG1hYyh2LCBrKTtcbiAgdmFyIFQgPSBCTi5mcm9tQnVmZmVyKHYpO1xuICB2YXIgTiA9IFBvaW50LmdldE4oKTtcblxuICAvLyBhbHNvIGV4cGxhaW5lZCBpbiAzLjIsIHdlIG11c3QgZW5zdXJlIFQgaXMgaW4gdGhlIHByb3BlciByYW5nZSAoMCwgTilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYWRycyB8fCAhKFQubHQoTikgJiYgVC5ndChCTi5aZXJvKSk7IGkrKykge1xuICAgIGsgPSBIYXNoLnNoYTI1NmhtYWMoQnVmZmVyLmNvbmNhdChbdiwgQnVmZmVyLmZyb20oWzB4MDBdKV0pLCBrKTtcbiAgICB2ID0gSGFzaC5zaGEyNTZobWFjKHYsIGspO1xuICAgIHYgPSBIYXNoLnNoYTI1NmhtYWModiwgayk7XG4gICAgVCA9IEJOLmZyb21CdWZmZXIodik7XG4gIH1cblxuICB0aGlzLmsgPSBUO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEluZm9ybWF0aW9uIGFib3V0IHB1YmxpYyBrZXkgcmVjb3Zlcnk6XG4vLyBodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9NjQzMC4wXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5NjY1NDkxL2hvdy1kby1pLWdldC1hbi1lY2RzYS1wdWJsaWMta2V5LWZyb20tanVzdC1hLWJpdGNvaW4tc2lnbmF0dXJlLXNlYzEtNC0xLTYta1xuRUNEU0EucHJvdG90eXBlLnRvUHVibGljS2V5ID0gZnVuY3Rpb24oKSB7XG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyNSAqL1xuICB2YXIgaSA9IHRoaXMuc2lnLmk7XG4gICQuY2hlY2tBcmd1bWVudChpID09PSAwIHx8IGkgPT09IDEgfHwgaSA9PT0gMiB8fCBpID09PSAzLCBuZXcgRXJyb3IoJ2kgbXVzdCBiZSBlcXVhbCB0byAwLCAxLCAyLCBvciAzJykpO1xuXG4gIHZhciBlID0gQk4uZnJvbUJ1ZmZlcih0aGlzLmhhc2hidWYpO1xuICB2YXIgciA9IHRoaXMuc2lnLnI7XG4gIHZhciBzID0gdGhpcy5zaWcucztcblxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcbiAgdmFyIGlzWU9kZCA9IGkgJiAxO1xuXG4gIC8vIFRoZSBtb3JlIHNpZ25pZmljYW50IGJpdCBzcGVjaWZpZXMgd2hldGhlciB3ZSBzaG91bGQgdXNlIHRoZVxuICAvLyBmaXJzdCBvciBzZWNvbmQgY2FuZGlkYXRlIGtleS5cbiAgdmFyIGlzU2Vjb25kS2V5ID0gaSA+PiAxO1xuXG4gIHZhciBuID0gUG9pbnQuZ2V0TigpO1xuICB2YXIgRyA9IFBvaW50LmdldEcoKTtcblxuICAvLyAxLjEgTGV0IHggPSByICsgam5cbiAgdmFyIHggPSBpc1NlY29uZEtleSA/IHIuYWRkKG4pIDogcjtcbiAgdmFyIFIgPSBQb2ludC5mcm9tWChpc1lPZGQsIHgpO1xuXG4gIC8vIDEuNCBDaGVjayB0aGF0IG5SIGlzIGF0IGluZmluaXR5XG4gIHZhciBuUiA9IFIubXVsKG4pO1xuXG4gIGlmICghblIuaXNJbmZpbml0eSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCduUiBpcyBub3QgYSB2YWxpZCBjdXJ2ZSBwb2ludCcpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSAtZSBmcm9tIGVcbiAgdmFyIGVOZWcgPSBlLm5lZygpLnVtb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSBlRylcbiAgLy8gUSA9IHJeLTEgKHNSICsgLWVHKVxuICB2YXIgckludiA9IHIuaW52bShuKTtcblxuICAvL3ZhciBRID0gUi5tdWx0aXBseVR3byhzLCBHLCBlTmVnKS5tdWwockludik7XG4gIHZhciBRID0gUi5tdWwocykuYWRkKEcubXVsKGVOZWcpKS5tdWwockludik7XG5cbiAgdmFyIHB1YmtleSA9IFB1YmxpY0tleS5mcm9tUG9pbnQoUSwgdGhpcy5zaWcuY29tcHJlc3NlZCk7XG5cbiAgcmV0dXJuIHB1YmtleTtcbn07XG5cbkVDRFNBLnByb3RvdHlwZS5zaWdFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjUgKi9cbiAgaWYgKCFCdWZmZXJVdGlsLmlzQnVmZmVyKHRoaXMuaGFzaGJ1ZikgfHwgdGhpcy5oYXNoYnVmLmxlbmd0aCAhPT0gMzIpIHtcbiAgICByZXR1cm4gJ2hhc2hidWYgbXVzdCBiZSBhIDMyIGJ5dGUgYnVmZmVyJztcbiAgfVxuXG4gIHZhciByID0gdGhpcy5zaWcucjtcbiAgdmFyIHMgPSB0aGlzLnNpZy5zO1xuICBpZiAoIShyLmd0KEJOLlplcm8pICYmIHIubHQoUG9pbnQuZ2V0TigpKSkgfHwgIShzLmd0KEJOLlplcm8pICYmIHMubHQoUG9pbnQuZ2V0TigpKSkpIHtcbiAgICByZXR1cm4gJ3IgYW5kIHMgbm90IGluIHJhbmdlJztcbiAgfVxuXG4gIHZhciBlID0gQk4uZnJvbUJ1ZmZlcih0aGlzLmhhc2hidWYsIHRoaXMuZW5kaWFuID8ge1xuICAgIGVuZGlhbjogdGhpcy5lbmRpYW5cbiAgfSA6IHVuZGVmaW5lZCk7XG4gIHZhciBuID0gUG9pbnQuZ2V0TigpO1xuICB2YXIgc2ludiA9IHMuaW52bShuKTtcbiAgdmFyIHUxID0gc2ludi5tdWwoZSkudW1vZChuKTtcbiAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZChuKTtcblxuICB2YXIgcCA9IFBvaW50LmdldEcoKS5tdWxBZGQodTEsIHRoaXMucHVia2V5LnBvaW50LCB1Mik7XG4gIGlmIChwLmlzSW5maW5pdHkoKSkge1xuICAgIHJldHVybiAncCBpcyBpbmZpbml0eSc7XG4gIH1cblxuICBpZiAocC5nZXRYKCkudW1vZChuKS5jbXAocikgIT09IDApIHtcbiAgICByZXR1cm4gJ0ludmFsaWQgc2lnbmF0dXJlJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbkVDRFNBLnRvTG93UyA9IGZ1bmN0aW9uKHMpIHtcbiAgLy9lbmZvcmNlIGxvdyBzXG4gIC8vc2VlIEJJUCA2MiwgXCJsb3cgUyB2YWx1ZXMgaW4gc2lnbmF0dXJlc1wiXG4gIGlmIChzLmd0KEJOLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oJzdGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGNUQ1NzZFNzM1N0E0NTAxRERGRTkyRjQ2NjgxQjIwQTAnLCAnaGV4JykpKSkge1xuICAgIHMgPSBQb2ludC5nZXROKCkuc3ViKHMpO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuRUNEU0EucHJvdG90eXBlLl9maW5kU2lnbmF0dXJlID0gZnVuY3Rpb24oZCwgZSkge1xuICB2YXIgTiA9IFBvaW50LmdldE4oKTtcbiAgdmFyIEcgPSBQb2ludC5nZXRHKCk7XG4gIC8vIHRyeSBkaWZmZXJlbnQgdmFsdWVzIG9mIGsgdW50aWwgciwgcyBhcmUgdmFsaWRcbiAgdmFyIGJhZHJzID0gMDtcbiAgdmFyIGssIFEsIHIsIHM7XG4gIGRvIHtcbiAgICBpZiAoIXRoaXMuayB8fCBiYWRycyA+IDApIHtcbiAgICAgIHRoaXMuZGV0ZXJtaW5pc3RpY0soYmFkcnMpO1xuICAgIH1cbiAgICBiYWRycysrO1xuICAgIGsgPSB0aGlzLms7XG4gICAgUSA9IEcubXVsKGspO1xuICAgIHIgPSBRLngudW1vZChOKTtcbiAgICBzID0gay5pbnZtKE4pLm11bChlLmFkZChkLm11bChyKSkpLnVtb2QoTik7XG4gIH0gd2hpbGUgKHIuY21wKEJOLlplcm8pIDw9IDAgfHwgcy5jbXAoQk4uWmVybykgPD0gMCk7XG5cbiAgcyA9IEVDRFNBLnRvTG93UyhzKTtcbiAgcmV0dXJuIHtcbiAgICBzOiBzLFxuICAgIHI6IHJcbiAgfTtcblxufTtcblxuRUNEU0EucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhhc2hidWYgPSB0aGlzLmhhc2hidWY7XG4gIHZhciBwcml2a2V5ID0gdGhpcy5wcml2a2V5O1xuICB2YXIgZCA9IHByaXZrZXkuYm47XG5cbiAgJC5jaGVja1N0YXRlKGhhc2hidWYgJiYgcHJpdmtleSAmJiBkLCBuZXcgRXJyb3IoJ2ludmFsaWQgcGFyYW1ldGVycycpKTtcbiAgJC5jaGVja1N0YXRlKEJ1ZmZlclV0aWwuaXNCdWZmZXIoaGFzaGJ1ZikgJiYgaGFzaGJ1Zi5sZW5ndGggPT09IDMyLCBuZXcgRXJyb3IoJ2hhc2hidWYgbXVzdCBiZSBhIDMyIGJ5dGUgYnVmZmVyJykpO1xuXG4gIHZhciBlID0gQk4uZnJvbUJ1ZmZlcihoYXNoYnVmLCB0aGlzLmVuZGlhbiA/IHtcbiAgICBlbmRpYW46IHRoaXMuZW5kaWFuXG4gIH0gOiB1bmRlZmluZWQpO1xuXG4gIHZhciBvYmogPSB0aGlzLl9maW5kU2lnbmF0dXJlKGQsIGUpO1xuICBvYmouY29tcHJlc3NlZCA9IHRoaXMucHVia2V5LmNvbXByZXNzZWQ7XG5cbiAgdGhpcy5zaWcgPSBuZXcgU2lnbmF0dXJlKG9iaik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRUNEU0EucHJvdG90eXBlLnNpZ25SYW5kb21LID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmFuZG9tSygpO1xuICByZXR1cm4gdGhpcy5zaWduKCk7XG59O1xuXG5FQ0RTQS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICBpZiAodGhpcy5oYXNoYnVmKSB7XG4gICAgb2JqLmhhc2hidWYgPSB0aGlzLmhhc2hidWYudG9TdHJpbmcoJ2hleCcpO1xuICB9XG4gIGlmICh0aGlzLnByaXZrZXkpIHtcbiAgICBvYmoucHJpdmtleSA9IHRoaXMucHJpdmtleS50b1N0cmluZygpO1xuICB9XG4gIGlmICh0aGlzLnB1YmtleSkge1xuICAgIG9iai5wdWJrZXkgPSB0aGlzLnB1YmtleS50b1N0cmluZygpO1xuICB9XG4gIGlmICh0aGlzLnNpZykge1xuICAgIG9iai5zaWcgPSB0aGlzLnNpZy50b1N0cmluZygpO1xuICB9XG4gIGlmICh0aGlzLmspIHtcbiAgICBvYmouayA9IHRoaXMuay50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xufTtcblxuRUNEU0EucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuc2lnRXJyb3IoKSkge1xuICAgIHRoaXMudmVyaWZpZWQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudmVyaWZpZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkVDRFNBLnNpZ24gPSBmdW5jdGlvbihoYXNoYnVmLCBwcml2a2V5LCBlbmRpYW4pIHtcbiAgcmV0dXJuIEVDRFNBKCkuc2V0KHtcbiAgICBoYXNoYnVmOiBoYXNoYnVmLFxuICAgIGVuZGlhbjogZW5kaWFuLFxuICAgIHByaXZrZXk6IHByaXZrZXlcbiAgfSkuc2lnbigpLnNpZztcbn07XG5cbkVDRFNBLnZlcmlmeSA9IGZ1bmN0aW9uKGhhc2hidWYsIHNpZywgcHVia2V5LCBlbmRpYW4pIHtcbiAgcmV0dXJuIEVDRFNBKCkuc2V0KHtcbiAgICBoYXNoYnVmOiBoYXNoYnVmLFxuICAgIGVuZGlhbjogZW5kaWFuLFxuICAgIHNpZzogc2lnLFxuICAgIHB1YmtleTogcHVia2V5XG4gIH0pLnZlcmlmeSgpLnZlcmlmaWVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFQ0RTQTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/hash.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar Hash = module.exports;\n\nHash.sha1 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha1').update(buf).digest();\n};\n\nHash.sha1.blocksize = 512;\n\nHash.sha256 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha256').update(buf).digest();\n};\n\nHash.sha256.blocksize = 512;\n\nHash.sha256sha256 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.sha256(Hash.sha256(buf));\n};\n\nHash.ripemd160 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('ripemd160').update(buf).digest();\n};\n\nHash.sha256ripemd160 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.ripemd160(Hash.sha256(buf));\n};\n\nHash.sha512 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha512').update(buf).digest();\n};\n\nHash.sha512.blocksize = 1024;\n\nHash.hmac = function(hashf, data, key) {\n  //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\n  //http://tools.ietf.org/html/rfc4868#section-2\n  $.checkArgument(BufferUtil.isBuffer(data));\n  $.checkArgument(BufferUtil.isBuffer(key));\n  $.checkArgument(hashf.blocksize);\n\n  var blocksize = hashf.blocksize / 8;\n\n  if (key.length > blocksize) {\n    key = hashf(key);\n  } else if (key < blocksize) {\n    var fill = Buffer.alloc(blocksize);\n    fill.fill(0);\n    key.copy(fill);\n    key = fill;\n  }\n\n  var o_key = Buffer.alloc(blocksize);\n  o_key.fill(0x5c);\n\n  var i_key = Buffer.alloc(blocksize);\n  i_key.fill(0x36);\n\n  var o_key_pad = Buffer.alloc(blocksize);\n  var i_key_pad = Buffer.alloc(blocksize);\n  for (var i = 0; i < blocksize; i++) {\n    o_key_pad[i] = o_key[i] ^ key[i];\n    i_key_pad[i] = i_key[i] ^ key[i];\n  }\n\n  return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));\n};\n\nHash.sha256hmac = function(data, key) {\n  return Hash.hmac(Hash.sha256, data, key);\n};\n\nHash.sha512hmac = function(data, key) {\n  return Hash.hmac(Hash.sha512, data, key);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9oYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsUUFBUSxtQkFBTyxDQUFDLHlGQUF1Qjs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL2hhc2guanM/MmJiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbnZhciBIYXNoID0gbW9kdWxlLmV4cG9ydHM7XG5cbkhhc2guc2hhMSA9IGZ1bmN0aW9uKGJ1Zikge1xuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihidWYpKTtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGJ1ZikuZGlnZXN0KCk7XG59O1xuXG5IYXNoLnNoYTEuYmxvY2tzaXplID0gNTEyO1xuXG5IYXNoLnNoYTI1NiA9IGZ1bmN0aW9uKGJ1Zikge1xuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihidWYpKTtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYnVmKS5kaWdlc3QoKTtcbn07XG5cbkhhc2guc2hhMjU2LmJsb2Nrc2l6ZSA9IDUxMjtcblxuSGFzaC5zaGEyNTZzaGEyNTYgPSBmdW5jdGlvbihidWYpIHtcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHJldHVybiBIYXNoLnNoYTI1NihIYXNoLnNoYTI1NihidWYpKTtcbn07XG5cbkhhc2gucmlwZW1kMTYwID0gZnVuY3Rpb24oYnVmKSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZikpO1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3JpcGVtZDE2MCcpLnVwZGF0ZShidWYpLmRpZ2VzdCgpO1xufTtcblxuSGFzaC5zaGEyNTZyaXBlbWQxNjAgPSBmdW5jdGlvbihidWYpIHtcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHJldHVybiBIYXNoLnJpcGVtZDE2MChIYXNoLnNoYTI1NihidWYpKTtcbn07XG5cbkhhc2guc2hhNTEyID0gZnVuY3Rpb24oYnVmKSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZikpO1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTUxMicpLnVwZGF0ZShidWYpLmRpZ2VzdCgpO1xufTtcblxuSGFzaC5zaGE1MTIuYmxvY2tzaXplID0gMTAyNDtcblxuSGFzaC5obWFjID0gZnVuY3Rpb24oaGFzaGYsIGRhdGEsIGtleSkge1xuICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFzaC1iYXNlZF9tZXNzYWdlX2F1dGhlbnRpY2F0aW9uX2NvZGVcbiAgLy9odHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0ODY4I3NlY3Rpb24tMlxuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihkYXRhKSk7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGtleSkpO1xuICAkLmNoZWNrQXJndW1lbnQoaGFzaGYuYmxvY2tzaXplKTtcblxuICB2YXIgYmxvY2tzaXplID0gaGFzaGYuYmxvY2tzaXplIC8gODtcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGhhc2hmKGtleSk7XG4gIH0gZWxzZSBpZiAoa2V5IDwgYmxvY2tzaXplKSB7XG4gICAgdmFyIGZpbGwgPSBCdWZmZXIuYWxsb2MoYmxvY2tzaXplKTtcbiAgICBmaWxsLmZpbGwoMCk7XG4gICAga2V5LmNvcHkoZmlsbCk7XG4gICAga2V5ID0gZmlsbDtcbiAgfVxuXG4gIHZhciBvX2tleSA9IEJ1ZmZlci5hbGxvYyhibG9ja3NpemUpO1xuICBvX2tleS5maWxsKDB4NWMpO1xuXG4gIHZhciBpX2tleSA9IEJ1ZmZlci5hbGxvYyhibG9ja3NpemUpO1xuICBpX2tleS5maWxsKDB4MzYpO1xuXG4gIHZhciBvX2tleV9wYWQgPSBCdWZmZXIuYWxsb2MoYmxvY2tzaXplKTtcbiAgdmFyIGlfa2V5X3BhZCA9IEJ1ZmZlci5hbGxvYyhibG9ja3NpemUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgb19rZXlfcGFkW2ldID0gb19rZXlbaV0gXiBrZXlbaV07XG4gICAgaV9rZXlfcGFkW2ldID0gaV9rZXlbaV0gXiBrZXlbaV07XG4gIH1cblxuICByZXR1cm4gaGFzaGYoQnVmZmVyLmNvbmNhdChbb19rZXlfcGFkLCBoYXNoZihCdWZmZXIuY29uY2F0KFtpX2tleV9wYWQsIGRhdGFdKSldKSk7XG59O1xuXG5IYXNoLnNoYTI1NmhtYWMgPSBmdW5jdGlvbihkYXRhLCBrZXkpIHtcbiAgcmV0dXJuIEhhc2guaG1hYyhIYXNoLnNoYTI1NiwgZGF0YSwga2V5KTtcbn07XG5cbkhhc2guc2hhNTEyaG1hYyA9IGZ1bmN0aW9uKGRhdGEsIGtleSkge1xuICByZXR1cm4gSGFzaC5obWFjKEhhc2guc2hhNTEyLCBkYXRhLCBrZXkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/point.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! ./bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\n\nvar EC = (__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\").ec);\nvar ec = new EC('secp256k1');\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\nvar Point = function Point(x, y, isRed) {\n  try {\n    var point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid Point');\n  }\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\nPoint.fromX = function fromX(odd, x){\n  try {\n    var point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid X');\n  }\n  point.validate();\n  return point;\n};\n\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n * (A.K.A curve order)\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\n/**\n * Secp256k1 field size\n * @returns {BN} A BN instance of the field size\n */\nPoint.getP = function() {\n  return ec.curve.p.clone();\n};\n\nPoint.prototype._getX = Point.prototype.getX;\n\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nPoint.prototype._getY = Point.prototype.getY;\n\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\nPoint.prototype.validate = function validate() {\n\n  if (this.isInfinity()){\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  var p2;\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n\n\n  //todo: needs test case\n  if (!(this.mul(Point.getN()).isInfinity())) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({size: 32});\n  var ybuf = point.getY().toBuffer({size: 32});\n\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n  return BufferUtil.concat([prefix, xbuf]);\n};\n\n\nPoint.prototype.liftX = function() {\n  const fieldSize = Point.getP();\n  const zero = new BN(0);\n  const one = new BN(1);\n  const two = new BN(2);\n  const three = new BN(3);\n  const four = new BN(4);\n  const seven = new BN(7);\n  const red = BN.red('k256');\n\n  const c = this.x.pow(three).add(seven).mod(fieldSize);\n  const y = c.toRed(red).redPow(fieldSize.add(one).div(four)).mod(fieldSize);\n  \n  if (!c.eq(y.pow(two).mod(fieldSize))) {\n    throw new Error('liftX failed');\n  }\n  \n  const pointX = this.x.red ? this.x.fromRed() : this.x;\n  const pointY = y.mod(two).eq(zero) ? y.fromRed() : fieldSize.sub(y)\n  return new Point(pointX, pointY, true);\n};\n\nmodule.exports = Point;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9wb2ludC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsK0RBQU07QUFDdkIsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWdCOztBQUV6QyxTQUFTLHlGQUFzQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFdBQVc7QUFDdEIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0Msb0NBQW9DLFNBQVM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9jcnlwdG8vcG9pbnQuanM/ZmU1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJy4vYm4nKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcblxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lYztcbnZhciBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJyk7XG52YXIgZWNQb2ludCA9IGVjLmN1cnZlLnBvaW50LmJpbmQoZWMuY3VydmUpO1xudmFyIGVjUG9pbnRGcm9tWCA9IGVjLmN1cnZlLnBvaW50RnJvbVguYmluZChlYy5jdXJ2ZSk7XG5cbi8qKlxuICpcbiAqIEluc3RhbnRpYXRlIGEgdmFsaWQgc2VjcDI1NmsxIFBvaW50IGZyb20gdGhlIFggYW5kIFkgY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtCTnxTdHJpbmd9IHggLSBUaGUgWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge0JOfFN0cmluZ30geSAtIFRoZSBZIGNvb3JkaW5hdGVcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljXG4gKiBAYXVnbWVudHMgZWxsaXB0aWMuY3VydmUucG9pbnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBBIHZhbGlkYXRpb24gZXJyb3IgaWYgZXhpc3RzXG4gKiBAcmV0dXJucyB7UG9pbnR9IEFuIGluc3RhbmNlIG9mIFBvaW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFBvaW50ID0gZnVuY3Rpb24gUG9pbnQoeCwgeSwgaXNSZWQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcG9pbnQgPSBlY1BvaW50KHgsIHksIGlzUmVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQb2ludCcpO1xuICB9XG4gIHBvaW50LnZhbGlkYXRlKCk7XG4gIHJldHVybiBwb2ludDtcbn07XG5cblBvaW50LnByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihlYy5jdXJ2ZS5wb2ludCgpKTtcblxuLyoqXG4gKlxuICogSW5zdGFudGlhdGUgYSB2YWxpZCBzZWNwMjU2azEgUG9pbnQgZnJvbSBvbmx5IHRoZSBYIGNvb3JkaW5hdGVcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9kZCAtIElmIHRoZSBZIGNvb3JkaW5hdGUgaXMgb2RkXG4gKiBAcGFyYW0ge0JOfFN0cmluZ30geCAtIFRoZSBYIGNvb3JkaW5hdGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBBIHZhbGlkYXRpb24gZXJyb3IgaWYgZXhpc3RzXG4gKiBAcmV0dXJucyB7UG9pbnR9IEFuIGluc3RhbmNlIG9mIFBvaW50XG4gKi9cblBvaW50LmZyb21YID0gZnVuY3Rpb24gZnJvbVgob2RkLCB4KXtcbiAgdHJ5IHtcbiAgICB2YXIgcG9pbnQgPSBlY1BvaW50RnJvbVgoeCwgb2RkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBYJyk7XG4gIH1cbiAgcG9pbnQudmFsaWRhdGUoKTtcbiAgcmV0dXJuIHBvaW50O1xufTtcblxuLyoqXG4gKlxuICogV2lsbCByZXR1cm4gYSBzZWNwMjU2azEgRUNEU0EgYmFzZSBwb2ludC5cbiAqXG4gKiBAbGluayBodHRwczovL2VuLmJpdGNvaW4uaXQvd2lraS9TZWNwMjU2azFcbiAqIEByZXR1cm5zIHtQb2ludH0gQW4gaW5zdGFuY2Ugb2YgdGhlIGJhc2UgcG9pbnQuXG4gKi9cblBvaW50LmdldEcgPSBmdW5jdGlvbiBnZXRHKCkge1xuICByZXR1cm4gZWMuY3VydmUuZztcbn07XG5cbi8qKlxuICpcbiAqIFdpbGwgcmV0dXJuIHRoZSBtYXggb2YgcmFuZ2Ugb2YgdmFsaWQgcHJpdmF0ZSBrZXlzIGFzIGdvdmVybmVkIGJ5IHRoZSBzZWNwMjU2azEgRUNEU0Egc3RhbmRhcmQuXG4gKiAoQS5LLkEgY3VydmUgb3JkZXIpXG4gKiBAbGluayBodHRwczovL2VuLmJpdGNvaW4uaXQvd2lraS9Qcml2YXRlX2tleSNSYW5nZV9vZl92YWxpZF9FQ0RTQV9wcml2YXRlX2tleXNcbiAqIEByZXR1cm5zIHtCTn0gQSBCTiBpbnN0YW5jZSBvZiB0aGUgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVcbiAqL1xuUG9pbnQuZ2V0TiA9IGZ1bmN0aW9uIGdldE4oKSB7XG4gIHJldHVybiBuZXcgQk4oZWMuY3VydmUubi50b0FycmF5KCkpO1xufTtcblxuLyoqXG4gKiBTZWNwMjU2azEgZmllbGQgc2l6ZVxuICogQHJldHVybnMge0JOfSBBIEJOIGluc3RhbmNlIG9mIHRoZSBmaWVsZCBzaXplXG4gKi9cblBvaW50LmdldFAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGVjLmN1cnZlLnAuY2xvbmUoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0WCA9IFBvaW50LnByb3RvdHlwZS5nZXRYO1xuXG4vKipcbiAqXG4gKiBXaWxsIHJldHVybiB0aGUgWCBjb29yZGluYXRlIG9mIHRoZSBQb2ludFxuICpcbiAqIEByZXR1cm5zIHtCTn0gQSBCTiBpbnN0YW5jZSBvZiB0aGUgWCBjb29yZGluYXRlXG4gKi9cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIG5ldyBCTih0aGlzLl9nZXRYKCkudG9BcnJheSgpKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0WSA9IFBvaW50LnByb3RvdHlwZS5nZXRZO1xuXG4vKipcbiAqXG4gKiBXaWxsIHJldHVybiB0aGUgWSBjb29yZGluYXRlIG9mIHRoZSBQb2ludFxuICpcbiAqIEByZXR1cm5zIHtCTn0gQSBCTiBpbnN0YW5jZSBvZiB0aGUgWSBjb29yZGluYXRlXG4gKi9cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgcmV0dXJuIG5ldyBCTih0aGlzLl9nZXRZKCkudG9BcnJheSgpKTtcbn07XG5cbi8qKlxuICpcbiAqIFdpbGwgZGV0ZXJtaW5lIGlmIHRoZSBwb2ludCBpcyB2YWxpZFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vd3d3LmlhY3Iub3JnL2FyY2hpdmUvcGtjMjAwMy8yNTY3MDIxMS8yNTY3MDIxMS5wZGZcbiAqIEBwYXJhbSB7UG9pbnR9IEFuIGluc3RhbmNlIG9mIFBvaW50XG4gKiBAdGhyb3dzIHtFcnJvcn0gQSB2YWxpZGF0aW9uIGVycm9yIGlmIGV4aXN0c1xuICogQHJldHVybnMge1BvaW50fSBBbiBpbnN0YW5jZSBvZiB0aGUgc2FtZSBQb2ludFxuICovXG5Qb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcblxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpe1xuICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgY2Fubm90IGJlIGVxdWFsIHRvIEluZmluaXR5Jyk7XG4gIH1cblxuICB2YXIgcDI7XG4gIHRyeSB7XG4gICAgcDIgPSBlY1BvaW50RnJvbVgodGhpcy5nZXRYKCksIHRoaXMuZ2V0WSgpLmlzT2RkKCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBkb2VzIG5vdCBsaWUgb24gdGhlIGN1cnZlJyk7XG4gIH1cblxuICBpZiAocDIueS5jbXAodGhpcy55KSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB5IHZhbHVlIGZvciBjdXJ2ZS4nKTtcbiAgfVxuXG5cbiAgLy90b2RvOiBuZWVkcyB0ZXN0IGNhc2VcbiAgaWYgKCEodGhpcy5tdWwoUG9pbnQuZ2V0TigpKS5pc0luZmluaXR5KCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCB0aW1lcyBOIG11c3QgYmUgaW5maW5pdHknKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG5Qb2ludC5wb2ludFRvQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIHBvaW50VG9Db21wcmVzc2VkKHBvaW50KSB7XG4gIHZhciB4YnVmID0gcG9pbnQuZ2V0WCgpLnRvQnVmZmVyKHtzaXplOiAzMn0pO1xuICB2YXIgeWJ1ZiA9IHBvaW50LmdldFkoKS50b0J1ZmZlcih7c2l6ZTogMzJ9KTtcblxuICB2YXIgcHJlZml4O1xuICB2YXIgb2RkID0geWJ1Zlt5YnVmLmxlbmd0aCAtIDFdICUgMjtcbiAgaWYgKG9kZCkge1xuICAgIHByZWZpeCA9IEJ1ZmZlci5mcm9tKFsweDAzXSk7XG4gIH0gZWxzZSB7XG4gICAgcHJlZml4ID0gQnVmZmVyLmZyb20oWzB4MDJdKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyVXRpbC5jb25jYXQoW3ByZWZpeCwgeGJ1Zl0pO1xufTtcblxuXG5Qb2ludC5wcm90b3R5cGUubGlmdFggPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZmllbGRTaXplID0gUG9pbnQuZ2V0UCgpO1xuICBjb25zdCB6ZXJvID0gbmV3IEJOKDApO1xuICBjb25zdCBvbmUgPSBuZXcgQk4oMSk7XG4gIGNvbnN0IHR3byA9IG5ldyBCTigyKTtcbiAgY29uc3QgdGhyZWUgPSBuZXcgQk4oMyk7XG4gIGNvbnN0IGZvdXIgPSBuZXcgQk4oNCk7XG4gIGNvbnN0IHNldmVuID0gbmV3IEJOKDcpO1xuICBjb25zdCByZWQgPSBCTi5yZWQoJ2syNTYnKTtcblxuICBjb25zdCBjID0gdGhpcy54LnBvdyh0aHJlZSkuYWRkKHNldmVuKS5tb2QoZmllbGRTaXplKTtcbiAgY29uc3QgeSA9IGMudG9SZWQocmVkKS5yZWRQb3coZmllbGRTaXplLmFkZChvbmUpLmRpdihmb3VyKSkubW9kKGZpZWxkU2l6ZSk7XG4gIFxuICBpZiAoIWMuZXEoeS5wb3codHdvKS5tb2QoZmllbGRTaXplKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpZnRYIGZhaWxlZCcpO1xuICB9XG4gIFxuICBjb25zdCBwb2ludFggPSB0aGlzLngucmVkID8gdGhpcy54LmZyb21SZWQoKSA6IHRoaXMueDtcbiAgY29uc3QgcG9pbnRZID0geS5tb2QodHdvKS5lcSh6ZXJvKSA/IHkuZnJvbVJlZCgpIDogZmllbGRTaXplLnN1Yih5KVxuICByZXR1cm4gbmV3IFBvaW50KHBvaW50WCwgcG9pbnRZLCB0cnVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/random.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction Random() {\n}\n\n/* secure random bytes that sometimes throws an error due to lack of entropy */\nRandom.getRandomBuffer = function(size) {\n  if (false)\n    {}\n  else\n    return Random.getRandomBufferNode(size);\n};\n\nRandom.getRandomBufferNode = function(size) {\n  var crypto = __webpack_require__(/*! crypto */ \"crypto\");\n  return crypto.randomBytes(size);\n};\n\nRandom.getRandomBufferBrowser = function(size) {\n  if (!window.crypto && !window.msCrypto)\n    throw new Error('window.crypto not available');\n\n  if (window.crypto && window.crypto.getRandomValues)\n    var crypto = window.crypto;\n  else if (window.msCrypto && window.msCrypto.getRandomValues) //internet explorer\n    var crypto = window.msCrypto;\n  else\n    throw new Error('window.crypto.getRandomValues not available');\n\n  var bbuf = new Uint8Array(size);\n  crypto.getRandomValues(bbuf);\n  var buf = Buffer.from(bbuf);\n\n  return buf;\n};\n\n/* insecure random bytes, but it never fails */\nRandom.getPseudoRandomBuffer = function(size) {\n  var b32 = 0x100000000;\n  var b = Buffer.alloc(size);\n  var r;\n\n  for (var i = 0; i <= size; i++) {\n    var j = Math.floor(i / 4);\n    var k = i - j * 4;\n    if (k === 0) {\n      r = Math.random() * b32;\n      b[i] = r & 0xff;\n    } else {\n      b[i] = (r = r >>> 8) & 0xff;\n    }\n  }\n\n  return b;\n};\n\nmodule.exports = Random;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9yYW5kb20uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFlO0FBQ3JCLElBQUksRUFBMkM7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL3JhbmRvbS5qcz84Zjk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gUmFuZG9tKCkge1xufVxuXG4vKiBzZWN1cmUgcmFuZG9tIGJ5dGVzIHRoYXQgc29tZXRpbWVzIHRocm93cyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBlbnRyb3B5ICovXG5SYW5kb20uZ2V0UmFuZG9tQnVmZmVyID0gZnVuY3Rpb24oc2l6ZSkge1xuICBpZiAocHJvY2Vzcy5icm93c2VyKVxuICAgIHJldHVybiBSYW5kb20uZ2V0UmFuZG9tQnVmZmVyQnJvd3NlcihzaXplKTtcbiAgZWxzZVxuICAgIHJldHVybiBSYW5kb20uZ2V0UmFuZG9tQnVmZmVyTm9kZShzaXplKTtcbn07XG5cblJhbmRvbS5nZXRSYW5kb21CdWZmZXJOb2RlID0gZnVuY3Rpb24oc2l6ZSkge1xuICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoc2l6ZSk7XG59O1xuXG5SYW5kb20uZ2V0UmFuZG9tQnVmZmVyQnJvd3NlciA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKCF3aW5kb3cuY3J5cHRvICYmICF3aW5kb3cubXNDcnlwdG8pXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3aW5kb3cuY3J5cHRvIG5vdCBhdmFpbGFibGUnKTtcblxuICBpZiAod2luZG93LmNyeXB0byAmJiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcylcbiAgICB2YXIgY3J5cHRvID0gd2luZG93LmNyeXB0bztcbiAgZWxzZSBpZiAod2luZG93Lm1zQ3J5cHRvICYmIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIC8vaW50ZXJuZXQgZXhwbG9yZXJcbiAgICB2YXIgY3J5cHRvID0gd2luZG93Lm1zQ3J5cHRvO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBub3QgYXZhaWxhYmxlJyk7XG5cbiAgdmFyIGJidWYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhiYnVmKTtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJidWYpO1xuXG4gIHJldHVybiBidWY7XG59O1xuXG4vKiBpbnNlY3VyZSByYW5kb20gYnl0ZXMsIGJ1dCBpdCBuZXZlciBmYWlscyAqL1xuUmFuZG9tLmdldFBzZXVkb1JhbmRvbUJ1ZmZlciA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdmFyIGIzMiA9IDB4MTAwMDAwMDAwO1xuICB2YXIgYiA9IEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgdmFyIHI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2l6ZTsgaSsrKSB7XG4gICAgdmFyIGogPSBNYXRoLmZsb29yKGkgLyA0KTtcbiAgICB2YXIgayA9IGkgLSBqICogNDtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgciA9IE1hdGgucmFuZG9tKCkgKiBiMzI7XG4gICAgICBiW2ldID0gciAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJbaV0gPSAociA9IHIgPj4+IDgpICYgMHhmZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/schnorr.js":
/*!********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/schnorr.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst JS = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nconst BN = __webpack_require__(/*! ./bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nconst Point = __webpack_require__(/*! ./point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nconst TaggedHash = __webpack_require__(/*! ./taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\nconst Schnorr = function Schnorr() {\n  if (!(this instanceof Schnorr)) {\n    return new Schnorr();\n  }\n  return this;\n};\n\nSchnorr.prototype.set = function() {};\n\n/**\n * Create a schnorr signature\n * @param {PrivateKey|Buffer|BN} privateKey\n * @param {String|Buffer} message Hex string or buffer\n * @param {String|Buffer} aux Hex string or buffer\n * @returns {Buffer}\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Default_Signing\n */\nSchnorr.sign = function(privateKey, message, aux) {\n  privateKey = Buffer.isBuffer(privateKey) ? privateKey : privateKey.toBuffer();\n  if (privateKey.length !== 32) {\n    throw new Error('Private key should be 32 bytes for schnorr signatures');\n  }\n\n  if (typeof message === 'string') {\n    $.checkArgument(JS.isHexaString(message), 'Schnorr message string is not hex');\n    message = Buffer.from(message, 'hex')\n  }\n  $.checkArgument($.isType(message, 'Buffer'), 'Schnorr message must be a hex string or buffer');\n\n  if (!aux) {\n    aux = crypto.randomBytes(32);\n  }\n  if (typeof aux === 'string') {\n    $.checkArgument(JS.isHexaString(aux), 'Schnorr aux string is not hex');\n    aux = Buffer.from(aux, 'hex')\n  }\n  $.checkArgument($.isType(aux, 'Buffer'), 'Schnorr aux must be a hex string or buffer');\n\n  const G = Point.getG();\n  const n = Point.getN();\n\n  const dPrime = new BN(privateKey);\n  if (dPrime.eqn(0) || dPrime.gte(n)) {\n    throw new Error('Invalid private key for schnorr signing');\n  }\n  const P = G.mul(dPrime);\n  const Pbuf = Buffer.from(P.encodeCompressed().slice(1)); // slice(1) removes the encoding prefix byte\n  const d = P.y.isEven() ? dPrime : n.sub(dPrime);\n  const t = d.xor(new BN(new TaggedHash('BIP0340/aux', aux).finalize()));\n  const rand = new TaggedHash('BIP0340/nonce', Buffer.concat([t.toBuffer(), Pbuf, message])).finalize();\n  const kPrime = new BN(rand).mod(n);\n  if (kPrime.eqn(0)) {\n    throw new Error('Error creating schnorr signature');\n  }\n  const R = G.mul(kPrime);\n  const Rbuf = Buffer.from(R.encodeCompressed().slice(1)); // slice(1) removes the encoding prefix byte\n  const k = R.y.isEven() ? kPrime : n.sub(kPrime);\n  const e = new BN(new TaggedHash('BIP0340/challenge', Buffer.concat([Rbuf, Pbuf, message])).finalize()).mod(n);\n  const sig = Buffer.concat([Rbuf, k.add(e.mul(d)).mod(n).toBuffer()]);\n\n  if (!Schnorr.verify(Pbuf, message, sig)) {\n    throw new Error('Error creating schnorr signature. Verification failed');\n  }\n  return sig;\n};\n\n\n/**\n * Verify a schnorr signature\n * @param {PublicKey|Buffer} publicKey \n * @param {String|Buffer} message Hex string or buffer\n * @param {String|Signature|Buffer} signature Hex string, Signature instance, or buffer\n * @returns {Boolean}\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Verification\n */\nSchnorr.verify = function(publicKey, message, signature) {\n  if ($.isType(publicKey, 'PublicKey')) {\n    publicKey = publicKey.point.x.toBuffer();\n  }\n  if (publicKey.length !== 32) {\n    throw new Error('Public key should be 32 bytes for schnorr signatures');\n  }\n\n  if (typeof message === 'string') {\n    $.checkArgument(JS.isHexaString(message), 'Schnorr message string is not hex');\n    message = Buffer.from(message, 'hex');\n  }\n  if (message.length !== 32) {\n    throw new Error('Message should be a 32 byte buffer');\n  }\n\n  if (typeof signature === 'string') {\n    $.checkArgument(JS.isHexaString(signature), 'Schnorr signature string is not hex');\n    signature = Buffer.from(signature, 'hex');\n  }\n  if (typeof signature.toBuffer === 'function') {\n    signature = signature.toBuffer();\n    if (signature.length === 65) {\n      signature = signature.slice(0, 64); // remove the sighashType byte\n    }\n  }\n  if (signature.length !== 64) {\n    throw new Error('Signature should be a 64 byte buffer. Got ' + signature.length + ' bytes');\n  }\n\n  try {\n    const p = Point.getP();\n    const n = Point.getN();\n\n    const P = Point.fromX(false, publicKey).liftX();\n    const r = new BN(signature.slice(0, 32));\n    const s = new BN(signature.slice(32, 64));\n    if (r.gte(p) || s.gte(n)) {\n      return false;\n    }\n    const e = getE(r, P, message);\n    const G = Point.getG();\n    const R = G.mul(s).add(P.mul(e).neg());\n    if (R.inf || !R.y.isEven() || !R.x.eq(r)) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n/* Utility function used in Verify() */\nconst getE = function(r, P, message) {\n  const n = Point.getN();\n  const hash = new TaggedHash('BIP0340/challenge', Buffer.concat([r.toBuffer({ size: 32 }), P.x.toBuffer({ size: 32 }), message])).finalize();\n  return new BN(hash).mod(n);\n};\n\nmodule.exports = Schnorr;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9zY2hub3JyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixVQUFVLG1CQUFPLENBQUMseUZBQXVCO0FBQ3pDLFdBQVcsbUJBQU8sQ0FBQyxtRUFBWTtBQUMvQixXQUFXLG1CQUFPLENBQUMsK0RBQU07QUFDekIsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFjOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsZUFBZTtBQUMxQixXQUFXLHlCQUF5QjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsVUFBVSxrQkFBa0IsVUFBVTtBQUNySDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9zY2hub3JyLmpzPzg2MzIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5jb25zdCBKUyA9IHJlcXVpcmUoJy4uL3V0aWwvanMnKTtcbmNvbnN0IEJOID0gcmVxdWlyZSgnLi9ibicpO1xuY29uc3QgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50Jyk7XG5jb25zdCBUYWdnZWRIYXNoID0gcmVxdWlyZSgnLi90YWdnZWRoYXNoJyk7XG5cbmNvbnN0IFNjaG5vcnIgPSBmdW5jdGlvbiBTY2hub3JyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2Nobm9ycikpIHtcbiAgICByZXR1cm4gbmV3IFNjaG5vcnIoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblNjaG5vcnIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQ3JlYXRlIGEgc2Nobm9yciBzaWduYXR1cmVcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleXxCdWZmZXJ8Qk59IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gbWVzc2FnZSBIZXggc3RyaW5nIG9yIGJ1ZmZlclxuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBhdXggSGV4IHN0cmluZyBvciBidWZmZXJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraSNEZWZhdWx0X1NpZ25pbmdcbiAqL1xuU2Nobm9yci5zaWduID0gZnVuY3Rpb24ocHJpdmF0ZUtleSwgbWVzc2FnZSwgYXV4KSB7XG4gIHByaXZhdGVLZXkgPSBCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleSkgPyBwcml2YXRlS2V5IDogcHJpdmF0ZUtleS50b0J1ZmZlcigpO1xuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcml2YXRlIGtleSBzaG91bGQgYmUgMzIgYnl0ZXMgZm9yIHNjaG5vcnIgc2lnbmF0dXJlcycpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICQuY2hlY2tBcmd1bWVudChKUy5pc0hleGFTdHJpbmcobWVzc2FnZSksICdTY2hub3JyIG1lc3NhZ2Ugc3RyaW5nIGlzIG5vdCBoZXgnKTtcbiAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSwgJ2hleCcpXG4gIH1cbiAgJC5jaGVja0FyZ3VtZW50KCQuaXNUeXBlKG1lc3NhZ2UsICdCdWZmZXInKSwgJ1NjaG5vcnIgbWVzc2FnZSBtdXN0IGJlIGEgaGV4IHN0cmluZyBvciBidWZmZXInKTtcblxuICBpZiAoIWF1eCkge1xuICAgIGF1eCA9IGNyeXB0by5yYW5kb21CeXRlcygzMik7XG4gIH1cbiAgaWYgKHR5cGVvZiBhdXggPT09ICdzdHJpbmcnKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50KEpTLmlzSGV4YVN0cmluZyhhdXgpLCAnU2Nobm9yciBhdXggc3RyaW5nIGlzIG5vdCBoZXgnKTtcbiAgICBhdXggPSBCdWZmZXIuZnJvbShhdXgsICdoZXgnKVxuICB9XG4gICQuY2hlY2tBcmd1bWVudCgkLmlzVHlwZShhdXgsICdCdWZmZXInKSwgJ1NjaG5vcnIgYXV4IG11c3QgYmUgYSBoZXggc3RyaW5nIG9yIGJ1ZmZlcicpO1xuXG4gIGNvbnN0IEcgPSBQb2ludC5nZXRHKCk7XG4gIGNvbnN0IG4gPSBQb2ludC5nZXROKCk7XG5cbiAgY29uc3QgZFByaW1lID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoZFByaW1lLmVxbigwKSB8fCBkUHJpbWUuZ3RlKG4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUga2V5IGZvciBzY2hub3JyIHNpZ25pbmcnKTtcbiAgfVxuICBjb25zdCBQID0gRy5tdWwoZFByaW1lKTtcbiAgY29uc3QgUGJ1ZiA9IEJ1ZmZlci5mcm9tKFAuZW5jb2RlQ29tcHJlc3NlZCgpLnNsaWNlKDEpKTsgLy8gc2xpY2UoMSkgcmVtb3ZlcyB0aGUgZW5jb2RpbmcgcHJlZml4IGJ5dGVcbiAgY29uc3QgZCA9IFAueS5pc0V2ZW4oKSA/IGRQcmltZSA6IG4uc3ViKGRQcmltZSk7XG4gIGNvbnN0IHQgPSBkLnhvcihuZXcgQk4obmV3IFRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYXV4KS5maW5hbGl6ZSgpKSk7XG4gIGNvbnN0IHJhbmQgPSBuZXcgVGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIEJ1ZmZlci5jb25jYXQoW3QudG9CdWZmZXIoKSwgUGJ1ZiwgbWVzc2FnZV0pKS5maW5hbGl6ZSgpO1xuICBjb25zdCBrUHJpbWUgPSBuZXcgQk4ocmFuZCkubW9kKG4pO1xuICBpZiAoa1ByaW1lLmVxbigwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgc2Nobm9yciBzaWduYXR1cmUnKTtcbiAgfVxuICBjb25zdCBSID0gRy5tdWwoa1ByaW1lKTtcbiAgY29uc3QgUmJ1ZiA9IEJ1ZmZlci5mcm9tKFIuZW5jb2RlQ29tcHJlc3NlZCgpLnNsaWNlKDEpKTsgLy8gc2xpY2UoMSkgcmVtb3ZlcyB0aGUgZW5jb2RpbmcgcHJlZml4IGJ5dGVcbiAgY29uc3QgayA9IFIueS5pc0V2ZW4oKSA/IGtQcmltZSA6IG4uc3ViKGtQcmltZSk7XG4gIGNvbnN0IGUgPSBuZXcgQk4obmV3IFRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgQnVmZmVyLmNvbmNhdChbUmJ1ZiwgUGJ1ZiwgbWVzc2FnZV0pKS5maW5hbGl6ZSgpKS5tb2Qobik7XG4gIGNvbnN0IHNpZyA9IEJ1ZmZlci5jb25jYXQoW1JidWYsIGsuYWRkKGUubXVsKGQpKS5tb2QobikudG9CdWZmZXIoKV0pO1xuXG4gIGlmICghU2Nobm9yci52ZXJpZnkoUGJ1ZiwgbWVzc2FnZSwgc2lnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgc2Nobm9yciBzaWduYXR1cmUuIFZlcmlmaWNhdGlvbiBmYWlsZWQnKTtcbiAgfVxuICByZXR1cm4gc2lnO1xufTtcblxuXG4vKipcbiAqIFZlcmlmeSBhIHNjaG5vcnIgc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1B1YmxpY0tleXxCdWZmZXJ9IHB1YmxpY0tleSBcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gbWVzc2FnZSBIZXggc3RyaW5nIG9yIGJ1ZmZlclxuICogQHBhcmFtIHtTdHJpbmd8U2lnbmF0dXJlfEJ1ZmZlcn0gc2lnbmF0dXJlIEhleCBzdHJpbmcsIFNpZ25hdHVyZSBpbnN0YW5jZSwgb3IgYnVmZmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpI1ZlcmlmaWNhdGlvblxuICovXG5TY2hub3JyLnZlcmlmeSA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgbWVzc2FnZSwgc2lnbmF0dXJlKSB7XG4gIGlmICgkLmlzVHlwZShwdWJsaWNLZXksICdQdWJsaWNLZXknKSkge1xuICAgIHB1YmxpY0tleSA9IHB1YmxpY0tleS5wb2ludC54LnRvQnVmZmVyKCk7XG4gIH1cbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQdWJsaWMga2V5IHNob3VsZCBiZSAzMiBieXRlcyBmb3Igc2Nobm9yciBzaWduYXR1cmVzJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50KEpTLmlzSGV4YVN0cmluZyhtZXNzYWdlKSwgJ1NjaG5vcnIgbWVzc2FnZSBzdHJpbmcgaXMgbm90IGhleCcpO1xuICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlLCAnaGV4Jyk7XG4gIH1cbiAgaWYgKG1lc3NhZ2UubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBzaG91bGQgYmUgYSAzMiBieXRlIGJ1ZmZlcicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50KEpTLmlzSGV4YVN0cmluZyhzaWduYXR1cmUpLCAnU2Nobm9yciBzaWduYXR1cmUgc3RyaW5nIGlzIG5vdCBoZXgnKTtcbiAgICBzaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUsICdoZXgnKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpZ25hdHVyZS50b0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS50b0J1ZmZlcigpO1xuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSA2NSkge1xuICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnNsaWNlKDAsIDY0KTsgLy8gcmVtb3ZlIHRoZSBzaWdoYXNoVHlwZSBieXRlXG4gICAgfVxuICB9XG4gIGlmIChzaWduYXR1cmUubGVuZ3RoICE9PSA2NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIHNob3VsZCBiZSBhIDY0IGJ5dGUgYnVmZmVyLiBHb3QgJyArIHNpZ25hdHVyZS5sZW5ndGggKyAnIGJ5dGVzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHAgPSBQb2ludC5nZXRQKCk7XG4gICAgY29uc3QgbiA9IFBvaW50LmdldE4oKTtcblxuICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tWChmYWxzZSwgcHVibGljS2V5KS5saWZ0WCgpO1xuICAgIGNvbnN0IHIgPSBuZXcgQk4oc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IG5ldyBCTihzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSk7XG4gICAgaWYgKHIuZ3RlKHApIHx8IHMuZ3RlKG4pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGUgPSBnZXRFKHIsIFAsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IEcgPSBQb2ludC5nZXRHKCk7XG4gICAgY29uc3QgUiA9IEcubXVsKHMpLmFkZChQLm11bChlKS5uZWcoKSk7XG4gICAgaWYgKFIuaW5mIHx8ICFSLnkuaXNFdmVuKCkgfHwgIVIueC5lcShyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyogVXRpbGl0eSBmdW5jdGlvbiB1c2VkIGluIFZlcmlmeSgpICovXG5jb25zdCBnZXRFID0gZnVuY3Rpb24ociwgUCwgbWVzc2FnZSkge1xuICBjb25zdCBuID0gUG9pbnQuZ2V0TigpO1xuICBjb25zdCBoYXNoID0gbmV3IFRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgQnVmZmVyLmNvbmNhdChbci50b0J1ZmZlcih7IHNpemU6IDMyIH0pLCBQLngudG9CdWZmZXIoeyBzaXplOiAzMiB9KSwgbWVzc2FnZV0pKS5maW5hbGl6ZSgpO1xuICByZXR1cm4gbmV3IEJOKGhhc2gpLm1vZChuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nobm9ycjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/schnorr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/signature.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! ./bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nvar Signature = function Signature(r, s, isSchnorr) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s, isSchnorr);\n  }\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s,\n      isSchnorr: isSchnorr\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 7 */\nSignature.prototype.set = function(obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n\n  // public key recovery parameter in range [0, 3]\n  this.i = typeof obj.i === 'undefined' ? this.i : obj.i;\n  // whether the recovered pubkey is compressed\n  this.compressed = typeof obj.compressed === 'undefined' ? this.compressed : obj.compressed;\n  this.isSchnorr = typeof obj.isSchnorr === 'undefined' ? this.isSchnorr : obj.isSchnorr;\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n\n  var sig = new Signature();\n\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function(buf, strict) {\n  var sig = new Signature();\n\n  // Schnorr Signatures use 65 byte for in tx r [len] 32 , s [len] 32, nhashtype\n  // NOTE: this check is not very reliable. You should use .fromSchnorr directly if you know it's a schnorr sig.\n  if((buf.length === 64 || buf.length === 65) && buf[0] != 0x30) {\n    return Signature.fromSchnorr(buf);\n  }\n  \n  $.checkArgument(!(buf.length === 64 && buf[0] === 0x30), new Error('64 DER (ecdsa) signatures not allowed'));\n  \n  var obj = Signature.parseDER(buf, strict);\n\n  sig.r = obj.r;\n  sig.s = obj.s;\n\n  return sig;\n};\n\n// The format used in a tx\nSignature.fromTxFormat = function(buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function(str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n\n\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\nSignature.parseDER = function(buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n\n  length = length < buflength ? length : buflength;\n\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n\n  return obj;\n};\n\n\nSignature.prototype.toCompact = function(i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n  if (compressed === false) {\n    val = val - 4;\n  }\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\n/**\n * Returns either a DER encoded buffer or a Schnorr encoded buffer if isSchnor == true\n */\nSignature.prototype.toBuffer = Signature.prototype.toDER = function() {\n  if(this.isSchnorr) {\n    const hashTypeBuf = !this.nhashtype || this.nhashtype === Signature.SIGHASH_DEFAULT ? Buffer.alloc(0) : Buffer.from([this.nhashtype]);\n    return Buffer.concat([this.r.toBuffer({ size: 32 }), this.s.toBuffer({ size: 32 }), hashTypeBuf]);\n  }\n\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function() {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\nSignature.isTxDER = function(buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n  var nLenR = buf[3];\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n  var nLenS = buf[5 + nLenR];\n  if ((nLenR + nLenS + 7) !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n  return true;\n};\n\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\nSignature.prototype.hasLowS = function() {\n  if (this.s.lt(new BN(1)) ||\n    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\nSignature.prototype.hasDefinedHashtype = function() {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  }\n  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n  return true;\n};\n\nSignature.prototype.toTxFormat = function() {\n  var derbuf = this.toDER();\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\n/**\n * Creates a Signature instance from a Schnorr sig\n * @param {Buffer} buf Schnorr signature buffer\n * @returns {Signature}\n */\nSignature.fromSchnorr = function(buf) {\n  $.checkArgument(Buffer.isBuffer(buf), 'Schnorr signature argument must be a buffer');\n  $.checkArgument(buf.length === 64 || buf.length === 65, 'Schnorr signatures must be 64 or 65 bytes');\n\n  const sig = new Signature();\n  let r = buf.slice(0,32);\n  let s = buf.slice(32, 64);\n  if (buf.length === 65) {\n    sig.nhashtype = buf[buf.length - 1];\n    $.checkState(sig.nhashtype !== Signature.SIGHASH_DEFAULT, new Error('invalid hashtype'));\n  } else {\n    sig.nhashtype = Signature.SIGHASH_DEFAULT;\n  }\n  sig.r = BN.fromBuffer(r);\n  sig.s = BN.fromBuffer(s);\n  sig.isSchnorr = true;\n  return sig;\n};\n\nSignature.SIGHASH_DEFAULT       = 0x00; //!< Taproot only; implied when sighash byte is missing, and equivalent to SIGHASH_ALL\nSignature.SIGHASH_ALL           = 0x01;\nSignature.SIGHASH_NONE          = 0x02;\nSignature.SIGHASH_SINGLE        = 0x03;\nSignature.SIGHASH_ANYONECANPAY  = 0x80;\n\nSignature.SIGHASH_OUTPUT_MASK = 3;\nSignature.SIGHASH_INPUT_MASK  = 128; // 0x80,\n\nSignature.Version = {};\nSignature.Version.BASE       = 0;\nSignature.Version.WITNESS_V0 = 1;\nSignature.Version.TAPROOT    = 2;\nSignature.Version.TAPSCRIPT  = 3;\n\nmodule.exports = Signature;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9zaWduYXR1cmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsU0FBUyxtQkFBTyxDQUFDLCtEQUFNO0FBQ3ZCLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsbUVBQVk7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVLHFCQUFxQixVQUFVO0FBQ3JGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL3NpZ25hdHVyZS5qcz8yOGEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnLi9ibicpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9qcycpO1xuXG52YXIgU2lnbmF0dXJlID0gZnVuY3Rpb24gU2lnbmF0dXJlKHIsIHMsIGlzU2Nobm9ycikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2lnbmF0dXJlKSkge1xuICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMsIGlzU2Nobm9ycik7XG4gIH1cbiAgaWYgKHIgaW5zdGFuY2VvZiBCTikge1xuICAgIHRoaXMuc2V0KHtcbiAgICAgIHI6IHIsXG4gICAgICBzOiBzLFxuICAgICAgaXNTY2hub3JyOiBpc1NjaG5vcnJcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChyKSB7XG4gICAgdmFyIG9iaiA9IHI7XG4gICAgdGhpcy5zZXQob2JqKTtcbiAgfVxufTtcblxuLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDcgKi9cblNpZ25hdHVyZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHRoaXMuciA9IG9iai5yIHx8IHRoaXMuciB8fCB1bmRlZmluZWQ7XG4gIHRoaXMucyA9IG9iai5zIHx8IHRoaXMucyB8fCB1bmRlZmluZWQ7XG5cbiAgLy8gcHVibGljIGtleSByZWNvdmVyeSBwYXJhbWV0ZXIgaW4gcmFuZ2UgWzAsIDNdXG4gIHRoaXMuaSA9IHR5cGVvZiBvYmouaSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmkgOiBvYmouaTtcbiAgLy8gd2hldGhlciB0aGUgcmVjb3ZlcmVkIHB1YmtleSBpcyBjb21wcmVzc2VkXG4gIHRoaXMuY29tcHJlc3NlZCA9IHR5cGVvZiBvYmouY29tcHJlc3NlZCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvbXByZXNzZWQgOiBvYmouY29tcHJlc3NlZDtcbiAgdGhpcy5pc1NjaG5vcnIgPSB0eXBlb2Ygb2JqLmlzU2Nobm9yciA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmlzU2Nobm9yciA6IG9iai5pc1NjaG5vcnI7XG4gIHRoaXMubmhhc2h0eXBlID0gb2JqLm5oYXNodHlwZSB8fCB0aGlzLm5oYXNodHlwZSB8fCB1bmRlZmluZWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuU2lnbmF0dXJlLmZyb21Db21wYWN0ID0gZnVuY3Rpb24oYnVmKSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZiksICdBcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIEJ1ZmZlcicpO1xuXG4gIHZhciBzaWcgPSBuZXcgU2lnbmF0dXJlKCk7XG5cbiAgdmFyIGNvbXByZXNzZWQgPSB0cnVlO1xuICB2YXIgaSA9IGJ1Zi5zbGljZSgwLCAxKVswXSAtIDI3IC0gNDtcbiAgaWYgKGkgPCAwKSB7XG4gICAgY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIGkgPSBpICsgNDtcbiAgfVxuXG4gIHZhciBiMiA9IGJ1Zi5zbGljZSgxLCAzMyk7XG4gIHZhciBiMyA9IGJ1Zi5zbGljZSgzMywgNjUpO1xuXG4gICQuY2hlY2tBcmd1bWVudChpID09PSAwIHx8IGkgPT09IDEgfHwgaSA9PT0gMiB8fCBpID09PSAzLCBuZXcgRXJyb3IoJ2kgbXVzdCBiZSAwLCAxLCAyLCBvciAzJykpO1xuICAkLmNoZWNrQXJndW1lbnQoYjIubGVuZ3RoID09PSAzMiwgbmV3IEVycm9yKCdyIG11c3QgYmUgMzIgYnl0ZXMnKSk7XG4gICQuY2hlY2tBcmd1bWVudChiMy5sZW5ndGggPT09IDMyLCBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAzMiBieXRlcycpKTtcblxuICBzaWcuY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XG4gIHNpZy5pID0gaTtcbiAgc2lnLnIgPSBCTi5mcm9tQnVmZmVyKGIyKTtcbiAgc2lnLnMgPSBCTi5mcm9tQnVmZmVyKGIzKTtcblxuICByZXR1cm4gc2lnO1xufTtcblxuU2lnbmF0dXJlLmZyb21ERVIgPSBTaWduYXR1cmUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1Ziwgc3RyaWN0KSB7XG4gIHZhciBzaWcgPSBuZXcgU2lnbmF0dXJlKCk7XG5cbiAgLy8gU2Nobm9yciBTaWduYXR1cmVzIHVzZSA2NSBieXRlIGZvciBpbiB0eCByIFtsZW5dIDMyICwgcyBbbGVuXSAzMiwgbmhhc2h0eXBlXG4gIC8vIE5PVEU6IHRoaXMgY2hlY2sgaXMgbm90IHZlcnkgcmVsaWFibGUuIFlvdSBzaG91bGQgdXNlIC5mcm9tU2Nobm9yciBkaXJlY3RseSBpZiB5b3Uga25vdyBpdCdzIGEgc2Nobm9yciBzaWcuXG4gIGlmKChidWYubGVuZ3RoID09PSA2NCB8fCBidWYubGVuZ3RoID09PSA2NSkgJiYgYnVmWzBdICE9IDB4MzApIHtcbiAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21TY2hub3JyKGJ1Zik7XG4gIH1cbiAgXG4gICQuY2hlY2tBcmd1bWVudCghKGJ1Zi5sZW5ndGggPT09IDY0ICYmIGJ1ZlswXSA9PT0gMHgzMCksIG5ldyBFcnJvcignNjQgREVSIChlY2RzYSkgc2lnbmF0dXJlcyBub3QgYWxsb3dlZCcpKTtcbiAgXG4gIHZhciBvYmogPSBTaWduYXR1cmUucGFyc2VERVIoYnVmLCBzdHJpY3QpO1xuXG4gIHNpZy5yID0gb2JqLnI7XG4gIHNpZy5zID0gb2JqLnM7XG5cbiAgcmV0dXJuIHNpZztcbn07XG5cbi8vIFRoZSBmb3JtYXQgdXNlZCBpbiBhIHR4XG5TaWduYXR1cmUuZnJvbVR4Rm9ybWF0ID0gZnVuY3Rpb24oYnVmKSB7XG4gIHZhciBuaGFzaHR5cGUgPSBidWYucmVhZFVJbnQ4KGJ1Zi5sZW5ndGggLSAxKTtcbiAgdmFyIGRlcmJ1ZiA9IGJ1Zi5zbGljZSgwLCBidWYubGVuZ3RoIC0gMSk7XG4gIHZhciBzaWcgPSBuZXcgU2lnbmF0dXJlLmZyb21ERVIoZGVyYnVmLCBmYWxzZSk7XG4gIHNpZy5uaGFzaHR5cGUgPSBuaGFzaHR5cGU7XG4gIHJldHVybiBzaWc7XG59O1xuXG5TaWduYXR1cmUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgYnVmID0gQnVmZmVyLmZyb20oc3RyLCAnaGV4Jyk7XG4gIHJldHVybiBTaWduYXR1cmUuZnJvbURFUihidWYpO1xufTtcblxuXG4vKipcbiAqIEluIG9yZGVyIHRvIG1pbWljIHRoZSBub24tc3RyaWN0IERFUiBlbmNvZGluZyBvZiBPcGVuU1NMLCBzZXQgc3RyaWN0ID0gZmFsc2UuXG4gKi9cblNpZ25hdHVyZS5wYXJzZURFUiA9IGZ1bmN0aW9uKGJ1Ziwgc3RyaWN0KSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZiksIG5ldyBFcnJvcignREVSIGZvcm1hdHRlZCBzaWduYXR1cmUgc2hvdWxkIGJlIGEgYnVmZmVyJykpO1xuICBpZiAoXy5pc1VuZGVmaW5lZChzdHJpY3QpKSB7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoZWFkZXIgPSBidWZbMF07XG4gICQuY2hlY2tBcmd1bWVudChoZWFkZXIgPT09IDB4MzAsIG5ldyBFcnJvcignSGVhZGVyIGJ5dGUgc2hvdWxkIGJlIDB4MzAnKSk7XG5cbiAgdmFyIGxlbmd0aCA9IGJ1ZlsxXTtcbiAgdmFyIGJ1Zmxlbmd0aCA9IGJ1Zi5zbGljZSgyKS5sZW5ndGg7XG4gICQuY2hlY2tBcmd1bWVudCghc3RyaWN0IHx8IGxlbmd0aCA9PT0gYnVmbGVuZ3RoLCBuZXcgRXJyb3IoJ0xlbmd0aCBieXRlIHNob3VsZCBsZW5ndGggb2Ygd2hhdCBmb2xsb3dzJykpO1xuXG4gIGxlbmd0aCA9IGxlbmd0aCA8IGJ1Zmxlbmd0aCA/IGxlbmd0aCA6IGJ1Zmxlbmd0aDtcblxuICB2YXIgcmhlYWRlciA9IGJ1ZlsyICsgMF07XG4gICQuY2hlY2tBcmd1bWVudChyaGVhZGVyID09PSAweDAyLCBuZXcgRXJyb3IoJ0ludGVnZXIgYnl0ZSBmb3IgciBzaG91bGQgYmUgMHgwMicpKTtcblxuICB2YXIgcmxlbmd0aCA9IGJ1ZlsyICsgMV07XG4gIHZhciByYnVmID0gYnVmLnNsaWNlKDIgKyAyLCAyICsgMiArIHJsZW5ndGgpO1xuICB2YXIgciA9IEJOLmZyb21CdWZmZXIocmJ1Zik7XG4gIHZhciBybmVnID0gYnVmWzIgKyAxICsgMV0gPT09IDB4MDAgPyB0cnVlIDogZmFsc2U7XG4gICQuY2hlY2tBcmd1bWVudChybGVuZ3RoID09PSByYnVmLmxlbmd0aCwgbmV3IEVycm9yKCdMZW5ndGggb2YgciBpbmNvcnJlY3QnKSk7XG5cbiAgdmFyIHNoZWFkZXIgPSBidWZbMiArIDIgKyBybGVuZ3RoICsgMF07XG4gICQuY2hlY2tBcmd1bWVudChzaGVhZGVyID09PSAweDAyLCBuZXcgRXJyb3IoJ0ludGVnZXIgYnl0ZSBmb3IgcyBzaG91bGQgYmUgMHgwMicpKTtcblxuICB2YXIgc2xlbmd0aCA9IGJ1ZlsyICsgMiArIHJsZW5ndGggKyAxXTtcbiAgdmFyIHNidWYgPSBidWYuc2xpY2UoMiArIDIgKyBybGVuZ3RoICsgMiwgMiArIDIgKyBybGVuZ3RoICsgMiArIHNsZW5ndGgpO1xuICB2YXIgcyA9IEJOLmZyb21CdWZmZXIoc2J1Zik7XG4gIHZhciBzbmVnID0gYnVmWzIgKyAyICsgcmxlbmd0aCArIDIgKyAyXSA9PT0gMHgwMCA/IHRydWUgOiBmYWxzZTtcbiAgJC5jaGVja0FyZ3VtZW50KHNsZW5ndGggPT09IHNidWYubGVuZ3RoLCBuZXcgRXJyb3IoJ0xlbmd0aCBvZiBzIGluY29ycmVjdCcpKTtcblxuICB2YXIgc3VtbGVuZ3RoID0gMiArIDIgKyBybGVuZ3RoICsgMiArIHNsZW5ndGg7XG4gICQuY2hlY2tBcmd1bWVudChsZW5ndGggPT09IHN1bWxlbmd0aCAtIDIsIG5ldyBFcnJvcignTGVuZ3RoIG9mIHNpZ25hdHVyZSBpbmNvcnJlY3QnKSk7XG5cbiAgdmFyIG9iaiA9IHtcbiAgICBoZWFkZXI6IGhlYWRlcixcbiAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICByaGVhZGVyOiByaGVhZGVyLFxuICAgIHJsZW5ndGg6IHJsZW5ndGgsXG4gICAgcm5lZzogcm5lZyxcbiAgICByYnVmOiByYnVmLFxuICAgIHI6IHIsXG4gICAgc2hlYWRlcjogc2hlYWRlcixcbiAgICBzbGVuZ3RoOiBzbGVuZ3RoLFxuICAgIHNuZWc6IHNuZWcsXG4gICAgc2J1Zjogc2J1ZixcbiAgICBzOiBzXG4gIH07XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0NvbXBhY3QgPSBmdW5jdGlvbihpLCBjb21wcmVzc2VkKSB7XG4gIGkgPSB0eXBlb2YgaSA9PT0gJ251bWJlcicgPyBpIDogdGhpcy5pO1xuICBjb21wcmVzc2VkID0gdHlwZW9mIGNvbXByZXNzZWQgPT09ICdib29sZWFuJyA/IGNvbXByZXNzZWQgOiB0aGlzLmNvbXByZXNzZWQ7XG5cbiAgaWYgKCEoaSA9PT0gMCB8fCBpID09PSAxIHx8IGkgPT09IDIgfHwgaSA9PT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2kgbXVzdCBiZSBlcXVhbCB0byAwLCAxLCAyLCBvciAzJyk7XG4gIH1cblxuICB2YXIgdmFsID0gaSArIDI3ICsgNDtcbiAgaWYgKGNvbXByZXNzZWQgPT09IGZhbHNlKSB7XG4gICAgdmFsID0gdmFsIC0gNDtcbiAgfVxuICB2YXIgYjEgPSBCdWZmZXIuZnJvbShbdmFsXSk7XG4gIHZhciBiMiA9IHRoaXMuci50b0J1ZmZlcih7XG4gICAgc2l6ZTogMzJcbiAgfSk7XG4gIHZhciBiMyA9IHRoaXMucy50b0J1ZmZlcih7XG4gICAgc2l6ZTogMzJcbiAgfSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtiMSwgYjIsIGIzXSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZWl0aGVyIGEgREVSIGVuY29kZWQgYnVmZmVyIG9yIGEgU2Nobm9yciBlbmNvZGVkIGJ1ZmZlciBpZiBpc1NjaG5vciA9PSB0cnVlXG4gKi9cblNpZ25hdHVyZS5wcm90b3R5cGUudG9CdWZmZXIgPSBTaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuaXNTY2hub3JyKSB7XG4gICAgY29uc3QgaGFzaFR5cGVCdWYgPSAhdGhpcy5uaGFzaHR5cGUgfHwgdGhpcy5uaGFzaHR5cGUgPT09IFNpZ25hdHVyZS5TSUdIQVNIX0RFRkFVTFQgPyBCdWZmZXIuYWxsb2MoMCkgOiBCdWZmZXIuZnJvbShbdGhpcy5uaGFzaHR5cGVdKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy5yLnRvQnVmZmVyKHsgc2l6ZTogMzIgfSksIHRoaXMucy50b0J1ZmZlcih7IHNpemU6IDMyIH0pLCBoYXNoVHlwZUJ1Zl0pO1xuICB9XG5cbiAgdmFyIHJuYnVmID0gdGhpcy5yLnRvQnVmZmVyKCk7XG4gIHZhciBzbmJ1ZiA9IHRoaXMucy50b0J1ZmZlcigpO1xuXG4gIHZhciBybmVnID0gcm5idWZbMF0gJiAweDgwID8gdHJ1ZSA6IGZhbHNlO1xuICB2YXIgc25lZyA9IHNuYnVmWzBdICYgMHg4MCA/IHRydWUgOiBmYWxzZTtcblxuICB2YXIgcmJ1ZiA9IHJuZWcgPyBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMHgwMF0pLCBybmJ1Zl0pIDogcm5idWY7XG4gIHZhciBzYnVmID0gc25lZyA/IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFsweDAwXSksIHNuYnVmXSkgOiBzbmJ1ZjtcblxuICB2YXIgcmxlbmd0aCA9IHJidWYubGVuZ3RoO1xuICB2YXIgc2xlbmd0aCA9IHNidWYubGVuZ3RoO1xuICB2YXIgbGVuZ3RoID0gMiArIHJsZW5ndGggKyAyICsgc2xlbmd0aDtcbiAgdmFyIHJoZWFkZXIgPSAweDAyO1xuICB2YXIgc2hlYWRlciA9IDB4MDI7XG4gIHZhciBoZWFkZXIgPSAweDMwO1xuXG4gIHZhciBkZXIgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbaGVhZGVyLCBsZW5ndGgsIHJoZWFkZXIsIHJsZW5ndGhdKSwgcmJ1ZiwgQnVmZmVyLmZyb20oW3NoZWFkZXIsIHNsZW5ndGhdKSwgc2J1Zl0pO1xuICByZXR1cm4gZGVyO1xufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVmID0gdGhpcy50b0RFUigpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0cmFuc2xhdGVkIGZyb20gYml0Y29pbmQncyBJc0RFUlNpZ25hdHVyZSBhbmQgaXMgdXNlZCBpblxuICogdGhlIHNjcmlwdCBpbnRlcnByZXRlci4gIFRoaXMgXCJERVJcIiBmb3JtYXQgYWN0dWFsbHkgaW5jbHVkZXMgYW4gZXh0cmEgYnl0ZSxcbiAqIHRoZSBuaGFzaHR5cGUsIGF0IHRoZSBlbmQuIEl0IGlzIHJlYWxseSB0aGUgdHggZm9ybWF0LCBub3QgREVSIGZvcm1hdC5cbiAqXG4gKiBBIGNhbm9uaWNhbCBzaWduYXR1cmUgZXhpc3RzIG9mOiBbMzBdIFt0b3RhbCBsZW5dIFswMl0gW2xlbiBSXSBbUl0gWzAyXSBbbGVuIFNdIFtTXSBbaGFzaHR5cGVdXG4gKiBXaGVyZSBSIGFuZCBTIGFyZSBub3QgbmVnYXRpdmUgKHRoZWlyIGZpcnN0IGJ5dGUgaGFzIGl0cyBoaWdoZXN0IGJpdCBub3Qgc2V0KSwgYW5kIG5vdFxuICogZXhjZXNzaXZlbHkgcGFkZGVkIChkbyBub3Qgc3RhcnQgd2l0aCBhIDAgYnl0ZSwgdW5sZXNzIGFuIG90aGVyd2lzZSBuZWdhdGl2ZSBudW1iZXIgZm9sbG93cyxcbiAqIGluIHdoaWNoIGNhc2UgYSBzaW5nbGUgMCBieXRlIGlzIG5lY2Vzc2FyeSBhbmQgZXZlbiByZXF1aXJlZCkuXG4gKlxuICogU2VlIGh0dHBzOi8vYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz04MzkyLm1zZzEyNzYyMyNtc2cxMjc2MjNcbiAqL1xuU2lnbmF0dXJlLmlzVHhERVIgPSBmdW5jdGlvbihidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPCA5KSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB0b28gc2hvcnRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGJ1Zi5sZW5ndGggPiA3Mykge1xuICAgIC8vIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB0b28gbG9uZ1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYnVmWzBdICE9PSAweDMwKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB3cm9uZyB0eXBlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChidWZbMV0gIT09IGJ1Zi5sZW5ndGggLSAzKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB3cm9uZyBsZW5ndGggbWFya2VyXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBuTGVuUiA9IGJ1ZlszXTtcbiAgaWYgKDUgKyBuTGVuUiA+PSBidWYubGVuZ3RoKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBTIGxlbmd0aCBtaXNwbGFjZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG5MZW5TID0gYnVmWzUgKyBuTGVuUl07XG4gIGlmICgobkxlblIgKyBuTGVuUyArIDcpICE9PSBidWYubGVuZ3RoKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBSK1MgbGVuZ3RoIG1pc21hdGNoXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIFIgPSBidWYuc2xpY2UoNCk7XG4gIGlmIChidWZbNCAtIDJdICE9PSAweDAyKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBSIHZhbHVlIHR5cGUgbWlzbWF0Y2hcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5MZW5SID09PSAwKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBSIGxlbmd0aCBpcyB6ZXJvXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChSWzBdICYgMHg4MCkge1xuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUiB2YWx1ZSBuZWdhdGl2ZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobkxlblIgPiAxICYmIChSWzBdID09PSAweDAwKSAmJiAhKFJbMV0gJiAweDgwKSkge1xuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUiB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgUyA9IGJ1Zi5zbGljZSg2ICsgbkxlblIpO1xuICBpZiAoYnVmWzYgKyBuTGVuUiAtIDJdICE9PSAweDAyKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBTIHZhbHVlIHR5cGUgbWlzbWF0Y2hcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5MZW5TID09PSAwKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBTIGxlbmd0aCBpcyB6ZXJvXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChTWzBdICYgMHg4MCkge1xuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUyB2YWx1ZSBuZWdhdGl2ZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobkxlblMgPiAxICYmIChTWzBdID09PSAweDAwKSAmJiAhKFNbMV0gJiAweDgwKSkge1xuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUyB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRvIGJpdGNvaW5kJ3MgSXNMb3dERVJTaWduYXR1cmVcbiAqIFNlZSBhbHNvIEVDRFNBIHNpZ25hdHVyZSBhbGdvcml0aG0gd2hpY2ggZW5mb3JjZXMgdGhpcy5cbiAqIFNlZSBhbHNvIEJJUCA2MiwgXCJsb3cgUyB2YWx1ZXMgaW4gc2lnbmF0dXJlc1wiXG4gKi9cblNpZ25hdHVyZS5wcm90b3R5cGUuaGFzTG93UyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zLmx0KG5ldyBCTigxKSkgfHxcbiAgICB0aGlzLnMuZ3QobmV3IEJOKCc3RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjVENTc2RTczNTdBNDUwMURERkU5MkY0NjY4MUIyMEEwJywgJ2hleCcpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbmhhc2h0eXBlIGlzIGV4YWN0bHkgZXF1YWwgdG8gb25lIG9mIHRoZSBzdGFuZGFyZCBvcHRpb25zIG9yIGNvbWJpbmF0aW9ucyB0aGVyZW9mLlxuICogVHJhbnNsYXRlZCBmcm9tIGJpdGNvaW5kJ3MgSXNEZWZpbmVkSGFzaHR5cGVTaWduYXR1cmVcbiAqL1xuU2lnbmF0dXJlLnByb3RvdHlwZS5oYXNEZWZpbmVkSGFzaHR5cGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFKU1V0aWwuaXNOYXR1cmFsTnVtYmVyKHRoaXMubmhhc2h0eXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBhY2NlcHQgd2l0aCBvciB3aXRob3V0IFNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSBieSBpZ25vcmluZyB0aGUgYml0XG4gIHZhciB0ZW1wID0gdGhpcy5uaGFzaHR5cGUgJiB+U2lnbmF0dXJlLlNJR0hBU0hfQU5ZT05FQ0FOUEFZO1xuICBpZiAodGVtcCA8IFNpZ25hdHVyZS5TSUdIQVNIX0FMTCB8fCB0ZW1wID4gU2lnbmF0dXJlLlNJR0hBU0hfU0lOR0xFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b1R4Rm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkZXJidWYgPSB0aGlzLnRvREVSKCk7XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoMSk7XG4gIGJ1Zi53cml0ZVVJbnQ4KHRoaXMubmhhc2h0eXBlLCAwKTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2RlcmJ1ZiwgYnVmXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTaWduYXR1cmUgaW5zdGFuY2UgZnJvbSBhIFNjaG5vcnIgc2lnXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFNjaG5vcnIgc2lnbmF0dXJlIGJ1ZmZlclxuICogQHJldHVybnMge1NpZ25hdHVyZX1cbiAqL1xuU2lnbmF0dXJlLmZyb21TY2hub3JyID0gZnVuY3Rpb24oYnVmKSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXIuaXNCdWZmZXIoYnVmKSwgJ1NjaG5vcnIgc2lnbmF0dXJlIGFyZ3VtZW50IG11c3QgYmUgYSBidWZmZXInKTtcbiAgJC5jaGVja0FyZ3VtZW50KGJ1Zi5sZW5ndGggPT09IDY0IHx8IGJ1Zi5sZW5ndGggPT09IDY1LCAnU2Nobm9yciBzaWduYXR1cmVzIG11c3QgYmUgNjQgb3IgNjUgYnl0ZXMnKTtcblxuICBjb25zdCBzaWcgPSBuZXcgU2lnbmF0dXJlKCk7XG4gIGxldCByID0gYnVmLnNsaWNlKDAsMzIpO1xuICBsZXQgcyA9IGJ1Zi5zbGljZSgzMiwgNjQpO1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gNjUpIHtcbiAgICBzaWcubmhhc2h0eXBlID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAkLmNoZWNrU3RhdGUoc2lnLm5oYXNodHlwZSAhPT0gU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVCwgbmV3IEVycm9yKCdpbnZhbGlkIGhhc2h0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHNpZy5uaGFzaHR5cGUgPSBTaWduYXR1cmUuU0lHSEFTSF9ERUZBVUxUO1xuICB9XG4gIHNpZy5yID0gQk4uZnJvbUJ1ZmZlcihyKTtcbiAgc2lnLnMgPSBCTi5mcm9tQnVmZmVyKHMpO1xuICBzaWcuaXNTY2hub3JyID0gdHJ1ZTtcbiAgcmV0dXJuIHNpZztcbn07XG5cblNpZ25hdHVyZS5TSUdIQVNIX0RFRkFVTFQgICAgICAgPSAweDAwOyAvLyE8IFRhcHJvb3Qgb25seTsgaW1wbGllZCB3aGVuIHNpZ2hhc2ggYnl0ZSBpcyBtaXNzaW5nLCBhbmQgZXF1aXZhbGVudCB0byBTSUdIQVNIX0FMTFxuU2lnbmF0dXJlLlNJR0hBU0hfQUxMICAgICAgICAgICA9IDB4MDE7XG5TaWduYXR1cmUuU0lHSEFTSF9OT05FICAgICAgICAgID0gMHgwMjtcblNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSAgICAgICAgPSAweDAzO1xuU2lnbmF0dXJlLlNJR0hBU0hfQU5ZT05FQ0FOUEFZICA9IDB4ODA7XG5cblNpZ25hdHVyZS5TSUdIQVNIX09VVFBVVF9NQVNLID0gMztcblNpZ25hdHVyZS5TSUdIQVNIX0lOUFVUX01BU0sgID0gMTI4OyAvLyAweDgwLFxuXG5TaWduYXR1cmUuVmVyc2lvbiA9IHt9O1xuU2lnbmF0dXJlLlZlcnNpb24uQkFTRSAgICAgICA9IDA7XG5TaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwID0gMTtcblNpZ25hdHVyZS5WZXJzaW9uLlRBUFJPT1QgICAgPSAyO1xuU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBUICA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/taggedhash.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Hash = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nconst BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nconst inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\n\n/**\n * Creates a tag hash to ensure uniqueness of a message between purposes.\n * For example, if there's a potential for a collision of messages between\n *   multiple purposes, a tag can be added to guard against such collisions.\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Design (see 'Tagged Hashes')\n * @param {String} tag The tag to prevent message collisions. Should uniquely reflect the purpose of the message.\n * @param {Buffer|String} message (optional)\n * @param {String} messageEncoding (default: 'hex') If `message` is a string, provide the encoding\n * @returns {TaggedHash} Instance of a BufferWriter with the written tag and `finalize` method\n */\nfunction TaggedHash(tag, message, messageEncoding = 'hex') {\n  if (!(this instanceof TaggedHash)) {\n    return new TaggedHash(tag, message, messageEncoding);\n  }\n  BufferWriter.apply(this);\n  tag = Buffer.from(tag);\n\n  const taghash = Hash.sha256(tag);\n  this.write(taghash);\n  this.write(taghash);\n  if (message) {\n    message = Buffer.isBuffer(message) ? message : Buffer.from(message, messageEncoding);\n    this.write(message);\n  }\n  return this;\n};\n\ninherits(TaggedHash, BufferWriter);\n\n/**\n * Returns a 32-byte SHA256 hash of the double tagged hashes concat'd with the message\n * as defined by BIP-340: SHA256(SHA256(tag), SHA256(tag), message)\n * @returns {Buffer}\n */\nTaggedHash.prototype.finalize = function() {\n  return Buffer.from(Hash.sha256(this.toBuffer()));\n};\n\n/**\n * Commonly used tags\n */\nObject.defineProperties(TaggedHash, {\n  TAPSIGHASH: { get: () => new TaggedHash('TapSighash') },\n  TAPLEAF:    { get: () => new TaggedHash('TapLeaf') },\n  TAPBRANCH:  { get: () => new TaggedHash('TapBranch') }\n});\n\nmodule.exports = TaggedHash;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by90YWdnZWRoYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxtRUFBUTtBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDdkQsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQVU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQsZ0JBQWdCLHNDQUFzQztBQUN0RCxnQkFBZ0I7QUFDaEIsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9jcnlwdG8vdGFnZ2VkaGFzaC5qcz9hYWI1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcbmNvbnN0IEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0YWcgaGFzaCB0byBlbnN1cmUgdW5pcXVlbmVzcyBvZiBhIG1lc3NhZ2UgYmV0d2VlbiBwdXJwb3Nlcy5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGVyZSdzIGEgcG90ZW50aWFsIGZvciBhIGNvbGxpc2lvbiBvZiBtZXNzYWdlcyBiZXR3ZWVuXG4gKiAgIG11bHRpcGxlIHB1cnBvc2VzLCBhIHRhZyBjYW4gYmUgYWRkZWQgdG8gZ3VhcmQgYWdhaW5zdCBzdWNoIGNvbGxpc2lvbnMuXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraSNEZXNpZ24gKHNlZSAnVGFnZ2VkIEhhc2hlcycpXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFnIFRoZSB0YWcgdG8gcHJldmVudCBtZXNzYWdlIGNvbGxpc2lvbnMuIFNob3VsZCB1bmlxdWVseSByZWZsZWN0IHRoZSBwdXJwb3NlIG9mIHRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBtZXNzYWdlIChvcHRpb25hbClcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlRW5jb2RpbmcgKGRlZmF1bHQ6ICdoZXgnKSBJZiBgbWVzc2FnZWAgaXMgYSBzdHJpbmcsIHByb3ZpZGUgdGhlIGVuY29kaW5nXG4gKiBAcmV0dXJucyB7VGFnZ2VkSGFzaH0gSW5zdGFuY2Ugb2YgYSBCdWZmZXJXcml0ZXIgd2l0aCB0aGUgd3JpdHRlbiB0YWcgYW5kIGBmaW5hbGl6ZWAgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIFRhZ2dlZEhhc2godGFnLCBtZXNzYWdlLCBtZXNzYWdlRW5jb2RpbmcgPSAnaGV4Jykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGFnZ2VkSGFzaCkpIHtcbiAgICByZXR1cm4gbmV3IFRhZ2dlZEhhc2godGFnLCBtZXNzYWdlLCBtZXNzYWdlRW5jb2RpbmcpO1xuICB9XG4gIEJ1ZmZlcldyaXRlci5hcHBseSh0aGlzKTtcbiAgdGFnID0gQnVmZmVyLmZyb20odGFnKTtcblxuICBjb25zdCB0YWdoYXNoID0gSGFzaC5zaGEyNTYodGFnKTtcbiAgdGhpcy53cml0ZSh0YWdoYXNoKTtcbiAgdGhpcy53cml0ZSh0YWdoYXNoKTtcbiAgaWYgKG1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpID8gbWVzc2FnZSA6IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIG1lc3NhZ2VFbmNvZGluZyk7XG4gICAgdGhpcy53cml0ZShtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmluaGVyaXRzKFRhZ2dlZEhhc2gsIEJ1ZmZlcldyaXRlcik7XG5cbi8qKlxuICogUmV0dXJucyBhIDMyLWJ5dGUgU0hBMjU2IGhhc2ggb2YgdGhlIGRvdWJsZSB0YWdnZWQgaGFzaGVzIGNvbmNhdCdkIHdpdGggdGhlIG1lc3NhZ2VcbiAqIGFzIGRlZmluZWQgYnkgQklQLTM0MDogU0hBMjU2KFNIQTI1Nih0YWcpLCBTSEEyNTYodGFnKSwgbWVzc2FnZSlcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cblRhZ2dlZEhhc2gucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShIYXNoLnNoYTI1Nih0aGlzLnRvQnVmZmVyKCkpKTtcbn07XG5cbi8qKlxuICogQ29tbW9ubHkgdXNlZCB0YWdzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRhZ2dlZEhhc2gsIHtcbiAgVEFQU0lHSEFTSDogeyBnZXQ6ICgpID0+IG5ldyBUYWdnZWRIYXNoKCdUYXBTaWdoYXNoJykgfSxcbiAgVEFQTEVBRjogICAgeyBnZXQ6ICgpID0+IG5ldyBUYWdnZWRIYXNoKCdUYXBMZWFmJykgfSxcbiAgVEFQQlJBTkNIOiAgeyBnZXQ6ICgpID0+IG5ldyBUYWdnZWRIYXNoKCdUYXBCcmFuY2gnKSB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWdnZWRIYXNoOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/base58.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar bs58 = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bitcore-lib/node_modules/bs58/index.js\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\n\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');\n\nvar Base58 = function Base58(obj) {\n  /* jshint maxcomplexity: 8 */\n  if (!(this instanceof Base58)) {\n    return new Base58(obj);\n  }\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58.validCharacters = function validCharacters(chars) {\n  if (buffer.Buffer.isBuffer(chars)) {\n    chars = chars.toString();\n  }\n  return _.every(_.map(chars, function(char) { return _.includes(ALPHABET, char); }));\n};\n\nBase58.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58.encode = function(buf) {\n  if (!buffer.Buffer.isBuffer(buf)) {\n    throw new Error('Input should be a buffer');\n  }\n  return bs58.encode(buf);\n};\n\nBase58.decode = function(str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n  return Buffer.from(bs58.decode(str));\n};\n\nBase58.prototype.fromBuffer = function(buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.fromString = function(str) {\n  var buf = Base58.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.toBuffer = function() {\n  return this.buf;\n};\n\nBase58.prototype.toString = function() {\n  return Base58.encode(this.buf);\n};\n\nmodule.exports = Base58;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2Jhc2U1OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsV0FBVyxtQkFBTyxDQUFDLHlFQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQ0FBb0M7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvZW5jb2RpbmcvYmFzZTU4LmpzP2E2MjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGJzNTggPSByZXF1aXJlKCdiczU4Jyk7XG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5cbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jy5zcGxpdCgnJyk7XG5cbnZhciBCYXNlNTggPSBmdW5jdGlvbiBCYXNlNTgob2JqKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCYXNlNTgpKSB7XG4gICAgcmV0dXJuIG5ldyBCYXNlNTgob2JqKTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgYnVmID0gb2JqO1xuICAgIHRoaXMuZnJvbUJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHN0ciA9IG9iajtcbiAgICB0aGlzLmZyb21TdHJpbmcoc3RyKTtcbiAgfSBlbHNlIGlmIChvYmopIHtcbiAgICB0aGlzLnNldChvYmopO1xuICB9XG59O1xuXG5CYXNlNTgudmFsaWRDaGFyYWN0ZXJzID0gZnVuY3Rpb24gdmFsaWRDaGFyYWN0ZXJzKGNoYXJzKSB7XG4gIGlmIChidWZmZXIuQnVmZmVyLmlzQnVmZmVyKGNoYXJzKSkge1xuICAgIGNoYXJzID0gY2hhcnMudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gXy5ldmVyeShfLm1hcChjaGFycywgZnVuY3Rpb24oY2hhcikgeyByZXR1cm4gXy5pbmNsdWRlcyhBTFBIQUJFVCwgY2hhcik7IH0pKTtcbn07XG5cbkJhc2U1OC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHRoaXMuYnVmID0gb2JqLmJ1ZiB8fCB0aGlzLmJ1ZiB8fCB1bmRlZmluZWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQmFzZTU4LmVuY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICBpZiAoIWJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hvdWxkIGJlIGEgYnVmZmVyJyk7XG4gIH1cbiAgcmV0dXJuIGJzNTguZW5jb2RlKGJ1Zik7XG59O1xuXG5CYXNlNTguZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJzNTguZGVjb2RlKHN0cikpO1xufTtcblxuQmFzZTU4LnByb3RvdHlwZS5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG4gIHRoaXMuYnVmID0gYnVmO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2U1OC5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgYnVmID0gQmFzZTU4LmRlY29kZShzdHIpO1xuICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlNTgucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJ1Zjtcbn07XG5cbkJhc2U1OC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEJhc2U1OC5lbmNvZGUodGhpcy5idWYpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlNTg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js":
/*!**************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/base58check.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar Base58 = __webpack_require__(/*! ./base58 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar sha256sha256 = (__webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\").sha256sha256);\n\nvar Base58Check = function Base58Check(obj) {\n  if (!(this instanceof Base58Check))\n    return new Base58Check(obj);\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58Check.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58Check.validChecksum = function validChecksum(data, checksum) {\n  if (_.isString(data)) {\n    data = Buffer.from(Base58.decode(data));\n  }\n  if (_.isString(checksum)) {\n    checksum =  Buffer.from(Base58.decode(checksum));\n  }\n  if (!checksum) {\n    checksum = data.slice(-4);\n    data = data.slice(0, -4);\n  }\n  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex');\n};\n\nBase58Check.decode = function(s) {\n  if (typeof s !== 'string')\n    throw new Error('Input must be a string');\n\n  var buf = Buffer.from(Base58.decode(s));\n\n  if (buf.length < 4)\n    throw new Error(\"Input string too short\");\n\n  var data = buf.slice(0, -4);\n  var csum = buf.slice(-4);\n\n  var hash = sha256sha256(data);\n  var hash4 = hash.slice(0, 4);\n\n  if (csum.toString('hex') !== hash4.toString('hex'))\n    throw new Error(\"Checksum mismatch\");\n\n  return data;\n};\n\nBase58Check.checksum = function(buffer) {\n  return sha256sha256(buffer).slice(0, 4);\n};\n\nBase58Check.encode = function(buf) {\n  if (!Buffer.isBuffer(buf))\n    throw new Error('Input must be a buffer');\n  var checkedBuf = Buffer.alloc(buf.length + 4);\n  var hash = Base58Check.checksum(buf);\n  buf.copy(checkedBuf);\n  hash.copy(checkedBuf, buf.length);\n  return Base58.encode(checkedBuf);\n};\n\nBase58Check.prototype.fromBuffer = function(buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.fromString = function(str) {\n  var buf = Base58Check.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.toBuffer = function() {\n  return this.buf;\n};\n\nBase58Check.prototype.toString = function() {\n  return Base58Check.encode(this.buf);\n};\n\nmodule.exports = Base58Check;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2Jhc2U1OGNoZWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixhQUFhLG1CQUFPLENBQUMseUVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLG1CQUFtQiwrR0FBc0M7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2Jhc2U1OGNoZWNrLmpzPzE5YzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIEJhc2U1OCA9IHJlcXVpcmUoJy4vYmFzZTU4Jyk7XG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgc2hhMjU2c2hhMjU2ID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKS5zaGEyNTZzaGEyNTY7XG5cbnZhciBCYXNlNThDaGVjayA9IGZ1bmN0aW9uIEJhc2U1OENoZWNrKG9iaikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmFzZTU4Q2hlY2spKVxuICAgIHJldHVybiBuZXcgQmFzZTU4Q2hlY2sob2JqKTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGJ1ZiA9IG9iajtcbiAgICB0aGlzLmZyb21CdWZmZXIoYnVmKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzdHIgPSBvYmo7XG4gICAgdGhpcy5mcm9tU3RyaW5nKHN0cik7XG4gIH0gZWxzZSBpZiAob2JqKSB7XG4gICAgdGhpcy5zZXQob2JqKTtcbiAgfVxufTtcblxuQmFzZTU4Q2hlY2sucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xuICB0aGlzLmJ1ZiA9IG9iai5idWYgfHwgdGhpcy5idWYgfHwgdW5kZWZpbmVkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2U1OENoZWNrLnZhbGlkQ2hlY2tzdW0gPSBmdW5jdGlvbiB2YWxpZENoZWNrc3VtKGRhdGEsIGNoZWNrc3VtKSB7XG4gIGlmIChfLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKEJhc2U1OC5kZWNvZGUoZGF0YSkpO1xuICB9XG4gIGlmIChfLmlzU3RyaW5nKGNoZWNrc3VtKSkge1xuICAgIGNoZWNrc3VtID0gIEJ1ZmZlci5mcm9tKEJhc2U1OC5kZWNvZGUoY2hlY2tzdW0pKTtcbiAgfVxuICBpZiAoIWNoZWNrc3VtKSB7XG4gICAgY2hlY2tzdW0gPSBkYXRhLnNsaWNlKC00KTtcbiAgICBkYXRhID0gZGF0YS5zbGljZSgwLCAtNCk7XG4gIH1cbiAgcmV0dXJuIEJhc2U1OENoZWNrLmNoZWNrc3VtKGRhdGEpLnRvU3RyaW5nKCdoZXgnKSA9PT0gY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpO1xufTtcblxuQmFzZTU4Q2hlY2suZGVjb2RlID0gZnVuY3Rpb24ocykge1xuICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG4gIHZhciBidWYgPSBCdWZmZXIuZnJvbShCYXNlNTguZGVjb2RlKHMpKTtcblxuICBpZiAoYnVmLmxlbmd0aCA8IDQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc3RyaW5nIHRvbyBzaG9ydFwiKTtcblxuICB2YXIgZGF0YSA9IGJ1Zi5zbGljZSgwLCAtNCk7XG4gIHZhciBjc3VtID0gYnVmLnNsaWNlKC00KTtcblxuICB2YXIgaGFzaCA9IHNoYTI1NnNoYTI1NihkYXRhKTtcbiAgdmFyIGhhc2g0ID0gaGFzaC5zbGljZSgwLCA0KTtcblxuICBpZiAoY3N1bS50b1N0cmluZygnaGV4JykgIT09IGhhc2g0LnRvU3RyaW5nKCdoZXgnKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGVja3N1bSBtaXNtYXRjaFwiKTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cbkJhc2U1OENoZWNrLmNoZWNrc3VtID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHJldHVybiBzaGEyNTZzaGEyNTYoYnVmZmVyKS5zbGljZSgwLCA0KTtcbn07XG5cbkJhc2U1OENoZWNrLmVuY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKVxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIGJ1ZmZlcicpO1xuICB2YXIgY2hlY2tlZEJ1ZiA9IEJ1ZmZlci5hbGxvYyhidWYubGVuZ3RoICsgNCk7XG4gIHZhciBoYXNoID0gQmFzZTU4Q2hlY2suY2hlY2tzdW0oYnVmKTtcbiAgYnVmLmNvcHkoY2hlY2tlZEJ1Zik7XG4gIGhhc2guY29weShjaGVja2VkQnVmLCBidWYubGVuZ3RoKTtcbiAgcmV0dXJuIEJhc2U1OC5lbmNvZGUoY2hlY2tlZEJ1Zik7XG59O1xuXG5CYXNlNThDaGVjay5wcm90b3R5cGUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xuICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlNThDaGVjay5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgYnVmID0gQmFzZTU4Q2hlY2suZGVjb2RlKHN0cik7XG4gIHRoaXMuYnVmID0gYnVmO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2U1OENoZWNrLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5idWY7XG59O1xuXG5CYXNlNThDaGVjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEJhc2U1OENoZWNrLmVuY29kZSh0aGlzLmJ1Zik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U1OENoZWNrO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/bech32.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/bech32.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bech32 = __webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/bech32/dist/index.js\");\n\n/**\n * Decode bech32/bech32m string\n * @param {String} str String to decode\n * @returns {Object} Decoded string info\n */\nvar decode = function(str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n\n  var decoded;\n  let fromWords = bech32.bech32.fromWords;\n  let encoding = encodings.BECH32;\n  try {\n    decoded = bech32.bech32.decode(str);\n  } catch (e) {\n    if (e.message.indexOf('Invalid checksum') > -1) {\n      decoded = bech32.bech32m.decode(str);\n      encoding = encodings.BECH32M;\n      fromWords = bech32.bech32m.fromWords;\n    } else {\n      throw e;\n    }\n  }\n\n  const version = decoded.words[0];\n  if (version >= 1 && encoding !== encodings.BECH32M) {\n    throw new Error('Version 1+ witness address must use Bech32m checksum');\n  }\n\n  return {\n    prefix: decoded.prefix,\n    data: Buffer.from(fromWords(decoded.words.slice(1))),\n    version\n  };\n};\n\n/**\n * Encode using BECH32 encoding\n * @param {String} prefix bech32 prefix\n * @param {Number} version\n * @param {String|Buffer} data \n * @param {String|Number} encoding (optional, default=bech32) Valid encodings are 'bech32', 'bech32m', 0, and 1.\n * @returns {String} encoded string\n */\nvar encode = function(prefix, version, data, encoding) {\n\tif (typeof prefix !== 'string') {\n\t\tthrow new Error('Prefix should be a string');\n\t}\n\tif (typeof version !== 'number') {\n\t\tthrow new Error('version should be a number');\n\t}\n  // convert string to number\n  if (encoding && typeof encoding == 'string') {\n    encoding = encodings[encoding.toUpperCase()] || -1; // fallback to -1 so it throws invalid encoding below\n  }\n  if (encoding && !(encoding == encodings.BECH32 || encoding == encodings.BECH32M)) {\n    throw new Error('Invalid encoding specified');\n  }\n  \n  let b32Variety = encoding == encodings.BECH32M ? bech32.bech32m : bech32.bech32;\n  let words = b32Variety.toWords(data);\n\n  words.unshift(version);\n\treturn b32Variety.encode(prefix, words);\n}\n\nconst encodings = {\n  BECH32: 1,\n  BECH32M: 2\n}\n\nmodule.exports = { decode: decode, encode: encode, encodings };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2JlY2gzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMseURBQVE7O0FBRTdCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvZW5jb2RpbmcvYmVjaDMyLmpzPzY2NmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmVjaDMyID0gcmVxdWlyZSgnYmVjaDMyJyk7XG5cbi8qKlxuICogRGVjb2RlIGJlY2gzMi9iZWNoMzJtIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBEZWNvZGVkIHN0cmluZyBpbmZvXG4gKi9cbnZhciBkZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBkZWNvZGVkO1xuICBsZXQgZnJvbVdvcmRzID0gYmVjaDMyLmJlY2gzMi5mcm9tV29yZHM7XG4gIGxldCBlbmNvZGluZyA9IGVuY29kaW5ncy5CRUNIMzI7XG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IGJlY2gzMi5iZWNoMzIuZGVjb2RlKHN0cik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5tZXNzYWdlLmluZGV4T2YoJ0ludmFsaWQgY2hlY2tzdW0nKSA+IC0xKSB7XG4gICAgICBkZWNvZGVkID0gYmVjaDMyLmJlY2gzMm0uZGVjb2RlKHN0cik7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5ncy5CRUNIMzJNO1xuICAgICAgZnJvbVdvcmRzID0gYmVjaDMyLmJlY2gzMm0uZnJvbVdvcmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHZlcnNpb24gPSBkZWNvZGVkLndvcmRzWzBdO1xuICBpZiAodmVyc2lvbiA+PSAxICYmIGVuY29kaW5nICE9PSBlbmNvZGluZ3MuQkVDSDMyTSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmVyc2lvbiAxKyB3aXRuZXNzIGFkZHJlc3MgbXVzdCB1c2UgQmVjaDMybSBjaGVja3N1bScpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwcmVmaXg6IGRlY29kZWQucHJlZml4LFxuICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGZyb21Xb3JkcyhkZWNvZGVkLndvcmRzLnNsaWNlKDEpKSksXG4gICAgdmVyc2lvblxuICB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGUgdXNpbmcgQkVDSDMyIGVuY29kaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IGJlY2gzMiBwcmVmaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGRhdGEgXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGVuY29kaW5nIChvcHRpb25hbCwgZGVmYXVsdD1iZWNoMzIpIFZhbGlkIGVuY29kaW5ncyBhcmUgJ2JlY2gzMicsICdiZWNoMzJtJywgMCwgYW5kIDEuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBlbmNvZGVkIHN0cmluZ1xuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24ocHJlZml4LCB2ZXJzaW9uLCBkYXRhLCBlbmNvZGluZykge1xuXHRpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZWZpeCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcblx0fVxuXHRpZiAodHlwZW9mIHZlcnNpb24gIT09ICdudW1iZXInKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd2ZXJzaW9uIHNob3VsZCBiZSBhIG51bWJlcicpO1xuXHR9XG4gIC8vIGNvbnZlcnQgc3RyaW5nIHRvIG51bWJlclxuICBpZiAoZW5jb2RpbmcgJiYgdHlwZW9mIGVuY29kaW5nID09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZ3NbZW5jb2RpbmcudG9VcHBlckNhc2UoKV0gfHwgLTE7IC8vIGZhbGxiYWNrIHRvIC0xIHNvIGl0IHRocm93cyBpbnZhbGlkIGVuY29kaW5nIGJlbG93XG4gIH1cbiAgaWYgKGVuY29kaW5nICYmICEoZW5jb2RpbmcgPT0gZW5jb2RpbmdzLkJFQ0gzMiB8fCBlbmNvZGluZyA9PSBlbmNvZGluZ3MuQkVDSDMyTSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2Rpbmcgc3BlY2lmaWVkJyk7XG4gIH1cbiAgXG4gIGxldCBiMzJWYXJpZXR5ID0gZW5jb2RpbmcgPT0gZW5jb2RpbmdzLkJFQ0gzMk0gPyBiZWNoMzIuYmVjaDMybSA6IGJlY2gzMi5iZWNoMzI7XG4gIGxldCB3b3JkcyA9IGIzMlZhcmlldHkudG9Xb3JkcyhkYXRhKTtcblxuICB3b3Jkcy51bnNoaWZ0KHZlcnNpb24pO1xuXHRyZXR1cm4gYjMyVmFyaWV0eS5lbmNvZGUocHJlZml4LCB3b3Jkcyk7XG59XG5cbmNvbnN0IGVuY29kaW5ncyA9IHtcbiAgQkVDSDMyOiAxLFxuICBCRUNIMzJNOiAyXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWNvZGU6IGRlY29kZSwgZW5jb2RlOiBlbmNvZGUsIGVuY29kaW5ncyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/bech32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js":
/*!***************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/bufferreader.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\n\nvar BufferReader = function BufferReader(buf) {\n  if (!(this instanceof BufferReader)) {\n    return new BufferReader(buf);\n  }\n  if (_.isUndefined(buf)) {\n    return;\n  }\n  if (Buffer.isBuffer(buf)) {\n    this.set({\n      buf: buf\n    });\n  } else if (_.isString(buf)) {\n    this.set({\n      buf: Buffer.from(buf, 'hex'),\n    });\n  } else if (_.isObject(buf)) {\n    var obj = buf;\n    this.set(obj);\n  } else {\n    throw new TypeError('Unrecognized argument for BufferReader');\n  }\n};\n\nBufferReader.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  this.pos = obj.pos || this.pos || 0;\n  return this;\n};\n\nBufferReader.prototype.eof = function() {\n  if(this.buf) {\n    return this.pos >= this.buf.length;\n  } else {\n    return true;\n  }\n};\n\nBufferReader.prototype.finished = BufferReader.prototype.eof;\n\nBufferReader.prototype.read = function(len) {\n  $.checkArgument(!_.isUndefined(len), 'Must specify a length');\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos = this.pos + len;\n  return buf;\n};\n\nBufferReader.prototype.readAll = function() {\n  var buf = this.buf.slice(this.pos, this.buf.length);\n  this.pos = this.buf.length;\n  return buf;\n};\n\nBufferReader.prototype.readUInt8 = function() {\n  var val = this.buf.readUInt8(this.pos);\n  this.pos = this.pos + 1;\n  return val;\n};\n\nBufferReader.prototype.readUInt16BE = function() {\n  var val = this.buf.readUInt16BE(this.pos);\n  this.pos = this.pos + 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt16LE = function() {\n  var val = this.buf.readUInt16LE(this.pos);\n  this.pos = this.pos + 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt32BE = function() {\n  var val = this.buf.readUInt32BE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt32LE = function() {\n  var val = this.buf.readUInt32LE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readInt32LE = function() {\n  var val = this.buf.readInt32LE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt64BEBN = function() {\n  var buf = this.buf.slice(this.pos, this.pos + 8);\n  var bn = BN.fromBuffer(buf);\n  this.pos = this.pos + 8;\n  return bn;\n};\n\nBufferReader.prototype.readUInt64LEBN = function() {\n  var second = this.buf.readUInt32LE(this.pos);\n  var first = this.buf.readUInt32LE(this.pos + 4);\n  var combined = (first * 0x100000000) + second;\n  // Instantiating an instance of BN with a number is faster than with an\n  // array or string. However, the maximum safe number for a double precision\n  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use\n  // non-floating point numbers less than this amount (52 bits). And in the case\n  // that the number is larger, we can instatiate an instance of BN by passing\n  // an array from the buffer (slower) and specifying the endianness.\n  var bn;\n  if (combined <= 0x1fffffffffffff) {\n    bn = new BN(combined);\n  } else {\n    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);\n    bn = new BN(data, 10, 'le');\n  }\n  this.pos = this.pos + 8;\n  return bn;\n};\n\nBufferReader.prototype.readVarintNum = function() {\n  var first = this.readUInt8();\n  switch (first) {\n    case 0xFD:\n      return this.readUInt16LE();\n    case 0xFE:\n      return this.readUInt32LE();\n    case 0xFF:\n      var bn = this.readUInt64LEBN();\n      var n = bn.toNumber();\n      if (n <= Math.pow(2, 53)) {\n        return n;\n      } else {\n        throw new Error('number too large to retain precision - use readVarintBN');\n      }\n      break;\n    default:\n      return first;\n  }\n};\n\n/**\n * reads a length prepended buffer\n */\nBufferReader.prototype.readVarLengthBuffer = function() {\n  var len = this.readVarintNum();\n  var buf = this.read(len);\n  $.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' +\n    'Expected to read: ' + len + ' and read ' + buf.length);\n  return buf;\n};\n\nBufferReader.prototype.readVarintBuf = function() {\n  var first = this.buf.readUInt8(this.pos);\n  switch (first) {\n    case 0xFD:\n      return this.read(1 + 2);\n    case 0xFE:\n      return this.read(1 + 4);\n    case 0xFF:\n      return this.read(1 + 8);\n    default:\n      return this.read(1);\n  }\n};\n\nBufferReader.prototype.readVarintBN = function() {\n  var first = this.readUInt8();\n  switch (first) {\n    case 0xFD:\n      return new BN(this.readUInt16LE());\n    case 0xFE:\n      return new BN(this.readUInt32LE());\n    case 0xFF:\n      return this.readUInt64LEBN();\n    default:\n      return new BN(first);\n  }\n};\n\nBufferReader.prototype.reverse = function() {\n  var buf = Buffer.alloc(this.buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf[i] = this.buf[this.buf.length - 1 - i];\n  }\n  this.buf = buf;\n  return this;\n};\n\nBufferReader.prototype.readReverse = function(len) {\n  if (_.isUndefined(len)) {\n    len = this.buf.length;\n  }\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos = this.pos + len;\n  return BufferUtil.reverse(buf);\n};\n\nmodule.exports = BufferReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2J1ZmZlcnJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHlGQUF1QjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsU0FBUyxtQkFBTyxDQUFDLHVFQUFjOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9lbmNvZGluZy9idWZmZXJyZWFkZXIuanM/NzdhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xudmFyIEJOID0gcmVxdWlyZSgnLi4vY3J5cHRvL2JuJyk7XG5cbnZhciBCdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXJSZWFkZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJSZWFkZXIoYnVmKTtcbiAgfVxuICBpZiAoXy5pc1VuZGVmaW5lZChidWYpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRoaXMuc2V0KHtcbiAgICAgIGJ1ZjogYnVmXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhidWYpKSB7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgYnVmOiBCdWZmZXIuZnJvbShidWYsICdoZXgnKSxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KGJ1ZikpIHtcbiAgICB2YXIgb2JqID0gYnVmO1xuICAgIHRoaXMuc2V0KG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIGFyZ3VtZW50IGZvciBCdWZmZXJSZWFkZXInKTtcbiAgfVxufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5idWYgPSBvYmouYnVmIHx8IHRoaXMuYnVmIHx8IHVuZGVmaW5lZDtcbiAgdGhpcy5wb3MgPSBvYmoucG9zIHx8IHRoaXMucG9zIHx8IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5lb2YgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5idWYpIHtcbiAgICByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5idWYubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLmZpbmlzaGVkID0gQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5lb2Y7XG5cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGxlbikge1xuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQobGVuKSwgJ011c3Qgc3BlY2lmeSBhIGxlbmd0aCcpO1xuICB2YXIgYnVmID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgbGVuKTtcbiAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbjtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZEFsbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVmID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIHRoaXMuYnVmLmxlbmd0aCk7XG4gIHRoaXMucG9zID0gdGhpcy5idWYubGVuZ3RoO1xuICByZXR1cm4gYnVmO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50OCh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyAxO1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MTZCRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyAyO1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MTZMRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyAyO1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJCRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyA0O1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyA0O1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEludDMyTEUodGhpcy5wb3MpO1xuICB0aGlzLnBvcyA9IHRoaXMucG9zICsgNDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQ2NEJFQk4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZiA9IHRoaXMuYnVmLnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIDgpO1xuICB2YXIgYm4gPSBCTi5mcm9tQnVmZmVyKGJ1Zik7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyA4O1xuICByZXR1cm4gYm47XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRVSW50NjRMRUJOID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWNvbmQgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpO1xuICB2YXIgZmlyc3QgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MgKyA0KTtcbiAgdmFyIGNvbWJpbmVkID0gKGZpcnN0ICogMHgxMDAwMDAwMDApICsgc2Vjb25kO1xuICAvLyBJbnN0YW50aWF0aW5nIGFuIGluc3RhbmNlIG9mIEJOIHdpdGggYSBudW1iZXIgaXMgZmFzdGVyIHRoYW4gd2l0aCBhblxuICAvLyBhcnJheSBvciBzdHJpbmcuIEhvd2V2ZXIsIHRoZSBtYXhpbXVtIHNhZmUgbnVtYmVyIGZvciBhIGRvdWJsZSBwcmVjaXNpb25cbiAgLy8gZmxvYXRpbmcgcG9pbnQgaXMgMiBeIDUyIC0gMSAoMHgxZmZmZmZmZmZmZmZmZiksIHRodXMgd2UgY2FuIHNhZmVseSB1c2VcbiAgLy8gbm9uLWZsb2F0aW5nIHBvaW50IG51bWJlcnMgbGVzcyB0aGFuIHRoaXMgYW1vdW50ICg1MiBiaXRzKS4gQW5kIGluIHRoZSBjYXNlXG4gIC8vIHRoYXQgdGhlIG51bWJlciBpcyBsYXJnZXIsIHdlIGNhbiBpbnN0YXRpYXRlIGFuIGluc3RhbmNlIG9mIEJOIGJ5IHBhc3NpbmdcbiAgLy8gYW4gYXJyYXkgZnJvbSB0aGUgYnVmZmVyIChzbG93ZXIpIGFuZCBzcGVjaWZ5aW5nIHRoZSBlbmRpYW5uZXNzLlxuICB2YXIgYm47XG4gIGlmIChjb21iaW5lZCA8PSAweDFmZmZmZmZmZmZmZmZmKSB7XG4gICAgYm4gPSBuZXcgQk4oY29tYmluZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5idWYsIHRoaXMucG9zLCB0aGlzLnBvcyArIDgpO1xuICAgIGJuID0gbmV3IEJOKGRhdGEsIDEwLCAnbGUnKTtcbiAgfVxuICB0aGlzLnBvcyA9IHRoaXMucG9zICsgODtcbiAgcmV0dXJuIGJuO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVmFyaW50TnVtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmaXJzdCA9IHRoaXMucmVhZFVJbnQ4KCk7XG4gIHN3aXRjaCAoZmlyc3QpIHtcbiAgICBjYXNlIDB4RkQ6XG4gICAgICByZXR1cm4gdGhpcy5yZWFkVUludDE2TEUoKTtcbiAgICBjYXNlIDB4RkU6XG4gICAgICByZXR1cm4gdGhpcy5yZWFkVUludDMyTEUoKTtcbiAgICBjYXNlIDB4RkY6XG4gICAgICB2YXIgYm4gPSB0aGlzLnJlYWRVSW50NjRMRUJOKCk7XG4gICAgICB2YXIgbiA9IGJuLnRvTnVtYmVyKCk7XG4gICAgICBpZiAobiA8PSBNYXRoLnBvdygyLCA1MykpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciB0b28gbGFyZ2UgdG8gcmV0YWluIHByZWNpc2lvbiAtIHVzZSByZWFkVmFyaW50Qk4nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gIH1cbn07XG5cbi8qKlxuICogcmVhZHMgYSBsZW5ndGggcHJlcGVuZGVkIGJ1ZmZlclxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRWYXJMZW5ndGhCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxlbiA9IHRoaXMucmVhZFZhcmludE51bSgpO1xuICB2YXIgYnVmID0gdGhpcy5yZWFkKGxlbik7XG4gICQuY2hlY2tTdGF0ZShidWYubGVuZ3RoID09PSBsZW4sICdJbnZhbGlkIGxlbmd0aCB3aGlsZSByZWFkaW5nIHZhcmxlbmd0aCBidWZmZXIuICcgK1xuICAgICdFeHBlY3RlZCB0byByZWFkOiAnICsgbGVuICsgJyBhbmQgcmVhZCAnICsgYnVmLmxlbmd0aCk7XG4gIHJldHVybiBidWY7XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRWYXJpbnRCdWYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpcnN0ID0gdGhpcy5idWYucmVhZFVJbnQ4KHRoaXMucG9zKTtcbiAgc3dpdGNoIChmaXJzdCkge1xuICAgIGNhc2UgMHhGRDpcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoMSArIDIpO1xuICAgIGNhc2UgMHhGRTpcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoMSArIDQpO1xuICAgIGNhc2UgMHhGRjpcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoMSArIDgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKDEpO1xuICB9XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRWYXJpbnRCTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlyc3QgPSB0aGlzLnJlYWRVSW50OCgpO1xuICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgY2FzZSAweEZEOlxuICAgICAgcmV0dXJuIG5ldyBCTih0aGlzLnJlYWRVSW50MTZMRSgpKTtcbiAgICBjYXNlIDB4RkU6XG4gICAgICByZXR1cm4gbmV3IEJOKHRoaXMucmVhZFVJbnQzMkxFKCkpO1xuICAgIGNhc2UgMHhGRjpcbiAgICAgIHJldHVybiB0aGlzLnJlYWRVSW50NjRMRUJOKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgQk4oZmlyc3QpO1xuICB9XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyh0aGlzLmJ1Zi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZltpXSA9IHRoaXMuYnVmW3RoaXMuYnVmLmxlbmd0aCAtIDEgLSBpXTtcbiAgfVxuICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRSZXZlcnNlID0gZnVuY3Rpb24obGVuKSB7XG4gIGlmIChfLmlzVW5kZWZpbmVkKGxlbikpIHtcbiAgICBsZW4gPSB0aGlzLmJ1Zi5sZW5ndGg7XG4gIH1cbiAgdmFyIGJ1ZiA9IHRoaXMuYnVmLnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIGxlbik7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyBsZW47XG4gIHJldHVybiBCdWZmZXJVdGlsLnJldmVyc2UoYnVmKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js":
/*!***************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/bufferwriter.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\nvar BufferWriter = function BufferWriter(obj) {\n  if (!(this instanceof BufferWriter))\n    return new BufferWriter(obj);\n  this.bufLen = 0;\n  if (obj)\n    this.set(obj);\n  else\n    this.bufs = [];\n};\n\nBufferWriter.prototype.set = function(obj) {\n  this.bufs = obj.bufs || this.bufs || [];\n  this.bufLen = this.bufs.reduce(function(prev, buf){ return prev + buf.length; }, 0);\n  return this;\n};\n\nBufferWriter.prototype.toBuffer = function() {\n  return this.concat();\n};\n\nBufferWriter.prototype.concat = function() {\n  return Buffer.concat(this.bufs, this.bufLen);\n};\n\nBufferWriter.prototype.write = function(buf) {\n  assert(bufferUtil.isBuffer(buf));\n  this.bufs.push(buf);\n  this.bufLen += buf.length;\n  return this;\n};\n\nBufferWriter.prototype.writeReverse = function(buf) {\n  assert(bufferUtil.isBuffer(buf));\n  this.bufs.push(bufferUtil.reverse(buf));\n  this.bufLen += buf.length;\n  return this;\n};\n\nBufferWriter.prototype.writeUInt8 = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16BE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16LE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32BE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeInt32LE = function(n) {\n  var buf = Buffer.alloc(4);\n  buf.writeInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32LE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64BEBN = function(bn) {\n  var buf = bn.toBuffer({size: 8});\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64LEBN = function(bn) {\n  var buf = bn.toBuffer({size: 8});\n  this.writeReverse(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintNum = function(n) {\n  var buf = BufferWriter.varintBufNum(n);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintBN = function(bn) {\n  var buf = BufferWriter.varintBufBN(bn);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.varintBufNum = function(n) {\n  var buf = undefined;\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    buf = Buffer.alloc(1 + 8);\n    buf.writeUInt8(255, 0);\n    buf.writeInt32LE(n & -1, 1);\n    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);\n  }\n  return buf;\n};\n\nBufferWriter.varintBufBN = function(bn) {\n  var buf = undefined;\n  var n = bn.toNumber();\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    var bw = new BufferWriter();\n    bw.writeUInt8(255);\n    bw.writeUInt64LEBN(bn);\n    var buf = bw.concat();\n  }\n  return buf;\n};\n\nmodule.exports = BufferWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2J1ZmZlcndyaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHNCQUFROztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCwyQkFBMkI7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvZW5jb2RpbmcvYnVmZmVyd3JpdGVyLmpzPzA2NTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBCdWZmZXJXcml0ZXIgPSBmdW5jdGlvbiBCdWZmZXJXcml0ZXIob2JqKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXJXcml0ZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKG9iaik7XG4gIHRoaXMuYnVmTGVuID0gMDtcbiAgaWYgKG9iailcbiAgICB0aGlzLnNldChvYmopO1xuICBlbHNlXG4gICAgdGhpcy5idWZzID0gW107XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xuICB0aGlzLmJ1ZnMgPSBvYmouYnVmcyB8fCB0aGlzLmJ1ZnMgfHwgW107XG4gIHRoaXMuYnVmTGVuID0gdGhpcy5idWZzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBidWYpeyByZXR1cm4gcHJldiArIGJ1Zi5sZW5ndGg7IH0sIDApO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29uY2F0KCk7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZnMsIHRoaXMuYnVmTGVuKTtcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWYpIHtcbiAgYXNzZXJ0KGJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHRoaXMuYnVmcy5wdXNoKGJ1Zik7XG4gIHRoaXMuYnVmTGVuICs9IGJ1Zi5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVJldmVyc2UgPSBmdW5jdGlvbihidWYpIHtcbiAgYXNzZXJ0KGJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHRoaXMuYnVmcy5wdXNoKGJ1ZmZlclV0aWwucmV2ZXJzZShidWYpKTtcbiAgdGhpcy5idWZMZW4gKz0gYnVmLmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbihuKSB7XG4gIGlmIChuIDwgMCkge1xuICAgIG4gPSBuID4+PiAwOyAvLyBDb252ZXJ0IHNpZ25lZCBpbnQgdG8gdW5zaWduZWQgaW50XG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgYnVmLndyaXRlVUludDgobiwgMCk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbihuKSB7XG4gIGlmIChuIDwgMCkge1xuICAgIG4gPSBuID4+PiAwOyAvLyBDb252ZXJ0IHNpZ25lZCBpbnQgdG8gdW5zaWduZWQgaW50XG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygyKTtcbiAgYnVmLndyaXRlVUludDE2QkUobiwgMCk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbihuKSB7XG4gIGlmIChuIDwgMCkge1xuICAgIG4gPSBuID4+PiAwOyAvLyBDb252ZXJ0IHNpZ25lZCBpbnQgdG8gdW5zaWduZWQgaW50XG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygyKTtcbiAgYnVmLndyaXRlVUludDE2TEUobiwgMCk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbihuKSB7XG4gIGlmIChuIDwgMCkge1xuICAgIG4gPSBuID4+PiAwOyAvLyBDb252ZXJ0IHNpZ25lZCBpbnQgdG8gdW5zaWduZWQgaW50XG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgYnVmLndyaXRlVUludDMyQkUobiwgMCk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgYnVmLndyaXRlSW50MzJMRShuLCAwKTtcbiAgdGhpcy53cml0ZShidWYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKG4gPCAwKSB7XG4gICAgbiA9IG4gPj4+IDA7IC8vIENvbnZlcnQgc2lnbmVkIGludCB0byB1bnNpZ25lZCBpbnRcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKDQpO1xuICBidWYud3JpdGVVSW50MzJMRShuLCAwKTtcbiAgdGhpcy53cml0ZShidWYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVVSW50NjRCRUJOID0gZnVuY3Rpb24oYm4pIHtcbiAgdmFyIGJ1ZiA9IGJuLnRvQnVmZmVyKHtzaXplOiA4fSk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDY0TEVCTiA9IGZ1bmN0aW9uKGJuKSB7XG4gIHZhciBidWYgPSBibi50b0J1ZmZlcih7c2l6ZTogOH0pO1xuICB0aGlzLndyaXRlUmV2ZXJzZShidWYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVWYXJpbnROdW0gPSBmdW5jdGlvbihuKSB7XG4gIHZhciBidWYgPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKG4pO1xuICB0aGlzLndyaXRlKGJ1Zik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVZhcmludEJOID0gZnVuY3Rpb24oYm4pIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlcldyaXRlci52YXJpbnRCdWZCTihibik7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtID0gZnVuY3Rpb24obikge1xuICB2YXIgYnVmID0gdW5kZWZpbmVkO1xuICBpZiAobiA8IDI1Mykge1xuICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICBidWYud3JpdGVVSW50OChuLCAwKTtcbiAgfSBlbHNlIGlmIChuIDwgMHgxMDAwMCkge1xuICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxICsgMik7XG4gICAgYnVmLndyaXRlVUludDgoMjUzLCAwKTtcbiAgICBidWYud3JpdGVVSW50MTZMRShuLCAxKTtcbiAgfSBlbHNlIGlmIChuIDwgMHgxMDAwMDAwMDApIHtcbiAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSArIDQpO1xuICAgIGJ1Zi53cml0ZVVJbnQ4KDI1NCwgMCk7XG4gICAgYnVmLndyaXRlVUludDMyTEUobiwgMSk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmFsbG9jKDEgKyA4KTtcbiAgICBidWYud3JpdGVVSW50OCgyNTUsIDApO1xuICAgIGJ1Zi53cml0ZUludDMyTEUobiAmIC0xLCAxKTtcbiAgICBidWYud3JpdGVVSW50MzJMRShNYXRoLmZsb29yKG4gLyAweDEwMDAwMDAwMCksIDUpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5CdWZmZXJXcml0ZXIudmFyaW50QnVmQk4gPSBmdW5jdGlvbihibikge1xuICB2YXIgYnVmID0gdW5kZWZpbmVkO1xuICB2YXIgbiA9IGJuLnRvTnVtYmVyKCk7XG4gIGlmIChuIDwgMjUzKSB7XG4gICAgYnVmID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgIGJ1Zi53cml0ZVVJbnQ4KG4sIDApO1xuICB9IGVsc2UgaWYgKG4gPCAweDEwMDAwKSB7XG4gICAgYnVmID0gQnVmZmVyLmFsbG9jKDEgKyAyKTtcbiAgICBidWYud3JpdGVVSW50OCgyNTMsIDApO1xuICAgIGJ1Zi53cml0ZVVJbnQxNkxFKG4sIDEpO1xuICB9IGVsc2UgaWYgKG4gPCAweDEwMDAwMDAwMCkge1xuICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxICsgNCk7XG4gICAgYnVmLndyaXRlVUludDgoMjU0LCAwKTtcbiAgICBidWYud3JpdGVVSW50MzJMRShuLCAxKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYncgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgYncud3JpdGVVSW50OCgyNTUpO1xuICAgIGJ3LndyaXRlVUludDY0TEVCTihibik7XG4gICAgdmFyIGJ1ZiA9IGJ3LmNvbmNhdCgpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/varint.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/varint.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BufferWriter = __webpack_require__(/*! ./bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar BufferReader = __webpack_require__(/*! ./bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\n\nvar Varint = function Varint(buf) {\n  if (!(this instanceof Varint))\n    return new Varint(buf);\n  if (Buffer.isBuffer(buf)) {\n    this.buf = buf;\n  } else if (typeof buf === 'number') {\n    var num = buf;\n    this.fromNumber(num);\n  } else if (buf instanceof BN) {\n    var bn = buf;\n    this.fromBN(bn);\n  } else if (buf) {\n    var obj = buf;\n    this.set(obj);\n  }\n};\n\nVarint.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf;\n  return this;\n};\n\nVarint.prototype.fromString = function(str) {\n  this.set({\n    buf: Buffer.from(str, 'hex')\n  });\n  return this;\n};\n\nVarint.prototype.toString = function() {\n  return this.buf.toString('hex');\n};\n\nVarint.prototype.fromBuffer = function(buf) {\n  this.buf = buf;\n  return this;\n};\n\nVarint.prototype.fromBufferReader = function(br) {\n  this.buf = br.readVarintBuf();\n  return this;\n};\n\nVarint.prototype.fromBN = function(bn) {\n  this.buf = BufferWriter().writeVarintBN(bn).concat();\n  return this;\n};\n\nVarint.prototype.fromNumber = function(num) {\n  this.buf = BufferWriter().writeVarintNum(num).concat();\n  return this;\n};\n\nVarint.prototype.toBuffer = function() {\n  return this.buf;\n};\n\nVarint.prototype.toBN = function() {\n  return BufferReader(this.buf).readVarintBN();\n};\n\nVarint.prototype.toNumber = function() {\n  return BufferReader(this.buf).readVarintNum();\n};\n\nmodule.exports = Varint;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL3ZhcmludC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBZ0I7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMscUZBQWdCO0FBQzNDLFNBQVMsbUJBQU8sQ0FBQyx1RUFBYzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL3ZhcmludC5qcz8yYzAzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4vYnVmZmVyd3JpdGVyJyk7XG52YXIgQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9idWZmZXJyZWFkZXInKTtcbnZhciBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xuXG52YXIgVmFyaW50ID0gZnVuY3Rpb24gVmFyaW50KGJ1Zikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVmFyaW50KSlcbiAgICByZXR1cm4gbmV3IFZhcmludChidWYpO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnVmID09PSAnbnVtYmVyJykge1xuICAgIHZhciBudW0gPSBidWY7XG4gICAgdGhpcy5mcm9tTnVtYmVyKG51bSk7XG4gIH0gZWxzZSBpZiAoYnVmIGluc3RhbmNlb2YgQk4pIHtcbiAgICB2YXIgYm4gPSBidWY7XG4gICAgdGhpcy5mcm9tQk4oYm4pO1xuICB9IGVsc2UgaWYgKGJ1Zikge1xuICAgIHZhciBvYmogPSBidWY7XG4gICAgdGhpcy5zZXQob2JqKTtcbiAgfVxufTtcblxuVmFyaW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5idWYgPSBvYmouYnVmIHx8IHRoaXMuYnVmO1xuICByZXR1cm4gdGhpcztcbn07XG5cblZhcmludC5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICB0aGlzLnNldCh7XG4gICAgYnVmOiBCdWZmZXIuZnJvbShzdHIsICdoZXgnKVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WYXJpbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJ1Zi50b1N0cmluZygnaGV4Jyk7XG59O1xuXG5WYXJpbnQucHJvdG90eXBlLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcbiAgdGhpcy5idWYgPSBidWY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVmFyaW50LnByb3RvdHlwZS5mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24oYnIpIHtcbiAgdGhpcy5idWYgPSBici5yZWFkVmFyaW50QnVmKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVmFyaW50LnByb3RvdHlwZS5mcm9tQk4gPSBmdW5jdGlvbihibikge1xuICB0aGlzLmJ1ZiA9IEJ1ZmZlcldyaXRlcigpLndyaXRlVmFyaW50Qk4oYm4pLmNvbmNhdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblZhcmludC5wcm90b3R5cGUuZnJvbU51bWJlciA9IGZ1bmN0aW9uKG51bSkge1xuICB0aGlzLmJ1ZiA9IEJ1ZmZlcldyaXRlcigpLndyaXRlVmFyaW50TnVtKG51bSkuY29uY2F0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVmFyaW50LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5idWY7XG59O1xuXG5WYXJpbnQucHJvdG90eXBlLnRvQk4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEJ1ZmZlclJlYWRlcih0aGlzLmJ1ZikucmVhZFZhcmludEJOKCk7XG59O1xuXG5WYXJpbnQucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBCdWZmZXJSZWFkZXIodGhpcy5idWYpLnJlYWRWYXJpbnROdW0oKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFyaW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/varint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/errors/index.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/errors/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nfunction format(message, args) {\n  return message\n    .replace('{0}', args[0])\n    .replace('{1}', args[1])\n    .replace('{2}', args[2]);\n}\nvar traverseNode = function(parent, errorDefinition) {\n  var NodeError = function() {\n    if (_.isString(errorDefinition.message)) {\n      this.message = format(errorDefinition.message, arguments);\n    } else if (_.isFunction(errorDefinition.message)) {\n      this.message = errorDefinition.message.apply(null, arguments);\n    } else {\n      throw new Error('Invalid error definition for ' + errorDefinition.name);\n    }\n    this.stack = this.message + '\\n' + (new Error()).stack;\n  };\n  NodeError.prototype = Object.create(parent.prototype);\n  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;\n  parent[errorDefinition.name] = NodeError;\n  if (errorDefinition.errors) {\n    childDefinitions(NodeError, errorDefinition.errors);\n  }\n  return NodeError;\n};\n\n/* jshint latedef: false */\nvar childDefinitions = function(parent, childDefinitions) {\n  _.each(childDefinitions, function(childDefinition) {\n    traverseNode(parent, childDefinition);\n  });\n};\n/* jshint latedef: true */\n\nvar traverseRoot = function(parent, errorsDefinition) {\n  childDefinitions(parent, errorsDefinition);\n  return parent;\n};\n\n\nvar bitcore = {};\nbitcore.Error = function() {\n  this.message = 'Internal error';\n  this.stack = this.message + '\\n' + (new Error()).stack;\n};\nbitcore.Error.prototype = Object.create(Error.prototype);\nbitcore.Error.prototype.name = 'bitcore.Error';\n\n\nvar data = __webpack_require__(/*! ./spec */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/spec.js\");\ntraverseRoot(bitcore.Error, data);\n\nmodule.exports = bitcore.Error;\n\nmodule.exports.extend = function(spec) {\n  return traverseNode(bitcore.Error, spec);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Vycm9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7O0FBRXhCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsV0FBVyxtQkFBTyxDQUFDLG1FQUFRO0FBQzNCOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Vycm9ycy9pbmRleC5qcz84Mzc5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuZnVuY3Rpb24gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpIHtcbiAgcmV0dXJuIG1lc3NhZ2VcbiAgICAucmVwbGFjZSgnezB9JywgYXJnc1swXSlcbiAgICAucmVwbGFjZSgnezF9JywgYXJnc1sxXSlcbiAgICAucmVwbGFjZSgnezJ9JywgYXJnc1syXSk7XG59XG52YXIgdHJhdmVyc2VOb2RlID0gZnVuY3Rpb24ocGFyZW50LCBlcnJvckRlZmluaXRpb24pIHtcbiAgdmFyIE5vZGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChfLmlzU3RyaW5nKGVycm9yRGVmaW5pdGlvbi5tZXNzYWdlKSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gZm9ybWF0KGVycm9yRGVmaW5pdGlvbi5tZXNzYWdlLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKGVycm9yRGVmaW5pdGlvbi5tZXNzYWdlKSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JEZWZpbml0aW9uLm1lc3NhZ2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVycm9yIGRlZmluaXRpb24gZm9yICcgKyBlcnJvckRlZmluaXRpb24ubmFtZSk7XG4gICAgfVxuICAgIHRoaXMuc3RhY2sgPSB0aGlzLm1lc3NhZ2UgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gIH07XG4gIE5vZGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBwYXJlbnQucHJvdG90eXBlLm5hbWUgKyBlcnJvckRlZmluaXRpb24ubmFtZTtcbiAgcGFyZW50W2Vycm9yRGVmaW5pdGlvbi5uYW1lXSA9IE5vZGVFcnJvcjtcbiAgaWYgKGVycm9yRGVmaW5pdGlvbi5lcnJvcnMpIHtcbiAgICBjaGlsZERlZmluaXRpb25zKE5vZGVFcnJvciwgZXJyb3JEZWZpbml0aW9uLmVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIE5vZGVFcnJvcjtcbn07XG5cbi8qIGpzaGludCBsYXRlZGVmOiBmYWxzZSAqL1xudmFyIGNoaWxkRGVmaW5pdGlvbnMgPSBmdW5jdGlvbihwYXJlbnQsIGNoaWxkRGVmaW5pdGlvbnMpIHtcbiAgXy5lYWNoKGNoaWxkRGVmaW5pdGlvbnMsIGZ1bmN0aW9uKGNoaWxkRGVmaW5pdGlvbikge1xuICAgIHRyYXZlcnNlTm9kZShwYXJlbnQsIGNoaWxkRGVmaW5pdGlvbik7XG4gIH0pO1xufTtcbi8qIGpzaGludCBsYXRlZGVmOiB0cnVlICovXG5cbnZhciB0cmF2ZXJzZVJvb3QgPSBmdW5jdGlvbihwYXJlbnQsIGVycm9yc0RlZmluaXRpb24pIHtcbiAgY2hpbGREZWZpbml0aW9ucyhwYXJlbnQsIGVycm9yc0RlZmluaXRpb24pO1xuICByZXR1cm4gcGFyZW50O1xufTtcblxuXG52YXIgYml0Y29yZSA9IHt9O1xuYml0Y29yZS5FcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm1lc3NhZ2UgPSAnSW50ZXJuYWwgZXJyb3InO1xuICB0aGlzLnN0YWNrID0gdGhpcy5tZXNzYWdlICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrO1xufTtcbmJpdGNvcmUuRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuYml0Y29yZS5FcnJvci5wcm90b3R5cGUubmFtZSA9ICdiaXRjb3JlLkVycm9yJztcblxuXG52YXIgZGF0YSA9IHJlcXVpcmUoJy4vc3BlYycpO1xudHJhdmVyc2VSb290KGJpdGNvcmUuRXJyb3IsIGRhdGEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpdGNvcmUuRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgcmV0dXJuIHRyYXZlcnNlTm9kZShiaXRjb3JlLkVycm9yLCBzcGVjKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/errors/spec.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/errors/spec.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar docsURL = 'http://bitcore.io/';\n\nmodule.exports = [{\n  name: 'InvalidB58Char',\n  message: 'Invalid Base58 character: {0} in {1}'\n}, {\n  name: 'InvalidB58Checksum',\n  message: 'Invalid Base58 checksum for {0}'\n}, {\n  name: 'InvalidNetwork',\n  message: 'Invalid version for network: got {0}'\n}, {\n  name: 'InvalidState',\n  message: 'Invalid state: {0}'\n}, {\n  name: 'NotImplemented',\n  message: 'Function {0} was not implemented yet'\n}, {\n  name: 'InvalidNetworkArgument',\n  message: 'Invalid network: must be \"livenet\" or \"testnet\", got {0}'\n}, {\n  name: 'InvalidArgument',\n  message: function() {\n    return 'Invalid Argument' + (arguments[0] ? (': ' + arguments[0]) : '') +\n      (arguments[1] ? (' Documentation: ' + docsURL + arguments[1]) : '');\n  }\n}, {\n  name: 'AbstractMethodInvoked',\n  message: 'Abstract Method Invocation: {0}'\n}, {\n  name: 'InvalidArgumentType',\n  message: function() {\n    return 'Invalid Argument for ' + arguments[2] + ', expected ' + arguments[1] + ' but got ' + typeof arguments[0];\n  }\n}, {\n  name: 'Unit',\n  message: 'Internal Error on Unit {0}',\n  errors: [{\n    'name': 'UnknownCode',\n    'message': 'Unrecognized unit code: {0}'\n  }, {\n    'name': 'InvalidRate',\n    'message': 'Invalid exchange rate: {0}'\n  }]\n}, {\n  name: 'MerkleBlock',\n  message: 'Internal Error on MerkleBlock {0}',\n  errors: [{\n    'name': 'InvalidMerkleTree',\n    'message': 'This MerkleBlock contain an invalid Merkle Tree'\n  }]\n}, {\n  name: 'Transaction',\n  message: 'Internal Error on Transaction {0}',\n  errors: [{\n    name: 'Input',\n    message: 'Internal Error on Input {0}',\n    errors: [{\n      name: 'MissingScript',\n      message: 'Need a script to create an input'\n    }, {\n      name: 'UnsupportedScript',\n      message: 'Unsupported input script type: {0}'\n    }, {\n      name: 'MissingPreviousOutput',\n      message: 'No previous output information.'\n    }, {\n      name: 'BlockHeightOutOfRange',\n      message: 'Block Height can only be between 0 and 65535'\n    } , {\n      name: 'LockTimeRange',\n      message: 'Seconds needs to be more that 0 and less that 33553920'\n    }\n    ]\n  }, {\n    name: 'NeedMoreInfo',\n    message: '{0}'\n  }, {\n    name: 'InvalidSorting',\n    message: 'The sorting function provided did not return the change output as one of the array elements'\n  }, {\n    name: 'InvalidOutputAmountSum',\n    message: '{0}'\n  }, {\n    name: 'MissingSignatures',\n    message: 'Some inputs have not been fully signed'\n  }, {\n    name: 'InvalidIndex',\n    message: 'Invalid index: {0} is not between 0, {1}'\n  }, {\n    name: 'UnableToVerifySignature',\n    message: 'Unable to verify signature: {0}'\n  }, {\n    name: 'DustOutputs',\n    message: 'Dust amount detected in one output'\n  }, {\n    name: 'InvalidSatoshis',\n    message: 'Output satoshis are invalid',\n  }, {\n    name: 'FeeError',\n    message: 'Internal Error on Fee {0}',\n    errors: [{\n      name: 'TooSmall',\n      message: 'Fee is too small: {0}',\n    }, {\n      name: 'TooLarge',\n      message: 'Fee is too large: {0}',\n    }, {\n      name: 'Different',\n      message: 'Unspent value is different from specified fee: {0}',\n    }]\n  }, {\n    name: 'ChangeAddressMissing',\n    message: 'Change address is missing'\n  }, {\n    name: 'BlockHeightTooHigh',\n    message: 'Block Height can be at most 2^32 -1'\n  }, {\n    name: 'NLockTimeOutOfRange',\n    message: 'Block Height can only be between 0 and 499 999 999'\n  }, {\n    name: 'LockTimeTooEarly',\n    message: 'Lock Time can\\'t be earlier than UNIX date 500 000 000'\n  }]\n}, {\n  name: 'Script',\n  message: 'Internal Error on Script {0}',\n  errors: [{\n    name: 'UnrecognizedAddress',\n    message: 'Expected argument {0} to be an address'\n  }, {\n    name: 'CantDeriveAddress',\n    message: 'Can\\'t derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.'\n  }, {\n    name: 'InvalidBuffer',\n    message: 'Invalid script buffer: can\\'t parse valid script from given buffer {0}'\n  }]\n}, {\n  name: 'HDPrivateKey',\n  message: 'Internal Error on HDPrivateKey {0}',\n  errors: [{\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument {0}, expected string, or number and boolean'\n  }, {\n    name: 'InvalidEntropyArgument',\n    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',\n    errors: [{\n      name: 'TooMuchEntropy',\n      message: 'Invalid entropy: more than 512 bits is non standard, got \"{0}\"'\n    }, {\n      name: 'NotEnoughEntropy',\n      message: 'Invalid entropy: at least 128 bits needed, got \"{0}\"'\n    }]\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xprivkey string in {0}'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path: {0}'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got \"{0}\"'\n  }]\n}, {\n  name: 'HDPublicKey',\n  message: 'Internal Error on HDPublicKey {0}',\n  errors: [{\n    name: 'ArgumentIsPrivateExtended',\n    message: 'Argument is an extended private key: {0}'\n  }, {\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument: got {0}'\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xpubkey: got \"{0}\"'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path, it should look like: \"m/1/100\", got \"{0}\"'\n  }, {\n    name: 'InvalidIndexCantDeriveHardened',\n    message: 'Invalid argument: creating a hardened path requires an HDPrivateKey'\n  }, {\n    name: 'MustSupplyArgument',\n    message: 'Must supply an argument to create a HDPublicKey'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument for creation, must be string, json, buffer, or object'\n  }]\n}];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Vycm9ycy9zcGVjLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRyxJQUFJLEVBQUU7QUFDaEQsQ0FBQztBQUNEO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0MsQ0FBQztBQUNEO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLEVBQUU7QUFDOUIsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLEdBQUc7QUFDekIsQ0FBQztBQUNEO0FBQ0Esa0VBQWtFLEVBQUU7QUFDcEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5Q0FBeUMsRUFBRTtBQUMzQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0MsR0FBRztBQUNIO0FBQ0Esd0NBQXdDLEVBQUU7QUFDMUMsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsRUFBRTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsRUFBRTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixHQUFHLG1CQUFtQixFQUFFO0FBQ3RELEdBQUc7QUFDSDtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QztBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckMsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckMsS0FBSztBQUNMO0FBQ0EsZ0VBQWdFLEVBQUU7QUFDbEUsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLHNDQUFzQyxFQUFFO0FBQ3hDO0FBQ0E7QUFDQSxpQ0FBaUMsR0FBRztBQUNwQyxHQUFHO0FBQ0g7QUFDQSw0REFBNEQsRUFBRTtBQUM5RCxHQUFHO0FBQ0g7QUFDQSxrRkFBa0YsRUFBRTtBQUNwRixHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDLEdBQUc7QUFDSDtBQUNBLDZFQUE2RSxFQUFFO0FBQy9FO0FBQ0E7QUFDQSwyRUFBMkUsRUFBRTtBQUM3RSxLQUFLO0FBQ0w7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EscURBQXFELEVBQUU7QUFDdkQsR0FBRztBQUNIO0FBQ0Esd0NBQXdDLEVBQUU7QUFDMUMsR0FBRztBQUNIO0FBQ0EseUdBQXlHLEVBQUU7QUFDM0csR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RCxHQUFHO0FBQ0g7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRCxHQUFHO0FBQ0g7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRCxHQUFHO0FBQ0g7QUFDQSw2RUFBNkUsRUFBRTtBQUMvRSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9lcnJvcnMvc3BlYy5qcz9kMWU5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGRvY3NVUkwgPSAnaHR0cDovL2JpdGNvcmUuaW8vJztcblxubW9kdWxlLmV4cG9ydHMgPSBbe1xuICBuYW1lOiAnSW52YWxpZEI1OENoYXInLFxuICBtZXNzYWdlOiAnSW52YWxpZCBCYXNlNTggY2hhcmFjdGVyOiB7MH0gaW4gezF9J1xufSwge1xuICBuYW1lOiAnSW52YWxpZEI1OENoZWNrc3VtJyxcbiAgbWVzc2FnZTogJ0ludmFsaWQgQmFzZTU4IGNoZWNrc3VtIGZvciB7MH0nXG59LCB7XG4gIG5hbWU6ICdJbnZhbGlkTmV0d29yaycsXG4gIG1lc3NhZ2U6ICdJbnZhbGlkIHZlcnNpb24gZm9yIG5ldHdvcms6IGdvdCB7MH0nXG59LCB7XG4gIG5hbWU6ICdJbnZhbGlkU3RhdGUnLFxuICBtZXNzYWdlOiAnSW52YWxpZCBzdGF0ZTogezB9J1xufSwge1xuICBuYW1lOiAnTm90SW1wbGVtZW50ZWQnLFxuICBtZXNzYWdlOiAnRnVuY3Rpb24gezB9IHdhcyBub3QgaW1wbGVtZW50ZWQgeWV0J1xufSwge1xuICBuYW1lOiAnSW52YWxpZE5ldHdvcmtBcmd1bWVudCcsXG4gIG1lc3NhZ2U6ICdJbnZhbGlkIG5ldHdvcms6IG11c3QgYmUgXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCIsIGdvdCB7MH0nXG59LCB7XG4gIG5hbWU6ICdJbnZhbGlkQXJndW1lbnQnLFxuICBtZXNzYWdlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ0ludmFsaWQgQXJndW1lbnQnICsgKGFyZ3VtZW50c1swXSA/ICgnOiAnICsgYXJndW1lbnRzWzBdKSA6ICcnKSArXG4gICAgICAoYXJndW1lbnRzWzFdID8gKCcgRG9jdW1lbnRhdGlvbjogJyArIGRvY3NVUkwgKyBhcmd1bWVudHNbMV0pIDogJycpO1xuICB9XG59LCB7XG4gIG5hbWU6ICdBYnN0cmFjdE1ldGhvZEludm9rZWQnLFxuICBtZXNzYWdlOiAnQWJzdHJhY3QgTWV0aG9kIEludm9jYXRpb246IHswfSdcbn0sIHtcbiAgbmFtZTogJ0ludmFsaWRBcmd1bWVudFR5cGUnLFxuICBtZXNzYWdlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ0ludmFsaWQgQXJndW1lbnQgZm9yICcgKyBhcmd1bWVudHNbMl0gKyAnLCBleHBlY3RlZCAnICsgYXJndW1lbnRzWzFdICsgJyBidXQgZ290ICcgKyB0eXBlb2YgYXJndW1lbnRzWzBdO1xuICB9XG59LCB7XG4gIG5hbWU6ICdVbml0JyxcbiAgbWVzc2FnZTogJ0ludGVybmFsIEVycm9yIG9uIFVuaXQgezB9JyxcbiAgZXJyb3JzOiBbe1xuICAgICduYW1lJzogJ1Vua25vd25Db2RlJyxcbiAgICAnbWVzc2FnZSc6ICdVbnJlY29nbml6ZWQgdW5pdCBjb2RlOiB7MH0nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdJbnZhbGlkUmF0ZScsXG4gICAgJ21lc3NhZ2UnOiAnSW52YWxpZCBleGNoYW5nZSByYXRlOiB7MH0nXG4gIH1dXG59LCB7XG4gIG5hbWU6ICdNZXJrbGVCbG9jaycsXG4gIG1lc3NhZ2U6ICdJbnRlcm5hbCBFcnJvciBvbiBNZXJrbGVCbG9jayB7MH0nLFxuICBlcnJvcnM6IFt7XG4gICAgJ25hbWUnOiAnSW52YWxpZE1lcmtsZVRyZWUnLFxuICAgICdtZXNzYWdlJzogJ1RoaXMgTWVya2xlQmxvY2sgY29udGFpbiBhbiBpbnZhbGlkIE1lcmtsZSBUcmVlJ1xuICB9XVxufSwge1xuICBuYW1lOiAnVHJhbnNhY3Rpb24nLFxuICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3Igb24gVHJhbnNhY3Rpb24gezB9JyxcbiAgZXJyb3JzOiBbe1xuICAgIG5hbWU6ICdJbnB1dCcsXG4gICAgbWVzc2FnZTogJ0ludGVybmFsIEVycm9yIG9uIElucHV0IHswfScsXG4gICAgZXJyb3JzOiBbe1xuICAgICAgbmFtZTogJ01pc3NpbmdTY3JpcHQnLFxuICAgICAgbWVzc2FnZTogJ05lZWQgYSBzY3JpcHQgdG8gY3JlYXRlIGFuIGlucHV0J1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdVbnN1cHBvcnRlZFNjcmlwdCcsXG4gICAgICBtZXNzYWdlOiAnVW5zdXBwb3J0ZWQgaW5wdXQgc2NyaXB0IHR5cGU6IHswfSdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnTWlzc2luZ1ByZXZpb3VzT3V0cHV0JyxcbiAgICAgIG1lc3NhZ2U6ICdObyBwcmV2aW91cyBvdXRwdXQgaW5mb3JtYXRpb24uJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdCbG9ja0hlaWdodE91dE9mUmFuZ2UnLFxuICAgICAgbWVzc2FnZTogJ0Jsb2NrIEhlaWdodCBjYW4gb25seSBiZSBiZXR3ZWVuIDAgYW5kIDY1NTM1J1xuICAgIH0gLCB7XG4gICAgICBuYW1lOiAnTG9ja1RpbWVSYW5nZScsXG4gICAgICBtZXNzYWdlOiAnU2Vjb25kcyBuZWVkcyB0byBiZSBtb3JlIHRoYXQgMCBhbmQgbGVzcyB0aGF0IDMzNTUzOTIwJ1xuICAgIH1cbiAgICBdXG4gIH0sIHtcbiAgICBuYW1lOiAnTmVlZE1vcmVJbmZvJyxcbiAgICBtZXNzYWdlOiAnezB9J1xuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWRTb3J0aW5nJyxcbiAgICBtZXNzYWdlOiAnVGhlIHNvcnRpbmcgZnVuY3Rpb24gcHJvdmlkZWQgZGlkIG5vdCByZXR1cm4gdGhlIGNoYW5nZSBvdXRwdXQgYXMgb25lIG9mIHRoZSBhcnJheSBlbGVtZW50cydcbiAgfSwge1xuICAgIG5hbWU6ICdJbnZhbGlkT3V0cHV0QW1vdW50U3VtJyxcbiAgICBtZXNzYWdlOiAnezB9J1xuICB9LCB7XG4gICAgbmFtZTogJ01pc3NpbmdTaWduYXR1cmVzJyxcbiAgICBtZXNzYWdlOiAnU29tZSBpbnB1dHMgaGF2ZSBub3QgYmVlbiBmdWxseSBzaWduZWQnXG4gIH0sIHtcbiAgICBuYW1lOiAnSW52YWxpZEluZGV4JyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBpbmRleDogezB9IGlzIG5vdCBiZXR3ZWVuIDAsIHsxfSdcbiAgfSwge1xuICAgIG5hbWU6ICdVbmFibGVUb1ZlcmlmeVNpZ25hdHVyZScsXG4gICAgbWVzc2FnZTogJ1VuYWJsZSB0byB2ZXJpZnkgc2lnbmF0dXJlOiB7MH0nXG4gIH0sIHtcbiAgICBuYW1lOiAnRHVzdE91dHB1dHMnLFxuICAgIG1lc3NhZ2U6ICdEdXN0IGFtb3VudCBkZXRlY3RlZCBpbiBvbmUgb3V0cHV0J1xuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWRTYXRvc2hpcycsXG4gICAgbWVzc2FnZTogJ091dHB1dCBzYXRvc2hpcyBhcmUgaW52YWxpZCcsXG4gIH0sIHtcbiAgICBuYW1lOiAnRmVlRXJyb3InLFxuICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBFcnJvciBvbiBGZWUgezB9JyxcbiAgICBlcnJvcnM6IFt7XG4gICAgICBuYW1lOiAnVG9vU21hbGwnLFxuICAgICAgbWVzc2FnZTogJ0ZlZSBpcyB0b28gc21hbGw6IHswfScsXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1Rvb0xhcmdlJyxcbiAgICAgIG1lc3NhZ2U6ICdGZWUgaXMgdG9vIGxhcmdlOiB7MH0nLFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdEaWZmZXJlbnQnLFxuICAgICAgbWVzc2FnZTogJ1Vuc3BlbnQgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gc3BlY2lmaWVkIGZlZTogezB9JyxcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ0NoYW5nZUFkZHJlc3NNaXNzaW5nJyxcbiAgICBtZXNzYWdlOiAnQ2hhbmdlIGFkZHJlc3MgaXMgbWlzc2luZydcbiAgfSwge1xuICAgIG5hbWU6ICdCbG9ja0hlaWdodFRvb0hpZ2gnLFxuICAgIG1lc3NhZ2U6ICdCbG9jayBIZWlnaHQgY2FuIGJlIGF0IG1vc3QgMl4zMiAtMSdcbiAgfSwge1xuICAgIG5hbWU6ICdOTG9ja1RpbWVPdXRPZlJhbmdlJyxcbiAgICBtZXNzYWdlOiAnQmxvY2sgSGVpZ2h0IGNhbiBvbmx5IGJlIGJldHdlZW4gMCBhbmQgNDk5IDk5OSA5OTknXG4gIH0sIHtcbiAgICBuYW1lOiAnTG9ja1RpbWVUb29FYXJseScsXG4gICAgbWVzc2FnZTogJ0xvY2sgVGltZSBjYW5cXCd0IGJlIGVhcmxpZXIgdGhhbiBVTklYIGRhdGUgNTAwIDAwMCAwMDAnXG4gIH1dXG59LCB7XG4gIG5hbWU6ICdTY3JpcHQnLFxuICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3Igb24gU2NyaXB0IHswfScsXG4gIGVycm9yczogW3tcbiAgICBuYW1lOiAnVW5yZWNvZ25pemVkQWRkcmVzcycsXG4gICAgbWVzc2FnZTogJ0V4cGVjdGVkIGFyZ3VtZW50IHswfSB0byBiZSBhbiBhZGRyZXNzJ1xuICB9LCB7XG4gICAgbmFtZTogJ0NhbnREZXJpdmVBZGRyZXNzJyxcbiAgICBtZXNzYWdlOiAnQ2FuXFwndCBkZXJpdmUgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggc2NyaXB0IHswfSwgbmVlZHMgdG8gYmUgcDJwa2ggaW4sIHAycGtoIG91dCwgcDJzaCBpbiwgb3IgcDJzaCBvdXQuJ1xuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWRCdWZmZXInLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHNjcmlwdCBidWZmZXI6IGNhblxcJ3QgcGFyc2UgdmFsaWQgc2NyaXB0IGZyb20gZ2l2ZW4gYnVmZmVyIHswfSdcbiAgfV1cbn0sIHtcbiAgbmFtZTogJ0hEUHJpdmF0ZUtleScsXG4gIG1lc3NhZ2U6ICdJbnRlcm5hbCBFcnJvciBvbiBIRFByaXZhdGVLZXkgezB9JyxcbiAgZXJyb3JzOiBbe1xuICAgIG5hbWU6ICdJbnZhbGlkRGVyaXZhdGlvbkFyZ3VtZW50JyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBkZXJpdmF0aW9uIGFyZ3VtZW50IHswfSwgZXhwZWN0ZWQgc3RyaW5nLCBvciBudW1iZXIgYW5kIGJvb2xlYW4nXG4gIH0sIHtcbiAgICBuYW1lOiAnSW52YWxpZEVudHJvcHlBcmd1bWVudCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgZW50cm9weTogbXVzdCBiZSBhbiBoZXhhIHN0cmluZyBvciBiaW5hcnkgYnVmZmVyLCBnb3QgezB9JyxcbiAgICBlcnJvcnM6IFt7XG4gICAgICBuYW1lOiAnVG9vTXVjaEVudHJvcHknLFxuICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZW50cm9weTogbW9yZSB0aGFuIDUxMiBiaXRzIGlzIG5vbiBzdGFuZGFyZCwgZ290IFwiezB9XCInXG4gICAgfSwge1xuICAgICAgbmFtZTogJ05vdEVub3VnaEVudHJvcHknLFxuICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZW50cm9weTogYXQgbGVhc3QgMTI4IGJpdHMgbmVlZGVkLCBnb3QgXCJ7MH1cIidcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWRMZW5ndGgnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGxlbmd0aCBmb3IgeHByaXZrZXkgc3RyaW5nIGluIHswfSdcbiAgfSwge1xuICAgIG5hbWU6ICdJbnZhbGlkUGF0aCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXRoOiB7MH0nXG4gIH0sIHtcbiAgICBuYW1lOiAnVW5yZWNvZ25pemVkQXJndW1lbnQnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGFyZ3VtZW50OiBjcmVhdGluZyBhIEhEUHJpdmF0ZUtleSByZXF1aXJlcyBhIHN0cmluZywgYnVmZmVyLCBqc29uIG9yIG9iamVjdCwgZ290IFwiezB9XCInXG4gIH1dXG59LCB7XG4gIG5hbWU6ICdIRFB1YmxpY0tleScsXG4gIG1lc3NhZ2U6ICdJbnRlcm5hbCBFcnJvciBvbiBIRFB1YmxpY0tleSB7MH0nLFxuICBlcnJvcnM6IFt7XG4gICAgbmFtZTogJ0FyZ3VtZW50SXNQcml2YXRlRXh0ZW5kZWQnLFxuICAgIG1lc3NhZ2U6ICdBcmd1bWVudCBpcyBhbiBleHRlbmRlZCBwcml2YXRlIGtleTogezB9J1xuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWREZXJpdmF0aW9uQXJndW1lbnQnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGRlcml2YXRpb24gYXJndW1lbnQ6IGdvdCB7MH0nXG4gIH0sIHtcbiAgICBuYW1lOiAnSW52YWxpZExlbmd0aCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgbGVuZ3RoIGZvciB4cHVia2V5OiBnb3QgXCJ7MH1cIidcbiAgfSwge1xuICAgIG5hbWU6ICdJbnZhbGlkUGF0aCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXRoLCBpdCBzaG91bGQgbG9vayBsaWtlOiBcIm0vMS8xMDBcIiwgZ290IFwiezB9XCInXG4gIH0sIHtcbiAgICBuYW1lOiAnSW52YWxpZEluZGV4Q2FudERlcml2ZUhhcmRlbmVkJyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBhcmd1bWVudDogY3JlYXRpbmcgYSBoYXJkZW5lZCBwYXRoIHJlcXVpcmVzIGFuIEhEUHJpdmF0ZUtleSdcbiAgfSwge1xuICAgIG5hbWU6ICdNdXN0U3VwcGx5QXJndW1lbnQnLFxuICAgIG1lc3NhZ2U6ICdNdXN0IHN1cHBseSBhbiBhcmd1bWVudCB0byBjcmVhdGUgYSBIRFB1YmxpY0tleSdcbiAgfSwge1xuICAgIG5hbWU6ICdVbnJlY29nbml6ZWRBcmd1bWVudCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgYXJndW1lbnQgZm9yIGNyZWF0aW9uLCBtdXN0IGJlIHN0cmluZywganNvbiwgYnVmZmVyLCBvciBvYmplY3QnXG4gIH1dXG59XTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/errors/spec.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/hdprivatekey.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/hdprivatekey.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar Base58 = __webpack_require__(/*! ./encoding/base58 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\");\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Network = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar Point = __webpack_require__(/*! ./crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nvar PrivateKey = __webpack_require__(/*! ./privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\nvar Random = __webpack_require__(/*! ./crypto/random */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar hdErrors = errors.HDPrivateKey;\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n\n\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\nHDPrivateKey.isValidPath = function(arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\nHDPrivateKey._getDerivationIndexes = function(path) {\n  var steps = path.split('/');\n\n  // Special cases:\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function(step) {\n    var isHardened = step.slice(-1) === '\\'';\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n    var index = +step; // cast to number\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n\n  return _.some(indexes, isNaN) ? null : indexes;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.derive = function(arg, hardened) {\n  return this.deriveNonCompliantChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32});\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index, null, nonCompliant);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPrivateKey.isValidSerialized = function(data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\nHDPrivateKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(0, 4);\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPrivateKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function(arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? Buffer.from(arg.privateKey,'hex') : arg.privateKey,\n    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,\n      HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function(network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\nHDPrivateKey.fromSeed = function(hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = Buffer.from(hexa, 'hex');\n  }\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\n\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\n\n\nHDPrivateKey.prototype._calcHDPublicKey = function() {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = __webpack_require__(/*! ./hdpublickey */ \"(ssr)/./node_modules/bitcore-lib/lib/hdpublickey.js\");\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.privateKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\nHDPrivateKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    BufferUtil.emptyBuffer(1), arg.privateKey\n  ];\n  var concat = buffer.Buffer.concat(sequence);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\n  arg.xprivkey = Buffer.from(xprivkey);\n\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  this._hdPublicKey = null;\n\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\nHDPrivateKey.prototype.toString = function() {\n  return this.xprivkey;\n};\n\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\nHDPrivateKey.prototype.inspect = function() {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\nHDPrivateKey.fromBuffer = function(arg) {\n  return new HDPrivateKey(arg.toString());\n};\n\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\nHDPrivateKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\n\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\n\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\n\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\n\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\n\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\n\nmodule.exports = HDPrivateKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2hkcHJpdmF0ZWtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7O0FBR2IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjs7QUFFdEMsU0FBUyxtQkFBTyxDQUFDLHNFQUFhO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsNEZBQXdCO0FBQ2xELFdBQVcsbUJBQU8sQ0FBQywwRUFBZTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsb0VBQVk7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBYztBQUN2QyxhQUFhLG1CQUFPLENBQUMsOEVBQWlCOztBQUV0QyxhQUFhLG1CQUFPLENBQUMsc0VBQVU7QUFDL0I7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBZTtBQUN4QyxhQUFhLG1CQUFPLENBQUMsa0VBQVc7O0FBRWhDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7O0FBSUE7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLDBFQUFlO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvaGRwcml2YXRla2V5LmpzPzIyZjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbnZhciBCTiA9IHJlcXVpcmUoJy4vY3J5cHRvL2JuJyk7XG52YXIgQmFzZTU4ID0gcmVxdWlyZSgnLi9lbmNvZGluZy9iYXNlNTgnKTtcbnZhciBCYXNlNThDaGVjayA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYmFzZTU4Y2hlY2snKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9jcnlwdG8vaGFzaCcpO1xudmFyIE5ldHdvcmsgPSByZXF1aXJlKCcuL25ldHdvcmtzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL2NyeXB0by9wb2ludCcpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuL3ByaXZhdGVrZXknKTtcbnZhciBSYW5kb20gPSByZXF1aXJlKCcuL2NyeXB0by9yYW5kb20nKTtcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgaGRFcnJvcnMgPSBlcnJvcnMuSERQcml2YXRlS2V5O1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL3V0aWwvYnVmZmVyJyk7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XG5cbnZhciBNSU5JTVVNX0VOVFJPUFlfQklUUyA9IDEyODtcbnZhciBCSVRTX1RPX0JZVEVTID0gMSAvIDg7XG52YXIgTUFYSU1VTV9FTlRST1BZX0JJVFMgPSA1MTI7XG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIGFuIGhpZXJhcmNoaWNhbGx5IGRlcml2ZWQgcHJpdmF0ZSBrZXkuXG4gKlxuICogTW9yZSBpbmZvIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwMzIubWVkaWF3aWtpXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8T2JqZWN0fSBhcmdcbiAqL1xuZnVuY3Rpb24gSERQcml2YXRlS2V5KGFyZykge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cbiAgaWYgKGFyZyBpbnN0YW5jZW9mIEhEUHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhEUHJpdmF0ZUtleSkpIHtcbiAgICByZXR1cm4gbmV3IEhEUHJpdmF0ZUtleShhcmcpO1xuICB9XG4gIGlmICghYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRlUmFuZG9tbHkoKTtcbiAgfVxuXG4gIGlmIChOZXR3b3JrLmdldChhcmcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRlUmFuZG9tbHkoYXJnKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGFyZykgfHwgQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcpKSB7XG4gICAgaWYgKEhEUHJpdmF0ZUtleS5pc1ZhbGlkU2VyaWFsaXplZChhcmcpKSB7XG4gICAgICB0aGlzLl9idWlsZEZyb21TZXJpYWxpemVkKGFyZyk7XG4gICAgfSBlbHNlIGlmIChKU1V0aWwuaXNWYWxpZEpTT04oYXJnKSkge1xuICAgICAgdGhpcy5fYnVpbGRGcm9tSlNPTihhcmcpO1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcpICYmIEhEUHJpdmF0ZUtleS5pc1ZhbGlkU2VyaWFsaXplZChhcmcudG9TdHJpbmcoKSkpIHtcbiAgICAgIHRoaXMuX2J1aWxkRnJvbVNlcmlhbGl6ZWQoYXJnLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBIRFByaXZhdGVLZXkuZ2V0U2VyaWFsaXplZEVycm9yKGFyZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoYXJnKSkge1xuICAgIHRoaXMuX2J1aWxkRnJvbU9iamVjdChhcmcpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5VbnJlY29nbml6ZWRBcmd1bWVudChhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBhIGdpdmVuIHBhdGggaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBhcmdcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGhhcmRlbmVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5IRFByaXZhdGVLZXkuaXNWYWxpZFBhdGggPSBmdW5jdGlvbihhcmcsIGhhcmRlbmVkKSB7XG4gIGlmIChfLmlzU3RyaW5nKGFyZykpIHtcbiAgICB2YXIgaW5kZXhlcyA9IEhEUHJpdmF0ZUtleS5fZ2V0RGVyaXZhdGlvbkluZGV4ZXMoYXJnKTtcbiAgICByZXR1cm4gaW5kZXhlcyAhPT0gbnVsbCAmJiBfLmV2ZXJ5KGluZGV4ZXMsIEhEUHJpdmF0ZUtleS5pc1ZhbGlkUGF0aCk7XG4gIH1cblxuICBpZiAoXy5pc051bWJlcihhcmcpKSB7XG4gICAgaWYgKGFyZyA8IEhEUHJpdmF0ZUtleS5IYXJkZW5lZCAmJiBoYXJkZW5lZCA9PT0gdHJ1ZSkge1xuICAgICAgYXJnICs9IEhEUHJpdmF0ZUtleS5IYXJkZW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGFyZyA+PSAwICYmIGFyZyA8IEhEUHJpdmF0ZUtleS5NYXhJbmRleDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCBzcGxpdHMgYSBzdHJpbmcgcGF0aCBpbnRvIGEgZGVyaXZhdGlvbiBpbmRleCBhcnJheS5cbiAqIEl0IHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHN0cmluZyBwYXRoIGlzIG1hbGZvcm1lZC5cbiAqIEl0IGRvZXMgbm90IHZhbGlkYXRlIGlmIGluZGV4ZXMgYXJlIGluIGJvdW5kcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkhEUHJpdmF0ZUtleS5fZ2V0RGVyaXZhdGlvbkluZGV4ZXMgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBzdGVwcyA9IHBhdGguc3BsaXQoJy8nKTtcblxuICAvLyBTcGVjaWFsIGNhc2VzOlxuICBpZiAoXy5pbmNsdWRlcyhIRFByaXZhdGVLZXkuUm9vdEVsZW1lbnRBbGlhcywgcGF0aCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAoIV8uaW5jbHVkZXMoSERQcml2YXRlS2V5LlJvb3RFbGVtZW50QWxpYXMsIHN0ZXBzWzBdKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGluZGV4ZXMgPSBzdGVwcy5zbGljZSgxKS5tYXAoZnVuY3Rpb24oc3RlcCkge1xuICAgIHZhciBpc0hhcmRlbmVkID0gc3RlcC5zbGljZSgtMSkgPT09ICdcXCcnO1xuICAgIGlmIChpc0hhcmRlbmVkKSB7XG4gICAgICBzdGVwID0gc3RlcC5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIGlmICghc3RlcCB8fCBzdGVwWzBdID09PSAnLScpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHZhciBpbmRleCA9ICtzdGVwOyAvLyBjYXN0IHRvIG51bWJlclxuICAgIGlmIChpc0hhcmRlbmVkKSB7XG4gICAgICBpbmRleCArPSBIRFByaXZhdGVLZXkuSGFyZGVuZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9KTtcblxuICByZXR1cm4gXy5zb21lKGluZGV4ZXMsIGlzTmFOKSA/IG51bGwgOiBpbmRleGVzO1xufTtcblxuLyoqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBVc2UgZGVyaXZlQ2hpbGQgb3IgZGVyaXZlTm9uQ29tcGxpYW50Q2hpbGQgaW5zdGVhZC4gVGhpcyBpcyBub3QgQklQMzIgY29tcGxpYW50XG4gKlxuICpcbiAqIEdldCBhIGRlcml2ZWQgY2hpbGQgYmFzZWQgb24gYSBzdHJpbmcgb3IgbnVtYmVyLlxuICpcbiAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgaXQncyBwYXJzZWQgYXMgdGhlIGZ1bGwgcGF0aCBvZlxuICogZGVyaXZhdGlvbi4gVmFsaWQgdmFsdWVzIGZvciB0aGlzIGFyZ3VtZW50IGluY2x1ZGUgXCJtXCIgKHdoaWNoIHJldHVybnMgdGhlXG4gKiBzYW1lIHByaXZhdGUga2V5KSwgXCJtLzAvMS80MC8yJy8xMDAwXCIsIHdoZXJlIHRoZSAnIHF1b3RlIG1lYW5zIGEgaGFyZGVuZWRcbiAqIGRlcml2YXRpb24uXG4gKlxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgbnVtYmVyLCB0aGUgY2hpbGQgd2l0aCB0aGF0IGluZGV4IHdpbGwgYmVcbiAqIGRlcml2ZWQuIElmIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdHJ1dGh5LCB0aGUgaGFyZGVuZWQgdmVyc2lvbiB3aWxsIGJlXG4gKiBkZXJpdmVkLiBTZWUgdGhlIGV4YW1wbGUgdXNhZ2UgZm9yIGNsYXJpZmljYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYXJlbnQgPSBuZXcgSERQcml2YXRlS2V5KCd4cHJ2Li4uJyk7XG4gKiB2YXIgY2hpbGRfMF8xXzJoID0gcGFyZW50LmRlcml2ZSgwKS5kZXJpdmUoMSkuZGVyaXZlKDIsIHRydWUpO1xuICogdmFyIGNvcHlfb2ZfY2hpbGRfMF8xXzJoID0gcGFyZW50LmRlcml2ZShcIm0vMC8xLzInXCIpO1xuICogYXNzZXJ0KGNoaWxkXzBfMV8yaC54cHJpdmtleSA9PT0gY29weV9vZl9jaGlsZF8wXzFfMmgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBhcmdcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGhhcmRlbmVkXG4gKi9cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24oYXJnLCBoYXJkZW5lZCkge1xuICByZXR1cm4gdGhpcy5kZXJpdmVOb25Db21wbGlhbnRDaGlsZChhcmcsIGhhcmRlbmVkKTtcbn07XG5cbi8qKlxuICogV0FSTklORzogVGhpcyBtZXRob2Qgd2lsbCBub3QgYmUgb2ZmaWNpYWxseSBzdXBwb3J0ZWQgdW50aWwgdjEuMC4wLlxuICpcbiAqXG4gKiBHZXQgYSBkZXJpdmVkIGNoaWxkIGJhc2VkIG9uIGEgc3RyaW5nIG9yIG51bWJlci5cbiAqXG4gKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIGl0J3MgcGFyc2VkIGFzIHRoZSBmdWxsIHBhdGggb2ZcbiAqIGRlcml2YXRpb24uIFZhbGlkIHZhbHVlcyBmb3IgdGhpcyBhcmd1bWVudCBpbmNsdWRlIFwibVwiICh3aGljaCByZXR1cm5zIHRoZVxuICogc2FtZSBwcml2YXRlIGtleSksIFwibS8wLzEvNDAvMicvMTAwMFwiLCB3aGVyZSB0aGUgJyBxdW90ZSBtZWFucyBhIGhhcmRlbmVkXG4gKiBkZXJpdmF0aW9uLlxuICpcbiAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIG51bWJlciwgdGhlIGNoaWxkIHdpdGggdGhhdCBpbmRleCB3aWxsIGJlXG4gKiBkZXJpdmVkLiBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRydXRoeSwgdGhlIGhhcmRlbmVkIHZlcnNpb24gd2lsbCBiZVxuICogZGVyaXZlZC4gU2VlIHRoZSBleGFtcGxlIHVzYWdlIGZvciBjbGFyaWZpY2F0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoZSBgbm9uQ29tcGxpYW50YCBvcHRpb24gc2hvdWxkIE5PVCBiZSB1c2VkLCBleGNlcHQgZm9yIG9sZGVyIGltcGxlbWVudGF0aW9uXG4gKiB0aGF0IHVzZWQgYSBkZXJpdmF0aW9uIHN0cmF0ZWd5IHRoYXQgdXNlZCBhIG5vbi16ZXJvIHBhZGRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBhcmVudCA9IG5ldyBIRFByaXZhdGVLZXkoJ3hwcnYuLi4nKTtcbiAqIHZhciBjaGlsZF8wXzFfMmggPSBwYXJlbnQuZGVyaXZlQ2hpbGQoMCkuZGVyaXZlQ2hpbGQoMSkuZGVyaXZlQ2hpbGQoMiwgdHJ1ZSk7XG4gKiB2YXIgY29weV9vZl9jaGlsZF8wXzFfMmggPSBwYXJlbnQuZGVyaXZlQ2hpbGQoXCJtLzAvMS8yJ1wiKTtcbiAqIGFzc2VydChjaGlsZF8wXzFfMmgueHByaXZrZXkgPT09IGNvcHlfb2ZfY2hpbGRfMF8xXzJoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXJnXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBoYXJkZW5lZFxuICovXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLmRlcml2ZUNoaWxkID0gZnVuY3Rpb24oYXJnLCBoYXJkZW5lZCkge1xuICBpZiAoXy5pc051bWJlcihhcmcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlcml2ZVdpdGhOdW1iZXIoYXJnLCBoYXJkZW5lZCk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhhcmcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlcml2ZUZyb21TdHJpbmcoYXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuSW52YWxpZERlcml2YXRpb25Bcmd1bWVudChhcmcpO1xuICB9XG59O1xuXG4vKipcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgbm90IGJlIG9mZmljaWFsbHkgc3VwcG9ydGVkIHVudGlsIHYxLjAuMFxuICpcbiAqXG4gKiBXQVJOSU5HOiBJZiB0aGlzIGlzIGEgbmV3IGltcGxlbWVudGF0aW9uIHlvdSBzaG91bGQgTk9UIHVzZSB0aGlzIG1ldGhvZCwgeW91IHNob3VsZCBiZSB1c2luZ1xuICogYGRlcml2ZWAgaW5zdGVhZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBleHBsaWNpdGx5IGZvciB1c2UgYW5kIGNvbXBhdGliaWxpdHkgd2l0aCBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0XG4gKiB3YXMgbm90IGNvbXBsaWFudCB3aXRoIEJJUDMyIHJlZ2FyZGluZyB0aGUgZGVyaXZhdGlvbiBhbGdvcml0aG0uIFRoZSBwcml2YXRlIGtleVxuICogbXVzdCBiZSAzMiBieXRlcyBoYXNoaW5nLCBhbmQgdGhpcyBpbXBsZW1lbnRhdGlvbiB3aWxsIHVzZSB0aGUgbm9uLXplcm8gcGFkZGVkXG4gKiBzZXJpYWxpemF0aW9uIG9mIGEgcHJpdmF0ZSBrZXksIHN1Y2ggdGhhdCBpdCdzIHN0aWxsIHBvc3NpYmxlIHRvIGRlcml2ZSB0aGUgcHJpdmF0ZUtleVxuICogdG8gcmVjb3ZlciB0aG9zZSBmdW5kcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGFyZ1xuICogQHBhcmFtIHtib29sZWFuP30gaGFyZGVuZWRcbiAqL1xuSERQcml2YXRlS2V5LnByb3RvdHlwZS5kZXJpdmVOb25Db21wbGlhbnRDaGlsZCA9IGZ1bmN0aW9uKGFyZywgaGFyZGVuZWQpIHtcbiAgaWYgKF8uaXNOdW1iZXIoYXJnKSkge1xuICAgIHJldHVybiB0aGlzLl9kZXJpdmVXaXRoTnVtYmVyKGFyZywgaGFyZGVuZWQsIHRydWUpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYXJnKSkge1xuICAgIHJldHVybiB0aGlzLl9kZXJpdmVGcm9tU3RyaW5nKGFyZywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWREZXJpdmF0aW9uQXJndW1lbnQoYXJnKTtcbiAgfVxufTtcblxuSERQcml2YXRlS2V5LnByb3RvdHlwZS5fZGVyaXZlV2l0aE51bWJlciA9IGZ1bmN0aW9uKGluZGV4LCBoYXJkZW5lZCwgbm9uQ29tcGxpYW50KSB7XG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cbiAgaWYgKCFIRFByaXZhdGVLZXkuaXNWYWxpZFBhdGgoaW5kZXgsIGhhcmRlbmVkKSkge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkUGF0aChpbmRleCk7XG4gIH1cblxuICBoYXJkZW5lZCA9IGluZGV4ID49IEhEUHJpdmF0ZUtleS5IYXJkZW5lZCA/IHRydWUgOiBoYXJkZW5lZDtcbiAgaWYgKGluZGV4IDwgSERQcml2YXRlS2V5LkhhcmRlbmVkICYmIGhhcmRlbmVkID09PSB0cnVlKSB7XG4gICAgaW5kZXggKz0gSERQcml2YXRlS2V5LkhhcmRlbmVkO1xuICB9XG5cbiAgdmFyIGluZGV4QnVmZmVyID0gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoaW5kZXgpO1xuICB2YXIgZGF0YTtcbiAgaWYgKGhhcmRlbmVkICYmIG5vbkNvbXBsaWFudCkge1xuICAgIC8vIFRoZSBwcml2YXRlIGtleSBzZXJpYWxpemF0aW9uIGluIHRoaXMgY2FzZSB3aWxsIG5vdCBiZSBleGFjdGx5IDMyIGJ5dGVzIGFuZCBjYW4gYmVcbiAgICAvLyBhbnkgdmFsdWUgbGVzcywgYW5kIHRoZSB2YWx1ZSBpcyBub3QgemVyby1wYWRkZWQuXG4gICAgdmFyIG5vblplcm9QYWRkZWQgPSB0aGlzLnByaXZhdGVLZXkuYm4udG9CdWZmZXIoKTtcbiAgICBkYXRhID0gQnVmZmVyVXRpbC5jb25jYXQoW0J1ZmZlci5mcm9tKFswXSksIG5vblplcm9QYWRkZWQsIGluZGV4QnVmZmVyXSk7XG4gIH0gZWxzZSBpZiAoaGFyZGVuZWQpIHtcbiAgICAvLyBUaGlzIHdpbGwgdXNlIGEgMzIgYnl0ZSB6ZXJvIHBhZGRlZCBzZXJpYWxpemF0aW9uIG9mIHRoZSBwcml2YXRlIGtleVxuICAgIHZhciBwcml2YXRlS2V5QnVmZmVyID0gdGhpcy5wcml2YXRlS2V5LmJuLnRvQnVmZmVyKHtzaXplOiAzMn0pO1xuICAgIGFzc2VydChwcml2YXRlS2V5QnVmZmVyLmxlbmd0aCA9PT0gMzIsICdsZW5ndGggb2YgcHJpdmF0ZSBrZXkgYnVmZmVyIGlzIGV4cGVjdGVkIHRvIGJlIDMyIGJ5dGVzJyk7XG4gICAgZGF0YSA9IEJ1ZmZlclV0aWwuY29uY2F0KFtCdWZmZXIuZnJvbShbMF0pLCBwcml2YXRlS2V5QnVmZmVyLCBpbmRleEJ1ZmZlcl0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGEgPSBCdWZmZXJVdGlsLmNvbmNhdChbdGhpcy5wdWJsaWNLZXkudG9CdWZmZXIoKSwgaW5kZXhCdWZmZXJdKTtcbiAgfVxuICB2YXIgaGFzaCA9IEhhc2guc2hhNTEyaG1hYyhkYXRhLCB0aGlzLl9idWZmZXJzLmNoYWluQ29kZSk7XG4gIHZhciBsZWZ0UGFydCA9IEJOLmZyb21CdWZmZXIoaGFzaC5zbGljZSgwLCAzMiksIHtcbiAgICBzaXplOiAzMlxuICB9KTtcbiAgdmFyIGNoYWluQ29kZSA9IGhhc2guc2xpY2UoMzIsIDY0KTtcblxuICB2YXIgcHJpdmF0ZUtleSA9IGxlZnRQYXJ0LmFkZCh0aGlzLnByaXZhdGVLZXkudG9CaWdOdW1iZXIoKSkudW1vZChQb2ludC5nZXROKCkpLnRvQnVmZmVyKHtcbiAgICBzaXplOiAzMlxuICB9KTtcblxuICBpZiAoIVByaXZhdGVLZXkuaXNWYWxpZChwcml2YXRlS2V5KSkge1xuICAgIC8vIEluZGV4IGF0IHRoaXMgcG9pbnQgaXMgYWxyZWFkeSBoYXJkZW5lZCwgd2UgY2FuIHBhc3MgbnVsbCBhcyB0aGUgaGFyZGVuZWQgYXJnXG4gICAgcmV0dXJuIHRoaXMuX2Rlcml2ZVdpdGhOdW1iZXIoaW5kZXggKyAxLCBudWxsLCBub25Db21wbGlhbnQpO1xuICB9XG5cbiAgdmFyIGRlcml2ZWQgPSBuZXcgSERQcml2YXRlS2V5KHtcbiAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmssXG4gICAgZGVwdGg6IHRoaXMuZGVwdGggKyAxLFxuICAgIHBhcmVudEZpbmdlclByaW50OiB0aGlzLmZpbmdlclByaW50LFxuICAgIGNoaWxkSW5kZXg6IGluZGV4LFxuICAgIGNoYWluQ29kZTogY2hhaW5Db2RlLFxuICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlcbiAgfSk7XG5cbiAgcmV0dXJuIGRlcml2ZWQ7XG59O1xuXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLl9kZXJpdmVGcm9tU3RyaW5nID0gZnVuY3Rpb24ocGF0aCwgbm9uQ29tcGxpYW50KSB7XG4gIGlmICghSERQcml2YXRlS2V5LmlzVmFsaWRQYXRoKHBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRQYXRoKHBhdGgpO1xuICB9XG5cbiAgdmFyIGluZGV4ZXMgPSBIRFByaXZhdGVLZXkuX2dldERlcml2YXRpb25JbmRleGVzKHBhdGgpO1xuICB2YXIgZGVyaXZlZCA9IGluZGV4ZXMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGluZGV4KSB7XG4gICAgcmV0dXJuIHByZXYuX2Rlcml2ZVdpdGhOdW1iZXIoaW5kZXgsIG51bGwsIG5vbkNvbXBsaWFudCk7XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiBkZXJpdmVkO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGEgZ2l2ZW4gc2VyaWFsaXplZCBwcml2YXRlIGtleSBpbiBiYXNlNTggd2l0aCBjaGVja3N1bSBmb3JtYXRcbiAqIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSAtIHRoZSBzZXJpYWxpemVkIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xOZXR3b3JrPX0gbmV0d29yayAtIG9wdGlvbmFsLCBpZiBwcmVzZW50LCBjaGVja3MgdGhhdCB0aGVcbiAqICAgICBuZXR3b3JrIHByb3ZpZGVkIG1hdGNoZXMgdGhlIG5ldHdvcmsgc2VyaWFsaXplZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkhEUHJpdmF0ZUtleS5pc1ZhbGlkU2VyaWFsaXplZCA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmspIHtcbiAgcmV0dXJuICFIRFByaXZhdGVLZXkuZ2V0U2VyaWFsaXplZEVycm9yKGRhdGEsIG5ldHdvcmspO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hhdCdzIHRoZSBlcnJvciB0aGF0IGNhdXNlcyB0aGUgdmFsaWRhdGlvbiBvZiBhIHNlcmlhbGl6ZWQgcHJpdmF0ZSBrZXlcbiAqIGluIGJhc2U1OCB3aXRoIGNoZWNrc3VtIHRvIGZhaWwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIC0gdGhlIHNlcmlhbGl6ZWQgcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfE5ldHdvcms9fSBuZXR3b3JrIC0gb3B0aW9uYWwsIGlmIHByZXNlbnQsIGNoZWNrcyB0aGF0IHRoZVxuICogICAgIG5ldHdvcmsgcHJvdmlkZWQgbWF0Y2hlcyB0aGUgbmV0d29yayBzZXJpYWxpemVkLlxuICogQHJldHVybiB7ZXJyb3JzLkludmFsaWRBcmd1bWVudHxudWxsfVxuICovXG5IRFByaXZhdGVLZXkuZ2V0U2VyaWFsaXplZEVycm9yID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaykge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cbiAgaWYgKCEoXy5pc1N0cmluZyhkYXRhKSB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKGRhdGEpKSkge1xuICAgIHJldHVybiBuZXcgaGRFcnJvcnMuVW5yZWNvZ25pemVkQXJndW1lbnQoJ0V4cGVjdGVkIHN0cmluZyBvciBidWZmZXInKTtcbiAgfVxuICBpZiAoIUJhc2U1OC52YWxpZENoYXJhY3RlcnMoZGF0YSkpIHtcbiAgICByZXR1cm4gbmV3IGVycm9ycy5JbnZhbGlkQjU4Q2hhcignKHVua25vd24pJywgZGF0YSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBkYXRhID0gQmFzZTU4Q2hlY2suZGVjb2RlKGRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuSW52YWxpZEI1OENoZWNrc3VtKGRhdGEpO1xuICB9XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gSERQcml2YXRlS2V5LkRhdGFMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IGhkRXJyb3JzLkludmFsaWRMZW5ndGgoZGF0YSk7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG5ldHdvcmspKSB7XG4gICAgdmFyIGVycm9yID0gSERQcml2YXRlS2V5Ll92YWxpZGF0ZU5ldHdvcmsoZGF0YSwgbmV0d29yayk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuSERQcml2YXRlS2V5Ll92YWxpZGF0ZU5ldHdvcmsgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrQXJnKSB7XG4gIHZhciBuZXR3b3JrID0gTmV0d29yay5nZXQobmV0d29ya0FyZyk7XG4gIGlmICghbmV0d29yaykge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWROZXR3b3JrQXJndW1lbnQobmV0d29ya0FyZyk7XG4gIH1cbiAgdmFyIHZlcnNpb24gPSBkYXRhLnNsaWNlKDAsIDQpO1xuICBpZiAoQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih2ZXJzaW9uKSAhPT0gbmV0d29yay54cHJpdmtleSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWROZXR3b3JrKHZlcnNpb24pO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuSERQcml2YXRlS2V5LmZyb21TdHJpbmcgPSBmdW5jdGlvbihhcmcpIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcoYXJnKSwgJ05vIHZhbGlkIHN0cmluZyB3YXMgcHJvdmlkZWQnKTtcbiAgcmV0dXJuIG5ldyBIRFByaXZhdGVLZXkoYXJnKTtcbn07XG5cbkhEUHJpdmF0ZUtleS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24oYXJnKSB7XG4gICQuY2hlY2tBcmd1bWVudChfLmlzT2JqZWN0KGFyZyksICdObyB2YWxpZCBhcmd1bWVudCB3YXMgcHJvdmlkZWQnKTtcbiAgcmV0dXJuIG5ldyBIRFByaXZhdGVLZXkoYXJnKTtcbn07XG5cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuX2J1aWxkRnJvbUpTT04gPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbU9iamVjdChKU09OLnBhcnNlKGFyZykpO1xufTtcblxuSERQcml2YXRlS2V5LnByb3RvdHlwZS5fYnVpbGRGcm9tT2JqZWN0ID0gZnVuY3Rpb24oYXJnKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMiAqL1xuICAvLyBUT0RPOiBUeXBlIHZhbGlkYXRpb25cbiAgdmFyIGJ1ZmZlcnMgPSB7XG4gICAgdmVyc2lvbjogYXJnLm5ldHdvcmsgPyBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihOZXR3b3JrLmdldChhcmcubmV0d29yaykueHByaXZrZXkpIDogYXJnLnZlcnNpb24sXG4gICAgZGVwdGg6IF8uaXNOdW1iZXIoYXJnLmRlcHRoKSA/IEJ1ZmZlclV0aWwuaW50ZWdlckFzU2luZ2xlQnl0ZUJ1ZmZlcihhcmcuZGVwdGgpIDogYXJnLmRlcHRoLFxuICAgIHBhcmVudEZpbmdlclByaW50OiBfLmlzTnVtYmVyKGFyZy5wYXJlbnRGaW5nZXJQcmludCkgPyBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihhcmcucGFyZW50RmluZ2VyUHJpbnQpIDogYXJnLnBhcmVudEZpbmdlclByaW50LFxuICAgIGNoaWxkSW5kZXg6IF8uaXNOdW1iZXIoYXJnLmNoaWxkSW5kZXgpID8gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoYXJnLmNoaWxkSW5kZXgpIDogYXJnLmNoaWxkSW5kZXgsXG4gICAgY2hhaW5Db2RlOiBfLmlzU3RyaW5nKGFyZy5jaGFpbkNvZGUpID8gQnVmZmVyLmZyb20oYXJnLmNoYWluQ29kZSwnaGV4JykgOiBhcmcuY2hhaW5Db2RlLFxuICAgIHByaXZhdGVLZXk6IChfLmlzU3RyaW5nKGFyZy5wcml2YXRlS2V5KSAmJiBKU1V0aWwuaXNIZXhhKGFyZy5wcml2YXRlS2V5KSkgPyBCdWZmZXIuZnJvbShhcmcucHJpdmF0ZUtleSwnaGV4JykgOiBhcmcucHJpdmF0ZUtleSxcbiAgICBjaGVja3N1bTogYXJnLmNoZWNrc3VtID8gKGFyZy5jaGVja3N1bS5sZW5ndGggPyBhcmcuY2hlY2tzdW0gOiBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihhcmcuY2hlY2tzdW0pKSA6IHVuZGVmaW5lZFxuICB9O1xuICByZXR1cm4gdGhpcy5fYnVpbGRGcm9tQnVmZmVycyhidWZmZXJzKTtcbn07XG5cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuX2J1aWxkRnJvbVNlcmlhbGl6ZWQgPSBmdW5jdGlvbihhcmcpIHtcbiAgdmFyIGRlY29kZWQgPSBCYXNlNThDaGVjay5kZWNvZGUoYXJnKTtcbiAgdmFyIGJ1ZmZlcnMgPSB7XG4gICAgdmVyc2lvbjogZGVjb2RlZC5zbGljZShIRFByaXZhdGVLZXkuVmVyc2lvblN0YXJ0LCBIRFByaXZhdGVLZXkuVmVyc2lvbkVuZCksXG4gICAgZGVwdGg6IGRlY29kZWQuc2xpY2UoSERQcml2YXRlS2V5LkRlcHRoU3RhcnQsIEhEUHJpdmF0ZUtleS5EZXB0aEVuZCksXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IGRlY29kZWQuc2xpY2UoSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50U3RhcnQsXG4gICAgICBIRFByaXZhdGVLZXkuUGFyZW50RmluZ2VyUHJpbnRFbmQpLFxuICAgIGNoaWxkSW5kZXg6IGRlY29kZWQuc2xpY2UoSERQcml2YXRlS2V5LkNoaWxkSW5kZXhTdGFydCwgSERQcml2YXRlS2V5LkNoaWxkSW5kZXhFbmQpLFxuICAgIGNoYWluQ29kZTogZGVjb2RlZC5zbGljZShIRFByaXZhdGVLZXkuQ2hhaW5Db2RlU3RhcnQsIEhEUHJpdmF0ZUtleS5DaGFpbkNvZGVFbmQpLFxuICAgIHByaXZhdGVLZXk6IGRlY29kZWQuc2xpY2UoSERQcml2YXRlS2V5LlByaXZhdGVLZXlTdGFydCwgSERQcml2YXRlS2V5LlByaXZhdGVLZXlFbmQpLFxuICAgIGNoZWNrc3VtOiBkZWNvZGVkLnNsaWNlKEhEUHJpdmF0ZUtleS5DaGVja3N1bVN0YXJ0LCBIRFByaXZhdGVLZXkuQ2hlY2tzdW1FbmQpLFxuICAgIHhwcml2a2V5OiBhcmdcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbUJ1ZmZlcnMoYnVmZmVycyk7XG59O1xuXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLl9nZW5lcmF0ZVJhbmRvbWx5ID0gZnVuY3Rpb24obmV0d29yaykge1xuICByZXR1cm4gSERQcml2YXRlS2V5LmZyb21TZWVkKFJhbmRvbS5nZXRSYW5kb21CdWZmZXIoNjQpLCBuZXR3b3JrKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBwcml2YXRlIGtleSBmcm9tIGEgc2VlZCwgYXMgZGVzY3JpYmVkIGluIEJJUDMyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBoZXhhXG4gKiBAcGFyYW0geyp9IG5ldHdvcmtcbiAqIEByZXR1cm4gSERQcml2YXRlS2V5XG4gKi9cbkhEUHJpdmF0ZUtleS5mcm9tU2VlZCA9IGZ1bmN0aW9uKGhleGEsIG5ldHdvcmspIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDggKi9cbiAgaWYgKEpTVXRpbC5pc0hleGFTdHJpbmcoaGV4YSkpIHtcbiAgICBoZXhhID0gQnVmZmVyLmZyb20oaGV4YSwgJ2hleCcpO1xuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGhleGEpKSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRFbnRyb3B5QXJndW1lbnQoaGV4YSk7XG4gIH1cbiAgaWYgKGhleGEubGVuZ3RoIDwgTUlOSU1VTV9FTlRST1BZX0JJVFMgKiBCSVRTX1RPX0JZVEVTKSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRFbnRyb3B5QXJndW1lbnQuTm90RW5vdWdoRW50cm9weShoZXhhKTtcbiAgfVxuICBpZiAoaGV4YS5sZW5ndGggPiBNQVhJTVVNX0VOVFJPUFlfQklUUyAqIEJJVFNfVE9fQllURVMpIHtcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuSW52YWxpZEVudHJvcHlBcmd1bWVudC5Ub29NdWNoRW50cm9weShoZXhhKTtcbiAgfVxuICB2YXIgaGFzaCA9IEhhc2guc2hhNTEyaG1hYyhoZXhhLCBCdWZmZXIuZnJvbSgnQml0Y29pbiBzZWVkJykpO1xuXG4gIHJldHVybiBuZXcgSERQcml2YXRlS2V5KHtcbiAgICBuZXR3b3JrOiBOZXR3b3JrLmdldChuZXR3b3JrKSB8fCBOZXR3b3JrLmRlZmF1bHROZXR3b3JrLFxuICAgIGRlcHRoOiAwLFxuICAgIHBhcmVudEZpbmdlclByaW50OiAwLFxuICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgcHJpdmF0ZUtleTogaGFzaC5zbGljZSgwLCAzMiksXG4gICAgY2hhaW5Db2RlOiBoYXNoLnNsaWNlKDMyLCA2NClcbiAgfSk7XG59O1xuXG5cblxuSERQcml2YXRlS2V5LnByb3RvdHlwZS5fY2FsY0hEUHVibGljS2V5ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5faGRQdWJsaWNLZXkpIHtcbiAgICB2YXIgSERQdWJsaWNLZXkgPSByZXF1aXJlKCcuL2hkcHVibGlja2V5Jyk7XG4gICAgdGhpcy5faGRQdWJsaWNLZXkgPSBuZXcgSERQdWJsaWNLZXkodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgYSBvYmplY3Qgd2l0aCBidWZmZXJzIGluIGFsbCB0aGUgcHJvcGVydGllcyBhbmQgcG9wdWxhdGVzIHRoZVxuICogaW50ZXJuYWwgc3RydWN0dXJlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ1xuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcudmVyc2lvblxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcuZGVwdGhcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLnBhcmVudEZpbmdlclByaW50XG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5jaGlsZEluZGV4XG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5jaGFpbkNvZGVcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLnByaXZhdGVLZXlcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmNoZWNrc3VtXG4gKiBAcGFyYW0ge3N0cmluZz19IGFyZy54cHJpdmtleSAtIGlmIHNldCwgZG9uJ3QgcmVjYWxjdWxhdGUgdGhlIGJhc2U1OFxuICogICAgICByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7SERQcml2YXRlS2V5fSB0aGlzXG4gKi9cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuX2J1aWxkRnJvbUJ1ZmZlcnMgPSBmdW5jdGlvbihhcmcpIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDggKi9cbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDIwICovXG5cbiAgSERQcml2YXRlS2V5Ll92YWxpZGF0ZUJ1ZmZlckFyZ3VtZW50cyhhcmcpO1xuXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xuICAgIF9idWZmZXJzOiBhcmdcbiAgfSk7XG5cbiAgdmFyIHNlcXVlbmNlID0gW1xuICAgIGFyZy52ZXJzaW9uLCBhcmcuZGVwdGgsIGFyZy5wYXJlbnRGaW5nZXJQcmludCwgYXJnLmNoaWxkSW5kZXgsIGFyZy5jaGFpbkNvZGUsXG4gICAgQnVmZmVyVXRpbC5lbXB0eUJ1ZmZlcigxKSwgYXJnLnByaXZhdGVLZXlcbiAgXTtcbiAgdmFyIGNvbmNhdCA9IGJ1ZmZlci5CdWZmZXIuY29uY2F0KHNlcXVlbmNlKTtcbiAgaWYgKCFhcmcuY2hlY2tzdW0gfHwgIWFyZy5jaGVja3N1bS5sZW5ndGgpIHtcbiAgICBhcmcuY2hlY2tzdW0gPSBCYXNlNThDaGVjay5jaGVja3N1bShjb25jYXQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChhcmcuY2hlY2tzdW0udG9TdHJpbmcoKSAhPT0gQmFzZTU4Q2hlY2suY2hlY2tzdW0oY29uY2F0KS50b1N0cmluZygpKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRCNThDaGVja3N1bShjb25jYXQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXR3b3JrID0gTmV0d29yay5nZXQoQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcihhcmcudmVyc2lvbikpO1xuICB2YXIgeHByaXZrZXk7XG4gIHhwcml2a2V5ID0gQmFzZTU4Q2hlY2suZW5jb2RlKGJ1ZmZlci5CdWZmZXIuY29uY2F0KHNlcXVlbmNlKSk7XG4gIGFyZy54cHJpdmtleSA9IEJ1ZmZlci5mcm9tKHhwcml2a2V5KTtcblxuICB2YXIgcHJpdmF0ZUtleSA9IG5ldyBQcml2YXRlS2V5KEJOLmZyb21CdWZmZXIoYXJnLnByaXZhdGVLZXkpLCBuZXR3b3JrKTtcbiAgdmFyIHB1YmxpY0tleSA9IHByaXZhdGVLZXkudG9QdWJsaWNLZXkoKTtcbiAgdmFyIHNpemUgPSBIRFByaXZhdGVLZXkuUGFyZW50RmluZ2VyUHJpbnRTaXplO1xuICB2YXIgZmluZ2VyUHJpbnQgPSBIYXNoLnNoYTI1NnJpcGVtZDE2MChwdWJsaWNLZXkudG9CdWZmZXIoKSkuc2xpY2UoMCwgc2l6ZSk7XG5cbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XG4gICAgeHByaXZrZXk6IHhwcml2a2V5LFxuICAgIG5ldHdvcms6IG5ldHdvcmssXG4gICAgZGVwdGg6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21TaW5nbGVCeXRlQnVmZmVyKGFyZy5kZXB0aCksXG4gICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSxcbiAgICBmaW5nZXJQcmludDogZmluZ2VyUHJpbnRcbiAgfSk7XG5cbiAgdGhpcy5faGRQdWJsaWNLZXkgPSBudWxsO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaGRQdWJsaWNLZXknLCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jYWxjSERQdWJsaWNLZXkoKTtcbiAgICAgIHJldHVybiB0aGlzLl9oZFB1YmxpY0tleTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3hwdWJrZXknLCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jYWxjSERQdWJsaWNLZXkoKTtcbiAgICAgIHJldHVybiB0aGlzLl9oZFB1YmxpY0tleS54cHVia2V5O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuSERQcml2YXRlS2V5Ll92YWxpZGF0ZUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKGFyZykge1xuICB2YXIgY2hlY2tCdWZmZXIgPSBmdW5jdGlvbihuYW1lLCBzaXplKSB7XG4gICAgdmFyIGJ1ZmYgPSBhcmdbbmFtZV07XG4gICAgYXNzZXJ0KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmZiksIG5hbWUgKyAnIGFyZ3VtZW50IGlzIG5vdCBhIGJ1ZmZlcicpO1xuICAgIGFzc2VydChcbiAgICAgIGJ1ZmYubGVuZ3RoID09PSBzaXplLFxuICAgICAgbmFtZSArICcgaGFzIG5vdCB0aGUgZXhwZWN0ZWQgc2l6ZTogZm91bmQgJyArIGJ1ZmYubGVuZ3RoICsgJywgZXhwZWN0ZWQgJyArIHNpemVcbiAgICApO1xuICB9O1xuICBjaGVja0J1ZmZlcigndmVyc2lvbicsIEhEUHJpdmF0ZUtleS5WZXJzaW9uU2l6ZSk7XG4gIGNoZWNrQnVmZmVyKCdkZXB0aCcsIEhEUHJpdmF0ZUtleS5EZXB0aFNpemUpO1xuICBjaGVja0J1ZmZlcigncGFyZW50RmluZ2VyUHJpbnQnLCBIRFByaXZhdGVLZXkuUGFyZW50RmluZ2VyUHJpbnRTaXplKTtcbiAgY2hlY2tCdWZmZXIoJ2NoaWxkSW5kZXgnLCBIRFByaXZhdGVLZXkuQ2hpbGRJbmRleFNpemUpO1xuICBjaGVja0J1ZmZlcignY2hhaW5Db2RlJywgSERQcml2YXRlS2V5LkNoYWluQ29kZVNpemUpO1xuICBjaGVja0J1ZmZlcigncHJpdmF0ZUtleScsIEhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5U2l6ZSk7XG4gIGlmIChhcmcuY2hlY2tzdW0gJiYgYXJnLmNoZWNrc3VtLmxlbmd0aCkge1xuICAgIGNoZWNrQnVmZmVyKCdjaGVja3N1bScsIEhEUHJpdmF0ZUtleS5DaGVja1N1bVNpemUpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHByaXZhdGUga2V5IChhIHN0cmluZyBzdGFydGluZ1xuICogd2l0aCBcInhwcnYuLi5cIlxuICpcbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueHByaXZrZXk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnNvbGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBleHRlbmRlZCBwcml2YXRlIGtleS5cbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxIRFByaXZhdGVLZXk6ICcgKyB0aGlzLnhwcml2a2V5ICsgJz4nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHdpdGggYSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHByaXZhdGUga2V5LlxuICpcbiAqIEZpZWxkcyBpbmNsdWRlOjx1bD5cbiAqIDxsaT4gbmV0d29yazogZWl0aGVyICdsaXZlbmV0JyBvciAndGVzdG5ldCdcbiAqIDxsaT4gZGVwdGg6IGEgbnVtYmVyIHJhbmdpbmcgZnJvbSAwIHRvIDI1NVxuICogPGxpPiBmaW5nZXJQcmludDogYSBudW1iZXIgcmFuZ2luZyBmcm9tIDAgdG8gMl4zMi0xLCB0YWtlbiBmcm9tIHRoZSBoYXNoIG9mIHRoZVxuICogPGxpPiAgICAgYXNzb2NpYXRlZCBwdWJsaWMga2V5XG4gKiA8bGk+IHBhcmVudEZpbmdlclByaW50OiBhIG51bWJlciByYW5naW5nIGZyb20gMCB0byAyXjMyLTEsIHRha2VuIGZyb20gdGhlIGhhc2hcbiAqIDxsaT4gICAgIG9mIHRoaXMgcGFyZW50J3MgYXNzb2NpYXRlZCBwdWJsaWMga2V5IG9yIHplcm8uXG4gKiA8bGk+IGNoaWxkSW5kZXg6IHRoZSBpbmRleCBmcm9tIHdoaWNoIHRoaXMgY2hpbGQgd2FzIGRlcml2ZWQgKG9yIHplcm8pXG4gKiA8bGk+IGNoYWluQ29kZTogYW4gaGV4YSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgbnVtYmVyIHVzZWQgaW4gdGhlIGRlcml2YXRpb25cbiAqIDxsaT4gcHJpdmF0ZUtleTogdGhlIHByaXZhdGUga2V5IGFzc29jaWF0ZWQsIGluIGhleGEgcmVwcmVzZW50YXRpb25cbiAqIDxsaT4geHByaXZrZXk6IHRoZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV4dGVuZGVkIHByaXZhdGUga2V5IGluIGNoZWNrc3VtXG4gKiA8bGk+ICAgICBiYXNlNTggZm9ybWF0XG4gKiA8bGk+IGNoZWNrc3VtOiB0aGUgYmFzZTU4IGNoZWNrc3VtIG9mIHhwcml2a2V5XG4gKiA8L3VsPlxuICogIEByZXR1cm4ge09iamVjdH1cbiAqL1xuSERQcml2YXRlS2V5LnByb3RvdHlwZS50b09iamVjdCA9IEhEUHJpdmF0ZUtleS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgbmV0d29yazogTmV0d29yay5nZXQoQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih0aGlzLl9idWZmZXJzLnZlcnNpb24pLCAneHByaXZrZXknKS5uYW1lLFxuICAgIGRlcHRoOiBCdWZmZXJVdGlsLmludGVnZXJGcm9tU2luZ2xlQnl0ZUJ1ZmZlcih0aGlzLl9idWZmZXJzLmRlcHRoKSxcbiAgICBmaW5nZXJQcmludDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih0aGlzLmZpbmdlclByaW50KSxcbiAgICBwYXJlbnRGaW5nZXJQcmludDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih0aGlzLl9idWZmZXJzLnBhcmVudEZpbmdlclByaW50KSxcbiAgICBjaGlsZEluZGV4OiBCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuX2J1ZmZlcnMuY2hpbGRJbmRleCksXG4gICAgY2hhaW5Db2RlOiBCdWZmZXJVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuX2J1ZmZlcnMuY2hhaW5Db2RlKSxcbiAgICBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXkudG9CdWZmZXIoKS50b1N0cmluZygnaGV4JyksXG4gICAgY2hlY2tzdW06IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy5jaGVja3N1bSksXG4gICAgeHByaXZrZXk6IHRoaXMueHByaXZrZXlcbiAgfTtcbn07XG5cbi8qKlxuICogQnVpbGQgYSBIRFByaXZhdGVLZXkgZnJvbSBhIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBhcmdcbiAqIEByZXR1cm4ge0hEUHJpdmF0ZUtleX1cbiAqL1xuSERQcml2YXRlS2V5LmZyb21CdWZmZXIgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIG5ldyBIRFByaXZhdGVLZXkoYXJnLnRvU3RyaW5nKCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBIRFByaXZhdGVLZXlcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEJ1ZmZlclV0aWwuY29weSh0aGlzLl9idWZmZXJzLnhwcml2a2V5KTtcbn07XG5cbkhEUHJpdmF0ZUtleS5EZWZhdWx0RGVwdGggPSAwO1xuSERQcml2YXRlS2V5LkRlZmF1bHRGaW5nZXJwcmludCA9IDA7XG5IRFByaXZhdGVLZXkuRGVmYXVsdENoaWxkSW5kZXggPSAwO1xuSERQcml2YXRlS2V5LkhhcmRlbmVkID0gMHg4MDAwMDAwMDtcbkhEUHJpdmF0ZUtleS5NYXhJbmRleCA9IDIgKiBIRFByaXZhdGVLZXkuSGFyZGVuZWQ7XG5cbkhEUHJpdmF0ZUtleS5Sb290RWxlbWVudEFsaWFzID0gWydtJywgJ00nLCAnbVxcJycsICdNXFwnJ107XG5cbkhEUHJpdmF0ZUtleS5WZXJzaW9uU2l6ZSA9IDQ7XG5IRFByaXZhdGVLZXkuRGVwdGhTaXplID0gMTtcbkhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludFNpemUgPSA0O1xuSERQcml2YXRlS2V5LkNoaWxkSW5kZXhTaXplID0gNDtcbkhEUHJpdmF0ZUtleS5DaGFpbkNvZGVTaXplID0gMzI7XG5IRFByaXZhdGVLZXkuUHJpdmF0ZUtleVNpemUgPSAzMjtcbkhEUHJpdmF0ZUtleS5DaGVja1N1bVNpemUgPSA0O1xuXG5IRFByaXZhdGVLZXkuRGF0YUxlbmd0aCA9IDc4O1xuSERQcml2YXRlS2V5LlNlcmlhbGl6ZWRCeXRlU2l6ZSA9IDgyO1xuXG5IRFByaXZhdGVLZXkuVmVyc2lvblN0YXJ0ID0gMDtcbkhEUHJpdmF0ZUtleS5WZXJzaW9uRW5kID0gSERQcml2YXRlS2V5LlZlcnNpb25TdGFydCArIEhEUHJpdmF0ZUtleS5WZXJzaW9uU2l6ZTtcbkhEUHJpdmF0ZUtleS5EZXB0aFN0YXJ0ID0gSERQcml2YXRlS2V5LlZlcnNpb25FbmQ7XG5IRFByaXZhdGVLZXkuRGVwdGhFbmQgPSBIRFByaXZhdGVLZXkuRGVwdGhTdGFydCArIEhEUHJpdmF0ZUtleS5EZXB0aFNpemU7XG5IRFByaXZhdGVLZXkuUGFyZW50RmluZ2VyUHJpbnRTdGFydCA9IEhEUHJpdmF0ZUtleS5EZXB0aEVuZDtcbkhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludEVuZCA9IEhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludFN0YXJ0ICsgSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50U2l6ZTtcbkhEUHJpdmF0ZUtleS5DaGlsZEluZGV4U3RhcnQgPSBIRFByaXZhdGVLZXkuUGFyZW50RmluZ2VyUHJpbnRFbmQ7XG5IRFByaXZhdGVLZXkuQ2hpbGRJbmRleEVuZCA9IEhEUHJpdmF0ZUtleS5DaGlsZEluZGV4U3RhcnQgKyBIRFByaXZhdGVLZXkuQ2hpbGRJbmRleFNpemU7XG5IRFByaXZhdGVLZXkuQ2hhaW5Db2RlU3RhcnQgPSBIRFByaXZhdGVLZXkuQ2hpbGRJbmRleEVuZDtcbkhEUHJpdmF0ZUtleS5DaGFpbkNvZGVFbmQgPSBIRFByaXZhdGVLZXkuQ2hhaW5Db2RlU3RhcnQgKyBIRFByaXZhdGVLZXkuQ2hhaW5Db2RlU2l6ZTtcbkhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5U3RhcnQgPSBIRFByaXZhdGVLZXkuQ2hhaW5Db2RlRW5kICsgMTtcbkhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5RW5kID0gSERQcml2YXRlS2V5LlByaXZhdGVLZXlTdGFydCArIEhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5U2l6ZTtcbkhEUHJpdmF0ZUtleS5DaGVja3N1bVN0YXJ0ID0gSERQcml2YXRlS2V5LlByaXZhdGVLZXlFbmQ7XG5IRFByaXZhdGVLZXkuQ2hlY2tzdW1FbmQgPSBIRFByaXZhdGVLZXkuQ2hlY2tzdW1TdGFydCArIEhEUHJpdmF0ZUtleS5DaGVja1N1bVNpemU7XG5cbmFzc2VydChIRFByaXZhdGVLZXkuQ2hlY2tzdW1FbmQgPT09IEhEUHJpdmF0ZUtleS5TZXJpYWxpemVkQnl0ZVNpemUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhEUHJpdmF0ZUtleTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/hdprivatekey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/hdpublickey.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/hdpublickey.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar Base58 = __webpack_require__(/*! ./encoding/base58 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\");\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar HDPrivateKey = __webpack_require__(/*! ./hdprivatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/hdprivatekey.js\");\nvar Network = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar Point = __webpack_require__(/*! ./crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\n\nvar bitcoreErrors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\n\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\nHDPublicKey.isValidPath = function(arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.derive = function(arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function(index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});\n  var chainCode = hash.slice(32, 64);\n\n  var publicKey;\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function(path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPublicKey.isValidSerialized = function(data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\nHDPublicKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n  return null;\n};\n\nHDPublicKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey,'hex') :\n      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,\n                                     HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\nHDPublicKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    arg.publicKey\n  ];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n\n  var publicKey = new PublicKey(arg.publicKey, {network: network});\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\nHDPublicKey.prototype.toString = function() {\n  return this.xpubkey;\n};\n\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\nHDPublicKey.prototype.inspect = function() {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\nHDPublicKey.fromBuffer = function(arg) {\n  return new HDPublicKey(arg);\n};\n\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\nHDPublicKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\n\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\n\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\n\nHDPublicKey.VersionStart           = 0;\nHDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart             = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\n\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\n\nmodule.exports = HDPublicKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2hkcHVibGlja2V5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMsd0ZBQXNCOztBQUV0QyxTQUFTLG1CQUFPLENBQUMsc0VBQWE7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLGtGQUFtQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDbEQsV0FBVyxtQkFBTyxDQUFDLDBFQUFlO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFnQjtBQUMzQyxjQUFjLG1CQUFPLENBQUMsb0VBQVk7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBYTs7QUFFckMsb0JBQW9CLG1CQUFPLENBQUMsc0VBQVU7QUFDdEM7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFN0IsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFlOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvaGRwdWJsaWNrZXkuanM/NTM4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbnZhciBCTiA9IHJlcXVpcmUoJy4vY3J5cHRvL2JuJyk7XG52YXIgQmFzZTU4ID0gcmVxdWlyZSgnLi9lbmNvZGluZy9iYXNlNTgnKTtcbnZhciBCYXNlNThDaGVjayA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYmFzZTU4Y2hlY2snKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9jcnlwdG8vaGFzaCcpO1xudmFyIEhEUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vaGRwcml2YXRla2V5Jyk7XG52YXIgTmV0d29yayA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vY3J5cHRvL3BvaW50Jyk7XG52YXIgUHVibGljS2V5ID0gcmVxdWlyZSgnLi9wdWJsaWNrZXknKTtcblxudmFyIGJpdGNvcmVFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGVycm9ycyA9IGJpdGNvcmVFcnJvcnM7XG52YXIgaGRFcnJvcnMgPSBiaXRjb3JlRXJyb3JzLkhEUHVibGljS2V5O1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9idWZmZXInKTtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gaGllcmFyY2hpY2FsbHkgZGVyaXZlZCBwdWJsaWMga2V5LlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDMyLm1lZGlhd2lraVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfEJ1ZmZlcn0gYXJnXG4gKi9cbmZ1bmN0aW9uIEhEUHVibGljS2V5KGFyZykge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTIgKi9cbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDIwICovXG4gIGlmIChhcmcgaW5zdGFuY2VvZiBIRFB1YmxpY0tleSkge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhEUHVibGljS2V5KSkge1xuICAgIHJldHVybiBuZXcgSERQdWJsaWNLZXkoYXJnKTtcbiAgfVxuICBpZiAoYXJnKSB7XG4gICAgaWYgKF8uaXNTdHJpbmcoYXJnKSB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZykpIHtcbiAgICAgIHZhciBlcnJvciA9IEhEUHVibGljS2V5LmdldFNlcmlhbGl6ZWRFcnJvcihhcmcpO1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRGcm9tU2VyaWFsaXplZChhcmcpO1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZykgJiYgIUhEUHVibGljS2V5LmdldFNlcmlhbGl6ZWRFcnJvcihhcmcudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbVNlcmlhbGl6ZWQoYXJnLnRvU3RyaW5nKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgaGRFcnJvcnMuQXJndW1lbnRJc1ByaXZhdGVFeHRlbmRlZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSERQcml2YXRlS2V5KGFyZykuaGRQdWJsaWNLZXk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfLmlzT2JqZWN0KGFyZykpIHtcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEhEUHJpdmF0ZUtleSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZEZyb21Qcml2YXRlKGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbU9iamVjdChhcmcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgaGRFcnJvcnMuVW5yZWNvZ25pemVkQXJndW1lbnQoYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLk11c3RTdXBwbHlBcmd1bWVudCgpO1xuICB9XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBhIGdpdmVuIHBhdGggaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBhcmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkhEUHVibGljS2V5LmlzVmFsaWRQYXRoID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmIChfLmlzU3RyaW5nKGFyZykpIHtcbiAgICB2YXIgaW5kZXhlcyA9IEhEUHJpdmF0ZUtleS5fZ2V0RGVyaXZhdGlvbkluZGV4ZXMoYXJnKTtcbiAgICByZXR1cm4gaW5kZXhlcyAhPT0gbnVsbCAmJiBfLmV2ZXJ5KGluZGV4ZXMsIEhEUHVibGljS2V5LmlzVmFsaWRQYXRoKTtcbiAgfVxuXG4gIGlmIChfLmlzTnVtYmVyKGFyZykpIHtcbiAgICByZXR1cm4gYXJnID49IDAgJiYgYXJnIDwgSERQdWJsaWNLZXkuSGFyZGVuZWQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIFVzZSBkZXJpdmVDaGlsZCBpbnN0ZWFkLlxuICpcbiAqXG4gKiBHZXQgYSBkZXJpdmF0ZWQgY2hpbGQgYmFzZWQgb24gYSBzdHJpbmcgb3IgbnVtYmVyLlxuICpcbiAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgaXQncyBwYXJzZWQgYXMgdGhlIGZ1bGwgcGF0aCBvZlxuICogZGVyaXZhdGlvbi4gVmFsaWQgdmFsdWVzIGZvciB0aGlzIGFyZ3VtZW50IGluY2x1ZGUgXCJtXCIgKHdoaWNoIHJldHVybnMgdGhlXG4gKiBzYW1lIHB1YmxpYyBrZXkpLCBcIm0vMC8xLzQwLzIvMTAwMFwiLlxuICpcbiAqIE5vdGUgdGhhdCBoYXJkZW5lZCBrZXlzIGNhbid0IGJlIGRlcml2ZWQgZnJvbSBhIHB1YmxpYyBleHRlbmRlZCBrZXkuXG4gKlxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgbnVtYmVyLCB0aGUgY2hpbGQgd2l0aCB0aGF0IGluZGV4IHdpbGwgYmVcbiAqIGRlcml2ZWQuIFNlZSB0aGUgZXhhbXBsZSB1c2FnZSBmb3IgY2xhcmlmaWNhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBhcmVudCA9IG5ldyBIRFB1YmxpY0tleSgneHB1Yi4uLicpO1xuICogdmFyIGNoaWxkXzBfMV8yID0gcGFyZW50LmRlcml2ZSgwKS5kZXJpdmUoMSkuZGVyaXZlKDIpO1xuICogdmFyIGNvcHlfb2ZfY2hpbGRfMF8xXzIgPSBwYXJlbnQuZGVyaXZlKFwibS8wLzEvMlwiKTtcbiAqIGFzc2VydChjaGlsZF8wXzFfMi54cHJpdmtleSA9PT0gY29weV9vZl9jaGlsZF8wXzFfMik7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGFyZ1xuICovXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24oYXJnLCBoYXJkZW5lZCkge1xuICByZXR1cm4gdGhpcy5kZXJpdmVDaGlsZChhcmcsIGhhcmRlbmVkKTtcbn07XG5cbi8qKlxuICogV0FSTklORzogVGhpcyBtZXRob2Qgd2lsbCBub3QgYmUgb2ZmaWNpYWxseSBzdXBwb3J0ZWQgdW50aWwgdjEuMC4wLlxuICpcbiAqXG4gKiBHZXQgYSBkZXJpdmF0ZWQgY2hpbGQgYmFzZWQgb24gYSBzdHJpbmcgb3IgbnVtYmVyLlxuICpcbiAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgaXQncyBwYXJzZWQgYXMgdGhlIGZ1bGwgcGF0aCBvZlxuICogZGVyaXZhdGlvbi4gVmFsaWQgdmFsdWVzIGZvciB0aGlzIGFyZ3VtZW50IGluY2x1ZGUgXCJtXCIgKHdoaWNoIHJldHVybnMgdGhlXG4gKiBzYW1lIHB1YmxpYyBrZXkpLCBcIm0vMC8xLzQwLzIvMTAwMFwiLlxuICpcbiAqIE5vdGUgdGhhdCBoYXJkZW5lZCBrZXlzIGNhbid0IGJlIGRlcml2ZWQgZnJvbSBhIHB1YmxpYyBleHRlbmRlZCBrZXkuXG4gKlxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgbnVtYmVyLCB0aGUgY2hpbGQgd2l0aCB0aGF0IGluZGV4IHdpbGwgYmVcbiAqIGRlcml2ZWQuIFNlZSB0aGUgZXhhbXBsZSB1c2FnZSBmb3IgY2xhcmlmaWNhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBhcmVudCA9IG5ldyBIRFB1YmxpY0tleSgneHB1Yi4uLicpO1xuICogdmFyIGNoaWxkXzBfMV8yID0gcGFyZW50LmRlcml2ZUNoaWxkKDApLmRlcml2ZUNoaWxkKDEpLmRlcml2ZUNoaWxkKDIpO1xuICogdmFyIGNvcHlfb2ZfY2hpbGRfMF8xXzIgPSBwYXJlbnQuZGVyaXZlQ2hpbGQoXCJtLzAvMS8yXCIpO1xuICogYXNzZXJ0KGNoaWxkXzBfMV8yLnhwcml2a2V5ID09PSBjb3B5X29mX2NoaWxkXzBfMV8yKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXJnXG4gKi9cbkhEUHVibGljS2V5LnByb3RvdHlwZS5kZXJpdmVDaGlsZCA9IGZ1bmN0aW9uKGFyZywgaGFyZGVuZWQpIHtcbiAgaWYgKF8uaXNOdW1iZXIoYXJnKSkge1xuICAgIHJldHVybiB0aGlzLl9kZXJpdmVXaXRoTnVtYmVyKGFyZywgaGFyZGVuZWQpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYXJnKSkge1xuICAgIHJldHVybiB0aGlzLl9kZXJpdmVGcm9tU3RyaW5nKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWREZXJpdmF0aW9uQXJndW1lbnQoYXJnKTtcbiAgfVxufTtcblxuSERQdWJsaWNLZXkucHJvdG90eXBlLl9kZXJpdmVXaXRoTnVtYmVyID0gZnVuY3Rpb24oaW5kZXgsIGhhcmRlbmVkKSB7XG4gIGlmIChpbmRleCA+PSBIRFB1YmxpY0tleS5IYXJkZW5lZCB8fCBoYXJkZW5lZCkge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkSW5kZXhDYW50RGVyaXZlSGFyZGVuZWQoKTtcbiAgfVxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRQYXRoKGluZGV4KTtcbiAgfVxuXG4gIHZhciBpbmRleEJ1ZmZlciA9IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGluZGV4KTtcbiAgdmFyIGRhdGEgPSBCdWZmZXJVdGlsLmNvbmNhdChbdGhpcy5wdWJsaWNLZXkudG9CdWZmZXIoKSwgaW5kZXhCdWZmZXJdKTtcbiAgdmFyIGhhc2ggPSBIYXNoLnNoYTUxMmhtYWMoZGF0YSwgdGhpcy5fYnVmZmVycy5jaGFpbkNvZGUpO1xuICB2YXIgbGVmdFBhcnQgPSBCTi5mcm9tQnVmZmVyKGhhc2guc2xpY2UoMCwgMzIpLCB7c2l6ZTogMzJ9KTtcbiAgdmFyIGNoYWluQ29kZSA9IGhhc2guc2xpY2UoMzIsIDY0KTtcblxuICB2YXIgcHVibGljS2V5O1xuICB0cnkge1xuICAgIHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tUG9pbnQoUG9pbnQuZ2V0RygpLm11bChsZWZ0UGFydCkuYWRkKHRoaXMucHVibGljS2V5LnBvaW50KSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVyaXZlV2l0aE51bWJlcihpbmRleCArIDEpO1xuICB9XG5cbiAgdmFyIGRlcml2ZWQgPSBuZXcgSERQdWJsaWNLZXkoe1xuICAgIG5ldHdvcms6IHRoaXMubmV0d29yayxcbiAgICBkZXB0aDogdGhpcy5kZXB0aCArIDEsXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IHRoaXMuZmluZ2VyUHJpbnQsXG4gICAgY2hpbGRJbmRleDogaW5kZXgsXG4gICAgY2hhaW5Db2RlOiBjaGFpbkNvZGUsXG4gICAgcHVibGljS2V5OiBwdWJsaWNLZXlcbiAgfSk7XG5cbiAgcmV0dXJuIGRlcml2ZWQ7XG59O1xuXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuX2Rlcml2ZUZyb21TdHJpbmcgPSBmdW5jdGlvbihwYXRoKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG4gIGlmIChfLmluY2x1ZGVzKHBhdGgsIFwiJ1wiKSkge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkSW5kZXhDYW50RGVyaXZlSGFyZGVuZWQoKTtcbiAgfSBlbHNlIGlmICghSERQdWJsaWNLZXkuaXNWYWxpZFBhdGgocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuSW52YWxpZFBhdGgocGF0aCk7XG4gIH1cblxuICB2YXIgaW5kZXhlcyA9IEhEUHJpdmF0ZUtleS5fZ2V0RGVyaXZhdGlvbkluZGV4ZXMocGF0aCk7XG4gIHZhciBkZXJpdmVkID0gaW5kZXhlcy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgaW5kZXgpIHtcbiAgICByZXR1cm4gcHJldi5fZGVyaXZlV2l0aE51bWJlcihpbmRleCk7XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiBkZXJpdmVkO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGEgZ2l2ZW4gc2VyaWFsaXplZCBwdWJsaWMga2V5IGluIGJhc2U1OCB3aXRoIGNoZWNrc3VtIGZvcm1hdFxuICogaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIC0gdGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleVxuICogQHBhcmFtIHtzdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBvcHRpb25hbCwgaWYgcHJlc2VudCwgY2hlY2tzIHRoYXQgdGhlXG4gKiAgICAgbmV0d29yayBwcm92aWRlZCBtYXRjaGVzIHRoZSBuZXR3b3JrIHNlcmlhbGl6ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5IRFB1YmxpY0tleS5pc1ZhbGlkU2VyaWFsaXplZCA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmspIHtcbiAgcmV0dXJuIF8uaXNOdWxsKEhEUHVibGljS2V5LmdldFNlcmlhbGl6ZWRFcnJvcihkYXRhLCBuZXR3b3JrKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGF0J3MgdGhlIGVycm9yIHRoYXQgY2F1c2VzIHRoZSB2YWxpZGF0aW9uIG9mIGEgc2VyaWFsaXplZCBwdWJsaWMga2V5XG4gKiBpbiBiYXNlNTggd2l0aCBjaGVja3N1bSB0byBmYWlsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSAtIHRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfE5ldHdvcms9fSBuZXR3b3JrIC0gb3B0aW9uYWwsIGlmIHByZXNlbnQsIGNoZWNrcyB0aGF0IHRoZVxuICogICAgIG5ldHdvcmsgcHJvdmlkZWQgbWF0Y2hlcyB0aGUgbmV0d29yayBzZXJpYWxpemVkLlxuICogQHJldHVybiB7ZXJyb3JzfG51bGx9XG4gKi9cbkhEUHVibGljS2V5LmdldFNlcmlhbGl6ZWRFcnJvciA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmspIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xuICBpZiAoIShfLmlzU3RyaW5nKGRhdGEpIHx8IEJ1ZmZlclV0aWwuaXNCdWZmZXIoZGF0YSkpKSB7XG4gICAgcmV0dXJuIG5ldyBoZEVycm9ycy5VbnJlY29nbml6ZWRBcmd1bWVudCgnZXhwZWN0ZWQgYnVmZmVyIG9yIHN0cmluZycpO1xuICB9XG4gIGlmICghQmFzZTU4LnZhbGlkQ2hhcmFjdGVycyhkYXRhKSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWRCNThDaGFyKCcodW5rbm93biknLCBkYXRhKTtcbiAgfVxuICB0cnkge1xuICAgIGRhdGEgPSBCYXNlNThDaGVjay5kZWNvZGUoZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbmV3IGVycm9ycy5JbnZhbGlkQjU4Q2hlY2tzdW0oZGF0YSk7XG4gIH1cbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBIRFB1YmxpY0tleS5EYXRhU2l6ZSkge1xuICAgIHJldHVybiBuZXcgaGRFcnJvcnMuSW52YWxpZExlbmd0aChkYXRhKTtcbiAgfVxuICBpZiAoIV8uaXNVbmRlZmluZWQobmV0d29yaykpIHtcbiAgICB2YXIgZXJyb3IgPSBIRFB1YmxpY0tleS5fdmFsaWRhdGVOZXR3b3JrKGRhdGEsIG5ldHdvcmspO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfVxuICB2YXIgdmVyc2lvbiA9IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIoZGF0YS5zbGljZSgwLCA0KSk7XG4gIGlmICh2ZXJzaW9uID09PSBOZXR3b3JrLmxpdmVuZXQueHByaXZrZXkgfHwgdmVyc2lvbiA9PT0gTmV0d29yay50ZXN0bmV0Lnhwcml2a2V5ICkge1xuICAgIHJldHVybiBuZXcgaGRFcnJvcnMuQXJndW1lbnRJc1ByaXZhdGVFeHRlbmRlZCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuSERQdWJsaWNLZXkuX3ZhbGlkYXRlTmV0d29yayA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmtBcmcpIHtcbiAgdmFyIG5ldHdvcmsgPSBOZXR3b3JrLmdldChuZXR3b3JrQXJnKTtcbiAgaWYgKCFuZXR3b3JrKSB7XG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuSW52YWxpZE5ldHdvcmtBcmd1bWVudChuZXR3b3JrQXJnKTtcbiAgfVxuICB2YXIgdmVyc2lvbiA9IGRhdGEuc2xpY2UoSERQdWJsaWNLZXkuVmVyc2lvblN0YXJ0LCBIRFB1YmxpY0tleS5WZXJzaW9uRW5kKTtcbiAgaWYgKEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodmVyc2lvbikgIT09IG5ldHdvcmsueHB1YmtleSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWROZXR3b3JrKHZlcnNpb24pO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuSERQdWJsaWNLZXkucHJvdG90eXBlLl9idWlsZEZyb21Qcml2YXRlID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgYXJncyA9IF8uY2xvbmUoYXJnLl9idWZmZXJzKTtcbiAgdmFyIHBvaW50ID0gUG9pbnQuZ2V0RygpLm11bChCTi5mcm9tQnVmZmVyKGFyZ3MucHJpdmF0ZUtleSkpO1xuICBhcmdzLnB1YmxpY0tleSA9IFBvaW50LnBvaW50VG9Db21wcmVzc2VkKHBvaW50KTtcbiAgYXJncy52ZXJzaW9uID0gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoTmV0d29yay5nZXQoQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcihhcmdzLnZlcnNpb24pKS54cHVia2V5KTtcbiAgYXJncy5wcml2YXRlS2V5ID0gdW5kZWZpbmVkO1xuICBhcmdzLmNoZWNrc3VtID0gdW5kZWZpbmVkO1xuICBhcmdzLnhwcml2a2V5ID0gdW5kZWZpbmVkO1xuICByZXR1cm4gdGhpcy5fYnVpbGRGcm9tQnVmZmVycyhhcmdzKTtcbn07XG5cbkhEUHVibGljS2V5LnByb3RvdHlwZS5fYnVpbGRGcm9tT2JqZWN0ID0gZnVuY3Rpb24oYXJnKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMCAqL1xuICAvLyBUT0RPOiBUeXBlIHZhbGlkYXRpb25cbiAgdmFyIGJ1ZmZlcnMgPSB7XG4gICAgdmVyc2lvbjogYXJnLm5ldHdvcmsgPyBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihOZXR3b3JrLmdldChhcmcubmV0d29yaykueHB1YmtleSkgOiBhcmcudmVyc2lvbixcbiAgICBkZXB0aDogXy5pc051bWJlcihhcmcuZGVwdGgpID8gQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKGFyZy5kZXB0aCkgOiBhcmcuZGVwdGgsXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IF8uaXNOdW1iZXIoYXJnLnBhcmVudEZpbmdlclByaW50KSA/IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGFyZy5wYXJlbnRGaW5nZXJQcmludCkgOiBhcmcucGFyZW50RmluZ2VyUHJpbnQsXG4gICAgY2hpbGRJbmRleDogXy5pc051bWJlcihhcmcuY2hpbGRJbmRleCkgPyBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihhcmcuY2hpbGRJbmRleCkgOiBhcmcuY2hpbGRJbmRleCxcbiAgICBjaGFpbkNvZGU6IF8uaXNTdHJpbmcoYXJnLmNoYWluQ29kZSkgPyBCdWZmZXIuZnJvbShhcmcuY2hhaW5Db2RlLCdoZXgnKSA6IGFyZy5jaGFpbkNvZGUsXG4gICAgcHVibGljS2V5OiBfLmlzU3RyaW5nKGFyZy5wdWJsaWNLZXkpID8gQnVmZmVyLmZyb20oYXJnLnB1YmxpY0tleSwnaGV4JykgOlxuICAgICAgQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcucHVibGljS2V5KSA/IGFyZy5wdWJsaWNLZXkgOiBhcmcucHVibGljS2V5LnRvQnVmZmVyKCksXG4gICAgY2hlY2tzdW06IF8uaXNOdW1iZXIoYXJnLmNoZWNrc3VtKSA/IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGFyZy5jaGVja3N1bSkgOiBhcmcuY2hlY2tzdW1cbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbUJ1ZmZlcnMoYnVmZmVycyk7XG59O1xuXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuX2J1aWxkRnJvbVNlcmlhbGl6ZWQgPSBmdW5jdGlvbihhcmcpIHtcbiAgdmFyIGRlY29kZWQgPSBCYXNlNThDaGVjay5kZWNvZGUoYXJnKTtcbiAgdmFyIGJ1ZmZlcnMgPSB7XG4gICAgdmVyc2lvbjogZGVjb2RlZC5zbGljZShIRFB1YmxpY0tleS5WZXJzaW9uU3RhcnQsIEhEUHVibGljS2V5LlZlcnNpb25FbmQpLFxuICAgIGRlcHRoOiBkZWNvZGVkLnNsaWNlKEhEUHVibGljS2V5LkRlcHRoU3RhcnQsIEhEUHVibGljS2V5LkRlcHRoRW5kKSxcbiAgICBwYXJlbnRGaW5nZXJQcmludDogZGVjb2RlZC5zbGljZShIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50RW5kKSxcbiAgICBjaGlsZEluZGV4OiBkZWNvZGVkLnNsaWNlKEhEUHVibGljS2V5LkNoaWxkSW5kZXhTdGFydCwgSERQdWJsaWNLZXkuQ2hpbGRJbmRleEVuZCksXG4gICAgY2hhaW5Db2RlOiBkZWNvZGVkLnNsaWNlKEhEUHVibGljS2V5LkNoYWluQ29kZVN0YXJ0LCBIRFB1YmxpY0tleS5DaGFpbkNvZGVFbmQpLFxuICAgIHB1YmxpY0tleTogZGVjb2RlZC5zbGljZShIRFB1YmxpY0tleS5QdWJsaWNLZXlTdGFydCwgSERQdWJsaWNLZXkuUHVibGljS2V5RW5kKSxcbiAgICBjaGVja3N1bTogZGVjb2RlZC5zbGljZShIRFB1YmxpY0tleS5DaGVja3N1bVN0YXJ0LCBIRFB1YmxpY0tleS5DaGVja3N1bUVuZCksXG4gICAgeHB1YmtleTogYXJnXG4gIH07XG4gIHJldHVybiB0aGlzLl9idWlsZEZyb21CdWZmZXJzKGJ1ZmZlcnMpO1xufTtcblxuLyoqXG4gKiBSZWNlaXZlcyBhIG9iamVjdCB3aXRoIGJ1ZmZlcnMgaW4gYWxsIHRoZSBwcm9wZXJ0aWVzIGFuZCBwb3B1bGF0ZXMgdGhlXG4gKiBpbnRlcm5hbCBzdHJ1Y3R1cmVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy52ZXJzaW9uXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5kZXB0aFxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcucGFyZW50RmluZ2VyUHJpbnRcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmNoaWxkSW5kZXhcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmNoYWluQ29kZVxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcucHVibGljS2V5XG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5jaGVja3N1bVxuICogQHBhcmFtIHtzdHJpbmc9fSBhcmcueHB1YmtleSAtIGlmIHNldCwgZG9uJ3QgcmVjYWxjdWxhdGUgdGhlIGJhc2U1OFxuICogICAgICByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7SERQdWJsaWNLZXl9IHRoaXNcbiAqL1xuSERQdWJsaWNLZXkucHJvdG90eXBlLl9idWlsZEZyb21CdWZmZXJzID0gZnVuY3Rpb24oYXJnKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xuXG4gIEhEUHVibGljS2V5Ll92YWxpZGF0ZUJ1ZmZlckFyZ3VtZW50cyhhcmcpO1xuXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xuICAgIF9idWZmZXJzOiBhcmdcbiAgfSk7XG5cbiAgdmFyIHNlcXVlbmNlID0gW1xuICAgIGFyZy52ZXJzaW9uLCBhcmcuZGVwdGgsIGFyZy5wYXJlbnRGaW5nZXJQcmludCwgYXJnLmNoaWxkSW5kZXgsIGFyZy5jaGFpbkNvZGUsXG4gICAgYXJnLnB1YmxpY0tleVxuICBdO1xuICB2YXIgY29uY2F0ID0gQnVmZmVyVXRpbC5jb25jYXQoc2VxdWVuY2UpO1xuICB2YXIgY2hlY2tzdW0gPSBCYXNlNThDaGVjay5jaGVja3N1bShjb25jYXQpO1xuICBpZiAoIWFyZy5jaGVja3N1bSB8fCAhYXJnLmNoZWNrc3VtLmxlbmd0aCkge1xuICAgIGFyZy5jaGVja3N1bSA9IGNoZWNrc3VtO1xuICB9IGVsc2Uge1xuICAgIGlmIChhcmcuY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpICE9PSBjaGVja3N1bS50b1N0cmluZygnaGV4JykpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEI1OENoZWNrc3VtKGNvbmNhdCwgY2hlY2tzdW0pO1xuICAgIH1cbiAgfVxuICB2YXIgbmV0d29yayA9IE5ldHdvcmsuZ2V0KEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIoYXJnLnZlcnNpb24pKTtcblxuICB2YXIgeHB1YmtleTtcbiAgeHB1YmtleSA9IEJhc2U1OENoZWNrLmVuY29kZShCdWZmZXJVdGlsLmNvbmNhdChzZXF1ZW5jZSkpO1xuICBhcmcueHB1YmtleSA9IEJ1ZmZlci5mcm9tKHhwdWJrZXkpO1xuXG4gIHZhciBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGFyZy5wdWJsaWNLZXksIHtuZXR3b3JrOiBuZXR3b3JrfSk7XG4gIHZhciBzaXplID0gSERQdWJsaWNLZXkuUGFyZW50RmluZ2VyUHJpbnRTaXplO1xuICB2YXIgZmluZ2VyUHJpbnQgPSBIYXNoLnNoYTI1NnJpcGVtZDE2MChwdWJsaWNLZXkudG9CdWZmZXIoKSkuc2xpY2UoMCwgc2l6ZSk7XG5cbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XG4gICAgeHB1YmtleTogeHB1YmtleSxcbiAgICBuZXR3b3JrOiBuZXR3b3JrLFxuICAgIGRlcHRoOiBCdWZmZXJVdGlsLmludGVnZXJGcm9tU2luZ2xlQnl0ZUJ1ZmZlcihhcmcuZGVwdGgpLFxuICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgIGZpbmdlclByaW50OiBmaW5nZXJQcmludFxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkhEUHVibGljS2V5Ll92YWxpZGF0ZUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKGFyZykge1xuICB2YXIgY2hlY2tCdWZmZXIgPSBmdW5jdGlvbihuYW1lLCBzaXplKSB7XG4gICAgdmFyIGJ1ZmYgPSBhcmdbbmFtZV07XG4gICAgYXNzZXJ0KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmZiksIG5hbWUgKyAnIGFyZ3VtZW50IGlzIG5vdCBhIGJ1ZmZlciwgaXRcXCdzICcgKyB0eXBlb2YgYnVmZik7XG4gICAgYXNzZXJ0KFxuICAgICAgYnVmZi5sZW5ndGggPT09IHNpemUsXG4gICAgICBuYW1lICsgJyBoYXMgbm90IHRoZSBleHBlY3RlZCBzaXplOiBmb3VuZCAnICsgYnVmZi5sZW5ndGggKyAnLCBleHBlY3RlZCAnICsgc2l6ZVxuICAgICk7XG4gIH07XG4gIGNoZWNrQnVmZmVyKCd2ZXJzaW9uJywgSERQdWJsaWNLZXkuVmVyc2lvblNpemUpO1xuICBjaGVja0J1ZmZlcignZGVwdGgnLCBIRFB1YmxpY0tleS5EZXB0aFNpemUpO1xuICBjaGVja0J1ZmZlcigncGFyZW50RmluZ2VyUHJpbnQnLCBIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludFNpemUpO1xuICBjaGVja0J1ZmZlcignY2hpbGRJbmRleCcsIEhEUHVibGljS2V5LkNoaWxkSW5kZXhTaXplKTtcbiAgY2hlY2tCdWZmZXIoJ2NoYWluQ29kZScsIEhEUHVibGljS2V5LkNoYWluQ29kZVNpemUpO1xuICBjaGVja0J1ZmZlcigncHVibGljS2V5JywgSERQdWJsaWNLZXkuUHVibGljS2V5U2l6ZSk7XG4gIGlmIChhcmcuY2hlY2tzdW0gJiYgYXJnLmNoZWNrc3VtLmxlbmd0aCkge1xuICAgIGNoZWNrQnVmZmVyKCdjaGVja3N1bScsIEhEUHVibGljS2V5LkNoZWNrU3VtU2l6ZSk7XG4gIH1cbn07XG5cbkhEUHVibGljS2V5LmZyb21TdHJpbmcgPSBmdW5jdGlvbihhcmcpIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcoYXJnKSwgJ05vIHZhbGlkIHN0cmluZyB3YXMgcHJvdmlkZWQnKTtcbiAgcmV0dXJuIG5ldyBIRFB1YmxpY0tleShhcmcpO1xufTtcblxuSERQdWJsaWNLZXkuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGFyZykge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc09iamVjdChhcmcpLCAnTm8gdmFsaWQgYXJndW1lbnQgd2FzIHByb3ZpZGVkJyk7XG4gIHJldHVybiBuZXcgSERQdWJsaWNLZXkoYXJnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZTU4IGNoZWNrZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAqIEByZXR1cm4ge3N0cmluZ30gYSBzdHJpbmcgc3RhcnRpbmcgd2l0aCBcInhwdWIuLi5cIiBpbiBsaXZlbmV0XG4gKi9cbkhEUHVibGljS2V5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54cHVia2V5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb25zb2xlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXh0ZW5kZWQgcHVibGljIGtleS5cbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cbkhEUHVibGljS2V5LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPEhEUHVibGljS2V5OiAnICsgdGhpcy54cHVia2V5ICsgJz4nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiB0byByZWNvbnN0cnVjdCBhIGtleS5cbiAqXG4gKiBGaWVsZHMgYXJlOiA8dWw+XG4gKiAgPGxpPiBuZXR3b3JrOiAnbGl2ZW5ldCcgb3IgJ3Rlc3RuZXQnXG4gKiAgPGxpPiBkZXB0aDogYSBudW1iZXIgZnJvbSAwIHRvIDI1NSwgdGhlIGRlcHRoIHRvIHRoZSBtYXN0ZXIgZXh0ZW5kZWQga2V5XG4gKiAgPGxpPiBmaW5nZXJQcmludDogYSBudW1iZXIgb2YgMzIgYml0cyB0YWtlbiBmcm9tIHRoZSBoYXNoIG9mIHRoZSBwdWJsaWMga2V5XG4gKiAgPGxpPiBmaW5nZXJQcmludDogYSBudW1iZXIgb2YgMzIgYml0cyB0YWtlbiBmcm9tIHRoZSBoYXNoIG9mIHRoaXMga2V5J3NcbiAqICA8bGk+ICAgICBwYXJlbnQncyBwdWJsaWMga2V5XG4gKiAgPGxpPiBjaGlsZEluZGV4OiBpbmRleCB3aXRoIHdoaWNoIHRoaXMga2V5IHdhcyBkZXJpdmVkXG4gKiAgPGxpPiBjaGFpbkNvZGU6IHN0cmluZyBpbiBoZXhhIGVuY29kaW5nIHVzZWQgZm9yIGRlcml2YXRpb25cbiAqICA8bGk+IHB1YmxpY0tleTogc3RyaW5nLCBoZXhhIGVuY29kZWQsIGluIGNvbXByZXNzZWQga2V5IGZvcm1hdFxuICogIDxsaT4gY2hlY2tzdW06IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy5jaGVja3N1bSksXG4gKiAgPGxpPiB4cHVia2V5OiB0aGUgc3RyaW5nIHdpdGggdGhlIGJhc2U1OCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV4dGVuZGVkIGtleVxuICogIDxsaT4gY2hlY2tzdW06IHRoZSBiYXNlNTggY2hlY2tzdW0gb2YgeHB1YmtleVxuICogPC91bD5cbiAqL1xuSERQdWJsaWNLZXkucHJvdG90eXBlLnRvT2JqZWN0ID0gSERQdWJsaWNLZXkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIG5ldHdvcms6IE5ldHdvcmsuZ2V0KEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy52ZXJzaW9uKSkubmFtZSxcbiAgICBkZXB0aDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbVNpbmdsZUJ5dGVCdWZmZXIodGhpcy5fYnVmZmVycy5kZXB0aCksXG4gICAgZmluZ2VyUHJpbnQ6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5maW5nZXJQcmludCksXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy5wYXJlbnRGaW5nZXJQcmludCksXG4gICAgY2hpbGRJbmRleDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih0aGlzLl9idWZmZXJzLmNoaWxkSW5kZXgpLFxuICAgIGNoYWluQ29kZTogQnVmZmVyVXRpbC5idWZmZXJUb0hleCh0aGlzLl9idWZmZXJzLmNoYWluQ29kZSksXG4gICAgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleS50b1N0cmluZygpLFxuICAgIGNoZWNrc3VtOiBCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuX2J1ZmZlcnMuY2hlY2tzdW0pLFxuICAgIHhwdWJrZXk6IHRoaXMueHB1YmtleVxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBIRFB1YmxpY0tleSBmcm9tIGEgYnVmZmVyIGFyZ3VtZW50XG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFyZ1xuICogQHJldHVybiB7SERQdWJsaWNLZXl9XG4gKi9cbkhEUHVibGljS2V5LmZyb21CdWZmZXIgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIG5ldyBIRFB1YmxpY0tleShhcmcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHhwdWJrZXlcbiAqXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbkhEUHVibGljS2V5LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQnVmZmVyVXRpbC5jb3B5KHRoaXMuX2J1ZmZlcnMueHB1YmtleSk7XG59O1xuXG5IRFB1YmxpY0tleS5IYXJkZW5lZCA9IDB4ODAwMDAwMDA7XG5IRFB1YmxpY0tleS5Sb290RWxlbWVudEFsaWFzID0gWydtJywgJ00nXTtcblxuSERQdWJsaWNLZXkuVmVyc2lvblNpemUgPSA0O1xuSERQdWJsaWNLZXkuRGVwdGhTaXplID0gMTtcbkhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50U2l6ZSA9IDQ7XG5IRFB1YmxpY0tleS5DaGlsZEluZGV4U2l6ZSA9IDQ7XG5IRFB1YmxpY0tleS5DaGFpbkNvZGVTaXplID0gMzI7XG5IRFB1YmxpY0tleS5QdWJsaWNLZXlTaXplID0gMzM7XG5IRFB1YmxpY0tleS5DaGVja1N1bVNpemUgPSA0O1xuXG5IRFB1YmxpY0tleS5EYXRhU2l6ZSA9IDc4O1xuSERQdWJsaWNLZXkuU2VyaWFsaXplZEJ5dGVTaXplID0gODI7XG5cbkhEUHVibGljS2V5LlZlcnNpb25TdGFydCAgICAgICAgICAgPSAwO1xuSERQdWJsaWNLZXkuVmVyc2lvbkVuZCAgICAgICAgICAgICA9IEhEUHVibGljS2V5LlZlcnNpb25TdGFydCArIEhEUHVibGljS2V5LlZlcnNpb25TaXplO1xuSERQdWJsaWNLZXkuRGVwdGhTdGFydCAgICAgICAgICAgICA9IEhEUHVibGljS2V5LlZlcnNpb25FbmQ7XG5IRFB1YmxpY0tleS5EZXB0aEVuZCAgICAgICAgICAgICAgID0gSERQdWJsaWNLZXkuRGVwdGhTdGFydCArIEhEUHVibGljS2V5LkRlcHRoU2l6ZTtcbkhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50U3RhcnQgPSBIRFB1YmxpY0tleS5EZXB0aEVuZDtcbkhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50RW5kICAgPSBIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludFN0YXJ0ICsgSERQdWJsaWNLZXkuUGFyZW50RmluZ2VyUHJpbnRTaXplO1xuSERQdWJsaWNLZXkuQ2hpbGRJbmRleFN0YXJ0ICAgICAgICA9IEhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50RW5kO1xuSERQdWJsaWNLZXkuQ2hpbGRJbmRleEVuZCAgICAgICAgICA9IEhEUHVibGljS2V5LkNoaWxkSW5kZXhTdGFydCArIEhEUHVibGljS2V5LkNoaWxkSW5kZXhTaXplO1xuSERQdWJsaWNLZXkuQ2hhaW5Db2RlU3RhcnQgICAgICAgICA9IEhEUHVibGljS2V5LkNoaWxkSW5kZXhFbmQ7XG5IRFB1YmxpY0tleS5DaGFpbkNvZGVFbmQgICAgICAgICAgID0gSERQdWJsaWNLZXkuQ2hhaW5Db2RlU3RhcnQgKyBIRFB1YmxpY0tleS5DaGFpbkNvZGVTaXplO1xuSERQdWJsaWNLZXkuUHVibGljS2V5U3RhcnQgICAgICAgICA9IEhEUHVibGljS2V5LkNoYWluQ29kZUVuZDtcbkhEUHVibGljS2V5LlB1YmxpY0tleUVuZCAgICAgICAgICAgPSBIRFB1YmxpY0tleS5QdWJsaWNLZXlTdGFydCArIEhEUHVibGljS2V5LlB1YmxpY0tleVNpemU7XG5IRFB1YmxpY0tleS5DaGVja3N1bVN0YXJ0ICAgICAgICAgID0gSERQdWJsaWNLZXkuUHVibGljS2V5RW5kO1xuSERQdWJsaWNLZXkuQ2hlY2tzdW1FbmQgICAgICAgICAgICA9IEhEUHVibGljS2V5LkNoZWNrc3VtU3RhcnQgKyBIRFB1YmxpY0tleS5DaGVja1N1bVNpemU7XG5cbmFzc2VydChIRFB1YmxpY0tleS5QdWJsaWNLZXlFbmQgPT09IEhEUHVibGljS2V5LkRhdGFTaXplKTtcbmFzc2VydChIRFB1YmxpY0tleS5DaGVja3N1bUVuZCA9PT0gSERQdWJsaWNLZXkuU2VyaWFsaXplZEJ5dGVTaXplKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIRFB1YmxpY0tleTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/hdpublickey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/message.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/message.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar PrivateKey = __webpack_require__(/*! ./privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar Address = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar BufferWriter = __webpack_require__(/*! ./encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar ECDSA = __webpack_require__(/*! ./crypto/ecdsa */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\");\nvar Signature = __webpack_require__(/*! ./crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar sha256sha256 = (__webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\").sha256sha256);\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nfunction Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n\n  return this;\n}\n\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\n\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = Buffer.from(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\n\nMessage.prototype._sign = function _sign(privateKey) {\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\n  var hash = this.magicHash();\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.privkey = privateKey;\n  ecdsa.pubkey = privateKey.toPublicKey();\n  ecdsa.signRandomK();\n  ecdsa.calci();\n  return ecdsa.sig;\n};\n\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n  return signature.toCompact().toString('base64');\n};\n\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n  return verified;\n};\n\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n\n  return this._verify(publicKey, signature);\n};\n\n/**\n * Will return a public key string if the provided signature and the message digest is correct\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {String}\n */\nMessage.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n  }\n\n  return publicKey.toString();\n};\n\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromString = function(str) {\n  return new Message(str);\n};\n\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n  return new Message(json.message);\n};\n\n/**\n * @returns {Object} A plain object with the message information\n */\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n\n/**\n * @returns {String} A JSON representation of the message information\n */\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\nMessage.prototype.toString = function() {\n  return this.message;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\nMessage.prototype.inspect = function() {\n  return '<Message: ' + this.toString() + '>';\n};\n\nmodule.exports = Message;\n\nvar Script = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFRO0FBQ3hCLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBVztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDcEQsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDNUMsbUJBQW1CLDhHQUFxQztBQUN4RCxhQUFhLG1CQUFPLENBQUMsa0VBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHNFQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL21lc3NhZ2UuanM/YTMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vcHJpdmF0ZWtleScpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vcHVibGlja2V5Jyk7XG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XG52YXIgRUNEU0EgPSByZXF1aXJlKCcuL2NyeXB0by9lY2RzYScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vY3J5cHRvL3NpZ25hdHVyZScpO1xudmFyIHNoYTI1NnNoYTI1NiA9IHJlcXVpcmUoJy4vY3J5cHRvL2hhc2gnKS5zaGEyNTZzaGEyNTY7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbmZ1bmN0aW9uIE1lc3NhZ2UobWVzc2FnZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWVzc2FnZSkpIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcobWVzc2FnZSksICdGaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuTWVzc2FnZS5NQUdJQ19CWVRFUyA9IEJ1ZmZlci5mcm9tKCdCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcbicpO1xuXG5NZXNzYWdlLnByb3RvdHlwZS5tYWdpY0hhc2ggPSBmdW5jdGlvbiBtYWdpY0hhc2goKSB7XG4gIHZhciBwcmVmaXgxID0gQnVmZmVyV3JpdGVyLnZhcmludEJ1Zk51bShNZXNzYWdlLk1BR0lDX0JZVEVTLmxlbmd0aCk7XG4gIHZhciBtZXNzYWdlQnVmZmVyID0gQnVmZmVyLmZyb20odGhpcy5tZXNzYWdlKTtcbiAgdmFyIHByZWZpeDIgPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKG1lc3NhZ2VCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3ByZWZpeDEsIE1lc3NhZ2UuTUFHSUNfQllURVMsIHByZWZpeDIsIG1lc3NhZ2VCdWZmZXJdKTtcbiAgdmFyIGhhc2ggPSBzaGEyNTZzaGEyNTYoYnVmKTtcbiAgcmV0dXJuIGhhc2g7XG59O1xuXG5NZXNzYWdlLnByb3RvdHlwZS5fc2lnbiA9IGZ1bmN0aW9uIF9zaWduKHByaXZhdGVLZXkpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHByaXZhdGVLZXkgaW5zdGFuY2VvZiBQcml2YXRlS2V5LCAnRmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIFByaXZhdGVLZXknKTtcbiAgdmFyIGhhc2ggPSB0aGlzLm1hZ2ljSGFzaCgpO1xuICB2YXIgZWNkc2EgPSBuZXcgRUNEU0EoKTtcbiAgZWNkc2EuaGFzaGJ1ZiA9IGhhc2g7XG4gIGVjZHNhLnByaXZrZXkgPSBwcml2YXRlS2V5O1xuICBlY2RzYS5wdWJrZXkgPSBwcml2YXRlS2V5LnRvUHVibGljS2V5KCk7XG4gIGVjZHNhLnNpZ25SYW5kb21LKCk7XG4gIGVjZHNhLmNhbGNpKCk7XG4gIHJldHVybiBlY2RzYS5zaWc7XG59O1xuXG4vKipcbiAqIFdpbGwgc2lnbiBhIG1lc3NhZ2Ugd2l0aCBhIGdpdmVuIGJpdGNvaW4gcHJpdmF0ZSBrZXkuXG4gKlxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlS2V5IC0gQW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleVxuICogQHJldHVybnMge1N0cmluZ30gQSBiYXNlNjQgZW5jb2RlZCBjb21wYWN0IHNpZ25hdHVyZVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihwcml2YXRlS2V5KSB7XG4gIHZhciBzaWduYXR1cmUgPSB0aGlzLl9zaWduKHByaXZhdGVLZXkpO1xuICByZXR1cm4gc2lnbmF0dXJlLnRvQ29tcGFjdCgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn07XG5cbk1lc3NhZ2UucHJvdG90eXBlLl92ZXJpZnkgPSBmdW5jdGlvbiBfdmVyaWZ5KHB1YmxpY0tleSwgc2lnbmF0dXJlKSB7XG4gICQuY2hlY2tBcmd1bWVudChwdWJsaWNLZXkgaW5zdGFuY2VvZiBQdWJsaWNLZXksICdGaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgUHVibGljS2V5Jyk7XG4gICQuY2hlY2tBcmd1bWVudChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUsICdTZWNvbmQgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIFNpZ25hdHVyZScpO1xuICB2YXIgaGFzaCA9IHRoaXMubWFnaWNIYXNoKCk7XG4gIHZhciB2ZXJpZmllZCA9IEVDRFNBLnZlcmlmeShoYXNoLCBzaWduYXR1cmUsIHB1YmxpY0tleSk7XG4gIGlmICghdmVyaWZpZWQpIHtcbiAgICB0aGlzLmVycm9yID0gJ1RoZSBzaWduYXR1cmUgd2FzIGludmFsaWQnO1xuICB9XG4gIHJldHVybiB2ZXJpZmllZDtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYSBib29sZWFuIG9mIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQgZm9yIGEgZ2l2ZW4gYml0Y29pbiBhZGRyZXNzLlxuICogSWYgaXQgaXNuJ3QgdGhlIHNwZWNpZmljIHJlYXNvbiBpcyBhY2Nlc3NpYmxlIHZpYSB0aGUgXCJlcnJvclwiIG1lbWJlci5cbiAqXG4gKiBAcGFyYW0ge0FkZHJlc3N8U3RyaW5nfSBiaXRjb2luQWRkcmVzcyAtIEEgYml0Y29pbiBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmF0dXJlU3RyaW5nIC0gQSBiYXNlNjQgZW5jb2RlZCBjb21wYWN0IHNpZ25hdHVyZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShiaXRjb2luQWRkcmVzcywgc2lnbmF0dXJlU3RyaW5nKSB7XG4gICQuY2hlY2tBcmd1bWVudChiaXRjb2luQWRkcmVzcyk7XG4gICQuY2hlY2tBcmd1bWVudChzaWduYXR1cmVTdHJpbmcgJiYgXy5pc1N0cmluZyhzaWduYXR1cmVTdHJpbmcpKTtcblxuICBpZiAoXy5pc1N0cmluZyhiaXRjb2luQWRkcmVzcykpIHtcbiAgICBiaXRjb2luQWRkcmVzcyA9IEFkZHJlc3MuZnJvbVN0cmluZyhiaXRjb2luQWRkcmVzcyk7XG4gIH1cbiAgdmFyIHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChCdWZmZXIuZnJvbShzaWduYXR1cmVTdHJpbmcsICdiYXNlNjQnKSk7XG5cbiAgLy8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxuICB2YXIgZWNkc2EgPSBuZXcgRUNEU0EoKTtcbiAgZWNkc2EuaGFzaGJ1ZiA9IHRoaXMubWFnaWNIYXNoKCk7XG4gIGVjZHNhLnNpZyA9IHNpZ25hdHVyZTtcbiAgdmFyIHB1YmxpY0tleSA9IGVjZHNhLnRvUHVibGljS2V5KCk7XG5cbiAgdmFyIHNpZ25hdHVyZUFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkocHVibGljS2V5LCBiaXRjb2luQWRkcmVzcy5uZXR3b3JrKTtcblxuICAvLyBjaGVjayB0aGF0IHRoZSByZWNvdmVyZWQgYWRkcmVzcyBhbmQgc3BlY2lmaWVkIGFkZHJlc3MgbWF0Y2hcbiAgaWYgKGJpdGNvaW5BZGRyZXNzLnRvU3RyaW5nKCkgIT09IHNpZ25hdHVyZUFkZHJlc3MudG9TdHJpbmcoKSkge1xuICAgIHRoaXMuZXJyb3IgPSAnVGhlIHNpZ25hdHVyZSBkaWQgbm90IG1hdGNoIHRoZSBtZXNzYWdlIGRpZ2VzdCc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX3ZlcmlmeShwdWJsaWNLZXksIHNpZ25hdHVyZSk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgcHVibGljIGtleSBzdHJpbmcgaWYgdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBhbmQgdGhlIG1lc3NhZ2UgZGlnZXN0IGlzIGNvcnJlY3RcbiAqIElmIGl0IGlzbid0IHRoZSBzcGVjaWZpYyByZWFzb24gaXMgYWNjZXNzaWJsZSB2aWEgdGhlIFwiZXJyb3JcIiBtZW1iZXIuXG4gKlxuICogQHBhcmFtIHtBZGRyZXNzfFN0cmluZ30gYml0Y29pbkFkZHJlc3MgLSBBIGJpdGNvaW4gYWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25hdHVyZVN0cmluZyAtIEEgYmFzZTY0IGVuY29kZWQgY29tcGFjdCBzaWduYXR1cmVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnJlY292ZXJQdWJsaWNLZXkgPSBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KGJpdGNvaW5BZGRyZXNzLCBzaWduYXR1cmVTdHJpbmcpIHtcbiAgJC5jaGVja0FyZ3VtZW50KGJpdGNvaW5BZGRyZXNzKTtcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ25hdHVyZVN0cmluZyAmJiBfLmlzU3RyaW5nKHNpZ25hdHVyZVN0cmluZykpO1xuXG4gIGlmIChfLmlzU3RyaW5nKGJpdGNvaW5BZGRyZXNzKSkge1xuICAgIGJpdGNvaW5BZGRyZXNzID0gQWRkcmVzcy5mcm9tU3RyaW5nKGJpdGNvaW5BZGRyZXNzKTtcbiAgfVxuICB2YXIgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KEJ1ZmZlci5mcm9tKHNpZ25hdHVyZVN0cmluZywgJ2Jhc2U2NCcpKTtcblxuICAvLyByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gIHZhciBlY2RzYSA9IG5ldyBFQ0RTQSgpO1xuICBlY2RzYS5oYXNoYnVmID0gdGhpcy5tYWdpY0hhc2goKTtcbiAgZWNkc2Euc2lnID0gc2lnbmF0dXJlO1xuICB2YXIgcHVibGljS2V5ID0gZWNkc2EudG9QdWJsaWNLZXkoKTtcblxuICB2YXIgc2lnbmF0dXJlQWRkcmVzcyA9IEFkZHJlc3MuZnJvbVB1YmxpY0tleShwdWJsaWNLZXksIGJpdGNvaW5BZGRyZXNzLm5ldHdvcmspO1xuXG4gIC8vIGNoZWNrIHRoYXQgdGhlIHJlY292ZXJlZCBhZGRyZXNzIGFuZCBzcGVjaWZpZWQgYWRkcmVzcyBtYXRjaFxuICBpZiAoYml0Y29pbkFkZHJlc3MudG9TdHJpbmcoKSAhPT0gc2lnbmF0dXJlQWRkcmVzcy50b1N0cmluZygpKSB7XG4gICAgdGhpcy5lcnJvciA9ICdUaGUgc2lnbmF0dXJlIGRpZCBub3QgbWF0Y2ggdGhlIG1lc3NhZ2UgZGlnZXN0JztcbiAgfVxuXG4gIHJldHVybiBwdWJsaWNLZXkudG9TdHJpbmcoKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYSBtZXNzYWdlIGZyb20gYSBtZXNzYWdlIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBBIHN0cmluZyBvZiB0aGUgbWVzc2FnZVxuICogQHJldHVybnMge01lc3NhZ2V9IEEgbmV3IGluc3RhbmNlIG9mIGEgTWVzc2FnZVxuICovXG5NZXNzYWdlLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIG5ldyBNZXNzYWdlKHN0cik7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgbWVzc2FnZSBmcm9tIEpTT05cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ganNvbiAtIEFuIEpTT04gc3RyaW5nIG9yIE9iamVjdCB3aXRoIGtleXM6IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtNZXNzYWdlfSBBIG5ldyBpbnN0YW5jZSBvZiBhIE1lc3NhZ2VcbiAqL1xuTWVzc2FnZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGpzb24pIHtcbiAgaWYgKEpTVXRpbC5pc1ZhbGlkSlNPTihqc29uKSkge1xuICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xuICB9XG4gIHJldHVybiBuZXcgTWVzc2FnZShqc29uLm1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHBsYWluIG9iamVjdCB3aXRoIHRoZSBtZXNzYWdlIGluZm9ybWF0aW9uXG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gIH07XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVzc2FnZSBpbmZvcm1hdGlvblxuICovXG5NZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvT2JqZWN0KCkpO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1lc3NhZ2VcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBNZXNzYWdlXG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1lc3NhZ2U7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBNZXNzYWdlXG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8TWVzc2FnZTogJyArIHRoaXMudG9TdHJpbmcoKSArICc+Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZTtcblxudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/networks.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/networks.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar networks = [];\nvar networkMaps = {};\n\n/**\n * A network is merely a map containing values that correspond to version\n * numbers for each bitcoin network. Currently only supporting \"livenet\"\n * (a.k.a. \"mainnet\") and \"testnet\".\n * @constructor\n */\nfunction Network() {}\n\nNetwork.prototype.toString = function toString() {\n  return this.name;\n};\n\n/**\n * @function\n * @member Networks#get\n * Retrieves the network associated with a magic number or string.\n * @param {string|number|Network} arg\n * @param {string|Array} keys - if set, only check if the magic number associated with this name matches\n * @return Network\n */\nfunction get(arg, keys) {\n  if (~networks.indexOf(arg)) {\n    return arg;\n  }\n  if (keys) {\n    if (!Array.isArray(keys)) {\n      keys = [keys];\n    }\n    for (const index in networks) {\n      if (keys.some(key => networks[index][key] === arg)) {\n        return networks[index];\n      }\n    }\n    return undefined;\n  }\n  if (networkMaps[arg] && networkMaps[arg].length >= 1) {\n    return networkMaps[arg][0];\n  } else {\n    return networkMaps[arg];\n  }\n}\n\n/**\n * @function\n * @member Networks#is\n * Returns true if the string is the network name or alias\n * @param {string} str - A string to check\n * @return boolean\n */\nfunction is(str) {\n  return this.name == str || this.alias == str;\n}\n\n/**\n * @function\n * @member Networks#add\n * Will add a custom Network\n * @param {Object} data\n * @param {string} data.name - The name of the network\n * @param {string} data.alias - The aliased name of the network\n * @param {Number} data.pubkeyhash - The publickey hash prefix\n * @param {Number} data.privatekey - The privatekey prefix\n * @param {Number} data.scripthash - The scripthash prefix\n * @param {string} data.bech32prefix - The native segwit prefix\n * @param {Number} data.xpubkey - The extended public key magic\n * @param {Number} data.xprivkey - The extended private key magic\n * @param {Array}  data.variants - An array of variants\n * @param {string} data.variants.name - The name of the variant\n * @param {Number} data.variants.networkMagic - The network magic number\n * @param {Number} data.variants.port - The network port\n * @param {Array}  data.variants.dnsSeeds - An array of dns seeds\n * @return Network\n */\nfunction addNetwork(data) {\n  var network = new Network();\n\n  JSUtil.defineImmutable(network, {\n    name: data.name,\n    alias: data.alias,\n    is: data.is,\n    pubkeyhash: data.pubkeyhash,\n    privatekey: data.privatekey,\n    scripthash: data.scripthash,\n    bech32prefix: data.bech32prefix,\n    xpubkey: data.xpubkey,\n    xprivkey: data.xprivkey\n  });\n\n  if (data.networkMagic) {\n    JSUtil.defineImmutable(network, {\n      networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)\n    });\n  }\n\n  if (data.port) {\n    JSUtil.defineImmutable(network, {\n      port: data.port\n    });\n  }\n\n  if (data.dnsSeeds) {\n    JSUtil.defineImmutable(network, {\n      dnsSeeds: data.dnsSeeds\n    });\n  }\n\n  for (const value of Object.values(network)) {\n    if (value != null && typeof value !== 'object') {\n      if (!networkMaps[value]) {\n        networkMaps[value] = [];\n      }\n      networkMaps[value].push(network);\n    }\n  };\n\n  networks.push(network);\n\n  for (const variant of data.variants || []) {\n    addNetwork({\n      ...data,\n      variants: undefined,\n      ...variant,\n    });\n  }\n\n  return network;\n}\n\n/**\n * @function\n * @member Networks#remove\n * Will remove a custom network\n * @param {Network} network\n */\nfunction removeNetwork(network) {\n  if (typeof network !== 'object') {\n    network = get(network);\n  }\n  for (var i = 0; i < networks.length; i++) {\n    if (networks[i] === network) {\n      networks.splice(i, 1);\n    }\n  }\n  for (var key in networkMaps) {\n    if (networkMaps[key].length) {\n      const index = networkMaps[key].indexOf(network);\n      if (index >= 0) {\n        networkMaps[key].splice(index, 1);\n      }\n      if (networkMaps[key].length === 0) {\n        delete networkMaps[key];\n      }\n    } else if (networkMaps[key] === network) {\n      delete networkMaps[key];\n    }\n  }\n}\n\naddNetwork({\n  name: 'livenet',\n  alias: 'mainnet',\n  is,\n  pubkeyhash: 0x00,\n  privatekey: 0x80,\n  scripthash: 0x05,\n  bech32prefix: 'bc',\n  xpubkey: 0x0488b21e,\n  xprivkey: 0x0488ade4,\n  networkMagic: 0xf9beb4d9,\n  port: 8333,\n  dnsSeeds: [\n    'seed.bitcoin.sipa.be',\n    'dnsseed.bluematt.me',\n    'dnsseed.bitcoin.dashjr.org',\n    'seed.bitcoinstats.com',\n    'seed.bitnodes.io',\n    'bitseed.xf2.org'\n  ]\n});\n\n/**\n * @instance\n * @member Networks#livenet\n */\nvar livenet = get('livenet');\n\naddNetwork({\n  name: 'testnet',\n  alias: 'testnet',\n  is,\n  pubkeyhash: 0x6f,\n  privatekey: 0xef,\n  scripthash: 0xc4,\n  bech32prefix: 'tb',\n  xpubkey: 0x043587cf,\n  xprivkey: 0x04358394,\n  variants: [{\n    name: 'testnet3',\n    networkMagic: 0x0b110907,\n    port: 18333,\n    dnsSeeds: [\n      'testnet-seed.bitcoin.petertodd.org',\n      'testnet-seed.bluematt.me',\n      'testnet-seed.alexykot.me',\n      'testnet-seed.bitcoin.schildbach.de'\n    ]\n  }, {\n    name: 'signet',\n    networkMagic: 0x0a03cf40,\n    port: 38332,\n    dnsSeeds: [\n      '178.128.221.177',\n      '103.16.128.63',\n      '153.126.143.201',\n      '192.241.163.142'\n    ]\n  }]\n});\n\n/**\n * @instance\n * @member Networks#testnet\n */\nvar testnet = get('testnet');\nvar testnet3 = get('testnet3');\nvar signet = get('signet');\n\naddNetwork({\n  name: 'regtest',\n  alias: 'dev',\n  is,\n  pubkeyhash: 0x6f,\n  privatekey: 0xef,\n  scripthash: 0xc4,\n  bech32prefix: 'bcrt',\n  xpubkey: 0x043587cf,\n  xprivkey: 0x04358394,\n  networkMagic: 0xfabfb5da,\n  port: 18444,\n  dnsSeeds: []\n});\n\n/**\n * @instance\n * @member Networks#regtest\n */\nvar regtest = get('regtest');\n\n/**\n * @function\n * @deprecated\n * @member Networks#enableRegtest\n * Will enable regtest features for testnet\n */\nfunction enableRegtest() {\n  testnet.regtestEnabled = true;\n}\n\n/**\n * @function\n * @deprecated\n * @member Networks#disableRegtest\n * Will disable regtest features for testnet\n */\nfunction disableRegtest() {\n  testnet.regtestEnabled = false;\n}\n\n/**\n * @namespace Networks\n */\nmodule.exports = {\n  add: addNetwork,\n  remove: removeNetwork,\n  defaultNetwork: livenet,\n  livenet: livenet,\n  mainnet: livenet,\n  testnet: testnet,\n  testnet3: testnet3,\n  signet: signet,\n  regtest: regtest,\n  get: get,\n  enableRegtest: enableRegtest,\n  disableRegtest: disableRegtest\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL25ldHdvcmtzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWU7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9uZXR3b3Jrcy5qcz8zN2JiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi91dGlsL2J1ZmZlcicpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9qcycpO1xudmFyIG5ldHdvcmtzID0gW107XG52YXIgbmV0d29ya01hcHMgPSB7fTtcblxuLyoqXG4gKiBBIG5ldHdvcmsgaXMgbWVyZWx5IGEgbWFwIGNvbnRhaW5pbmcgdmFsdWVzIHRoYXQgY29ycmVzcG9uZCB0byB2ZXJzaW9uXG4gKiBudW1iZXJzIGZvciBlYWNoIGJpdGNvaW4gbmV0d29yay4gQ3VycmVudGx5IG9ubHkgc3VwcG9ydGluZyBcImxpdmVuZXRcIlxuICogKGEuay5hLiBcIm1haW5uZXRcIikgYW5kIFwidGVzdG5ldFwiLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE5ldHdvcmsoKSB7fVxuXG5OZXR3b3JrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5uYW1lO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXIgTmV0d29ya3MjZ2V0XG4gKiBSZXRyaWV2ZXMgdGhlIG5ldHdvcmsgYXNzb2NpYXRlZCB3aXRoIGEgbWFnaWMgbnVtYmVyIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxOZXR3b3JrfSBhcmdcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBrZXlzIC0gaWYgc2V0LCBvbmx5IGNoZWNrIGlmIHRoZSBtYWdpYyBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbmFtZSBtYXRjaGVzXG4gKiBAcmV0dXJuIE5ldHdvcmtcbiAqL1xuZnVuY3Rpb24gZ2V0KGFyZywga2V5cykge1xuICBpZiAofm5ldHdvcmtzLmluZGV4T2YoYXJnKSkge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbiAgaWYgKGtleXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgIGtleXMgPSBba2V5c107XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gbmV0d29ya3MpIHtcbiAgICAgIGlmIChrZXlzLnNvbWUoa2V5ID0+IG5ldHdvcmtzW2luZGV4XVtrZXldID09PSBhcmcpKSB7XG4gICAgICAgIHJldHVybiBuZXR3b3Jrc1tpbmRleF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG5ldHdvcmtNYXBzW2FyZ10gJiYgbmV0d29ya01hcHNbYXJnXS5sZW5ndGggPj0gMSkge1xuICAgIHJldHVybiBuZXR3b3JrTWFwc1thcmddWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXR3b3JrTWFwc1thcmddO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyIE5ldHdvcmtzI2lzXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBpcyB0aGUgbmV0d29yayBuYW1lIG9yIGFsaWFzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gQSBzdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm4gYm9vbGVhblxuICovXG5mdW5jdGlvbiBpcyhzdHIpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSA9PSBzdHIgfHwgdGhpcy5hbGlhcyA9PSBzdHI7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyIE5ldHdvcmtzI2FkZFxuICogV2lsbCBhZGQgYSBjdXN0b20gTmV0d29ya1xuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbmV0d29ya1xuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEuYWxpYXMgLSBUaGUgYWxpYXNlZCBuYW1lIG9mIHRoZSBuZXR3b3JrXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YS5wdWJrZXloYXNoIC0gVGhlIHB1YmxpY2tleSBoYXNoIHByZWZpeFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucHJpdmF0ZWtleSAtIFRoZSBwcml2YXRla2V5IHByZWZpeFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2NyaXB0aGFzaCAtIFRoZSBzY3JpcHRoYXNoIHByZWZpeFxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEuYmVjaDMycHJlZml4IC0gVGhlIG5hdGl2ZSBzZWd3aXQgcHJlZml4XG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YS54cHVia2V5IC0gVGhlIGV4dGVuZGVkIHB1YmxpYyBrZXkgbWFnaWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnhwcml2a2V5IC0gVGhlIGV4dGVuZGVkIHByaXZhdGUga2V5IG1hZ2ljXG4gKiBAcGFyYW0ge0FycmF5fSAgZGF0YS52YXJpYW50cyAtIEFuIGFycmF5IG9mIHZhcmlhbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YS52YXJpYW50cy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhcmlhbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnZhcmlhbnRzLm5ldHdvcmtNYWdpYyAtIFRoZSBuZXR3b3JrIG1hZ2ljIG51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudmFyaWFudHMucG9ydCAtIFRoZSBuZXR3b3JrIHBvcnRcbiAqIEBwYXJhbSB7QXJyYXl9ICBkYXRhLnZhcmlhbnRzLmRuc1NlZWRzIC0gQW4gYXJyYXkgb2YgZG5zIHNlZWRzXG4gKiBAcmV0dXJuIE5ldHdvcmtcbiAqL1xuZnVuY3Rpb24gYWRkTmV0d29yayhkYXRhKSB7XG4gIHZhciBuZXR3b3JrID0gbmV3IE5ldHdvcmsoKTtcblxuICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKG5ldHdvcmssIHtcbiAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgYWxpYXM6IGRhdGEuYWxpYXMsXG4gICAgaXM6IGRhdGEuaXMsXG4gICAgcHVia2V5aGFzaDogZGF0YS5wdWJrZXloYXNoLFxuICAgIHByaXZhdGVrZXk6IGRhdGEucHJpdmF0ZWtleSxcbiAgICBzY3JpcHRoYXNoOiBkYXRhLnNjcmlwdGhhc2gsXG4gICAgYmVjaDMycHJlZml4OiBkYXRhLmJlY2gzMnByZWZpeCxcbiAgICB4cHVia2V5OiBkYXRhLnhwdWJrZXksXG4gICAgeHByaXZrZXk6IGRhdGEueHByaXZrZXlcbiAgfSk7XG5cbiAgaWYgKGRhdGEubmV0d29ya01hZ2ljKSB7XG4gICAgSlNVdGlsLmRlZmluZUltbXV0YWJsZShuZXR3b3JrLCB7XG4gICAgICBuZXR3b3JrTWFnaWM6IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGRhdGEubmV0d29ya01hZ2ljKVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGRhdGEucG9ydCkge1xuICAgIEpTVXRpbC5kZWZpbmVJbW11dGFibGUobmV0d29yaywge1xuICAgICAgcG9ydDogZGF0YS5wb3J0XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGF0YS5kbnNTZWVkcykge1xuICAgIEpTVXRpbC5kZWZpbmVJbW11dGFibGUobmV0d29yaywge1xuICAgICAgZG5zU2VlZHM6IGRhdGEuZG5zU2VlZHNcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgT2JqZWN0LnZhbHVlcyhuZXR3b3JrKSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICghbmV0d29ya01hcHNbdmFsdWVdKSB7XG4gICAgICAgIG5ldHdvcmtNYXBzW3ZhbHVlXSA9IFtdO1xuICAgICAgfVxuICAgICAgbmV0d29ya01hcHNbdmFsdWVdLnB1c2gobmV0d29yayk7XG4gICAgfVxuICB9O1xuXG4gIG5ldHdvcmtzLnB1c2gobmV0d29yayk7XG5cbiAgZm9yIChjb25zdCB2YXJpYW50IG9mIGRhdGEudmFyaWFudHMgfHwgW10pIHtcbiAgICBhZGROZXR3b3JrKHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICB2YXJpYW50czogdW5kZWZpbmVkLFxuICAgICAgLi4udmFyaWFudCxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBuZXR3b3JrO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlciBOZXR3b3JrcyNyZW1vdmVcbiAqIFdpbGwgcmVtb3ZlIGEgY3VzdG9tIG5ldHdvcmtcbiAqIEBwYXJhbSB7TmV0d29ya30gbmV0d29ya1xuICovXG5mdW5jdGlvbiByZW1vdmVOZXR3b3JrKG5ldHdvcmspIHtcbiAgaWYgKHR5cGVvZiBuZXR3b3JrICE9PSAnb2JqZWN0Jykge1xuICAgIG5ldHdvcmsgPSBnZXQobmV0d29yayk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXR3b3Jrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuZXR3b3Jrc1tpXSA9PT0gbmV0d29yaykge1xuICAgICAgbmV0d29ya3Muc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gbmV0d29ya01hcHMpIHtcbiAgICBpZiAobmV0d29ya01hcHNba2V5XS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbmV0d29ya01hcHNba2V5XS5pbmRleE9mKG5ldHdvcmspO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgbmV0d29ya01hcHNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKG5ldHdvcmtNYXBzW2tleV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBuZXR3b3JrTWFwc1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV0d29ya01hcHNba2V5XSA9PT0gbmV0d29yaykge1xuICAgICAgZGVsZXRlIG5ldHdvcmtNYXBzW2tleV07XG4gICAgfVxuICB9XG59XG5cbmFkZE5ldHdvcmsoe1xuICBuYW1lOiAnbGl2ZW5ldCcsXG4gIGFsaWFzOiAnbWFpbm5ldCcsXG4gIGlzLFxuICBwdWJrZXloYXNoOiAweDAwLFxuICBwcml2YXRla2V5OiAweDgwLFxuICBzY3JpcHRoYXNoOiAweDA1LFxuICBiZWNoMzJwcmVmaXg6ICdiYycsXG4gIHhwdWJrZXk6IDB4MDQ4OGIyMWUsXG4gIHhwcml2a2V5OiAweDA0ODhhZGU0LFxuICBuZXR3b3JrTWFnaWM6IDB4ZjliZWI0ZDksXG4gIHBvcnQ6IDgzMzMsXG4gIGRuc1NlZWRzOiBbXG4gICAgJ3NlZWQuYml0Y29pbi5zaXBhLmJlJyxcbiAgICAnZG5zc2VlZC5ibHVlbWF0dC5tZScsXG4gICAgJ2Ruc3NlZWQuYml0Y29pbi5kYXNoanIub3JnJyxcbiAgICAnc2VlZC5iaXRjb2luc3RhdHMuY29tJyxcbiAgICAnc2VlZC5iaXRub2Rlcy5pbycsXG4gICAgJ2JpdHNlZWQueGYyLm9yZydcbiAgXVxufSk7XG5cbi8qKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyIE5ldHdvcmtzI2xpdmVuZXRcbiAqL1xudmFyIGxpdmVuZXQgPSBnZXQoJ2xpdmVuZXQnKTtcblxuYWRkTmV0d29yayh7XG4gIG5hbWU6ICd0ZXN0bmV0JyxcbiAgYWxpYXM6ICd0ZXN0bmV0JyxcbiAgaXMsXG4gIHB1YmtleWhhc2g6IDB4NmYsXG4gIHByaXZhdGVrZXk6IDB4ZWYsXG4gIHNjcmlwdGhhc2g6IDB4YzQsXG4gIGJlY2gzMnByZWZpeDogJ3RiJyxcbiAgeHB1YmtleTogMHgwNDM1ODdjZixcbiAgeHByaXZrZXk6IDB4MDQzNTgzOTQsXG4gIHZhcmlhbnRzOiBbe1xuICAgIG5hbWU6ICd0ZXN0bmV0MycsXG4gICAgbmV0d29ya01hZ2ljOiAweDBiMTEwOTA3LFxuICAgIHBvcnQ6IDE4MzMzLFxuICAgIGRuc1NlZWRzOiBbXG4gICAgICAndGVzdG5ldC1zZWVkLmJpdGNvaW4ucGV0ZXJ0b2RkLm9yZycsXG4gICAgICAndGVzdG5ldC1zZWVkLmJsdWVtYXR0Lm1lJyxcbiAgICAgICd0ZXN0bmV0LXNlZWQuYWxleHlrb3QubWUnLFxuICAgICAgJ3Rlc3RuZXQtc2VlZC5iaXRjb2luLnNjaGlsZGJhY2guZGUnXG4gICAgXVxuICB9LCB7XG4gICAgbmFtZTogJ3NpZ25ldCcsXG4gICAgbmV0d29ya01hZ2ljOiAweDBhMDNjZjQwLFxuICAgIHBvcnQ6IDM4MzMyLFxuICAgIGRuc1NlZWRzOiBbXG4gICAgICAnMTc4LjEyOC4yMjEuMTc3JyxcbiAgICAgICcxMDMuMTYuMTI4LjYzJyxcbiAgICAgICcxNTMuMTI2LjE0My4yMDEnLFxuICAgICAgJzE5Mi4yNDEuMTYzLjE0MidcbiAgICBdXG4gIH1dXG59KTtcblxuLyoqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgTmV0d29ya3MjdGVzdG5ldFxuICovXG52YXIgdGVzdG5ldCA9IGdldCgndGVzdG5ldCcpO1xudmFyIHRlc3RuZXQzID0gZ2V0KCd0ZXN0bmV0MycpO1xudmFyIHNpZ25ldCA9IGdldCgnc2lnbmV0Jyk7XG5cbmFkZE5ldHdvcmsoe1xuICBuYW1lOiAncmVndGVzdCcsXG4gIGFsaWFzOiAnZGV2JyxcbiAgaXMsXG4gIHB1YmtleWhhc2g6IDB4NmYsXG4gIHByaXZhdGVrZXk6IDB4ZWYsXG4gIHNjcmlwdGhhc2g6IDB4YzQsXG4gIGJlY2gzMnByZWZpeDogJ2JjcnQnLFxuICB4cHVia2V5OiAweDA0MzU4N2NmLFxuICB4cHJpdmtleTogMHgwNDM1ODM5NCxcbiAgbmV0d29ya01hZ2ljOiAweGZhYmZiNWRhLFxuICBwb3J0OiAxODQ0NCxcbiAgZG5zU2VlZHM6IFtdXG59KTtcblxuLyoqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgTmV0d29ya3MjcmVndGVzdFxuICovXG52YXIgcmVndGVzdCA9IGdldCgncmVndGVzdCcpO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlcHJlY2F0ZWRcbiAqIEBtZW1iZXIgTmV0d29ya3MjZW5hYmxlUmVndGVzdFxuICogV2lsbCBlbmFibGUgcmVndGVzdCBmZWF0dXJlcyBmb3IgdGVzdG5ldFxuICovXG5mdW5jdGlvbiBlbmFibGVSZWd0ZXN0KCkge1xuICB0ZXN0bmV0LnJlZ3Rlc3RFbmFibGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXByZWNhdGVkXG4gKiBAbWVtYmVyIE5ldHdvcmtzI2Rpc2FibGVSZWd0ZXN0XG4gKiBXaWxsIGRpc2FibGUgcmVndGVzdCBmZWF0dXJlcyBmb3IgdGVzdG5ldFxuICovXG5mdW5jdGlvbiBkaXNhYmxlUmVndGVzdCgpIHtcbiAgdGVzdG5ldC5yZWd0ZXN0RW5hYmxlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgTmV0d29ya3NcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZDogYWRkTmV0d29yayxcbiAgcmVtb3ZlOiByZW1vdmVOZXR3b3JrLFxuICBkZWZhdWx0TmV0d29yazogbGl2ZW5ldCxcbiAgbGl2ZW5ldDogbGl2ZW5ldCxcbiAgbWFpbm5ldDogbGl2ZW5ldCxcbiAgdGVzdG5ldDogdGVzdG5ldCxcbiAgdGVzdG5ldDM6IHRlc3RuZXQzLFxuICBzaWduZXQ6IHNpZ25ldCxcbiAgcmVndGVzdDogcmVndGVzdCxcbiAgZ2V0OiBnZXQsXG4gIGVuYWJsZVJlZ3Rlc3Q6IGVuYWJsZVJlZ3Rlc3QsXG4gIGRpc2FibGVSZWd0ZXN0OiBkaXNhYmxlUmVndGVzdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/networks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/opcode.js":
/*!************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/opcode.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nfunction Opcode(num) {\n  if (!(this instanceof Opcode)) {\n    return new Opcode(num);\n  }\n\n  var value;\n\n  if (_.isNumber(num)) {\n    value = num;\n  } else if (_.isString(num)) {\n    value = Opcode.map[num];\n  } else {\n    throw new TypeError('Unrecognized num type: \"' + typeof(num) + '\" for Opcode');\n  }\n\n  JSUtil.defineImmutable(this, {\n    num: value\n  });\n\n  return this;\n}\n\nOpcode.fromBuffer = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return new Opcode(Number('0x' + buf.toString('hex')));\n};\n\nOpcode.fromNumber = function(num) {\n  $.checkArgument(_.isNumber(num));\n  return new Opcode(num);\n};\n\nOpcode.fromString = function(str) {\n  $.checkArgument(_.isString(str));\n  var value = Opcode.map[str];\n  if (typeof value === 'undefined') {\n    throw new TypeError('Invalid opcodestr');\n  }\n  return new Opcode(value);\n};\n\nOpcode.prototype.toHex = function() {\n  return this.num.toString(16);\n};\n\nOpcode.prototype.toBuffer = function() {\n  return Buffer.from(this.toHex(), 'hex');\n};\n\nOpcode.prototype.toNumber = function() {\n  return this.num;\n};\n\nOpcode.prototype.toString = function() {\n  var str = Opcode.reverseMap[this.num];\n  if (typeof str === 'undefined') {\n    throw new Error('Opcode does not have a string representation');\n  }\n  return str;\n};\n\nOpcode.smallInt = function(n) {\n  $.checkArgument(_.isNumber(n), 'Invalid Argument: n should be number');\n  $.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');\n  if (n === 0) {\n    return Opcode('OP_0');\n  }\n  return new Opcode(Opcode.map.OP_1 + n - 1);\n};\n\n/**\n * Converts OP_0 - OP_16 to an int\n * @param {Number} opcode Opcode\n * @returns {Number}\n */\nOpcode.decodeOpN = function(opcode) {\n  if (opcode === Opcode.OP_0) {\n    return 0;\n  }\n  $.checkArgument(opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16, new Error('Invalid opcode: ' + JSON.stringify(opcode)));\n  return opcode - (Opcode.OP_1 - 1);\n};\n\n/**\n * Returns true if given opcode is classified as a \"success\".\n * This was taken from commit https://github.com/bitcoin/bitcoin/commit/72422ce396b8eba7b1a72c171c2f07dae691d1b5\n * @param {Number|String} opcode \n * @returns {Boolean}\n */\nOpcode.isOpSuccess = function(opcode) {\n  if (typeof opcode === 'string' && !parseInt(opcode)) {\n    opcode = Opcode[opcode];\n  }\n  return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\n        (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\n        (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\n        (opcode >= 187 && opcode <= 254);\n};\n\n\nOpcode.map = {\n  // push value\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n\n  // control\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n\n  // stack ops\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n\n  // splice ops\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n\n  // bit logic\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n\n  // numeric\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n\n  OP_WITHIN: 165,\n\n  // crypto\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_CHECKSEQUENCEVERIFY: 178,\n\n  // expansion\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_NOP3: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n\n  // Opcode added by BIP 342 (Tapscript)\n  OP_CHECKSIGADD: 186, // 0xba\n\n  // template matching params\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255\n};\n\nOpcode.reverseMap = [];\n\nfor (var k in Opcode.map) {\n  Opcode.reverseMap[Opcode.map[k]] = k;\n}\n\n// Easier access to opcodes\n_.extend(Opcode, Opcode.map);\n\n/**\n * @returns true if opcode is one of OP_0, OP_1, ..., OP_16\n */\nOpcode.isSmallIntOp = function(opcode) {\n  if (opcode instanceof Opcode) {\n    opcode = opcode.toNumber();\n  }\n  return ((opcode === Opcode.map.OP_0) ||\n    ((opcode >= Opcode.map.OP_1) && (opcode <= Opcode.map.OP_16)));\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Script opcode\n */\nOpcode.prototype.inspect = function() {\n  return '<Opcode: ' + this.toString() + ', hex: '+this.toHex()+', decimal: '+this.num+'>';\n};\n\nmodule.exports = Opcode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL29wY29kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBZTtBQUN4QyxhQUFhLG1CQUFPLENBQUMsa0VBQVc7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9vcGNvZGUuanM/Y2FhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9idWZmZXInKTtcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuL3V0aWwvanMnKTtcblxuZnVuY3Rpb24gT3Bjb2RlKG51bSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT3Bjb2RlKSkge1xuICAgIHJldHVybiBuZXcgT3Bjb2RlKG51bSk7XG4gIH1cblxuICB2YXIgdmFsdWU7XG5cbiAgaWYgKF8uaXNOdW1iZXIobnVtKSkge1xuICAgIHZhbHVlID0gbnVtO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcobnVtKSkge1xuICAgIHZhbHVlID0gT3Bjb2RlLm1hcFtudW1dO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVjb2duaXplZCBudW0gdHlwZTogXCInICsgdHlwZW9mKG51bSkgKyAnXCIgZm9yIE9wY29kZScpO1xuICB9XG5cbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XG4gICAgbnVtOiB2YWx1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuT3Bjb2RlLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHJldHVybiBuZXcgT3Bjb2RlKE51bWJlcignMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKSkpO1xufTtcblxuT3Bjb2RlLmZyb21OdW1iZXIgPSBmdW5jdGlvbihudW0pIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNOdW1iZXIobnVtKSk7XG4gIHJldHVybiBuZXcgT3Bjb2RlKG51bSk7XG59O1xuXG5PcGNvZGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc1N0cmluZyhzdHIpKTtcbiAgdmFyIHZhbHVlID0gT3Bjb2RlLm1hcFtzdHJdO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3Bjb2Rlc3RyJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPcGNvZGUodmFsdWUpO1xufTtcblxuT3Bjb2RlLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5udW0udG9TdHJpbmcoMTYpO1xufTtcblxuT3Bjb2RlLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy50b0hleCgpLCAnaGV4Jyk7XG59O1xuXG5PcGNvZGUucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm51bTtcbn07XG5cbk9wY29kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9IE9wY29kZS5yZXZlcnNlTWFwW3RoaXMubnVtXTtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcGNvZGUgZG9lcyBub3QgaGF2ZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbicpO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5PcGNvZGUuc21hbGxJbnQgPSBmdW5jdGlvbihuKSB7XG4gICQuY2hlY2tBcmd1bWVudChfLmlzTnVtYmVyKG4pLCAnSW52YWxpZCBBcmd1bWVudDogbiBzaG91bGQgYmUgbnVtYmVyJyk7XG4gICQuY2hlY2tBcmd1bWVudChuID49IDAgJiYgbiA8PSAxNiwgJ0ludmFsaWQgQXJndW1lbnQ6IG4gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDE2Jyk7XG4gIGlmIChuID09PSAwKSB7XG4gICAgcmV0dXJuIE9wY29kZSgnT1BfMCcpO1xuICB9XG4gIHJldHVybiBuZXcgT3Bjb2RlKE9wY29kZS5tYXAuT1BfMSArIG4gLSAxKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgT1BfMCAtIE9QXzE2IHRvIGFuIGludFxuICogQHBhcmFtIHtOdW1iZXJ9IG9wY29kZSBPcGNvZGVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbk9wY29kZS5kZWNvZGVPcE4gPSBmdW5jdGlvbihvcGNvZGUpIHtcbiAgaWYgKG9wY29kZSA9PT0gT3Bjb2RlLk9QXzApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAkLmNoZWNrQXJndW1lbnQob3Bjb2RlID49IE9wY29kZS5PUF8xICYmIG9wY29kZSA8PSBPcGNvZGUuT1BfMTYsIG5ldyBFcnJvcignSW52YWxpZCBvcGNvZGU6ICcgKyBKU09OLnN0cmluZ2lmeShvcGNvZGUpKSk7XG4gIHJldHVybiBvcGNvZGUgLSAoT3Bjb2RlLk9QXzEgLSAxKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIG9wY29kZSBpcyBjbGFzc2lmaWVkIGFzIGEgXCJzdWNjZXNzXCIuXG4gKiBUaGlzIHdhcyB0YWtlbiBmcm9tIGNvbW1pdCBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2NvbW1pdC83MjQyMmNlMzk2YjhlYmE3YjFhNzJjMTcxYzJmMDdkYWU2OTFkMWI1XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9wY29kZSBcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5PcGNvZGUuaXNPcFN1Y2Nlc3MgPSBmdW5jdGlvbihvcGNvZGUpIHtcbiAgaWYgKHR5cGVvZiBvcGNvZGUgPT09ICdzdHJpbmcnICYmICFwYXJzZUludChvcGNvZGUpKSB7XG4gICAgb3Bjb2RlID0gT3Bjb2RlW29wY29kZV07XG4gIH1cbiAgcmV0dXJuIG9wY29kZSA9PSA4MCB8fCBvcGNvZGUgPT0gOTggfHwgKG9wY29kZSA+PSAxMjYgJiYgb3Bjb2RlIDw9IDEyOSkgfHxcbiAgICAgICAgKG9wY29kZSA+PSAxMzEgJiYgb3Bjb2RlIDw9IDEzNCkgfHwgKG9wY29kZSA+PSAxMzcgJiYgb3Bjb2RlIDw9IDEzOCkgfHxcbiAgICAgICAgKG9wY29kZSA+PSAxNDEgJiYgb3Bjb2RlIDw9IDE0MikgfHwgKG9wY29kZSA+PSAxNDkgJiYgb3Bjb2RlIDw9IDE1MykgfHxcbiAgICAgICAgKG9wY29kZSA+PSAxODcgJiYgb3Bjb2RlIDw9IDI1NCk7XG59O1xuXG5cbk9wY29kZS5tYXAgPSB7XG4gIC8vIHB1c2ggdmFsdWVcbiAgT1BfRkFMU0U6IDAsXG4gIE9QXzA6IDAsXG4gIE9QX1BVU0hEQVRBMTogNzYsXG4gIE9QX1BVU0hEQVRBMjogNzcsXG4gIE9QX1BVU0hEQVRBNDogNzgsXG4gIE9QXzFORUdBVEU6IDc5LFxuICBPUF9SRVNFUlZFRDogODAsXG4gIE9QX1RSVUU6IDgxLFxuICBPUF8xOiA4MSxcbiAgT1BfMjogODIsXG4gIE9QXzM6IDgzLFxuICBPUF80OiA4NCxcbiAgT1BfNTogODUsXG4gIE9QXzY6IDg2LFxuICBPUF83OiA4NyxcbiAgT1BfODogODgsXG4gIE9QXzk6IDg5LFxuICBPUF8xMDogOTAsXG4gIE9QXzExOiA5MSxcbiAgT1BfMTI6IDkyLFxuICBPUF8xMzogOTMsXG4gIE9QXzE0OiA5NCxcbiAgT1BfMTU6IDk1LFxuICBPUF8xNjogOTYsXG5cbiAgLy8gY29udHJvbFxuICBPUF9OT1A6IDk3LFxuICBPUF9WRVI6IDk4LFxuICBPUF9JRjogOTksXG4gIE9QX05PVElGOiAxMDAsXG4gIE9QX1ZFUklGOiAxMDEsXG4gIE9QX1ZFUk5PVElGOiAxMDIsXG4gIE9QX0VMU0U6IDEwMyxcbiAgT1BfRU5ESUY6IDEwNCxcbiAgT1BfVkVSSUZZOiAxMDUsXG4gIE9QX1JFVFVSTjogMTA2LFxuXG4gIC8vIHN0YWNrIG9wc1xuICBPUF9UT0FMVFNUQUNLOiAxMDcsXG4gIE9QX0ZST01BTFRTVEFDSzogMTA4LFxuICBPUF8yRFJPUDogMTA5LFxuICBPUF8yRFVQOiAxMTAsXG4gIE9QXzNEVVA6IDExMSxcbiAgT1BfMk9WRVI6IDExMixcbiAgT1BfMlJPVDogMTEzLFxuICBPUF8yU1dBUDogMTE0LFxuICBPUF9JRkRVUDogMTE1LFxuICBPUF9ERVBUSDogMTE2LFxuICBPUF9EUk9QOiAxMTcsXG4gIE9QX0RVUDogMTE4LFxuICBPUF9OSVA6IDExOSxcbiAgT1BfT1ZFUjogMTIwLFxuICBPUF9QSUNLOiAxMjEsXG4gIE9QX1JPTEw6IDEyMixcbiAgT1BfUk9UOiAxMjMsXG4gIE9QX1NXQVA6IDEyNCxcbiAgT1BfVFVDSzogMTI1LFxuXG4gIC8vIHNwbGljZSBvcHNcbiAgT1BfQ0FUOiAxMjYsXG4gIE9QX1NVQlNUUjogMTI3LFxuICBPUF9MRUZUOiAxMjgsXG4gIE9QX1JJR0hUOiAxMjksXG4gIE9QX1NJWkU6IDEzMCxcblxuICAvLyBiaXQgbG9naWNcbiAgT1BfSU5WRVJUOiAxMzEsXG4gIE9QX0FORDogMTMyLFxuICBPUF9PUjogMTMzLFxuICBPUF9YT1I6IDEzNCxcbiAgT1BfRVFVQUw6IDEzNSxcbiAgT1BfRVFVQUxWRVJJRlk6IDEzNixcbiAgT1BfUkVTRVJWRUQxOiAxMzcsXG4gIE9QX1JFU0VSVkVEMjogMTM4LFxuXG4gIC8vIG51bWVyaWNcbiAgT1BfMUFERDogMTM5LFxuICBPUF8xU1VCOiAxNDAsXG4gIE9QXzJNVUw6IDE0MSxcbiAgT1BfMkRJVjogMTQyLFxuICBPUF9ORUdBVEU6IDE0MyxcbiAgT1BfQUJTOiAxNDQsXG4gIE9QX05PVDogMTQ1LFxuICBPUF8wTk9URVFVQUw6IDE0NixcblxuICBPUF9BREQ6IDE0NyxcbiAgT1BfU1VCOiAxNDgsXG4gIE9QX01VTDogMTQ5LFxuICBPUF9ESVY6IDE1MCxcbiAgT1BfTU9EOiAxNTEsXG4gIE9QX0xTSElGVDogMTUyLFxuICBPUF9SU0hJRlQ6IDE1MyxcblxuICBPUF9CT09MQU5EOiAxNTQsXG4gIE9QX0JPT0xPUjogMTU1LFxuICBPUF9OVU1FUVVBTDogMTU2LFxuICBPUF9OVU1FUVVBTFZFUklGWTogMTU3LFxuICBPUF9OVU1OT1RFUVVBTDogMTU4LFxuICBPUF9MRVNTVEhBTjogMTU5LFxuICBPUF9HUkVBVEVSVEhBTjogMTYwLFxuICBPUF9MRVNTVEhBTk9SRVFVQUw6IDE2MSxcbiAgT1BfR1JFQVRFUlRIQU5PUkVRVUFMOiAxNjIsXG4gIE9QX01JTjogMTYzLFxuICBPUF9NQVg6IDE2NCxcblxuICBPUF9XSVRISU46IDE2NSxcblxuICAvLyBjcnlwdG9cbiAgT1BfUklQRU1EMTYwOiAxNjYsXG4gIE9QX1NIQTE6IDE2NyxcbiAgT1BfU0hBMjU2OiAxNjgsXG4gIE9QX0hBU0gxNjA6IDE2OSxcbiAgT1BfSEFTSDI1NjogMTcwLFxuICBPUF9DT0RFU0VQQVJBVE9SOiAxNzEsXG4gIE9QX0NIRUNLU0lHOiAxNzIsXG4gIE9QX0NIRUNLU0lHVkVSSUZZOiAxNzMsXG4gIE9QX0NIRUNLTVVMVElTSUc6IDE3NCxcbiAgT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWTogMTc1LFxuXG4gIE9QX0NIRUNLTE9DS1RJTUVWRVJJRlk6IDE3NyxcbiAgT1BfQ0hFQ0tTRVFVRU5DRVZFUklGWTogMTc4LFxuXG4gIC8vIGV4cGFuc2lvblxuICBPUF9OT1AxOiAxNzYsXG4gIE9QX05PUDI6IDE3NyxcbiAgT1BfTk9QMzogMTc4LFxuICBPUF9OT1A0OiAxNzksXG4gIE9QX05PUDU6IDE4MCxcbiAgT1BfTk9QNjogMTgxLFxuICBPUF9OT1A3OiAxODIsXG4gIE9QX05PUDg6IDE4MyxcbiAgT1BfTk9QOTogMTg0LFxuICBPUF9OT1AxMDogMTg1LFxuXG4gIC8vIE9wY29kZSBhZGRlZCBieSBCSVAgMzQyIChUYXBzY3JpcHQpXG4gIE9QX0NIRUNLU0lHQUREOiAxODYsIC8vIDB4YmFcblxuICAvLyB0ZW1wbGF0ZSBtYXRjaGluZyBwYXJhbXNcbiAgT1BfUFVCS0VZSEFTSDogMjUzLFxuICBPUF9QVUJLRVk6IDI1NCxcbiAgT1BfSU5WQUxJRE9QQ09ERTogMjU1XG59O1xuXG5PcGNvZGUucmV2ZXJzZU1hcCA9IFtdO1xuXG5mb3IgKHZhciBrIGluIE9wY29kZS5tYXApIHtcbiAgT3Bjb2RlLnJldmVyc2VNYXBbT3Bjb2RlLm1hcFtrXV0gPSBrO1xufVxuXG4vLyBFYXNpZXIgYWNjZXNzIHRvIG9wY29kZXNcbl8uZXh0ZW5kKE9wY29kZSwgT3Bjb2RlLm1hcCk7XG5cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiBvcGNvZGUgaXMgb25lIG9mIE9QXzAsIE9QXzEsIC4uLiwgT1BfMTZcbiAqL1xuT3Bjb2RlLmlzU21hbGxJbnRPcCA9IGZ1bmN0aW9uKG9wY29kZSkge1xuICBpZiAob3Bjb2RlIGluc3RhbmNlb2YgT3Bjb2RlKSB7XG4gICAgb3Bjb2RlID0gb3Bjb2RlLnRvTnVtYmVyKCk7XG4gIH1cbiAgcmV0dXJuICgob3Bjb2RlID09PSBPcGNvZGUubWFwLk9QXzApIHx8XG4gICAgKChvcGNvZGUgPj0gT3Bjb2RlLm1hcC5PUF8xKSAmJiAob3Bjb2RlIDw9IE9wY29kZS5tYXAuT1BfMTYpKSk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTY3JpcHQgb3Bjb2RlXG4gKi9cbk9wY29kZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxPcGNvZGU6ICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnLCBoZXg6ICcrdGhpcy50b0hleCgpKycsIGRlY2ltYWw6ICcrdGhpcy5udW0rJz4nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcGNvZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/opcode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/privatekey.js":
/*!****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/privatekey.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar Address = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar Networks = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar Point = __webpack_require__(/*! ./crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar Random = __webpack_require__(/*! ./crypto/random */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst TaggedHash = __webpack_require__(/*! ./crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\nfunction PrivateKey(data, network) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 8 */\n\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network);\n\n  // validation\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0){\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n  if (typeof(info.network) === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n\n  return this;\n\n};\n\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\nPrivateKey.prototype._classifyArguments = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  };\n\n  // detect type of data\n  if (_.isUndefined(data) || _.isNull(data)){\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network){\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof(data) === 'string'){\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(Buffer.from(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n  return info;\n};\n\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\nPrivateKey._getRandomBN = function(){\n  var condition;\n  var bn;\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n  return bn;\n};\n\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformBuffer = function(buf, network) {\n\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n\n  return info;\n};\n\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\nPrivateKey._transformBNBuffer = function(buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformWIF = function(str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\nPrivateKey.fromBuffer = function(arg, network) {\n  return new PrivateKey(arg, network);\n};\n\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformObject = function(json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn: bn,\n    network: network,\n    compressed: json.compressed\n  };\n};\n\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromString = PrivateKey.fromWIF = function(str) {\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\nPrivateKey.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromRandom = function(network) {\n  var bn = PrivateKey._getRandomBN();\n  return new PrivateKey(bn, network);\n};\n\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\nPrivateKey.getValidationError = function(data, network) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\nPrivateKey.isValid = function(data, network){\n  if (!data) {\n    return false;\n  }\n  return !PrivateKey.getValidationError(data, network);\n};\n\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\nPrivateKey.prototype.toString = function() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\nPrivateKey.prototype.toWIF = function() {\n  var network = this.network;\n  var compressed = this.compressed;\n\n  var buf;\n  if (compressed) {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32}),\n                         Buffer.from([0x01])]);\n  } else {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32})]);\n  }\n\n  return Base58Check.encode(buf);\n};\n\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\nPrivateKey.prototype.toBigNumber = function(){\n  return this.bn;\n};\n\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBuffer = function(){\n  return this.bn.toBuffer({size: 32});\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Will return the private key as a BN buffer without leading zero padding\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBufferNoPadding = function() {\n  return this.bn.toBuffer();\n};\n\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\nPrivateKey.prototype.toPublicKey = function(){\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n  return this._pubkey;\n};\n\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\nPrivateKey.prototype.toAddress = function(network, type) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network, type);\n};\n\n/**\n * @returns {Object} A plain object representation\n */\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Create a tweaked version of this private key\n * @param {Buffer} merkleRoot (optional)\n * @returns {{ tweakedPrivKey: Buffer }}\n */\nPrivateKey.prototype.createTapTweak = function(merkleRoot) {\n  const order = Point.getN();\n  const P = Point.getG().mul(this.bn);\n  const secKey = P.y.isEven() ? this.bn : order.sub(this.bn);\n  const taggedWriter = new TaggedHash('TapTweak');\n  taggedWriter.write(P.x.toBuffer({ size: 32 }));\n\n  if (merkleRoot) {\n    $.checkArgument(Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32, 'merkleRoot must be 32 byte buffer');\n    taggedWriter.write(merkleRoot);\n  }\n  const tweakHash = taggedWriter.finalize();\n\n  $.checkState(BN.fromBuffer(tweakHash).lt(order), 'TapTweak hash failed secp256k1 order check');\n  return {\n    tweakedPrivKey: secKey.add(new BN(tweakHash)).mod(order).toBuffer({ size: 32 })\n  };\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\nPrivateKey.prototype.inspect = function() {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\n};\n\nmodule.exports = PrivateKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3ByaXZhdGVrZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFRO0FBQ3hCLGNBQWMsbUJBQU8sQ0FBQyxrRUFBVztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDbEQsU0FBUyxtQkFBTyxDQUFDLHNFQUFhO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxrRUFBVztBQUNoQyxlQUFlLG1CQUFPLENBQUMsb0VBQVk7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBYTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsOEVBQWlCO0FBQ3RDLFFBQVEsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQXFCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUIsYUFBYSxlQUFlO0FBQ3hELGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxpQkFBaUIsYUFBYSxlQUFlO0FBQ3hELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQixhQUFhLGVBQWU7QUFDeEQsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUIsYUFBYSxlQUFlO0FBQ3hELGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RSxVQUFVO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvcHJpdmF0ZWtleS5qcz82ZGU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XG52YXIgQmFzZTU4Q2hlY2sgPSByZXF1aXJlKCcuL2VuY29kaW5nL2Jhc2U1OGNoZWNrJyk7XG52YXIgQk4gPSByZXF1aXJlKCcuL2NyeXB0by9ibicpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9qcycpO1xudmFyIE5ldHdvcmtzID0gcmVxdWlyZSgnLi9uZXR3b3JrcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9jcnlwdG8vcG9pbnQnKTtcbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuL3B1YmxpY2tleScpO1xudmFyIFJhbmRvbSA9IHJlcXVpcmUoJy4vY3J5cHRvL3JhbmRvbScpO1xudmFyICQgPSByZXF1aXJlKCcuL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4vY3J5cHRvL3RhZ2dlZGhhc2gnKTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIFByaXZhdGVLZXkgZnJvbSBhIEJOLCBCdWZmZXIgYW5kIFdJRi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gZ2VuZXJhdGUgYSBuZXcgcmFuZG9tIGtleVxuICogdmFyIGtleSA9IFByaXZhdGVLZXkoKTtcbiAqXG4gKiAvLyBnZXQgdGhlIGFzc29jaWF0ZWQgYWRkcmVzc1xuICogdmFyIGFkZHJlc3MgPSBrZXkudG9BZGRyZXNzKCk7XG4gKlxuICogLy8gZW5jb2RlIGludG8gd2FsbGV0IGV4cG9ydCBmb3JtYXRcbiAqIHZhciBleHBvcnRlZCA9IGtleS50b1dJRigpO1xuICpcbiAqIC8vIGluc3RhbnRpYXRlIGZyb20gdGhlIGV4cG9ydGVkIChhbmQgc2F2ZWQpIHByaXZhdGUga2V5XG4gKiB2YXIgaW1wb3J0ZWQgPSBQcml2YXRlS2V5LmZyb21XSUYoZXhwb3J0ZWQpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICogQHBhcmFtIHtOZXR3b3JrfHN0cmluZz19IG5ldHdvcmsgLSBhIHtAbGluayBOZXR3b3JrfSBvYmplY3QsIG9yIGEgc3RyaW5nIHdpdGggdGhlIG5ldHdvcmsgbmFtZVxuICogQHJldHVybnMge1ByaXZhdGVLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIGFuIFByaXZhdGVLZXlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQcml2YXRlS2V5KGRhdGEsIG5ldHdvcmspIHtcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDIwICovXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByaXZhdGVLZXkpKSB7XG4gICAgcmV0dXJuIG5ldyBQcml2YXRlS2V5KGRhdGEsIG5ldHdvcmspO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGluZm8gPSB0aGlzLl9jbGFzc2lmeUFyZ3VtZW50cyhkYXRhLCBuZXR3b3JrKTtcblxuICAvLyB2YWxpZGF0aW9uXG4gIGlmICghaW5mby5ibiB8fCBpbmZvLmJuLmNtcChuZXcgQk4oMCkpID09PSAwKXtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOdW1iZXIgY2FuIG5vdCBiZSBlcXVhbCB0byB6ZXJvLCB1bmRlZmluZWQsIG51bGwgb3IgZmFsc2UnKTtcbiAgfVxuICBpZiAoIWluZm8uYm4ubHQoUG9pbnQuZ2V0TigpKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ051bWJlciBtdXN0IGJlIGxlc3MgdGhhbiBOJyk7XG4gIH1cbiAgaWYgKHR5cGVvZihpbmZvLm5ldHdvcmspID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3Qgc3BlY2lmeSB0aGUgbmV0d29yayAoXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCIpJyk7XG4gIH1cblxuICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKHRoaXMsIHtcbiAgICBibjogaW5mby5ibixcbiAgICBjb21wcmVzc2VkOiBpbmZvLmNvbXByZXNzZWQsXG4gICAgbmV0d29yazogaW5mby5uZXR3b3JrXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHVibGljS2V5Jywge1xuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IHRoaXMudG9QdWJsaWNLZXkuYmluZCh0aGlzKVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgdG8gaW5zdGFudGlhdGUgUHJpdmF0ZUtleSBpbnRlcm5hbCBgaW5mb2Agb2JqZWN0IGZyb21cbiAqIGRpZmZlcmVudCBraW5kcyBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7TmV0d29ya3xzdHJpbmc9fSBuZXR3b3JrIC0gYSB7QGxpbmsgTmV0d29ya30gb2JqZWN0LCBvciBhIHN0cmluZyB3aXRoIHRoZSBuZXR3b3JrIG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuUHJpdmF0ZUtleS5wcm90b3R5cGUuX2NsYXNzaWZ5QXJndW1lbnRzID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaykge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cbiAgdmFyIGluZm8gPSB7XG4gICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICBuZXR3b3JrOiBuZXR3b3JrID8gTmV0d29ya3MuZ2V0KG5ldHdvcmspIDogTmV0d29ya3MuZGVmYXVsdE5ldHdvcmtcbiAgfTtcblxuICAvLyBkZXRlY3QgdHlwZSBvZiBkYXRhXG4gIGlmIChfLmlzVW5kZWZpbmVkKGRhdGEpIHx8IF8uaXNOdWxsKGRhdGEpKXtcbiAgICBpbmZvLmJuID0gUHJpdmF0ZUtleS5fZ2V0UmFuZG9tQk4oKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQk4pIHtcbiAgICBpbmZvLmJuID0gZGF0YTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgaW5mbyA9IFByaXZhdGVLZXkuX3RyYW5zZm9ybUJ1ZmZlcihkYXRhLCBuZXR3b3JrKTtcbiAgfSBlbHNlIGlmIChkYXRhLmJuICYmIGRhdGEubmV0d29yayl7XG4gICAgaW5mbyA9IFByaXZhdGVLZXkuX3RyYW5zZm9ybU9iamVjdChkYXRhKTtcbiAgfSBlbHNlIGlmICghbmV0d29yayAmJiBOZXR3b3Jrcy5nZXQoZGF0YSkpIHtcbiAgICBpbmZvLmJuID0gUHJpdmF0ZUtleS5fZ2V0UmFuZG9tQk4oKTtcbiAgICBpbmZvLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQoZGF0YSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKGRhdGEpID09PSAnc3RyaW5nJyl7XG4gICAgaWYgKEpTVXRpbC5pc0hleGEoZGF0YSkpIHtcbiAgICAgIGluZm8uYm4gPSBuZXcgQk4oQnVmZmVyLmZyb20oZGF0YSwgJ2hleCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IFByaXZhdGVLZXkuX3RyYW5zZm9ybVdJRihkYXRhLCBuZXR3b3JrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgaXMgYW4gdW5yZWNvZ25pemVkIGRhdGEgdHlwZS4nKTtcbiAgfVxuICByZXR1cm4gaW5mbztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2V0IGEgcmFuZG9tIEJpZyBOdW1iZXIgKEJOKVxuICpcbiAqIEByZXR1cm5zIHtCTn0gQSBuZXcgcmFuZG9tbHkgZ2VuZXJhdGVkIEJOXG4gKiBAcHJpdmF0ZVxuICovXG5Qcml2YXRlS2V5Ll9nZXRSYW5kb21CTiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjb25kaXRpb247XG4gIHZhciBibjtcbiAgZG8ge1xuICAgIHZhciBwcml2YnVmID0gUmFuZG9tLmdldFJhbmRvbUJ1ZmZlcigzMik7XG4gICAgYm4gPSBCTi5mcm9tQnVmZmVyKHByaXZidWYpO1xuICAgIGNvbmRpdGlvbiA9IGJuLmx0KFBvaW50LmdldE4oKSk7XG4gIH0gd2hpbGUgKCFjb25kaXRpb24pO1xuICByZXR1cm4gYm47XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIFdJRiBCdWZmZXIgaW50byBhIHByaXZhdGUga2V5XG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIEFuIFdJRiBzdHJpbmdcbiAqIEBwYXJhbSB7TmV0d29ya3xzdHJpbmc9fSBuZXR3b3JrIC0gYSB7QGxpbmsgTmV0d29ya30gb2JqZWN0LCBvciBhIHN0cmluZyB3aXRoIHRoZSBuZXR3b3JrIG5hbWVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IGJuLCBuZXR3b3JrIGFuZCBjb21wcmVzc2VkXG4gKiBAcHJpdmF0ZVxuICovXG5Qcml2YXRlS2V5Ll90cmFuc2Zvcm1CdWZmZXIgPSBmdW5jdGlvbihidWYsIG5ldHdvcmspIHtcblxuICB2YXIgaW5mbyA9IHt9O1xuXG4gIGlmIChidWYubGVuZ3RoID09PSAzMikge1xuICAgIHJldHVybiBQcml2YXRlS2V5Ll90cmFuc2Zvcm1CTkJ1ZmZlcihidWYsIG5ldHdvcmspO1xuICB9XG5cbiAgaW5mby5uZXR3b3JrID0gTmV0d29ya3MuZ2V0KGJ1ZlswXSwgJ3ByaXZhdGVrZXknKTtcblxuICBpZiAoIWluZm8ubmV0d29yaykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuZXR3b3JrJyk7XG4gIH1cblxuICBpZiAobmV0d29yayAmJiBpbmZvLm5ldHdvcmsgIT09IE5ldHdvcmtzLmdldChuZXR3b3JrKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ByaXZhdGUga2V5IG5ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgfVxuXG4gIGlmIChidWYubGVuZ3RoID09PSAxICsgMzIgKyAxICYmIGJ1ZlsxICsgMzIgKyAxIC0gMV0gPT09IDEpIHtcbiAgICBpbmZvLmNvbXByZXNzZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPT09IDEgKyAzMikge1xuICAgIGluZm8uY29tcHJlc3NlZCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIG9mIGJ1ZmZlciBtdXN0IGJlIDMzICh1bmNvbXByZXNzZWQpIG9yIDM0IChjb21wcmVzc2VkKScpO1xuICB9XG5cbiAgaW5mby5ibiA9IEJOLmZyb21CdWZmZXIoYnVmLnNsaWNlKDEsIDMyICsgMSkpO1xuXG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBCTiBidWZmZXIgaW50byBhIHByaXZhdGUga2V5XG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHBhcmFtIHtOZXR3b3JrfHN0cmluZz19IG5ldHdvcmsgLSBhIHtAbGluayBOZXR3b3JrfSBvYmplY3QsIG9yIGEgc3RyaW5nIHdpdGggdGhlIG5ldHdvcmsgbmFtZVxuICogQHJldHVybnMge29iamVjdH0gYW4gT2JqZWN0IHdpdGgga2V5czogYm4sIG5ldHdvcmssIGFuZCBjb21wcmVzc2VkXG4gKiBAcHJpdmF0ZVxuICovXG5Qcml2YXRlS2V5Ll90cmFuc2Zvcm1CTkJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZiwgbmV0d29yaykge1xuICB2YXIgaW5mbyA9IHt9O1xuICBpbmZvLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQobmV0d29yaykgfHwgTmV0d29ya3MuZGVmYXVsdE5ldHdvcms7XG4gIGluZm8uYm4gPSBCTi5mcm9tQnVmZmVyKGJ1Zik7XG4gIGluZm8uY29tcHJlc3NlZCA9IGZhbHNlO1xuICByZXR1cm4gaW5mbztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGEgV0lGIHN0cmluZyBpbnRvIGEgcHJpdmF0ZSBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVmIC0gQW4gV0lGIHN0cmluZ1xuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5czogYm4sIG5ldHdvcmsgYW5kIGNvbXByZXNzZWRcbiAqIEBwcml2YXRlXG4gKi9cblByaXZhdGVLZXkuX3RyYW5zZm9ybVdJRiA9IGZ1bmN0aW9uKHN0ciwgbmV0d29yaykge1xuICByZXR1cm4gUHJpdmF0ZUtleS5fdHJhbnNmb3JtQnVmZmVyKEJhc2U1OENoZWNrLmRlY29kZShzdHIpLCBuZXR3b3JrKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYSBQcml2YXRlS2V5IGZyb20gYSBCdWZmZXIgd2l0aCB0aGUgREVSIG9yIFdJRiByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBhcmdcbiAqIEBwYXJhbSB7TmV0d29ya30gbmV0d29ya1xuICogQHJldHVybiB7UHJpdmF0ZUtleX1cbiAqL1xuUHJpdmF0ZUtleS5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYXJnLCBuZXR3b3JrKSB7XG4gIHJldHVybiBuZXcgUHJpdmF0ZUtleShhcmcsIG5ldHdvcmspO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBKU09OIHN0cmluZyBvbiBwbGFpbiBvYmplY3QgaW50byBhIHByaXZhdGUga2V5XG4gKiByZXR1cm4gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ganNvbiAtIEEgSlNPTiBzdHJpbmcgb3IgcGxhaW4gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBibiwgbmV0d29yayBhbmQgY29tcHJlc3NlZFxuICogQHByaXZhdGVcbiAqL1xuUHJpdmF0ZUtleS5fdHJhbnNmb3JtT2JqZWN0ID0gZnVuY3Rpb24oanNvbikge1xuICB2YXIgYm4gPSBuZXcgQk4oanNvbi5ibiwgJ2hleCcpO1xuICB2YXIgbmV0d29yayA9IE5ldHdvcmtzLmdldChqc29uLm5ldHdvcmspO1xuICByZXR1cm4ge1xuICAgIGJuOiBibixcbiAgICBuZXR3b3JrOiBuZXR3b3JrLFxuICAgIGNvbXByZXNzZWQ6IGpzb24uY29tcHJlc3NlZFxuICB9O1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIFByaXZhdGVLZXkgZnJvbSBhIFdJRiBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIFdJRiBlbmNvZGVkIHByaXZhdGUga2V5IHN0cmluZ1xuICogQHJldHVybnMge1ByaXZhdGVLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFByaXZhdGVLZXlcbiAqL1xuUHJpdmF0ZUtleS5mcm9tU3RyaW5nID0gUHJpdmF0ZUtleS5mcm9tV0lGID0gZnVuY3Rpb24oc3RyKSB7XG4gICQuY2hlY2tBcmd1bWVudChfLmlzU3RyaW5nKHN0ciksICdGaXJzdCBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIHN0cmluZy4nKTtcbiAgcmV0dXJuIG5ldyBQcml2YXRlS2V5KHN0cik7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHJpdmF0ZUtleSBmcm9tIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG91dHB1dCBmcm9tIHByaXZhdGVLZXkudG9PYmplY3QoKVxuICovXG5Qcml2YXRlS2V5LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3Qob2JqKSwgJ0ZpcnN0IGFyZ3VtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgcmV0dXJuIG5ldyBQcml2YXRlS2V5KG9iaik7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHJpdmF0ZUtleSBmcm9tIHJhbmRvbSBieXRlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmV0d29yayAtIEVpdGhlciBcImxpdmVuZXRcIiBvciBcInRlc3RuZXRcIlxuICogQHJldHVybnMge1ByaXZhdGVLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFByaXZhdGVLZXlcbiAqL1xuUHJpdmF0ZUtleS5mcm9tUmFuZG9tID0gZnVuY3Rpb24obmV0d29yaykge1xuICB2YXIgYm4gPSBQcml2YXRlS2V5Ll9nZXRSYW5kb21CTigpO1xuICByZXR1cm4gbmV3IFByaXZhdGVLZXkoYm4sIG5ldHdvcmspO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGVyZSB3b3VsZCBiZSBhbnkgZXJyb3JzIHdoZW4gaW5pdGlhbGl6aW5nIGEgUHJpdmF0ZUtleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGVuY29kZWQgZGF0YSBpbiB2YXJpb3VzIGZvcm1hdHNcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmV0d29yayAtIEVpdGhlciBcImxpdmVuZXRcIiBvciBcInRlc3RuZXRcIlxuICogQHJldHVybnMge251bGx8RXJyb3J9IEFuIGVycm9yIGlmIGV4aXN0c1xuICovXG5Qcml2YXRlS2V5LmdldFZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmspIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIC8qIGpzaGludCBub25ldzogZmFsc2UgKi9cbiAgICBuZXcgUHJpdmF0ZUtleShkYXRhLCBuZXR3b3JrKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwYXJhbWV0ZXJzIGFyZSB2YWxpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGVuY29kZWQgZGF0YSBpbiB2YXJpb3VzIGZvcm1hdHNcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmV0d29yayAtIEVpdGhlciBcImxpdmVuZXRcIiBvciBcInRlc3RuZXRcIlxuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBwcml2YXRlIGtleSBpcyB3b3VsZCBiZSB2YWxpZFxuICovXG5Qcml2YXRlS2V5LmlzVmFsaWQgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrKXtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhUHJpdmF0ZUtleS5nZXRWYWxpZGF0aW9uRXJyb3IoZGF0YSwgbmV0d29yayk7XG59O1xuXG4vKipcbiAqIFdpbGwgb3V0cHV0IHRoZSBQcml2YXRlS2V5IGVuY29kZWQgYXMgaGV4IHN0cmluZ1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblByaXZhdGVLZXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBXaWxsIG91dHB1dCB0aGUgUHJpdmF0ZUtleSB0byBhIFdJRiBzdHJpbmdcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIFdJUCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXlcbiAqL1xuUHJpdmF0ZUtleS5wcm90b3R5cGUudG9XSUYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XG4gIHZhciBjb21wcmVzc2VkID0gdGhpcy5jb21wcmVzc2VkO1xuXG4gIHZhciBidWY7XG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oW25ldHdvcmsucHJpdmF0ZWtleV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm4udG9CdWZmZXIoe3NpemU6IDMyfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20oWzB4MDFdKV0pO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFtuZXR3b3JrLnByaXZhdGVrZXldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJuLnRvQnVmZmVyKHtzaXplOiAzMn0pXSk7XG4gIH1cblxuICByZXR1cm4gQmFzZTU4Q2hlY2suZW5jb2RlKGJ1Zik7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIHRoZSBwcml2YXRlIGtleSBhcyBhIEJOIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0JOfSBBIEJOIGluc3RhbmNlIG9mIHRoZSBwcml2YXRlIGtleVxuICovXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b0JpZ051bWJlciA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLmJuO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0aGUgcHJpdmF0ZSBrZXkgYXMgYSBCTiBidWZmZXJcbiAqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBBIGJ1ZmZlciBvZiB0aGUgcHJpdmF0ZSBrZXlcbiAqL1xuUHJpdmF0ZUtleS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5ibi50b0J1ZmZlcih7c2l6ZTogMzJ9KTtcbn07XG5cbi8qKlxuICogV0FSTklORzogVGhpcyBtZXRob2Qgd2lsbCBub3QgYmUgb2ZmaWNpYWxseSBzdXBwb3J0ZWQgdW50aWwgdjEuMC4wLlxuICpcbiAqXG4gKiBXaWxsIHJldHVybiB0aGUgcHJpdmF0ZSBrZXkgYXMgYSBCTiBidWZmZXIgd2l0aG91dCBsZWFkaW5nIHplcm8gcGFkZGluZ1xuICpcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEEgYnVmZmVyIG9mIHRoZSBwcml2YXRlIGtleVxuICovXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b0J1ZmZlck5vUGFkZGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ibi50b0J1ZmZlcigpO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyBwdWJsaWMga2V5XG4gKlxuICogQHJldHVybnMge1B1YmxpY0tleX0gQSBwdWJsaWMga2V5IGdlbmVyYXRlZCBmcm9tIHRoZSBwcml2YXRlIGtleVxuICovXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b1B1YmxpY0tleSA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5fcHVia2V5KSB7XG4gICAgdGhpcy5fcHVia2V5ID0gUHVibGljS2V5LmZyb21Qcml2YXRlS2V5KHRoaXMpO1xuICB9XG4gIHJldHVybiB0aGlzLl9wdWJrZXk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGFuIGFkZHJlc3MgZm9yIHRoZSBwcml2YXRlIGtleVxuICogQHBhcmFtIHtOZXR3b3JrPX0gbmV0d29yayAtIG9wdGlvbmFsIHBhcmFtZXRlciBzcGVjaWZ5aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEVpdGhlciAncHVia2V5aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsIG9yICdzY3JpcHRoYXNoJ1xuICogdGhlIGRlc2lyZWQgbmV0d29yayBmb3IgdGhlIGFkZHJlc3NcbiAqXG4gKiBAcmV0dXJucyB7QWRkcmVzc30gQW4gYWRkcmVzcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcHJpdmF0ZSBrZXlcbiAqL1xuUHJpdmF0ZUtleS5wcm90b3R5cGUudG9BZGRyZXNzID0gZnVuY3Rpb24obmV0d29yaywgdHlwZSkge1xuICB2YXIgcHVia2V5ID0gdGhpcy50b1B1YmxpY0tleSgpO1xuICByZXR1cm4gQWRkcmVzcy5mcm9tUHVibGljS2V5KHB1YmtleSwgbmV0d29yayB8fCB0aGlzLm5ldHdvcmssIHR5cGUpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHBsYWluIG9iamVjdCByZXByZXNlbnRhdGlvblxuICovXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b09iamVjdCA9IFByaXZhdGVLZXkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIGJuOiB0aGlzLmJuLnRvU3RyaW5nKCdoZXgnKSxcbiAgICBjb21wcmVzc2VkOiB0aGlzLmNvbXByZXNzZWQsXG4gICAgbmV0d29yazogdGhpcy5uZXR3b3JrLnRvU3RyaW5nKClcbiAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgdHdlYWtlZCB2ZXJzaW9uIG9mIHRoaXMgcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXJrbGVSb290IChvcHRpb25hbClcbiAqIEByZXR1cm5zIHt7IHR3ZWFrZWRQcml2S2V5OiBCdWZmZXIgfX1cbiAqL1xuUHJpdmF0ZUtleS5wcm90b3R5cGUuY3JlYXRlVGFwVHdlYWsgPSBmdW5jdGlvbihtZXJrbGVSb290KSB7XG4gIGNvbnN0IG9yZGVyID0gUG9pbnQuZ2V0TigpO1xuICBjb25zdCBQID0gUG9pbnQuZ2V0RygpLm11bCh0aGlzLmJuKTtcbiAgY29uc3Qgc2VjS2V5ID0gUC55LmlzRXZlbigpID8gdGhpcy5ibiA6IG9yZGVyLnN1Yih0aGlzLmJuKTtcbiAgY29uc3QgdGFnZ2VkV3JpdGVyID0gbmV3IFRhZ2dlZEhhc2goJ1RhcFR3ZWFrJyk7XG4gIHRhZ2dlZFdyaXRlci53cml0ZShQLngudG9CdWZmZXIoeyBzaXplOiAzMiB9KSk7XG5cbiAgaWYgKG1lcmtsZVJvb3QpIHtcbiAgICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyLmlzQnVmZmVyKG1lcmtsZVJvb3QpICYmIG1lcmtsZVJvb3QubGVuZ3RoID09PSAzMiwgJ21lcmtsZVJvb3QgbXVzdCBiZSAzMiBieXRlIGJ1ZmZlcicpO1xuICAgIHRhZ2dlZFdyaXRlci53cml0ZShtZXJrbGVSb290KTtcbiAgfVxuICBjb25zdCB0d2Vha0hhc2ggPSB0YWdnZWRXcml0ZXIuZmluYWxpemUoKTtcblxuICAkLmNoZWNrU3RhdGUoQk4uZnJvbUJ1ZmZlcih0d2Vha0hhc2gpLmx0KG9yZGVyKSwgJ1RhcFR3ZWFrIGhhc2ggZmFpbGVkIHNlY3AyNTZrMSBvcmRlciBjaGVjaycpO1xuICByZXR1cm4ge1xuICAgIHR3ZWFrZWRQcml2S2V5OiBzZWNLZXkuYWRkKG5ldyBCTih0d2Vha0hhc2gpKS5tb2Qob3JkZXIpLnRvQnVmZmVyKHsgc2l6ZTogMzIgfSlcbiAgfTtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYSBzdHJpbmcgZm9ybWF0dGVkIGZvciB0aGUgY29uc29sZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFByaXZhdGUga2V5XG4gKi9cblByaXZhdGVLZXkucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHVuY29tcHJlc3NlZCA9ICF0aGlzLmNvbXByZXNzZWQgPyAnLCB1bmNvbXByZXNzZWQnIDogJyc7XG4gIHJldHVybiAnPFByaXZhdGVLZXk6ICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnLCBuZXR3b3JrOiAnICsgdGhpcy5uZXR3b3JrICsgdW5jb21wcmVzc2VkICsgJz4nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcml2YXRlS2V5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/publickey.js":
/*!***************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/publickey.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar Point = __webpack_require__(/*! ./crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar Network = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst TaggedHash = __webpack_require__(/*! ./crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\nfunction PublicKey(data, extra) {\n\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra);\n\n  // validation\n  info.point.validate();\n\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n\n  return this;\n};\n\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\nPublicKey.prototype._classifyArgs = function(data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  };\n\n  // detect type of data\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof(data) === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n  return info;\n};\n\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isPrivateKey = function(param) {\n  var PrivateKey = __webpack_require__(/*! ./privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\n  return param instanceof PrivateKey;\n};\n\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isBuffer = function(param) {\n  return (param instanceof Buffer) || (param instanceof Uint8Array);\n};\n\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformDER = function(buf, strict) {\n  /* jshint maxstatements: 30 */\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n\n  strict = _.isUndefined(strict) ? true : strict;\n\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n  return info;\n};\n\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformX = function(odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformObject = function(json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = PublicKey._transformPrivateKey(privkey);\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf A DER buffer (33+ bytes) or a 32 byte X-only coordinate (taproot only)\n * @param {Boolean} strict (optional; Only applies to DER format) If set to false, will loosen some conditions\n * @returns {PublicKey}\n */\nPublicKey.fromBuffer = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key or 32 byte X coordinate (taproot)');\n  if (buf.length === 32) {\n    return PublicKey.fromX(false, buf);\n  }\n  return PublicKey.fromDER(buf, strict);\n}\n\n/**\n * Instantiate a PublicKey from a DER buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromDER = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = PublicKey._transformDER(buf, strict);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPoint = function(point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromString = function(str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n  var info = PublicKey._transformDER(buf);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromX = function(odd, x) {\n  var info = PublicKey._transformX(odd, x);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * PublicKey instance from a Taproot (32-byte) public key\n * @param {String|Buffer} hexBuf \n * @returns {PublicKey}\n */\nPublicKey.fromTaproot = function(hexBuf) {\n  if (typeof hexBuf === 'string' && JSUtil.isHexaString(hexBuf)) {\n    hexBuf = Buffer.from(hexBuf, 'hex');\n  }\n  $.checkArgument(Buffer.isBuffer(hexBuf), 'hexBuf must be a hex string or buffer');\n  $.checkArgument(hexBuf.length === 32, 'Taproot public keys must be 32 bytes');\n  return new PublicKey.fromX(false, hexBuf);\n}\n\n/**\n * Verifies if the input is a valid Taproot public key\n * @param {String|Buffer} hexBuf \n * @returns {Boolean}\n */\nPublicKey.isValidTaproot = function(hexBuf) {\n  try {\n    return !!PublicKey.fromTaproot(hexBuf);\n  } catch (e) {\n    return false;\n  }\n};\n\n\n/**\n * Get the TapTweak tagged hash of this pub key and the merkleRoot\n * @param {Buffer} merkleRoot (optional)\n * @returns {Buffer}\n */\nPublicKey.prototype.computeTapTweakHash = function(merkleRoot) {\n  const taggedWriter = new TaggedHash('TapTweak');\n  taggedWriter.write(this.point.x.toBuffer({ size: 32 }));\n\n  //  If !merkleRoot, then we have no scripts. The actual tweak does not matter, but \n  //  follow BIP341 here to allow for reproducible tweaking.\n\n  if (merkleRoot) {\n    $.checkArgument(Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32, 'merkleRoot must be 32 byte buffer');\n    taggedWriter.write(merkleRoot);\n  }\n  const tweakHash = taggedWriter.finalize();\n  \n  const order = Point.getN();\n  $.checkState(BN.fromBuffer(tweakHash).lt(order), 'TapTweak hash failed secp256k1 order check');\n  return tweakHash;\n};\n\n\n/**\n * Verify a tweaked public key against this key\n * @param {PublicKey|Buffer} p Tweaked pub key\n * @param {Buffer} merkleRoot (optional)\n * @param {Buffer} control \n * @returns {Boolean}\n */\nPublicKey.prototype.checkTapTweak = function(p, merkleRoot, control) {\n  if (Buffer.isBuffer(p)) {\n    p = PublicKey.fromTaproot(p);\n  }\n  const tweak = p.computeTapTweakHash(merkleRoot);\n\n  const P = p.point.liftX();\n  const Q = P.add(this.point.curve.g.mul(BN.fromBuffer(tweak)));\n  \n  return this.point.x.eq(Q.x) && Q.y.mod(new BN(2)).eq(new BN(control[0] & 1));\n};\n\n\n/**\n * Create a tweaked version of this pub key\n * @param {Buffer} merkleRoot (optional)\n * @returns {{ parity: Number, tweakedPubKey: Buffer }}\n */\nPublicKey.prototype.createTapTweak = function(merkleRoot) {\n  $.checkArgument(merkleRoot == null || (Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32), 'merkleRoot must be a 32 byte buffer');\n\n  let t = this.computeTapTweakHash(merkleRoot);\n  t = new BN(t);\n  const Q = this.point.liftX().add(Point.getG().mul(t));\n  const parity = Q.y.isEven() ? 0 : 1;\n  return {\n    parity,\n    tweakedPubKey: Q.x.toBuffer()\n  };\n};\n\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\nPublicKey.getValidationError = function(data) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\nPublicKey.isValid = function(data) {\n  return !PublicKey.getValidationError(data);\n};\n\n/**\n * @returns {Object} A plain object of the PublicKey\n */\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {\n  var x = this.point.getX();\n  var y = this.point.getY();\n\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n\n  var prefix;\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n    if (odd) {\n      prefix = Buffer.from([0x03]);\n    } else {\n      prefix = Buffer.from([0x02]);\n    }\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} An address generated from the public key\n */\nPublicKey.prototype.toAddress = function(network, type) {\n  var Address = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\n  return Address.fromPublicKey(this, network || this.network, type);\n};\n\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\nPublicKey.prototype.toString = function() {\n  return this.toDER().toString('hex');\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\nPublicKey.prototype.inspect = function() {\n  return '<PublicKey: ' + this.toString() +\n    (this.compressed ? '' : ', uncompressed') + '>';\n};\n\n\nmodule.exports = PublicKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3B1YmxpY2tleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsc0VBQWE7QUFDOUIsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxXQUFXLG1CQUFPLENBQUMsMEVBQWU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBWTtBQUNsQyxRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBcUI7O0FBRWhEO0FBQ0EsbUNBQW1DLGlCQUFpQixHQUFHLFlBQVk7QUFDbkU7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTLGtCQUFrQjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFXO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9wdWJsaWNrZXkuanM/Yzk4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJy4vY3J5cHRvL2JuJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL2NyeXB0by9wb2ludCcpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuL2NyeXB0by9oYXNoJyk7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XG52YXIgTmV0d29yayA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5jb25zdCBUYWdnZWRIYXNoID0gcmVxdWlyZSgnLi9jcnlwdG8vdGFnZ2VkaGFzaCcpO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHVibGljS2V5IGZyb20gYSB7QGxpbmsgUHJpdmF0ZUtleX0sIHtAbGluayBQb2ludH0sIGBzdHJpbmdgLCBvciBgQnVmZmVyYC5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGludGVybmFsIHByb3BlcnRpZXMsIGBuZXR3b3JrYCBhbmQgYGNvbXByZXNzZWRgLCB0aGF0IGRlYWwgd2l0aCBpbXBvcnRpbmdcbiAqIGEgUHVibGljS2V5IGZyb20gYSBQcml2YXRlS2V5IGluIFdJRiBmb3JtYXQuIE1vcmUgZGV0YWlscyBkZXNjcmliZWQgb24ge0BsaW5rIFByaXZhdGVLZXl9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIGluc3RhbnRpYXRlIGZyb20gYSBwcml2YXRlIGtleVxuICogdmFyIGtleSA9IFB1YmxpY0tleShwcml2YXRlS2V5LCB0cnVlKTtcbiAqXG4gKiAvLyBleHBvcnQgdG8gYXMgYSBERVIgaGV4IGVuY29kZWQgc3RyaW5nXG4gKiB2YXIgZXhwb3J0ZWQgPSBrZXkudG9TdHJpbmcoKTtcbiAqXG4gKiAvLyBpbXBvcnQgdGhlIHB1YmxpYyBrZXlcbiAqIHZhciBpbXBvcnRlZCA9IFB1YmxpY0tleS5mcm9tU3RyaW5nKGV4cG9ydGVkKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGVuY29kZWQgZGF0YSBpbiB2YXJpb3VzIGZvcm1hdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSAtIGFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtOZXR3b3JrPX0gZXh0cmEubmV0d29yayAtIFdoaWNoIG5ldHdvcmsgc2hvdWxkIHRoZSBhZGRyZXNzIGZvciB0aGlzIHB1YmxpYyBrZXkgYmUgZm9yXG4gKiBAcGFyYW0ge1N0cmluZz19IGV4dHJhLmNvbXByZXNzZWQgLSBJZiB0aGUgcHVibGljIGtleSBpcyBjb21wcmVzc2VkXG4gKiBAcmV0dXJucyB7UHVibGljS2V5fSBBIG5ldyB2YWxpZCBpbnN0YW5jZSBvZiBhbiBQdWJsaWNLZXlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQdWJsaWNLZXkoZGF0YSwgZXh0cmEpIHtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHVibGljS2V5KSkge1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KGRhdGEsIGV4dHJhKTtcbiAgfVxuXG4gICQuY2hlY2tBcmd1bWVudChkYXRhLCAnRmlyc3QgYXJndW1lbnQgaXMgcmVxdWlyZWQsIHBsZWFzZSBpbmNsdWRlIHB1YmxpYyBrZXkgZGF0YS4nKTtcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFB1YmxpY0tleSkge1xuICAgIC8vIFJldHVybiBjb3B5LCBidXQgYXMgaXQncyBhbiBpbW11dGFibGUgb2JqZWN0LCByZXR1cm4gc2FtZSBhcmd1bWVudFxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGV4dHJhID0gZXh0cmEgfHwge307XG5cbiAgdmFyIGluZm8gPSB0aGlzLl9jbGFzc2lmeUFyZ3MoZGF0YSwgZXh0cmEpO1xuXG4gIC8vIHZhbGlkYXRpb25cbiAgaW5mby5wb2ludC52YWxpZGF0ZSgpO1xuXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xuICAgIHBvaW50OiBpbmZvLnBvaW50LFxuICAgIGNvbXByZXNzZWQ6IGluZm8uY29tcHJlc3NlZCxcbiAgICBuZXR3b3JrOiBpbmZvLm5ldHdvcmsgfHwgTmV0d29yay5kZWZhdWx0TmV0d29ya1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLl9jbGFzc2lmeUFyZ3MgPSBmdW5jdGlvbihkYXRhLCBleHRyYSkge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cbiAgdmFyIGluZm8gPSB7XG4gICAgY29tcHJlc3NlZDogXy5pc1VuZGVmaW5lZChleHRyYS5jb21wcmVzc2VkKSB8fCBleHRyYS5jb21wcmVzc2VkXG4gIH07XG5cbiAgLy8gZGV0ZWN0IHR5cGUgb2YgZGF0YVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgaW5mby5wb2ludCA9IGRhdGE7XG4gIH0gZWxzZSBpZiAoZGF0YS54ICYmIGRhdGEueSkge1xuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybU9iamVjdChkYXRhKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YoZGF0YSkgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtREVSKEJ1ZmZlci5mcm9tKGRhdGEsICdoZXgnKSk7XG4gIH0gZWxzZSBpZiAoUHVibGljS2V5Ll9pc0J1ZmZlcihkYXRhKSkge1xuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybURFUihkYXRhKTtcbiAgfSBlbHNlIGlmIChQdWJsaWNLZXkuX2lzUHJpdmF0ZUtleShkYXRhKSkge1xuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybVByaXZhdGVLZXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgaXMgYW4gdW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0LicpO1xuICB9XG4gIGlmICghaW5mby5uZXR3b3JrKSB7XG4gICAgaW5mby5uZXR3b3JrID0gXy5pc1VuZGVmaW5lZChleHRyYS5uZXR3b3JrKSA/IHVuZGVmaW5lZCA6IE5ldHdvcmsuZ2V0KGV4dHJhLm5ldHdvcmspO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBkZXRlY3QgaWYgYW4gb2JqZWN0IGlzIGEge0BsaW5rIFByaXZhdGVLZXl9XG4gKlxuICogQHBhcmFtIHsqfSBwYXJhbSAtIG9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cblB1YmxpY0tleS5faXNQcml2YXRlS2V5ID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgdmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuL3ByaXZhdGVrZXknKTtcbiAgcmV0dXJuIHBhcmFtIGluc3RhbmNlb2YgUHJpdmF0ZUtleTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gcGFyYW0gLSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5QdWJsaWNLZXkuX2lzQnVmZmVyID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgcmV0dXJuIChwYXJhbSBpbnN0YW5jZW9mIEJ1ZmZlcikgfHwgKHBhcmFtIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIHByaXZhdGUga2V5IGludG8gYSBwdWJsaWMga2V5IHBvaW50XG4gKlxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2a2V5IC0gQW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5czogcG9pbnQgYW5kIGNvbXByZXNzZWRcbiAqIEBwcml2YXRlXG4gKi9cblB1YmxpY0tleS5fdHJhbnNmb3JtUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHByaXZrZXkpIHtcbiAgJC5jaGVja0FyZ3VtZW50KFB1YmxpY0tleS5faXNQcml2YXRlS2V5KHByaXZrZXkpLCAnTXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQcml2YXRlS2V5Jyk7XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8ucG9pbnQgPSBQb2ludC5nZXRHKCkubXVsKHByaXZrZXkuYm4pO1xuICBpbmZvLmNvbXByZXNzZWQgPSBwcml2a2V5LmNvbXByZXNzZWQ7XG4gIGluZm8ubmV0d29yayA9IHByaXZrZXkubmV0d29yaztcbiAgcmV0dXJuIGluZm87XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBERVIgaW50byBhIHB1YmxpYyBrZXkgcG9pbnRcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gQW4gaGV4IGVuY29kZWQgYnVmZmVyXG4gKiBAcGFyYW0ge2Jvb2w9fSBzdHJpY3QgLSBpZiBzZXQgdG8gZmFsc2UsIHdpbGwgbG9vc2VuIHNvbWUgY29uZGl0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5czogcG9pbnQgYW5kIGNvbXByZXNzZWRcbiAqIEBwcml2YXRlXG4gKi9cblB1YmxpY0tleS5fdHJhbnNmb3JtREVSID0gZnVuY3Rpb24oYnVmLCBzdHJpY3QpIHtcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDMwICovXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMiAqL1xuICAkLmNoZWNrQXJndW1lbnQoUHVibGljS2V5Ll9pc0J1ZmZlcihidWYpLCAnTXVzdCBiZSBhIGhleCBidWZmZXIgb2YgREVSIGVuY29kZWQgcHVibGljIGtleScpO1xuICB2YXIgaW5mbyA9IHt9O1xuXG4gIHN0cmljdCA9IF8uaXNVbmRlZmluZWQoc3RyaWN0KSA/IHRydWUgOiBzdHJpY3Q7XG5cbiAgdmFyIHg7XG4gIHZhciB5O1xuICB2YXIgeGJ1ZjtcbiAgdmFyIHlidWY7XG5cbiAgaWYgKGJ1ZlswXSA9PT0gMHgwNCB8fCAoIXN0cmljdCAmJiAoYnVmWzBdID09PSAweDA2IHx8IGJ1ZlswXSA9PT0gMHgwNykpKSB7XG4gICAgeGJ1ZiA9IGJ1Zi5zbGljZSgxLCAzMyk7XG4gICAgeWJ1ZiA9IGJ1Zi5zbGljZSgzMywgNjUpO1xuICAgIGlmICh4YnVmLmxlbmd0aCAhPT0gMzIgfHwgeWJ1Zi5sZW5ndGggIT09IDMyIHx8IGJ1Zi5sZW5ndGggIT09IDY1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMZW5ndGggb2YgeCBhbmQgeSBtdXN0IGJlIDMyIGJ5dGVzJyk7XG4gICAgfVxuICAgIHggPSBuZXcgQk4oeGJ1Zik7XG4gICAgeSA9IG5ldyBCTih5YnVmKTtcbiAgICBpbmZvLnBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgIGluZm8uY29tcHJlc3NlZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHgwMykge1xuICAgIHhidWYgPSBidWYuc2xpY2UoMSk7XG4gICAgeCA9IG5ldyBCTih4YnVmKTtcbiAgICBpbmZvID0gUHVibGljS2V5Ll90cmFuc2Zvcm1YKHRydWUsIHgpO1xuICAgIGluZm8uY29tcHJlc3NlZCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoYnVmWzBdID09PSAweDAyKSB7XG4gICAgeGJ1ZiA9IGJ1Zi5zbGljZSgxKTtcbiAgICB4ID0gbmV3IEJOKHhidWYpO1xuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybVgoZmFsc2UsIHgpO1xuICAgIGluZm8uY29tcHJlc3NlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBERVIgZm9ybWF0IHB1YmxpYyBrZXknKTtcbiAgfVxuICByZXR1cm4gaW5mbztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIFggaW50byBhIHB1YmxpYyBrZXkgcG9pbnRcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9kZCAtIElmIHRoZSBwb2ludCBpcyBhYm92ZSBvciBiZWxvdyB0aGUgeCBheGlzXG4gKiBAcGFyYW0ge1BvaW50fSB4IC0gVGhlIHggcG9pbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IHBvaW50IGFuZCBjb21wcmVzc2VkXG4gKiBAcHJpdmF0ZVxuICovXG5QdWJsaWNLZXkuX3RyYW5zZm9ybVggPSBmdW5jdGlvbihvZGQsIHgpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHR5cGVvZiBvZGQgPT09ICdib29sZWFuJywgJ011c3Qgc3BlY2lmeSB3aGV0aGVyIHkgaXMgb2RkIG9yIG5vdCAodHJ1ZSBvciBmYWxzZSknKTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5wb2ludCA9IFBvaW50LmZyb21YKG9kZCwgeCk7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBKU09OIGludG8gYSBwdWJsaWMga2V5IHBvaW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIC0gYSBKU09OIHN0cmluZyBvciBwbGFpbiBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IHBvaW50IGFuZCBjb21wcmVzc2VkXG4gKiBAcHJpdmF0ZVxuICovXG5QdWJsaWNLZXkuX3RyYW5zZm9ybU9iamVjdCA9IGZ1bmN0aW9uKGpzb24pIHtcbiAgdmFyIHggPSBuZXcgQk4oanNvbi54LCAnaGV4Jyk7XG4gIHZhciB5ID0gbmV3IEJOKGpzb24ueSwgJ2hleCcpO1xuICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gIHJldHVybiBuZXcgUHVibGljS2V5KHBvaW50LCB7XG4gICAgY29tcHJlc3NlZDoganNvbi5jb21wcmVzc2VkXG4gIH0pO1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIFB1YmxpY0tleSBmcm9tIGEgUHJpdmF0ZUtleVxuICpcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmtleSAtIEFuIGluc3RhbmNlIG9mIFByaXZhdGVLZXlcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFB1YmxpY0tleVxuICovXG5QdWJsaWNLZXkuZnJvbVByaXZhdGVLZXkgPSBmdW5jdGlvbihwcml2a2V5KSB7XG4gICQuY2hlY2tBcmd1bWVudChQdWJsaWNLZXkuX2lzUHJpdmF0ZUtleShwcml2a2V5KSwgJ011c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleScpO1xuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtUHJpdmF0ZUtleShwcml2a2V5KTtcbiAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoaW5mby5wb2ludCwge1xuICAgIGNvbXByZXNzZWQ6IGluZm8uY29tcHJlc3NlZCxcbiAgICBuZXR3b3JrOiBpbmZvLm5ldHdvcmtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHVibGljS2V5IGZyb20gYSBCdWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgQSBERVIgYnVmZmVyICgzMysgYnl0ZXMpIG9yIGEgMzIgYnl0ZSBYLW9ubHkgY29vcmRpbmF0ZSAodGFwcm9vdCBvbmx5KVxuICogQHBhcmFtIHtCb29sZWFufSBzdHJpY3QgKG9wdGlvbmFsOyBPbmx5IGFwcGxpZXMgdG8gREVSIGZvcm1hdCkgSWYgc2V0IHRvIGZhbHNlLCB3aWxsIGxvb3NlbiBzb21lIGNvbmRpdGlvbnNcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9XG4gKi9cblB1YmxpY0tleS5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmLCBzdHJpY3QpIHtcbiAgJC5jaGVja0FyZ3VtZW50KFB1YmxpY0tleS5faXNCdWZmZXIoYnVmKSwgJ011c3QgYmUgYSBoZXggYnVmZmVyIG9mIERFUiBlbmNvZGVkIHB1YmxpYyBrZXkgb3IgMzIgYnl0ZSBYIGNvb3JkaW5hdGUgKHRhcHJvb3QpJyk7XG4gIGlmIChidWYubGVuZ3RoID09PSAzMikge1xuICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVgoZmFsc2UsIGJ1Zik7XG4gIH1cbiAgcmV0dXJuIFB1YmxpY0tleS5mcm9tREVSKGJ1Ziwgc3RyaWN0KTtcbn1cblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIFB1YmxpY0tleSBmcm9tIGEgREVSIGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIEEgREVSIGhleCBidWZmZXJcbiAqIEBwYXJhbSB7Ym9vbD19IHN0cmljdCAtIGlmIHNldCB0byBmYWxzZSwgd2lsbCBsb29zZW4gc29tZSBjb25kaXRpb25zXG4gKiBAcmV0dXJucyB7UHVibGljS2V5fSBBIG5ldyB2YWxpZCBpbnN0YW5jZSBvZiBQdWJsaWNLZXlcbiAqL1xuUHVibGljS2V5LmZyb21ERVIgPSBmdW5jdGlvbihidWYsIHN0cmljdCkge1xuICAkLmNoZWNrQXJndW1lbnQoUHVibGljS2V5Ll9pc0J1ZmZlcihidWYpLCAnTXVzdCBiZSBhIGhleCBidWZmZXIgb2YgREVSIGVuY29kZWQgcHVibGljIGtleScpO1xuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtREVSKGJ1Ziwgc3RyaWN0KTtcbiAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoaW5mby5wb2ludCwge1xuICAgIGNvbXByZXNzZWQ6IGluZm8uY29tcHJlc3NlZFxuICB9KTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYSBQdWJsaWNLZXkgZnJvbSBhIFBvaW50XG4gKlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIFBvaW50IGluc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBjb21wcmVzc2VkIC0gd2hldGhlciB0byBzdG9yZSB0aGlzIHB1YmxpYyBrZXkgYXMgY29tcHJlc3NlZCBmb3JtYXRcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFB1YmxpY0tleVxuICovXG5QdWJsaWNLZXkuZnJvbVBvaW50ID0gZnVuY3Rpb24ocG9pbnQsIGNvbXByZXNzZWQpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHBvaW50IGluc3RhbmNlb2YgUG9pbnQsICdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFBvaW50LicpO1xuICByZXR1cm4gbmV3IFB1YmxpY0tleShwb2ludCwge1xuICAgIGNvbXByZXNzZWQ6IGNvbXByZXNzZWRcbiAgfSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHVibGljS2V5IGZyb20gYSBERVIgaGV4IGVuY29kZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIEEgREVSIGhleCBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nPX0gZW5jb2RpbmcgLSBUaGUgdHlwZSBvZiBzdHJpbmcgZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFB1YmxpY0tleVxuICovXG5QdWJsaWNLZXkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0ciwgZW5jb2RpbmcgfHwgJ2hleCcpO1xuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtREVSKGJ1Zik7XG4gIHJldHVybiBuZXcgUHVibGljS2V5KGluZm8ucG9pbnQsIHtcbiAgICBjb21wcmVzc2VkOiBpbmZvLmNvbXByZXNzZWRcbiAgfSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHVibGljS2V5IGZyb20gYW4gWCBQb2ludFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb2RkIC0gSWYgdGhlIHBvaW50IGlzIGFib3ZlIG9yIGJlbG93IHRoZSB4IGF4aXNcbiAqIEBwYXJhbSB7UG9pbnR9IHggLSBUaGUgeCBwb2ludFxuICogQHJldHVybnMge1B1YmxpY0tleX0gQSBuZXcgdmFsaWQgaW5zdGFuY2Ugb2YgUHVibGljS2V5XG4gKi9cblB1YmxpY0tleS5mcm9tWCA9IGZ1bmN0aW9uKG9kZCwgeCkge1xuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtWChvZGQsIHgpO1xuICByZXR1cm4gbmV3IFB1YmxpY0tleShpbmZvLnBvaW50LCB7XG4gICAgY29tcHJlc3NlZDogaW5mby5jb21wcmVzc2VkXG4gIH0pO1xufTtcblxuLyoqXG4gKiBQdWJsaWNLZXkgaW5zdGFuY2UgZnJvbSBhIFRhcHJvb3QgKDMyLWJ5dGUpIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gaGV4QnVmIFxuICogQHJldHVybnMge1B1YmxpY0tleX1cbiAqL1xuUHVibGljS2V5LmZyb21UYXByb290ID0gZnVuY3Rpb24oaGV4QnVmKSB7XG4gIGlmICh0eXBlb2YgaGV4QnVmID09PSAnc3RyaW5nJyAmJiBKU1V0aWwuaXNIZXhhU3RyaW5nKGhleEJ1ZikpIHtcbiAgICBoZXhCdWYgPSBCdWZmZXIuZnJvbShoZXhCdWYsICdoZXgnKTtcbiAgfVxuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyLmlzQnVmZmVyKGhleEJ1ZiksICdoZXhCdWYgbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYnVmZmVyJyk7XG4gICQuY2hlY2tBcmd1bWVudChoZXhCdWYubGVuZ3RoID09PSAzMiwgJ1RhcHJvb3QgcHVibGljIGtleXMgbXVzdCBiZSAzMiBieXRlcycpO1xuICByZXR1cm4gbmV3IFB1YmxpY0tleS5mcm9tWChmYWxzZSwgaGV4QnVmKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyBpZiB0aGUgaW5wdXQgaXMgYSB2YWxpZCBUYXByb290IHB1YmxpYyBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gaGV4QnVmIFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblB1YmxpY0tleS5pc1ZhbGlkVGFwcm9vdCA9IGZ1bmN0aW9uKGhleEJ1Zikge1xuICB0cnkge1xuICAgIHJldHVybiAhIVB1YmxpY0tleS5mcm9tVGFwcm9vdChoZXhCdWYpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBUYXBUd2VhayB0YWdnZWQgaGFzaCBvZiB0aGlzIHB1YiBrZXkgYW5kIHRoZSBtZXJrbGVSb290XG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVya2xlUm9vdCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLmNvbXB1dGVUYXBUd2Vha0hhc2ggPSBmdW5jdGlvbihtZXJrbGVSb290KSB7XG4gIGNvbnN0IHRhZ2dlZFdyaXRlciA9IG5ldyBUYWdnZWRIYXNoKCdUYXBUd2VhaycpO1xuICB0YWdnZWRXcml0ZXIud3JpdGUodGhpcy5wb2ludC54LnRvQnVmZmVyKHsgc2l6ZTogMzIgfSkpO1xuXG4gIC8vICBJZiAhbWVya2xlUm9vdCwgdGhlbiB3ZSBoYXZlIG5vIHNjcmlwdHMuIFRoZSBhY3R1YWwgdHdlYWsgZG9lcyBub3QgbWF0dGVyLCBidXQgXG4gIC8vICBmb2xsb3cgQklQMzQxIGhlcmUgdG8gYWxsb3cgZm9yIHJlcHJvZHVjaWJsZSB0d2Vha2luZy5cblxuICBpZiAobWVya2xlUm9vdCkge1xuICAgICQuY2hlY2tBcmd1bWVudChCdWZmZXIuaXNCdWZmZXIobWVya2xlUm9vdCkgJiYgbWVya2xlUm9vdC5sZW5ndGggPT09IDMyLCAnbWVya2xlUm9vdCBtdXN0IGJlIDMyIGJ5dGUgYnVmZmVyJyk7XG4gICAgdGFnZ2VkV3JpdGVyLndyaXRlKG1lcmtsZVJvb3QpO1xuICB9XG4gIGNvbnN0IHR3ZWFrSGFzaCA9IHRhZ2dlZFdyaXRlci5maW5hbGl6ZSgpO1xuICBcbiAgY29uc3Qgb3JkZXIgPSBQb2ludC5nZXROKCk7XG4gICQuY2hlY2tTdGF0ZShCTi5mcm9tQnVmZmVyKHR3ZWFrSGFzaCkubHQob3JkZXIpLCAnVGFwVHdlYWsgaGFzaCBmYWlsZWQgc2VjcDI1NmsxIG9yZGVyIGNoZWNrJyk7XG4gIHJldHVybiB0d2Vha0hhc2g7XG59O1xuXG5cbi8qKlxuICogVmVyaWZ5IGEgdHdlYWtlZCBwdWJsaWMga2V5IGFnYWluc3QgdGhpcyBrZXlcbiAqIEBwYXJhbSB7UHVibGljS2V5fEJ1ZmZlcn0gcCBUd2Vha2VkIHB1YiBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXJrbGVSb290IChvcHRpb25hbClcbiAqIEBwYXJhbSB7QnVmZmVyfSBjb250cm9sIFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblB1YmxpY0tleS5wcm90b3R5cGUuY2hlY2tUYXBUd2VhayA9IGZ1bmN0aW9uKHAsIG1lcmtsZVJvb3QsIGNvbnRyb2wpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwKSkge1xuICAgIHAgPSBQdWJsaWNLZXkuZnJvbVRhcHJvb3QocCk7XG4gIH1cbiAgY29uc3QgdHdlYWsgPSBwLmNvbXB1dGVUYXBUd2Vha0hhc2gobWVya2xlUm9vdCk7XG5cbiAgY29uc3QgUCA9IHAucG9pbnQubGlmdFgoKTtcbiAgY29uc3QgUSA9IFAuYWRkKHRoaXMucG9pbnQuY3VydmUuZy5tdWwoQk4uZnJvbUJ1ZmZlcih0d2VhaykpKTtcbiAgXG4gIHJldHVybiB0aGlzLnBvaW50LnguZXEoUS54KSAmJiBRLnkubW9kKG5ldyBCTigyKSkuZXEobmV3IEJOKGNvbnRyb2xbMF0gJiAxKSk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgdHdlYWtlZCB2ZXJzaW9uIG9mIHRoaXMgcHViIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IG1lcmtsZVJvb3QgKG9wdGlvbmFsKVxuICogQHJldHVybnMge3sgcGFyaXR5OiBOdW1iZXIsIHR3ZWFrZWRQdWJLZXk6IEJ1ZmZlciB9fVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLmNyZWF0ZVRhcFR3ZWFrID0gZnVuY3Rpb24obWVya2xlUm9vdCkge1xuICAkLmNoZWNrQXJndW1lbnQobWVya2xlUm9vdCA9PSBudWxsIHx8IChCdWZmZXIuaXNCdWZmZXIobWVya2xlUm9vdCkgJiYgbWVya2xlUm9vdC5sZW5ndGggPT09IDMyKSwgJ21lcmtsZVJvb3QgbXVzdCBiZSBhIDMyIGJ5dGUgYnVmZmVyJyk7XG5cbiAgbGV0IHQgPSB0aGlzLmNvbXB1dGVUYXBUd2Vha0hhc2gobWVya2xlUm9vdCk7XG4gIHQgPSBuZXcgQk4odCk7XG4gIGNvbnN0IFEgPSB0aGlzLnBvaW50LmxpZnRYKCkuYWRkKFBvaW50LmdldEcoKS5tdWwodCkpO1xuICBjb25zdCBwYXJpdHkgPSBRLnkuaXNFdmVuKCkgPyAwIDogMTtcbiAgcmV0dXJuIHtcbiAgICBwYXJpdHksXG4gICAgdHdlYWtlZFB1YktleTogUS54LnRvQnVmZmVyKClcbiAgfTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlcmUgd291bGQgYmUgYW55IGVycm9ycyB3aGVuIGluaXRpYWxpemluZyBhIFB1YmxpY0tleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGVuY29kZWQgZGF0YSBpbiB2YXJpb3VzIGZvcm1hdHNcbiAqIEByZXR1cm5zIHtudWxsfEVycm9yfSBBbiBlcnJvciBpZiBleGlzdHNcbiAqL1xuUHVibGljS2V5LmdldFZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIC8qIGpzaGludCBub25ldzogZmFsc2UgKi9cbiAgICBuZXcgUHVibGljS2V5KGRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIHZhbGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBwdWJsaWMga2V5IHdvdWxkIGJlIHZhbGlkXG4gKi9cblB1YmxpY0tleS5pc1ZhbGlkID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gIVB1YmxpY0tleS5nZXRWYWxpZGF0aW9uRXJyb3IoZGF0YSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcGxhaW4gb2JqZWN0IG9mIHRoZSBQdWJsaWNLZXlcbiAqL1xuUHVibGljS2V5LnByb3RvdHlwZS50b09iamVjdCA9IFB1YmxpY0tleS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgeDogdGhpcy5wb2ludC5nZXRYKCkudG9TdHJpbmcoJ2hleCcsIDIpLFxuICAgIHk6IHRoaXMucG9pbnQuZ2V0WSgpLnRvU3RyaW5nKCdoZXgnLCAyKSxcbiAgICBjb21wcmVzc2VkOiB0aGlzLmNvbXByZXNzZWRcbiAgfTtcbn07XG5cbi8qKlxuICogV2lsbCBvdXRwdXQgdGhlIFB1YmxpY0tleSB0byBhIERFUiBCdWZmZXJcbiAqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBBIERFUiBoZXggZW5jb2RlZCBidWZmZXJcbiAqL1xuUHVibGljS2V5LnByb3RvdHlwZS50b0J1ZmZlciA9IFB1YmxpY0tleS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLnBvaW50LmdldFgoKTtcbiAgdmFyIHkgPSB0aGlzLnBvaW50LmdldFkoKTtcblxuICB2YXIgeGJ1ZiA9IHgudG9CdWZmZXIoe1xuICAgIHNpemU6IDMyXG4gIH0pO1xuICB2YXIgeWJ1ZiA9IHkudG9CdWZmZXIoe1xuICAgIHNpemU6IDMyXG4gIH0pO1xuXG4gIHZhciBwcmVmaXg7XG4gIGlmICghdGhpcy5jb21wcmVzc2VkKSB7XG4gICAgcHJlZml4ID0gQnVmZmVyLmZyb20oWzB4MDRdKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbcHJlZml4LCB4YnVmLCB5YnVmXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9kZCA9IHlidWZbeWJ1Zi5sZW5ndGggLSAxXSAlIDI7XG4gICAgaWYgKG9kZCkge1xuICAgICAgcHJlZml4ID0gQnVmZmVyLmZyb20oWzB4MDNdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gQnVmZmVyLmZyb20oWzB4MDJdKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgeGJ1Zl0pO1xuICB9XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc2hhMjU2ICsgcmlwZW1kMTYwIGhhc2ggb2YgdGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2Jsb2IvbWFzdGVyL3NyYy9wdWJrZXkuaCNMMTQxXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLl9nZXRJRCA9IGZ1bmN0aW9uIF9nZXRJRCgpIHtcbiAgcmV0dXJuIEhhc2guc2hhMjU2cmlwZW1kMTYwKHRoaXMudG9CdWZmZXIoKSk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGFuIGFkZHJlc3MgZm9yIHRoZSBwdWJsaWMga2V5XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBXaGljaCBuZXR3b3JrIHNob3VsZCB0aGUgYWRkcmVzcyBiZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gRWl0aGVyICdwdWJrZXloYXNoJywgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3NjcmlwdGhhc2gnXG4gKiBAcmV0dXJucyB7QWRkcmVzc30gQW4gYWRkcmVzcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcHVibGljIGtleVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLnRvQWRkcmVzcyA9IGZ1bmN0aW9uKG5ldHdvcmssIHR5cGUpIHtcbiAgdmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKTtcbiAgcmV0dXJuIEFkZHJlc3MuZnJvbVB1YmxpY0tleSh0aGlzLCBuZXR3b3JrIHx8IHRoaXMubmV0d29yaywgdHlwZSk7XG59O1xuXG4vKipcbiAqIFdpbGwgb3V0cHV0IHRoZSBQdWJsaWNLZXkgdG8gYSBERVIgZW5jb2RlZCBoZXggc3RyaW5nXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gQSBERVIgaGV4IGVuY29kZWQgc3RyaW5nXG4gKi9cblB1YmxpY0tleS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9ERVIoKS50b1N0cmluZygnaGV4Jyk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBQdWJsaWMga2V5XG4gKi9cblB1YmxpY0tleS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxQdWJsaWNLZXk6ICcgKyB0aGlzLnRvU3RyaW5nKCkgK1xuICAgICh0aGlzLmNvbXByZXNzZWQgPyAnJyA6ICcsIHVuY29tcHJlc3NlZCcpICsgJz4nO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFB1YmxpY0tleTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/publickey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/script/index.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/script/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/script.js\");\n\nmodule.exports.Interpreter = __webpack_require__(/*! ./interpreter */ \"(ssr)/./node_modules/bitcore-lib/lib/script/interpreter.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3NjcmlwdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2R0FBb0M7O0FBRXBDLG1JQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9zY3JpcHQvaW5kZXguanM/ZGVmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5cbm1vZHVsZS5leHBvcnRzLkludGVycHJldGVyID0gcmVxdWlyZSgnLi9pbnRlcnByZXRlcicpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/script/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/script/interpreter.js":
/*!************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/script/interpreter.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nconst Script = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/script.js\");\nconst Opcode = __webpack_require__(/*! ../opcode */ \"(ssr)/./node_modules/bitcore-lib/lib/opcode.js\");\nconst BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nconst Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nconst Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nconst PublicKey = __webpack_require__(/*! ../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst SighashWitness = __webpack_require__(/*! ../transaction/sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\nconst SighashSchnorr = __webpack_require__(/*! ../transaction/sighashschnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js\");\nconst BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n\n\nInterpreter.prototype.verifyWitnessProgram = function(version, program, witness, satoshis, flags, isP2SH) {\n\n  var scriptPubKey = new Script();\n  var stack = [];\n\n  if (version === 0) {\n    if (program.length === Interpreter.WITNESS_V0_SCRIPTHASH_SIZE) {\n      if (witness.length === 0) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\n        return false;\n      }\n\n      var scriptPubKeyBuffer = witness[witness.length - 1];\n      scriptPubKey = new Script(scriptPubKeyBuffer);\n      var hash = Hash.sha256(scriptPubKeyBuffer);\n      if (hash.toString('hex') !== program.toString('hex')) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      stack = witness.slice(0, -1);\n      return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.WITNESS_V0, satoshis, flags);\n    } else if (program.length === Interpreter.WITNESS_V0_KEYHASH_SIZE) {\n      if (witness.length !== 2) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      scriptPubKey.add(Opcode.OP_DUP);\n      scriptPubKey.add(Opcode.OP_HASH160);\n      scriptPubKey.add(program);\n      scriptPubKey.add(Opcode.OP_EQUALVERIFY);\n      scriptPubKey.add(Opcode.OP_CHECKSIG);\n\n      stack = witness;\n      return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.WITNESS_V0, satoshis, flags);\n    } else {\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH';\n      return false;\n    }\n  } else if (version === 1 && program.length == Interpreter.WITNESS_V1_TAPROOT_SIZE && !isP2SH) {\n    const execdata = { annexPresent: false };\n    // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n    if (!(flags & Interpreter.SCRIPT_VERIFY_TAPROOT)) {\n      return true;\n    }\n    stack = Array.from(witness);\n    if (stack.length == 0) {\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\n      return false;\n    }\n    if (stack.length >= 2 && stack[stack.length - 1].length && stack[stack.length - 1][0] === Script.ANNEX_TAG) {\n      // Drop annex (this is non-standard; see IsWitnessStandard)\n      const annex = stack.pop();\n      const annexWriter = new BufferWriter();\n      annexWriter.writeVarintNum(annex.length);\n      annexWriter.write(annex);\n      execdata.annexHash = Hash.sha256(annexWriter.toBuffer());\n      execdata.annexPresent = true;\n    }\n    execdata.annexInit = true;\n    if (stack.length === 1) {\n      // Key path spending (stack size is 1 after removing optional annex)\n      return this.checkSchnorrSignature(stack[0], program, Signature.Version.TAPROOT, execdata);\n    } else {\n      // Script path spending (stack size is >1 after removing optional annex)\n      const control = stack.pop();\n      const scriptPubKeyBuf = stack.pop();\n\n      if (\n        control.length < Interpreter.TAPROOT_CONTROL_BASE_SIZE  ||\n        control.length > Interpreter.TAPROOT_CONTROL_MAX_SIZE   ||\n        ((control.length - Interpreter.TAPROOT_CONTROL_BASE_SIZE) % Interpreter.TAPROOT_CONTROL_NODE_SIZE) != 0\n      ) {\n        this.errstr = 'SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE';\n        return false;\n      }\n      execdata.tapleafHash = Interpreter.computeTapleafHash(control[0] & Interpreter.TAPROOT_LEAF_MASK, scriptPubKeyBuf);\n      if (!Interpreter.verifyTaprootCommitment(control, program, execdata.tapleafHash)) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n      execdata.tapleafHashInit = true;\n      if ((control[0] & Interpreter.TAPROOT_LEAF_MASK) === Interpreter.TAPROOT_LEAF_TAPSCRIPT) {\n        // Tapscript (leaf version 0xc0)\n        let witnessSize;\n        {\n          const bw = new BufferWriter();\n          bw.writeVarintNum(witness.length);\n          for (let element of witness) {\n            bw.writeVarintNum(element.length);\n            bw.write(element);\n          }\n          witnessSize = bw.toBuffer().length;\n        }\n\n        try {\n          scriptPubKey = new Script(scriptPubKeyBuf);\n        } catch (err) {\n          // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n          this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n          return false;\n        }\n\n        execdata.validationWeightLeft = witnessSize + Script.VALIDATION_WEIGHT_OFFSET;\n        execdata.validationWeightLeftInit = true;\n        return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.TAPSCRIPT, satoshis, flags, execdata);\n      }\n      // If none of the above conditions are met then this must be an upgraded taproot version.\n      if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {\n        this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION';\n        return false;\n      }\n      // Future softfork compatibility\n      return true;\n    }\n  } else if ((flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)) {\n    this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM';\n    return false;\n  }\n  // Other version/size/p2sh combinations return true for future softfork compatibility\n  return true;\n};\n\n\nInterpreter.prototype.executeWitnessScript = function(scriptPubKey, stack, sigversion, satoshis, flags, execdata) {\n  if (sigversion === Signature.Version.TAPSCRIPT) {\n    for (let chunk of scriptPubKey.chunks) {\n      // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n      if (Opcode.isOpSuccess(chunk.opcodenum)) {\n        if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n          this.errstr = 'SCRIPT_ERR_DISCOURAGE_OP_SUCCESS';\n          return false;\n        }\n        return true;\n      }\n    }\n\n    // Tapscript enforces initial stack size limits (altstack is empty here)\n    if (stack.length > Interpreter.MAX_STACK_SIZE) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  }\n\n  // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n  if (stack.length && stack.some(elem => elem.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE)) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  this.initialize();\n\n  this.set({\n    script: scriptPubKey,\n    stack: stack,\n    sigversion: sigversion,\n    satoshis: satoshis,\n    flags: flags,\n    execdata: execdata\n  });\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length !== 1) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  return true;\n};\n\n\n\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n * @param {number} witness - array of witness data\n * @param {number} satoshis - number of satoshis created by this output\n *\n * Translated from bitcoind's VerifyScript\n */\nInterpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {\n\n  var Transaction = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\");\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n  if (_.isUndefined(witness)) {\n    witness = null;\n  }\n  if (_.isUndefined(satoshis)) {\n    satoshis = 0;\n  }\n\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    sigversion: Signature.Version.BASE,\n    satoshis: 0,\n    flags: flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  }\n\n  // evaluate scriptSig\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n\n  // evaluate scriptPubkey\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  var hadWitness = false;\n  if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n    var witnessValues = {};\n    if (scriptPubkey.isWitnessProgram(witnessValues)) {\n      hadWitness = true;\n      if (scriptSig.toBuffer().length !== 0) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED';\n        return false;\n      }\n      if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags, /* isP2SH */ false)) {\n        return false;\n      }\n    }\n  }\n\n  // Additional validation for spend-to-script-hash transactions:\n  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    }\n\n    // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags\n    });\n\n    // evaluate redeemScript\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n    if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n      var p2shWitnessValues = {};\n      if (redeemScript.isWitnessProgram(p2shWitnessValues)) {\n        hadWitness = true;\n        var redeemScriptPush = new Script();\n        redeemScriptPush.add(redeemScript.toBuffer());\n        if (scriptSig.toHex() !== redeemScriptPush.toHex()) {\n          this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED_P2SH';\n          return false;\n        }\n\n        if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags, /* isP2SH */ true)) {\n          return false;\n        }\n        // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n        // for witness programs.\n        stack = [stack[0]];\n      }\n    }\n  }\n\n  // The CLEANSTACK check is only performed after potential P2SH evaluation,\n  // as the non-P2SH evaluation of a P2SH script will obviously not result in\n  // a clean stack (the P2SH inputs remain). The same holds for witness\n  // evaluation.\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {\n      // Disallow CLEANSTACK without P2SH, as otherwise a switch\n      // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a\n      // softfork (and P2SH should be one).\n      if (\n        (this.flags & Interpreter.SCRIPT_VERIFY_P2SH)    == 0 ||\n        (this.flags & Interpreter.SCRIPT_VERIFY_WITNESS) == 0\n      ) {\n        throw 'flags & SCRIPT_VERIFY_P2SH';\n      }\n\n      if (stackCopy.length != 1) {\n        this.errstr = 'SCRIPT_ERR_CLEANSTACK';\n        return false;\n      }\n  }\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n    if (!hadWitness && witness.length > 0) {\n      this.errstr = 'SCRIPT_ERR_WITNESS_UNEXPECTED';\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function(obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.satoshis = 0;\n  this.sigversion = Signature.Version.BASE;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n  this.execdata = {};\n};\n\nInterpreter.prototype.set = function(obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin === 'undefined' ? this.nin : parseInt(obj.nin);\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altstack || this.altstack;\n  this.pc = typeof obj.pc === 'undefined' ? this.pc : obj.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash === 'undefined' ? this.pbegincodehash : obj.pbegincodehash;\n  this.sigversion = typeof obj.sigversion === 'undefined' ? this.sigversion : obj.sigversion;\n  this.satoshis = typeof obj.satoshis === 'undefined' ? this.satoshis : obj.satoshis;\n  this.nOpCount = typeof obj.nOpCount === 'undefined' ? this.nOpCount : obj.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags === 'undefined' ? this.flags : obj.flags;\n  this.execdata = typeof obj.execdata === 'undefined' ? this.execdata : (obj.execdata || {});\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\n\nInterpreter.MAX_SCRIPT_SIZE = 10000;\nInterpreter.MAX_STACK_SIZE = 1000;\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\n\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);\n\n// flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\nInterpreter.SCRIPT_VERIFY_NONE = 0;\n\n// Evaluate P2SH subscripts (softfork safe, BIP16).\nInterpreter.SCRIPT_VERIFY_P2SH = (1 << 0);\n\n// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\nInterpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);\n\n// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\nInterpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);\n\n// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\nInterpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);\n\n// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);\n\n// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);\n\n// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);\n\n// Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);\n\n\n// Require that only a single stack element remains after evaluation. This\n// changes the success criterion from \"At least one stack element must\n// remain, and when interpreted as a boolean, it must be true\" to \"Exactly\n// one stack element must remain, and when interpreted as a boolean, it must\n// be true\".\n// (softfork safe, BIP62 rule 6)\n// Note: CLEANSTACK should never be used without P2SH or WITNESS.\nInterpreter.SCRIPT_VERIFY_CLEANSTACK = (1 << 8),\n\n// Verify CHECKLOCKTIMEVERIFY\n//\n// See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);\n\n// support CHECKSEQUENCEVERIFY opcode\n//\n// See BIP112 for details\nInterpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1 << 10);\n\n// Support segregated witness\n//\nInterpreter.SCRIPT_VERIFY_WITNESS = (1 << 11);\n\n// Making v1-v16 witness program non-standard\n//\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1 << 12);\n\n\n//\n// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly\n// 0x01 or empty vector\n//\nInterpreter.SCRIPT_VERIFY_MINIMALIF = (1 << 13);\n\n\n// Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n//\nInterpreter.SCRIPT_VERIFY_NULLFAIL = (1 << 14);\n\n// Public keys in scripts must be compressed\n//\nInterpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1 << 15);\n\n// Do we accept signature using SIGHASH_FORKID\n//\nInterpreter.SCRIPT_ENABLE_SIGHASH_FORKID = (1 << 16);\n\n// Do we accept activate replay protection using a different fork id.\n//\nInterpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = (1 << 17);\n\n// Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n//\nInterpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE = (1 << 16);\n\n// Verify taproot script \n//\nInterpreter.SCRIPT_VERIFY_TAPROOT = (1 << 17);\n\n// Making unknown Taproot leaf versions non-standard\n//\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1 << 18);\n\n// Making unknown OP_SUCCESS non-standard\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1 << 19);\n\n// Making unknown public key versions (in BIP 342 scripts) non-standard\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1 << 20);\n\n\n\n/* Below flags apply in the context of BIP 68*/\n/**\n * If this flag set, CTxIn::nSequence is NOT interpreted as a relative\n * lock-time.\n */\nInterpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time and this flag is set,\n * the relative lock-time has units of 512 seconds, otherwise it specifies\n * blocks with a granularity of 1.\n */\nInterpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to\n * extract that lock-time from the sequence field.\n */\nInterpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\n/** Signature hash sizes */\nInterpreter.WITNESS_V0_SCRIPTHASH_SIZE = 32;\nInterpreter.WITNESS_V0_KEYHASH_SIZE = 20;\nInterpreter.WITNESS_V1_TAPROOT_SIZE = 32;\n\nInterpreter.TAPROOT_LEAF_MASK = 0xfe;\nInterpreter.TAPROOT_LEAF_TAPSCRIPT = 0xc0;\nInterpreter.TAPROOT_CONTROL_BASE_SIZE = 33;\nInterpreter.TAPROOT_CONTROL_NODE_SIZE = 32;\nInterpreter.TAPROOT_CONTROL_MAX_NODE_COUNT = 128;\nInterpreter.TAPROOT_CONTROL_MAX_SIZE = Interpreter.TAPROOT_CONTROL_BASE_SIZE + Interpreter.TAPROOT_CONTROL_NODE_SIZE * Interpreter.TAPROOT_CONTROL_MAX_NODE_COUNT;\n\n// Conceptually, this doesn't really belong with the Interpreter, but I haven't found a better place for it.\nInterpreter.PROTOCOL_VERSION = 70016;\n\nInterpreter.castToBool = function(buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\nInterpreter.prototype.checkSignatureEncoding = function(buf) {\n  var sig;\n\n    // Empty signature. Not strictly DER encoded, but allowed to provide a\n    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n    if (buf.length == 0) {\n        return true;\n    }\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\nInterpreter.prototype.checkPubkeyEncoding = function(buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n\n  // Only compressed keys are accepted in segwit\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == Signature.Version.WITNESS_V0 && !PublicKey.fromBuffer(buf).compressed) {\n    this.errstr = 'SCRIPT_ERR_WITNESS_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n\n\n/**\n * Verifies ECDSA signature\n * @param {Signature} sig \n * @param {PublicKey} pubkey \n * @param {Number} nin \n * @param {Script} subscript \n * @param {Number} satoshis \n * @returns {Boolean}\n */\nInterpreter.prototype.checkEcdsaSignature = function(sig, pubkey, nin, subscript, satoshis) {\n  var subscriptBuffer = subscript.toBuffer();\n  var scriptCodeWriter = new BufferWriter();\n  scriptCodeWriter.writeVarintNum(subscriptBuffer.length);\n  scriptCodeWriter.write(subscriptBuffer);\n\n  $.checkState(JSUtil.isNaturalNumber(satoshis));\n  var satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();\n\n  var verified = SighashWitness.verify(\n    this,\n    sig,\n    pubkey,\n    nin,\n    scriptCodeWriter.toBuffer(),\n    satoshisBuffer\n  );\n  return verified;\n};\n\n\n/**\n * Verifies Schnorr signature\n * @param {Signature|Buffer} sig \n * @param {PublicKey|Buffer} pubkey \n * @param {Number} sigversion \n * @param {Object} execdata \n * @returns {Boolean}\n */\nInterpreter.prototype.checkSchnorrSignature = function(sig, pubkey, sigversion, execdata) {\n  $.checkArgument(sig && Buffer.isBuffer(sig), 'Missing sig');\n  $.checkArgument(pubkey && Buffer.isBuffer(pubkey), 'Missing pubkey');\n  $.checkArgument(sigversion, 'Missing sigversion');\n  $.checkArgument(execdata, 'Missing execdata');\n\n  $.checkArgument(pubkey.length === 32, 'Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.');\n  // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not\n  // abort script execution). This is implemented in EvalChecksigTapscript, which won't invoke\n  // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with\n  // size different from 64 or 65.\n  if (!(sig.length === 64 || sig.length === 65)) {\n    this.errstr = 'SCRIPT_ERR_SCHNORR_SIG_SIZE';\n    return false;\n  }\n\n  if (sig.length === 65 && sig[sig.length - 1] === Signature.SIGHASH_DEFAULT) {\n    this.errstr = 'SCRIPT_ERR_SCHNORR_SIG_HASHTYPE';\n    return false;\n  }\n  sig = Signature.fromSchnorr(sig);\n  const verified = SighashSchnorr.verify(\n    this.tx,\n    sig,\n    pubkey,\n    sigversion,\n    this.nin,\n    execdata\n  );\n  return verified;\n};\n\n\n/**\n * Based on bitcoind's EvalChecksigPreTapscript function\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\n */\nInterpreter.prototype._evalChecksigPreTapscript = function(bufSig, bufPubkey) {\n  $.checkArgument(\n    this.sigversion === Signature.Version.BASE || this.sigversion === Signature.Version.WITNESS_V0,\n    'sigversion must be base or witness_v0'\n  );\n\n  // Success signifies if the signature is valid.\n  // Result signifies the result of this funciton, which also takes flags into account.\n  const retVal = { success: false, result: false };\n\n  const subscript = new Script().set({\n    chunks: this.script.chunks.slice(this.pbegincodehash)\n  });\n\n  // Drop the signature in pre-segwit scripts but not segwit scripts\n  if (this.sigversion === Signature.Version.BASE) {\n    // Drop the signature, since there's no way for a signature to sign itself\n    const tmpScript = new Script().add(bufSig);\n    let found = subscript.chunks.length;\n    subscript.findAndDelete(tmpScript);\n\n    found = found == subscript.chunks.length + 1; // found if a chunk was removed\n    if (found && (this.flags & Interpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE)) {\n      this.errstr = 'SCRIPT_ERR_SIG_FINDANDDELETE';\n      return retVal;\n    }\n  }\n\n  if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n    return retVal;\n  }\n\n  try {\n    const sig = Signature.fromTxFormat(bufSig);\n    const pubkey = PublicKey.fromBuffer(bufPubkey, false);\n    retVal.success = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);\n  } catch (e) {\n    //invalid sig or pubkey\n    retVal.success = false;\n  }\n\n  if (!retVal.success && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) && bufSig.length) {\n    this.errstr = 'SCRIPT_ERR_SIG_NULLFAIL';\n    return retVal;\n  }\n  \n  // If it reaches here, then true\n  retVal.result = true;\n  return retVal;\n};\n\n\n/**\n * Based on bitcoind's EvalChecksigTapscript function\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\n */\nInterpreter.prototype._evalChecksigTapscript = function(bufSig, bufPubkey) {\n  $.checkArgument(this.sigversion == Signature.Version.TAPSCRIPT, 'this.sigversion must by TAPSCRIPT');\n\n  /*\n    *  The following validation sequence is consensus critical. Please note how --\n    *    upgradable public key versions precede other rules;\n    *    the script execution fails when using empty signature with invalid public key;\n    *    the script execution fails when using non-empty invalid signature.\n    */\n\n  // Success signifies if the signature is valid.\n  // Result signifies the result of this funciton, which also takes flags into account.\n  const retVal = {\n    success: bufSig.length > 0,\n    result: false\n  }\n  if (retVal.success) {\n    // Implement the sigops/witnesssize ratio test.\n    // Passing with an upgradable public key version is also counted.\n    $.checkState(this.execdata.validationWeightLeftInit, 'validationWeightLeftInit is false');\n    this.execdata.validationWeightLeft -= Script.VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n    if (this.execdata.validationWeightLeft < 0) {\n      this.errstr = 'SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT';\n      return retVal;\n    }\n  }\n  if (bufPubkey.length === 0) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return retVal;\n  } else if (bufPubkey.length == 32) {\n    if (retVal.success && !this.tx.checkSchnorrSignature(bufSig, bufPubkey, this.nin, this.sigversion, this.execdata)) {\n      this.errstr = 'SCRIPT_ERR_SCHNORR_SIG';\n      return retVal;\n    }\n  } else {\n    /*\n      *  New public key version softforks should be defined before this `else` block.\n      *  Generally, the new code should not do anything but failing the script execution. To avoid\n      *  consensus bugs, it should not modify any existing values (including `success`).\n      */\n    if ((this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n      this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE';\n      return retVal;\n    }\n  }\n\n  // If it reaches here, then true\n  retVal.result = true;\n  return retVal;\n}\n\n/**\n * Based on bitcoind's EvalChecksig function\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\n * @returns {{ success: Boolean, verified: Boolean }}\n */\nInterpreter.prototype._evalCheckSig = function(bufSig, bufPubkey) {\n  switch(this.sigversion) {\n    case Signature.Version.BASE:\n    case Signature.Version.WITNESS_V0:\n      // const verified = this._evalChecksigPreTapscript(bufSig, bufPubkey);\n      // return { success: verified, verified }; // This is to keep the same return format as _evalCheckSigTapscript\n      return this._evalChecksigPreTapscript(bufSig, bufPubkey);\n    case Signature.Version.TAPSCRIPT:\n      return this._evalChecksigTapscript(bufSig, bufPubkey);\n    case Signature.Version.TAPROOT:\n      // Key path spending in Taproot has no script, so this is unreachable.\n      throw new Error('Called evalCheckSig with a TAPROOT sigversion. Check your implementation');\n  }\n};\n\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.evaluate = function() {\n  // sigversion cannot be TAPROOT here, as it admits no script execution.\n  $.checkArgument(this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0 || this.sigversion == Signature.Version.TAPSCRIPT, 'invalid sigversion');\n\n  if (\n    (this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0) &&\n    this.script.toBuffer().length > Interpreter.MAX_SCRIPT_SIZE\n  ) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n      if (!fSuccess) {\n        return false;\n      }\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\nInterpreter.prototype.checkLockTime = function(nLockTime) {\n\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(\n    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||\n    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))\n  )) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  }\n\n  // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n}\n\n\n/**\n * Checks a sequence parameter with the transaction's sequence.\n * @param {BN} nSequence the sequence read from the script\n * @return {boolean} true if the transaction's sequence is less than or equal to\n *                   the transaction's sequence \n */\nInterpreter.prototype.checkSequence = function(nSequence) {\n\n  // Relative lock times are supported by comparing the passed in operand to\n  // the sequence number of the input.\n  var txToSequence = this.tx.inputs[this.nin].sequenceNumber;\n\n  // Fail if the transaction's version number is not set high enough to\n  // trigger BIP 68 rules.\n  if (this.tx.version < 2) {\n    return false;\n  }\n\n  // Sequence numbers with their most significant bit set are not consensus\n  // constrained. Testing that the transaction's sequence number do not have\n  // this bit set prevents using this property to get around a\n  // CHECKSEQUENCEVERIFY check.\n  if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return false;\n  }\n\n  // Mask off any bits that do not have consensus-enforced meaning before\n  // doing the integer comparisons\n  var nLockTimeMask =\n      Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;\n  var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);\n  var nSequenceMasked = nSequence.and(nLockTimeMask);\n\n  // There are two kinds of nSequence: lock-by-blockheight and\n  // lock-by-blocktime, distinguished by whether nSequenceMasked <\n  // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n  //\n  // We want to compare apples to apples, so fail the script unless the type\n  // of nSequenceMasked being tested is the same as the nSequenceMasked in the\n  // transaction.\n  var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);\n  \n  if (!((txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)  &&\n          nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)) ||\n        (txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&\n          nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)))) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the comparison is a\n  // simple numeric one.\n  return nSequenceMasked.lte(txToSequenceMasked)\n}\n\n\nInterpreter.computeTapleafHash = function(leafVersion, scriptBuf) {\n  const tagWriter = TaggedHash.TAPLEAF;\n  tagWriter.writeUInt8(leafVersion);\n  tagWriter.writeVarintNum(scriptBuf.length);\n  tagWriter.write(scriptBuf);\n  return tagWriter.finalize();\n};\n\n\nInterpreter.computeTaprootMerkleRoot = function(control, tapleafHash) {\n  const pathLen = (control.length - Interpreter.TAPROOT_CONTROL_BASE_SIZE) / Interpreter.TAPROOT_CONTROL_NODE_SIZE;\n  let k = tapleafHash;\n  for (let i = 0; i < pathLen; ++i) {\n    const tagWriter = TaggedHash.TAPBRANCH;\n    const start = Interpreter.TAPROOT_CONTROL_BASE_SIZE + Interpreter.TAPROOT_CONTROL_NODE_SIZE * i;\n    const node = control.slice(start, start + Interpreter.TAPROOT_CONTROL_NODE_SIZE);\n    if (Buffer.compare(k, node) === -1) {\n      tagWriter.write(k);\n      tagWriter.write(node);\n    } else {\n      tagWriter.write(node);\n      tagWriter.write(k);\n    }\n    k = tagWriter.finalize();\n  }\n  return k;\n};\n\n\nInterpreter.verifyTaprootCommitment = function(control, program, tapleafHash) {\n  $.checkArgument(control.length >= Interpreter.TAPROOT_CONTROL_BASE_SIZE, 'control too short');\n  $.checkArgument(program.length >= 32, 'program is too short');\n\n  try {\n    //! The internal pubkey (x-only, so no Y coordinate parity).\n    const p = PublicKey.fromX(false, control.slice(1, Interpreter.TAPROOT_CONTROL_BASE_SIZE));\n    //! The output pubkey (taken from the scriptPubKey).\n    const q = PublicKey.fromX(false, program);\n    // Compute the Merkle root from the leaf and the provided path.\n    const merkleRoot = Interpreter.computeTaprootMerkleRoot(control, tapleafHash);\n    // Verify that the output pubkey matches the tweaked internal pubkey, after correcting for parity.\n    return q.checkTapTweak(p, merkleRoot, control);\n  } catch (err) {\n    return false;\n  }\n};\n\n\n/** \n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.step = function() {\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;\n\n  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n  var fExec = (this.vfExec.indexOf(false) === -1);\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess;\n  this.execdata = this.execdata || {};\n  if (!this.execdata.codeseparatorPosInit) {\n    this.execdata.codeseparatorPos = new BN(0xFFFFFFFF);\n    this.execdata.codeseparatorPosInit = true;\n  }\n\n  // Read instruction\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  if (this.sigversion === Signature.Version.BASE || this.sigversion === Signature.Version.WITNESS_V0) {\n    // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n    if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {\n      this.errstr = 'SCRIPT_ERR_OP_COUNT';\n      return false;\n    }\n  }\n\n\n  if (opcodenum === Opcode.OP_CAT ||\n    opcodenum === Opcode.OP_SUBSTR ||\n    opcodenum === Opcode.OP_LEFT ||\n    opcodenum === Opcode.OP_RIGHT ||\n    opcodenum === Opcode.OP_INVERT ||\n    opcodenum === Opcode.OP_AND ||\n    opcodenum === Opcode.OP_OR ||\n    opcodenum === Opcode.OP_XOR ||\n    opcodenum === Opcode.OP_2MUL ||\n    opcodenum === Opcode.OP_2DIV ||\n    opcodenum === Opcode.OP_MUL ||\n    opcodenum === Opcode.OP_DIV ||\n    opcodenum === Opcode.OP_MOD ||\n    opcodenum === Opcode.OP_LSHIFT ||\n    opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  // With SCRIPT_VERIFY_CONST_SCRIPTCODE, OP_CODESEPARATOR in non-segwit script is rejected even in an unexecuted branch\n  if (opcodenum == Opcode.OP_CODESEPARATOR && this.sigversion === Signature.Version.BASE && (this.flags & Interpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE)) {\n    this.errstr = 'SCRIPT_ERR_OP_CODESEPARATOR';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf);\n          // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n\n\n        //\n        // Control\n        //\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n      case Opcode.OP_NOP3:\n      case Opcode.OP_CHECKSEQUENCEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n          // not enabled; treat as a NOP3\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n\n        // nSequence, like nLockTime, is a 32-bit unsigned\n        // integer field. See the comment in CHECKLOCKTIMEVERIFY\n        // regarding 5-byte numeric operands.\n\n        var nSequence = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKSEQUENCEVERIFY.\n        if (nSequence.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // To provide for future soft-fork extensibility, if the\n        // operand has the disabled lock-time flag set,\n        // CHECKSEQUENCEVERIFY behaves as a NOP.\n        if ((nSequence &\n          Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {\n          break;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkSequence(nSequence)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n\n            buf = this.stack[this.stack.length - 1];\n\n            // Tapscript requires minimal IF/NOTIF inputs as a consensus rule.\n            if (this.sigversion === Signature.Version.TAPSCRIPT) {\n              // The input argument to the OP_IF and OP_NOTIF opcodes must be either\n              // exactly 0 (the empty vector) or exactly 1 (the one-byte vector with value 1).\n              if (buf.length > 1 || (buf.length === 1 && buf[0] !== 1)) {\n                this.errstr = 'SCRIPT_ERR_TAPSCRIPT_MINIMALIF';\n                return false;\n              }\n            }\n            // Under witness v0 rules it is only a policy rule, enabled through SCRIPT_VERIFY_MINIMALIF.\n            if (this.sigversion === Signature.Version.WITNESS_V0 && (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF)) {\n              buf = this.stack[this.stack.length - 1];\n              if (buf.length > 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n              if (buf.length == 1 && buf[0]!=1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n            }\n            fValue = Interpreter.castToBool(buf);\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n            this.stack.pop();\n          }\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n\n\n        //\n        // Stack ops\n        //\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 4];\n          buf2 = this.stack[this.stack.length - 3];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 2]);\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - n - 1];\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 2];\n          x2 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        }\n        break;\n\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn = new BN(this.stack[this.stack.length - 1].length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n\n        //\n        // Bitwise logic\n        //\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n\n        //\n        // Numeric\n        //\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n              break;\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n            case Opcode.OP_BOOLAND:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n            case Opcode.OP_BOOLOR:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n            case Opcode.OP_MIN:\n              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);\n              break;\n            case Opcode.OP_MAX:\n              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);\n              break;\n              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n\n\n        //\n        // Crypto\n        //\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n          var bufHash;\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n          this.execdata.codeseparatorPos = this.pc - 1;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1];\n\n          const { success: fSuccess, result } = this._evalCheckSig(bufSig, bufPubkey);\n          if (!result) {\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n\n          // stack.push_back(fSuccess ? vchTrue : vchFalse);\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      case Opcode.OP_CHECKSIGADD:\n        {\n          // OP_CHECKSIGADD is only available in Tapscript\n          if (this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0) {\n            this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n            return false;\n          }\n\n          // (sig num pubkey -- num)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          let sig = this.stack[this.stack.length - 3];\n          let num = this.stack[this.stack.length - 2];\n          let pubkey = this.stack[this.stack.length - 1];\n\n          num = BN.fromScriptNumBuffer(num, fRequireMinimal);\n\n          const { success, result } = this._evalCheckSig(sig, pubkey);\n          if (!result) {\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(num.addn(success ? 1 : 0).toScriptNumBuffer());\n        }\n        break;\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n          var i = 1;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n          this.nOpCount += nKeysCount;\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          }\n          // int ikey = ++i;\n          var ikey = ++i;\n          i += nKeysCount;\n\n          // ikey2 is the position of last non-signature item in\n          // the stack. Top stack item = 1. With\n          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if\n          // operation fails.\n          var ikey2 = nKeysCount + 2;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          }\n          // int isig = ++i;\n          var isig = ++i;\n          i += nSigsCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          // Subset of script starting at the most recent codeseparator\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signatures, since there's no way for a signature to sign itself\n          for (var k = 0; k < nSigsCount; k++) {\n            bufSig = this.stack[this.stack.length - isig - k];\n            subscript.findAndDelete(new Script().add(bufSig));\n          }\n\n          fSuccess = true;\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig];\n            // valtype& vchPubKey = stacktop(-ikey);\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk;\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis, this.execdata);\n            } catch (e) {\n              //invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig++;\n              nSigsCount--;\n            }\n            ikey++;\n            nKeysCount--;\n\n            // If there are more signatures left than keys left,\n            // then too many signatures have failed\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          }\n\n\n          // Clean up stack of actual arguments\n          while (i-- > 1) {\n            if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&\n              !ikey2 && this.stack[this.stack.length - 1].length) {\n\n              this.errstr = 'SCRIPT_ERR_NULLFAIL';\n              return false;\n            }\n\n            if (ikey2 > 0) {\n              ikey2--;\n            }\n\n            this.stack.pop();\n          }\n\n          // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n          this.stack.pop();\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  // Size limits\n  if (this.stack.length + this.altstack.length > Interpreter.MAX_STACK_SIZE) {\n    this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n    return false;\n  }\n\n  return true;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3NjcmlwdC9pbnRlcnByZXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMscURBQVE7O0FBRTFCLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsaUVBQVc7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMscUZBQXFCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFjO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDekMsdUJBQXVCLG1CQUFPLENBQUMseUdBQStCO0FBQzlELHVCQUF1QixtQkFBTyxDQUFDLHlHQUErQjtBQUM5RCxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDdkQsbUJBQW1CLG1CQUFPLENBQUMsdUZBQXNCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9zY3JpcHQvaW50ZXJwcmV0ZXIuanM/NDljMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuY29uc3QgU2NyaXB0ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbmNvbnN0IE9wY29kZSA9IHJlcXVpcmUoJy4uL29wY29kZScpO1xuY29uc3QgQk4gPSByZXF1aXJlKCcuLi9jcnlwdG8vYm4nKTtcbmNvbnN0IEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xuY29uc3QgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xuY29uc3QgUHVibGljS2V5ID0gcmVxdWlyZSgnLi4vcHVibGlja2V5Jyk7XG5jb25zdCAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5jb25zdCBTaWdoYXNoV2l0bmVzcyA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uL3NpZ2hhc2h3aXRuZXNzJyk7XG5jb25zdCBTaWdoYXNoU2Nobm9yciA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uL3NpZ2hhc2hzY2hub3JyJyk7XG5jb25zdCBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcbmNvbnN0IFRhZ2dlZEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vdGFnZ2VkaGFzaCcpO1xuXG4vKipcbiAqIEJpdGNvaW4gdHJhbnNhY3Rpb25zIGNvbnRhaW4gc2NyaXB0cy4gRWFjaCBpbnB1dCBoYXMgYSBzY3JpcHQgY2FsbGVkIHRoZVxuICogc2NyaXB0U2lnLCBhbmQgZWFjaCBvdXRwdXQgaGFzIGEgc2NyaXB0IGNhbGxlZCB0aGUgc2NyaXB0UHVia2V5LiBUbyB2YWxpZGF0ZVxuICogYW4gaW5wdXQsIHRoZSBpbnB1dCdzIHNjcmlwdCBpcyBjb25jYXRlbmF0ZWQgd2l0aCB0aGUgcmVmZXJlbmNlZCBvdXRwdXQgc2NyaXB0LFxuICogYW5kIHRoZSByZXN1bHQgaXMgZXhlY3V0ZWQuIElmIGF0IHRoZSBlbmQgb2YgZXhlY3V0aW9uIHRoZSBzdGFjayBjb250YWlucyBhXG4gKiBcInRydWVcIiB2YWx1ZSwgdGhlbiB0aGUgdHJhbnNhY3Rpb24gaXMgdmFsaWQuXG4gKlxuICogVGhlIHByaW1hcnkgd2F5IHRvIHVzZSB0aGlzIGNsYXNzIGlzIHZpYSB0aGUgdmVyaWZ5IGZ1bmN0aW9uLlxuICogZS5nLiwgSW50ZXJwcmV0ZXIoKS52ZXJpZnkoIC4uLiApO1xuICovXG52YXIgSW50ZXJwcmV0ZXIgPSBmdW5jdGlvbiBJbnRlcnByZXRlcihvYmopIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEludGVycHJldGVyKSkge1xuICAgIHJldHVybiBuZXcgSW50ZXJwcmV0ZXIob2JqKTtcbiAgfVxuICBpZiAob2JqKSB7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy5zZXQob2JqKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxufTtcblxuXG5JbnRlcnByZXRlci5wcm90b3R5cGUudmVyaWZ5V2l0bmVzc1Byb2dyYW0gPSBmdW5jdGlvbih2ZXJzaW9uLCBwcm9ncmFtLCB3aXRuZXNzLCBzYXRvc2hpcywgZmxhZ3MsIGlzUDJTSCkge1xuXG4gIHZhciBzY3JpcHRQdWJLZXkgPSBuZXcgU2NyaXB0KCk7XG4gIHZhciBzdGFjayA9IFtdO1xuXG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgaWYgKHByb2dyYW0ubGVuZ3RoID09PSBJbnRlcnByZXRlci5XSVRORVNTX1YwX1NDUklQVEhBU0hfU0laRSkge1xuICAgICAgaWYgKHdpdG5lc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19QUk9HUkFNX1dJVE5FU1NfRU1QVFknO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBzY3JpcHRQdWJLZXlCdWZmZXIgPSB3aXRuZXNzW3dpdG5lc3MubGVuZ3RoIC0gMV07XG4gICAgICBzY3JpcHRQdWJLZXkgPSBuZXcgU2NyaXB0KHNjcmlwdFB1YktleUJ1ZmZlcik7XG4gICAgICB2YXIgaGFzaCA9IEhhc2guc2hhMjU2KHNjcmlwdFB1YktleUJ1ZmZlcik7XG4gICAgICBpZiAoaGFzaC50b1N0cmluZygnaGV4JykgIT09IHByb2dyYW0udG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19QUk9HUkFNX01JU01BVENIJztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzdGFjayA9IHdpdG5lc3Muc2xpY2UoMCwgLTEpO1xuICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVdpdG5lc3NTY3JpcHQoc2NyaXB0UHViS2V5LCBzdGFjaywgU2lnbmF0dXJlLlZlcnNpb24uV0lUTkVTU19WMCwgc2F0b3NoaXMsIGZsYWdzKTtcbiAgICB9IGVsc2UgaWYgKHByb2dyYW0ubGVuZ3RoID09PSBJbnRlcnByZXRlci5XSVRORVNTX1YwX0tFWUhBU0hfU0laRSkge1xuICAgICAgaWYgKHdpdG5lc3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19QUk9HUkFNX01JU01BVENIJztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzY3JpcHRQdWJLZXkuYWRkKE9wY29kZS5PUF9EVVApO1xuICAgICAgc2NyaXB0UHViS2V5LmFkZChPcGNvZGUuT1BfSEFTSDE2MCk7XG4gICAgICBzY3JpcHRQdWJLZXkuYWRkKHByb2dyYW0pO1xuICAgICAgc2NyaXB0UHViS2V5LmFkZChPcGNvZGUuT1BfRVFVQUxWRVJJRlkpO1xuICAgICAgc2NyaXB0UHViS2V5LmFkZChPcGNvZGUuT1BfQ0hFQ0tTSUcpO1xuXG4gICAgICBzdGFjayA9IHdpdG5lc3M7XG4gICAgICByZXR1cm4gdGhpcy5leGVjdXRlV2l0bmVzc1NjcmlwdChzY3JpcHRQdWJLZXksIHN0YWNrLCBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwLCBzYXRvc2hpcywgZmxhZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1dJVE5FU1NfUFJPR1JBTV9XUk9OR19MRU5HVEgnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAxICYmIHByb2dyYW0ubGVuZ3RoID09IEludGVycHJldGVyLldJVE5FU1NfVjFfVEFQUk9PVF9TSVpFICYmICFpc1AyU0gpIHtcbiAgICBjb25zdCBleGVjZGF0YSA9IHsgYW5uZXhQcmVzZW50OiBmYWxzZSB9O1xuICAgIC8vIEJJUDM0MSBUYXByb290OiAzMi1ieXRlIG5vbi1QMlNIIHdpdG5lc3MgdjEgcHJvZ3JhbSAod2hpY2ggZW5jb2RlcyBhIFAyQy10d2Vha2VkIHB1YmtleSlcbiAgICBpZiAoIShmbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfVEFQUk9PVCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzdGFjayA9IEFycmF5LmZyb20od2l0bmVzcyk7XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1dJVE5FU1NfUFJPR1JBTV9XSVRORVNTX0VNUFRZJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+PSAyICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmxlbmd0aCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXVswXSA9PT0gU2NyaXB0LkFOTkVYX1RBRykge1xuICAgICAgLy8gRHJvcCBhbm5leCAodGhpcyBpcyBub24tc3RhbmRhcmQ7IHNlZSBJc1dpdG5lc3NTdGFuZGFyZClcbiAgICAgIGNvbnN0IGFubmV4ID0gc3RhY2sucG9wKCk7XG4gICAgICBjb25zdCBhbm5leFdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgIGFubmV4V3JpdGVyLndyaXRlVmFyaW50TnVtKGFubmV4Lmxlbmd0aCk7XG4gICAgICBhbm5leFdyaXRlci53cml0ZShhbm5leCk7XG4gICAgICBleGVjZGF0YS5hbm5leEhhc2ggPSBIYXNoLnNoYTI1Nihhbm5leFdyaXRlci50b0J1ZmZlcigpKTtcbiAgICAgIGV4ZWNkYXRhLmFubmV4UHJlc2VudCA9IHRydWU7XG4gICAgfVxuICAgIGV4ZWNkYXRhLmFubmV4SW5pdCA9IHRydWU7XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gS2V5IHBhdGggc3BlbmRpbmcgKHN0YWNrIHNpemUgaXMgMSBhZnRlciByZW1vdmluZyBvcHRpb25hbCBhbm5leClcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrU2Nobm9yclNpZ25hdHVyZShzdGFja1swXSwgcHJvZ3JhbSwgU2lnbmF0dXJlLlZlcnNpb24uVEFQUk9PVCwgZXhlY2RhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTY3JpcHQgcGF0aCBzcGVuZGluZyAoc3RhY2sgc2l6ZSBpcyA+MSBhZnRlciByZW1vdmluZyBvcHRpb25hbCBhbm5leClcbiAgICAgIGNvbnN0IGNvbnRyb2wgPSBzdGFjay5wb3AoKTtcbiAgICAgIGNvbnN0IHNjcmlwdFB1YktleUJ1ZiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGNvbnRyb2wubGVuZ3RoIDwgSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX0JBU0VfU0laRSAgfHxcbiAgICAgICAgY29udHJvbC5sZW5ndGggPiBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfTUFYX1NJWkUgICB8fFxuICAgICAgICAoKGNvbnRyb2wubGVuZ3RoIC0gSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX0JBU0VfU0laRSkgJSBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfTk9ERV9TSVpFKSAhPSAwXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9UQVBST09UX1dST05HX0NPTlRST0xfU0laRSc7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGV4ZWNkYXRhLnRhcGxlYWZIYXNoID0gSW50ZXJwcmV0ZXIuY29tcHV0ZVRhcGxlYWZIYXNoKGNvbnRyb2xbMF0gJiBJbnRlcnByZXRlci5UQVBST09UX0xFQUZfTUFTSywgc2NyaXB0UHViS2V5QnVmKTtcbiAgICAgIGlmICghSW50ZXJwcmV0ZXIudmVyaWZ5VGFwcm9vdENvbW1pdG1lbnQoY29udHJvbCwgcHJvZ3JhbSwgZXhlY2RhdGEudGFwbGVhZkhhc2gpKSB7XG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19QUk9HUkFNX01JU01BVENIJztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZXhlY2RhdGEudGFwbGVhZkhhc2hJbml0ID0gdHJ1ZTtcbiAgICAgIGlmICgoY29udHJvbFswXSAmIEludGVycHJldGVyLlRBUFJPT1RfTEVBRl9NQVNLKSA9PT0gSW50ZXJwcmV0ZXIuVEFQUk9PVF9MRUFGX1RBUFNDUklQVCkge1xuICAgICAgICAvLyBUYXBzY3JpcHQgKGxlYWYgdmVyc2lvbiAweGMwKVxuICAgICAgICBsZXQgd2l0bmVzc1NpemU7XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBidyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICBidy53cml0ZVZhcmludE51bSh3aXRuZXNzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiB3aXRuZXNzKSB7XG4gICAgICAgICAgICBidy53cml0ZVZhcmludE51bShlbGVtZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICBidy53cml0ZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2l0bmVzc1NpemUgPSBidy50b0J1ZmZlcigpLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2NyaXB0UHViS2V5ID0gbmV3IFNjcmlwdChzY3JpcHRQdWJLZXlCdWYpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBOb3RlIGhvdyB0aGlzIGNvbmRpdGlvbiB3b3VsZCBub3QgYmUgcmVhY2hlZCBpZiBhbiB1bmtub3duIE9QX1NVQ0NFU1N4IHdhcyBmb3VuZFxuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfQkFEX09QQ09ERSc7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhlY2RhdGEudmFsaWRhdGlvbldlaWdodExlZnQgPSB3aXRuZXNzU2l6ZSArIFNjcmlwdC5WQUxJREFUSU9OX1dFSUdIVF9PRkZTRVQ7XG4gICAgICAgIGV4ZWNkYXRhLnZhbGlkYXRpb25XZWlnaHRMZWZ0SW5pdCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVXaXRuZXNzU2NyaXB0KHNjcmlwdFB1YktleSwgc3RhY2ssIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVCwgc2F0b3NoaXMsIGZsYWdzLCBleGVjZGF0YSk7XG4gICAgICB9XG4gICAgICAvLyBJZiBub25lIG9mIHRoZSBhYm92ZSBjb25kaXRpb25zIGFyZSBtZXQgdGhlbiB0aGlzIG11c3QgYmUgYW4gdXBncmFkZWQgdGFwcm9vdCB2ZXJzaW9uLlxuICAgICAgaWYgKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfVEFQUk9PVF9WRVJTSU9OKSB7XG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9VUEdSQURBQkxFX1RBUFJPT1RfVkVSU0lPTic7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEZ1dHVyZSBzb2Z0Zm9yayBjb21wYXRpYmlsaXR5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfV0lUTkVTU19QUk9HUkFNKSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9VUEdSQURBQkxFX1dJVE5FU1NfUFJPR1JBTSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE90aGVyIHZlcnNpb24vc2l6ZS9wMnNoIGNvbWJpbmF0aW9ucyByZXR1cm4gdHJ1ZSBmb3IgZnV0dXJlIHNvZnRmb3JrIGNvbXBhdGliaWxpdHlcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbkludGVycHJldGVyLnByb3RvdHlwZS5leGVjdXRlV2l0bmVzc1NjcmlwdCA9IGZ1bmN0aW9uKHNjcmlwdFB1YktleSwgc3RhY2ssIHNpZ3ZlcnNpb24sIHNhdG9zaGlzLCBmbGFncywgZXhlY2RhdGEpIHtcbiAgaWYgKHNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVCkge1xuICAgIGZvciAobGV0IGNodW5rIG9mIHNjcmlwdFB1YktleS5jaHVua3MpIHtcbiAgICAgIC8vIE5ldyBvcGNvZGVzIHdpbGwgYmUgbGlzdGVkIGhlcmUuIE1heSB1c2UgYSBkaWZmZXJlbnQgc2lndmVyc2lvbiB0byBtb2RpZnkgZXhpc3Rpbmcgb3Bjb2Rlcy5cbiAgICAgIGlmIChPcGNvZGUuaXNPcFN1Y2Nlc3MoY2h1bmsub3Bjb2RlbnVtKSkge1xuICAgICAgICBpZiAoZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfT1BfU1VDQ0VTUykge1xuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9PUF9TVUNDRVNTJztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFwc2NyaXB0IGVuZm9yY2VzIGluaXRpYWwgc3RhY2sgc2l6ZSBsaW1pdHMgKGFsdHN0YWNrIGlzIGVtcHR5IGhlcmUpXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IEludGVycHJldGVyLk1BWF9TVEFDS19TSVpFKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NUQUNLX1NJWkUnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIERpc2FsbG93IHN0YWNrIGl0ZW0gc2l6ZSA+IE1BWF9TQ1JJUFRfRUxFTUVOVF9TSVpFIGluIHdpdG5lc3Mgc3RhY2tcbiAgaWYgKHN0YWNrLmxlbmd0aCAmJiBzdGFjay5zb21lKGVsZW0gPT4gZWxlbS5sZW5ndGggPiBJbnRlcnByZXRlci5NQVhfU0NSSVBUX0VMRU1FTlRfU0laRSkpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1BVU0hfU0laRSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhpcy5pbml0aWFsaXplKCk7XG5cbiAgdGhpcy5zZXQoe1xuICAgIHNjcmlwdDogc2NyaXB0UHViS2V5LFxuICAgIHN0YWNrOiBzdGFjayxcbiAgICBzaWd2ZXJzaW9uOiBzaWd2ZXJzaW9uLFxuICAgIHNhdG9zaGlzOiBzYXRvc2hpcyxcbiAgICBmbGFnczogZmxhZ3MsXG4gICAgZXhlY2RhdGE6IGV4ZWNkYXRhXG4gIH0pO1xuXG4gIGlmICghdGhpcy5ldmFsdWF0ZSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICE9PSAxKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9FVkFMX0ZBTFNFJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYnVmID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICBpZiAoIUludGVycHJldGVyLmNhc3RUb0Jvb2woYnVmKSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRVZBTF9GQUxTRV9JTl9TVEFDSyc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLyoqXG4gKiBWZXJpZmllcyBhIFNjcmlwdCBieSBleGVjdXRpbmcgaXQgYW5kIHJldHVybnMgdHJ1ZSBpZiBpdCBpcyB2YWxpZC5cbiAqIFRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcHJvdmlkZWQgd2l0aCB0aGUgc2NyaXB0U2lnIGFuZCB0aGUgc2NyaXB0UHVia2V5XG4gKiBzZXBhcmF0ZWx5LlxuICogQHBhcmFtIHtTY3JpcHR9IHNjcmlwdFNpZyAtIHRoZSBzY3JpcHQncyBmaXJzdCBwYXJ0IChjb3JyZXNwb25kaW5nIHRvIHRoZSB0eCBpbnB1dClcbiAqIEBwYXJhbSB7U2NyaXB0fSBzY3JpcHRQdWJrZXkgLSB0aGUgc2NyaXB0J3MgbGFzdCBwYXJ0IChjb3JyZXNwb25kaW5nIHRvIHRoZSB0eCBvdXRwdXQpXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uPX0gdHggLSB0aGUgVHJhbnNhY3Rpb24gY29udGFpbmluZyB0aGUgc2NyaXB0U2lnIGluIG9uZSBpbnB1dCAodXNlZFxuICogICAgdG8gY2hlY2sgc2lnbmF0dXJlIHZhbGlkaXR5IGZvciBzb21lIG9wY29kZXMgbGlrZSBPUF9DSEVDS1NJRylcbiAqIEBwYXJhbSB7bnVtYmVyfSBuaW4gLSBpbmRleCBvZiB0aGUgdHJhbnNhY3Rpb24gaW5wdXQgY29udGFpbmluZyB0aGUgc2NyaXB0U2lnIHZlcmlmaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gZXZhbHVhdGlvbiBmbGFncy4gU2VlIEludGVycHJldGVyLlNDUklQVF8qIGNvbnN0YW50c1xuICogQHBhcmFtIHtudW1iZXJ9IHdpdG5lc3MgLSBhcnJheSBvZiB3aXRuZXNzIGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYXRvc2hpcyAtIG51bWJlciBvZiBzYXRvc2hpcyBjcmVhdGVkIGJ5IHRoaXMgb3V0cHV0XG4gKlxuICogVHJhbnNsYXRlZCBmcm9tIGJpdGNvaW5kJ3MgVmVyaWZ5U2NyaXB0XG4gKi9cbkludGVycHJldGVyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbihzY3JpcHRTaWcsIHNjcmlwdFB1YmtleSwgdHgsIG5pbiwgZmxhZ3MsIHdpdG5lc3MsIHNhdG9zaGlzKSB7XG5cbiAgdmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi4vdHJhbnNhY3Rpb24nKTtcbiAgaWYgKF8uaXNVbmRlZmluZWQodHgpKSB7XG4gICAgdHggPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgfVxuICBpZiAoXy5pc1VuZGVmaW5lZChuaW4pKSB7XG4gICAgbmluID0gMDtcbiAgfVxuICBpZiAoXy5pc1VuZGVmaW5lZChmbGFncykpIHtcbiAgICBmbGFncyA9IDA7XG4gIH1cbiAgaWYgKF8uaXNVbmRlZmluZWQod2l0bmVzcykpIHtcbiAgICB3aXRuZXNzID0gbnVsbDtcbiAgfVxuICBpZiAoXy5pc1VuZGVmaW5lZChzYXRvc2hpcykpIHtcbiAgICBzYXRvc2hpcyA9IDA7XG4gIH1cblxuICB0aGlzLnNldCh7XG4gICAgc2NyaXB0OiBzY3JpcHRTaWcsXG4gICAgdHg6IHR4LFxuICAgIG5pbjogbmluLFxuICAgIHNpZ3ZlcnNpb246IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UsXG4gICAgc2F0b3NoaXM6IDAsXG4gICAgZmxhZ3M6IGZsYWdzXG4gIH0pO1xuICB2YXIgc3RhY2tDb3B5O1xuXG4gIGlmICgoZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1NJR1BVU0hPTkxZKSAhPT0gMCAmJiAhc2NyaXB0U2lnLmlzUHVzaE9ubHkoKSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX1BVU0hPTkxZJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBldmFsdWF0ZSBzY3JpcHRTaWdcbiAgaWYgKCF0aGlzLmV2YWx1YXRlKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1AyU0gpIHtcbiAgICBzdGFja0NvcHkgPSB0aGlzLnN0YWNrLnNsaWNlKCk7XG4gIH1cblxuICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrO1xuICB0aGlzLmluaXRpYWxpemUoKTtcbiAgdGhpcy5zZXQoe1xuICAgIHNjcmlwdDogc2NyaXB0UHVia2V5LFxuICAgIHN0YWNrOiBzdGFjayxcbiAgICB0eDogdHgsXG4gICAgbmluOiBuaW4sXG4gICAgZmxhZ3M6IGZsYWdzXG4gIH0pO1xuXG4gIC8vIGV2YWx1YXRlIHNjcmlwdFB1YmtleVxuICBpZiAoIXRoaXMuZXZhbHVhdGUoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRVZBTF9GQUxTRV9OT19SRVNVTFQnO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gIGlmICghSW50ZXJwcmV0ZXIuY2FzdFRvQm9vbChidWYpKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9FVkFMX0ZBTFNFX0lOX1NUQUNLJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaGFkV2l0bmVzcyA9IGZhbHNlO1xuICBpZiAoKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9XSVRORVNTKSkge1xuICAgIHZhciB3aXRuZXNzVmFsdWVzID0ge307XG4gICAgaWYgKHNjcmlwdFB1YmtleS5pc1dpdG5lc3NQcm9ncmFtKHdpdG5lc3NWYWx1ZXMpKSB7XG4gICAgICBoYWRXaXRuZXNzID0gdHJ1ZTtcbiAgICAgIGlmIChzY3JpcHRTaWcudG9CdWZmZXIoKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX01BTExFQVRFRCc7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy52ZXJpZnlXaXRuZXNzUHJvZ3JhbSh3aXRuZXNzVmFsdWVzLnZlcnNpb24sIHdpdG5lc3NWYWx1ZXMucHJvZ3JhbSwgd2l0bmVzcywgc2F0b3NoaXMsIHRoaXMuZmxhZ3MsIC8qIGlzUDJTSCAqLyBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZGl0aW9uYWwgdmFsaWRhdGlvbiBmb3Igc3BlbmQtdG8tc2NyaXB0LWhhc2ggdHJhbnNhY3Rpb25zOlxuICBpZiAoKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9QMlNIKSAmJiBzY3JpcHRQdWJrZXkuaXNTY3JpcHRIYXNoT3V0KCkpIHtcbiAgICAvLyBzY3JpcHRTaWcgbXVzdCBiZSBsaXRlcmFscy1vbmx5IG9yIHZhbGlkYXRpb24gZmFpbHNcbiAgICBpZiAoIXNjcmlwdFNpZy5pc1B1c2hPbmx5KCkpIHtcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX1BVU0hPTkxZJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBzdGFja0NvcHkgY2Fubm90IGJlIGVtcHR5IGhlcmUsIGJlY2F1c2UgaWYgaXQgd2FzIHRoZVxuICAgIC8vIFAyU0ggIEhBU0ggPD4gRVFVQUwgIHNjcmlwdFB1YktleSB3b3VsZCBiZSBldmFsdWF0ZWQgd2l0aFxuICAgIC8vIGFuIGVtcHR5IHN0YWNrIGFuZCB0aGUgRXZhbFNjcmlwdCBhYm92ZSB3b3VsZCByZXR1cm4gZmFsc2UuXG4gICAgaWYgKHN0YWNrQ29weS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW50ZXJuYWwgZXJyb3IgLSBzdGFjayBjb3B5IGVtcHR5Jyk7XG4gICAgfVxuXG4gICAgdmFyIHJlZGVlbVNjcmlwdFNlcmlhbGl6ZWQgPSBzdGFja0NvcHlbc3RhY2tDb3B5Lmxlbmd0aCAtIDFdO1xuICAgIHZhciByZWRlZW1TY3JpcHQgPSBTY3JpcHQuZnJvbUJ1ZmZlcihyZWRlZW1TY3JpcHRTZXJpYWxpemVkKTtcbiAgICBzdGFja0NvcHkucG9wKCk7XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLnNldCh7XG4gICAgICBzY3JpcHQ6IHJlZGVlbVNjcmlwdCxcbiAgICAgIHN0YWNrOiBzdGFja0NvcHksXG4gICAgICB0eDogdHgsXG4gICAgICBuaW46IG5pbixcbiAgICAgIGZsYWdzOiBmbGFnc1xuICAgIH0pO1xuXG4gICAgLy8gZXZhbHVhdGUgcmVkZWVtU2NyaXB0XG4gICAgaWYgKCF0aGlzLmV2YWx1YXRlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhY2tDb3B5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9FVkFMX0ZBTFNFX05PX1AyU0hfU1RBQ0snO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghSW50ZXJwcmV0ZXIuY2FzdFRvQm9vbChzdGFja0NvcHlbc3RhY2tDb3B5Lmxlbmd0aCAtIDFdKSkge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9FVkFMX0ZBTFNFX0lOX1AyU0hfU1RBQ0snO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9XSVRORVNTKSkge1xuICAgICAgdmFyIHAyc2hXaXRuZXNzVmFsdWVzID0ge307XG4gICAgICBpZiAocmVkZWVtU2NyaXB0LmlzV2l0bmVzc1Byb2dyYW0ocDJzaFdpdG5lc3NWYWx1ZXMpKSB7XG4gICAgICAgIGhhZFdpdG5lc3MgPSB0cnVlO1xuICAgICAgICB2YXIgcmVkZWVtU2NyaXB0UHVzaCA9IG5ldyBTY3JpcHQoKTtcbiAgICAgICAgcmVkZWVtU2NyaXB0UHVzaC5hZGQocmVkZWVtU2NyaXB0LnRvQnVmZmVyKCkpO1xuICAgICAgICBpZiAoc2NyaXB0U2lnLnRvSGV4KCkgIT09IHJlZGVlbVNjcmlwdFB1c2gudG9IZXgoKSkge1xuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19NQUxMRUFURURfUDJTSCc7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnZlcmlmeVdpdG5lc3NQcm9ncmFtKHAyc2hXaXRuZXNzVmFsdWVzLnZlcnNpb24sIHAyc2hXaXRuZXNzVmFsdWVzLnByb2dyYW0sIHdpdG5lc3MsIHNhdG9zaGlzLCB0aGlzLmZsYWdzLCAvKiBpc1AyU0ggKi8gdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnlwYXNzIHRoZSBjbGVhbnN0YWNrIGNoZWNrIGF0IHRoZSBlbmQuIFRoZSBhY3R1YWwgc3RhY2sgaXMgb2J2aW91c2x5IG5vdCBjbGVhblxuICAgICAgICAvLyBmb3Igd2l0bmVzcyBwcm9ncmFtcy5cbiAgICAgICAgc3RhY2sgPSBbc3RhY2tbMF1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBDTEVBTlNUQUNLIGNoZWNrIGlzIG9ubHkgcGVyZm9ybWVkIGFmdGVyIHBvdGVudGlhbCBQMlNIIGV2YWx1YXRpb24sXG4gIC8vIGFzIHRoZSBub24tUDJTSCBldmFsdWF0aW9uIG9mIGEgUDJTSCBzY3JpcHQgd2lsbCBvYnZpb3VzbHkgbm90IHJlc3VsdCBpblxuICAvLyBhIGNsZWFuIHN0YWNrICh0aGUgUDJTSCBpbnB1dHMgcmVtYWluKS4gVGhlIHNhbWUgaG9sZHMgZm9yIHdpdG5lc3NcbiAgLy8gZXZhbHVhdGlvbi5cbiAgaWYgKCh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9DTEVBTlNUQUNLKSAhPSAwKSB7XG4gICAgICAvLyBEaXNhbGxvdyBDTEVBTlNUQUNLIHdpdGhvdXQgUDJTSCwgYXMgb3RoZXJ3aXNlIGEgc3dpdGNoXG4gICAgICAvLyBDTEVBTlNUQUNLLT5QMlNIK0NMRUFOU1RBQ0sgd291bGQgYmUgcG9zc2libGUsIHdoaWNoIGlzIG5vdCBhXG4gICAgICAvLyBzb2Z0Zm9yayAoYW5kIFAyU0ggc2hvdWxkIGJlIG9uZSkuXG4gICAgICBpZiAoXG4gICAgICAgICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9QMlNIKSAgICA9PSAwIHx8XG4gICAgICAgICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9XSVRORVNTKSA9PSAwXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgJ2ZsYWdzICYgU0NSSVBUX1ZFUklGWV9QMlNIJztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YWNrQ29weS5sZW5ndGggIT0gMSkge1xuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0NMRUFOU1RBQ0snO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1dJVE5FU1MpKSB7XG4gICAgaWYgKCFoYWRXaXRuZXNzICYmIHdpdG5lc3MubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX1VORVhQRUNURUQnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcnByZXRlcjtcblxuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5zdGFjayA9IFtdO1xuICB0aGlzLmFsdHN0YWNrID0gW107XG4gIHRoaXMucGMgPSAwO1xuICB0aGlzLnNhdG9zaGlzID0gMDtcbiAgdGhpcy5zaWd2ZXJzaW9uID0gU2lnbmF0dXJlLlZlcnNpb24uQkFTRTtcbiAgdGhpcy5wYmVnaW5jb2RlaGFzaCA9IDA7XG4gIHRoaXMubk9wQ291bnQgPSAwO1xuICB0aGlzLnZmRXhlYyA9IFtdO1xuICB0aGlzLmVycnN0ciA9ICcnO1xuICB0aGlzLmZsYWdzID0gMDtcbiAgdGhpcy5leGVjZGF0YSA9IHt9O1xufTtcblxuSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xuICB0aGlzLnNjcmlwdCA9IG9iai5zY3JpcHQgfHwgdGhpcy5zY3JpcHQ7XG4gIHRoaXMudHggPSBvYmoudHggfHwgdGhpcy50eDtcbiAgdGhpcy5uaW4gPSB0eXBlb2Ygb2JqLm5pbiA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm5pbiA6IHBhcnNlSW50KG9iai5uaW4pO1xuICB0aGlzLnN0YWNrID0gb2JqLnN0YWNrIHx8IHRoaXMuc3RhY2s7XG4gIHRoaXMuYWx0c3RhY2sgPSBvYmouYWx0c3RhY2sgfHwgdGhpcy5hbHRzdGFjaztcbiAgdGhpcy5wYyA9IHR5cGVvZiBvYmoucGMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5wYyA6IG9iai5wYztcbiAgdGhpcy5wYmVnaW5jb2RlaGFzaCA9IHR5cGVvZiBvYmoucGJlZ2luY29kZWhhc2ggPT09ICd1bmRlZmluZWQnID8gdGhpcy5wYmVnaW5jb2RlaGFzaCA6IG9iai5wYmVnaW5jb2RlaGFzaDtcbiAgdGhpcy5zaWd2ZXJzaW9uID0gdHlwZW9mIG9iai5zaWd2ZXJzaW9uID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2lndmVyc2lvbiA6IG9iai5zaWd2ZXJzaW9uO1xuICB0aGlzLnNhdG9zaGlzID0gdHlwZW9mIG9iai5zYXRvc2hpcyA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNhdG9zaGlzIDogb2JqLnNhdG9zaGlzO1xuICB0aGlzLm5PcENvdW50ID0gdHlwZW9mIG9iai5uT3BDb3VudCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm5PcENvdW50IDogb2JqLm5PcENvdW50O1xuICB0aGlzLnZmRXhlYyA9IG9iai52ZkV4ZWMgfHwgdGhpcy52ZkV4ZWM7XG4gIHRoaXMuZXJyc3RyID0gb2JqLmVycnN0ciB8fCB0aGlzLmVycnN0cjtcbiAgdGhpcy5mbGFncyA9IHR5cGVvZiBvYmouZmxhZ3MgPT09ICd1bmRlZmluZWQnID8gdGhpcy5mbGFncyA6IG9iai5mbGFncztcbiAgdGhpcy5leGVjZGF0YSA9IHR5cGVvZiBvYmouZXhlY2RhdGEgPT09ICd1bmRlZmluZWQnID8gdGhpcy5leGVjZGF0YSA6IChvYmouZXhlY2RhdGEgfHwge30pO1xufTtcblxuSW50ZXJwcmV0ZXIudHJ1ZSA9IEJ1ZmZlci5mcm9tKFsxXSk7XG5JbnRlcnByZXRlci5mYWxzZSA9IEJ1ZmZlci5mcm9tKFtdKTtcblxuSW50ZXJwcmV0ZXIuTUFYX1NDUklQVF9TSVpFID0gMTAwMDA7XG5JbnRlcnByZXRlci5NQVhfU1RBQ0tfU0laRSA9IDEwMDA7XG5JbnRlcnByZXRlci5NQVhfU0NSSVBUX0VMRU1FTlRfU0laRSA9IDUyMDtcblxuSW50ZXJwcmV0ZXIuTE9DS1RJTUVfVEhSRVNIT0xEID0gNTAwMDAwMDAwO1xuSW50ZXJwcmV0ZXIuTE9DS1RJTUVfVEhSRVNIT0xEX0JOID0gbmV3IEJOKEludGVycHJldGVyLkxPQ0tUSU1FX1RIUkVTSE9MRCk7XG5cbi8vIGZsYWdzIHRha2VuIGZyb20gYml0Y29pbmRcbi8vIGJpdGNvaW5kIGNvbW1pdDogYjVkMWIxMDkyOTk4YmM5NTMxMzg1NmQ1MzVjNjMyZWE1YThmOTEwNFxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9OT05FID0gMDtcblxuLy8gRXZhbHVhdGUgUDJTSCBzdWJzY3JpcHRzIChzb2Z0Zm9yayBzYWZlLCBCSVAxNikuXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1AyU0ggPSAoMSA8PCAwKTtcblxuLy8gUGFzc2luZyBhIG5vbi1zdHJpY3QtREVSIHNpZ25hdHVyZSBvciBvbmUgd2l0aCB1bmRlZmluZWQgaGFzaHR5cGUgdG8gYSBjaGVja3NpZyBvcGVyYXRpb24gY2F1c2VzIHNjcmlwdCBmYWlsdXJlLlxuLy8gUGFzc2luZyBhIHB1YmtleSB0aGF0IGlzIG5vdCAoMHgwNCArIDY0IGJ5dGVzKSBvciAoMHgwMiBvciAweDAzICsgMzIgYnl0ZXMpIHRvIGNoZWNrc2lnIGNhdXNlcyB0aGF0IHB1YmtleSB0byBiZVxuLy8gc2tpcHBlZCAobm90IHNvZnRmb3JrIHNhZmU6IHRoaXMgZmxhZyBjYW4gd2lkZW4gdGhlIHZhbGlkaXR5IG9mIE9QX0NIRUNLU0lHIE9QX05PVCkuXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1NUUklDVEVOQyA9ICgxIDw8IDEpO1xuXG4vLyBQYXNzaW5nIGEgbm9uLXN0cmljdC1ERVIgc2lnbmF0dXJlIHRvIGEgY2hlY2tzaWcgb3BlcmF0aW9uIGNhdXNlcyBzY3JpcHQgZmFpbHVyZSAoc29mdGZvcmsgc2FmZSwgQklQNjIgcnVsZSAxKVxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ERVJTSUcgPSAoMSA8PCAyKTtcblxuLy8gUGFzc2luZyBhIG5vbi1zdHJpY3QtREVSIHNpZ25hdHVyZSBvciBvbmUgd2l0aCBTID4gb3JkZXIvMiB0byBhIGNoZWNrc2lnIG9wZXJhdGlvbiBjYXVzZXMgc2NyaXB0IGZhaWx1cmVcbi8vIChzb2Z0Zm9yayBzYWZlLCBCSVA2MiBydWxlIDUpLlxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9MT1dfUyA9ICgxIDw8IDMpO1xuXG4vLyB2ZXJpZnkgZHVtbXkgc3RhY2sgaXRlbSBjb25zdW1lZCBieSBDSEVDS01VTFRJU0lHIGlzIG9mIHplcm8tbGVuZ3RoIChzb2Z0Zm9yayBzYWZlLCBCSVA2MiBydWxlIDcpLlxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9OVUxMRFVNTVkgPSAoMSA8PCA0KTtcblxuLy8gVXNpbmcgYSBub24tcHVzaCBvcGVyYXRvciBpbiB0aGUgc2NyaXB0U2lnIGNhdXNlcyBzY3JpcHQgZmFpbHVyZSAoc29mdGZvcmsgc2FmZSwgQklQNjIgcnVsZSAyKS5cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfU0lHUFVTSE9OTFkgPSAoMSA8PCA1KTtcblxuLy8gUmVxdWlyZSBtaW5pbWFsIGVuY29kaW5ncyBmb3IgYWxsIHB1c2ggb3BlcmF0aW9ucyAoT1BfMC4uLiBPUF8xNiwgT1BfMU5FR0FURSB3aGVyZSBwb3NzaWJsZSwgZGlyZWN0XG4vLyBwdXNoZXMgdXAgdG8gNzUgYnl0ZXMsIE9QX1BVU0hEQVRBIHVwIHRvIDI1NSBieXRlcywgT1BfUFVTSERBVEEyIGZvciBhbnl0aGluZyBsYXJnZXIpLiBFdmFsdWF0aW5nXG4vLyBhbnkgb3RoZXIgcHVzaCBjYXVzZXMgdGhlIHNjcmlwdCB0byBmYWlsIChCSVA2MiBydWxlIDMpLlxuLy8gSW4gYWRkaXRpb24sIHdoZW5ldmVyIGEgc3RhY2sgZWxlbWVudCBpcyBpbnRlcnByZXRlZCBhcyBhIG51bWJlciwgaXQgbXVzdCBiZSBvZiBtaW5pbWFsIGxlbmd0aCAoQklQNjIgcnVsZSA0KS5cbi8vIChzb2Z0Zm9yayBzYWZlKVxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9NSU5JTUFMREFUQSA9ICgxIDw8IDYpO1xuXG4vLyBEaXNjb3VyYWdlIHVzZSBvZiBOT1BzIHJlc2VydmVkIGZvciB1cGdyYWRlcyAoTk9QMS0xMClcbi8vXG4vLyBQcm92aWRlZCBzbyB0aGF0IG5vZGVzIGNhbiBhdm9pZCBhY2NlcHRpbmcgb3IgbWluaW5nIHRyYW5zYWN0aW9uc1xuLy8gY29udGFpbmluZyBleGVjdXRlZCBOT1AncyB3aG9zZSBtZWFuaW5nIG1heSBjaGFuZ2UgYWZ0ZXIgYSBzb2Z0LWZvcmssXG4vLyB0aHVzIHJlbmRlcmluZyB0aGUgc2NyaXB0IGludmFsaWQ7IHdpdGggdGhpcyBmbGFnIHNldCBleGVjdXRpbmdcbi8vIGRpc2NvdXJhZ2VkIE5PUHMgZmFpbHMgdGhlIHNjcmlwdC4gVGhpcyB2ZXJpZmljYXRpb24gZmxhZyB3aWxsIG5ldmVyIGJlXG4vLyBhIG1hbmRhdG9yeSBmbGFnIGFwcGxpZWQgdG8gc2NyaXB0cyBpbiBhIGJsb2NrLiBOT1BzIHRoYXQgYXJlIG5vdFxuLy8gZXhlY3V0ZWQsIGUuZy4gIHdpdGhpbiBhbiB1bmV4ZWN1dGVkIElGIEVORElGIGJsb2NrLCBhcmUgKm5vdCogcmVqZWN0ZWQuXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9OT1BTID0gKDEgPDwgNyk7XG5cblxuLy8gUmVxdWlyZSB0aGF0IG9ubHkgYSBzaW5nbGUgc3RhY2sgZWxlbWVudCByZW1haW5zIGFmdGVyIGV2YWx1YXRpb24uIFRoaXNcbi8vIGNoYW5nZXMgdGhlIHN1Y2Nlc3MgY3JpdGVyaW9uIGZyb20gXCJBdCBsZWFzdCBvbmUgc3RhY2sgZWxlbWVudCBtdXN0XG4vLyByZW1haW4sIGFuZCB3aGVuIGludGVycHJldGVkIGFzIGEgYm9vbGVhbiwgaXQgbXVzdCBiZSB0cnVlXCIgdG8gXCJFeGFjdGx5XG4vLyBvbmUgc3RhY2sgZWxlbWVudCBtdXN0IHJlbWFpbiwgYW5kIHdoZW4gaW50ZXJwcmV0ZWQgYXMgYSBib29sZWFuLCBpdCBtdXN0XG4vLyBiZSB0cnVlXCIuXG4vLyAoc29mdGZvcmsgc2FmZSwgQklQNjIgcnVsZSA2KVxuLy8gTm90ZTogQ0xFQU5TVEFDSyBzaG91bGQgbmV2ZXIgYmUgdXNlZCB3aXRob3V0IFAyU0ggb3IgV0lUTkVTUy5cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ0xFQU5TVEFDSyA9ICgxIDw8IDgpLFxuXG4vLyBWZXJpZnkgQ0hFQ0tMT0NLVElNRVZFUklGWVxuLy9cbi8vIFNlZSBCSVA2NSBmb3IgZGV0YWlscy5cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ0hFQ0tMT0NLVElNRVZFUklGWSA9ICgxIDw8IDkpO1xuXG4vLyBzdXBwb3J0IENIRUNLU0VRVUVOQ0VWRVJJRlkgb3Bjb2RlXG4vL1xuLy8gU2VlIEJJUDExMiBmb3IgZGV0YWlsc1xuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9DSEVDS1NFUVVFTkNFVkVSSUZZID0gKDEgPDwgMTApO1xuXG4vLyBTdXBwb3J0IHNlZ3JlZ2F0ZWQgd2l0bmVzc1xuLy9cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfV0lUTkVTUyA9ICgxIDw8IDExKTtcblxuLy8gTWFraW5nIHYxLXYxNiB3aXRuZXNzIHByb2dyYW0gbm9uLXN0YW5kYXJkXG4vL1xuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfV0lUTkVTU19QUk9HUkFNID0gKDEgPDwgMTIpO1xuXG5cbi8vXG4vLyBTZWd3aXQgc2NyaXB0IG9ubHk6IFJlcXVpcmUgdGhlIGFyZ3VtZW50IG9mIE9QX0lGL05PVElGIHRvIGJlIGV4YWN0bHlcbi8vIDB4MDEgb3IgZW1wdHkgdmVjdG9yXG4vL1xuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9NSU5JTUFMSUYgPSAoMSA8PCAxMyk7XG5cblxuLy8gU2lnbmF0dXJlKHMpIG11c3QgYmUgZW1wdHkgdmVjdG9yIGlmIGFuIENIRUNLKE1VTFRJKVNJRyBvcGVyYXRpb24gZmFpbGVkXG4vL1xuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9OVUxMRkFJTCA9ICgxIDw8IDE0KTtcblxuLy8gUHVibGljIGtleXMgaW4gc2NyaXB0cyBtdXN0IGJlIGNvbXByZXNzZWRcbi8vXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1dJVE5FU1NfUFVCS0VZVFlQRSA9ICgxIDw8IDE1KTtcblxuLy8gRG8gd2UgYWNjZXB0IHNpZ25hdHVyZSB1c2luZyBTSUdIQVNIX0ZPUktJRFxuLy9cbkludGVycHJldGVyLlNDUklQVF9FTkFCTEVfU0lHSEFTSF9GT1JLSUQgPSAoMSA8PCAxNik7XG5cbi8vIERvIHdlIGFjY2VwdCBhY3RpdmF0ZSByZXBsYXkgcHJvdGVjdGlvbiB1c2luZyBhIGRpZmZlcmVudCBmb3JrIGlkLlxuLy9cbkludGVycHJldGVyLlNDUklQVF9FTkFCTEVfUkVQTEFZX1BST1RFQ1RJT04gPSAoMSA8PCAxNyk7XG5cbi8vIE1ha2luZyBPUF9DT0RFU0VQQVJBVE9SIGFuZCBGaW5kQW5kRGVsZXRlIGZhaWwgYW55IG5vbi1zZWd3aXQgc2NyaXB0c1xuLy9cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ09OU1RfU0NSSVBUQ09ERSA9ICgxIDw8IDE2KTtcblxuLy8gVmVyaWZ5IHRhcHJvb3Qgc2NyaXB0IFxuLy9cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfVEFQUk9PVCA9ICgxIDw8IDE3KTtcblxuLy8gTWFraW5nIHVua25vd24gVGFwcm9vdCBsZWFmIHZlcnNpb25zIG5vbi1zdGFuZGFyZFxuLy9cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX1RBUFJPT1RfVkVSU0lPTiA9ICgxIDw8IDE4KTtcblxuLy8gTWFraW5nIHVua25vd24gT1BfU1VDQ0VTUyBub24tc3RhbmRhcmRcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9PUF9TVUNDRVNTID0gKDEgPDwgMTkpO1xuXG4vLyBNYWtpbmcgdW5rbm93biBwdWJsaWMga2V5IHZlcnNpb25zIChpbiBCSVAgMzQyIHNjcmlwdHMpIG5vbi1zdGFuZGFyZFxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfUFVCS0VZVFlQRSA9ICgxIDw8IDIwKTtcblxuXG5cbi8qIEJlbG93IGZsYWdzIGFwcGx5IGluIHRoZSBjb250ZXh0IG9mIEJJUCA2OCovXG4vKipcbiAqIElmIHRoaXMgZmxhZyBzZXQsIENUeEluOjpuU2VxdWVuY2UgaXMgTk9UIGludGVycHJldGVkIGFzIGEgcmVsYXRpdmVcbiAqIGxvY2stdGltZS5cbiAqL1xuSW50ZXJwcmV0ZXIuU0VRVUVOQ0VfTE9DS1RJTUVfRElTQUJMRV9GTEFHID0gKDEgPDwgMzEpO1xuXG4vKipcbiAqIElmIENUeEluOjpuU2VxdWVuY2UgZW5jb2RlcyBhIHJlbGF0aXZlIGxvY2stdGltZSBhbmQgdGhpcyBmbGFnIGlzIHNldCxcbiAqIHRoZSByZWxhdGl2ZSBsb2NrLXRpbWUgaGFzIHVuaXRzIG9mIDUxMiBzZWNvbmRzLCBvdGhlcndpc2UgaXQgc3BlY2lmaWVzXG4gKiBibG9ja3Mgd2l0aCBhIGdyYW51bGFyaXR5IG9mIDEuXG4gKi9cbkludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBRyA9ICgxIDw8IDIyKTtcblxuLyoqXG4gKiBJZiBDVHhJbjo6blNlcXVlbmNlIGVuY29kZXMgYSByZWxhdGl2ZSBsb2NrLXRpbWUsIHRoaXMgbWFzayBpcyBhcHBsaWVkIHRvXG4gKiBleHRyYWN0IHRoYXQgbG9jay10aW1lIGZyb20gdGhlIHNlcXVlbmNlIGZpZWxkLlxuICovXG5JbnRlcnByZXRlci5TRVFVRU5DRV9MT0NLVElNRV9NQVNLID0gMHgwMDAwZmZmZjtcblxuLyoqIFNpZ25hdHVyZSBoYXNoIHNpemVzICovXG5JbnRlcnByZXRlci5XSVRORVNTX1YwX1NDUklQVEhBU0hfU0laRSA9IDMyO1xuSW50ZXJwcmV0ZXIuV0lUTkVTU19WMF9LRVlIQVNIX1NJWkUgPSAyMDtcbkludGVycHJldGVyLldJVE5FU1NfVjFfVEFQUk9PVF9TSVpFID0gMzI7XG5cbkludGVycHJldGVyLlRBUFJPT1RfTEVBRl9NQVNLID0gMHhmZTtcbkludGVycHJldGVyLlRBUFJPT1RfTEVBRl9UQVBTQ1JJUFQgPSAweGMwO1xuSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX0JBU0VfU0laRSA9IDMzO1xuSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX05PREVfU0laRSA9IDMyO1xuSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX01BWF9OT0RFX0NPVU5UID0gMTI4O1xuSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX01BWF9TSVpFID0gSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX0JBU0VfU0laRSArIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9OT0RFX1NJWkUgKiBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfTUFYX05PREVfQ09VTlQ7XG5cbi8vIENvbmNlcHR1YWxseSwgdGhpcyBkb2Vzbid0IHJlYWxseSBiZWxvbmcgd2l0aCB0aGUgSW50ZXJwcmV0ZXIsIGJ1dCBJIGhhdmVuJ3QgZm91bmQgYSBiZXR0ZXIgcGxhY2UgZm9yIGl0LlxuSW50ZXJwcmV0ZXIuUFJPVE9DT0xfVkVSU0lPTiA9IDcwMDE2O1xuXG5JbnRlcnByZXRlci5jYXN0VG9Cb29sID0gZnVuY3Rpb24oYnVmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSAhPT0gMCkge1xuICAgICAgLy8gY2FuIGJlIG5lZ2F0aXZlIHplcm9cbiAgICAgIGlmIChpID09PSBidWYubGVuZ3RoIC0gMSAmJiBidWZbaV0gPT09IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlZCBmcm9tIGJpdGNvaW5kJ3MgQ2hlY2tTaWduYXR1cmVFbmNvZGluZ1xuICovXG5JbnRlcnByZXRlci5wcm90b3R5cGUuY2hlY2tTaWduYXR1cmVFbmNvZGluZyA9IGZ1bmN0aW9uKGJ1Zikge1xuICB2YXIgc2lnO1xuXG4gICAgLy8gRW1wdHkgc2lnbmF0dXJlLiBOb3Qgc3RyaWN0bHkgREVSIGVuY29kZWQsIGJ1dCBhbGxvd2VkIHRvIHByb3ZpZGUgYVxuICAgIC8vIGNvbXBhY3Qgd2F5IHRvIHByb3ZpZGUgYW4gaW52YWxpZCBzaWduYXR1cmUgZm9yIHVzZSB3aXRoIENIRUNLKE1VTFRJKVNJR1xuICAgIGlmIChidWYubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIGlmICgodGhpcy5mbGFncyAmIChJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RFUlNJRyB8IEludGVycHJldGVyLlNDUklQVF9WRVJJRllfTE9XX1MgfCBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1NUUklDVEVOQykpICE9PSAwICYmICFTaWduYXR1cmUuaXNUeERFUihidWYpKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TSUdfREVSX0lOVkFMSURfRk9STUFUJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0xPV19TKSAhPT0gMCkge1xuICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoYnVmKTtcbiAgICBpZiAoIXNpZy5oYXNMb3dTKCkpIHtcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX0RFUl9ISUdIX1MnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfU1RSSUNURU5DKSAhPT0gMCkge1xuICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoYnVmKTtcbiAgICBpZiAoIXNpZy5oYXNEZWZpbmVkSGFzaHR5cGUoKSkge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TSUdfSEFTSFRZUEUnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVkIGZyb20gYml0Y29pbmQncyBDaGVja1B1YktleUVuY29kaW5nXG4gKi9cbkludGVycHJldGVyLnByb3RvdHlwZS5jaGVja1B1YmtleUVuY29kaW5nID0gZnVuY3Rpb24oYnVmKSB7XG4gIGlmICgodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfU1RSSUNURU5DKSAhPT0gMCAmJiAhUHVibGljS2V5LmlzVmFsaWQoYnVmKSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfUFVCS0VZVFlQRSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gT25seSBjb21wcmVzc2VkIGtleXMgYXJlIGFjY2VwdGVkIGluIHNlZ3dpdFxuICBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1dJVE5FU1NfUFVCS0VZVFlQRSkgIT0gMCAmJiB0aGlzLnNpZ3ZlcnNpb24gPT0gU2lnbmF0dXJlLlZlcnNpb24uV0lUTkVTU19WMCAmJiAhUHVibGljS2V5LmZyb21CdWZmZXIoYnVmKS5jb21wcmVzc2VkKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX1BVQktFWVRZUEUnO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIFZlcmlmaWVzIEVDRFNBIHNpZ25hdHVyZVxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZyBcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgXG4gKiBAcGFyYW0ge051bWJlcn0gbmluIFxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdCBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYXRvc2hpcyBcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5JbnRlcnByZXRlci5wcm90b3R5cGUuY2hlY2tFY2RzYVNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZywgcHVia2V5LCBuaW4sIHN1YnNjcmlwdCwgc2F0b3NoaXMpIHtcbiAgdmFyIHN1YnNjcmlwdEJ1ZmZlciA9IHN1YnNjcmlwdC50b0J1ZmZlcigpO1xuICB2YXIgc2NyaXB0Q29kZVdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgc2NyaXB0Q29kZVdyaXRlci53cml0ZVZhcmludE51bShzdWJzY3JpcHRCdWZmZXIubGVuZ3RoKTtcbiAgc2NyaXB0Q29kZVdyaXRlci53cml0ZShzdWJzY3JpcHRCdWZmZXIpO1xuXG4gICQuY2hlY2tTdGF0ZShKU1V0aWwuaXNOYXR1cmFsTnVtYmVyKHNhdG9zaGlzKSk7XG4gIHZhciBzYXRvc2hpc0J1ZmZlciA9IG5ldyBCdWZmZXJXcml0ZXIoKS53cml0ZVVJbnQ2NExFQk4obmV3IEJOKHNhdG9zaGlzKSkudG9CdWZmZXIoKTtcblxuICB2YXIgdmVyaWZpZWQgPSBTaWdoYXNoV2l0bmVzcy52ZXJpZnkoXG4gICAgdGhpcyxcbiAgICBzaWcsXG4gICAgcHVia2V5LFxuICAgIG5pbixcbiAgICBzY3JpcHRDb2RlV3JpdGVyLnRvQnVmZmVyKCksXG4gICAgc2F0b3NoaXNCdWZmZXJcbiAgKTtcbiAgcmV0dXJuIHZlcmlmaWVkO1xufTtcblxuXG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZyBcbiAqIEBwYXJhbSB7UHVibGljS2V5fEJ1ZmZlcn0gcHVia2V5IFxuICogQHBhcmFtIHtOdW1iZXJ9IHNpZ3ZlcnNpb24gXG4gKiBAcGFyYW0ge09iamVjdH0gZXhlY2RhdGEgXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNoZWNrU2Nobm9yclNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZywgcHVia2V5LCBzaWd2ZXJzaW9uLCBleGVjZGF0YSkge1xuICAkLmNoZWNrQXJndW1lbnQoc2lnICYmIEJ1ZmZlci5pc0J1ZmZlcihzaWcpLCAnTWlzc2luZyBzaWcnKTtcbiAgJC5jaGVja0FyZ3VtZW50KHB1YmtleSAmJiBCdWZmZXIuaXNCdWZmZXIocHVia2V5KSwgJ01pc3NpbmcgcHVia2V5Jyk7XG4gICQuY2hlY2tBcmd1bWVudChzaWd2ZXJzaW9uLCAnTWlzc2luZyBzaWd2ZXJzaW9uJyk7XG4gICQuY2hlY2tBcmd1bWVudChleGVjZGF0YSwgJ01pc3NpbmcgZXhlY2RhdGEnKTtcblxuICAkLmNoZWNrQXJndW1lbnQocHVia2V5Lmxlbmd0aCA9PT0gMzIsICdTY2hub3JyIHNpZ25hdHVyZXMgaGF2ZSAzMi1ieXRlIHB1YmxpYyBrZXlzLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbmZvcmNpbmcgdGhpcy4nKTtcbiAgLy8gTm90ZSB0aGF0IGluIFRhcHNjcmlwdCBldmFsdWF0aW9uLCBlbXB0eSBzaWduYXR1cmVzIGFyZSB0cmVhdGVkIHNwZWNpYWxseSAoaW52YWxpZCBzaWduYXR1cmUgdGhhdCBkb2VzIG5vdFxuICAvLyBhYm9ydCBzY3JpcHQgZXhlY3V0aW9uKS4gVGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBFdmFsQ2hlY2tzaWdUYXBzY3JpcHQsIHdoaWNoIHdvbid0IGludm9rZVxuICAvLyBDaGVja1NjaG5vcnJTaWduYXR1cmUgaW4gdGhhdCBjYXNlLiBJbiBvdGhlciBjb250ZXh0cywgdGhleSBhcmUgaW52YWxpZCBsaWtlIGV2ZXJ5IG90aGVyIHNpZ25hdHVyZSB3aXRoXG4gIC8vIHNpemUgZGlmZmVyZW50IGZyb20gNjQgb3IgNjUuXG4gIGlmICghKHNpZy5sZW5ndGggPT09IDY0IHx8IHNpZy5sZW5ndGggPT09IDY1KSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0NITk9SUl9TSUdfU0laRSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHNpZy5sZW5ndGggPT09IDY1ICYmIHNpZ1tzaWcubGVuZ3RoIC0gMV0gPT09IFNpZ25hdHVyZS5TSUdIQVNIX0RFRkFVTFQpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NDSE5PUlJfU0lHX0hBU0hUWVBFJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2lnID0gU2lnbmF0dXJlLmZyb21TY2hub3JyKHNpZyk7XG4gIGNvbnN0IHZlcmlmaWVkID0gU2lnaGFzaFNjaG5vcnIudmVyaWZ5KFxuICAgIHRoaXMudHgsXG4gICAgc2lnLFxuICAgIHB1YmtleSxcbiAgICBzaWd2ZXJzaW9uLFxuICAgIHRoaXMubmluLFxuICAgIGV4ZWNkYXRhXG4gICk7XG4gIHJldHVybiB2ZXJpZmllZDtcbn07XG5cblxuLyoqXG4gKiBCYXNlZCBvbiBiaXRjb2luZCdzIEV2YWxDaGVja3NpZ1ByZVRhcHNjcmlwdCBmdW5jdGlvblxuICogYml0Y29pbmQgY29tbWl0OiBhMDk4ODE0MGI3MTQ4NWFkMTJjM2MzYTRhOTU3M2Y3YzIxYjFlZmY4XG4gKi9cbkludGVycHJldGVyLnByb3RvdHlwZS5fZXZhbENoZWNrc2lnUHJlVGFwc2NyaXB0ID0gZnVuY3Rpb24oYnVmU2lnLCBidWZQdWJrZXkpIHtcbiAgJC5jaGVja0FyZ3VtZW50KFxuICAgIHRoaXMuc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uQkFTRSB8fCB0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjAsXG4gICAgJ3NpZ3ZlcnNpb24gbXVzdCBiZSBiYXNlIG9yIHdpdG5lc3NfdjAnXG4gICk7XG5cbiAgLy8gU3VjY2VzcyBzaWduaWZpZXMgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAgLy8gUmVzdWx0IHNpZ25pZmllcyB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY2l0b24sIHdoaWNoIGFsc28gdGFrZXMgZmxhZ3MgaW50byBhY2NvdW50LlxuICBjb25zdCByZXRWYWwgPSB7IHN1Y2Nlc3M6IGZhbHNlLCByZXN1bHQ6IGZhbHNlIH07XG5cbiAgY29uc3Qgc3Vic2NyaXB0ID0gbmV3IFNjcmlwdCgpLnNldCh7XG4gICAgY2h1bmtzOiB0aGlzLnNjcmlwdC5jaHVua3Muc2xpY2UodGhpcy5wYmVnaW5jb2RlaGFzaClcbiAgfSk7XG5cbiAgLy8gRHJvcCB0aGUgc2lnbmF0dXJlIGluIHByZS1zZWd3aXQgc2NyaXB0cyBidXQgbm90IHNlZ3dpdCBzY3JpcHRzXG4gIGlmICh0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UpIHtcbiAgICAvLyBEcm9wIHRoZSBzaWduYXR1cmUsIHNpbmNlIHRoZXJlJ3Mgbm8gd2F5IGZvciBhIHNpZ25hdHVyZSB0byBzaWduIGl0c2VsZlxuICAgIGNvbnN0IHRtcFNjcmlwdCA9IG5ldyBTY3JpcHQoKS5hZGQoYnVmU2lnKTtcbiAgICBsZXQgZm91bmQgPSBzdWJzY3JpcHQuY2h1bmtzLmxlbmd0aDtcbiAgICBzdWJzY3JpcHQuZmluZEFuZERlbGV0ZSh0bXBTY3JpcHQpO1xuXG4gICAgZm91bmQgPSBmb3VuZCA9PSBzdWJzY3JpcHQuY2h1bmtzLmxlbmd0aCArIDE7IC8vIGZvdW5kIGlmIGEgY2h1bmsgd2FzIHJlbW92ZWRcbiAgICBpZiAoZm91bmQgJiYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NPTlNUX1NDUklQVENPREUpKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NJR19GSU5EQU5EREVMRVRFJztcbiAgICAgIHJldHVybiByZXRWYWw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLmNoZWNrU2lnbmF0dXJlRW5jb2RpbmcoYnVmU2lnKSB8fCAhdGhpcy5jaGVja1B1YmtleUVuY29kaW5nKGJ1ZlB1YmtleSkpIHtcbiAgICByZXR1cm4gcmV0VmFsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzaWcgPSBTaWduYXR1cmUuZnJvbVR4Rm9ybWF0KGJ1ZlNpZyk7XG4gICAgY29uc3QgcHVia2V5ID0gUHVibGljS2V5LmZyb21CdWZmZXIoYnVmUHVia2V5LCBmYWxzZSk7XG4gICAgcmV0VmFsLnN1Y2Nlc3MgPSB0aGlzLnR4LnZlcmlmeVNpZ25hdHVyZShzaWcsIHB1YmtleSwgdGhpcy5uaW4sIHN1YnNjcmlwdCwgdGhpcy5zaWd2ZXJzaW9uLCB0aGlzLnNhdG9zaGlzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vaW52YWxpZCBzaWcgb3IgcHVia2V5XG4gICAgcmV0VmFsLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghcmV0VmFsLnN1Y2Nlc3MgJiYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX05VTExGQUlMKSAmJiBidWZTaWcubGVuZ3RoKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TSUdfTlVMTEZBSUwnO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH1cbiAgXG4gIC8vIElmIGl0IHJlYWNoZXMgaGVyZSwgdGhlbiB0cnVlXG4gIHJldFZhbC5yZXN1bHQgPSB0cnVlO1xuICByZXR1cm4gcmV0VmFsO1xufTtcblxuXG4vKipcbiAqIEJhc2VkIG9uIGJpdGNvaW5kJ3MgRXZhbENoZWNrc2lnVGFwc2NyaXB0IGZ1bmN0aW9uXG4gKiBiaXRjb2luZCBjb21taXQ6IGEwOTg4MTQwYjcxNDg1YWQxMmMzYzNhNGE5NTczZjdjMjFiMWVmZjhcbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLl9ldmFsQ2hlY2tzaWdUYXBzY3JpcHQgPSBmdW5jdGlvbihidWZTaWcsIGJ1ZlB1YmtleSkge1xuICAkLmNoZWNrQXJndW1lbnQodGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVCwgJ3RoaXMuc2lndmVyc2lvbiBtdXN0IGJ5IFRBUFNDUklQVCcpO1xuXG4gIC8qXG4gICAgKiAgVGhlIGZvbGxvd2luZyB2YWxpZGF0aW9uIHNlcXVlbmNlIGlzIGNvbnNlbnN1cyBjcml0aWNhbC4gUGxlYXNlIG5vdGUgaG93IC0tXG4gICAgKiAgICB1cGdyYWRhYmxlIHB1YmxpYyBrZXkgdmVyc2lvbnMgcHJlY2VkZSBvdGhlciBydWxlcztcbiAgICAqICAgIHRoZSBzY3JpcHQgZXhlY3V0aW9uIGZhaWxzIHdoZW4gdXNpbmcgZW1wdHkgc2lnbmF0dXJlIHdpdGggaW52YWxpZCBwdWJsaWMga2V5O1xuICAgICogICAgdGhlIHNjcmlwdCBleGVjdXRpb24gZmFpbHMgd2hlbiB1c2luZyBub24tZW1wdHkgaW52YWxpZCBzaWduYXR1cmUuXG4gICAgKi9cblxuICAvLyBTdWNjZXNzIHNpZ25pZmllcyBpZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICAvLyBSZXN1bHQgc2lnbmlmaWVzIHRoZSByZXN1bHQgb2YgdGhpcyBmdW5jaXRvbiwgd2hpY2ggYWxzbyB0YWtlcyBmbGFncyBpbnRvIGFjY291bnQuXG4gIGNvbnN0IHJldFZhbCA9IHtcbiAgICBzdWNjZXNzOiBidWZTaWcubGVuZ3RoID4gMCxcbiAgICByZXN1bHQ6IGZhbHNlXG4gIH1cbiAgaWYgKHJldFZhbC5zdWNjZXNzKSB7XG4gICAgLy8gSW1wbGVtZW50IHRoZSBzaWdvcHMvd2l0bmVzc3NpemUgcmF0aW8gdGVzdC5cbiAgICAvLyBQYXNzaW5nIHdpdGggYW4gdXBncmFkYWJsZSBwdWJsaWMga2V5IHZlcnNpb24gaXMgYWxzbyBjb3VudGVkLlxuICAgICQuY2hlY2tTdGF0ZSh0aGlzLmV4ZWNkYXRhLnZhbGlkYXRpb25XZWlnaHRMZWZ0SW5pdCwgJ3ZhbGlkYXRpb25XZWlnaHRMZWZ0SW5pdCBpcyBmYWxzZScpO1xuICAgIHRoaXMuZXhlY2RhdGEudmFsaWRhdGlvbldlaWdodExlZnQgLT0gU2NyaXB0LlZBTElEQVRJT05fV0VJR0hUX1BFUl9TSUdPUF9QQVNTRUQ7XG4gICAgaWYgKHRoaXMuZXhlY2RhdGEudmFsaWRhdGlvbldlaWdodExlZnQgPCAwKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1RBUFNDUklQVF9WQUxJREFUSU9OX1dFSUdIVCc7XG4gICAgICByZXR1cm4gcmV0VmFsO1xuICAgIH1cbiAgfVxuICBpZiAoYnVmUHVia2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfUFVCS0VZVFlQRSc7XG4gICAgcmV0dXJuIHJldFZhbDtcbiAgfSBlbHNlIGlmIChidWZQdWJrZXkubGVuZ3RoID09IDMyKSB7XG4gICAgaWYgKHJldFZhbC5zdWNjZXNzICYmICF0aGlzLnR4LmNoZWNrU2Nobm9yclNpZ25hdHVyZShidWZTaWcsIGJ1ZlB1YmtleSwgdGhpcy5uaW4sIHRoaXMuc2lndmVyc2lvbiwgdGhpcy5leGVjZGF0YSkpIHtcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0NITk9SUl9TSUcnO1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLypcbiAgICAgICogIE5ldyBwdWJsaWMga2V5IHZlcnNpb24gc29mdGZvcmtzIHNob3VsZCBiZSBkZWZpbmVkIGJlZm9yZSB0aGlzIGBlbHNlYCBibG9jay5cbiAgICAgICogIEdlbmVyYWxseSwgdGhlIG5ldyBjb2RlIHNob3VsZCBub3QgZG8gYW55dGhpbmcgYnV0IGZhaWxpbmcgdGhlIHNjcmlwdCBleGVjdXRpb24uIFRvIGF2b2lkXG4gICAgICAqICBjb25zZW5zdXMgYnVncywgaXQgc2hvdWxkIG5vdCBtb2RpZnkgYW55IGV4aXN0aW5nIHZhbHVlcyAoaW5jbHVkaW5nIGBzdWNjZXNzYCkuXG4gICAgICAqL1xuICAgIGlmICgodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX1BVQktFWVRZUEUpICE9IDApIHtcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9VUEdSQURBQkxFX1BVQktFWVRZUEUnO1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBpdCByZWFjaGVzIGhlcmUsIHRoZW4gdHJ1ZVxuICByZXRWYWwucmVzdWx0ID0gdHJ1ZTtcbiAgcmV0dXJuIHJldFZhbDtcbn1cblxuLyoqXG4gKiBCYXNlZCBvbiBiaXRjb2luZCdzIEV2YWxDaGVja3NpZyBmdW5jdGlvblxuICogYml0Y29pbmQgY29tbWl0OiBhMDk4ODE0MGI3MTQ4NWFkMTJjM2MzYTRhOTU3M2Y3YzIxYjFlZmY4XG4gKiBAcmV0dXJucyB7eyBzdWNjZXNzOiBCb29sZWFuLCB2ZXJpZmllZDogQm9vbGVhbiB9fVxuICovXG5JbnRlcnByZXRlci5wcm90b3R5cGUuX2V2YWxDaGVja1NpZyA9IGZ1bmN0aW9uKGJ1ZlNpZywgYnVmUHVia2V5KSB7XG4gIHN3aXRjaCh0aGlzLnNpZ3ZlcnNpb24pIHtcbiAgICBjYXNlIFNpZ25hdHVyZS5WZXJzaW9uLkJBU0U6XG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwOlxuICAgICAgLy8gY29uc3QgdmVyaWZpZWQgPSB0aGlzLl9ldmFsQ2hlY2tzaWdQcmVUYXBzY3JpcHQoYnVmU2lnLCBidWZQdWJrZXkpO1xuICAgICAgLy8gcmV0dXJuIHsgc3VjY2VzczogdmVyaWZpZWQsIHZlcmlmaWVkIH07IC8vIFRoaXMgaXMgdG8ga2VlcCB0aGUgc2FtZSByZXR1cm4gZm9ybWF0IGFzIF9ldmFsQ2hlY2tTaWdUYXBzY3JpcHRcbiAgICAgIHJldHVybiB0aGlzLl9ldmFsQ2hlY2tzaWdQcmVUYXBzY3JpcHQoYnVmU2lnLCBidWZQdWJrZXkpO1xuICAgIGNhc2UgU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBUOlxuICAgICAgcmV0dXJuIHRoaXMuX2V2YWxDaGVja3NpZ1RhcHNjcmlwdChidWZTaWcsIGJ1ZlB1YmtleSk7XG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09UOlxuICAgICAgLy8gS2V5IHBhdGggc3BlbmRpbmcgaW4gVGFwcm9vdCBoYXMgbm8gc2NyaXB0LCBzbyB0aGlzIGlzIHVucmVhY2hhYmxlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsZWQgZXZhbENoZWNrU2lnIHdpdGggYSBUQVBST09UIHNpZ3ZlcnNpb24uIENoZWNrIHlvdXIgaW1wbGVtZW50YXRpb24nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlZCBvbiBiaXRjb2luZCdzIEV2YWxTY3JpcHQgZnVuY3Rpb24sIHdpdGggdGhlIGlubmVyIGxvb3AgbW92ZWQgdG9cbiAqIEludGVycHJldGVyLnByb3RvdHlwZS5zdGVwKClcbiAqIGJpdGNvaW5kIGNvbW1pdDogYjVkMWIxMDkyOTk4YmM5NTMxMzg1NmQ1MzVjNjMyZWE1YThmOTEwNFxuICovXG5JbnRlcnByZXRlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2lndmVyc2lvbiBjYW5ub3QgYmUgVEFQUk9PVCBoZXJlLCBhcyBpdCBhZG1pdHMgbm8gc2NyaXB0IGV4ZWN1dGlvbi5cbiAgJC5jaGVja0FyZ3VtZW50KHRoaXMuc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5CQVNFIHx8IHRoaXMuc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwIHx8IHRoaXMuc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQsICdpbnZhbGlkIHNpZ3ZlcnNpb24nKTtcblxuICBpZiAoXG4gICAgKHRoaXMuc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5CQVNFIHx8IHRoaXMuc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwKSAmJlxuICAgIHRoaXMuc2NyaXB0LnRvQnVmZmVyKCkubGVuZ3RoID4gSW50ZXJwcmV0ZXIuTUFYX1NDUklQVF9TSVpFXG4gICkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0NSSVBUX1NJWkUnO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgd2hpbGUgKHRoaXMucGMgPCB0aGlzLnNjcmlwdC5jaHVua3MubGVuZ3RoKSB7XG4gICAgICB2YXIgZlN1Y2Nlc3MgPSB0aGlzLnN0ZXAoKTtcbiAgICAgIGlmICghZlN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVU5LTk9XTl9FUlJPUjogJyArIGU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMudmZFeGVjLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1VOQkFMQU5DRURfQ09ORElUSU9OQUwnO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDaGVja3MgYSBsb2NrdGltZSBwYXJhbWV0ZXIgd2l0aCB0aGUgdHJhbnNhY3Rpb24ncyBsb2NrdGltZS5cbiAqIFRoZXJlIGFyZSB0d28gdGltZXMgb2YgbkxvY2tUaW1lOiBsb2NrLWJ5LWJsb2NraGVpZ2h0IGFuZCBsb2NrLWJ5LWJsb2NrdGltZSxcbiAqIGRpc3Rpbmd1aXNoZWQgYnkgd2hldGhlciBuTG9ja1RpbWUgPCBMT0NLVElNRV9USFJFU0hPTEQgPSA1MDAwMDAwMDBcbiAqXG4gKiBTZWUgdGhlIGNvcnJlc3BvbmRpbmcgY29kZSBvbiBiaXRjb2luIGNvcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2Jsb2IvZmZkNzVhZGNlMDFhNzhiMzQ2MWIzZmYwNWJjYzJiNTMwYTljZTk5NC9zcmMvc2NyaXB0L2ludGVycHJldGVyLmNwcCNMMTEyOVxuICpcbiAqIEBwYXJhbSB7Qk59IG5Mb2NrVGltZSB0aGUgbG9ja3RpbWUgcmVhZCBmcm9tIHRoZSBzY3JpcHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uJ3MgbG9ja3RpbWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gKiAgICAgICAgICAgICAgICAgICB0aGUgdHJhbnNhY3Rpb24ncyBsb2NrdGltZVxuICovXG5JbnRlcnByZXRlci5wcm90b3R5cGUuY2hlY2tMb2NrVGltZSA9IGZ1bmN0aW9uKG5Mb2NrVGltZSkge1xuXG4gIC8vIFdlIHdhbnQgdG8gY29tcGFyZSBhcHBsZXMgdG8gYXBwbGVzLCBzbyBmYWlsIHRoZSBzY3JpcHRcbiAgLy8gdW5sZXNzIHRoZSB0eXBlIG9mIG5Mb2NrVGltZSBiZWluZyB0ZXN0ZWQgaXMgdGhlIHNhbWUgYXNcbiAgLy8gdGhlIG5Mb2NrVGltZSBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gIGlmICghKFxuICAgICh0aGlzLnR4Lm5Mb2NrVGltZSA8ICBJbnRlcnByZXRlci5MT0NLVElNRV9USFJFU0hPTEQgJiYgbkxvY2tUaW1lLmx0KEludGVycHJldGVyLkxPQ0tUSU1FX1RIUkVTSE9MRF9CTikpIHx8XG4gICAgKHRoaXMudHgubkxvY2tUaW1lID49IEludGVycHJldGVyLkxPQ0tUSU1FX1RIUkVTSE9MRCAmJiBuTG9ja1RpbWUuZ3RlKEludGVycHJldGVyLkxPQ0tUSU1FX1RIUkVTSE9MRF9CTikpXG4gICkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBOb3cgdGhhdCB3ZSBrbm93IHdlJ3JlIGNvbXBhcmluZyBhcHBsZXMtdG8tYXBwbGVzLCB0aGVcbiAgLy8gY29tcGFyaXNvbiBpcyBhIHNpbXBsZSBudW1lcmljIG9uZS5cbiAgaWYgKG5Mb2NrVGltZS5ndChuZXcgQk4odGhpcy50eC5uTG9ja1RpbWUpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZpbmFsbHkgdGhlIG5Mb2NrVGltZSBmZWF0dXJlIGNhbiBiZSBkaXNhYmxlZCBhbmQgdGh1c1xuICAvLyBDSEVDS0xPQ0tUSU1FVkVSSUZZIGJ5cGFzc2VkIGlmIGV2ZXJ5IHR4aW4gaGFzIGJlZW5cbiAgLy8gZmluYWxpemVkIGJ5IHNldHRpbmcgblNlcXVlbmNlIHRvIG1heGludC4gVGhlXG4gIC8vIHRyYW5zYWN0aW9uIHdvdWxkIGJlIGFsbG93ZWQgaW50byB0aGUgYmxvY2tjaGFpbiwgbWFraW5nXG4gIC8vIHRoZSBvcGNvZGUgaW5lZmZlY3RpdmUuXG4gIC8vXG4gIC8vIFRlc3RpbmcgaWYgdGhpcyB2aW4gaXMgbm90IGZpbmFsIGlzIHN1ZmZpY2llbnQgdG9cbiAgLy8gcHJldmVudCB0aGlzIGNvbmRpdGlvbi4gQWx0ZXJuYXRpdmVseSB3ZSBjb3VsZCB0ZXN0IGFsbFxuICAvLyBpbnB1dHMsIGJ1dCB0ZXN0aW5nIGp1c3QgdGhpcyBpbnB1dCBtaW5pbWl6ZXMgdGhlIGRhdGFcbiAgLy8gcmVxdWlyZWQgdG8gcHJvdmUgY29ycmVjdCBDSEVDS0xPQ0tUSU1FVkVSSUZZIGV4ZWN1dGlvbi5cbiAgaWYgKCF0aGlzLnR4LmlucHV0c1t0aGlzLm5pbl0uaXNGaW5hbCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqXG4gKiBDaGVja3MgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgd2l0aCB0aGUgdHJhbnNhY3Rpb24ncyBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7Qk59IG5TZXF1ZW5jZSB0aGUgc2VxdWVuY2UgcmVhZCBmcm9tIHRoZSBzY3JpcHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uJ3Mgc2VxdWVuY2UgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gKiAgICAgICAgICAgICAgICAgICB0aGUgdHJhbnNhY3Rpb24ncyBzZXF1ZW5jZSBcbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNoZWNrU2VxdWVuY2UgPSBmdW5jdGlvbihuU2VxdWVuY2UpIHtcblxuICAvLyBSZWxhdGl2ZSBsb2NrIHRpbWVzIGFyZSBzdXBwb3J0ZWQgYnkgY29tcGFyaW5nIHRoZSBwYXNzZWQgaW4gb3BlcmFuZCB0b1xuICAvLyB0aGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBpbnB1dC5cbiAgdmFyIHR4VG9TZXF1ZW5jZSA9IHRoaXMudHguaW5wdXRzW3RoaXMubmluXS5zZXF1ZW5jZU51bWJlcjtcblxuICAvLyBGYWlsIGlmIHRoZSB0cmFuc2FjdGlvbidzIHZlcnNpb24gbnVtYmVyIGlzIG5vdCBzZXQgaGlnaCBlbm91Z2ggdG9cbiAgLy8gdHJpZ2dlciBCSVAgNjggcnVsZXMuXG4gIGlmICh0aGlzLnR4LnZlcnNpb24gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gU2VxdWVuY2UgbnVtYmVycyB3aXRoIHRoZWlyIG1vc3Qgc2lnbmlmaWNhbnQgYml0IHNldCBhcmUgbm90IGNvbnNlbnN1c1xuICAvLyBjb25zdHJhaW5lZC4gVGVzdGluZyB0aGF0IHRoZSB0cmFuc2FjdGlvbidzIHNlcXVlbmNlIG51bWJlciBkbyBub3QgaGF2ZVxuICAvLyB0aGlzIGJpdCBzZXQgcHJldmVudHMgdXNpbmcgdGhpcyBwcm9wZXJ0eSB0byBnZXQgYXJvdW5kIGFcbiAgLy8gQ0hFQ0tTRVFVRU5DRVZFUklGWSBjaGVjay5cbiAgaWYgKHR4VG9TZXF1ZW5jZSAmIFNFUVVFTkNFX0xPQ0tUSU1FX0RJU0FCTEVfRkxBRykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE1hc2sgb2ZmIGFueSBiaXRzIHRoYXQgZG8gbm90IGhhdmUgY29uc2Vuc3VzLWVuZm9yY2VkIG1lYW5pbmcgYmVmb3JlXG4gIC8vIGRvaW5nIHRoZSBpbnRlZ2VyIGNvbXBhcmlzb25zXG4gIHZhciBuTG9ja1RpbWVNYXNrID1cbiAgICAgIEludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBRyB8IEludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX01BU0s7XG4gIHZhciB0eFRvU2VxdWVuY2VNYXNrZWQgPSBuZXcgQk4odHhUb1NlcXVlbmNlICYgbkxvY2tUaW1lTWFzayk7XG4gIHZhciBuU2VxdWVuY2VNYXNrZWQgPSBuU2VxdWVuY2UuYW5kKG5Mb2NrVGltZU1hc2spO1xuXG4gIC8vIFRoZXJlIGFyZSB0d28ga2luZHMgb2YgblNlcXVlbmNlOiBsb2NrLWJ5LWJsb2NraGVpZ2h0IGFuZFxuICAvLyBsb2NrLWJ5LWJsb2NrdGltZSwgZGlzdGluZ3Vpc2hlZCBieSB3aGV0aGVyIG5TZXF1ZW5jZU1hc2tlZCA8XG4gIC8vIENUeEluOjpTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcuXG4gIC8vXG4gIC8vIFdlIHdhbnQgdG8gY29tcGFyZSBhcHBsZXMgdG8gYXBwbGVzLCBzbyBmYWlsIHRoZSBzY3JpcHQgdW5sZXNzIHRoZSB0eXBlXG4gIC8vIG9mIG5TZXF1ZW5jZU1hc2tlZCBiZWluZyB0ZXN0ZWQgaXMgdGhlIHNhbWUgYXMgdGhlIG5TZXF1ZW5jZU1hc2tlZCBpbiB0aGVcbiAgLy8gdHJhbnNhY3Rpb24uXG4gIHZhciBTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUdfQk4gPSBuZXcgQk4oSW50ZXJwcmV0ZXIuU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHKTtcbiAgXG4gIGlmICghKCh0eFRvU2VxdWVuY2VNYXNrZWQubHQoU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOKSAgJiZcbiAgICAgICAgICBuU2VxdWVuY2VNYXNrZWQubHQoU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOKSkgfHxcbiAgICAgICAgKHR4VG9TZXF1ZW5jZU1hc2tlZC5ndGUoU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOKSAmJlxuICAgICAgICAgIG5TZXF1ZW5jZU1hc2tlZC5ndGUoU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOKSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTm93IHRoYXQgd2Uga25vdyB3ZSdyZSBjb21wYXJpbmcgYXBwbGVzLXRvLWFwcGxlcywgdGhlIGNvbXBhcmlzb24gaXMgYVxuICAvLyBzaW1wbGUgbnVtZXJpYyBvbmUuXG4gIHJldHVybiBuU2VxdWVuY2VNYXNrZWQubHRlKHR4VG9TZXF1ZW5jZU1hc2tlZClcbn1cblxuXG5JbnRlcnByZXRlci5jb21wdXRlVGFwbGVhZkhhc2ggPSBmdW5jdGlvbihsZWFmVmVyc2lvbiwgc2NyaXB0QnVmKSB7XG4gIGNvbnN0IHRhZ1dyaXRlciA9IFRhZ2dlZEhhc2guVEFQTEVBRjtcbiAgdGFnV3JpdGVyLndyaXRlVUludDgobGVhZlZlcnNpb24pO1xuICB0YWdXcml0ZXIud3JpdGVWYXJpbnROdW0oc2NyaXB0QnVmLmxlbmd0aCk7XG4gIHRhZ1dyaXRlci53cml0ZShzY3JpcHRCdWYpO1xuICByZXR1cm4gdGFnV3JpdGVyLmZpbmFsaXplKCk7XG59O1xuXG5cbkludGVycHJldGVyLmNvbXB1dGVUYXByb290TWVya2xlUm9vdCA9IGZ1bmN0aW9uKGNvbnRyb2wsIHRhcGxlYWZIYXNoKSB7XG4gIGNvbnN0IHBhdGhMZW4gPSAoY29udHJvbC5sZW5ndGggLSBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfQkFTRV9TSVpFKSAvIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9OT0RFX1NJWkU7XG4gIGxldCBrID0gdGFwbGVhZkhhc2g7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aExlbjsgKytpKSB7XG4gICAgY29uc3QgdGFnV3JpdGVyID0gVGFnZ2VkSGFzaC5UQVBCUkFOQ0g7XG4gICAgY29uc3Qgc3RhcnQgPSBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfQkFTRV9TSVpFICsgSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX05PREVfU0laRSAqIGk7XG4gICAgY29uc3Qgbm9kZSA9IGNvbnRyb2wuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX05PREVfU0laRSk7XG4gICAgaWYgKEJ1ZmZlci5jb21wYXJlKGssIG5vZGUpID09PSAtMSkge1xuICAgICAgdGFnV3JpdGVyLndyaXRlKGspO1xuICAgICAgdGFnV3JpdGVyLndyaXRlKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdXcml0ZXIud3JpdGUobm9kZSk7XG4gICAgICB0YWdXcml0ZXIud3JpdGUoayk7XG4gICAgfVxuICAgIGsgPSB0YWdXcml0ZXIuZmluYWxpemUoKTtcbiAgfVxuICByZXR1cm4gaztcbn07XG5cblxuSW50ZXJwcmV0ZXIudmVyaWZ5VGFwcm9vdENvbW1pdG1lbnQgPSBmdW5jdGlvbihjb250cm9sLCBwcm9ncmFtLCB0YXBsZWFmSGFzaCkge1xuICAkLmNoZWNrQXJndW1lbnQoY29udHJvbC5sZW5ndGggPj0gSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX0JBU0VfU0laRSwgJ2NvbnRyb2wgdG9vIHNob3J0Jyk7XG4gICQuY2hlY2tBcmd1bWVudChwcm9ncmFtLmxlbmd0aCA+PSAzMiwgJ3Byb2dyYW0gaXMgdG9vIHNob3J0Jyk7XG5cbiAgdHJ5IHtcbiAgICAvLyEgVGhlIGludGVybmFsIHB1YmtleSAoeC1vbmx5LCBzbyBubyBZIGNvb3JkaW5hdGUgcGFyaXR5KS5cbiAgICBjb25zdCBwID0gUHVibGljS2V5LmZyb21YKGZhbHNlLCBjb250cm9sLnNsaWNlKDEsIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9CQVNFX1NJWkUpKTtcbiAgICAvLyEgVGhlIG91dHB1dCBwdWJrZXkgKHRha2VuIGZyb20gdGhlIHNjcmlwdFB1YktleSkuXG4gICAgY29uc3QgcSA9IFB1YmxpY0tleS5mcm9tWChmYWxzZSwgcHJvZ3JhbSk7XG4gICAgLy8gQ29tcHV0ZSB0aGUgTWVya2xlIHJvb3QgZnJvbSB0aGUgbGVhZiBhbmQgdGhlIHByb3ZpZGVkIHBhdGguXG4gICAgY29uc3QgbWVya2xlUm9vdCA9IEludGVycHJldGVyLmNvbXB1dGVUYXByb290TWVya2xlUm9vdChjb250cm9sLCB0YXBsZWFmSGFzaCk7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIG91dHB1dCBwdWJrZXkgbWF0Y2hlcyB0aGUgdHdlYWtlZCBpbnRlcm5hbCBwdWJrZXksIGFmdGVyIGNvcnJlY3RpbmcgZm9yIHBhcml0eS5cbiAgICByZXR1cm4gcS5jaGVja1RhcFR3ZWFrKHAsIG1lcmtsZVJvb3QsIGNvbnRyb2wpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cblxuLyoqIFxuICogQmFzZWQgb24gdGhlIGlubmVyIGxvb3Agb2YgYml0Y29pbmQncyBFdmFsU2NyaXB0IGZ1bmN0aW9uXG4gKiBiaXRjb2luZCBjb21taXQ6IGI1ZDFiMTA5Mjk5OGJjOTUzMTM4NTZkNTM1YzYzMmVhNWE4ZjkxMDRcbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZSZXF1aXJlTWluaW1hbCA9ICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9NSU5JTUFMREFUQSkgIT09IDA7XG5cbiAgLy9ib29sIGZFeGVjID0gIWNvdW50KHZmRXhlYy5iZWdpbigpLCB2ZkV4ZWMuZW5kKCksIGZhbHNlKTtcbiAgdmFyIGZFeGVjID0gKHRoaXMudmZFeGVjLmluZGV4T2YoZmFsc2UpID09PSAtMSk7XG4gIHZhciBidWYsIGJ1ZjEsIGJ1ZjIsIHNwbGljZWQsIG4sIHgxLCB4MiwgYm4sIGJuMSwgYm4yLCBidWZTaWcsIGJ1ZlB1YmtleSwgc3Vic2NyaXB0O1xuICB2YXIgc2lnLCBwdWJrZXk7XG4gIHZhciBmVmFsdWUsIGZTdWNjZXNzO1xuICB0aGlzLmV4ZWNkYXRhID0gdGhpcy5leGVjZGF0YSB8fCB7fTtcbiAgaWYgKCF0aGlzLmV4ZWNkYXRhLmNvZGVzZXBhcmF0b3JQb3NJbml0KSB7XG4gICAgdGhpcy5leGVjZGF0YS5jb2Rlc2VwYXJhdG9yUG9zID0gbmV3IEJOKDB4RkZGRkZGRkYpO1xuICAgIHRoaXMuZXhlY2RhdGEuY29kZXNlcGFyYXRvclBvc0luaXQgPSB0cnVlO1xuICB9XG5cbiAgLy8gUmVhZCBpbnN0cnVjdGlvblxuICB2YXIgY2h1bmsgPSB0aGlzLnNjcmlwdC5jaHVua3NbdGhpcy5wY107XG4gIHRoaXMucGMrKztcbiAgdmFyIG9wY29kZW51bSA9IGNodW5rLm9wY29kZW51bTtcbiAgaWYgKF8uaXNVbmRlZmluZWQob3Bjb2RlbnVtKSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVU5ERUZJTkVEX09QQ09ERSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjaHVuay5idWYgJiYgY2h1bmsuYnVmLmxlbmd0aCA+IEludGVycHJldGVyLk1BWF9TQ1JJUFRfRUxFTUVOVF9TSVpFKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9QVVNIX1NJWkUnO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UgfHwgdGhpcy5zaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwKSB7XG4gICAgLy8gTm90ZSBob3cgT3Bjb2RlLk9QX1JFU0VSVkVEIGRvZXMgbm90IGNvdW50IHRvd2FyZHMgdGhlIG9wY29kZSBsaW1pdC5cbiAgICBpZiAob3Bjb2RlbnVtID4gT3Bjb2RlLk9QXzE2ICYmICsrKHRoaXMubk9wQ291bnQpID4gMjAxKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX09QX0NPVU5UJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuXG4gIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9DQVQgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9TVUJTVFIgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9MRUZUIHx8XG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUklHSFQgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9JTlZFUlQgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9BTkQgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9PUiB8fFxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1hPUiB8fFxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QXzJNVUwgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF8yRElWIHx8XG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfTVVMIHx8XG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfRElWIHx8XG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfTU9EIHx8XG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfTFNISUZUIHx8XG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUlNISUZUKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9ESVNBQkxFRF9PUENPREUnO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFdpdGggU0NSSVBUX1ZFUklGWV9DT05TVF9TQ1JJUFRDT0RFLCBPUF9DT0RFU0VQQVJBVE9SIGluIG5vbi1zZWd3aXQgc2NyaXB0IGlzIHJlamVjdGVkIGV2ZW4gaW4gYW4gdW5leGVjdXRlZCBicmFuY2hcbiAgaWYgKG9wY29kZW51bSA9PSBPcGNvZGUuT1BfQ09ERVNFUEFSQVRPUiAmJiB0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UgJiYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NPTlNUX1NDUklQVENPREUpKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9PUF9DT0RFU0VQQVJBVE9SJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZkV4ZWMgJiYgMCA8PSBvcGNvZGVudW0gJiYgb3Bjb2RlbnVtIDw9IE9wY29kZS5PUF9QVVNIREFUQTQpIHtcbiAgICBpZiAoZlJlcXVpcmVNaW5pbWFsICYmICF0aGlzLnNjcmlwdC5jaGVja01pbmltYWxQdXNoKHRoaXMucGMgLSAxKSkge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9NSU5JTUFMREFUQSc7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY2h1bmsuYnVmKSB7XG4gICAgICB0aGlzLnN0YWNrLnB1c2goSW50ZXJwcmV0ZXIuZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoY2h1bmsubGVuICE9PSBjaHVuay5idWYubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBvZiBwdXNoIHZhbHVlIG5vdCBlcXVhbCB0byBsZW5ndGggb2YgZGF0YScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YWNrLnB1c2goY2h1bmsuYnVmKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZkV4ZWMgfHwgKE9wY29kZS5PUF9JRiA8PSBvcGNvZGVudW0gJiYgb3Bjb2RlbnVtIDw9IE9wY29kZS5PUF9FTkRJRikpIHtcbiAgICBzd2l0Y2ggKG9wY29kZW51bSkge1xuICAgICAgLy8gUHVzaCB2YWx1ZVxuICAgICAgY2FzZSBPcGNvZGUuT1BfMU5FR0FURTpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzE6XG4gICAgICBjYXNlIE9wY29kZS5PUF8yOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfMzpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzQ6XG4gICAgICBjYXNlIE9wY29kZS5PUF81OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfNjpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzc6XG4gICAgICBjYXNlIE9wY29kZS5PUF84OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfOTpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzEwOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfMTE6XG4gICAgICBjYXNlIE9wY29kZS5PUF8xMjpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzEzOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfMTQ6XG4gICAgICBjYXNlIE9wY29kZS5PUF8xNTpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzE2OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKCAtLSB2YWx1ZSlcbiAgICAgICAgICAvLyBTY3JpcHROdW0gYm4oKGludClvcGNvZGUgLSAoaW50KShPcGNvZGUuT1BfMSAtIDEpKTtcbiAgICAgICAgICBuID0gb3Bjb2RlbnVtIC0gKE9wY29kZS5PUF8xIC0gMSk7XG4gICAgICAgICAgYnVmID0gbmV3IEJOKG4pLnRvU2NyaXB0TnVtQnVmZmVyKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1Zik7XG4gICAgICAgICAgLy8gVGhlIHJlc3VsdCBvZiB0aGVzZSBvcGNvZGVzIHNob3VsZCBhbHdheXMgYmUgdGhlIG1pbmltYWwgd2F5IHRvIHB1c2ggdGhlIGRhdGFcbiAgICAgICAgICAvLyB0aGV5IHB1c2gsIHNvIG5vIG5lZWQgZm9yIGEgQ2hlY2tNaW5pbWFsUHVzaCBoZXJlLlxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQ29udHJvbFxuICAgICAgICAvL1xuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9QOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9QMjpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0NIRUNLTE9DS1RJTUVWRVJJRlk6XG5cbiAgICAgICAgaWYgKCEodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ0hFQ0tMT0NLVElNRVZFUklGWSkpIHtcbiAgICAgICAgICAvLyBub3QgZW5hYmxlZDsgdHJlYXQgYXMgYSBOT1AyXG4gICAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9OT1BTKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9OT1BTJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGVsc2V3aGVyZSBudW1lcmljIG9wY29kZXMgYXJlIGxpbWl0ZWQgdG9cbiAgICAgICAgLy8gb3BlcmFuZHMgaW4gdGhlIHJhbmdlIC0yKiozMSsxIHRvIDIqKjMxLTEsIGhvd2V2ZXIgaXQgaXNcbiAgICAgICAgLy8gbGVnYWwgZm9yIG9wY29kZXMgdG8gcHJvZHVjZSByZXN1bHRzIGV4Y2VlZGluZyB0aGF0XG4gICAgICAgIC8vIHJhbmdlLiBUaGlzIGxpbWl0YXRpb24gaXMgaW1wbGVtZW50ZWQgYnkgQ1NjcmlwdE51bSdzXG4gICAgICAgIC8vIGRlZmF1bHQgNC1ieXRlIGxpbWl0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB3ZSBrZXB0IHRvIHRoYXQgbGltaXQgd2UnZCBoYXZlIGEgeWVhciAyMDM4IHByb2JsZW0sXG4gICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZSBuTG9ja1RpbWUgZmllbGQgaW4gdHJhbnNhY3Rpb25zXG4gICAgICAgIC8vIHRoZW1zZWx2ZXMgaXMgdWludDMyIHdoaWNoIG9ubHkgYmVjb21lcyBtZWFuaW5nbGVzc1xuICAgICAgICAvLyBhZnRlciB0aGUgeWVhciAyMTA2LlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaHVzIGFzIGEgc3BlY2lhbCBjYXNlIHdlIHRlbGwgQ1NjcmlwdE51bSB0byBhY2NlcHQgdXBcbiAgICAgICAgLy8gdG8gNS1ieXRlIGJpZ251bXMsIHdoaWNoIGFyZSBnb29kIHVudGlsIDIqKjM5LTEsIHdlbGxcbiAgICAgICAgLy8gYmV5b25kIHRoZSAyKiozMi0xIGxpbWl0IG9mIHRoZSBuTG9ja1RpbWUgZmllbGQgaXRzZWxmLlxuICAgICAgICB2YXIgbkxvY2tUaW1lID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0sIGZSZXF1aXJlTWluaW1hbCwgNSk7XG5cbiAgICAgICAgLy8gSW4gdGhlIHJhcmUgZXZlbnQgdGhhdCB0aGUgYXJndW1lbnQgbWF5IGJlIDwgMCBkdWUgdG9cbiAgICAgICAgLy8gc29tZSBhcml0aG1ldGljIGJlaW5nIGRvbmUgZmlyc3QsIHlvdSBjYW4gYWx3YXlzIHVzZVxuICAgICAgICAvLyAwIE1BWCBDSEVDS0xPQ0tUSU1FVkVSSUZZLlxuICAgICAgICBpZiAobkxvY2tUaW1lLmx0KG5ldyBCTigwKSkpIHtcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX05FR0FUSVZFX0xPQ0tUSU1FJztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3R1YWxseSBjb21wYXJlIHRoZSBzcGVjaWZpZWQgbG9jayB0aW1lIHdpdGggdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tMb2NrVGltZShuTG9ja1RpbWUpKSB7XG4gICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9VTlNBVElTRklFRF9MT0NLVElNRSc7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1AzOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tTRVFVRU5DRVZFUklGWTpcblxuICAgICAgICBpZiAoISh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9DSEVDS1NFUVVFTkNFVkVSSUZZKSkge1xuICAgICAgICAgIC8vIG5vdCBlbmFibGVkOyB0cmVhdCBhcyBhIE5PUDNcbiAgICAgICAgICBpZiAodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX05PUFMpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9VUEdSQURBQkxFX05PUFMnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIG5TZXF1ZW5jZSwgbGlrZSBuTG9ja1RpbWUsIGlzIGEgMzItYml0IHVuc2lnbmVkXG4gICAgICAgIC8vIGludGVnZXIgZmllbGQuIFNlZSB0aGUgY29tbWVudCBpbiBDSEVDS0xPQ0tUSU1FVkVSSUZZXG4gICAgICAgIC8vIHJlZ2FyZGluZyA1LWJ5dGUgbnVtZXJpYyBvcGVyYW5kcy5cblxuICAgICAgICB2YXIgblNlcXVlbmNlID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0sIGZSZXF1aXJlTWluaW1hbCwgNSk7XG5cblxuICAgICAgICAvLyBJbiB0aGUgcmFyZSBldmVudCB0aGF0IHRoZSBhcmd1bWVudCBtYXkgYmUgPCAwIGR1ZSB0b1xuICAgICAgICAvLyBzb21lIGFyaXRobWV0aWMgYmVpbmcgZG9uZSBmaXJzdCwgeW91IGNhbiBhbHdheXMgdXNlXG4gICAgICAgIC8vIDAgTUFYIENIRUNLU0VRVUVOQ0VWRVJJRlkuXG4gICAgICAgIGlmIChuU2VxdWVuY2UubHQobmV3IEJOKDApKSkge1xuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfTkVHQVRJVkVfTE9DS1RJTUUnO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvIHByb3ZpZGUgZm9yIGZ1dHVyZSBzb2Z0LWZvcmsgZXh0ZW5zaWJpbGl0eSwgaWYgdGhlXG4gICAgICAgIC8vIG9wZXJhbmQgaGFzIHRoZSBkaXNhYmxlZCBsb2NrLXRpbWUgZmxhZyBzZXQsXG4gICAgICAgIC8vIENIRUNLU0VRVUVOQ0VWRVJJRlkgYmVoYXZlcyBhcyBhIE5PUC5cbiAgICAgICAgaWYgKChuU2VxdWVuY2UgJlxuICAgICAgICAgIEludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX0RJU0FCTEVfRkxBRykgIT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWN0dWFsbHkgY29tcGFyZSB0aGUgc3BlY2lmaWVkIGxvY2sgdGltZSB3aXRoIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrU2VxdWVuY2UoblNlcXVlbmNlKSkge1xuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVU5TQVRJU0ZJRURfTE9DS1RJTUUnO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuXG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05PUDE6XG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A0OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9QNTpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05PUDY6XG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A3OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9QODpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05PUDk6XG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1AxMDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfTk9QUykge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9ESVNDT1VSQUdFX1VQR1JBREFCTEVfTk9QUyc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9JRjpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05PVElGOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gPGV4cHJlc3Npb24+IGlmIFtzdGF0ZW1lbnRzXSBbZWxzZSBbc3RhdGVtZW50c11dIGVuZGlmXG4gICAgICAgICAgLy8gYm9vbCBmVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBmVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZkV4ZWMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9VTkJBTEFOQ0VEX0NPTkRJVElPTkFMJztcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIC8vIFRhcHNjcmlwdCByZXF1aXJlcyBtaW5pbWFsIElGL05PVElGIGlucHV0cyBhcyBhIGNvbnNlbnN1cyBydWxlLlxuICAgICAgICAgICAgaWYgKHRoaXMuc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBUKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBpbnB1dCBhcmd1bWVudCB0byB0aGUgT1BfSUYgYW5kIE9QX05PVElGIG9wY29kZXMgbXVzdCBiZSBlaXRoZXJcbiAgICAgICAgICAgICAgLy8gZXhhY3RseSAwICh0aGUgZW1wdHkgdmVjdG9yKSBvciBleGFjdGx5IDEgKHRoZSBvbmUtYnl0ZSB2ZWN0b3Igd2l0aCB2YWx1ZSAxKS5cbiAgICAgICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPiAxIHx8IChidWYubGVuZ3RoID09PSAxICYmIGJ1ZlswXSAhPT0gMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1RBUFNDUklQVF9NSU5JTUFMSUYnO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5kZXIgd2l0bmVzcyB2MCBydWxlcyBpdCBpcyBvbmx5IGEgcG9saWN5IHJ1bGUsIGVuYWJsZWQgdGhyb3VnaCBTQ1JJUFRfVkVSSUZZX01JTklNQUxJRi5cbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjAgJiYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX01JTklNQUxJRikpIHtcbiAgICAgICAgICAgICAgYnVmID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX01JTklNQUxJRic7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChidWYubGVuZ3RoID09IDEgJiYgYnVmWzBdIT0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9NSU5JTUFMSUYnO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZlZhbHVlID0gSW50ZXJwcmV0ZXIuY2FzdFRvQm9vbChidWYpO1xuICAgICAgICAgICAgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX05PVElGKSB7XG4gICAgICAgICAgICAgIGZWYWx1ZSA9ICFmVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZmRXhlYy5wdXNoKGZWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0VMU0U6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGhpcy52ZkV4ZWMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1VOQkFMQU5DRURfQ09ORElUSU9OQUwnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZmRXhlY1t0aGlzLnZmRXhlYy5sZW5ndGggLSAxXSA9ICF0aGlzLnZmRXhlY1t0aGlzLnZmRXhlYy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfRU5ESUY6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGhpcy52ZkV4ZWMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1VOQkFMQU5DRURfQ09ORElUSU9OQUwnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZmRXhlYy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfVkVSSUZZOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHRydWUgLS0gKSBvclxuICAgICAgICAgIC8vIChmYWxzZSAtLSBmYWxzZSkgYW5kIHJldHVyblxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgZlZhbHVlID0gSW50ZXJwcmV0ZXIuY2FzdFRvQm9vbChidWYpO1xuICAgICAgICAgIGlmIChmVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVkVSSUZZJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1JFVFVSTjpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfT1BfUkVUVVJOJztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBTdGFjayBvcHNcbiAgICAgICAgLy9cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1RPQUxUU1RBQ0s6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hbHRzdGFjay5wdXNoKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9GUk9NQUxUU1RBQ0s6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGhpcy5hbHRzdGFjay5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfQUxUU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuYWx0c3RhY2sucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF8yRFJPUDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4MSB4MiAtLSApXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfMkRVUDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4MSB4MiAtLSB4MSB4MiB4MSB4MilcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmMSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgICBidWYyID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYxKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmMik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzNEVVA6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgeDMgLS0geDEgeDIgeDMgeDEgeDIgeDMpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZjEgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gM107XG4gICAgICAgICAgYnVmMiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgICB2YXIgYnVmMyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmMSk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1ZjIpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfMk9WRVI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgeDMgeDQgLS0geDEgeDIgeDMgeDQgeDEgeDIpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZjEgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gNF07XG4gICAgICAgICAgYnVmMiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAzXTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmMSk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1ZjIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF8yUk9UOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHgxIHgyIHgzIHg0IHg1IHg2IC0tIHgzIHg0IHg1IHg2IHgxIHgyKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGxpY2VkID0gdGhpcy5zdGFjay5zcGxpY2UodGhpcy5zdGFjay5sZW5ndGggLSA2LCAyKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goc3BsaWNlZFswXSk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHNwbGljZWRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF8yU1dBUDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4MSB4MiB4MyB4NCAtLSB4MyB4NCB4MSB4MilcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BsaWNlZCA9IHRoaXMuc3RhY2suc3BsaWNlKHRoaXMuc3RhY2subGVuZ3RoIC0gNCwgMik7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHNwbGljZWRbMF0pO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChzcGxpY2VkWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfSUZEVVA6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeCAtIDAgfCB4IHgpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICBmVmFsdWUgPSBJbnRlcnByZXRlci5jYXN0VG9Cb29sKGJ1Zik7XG4gICAgICAgICAgaWYgKGZWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1Zik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9ERVBUSDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIC0tIHN0YWNrc2l6ZVxuICAgICAgICAgIGJ1ZiA9IG5ldyBCTih0aGlzLnN0YWNrLmxlbmd0aCkudG9TY3JpcHROdW1CdWZmZXIoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfRFJPUDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4IC0tIClcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfRFVQOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHggLS0geCB4KVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfTklQOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHgxIHgyIC0tIHgyKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSh0aGlzLnN0YWNrLmxlbmd0aCAtIDIsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9PVkVSOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHgxIHgyIC0tIHgxIHgyIHgxKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfUElDSzpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1JPTEw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeG4gLi4uIHgyIHgxIHgwIG4gLSB4biAuLi4geDIgeDEgeDAgeG4pXG4gICAgICAgICAgLy8gKHhuIC4uLiB4MiB4MSB4MCBuIC0gLi4uIHgyIHgxIHgwIHhuKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgYm4gPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKGJ1ZiwgZlJlcXVpcmVNaW5pbWFsKTtcbiAgICAgICAgICBuID0gYm4udG9OdW1iZXIoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIG4gLSAxXTtcbiAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUk9MTCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5zcGxpY2UodGhpcy5zdGFjay5sZW5ndGggLSBuIC0gMSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9ST1Q6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgeDMgLS0geDIgeDMgeDEpXG4gICAgICAgICAgLy8gIHgyIHgxIHgzICBhZnRlciBmaXJzdCBzd2FwXG4gICAgICAgICAgLy8gIHgyIHgzIHgxICBhZnRlciBzZWNvbmQgc3dhcFxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB4MSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAzXTtcbiAgICAgICAgICB4MiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgICB2YXIgeDMgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDNdID0geDI7XG4gICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdID0geDM7XG4gICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0geDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1NXQVA6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgLS0geDIgeDEpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHgxID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIHgyID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXSA9IHgyO1xuICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IHgxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9UVUNLOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHgxIHgyIC0tIHgyIHgxIHgyKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSh0aGlzLnN0YWNrLmxlbmd0aCAtIDIsIDAsIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgY2FzZSBPcGNvZGUuT1BfU0laRTpcbiAgICAgICAge1xuICAgICAgICAgIC8vIChpbiAtLSBpbiBzaXplKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBibiA9IG5ldyBCTih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0ubGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYm4udG9TY3JpcHROdW1CdWZmZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBCaXR3aXNlIGxvZ2ljXG4gICAgICAgIC8vXG4gICAgICBjYXNlIE9wY29kZS5PUF9FUVVBTDpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0VRVUFMVkVSSUZZOlxuICAgICAgICAvL2Nhc2UgT3Bjb2RlLk9QX05PVEVRVUFMOiAvLyB1c2UgT3Bjb2RlLk9QX05VTU5PVEVRVUFMXG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgLSBib29sKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWYxID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIGJ1ZjIgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFyIGZFcXVhbCA9IGJ1ZjEudG9TdHJpbmcoJ2hleCcpID09PSBidWYyLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZFcXVhbCA/IEludGVycHJldGVyLnRydWUgOiBJbnRlcnByZXRlci5mYWxzZSk7XG4gICAgICAgICAgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0VRVUFMVkVSSUZZKSB7XG4gICAgICAgICAgICBpZiAoZkVxdWFsKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0VRVUFMVkVSSUZZJztcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE51bWVyaWNcbiAgICAgICAgLy9cbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzFBREQ6XG4gICAgICBjYXNlIE9wY29kZS5PUF8xU1VCOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTkVHQVRFOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfQUJTOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9UOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfME5PVEVRVUFMOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKGluIC0tIG91dClcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGJuID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcihidWYsIGZSZXF1aXJlTWluaW1hbCk7XG4gICAgICAgICAgc3dpdGNoIChvcGNvZGVudW0pIHtcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QXzFBREQ6XG4gICAgICAgICAgICAgIGJuID0gYm4uYWRkKEJOLk9uZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfMVNVQjpcbiAgICAgICAgICAgICAgYm4gPSBibi5zdWIoQk4uT25lKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9ORUdBVEU6XG4gICAgICAgICAgICAgIGJuID0gYm4ubmVnKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfQUJTOlxuICAgICAgICAgICAgICBpZiAoYm4uY21wKEJOLlplcm8pIDwgMCkge1xuICAgICAgICAgICAgICAgIGJuID0gYm4ubmVnKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9OT1Q6XG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibi5jbXAoQk4uWmVybykgPT09IDApICsgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfME5PVEVRVUFMOlxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoYm4uY21wKEJOLlplcm8pICE9PSAwKSArIDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgLy9kZWZhdWx0OiAgICAgIGFzc2VydCghJ2ludmFsaWQgb3Bjb2RlJyk7IGJyZWFrOyAvLyBUT0RPOiBkb2VzIHRoaXMgZXZlciBvY2N1cj9cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYm4udG9TY3JpcHROdW1CdWZmZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0FERDpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1NVQjpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0JPT0xBTkQ6XG4gICAgICBjYXNlIE9wY29kZS5PUF9CT09MT1I6XG4gICAgICBjYXNlIE9wY29kZS5PUF9OVU1FUVVBTDpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05VTUVRVUFMVkVSSUZZOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTlVNTk9URVFVQUw6XG4gICAgICBjYXNlIE9wY29kZS5PUF9MRVNTVEhBTjpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0dSRUFURVJUSEFOOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTEVTU1RIQU5PUkVRVUFMOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfR1JFQVRFUlRIQU5PUkVRVUFMOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTUlOOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTUFYOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHgxIHgyIC0tIG91dClcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm4xID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl0sIGZSZXF1aXJlTWluaW1hbCk7XG4gICAgICAgICAgYm4yID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0sIGZSZXF1aXJlTWluaW1hbCk7XG4gICAgICAgICAgYm4gPSBuZXcgQk4oMCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKG9wY29kZW51bSkge1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfQUREOlxuICAgICAgICAgICAgICBibiA9IGJuMS5hZGQoYm4yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX1NVQjpcbiAgICAgICAgICAgICAgYm4gPSBibjEuc3ViKGJuMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0JPT0xBTkQ6ICAgICAgIGJuID0gKGJuMSAhPSBiblplcm8gJiYgYm4yICE9IGJuWmVybyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfQk9PTEFORDpcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKChibjEuY21wKEJOLlplcm8pICE9PSAwKSAmJiAoYm4yLmNtcChCTi5aZXJvKSAhPT0gMCkpICsgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvLyBjYXNlIE9wY29kZS5PUF9CT09MT1I6ICAgICAgICBibiA9IChibjEgIT0gYm5aZXJvIHx8IGJuMiAhPSBiblplcm8pOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX0JPT0xPUjpcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKChibjEuY21wKEJOLlplcm8pICE9PSAwKSB8fCAoYm4yLmNtcChCTi5aZXJvKSAhPT0gMCkpICsgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvLyBjYXNlIE9wY29kZS5PUF9OVU1FUVVBTDogICAgICBibiA9IChibjEgPT0gYm4yKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9OVU1FUVVBTDpcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKGJuMS5jbXAoYm4yKSA9PT0gMCkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX05VTUVRVUFMVkVSSUZZOiAgICBibiA9IChibjEgPT0gYm4yKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9OVU1FUVVBTFZFUklGWTpcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKGJuMS5jbXAoYm4yKSA9PT0gMCkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX05VTU5PVEVRVUFMOiAgICAgYm4gPSAoYm4xICE9IGJuMik7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfTlVNTk9URVFVQUw6XG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibjEuY21wKGJuMikgIT09IDApICsgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvLyBjYXNlIE9wY29kZS5PUF9MRVNTVEhBTjogICAgICBibiA9IChibjEgPCBibjIpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX0xFU1NUSEFOOlxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoYm4xLmNtcChibjIpIDwgMCkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0dSRUFURVJUSEFOOiAgICAgYm4gPSAoYm4xID4gYm4yKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9HUkVBVEVSVEhBTjpcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKGJuMS5jbXAoYm4yKSA+IDApICsgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvLyBjYXNlIE9wY29kZS5PUF9MRVNTVEhBTk9SRVFVQUw6ICAgYm4gPSAoYm4xIDw9IGJuMik7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfTEVTU1RIQU5PUkVRVUFMOlxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoYm4xLmNtcChibjIpIDw9IDApICsgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvLyBjYXNlIE9wY29kZS5PUF9HUkVBVEVSVEhBTk9SRVFVQUw6ICBibiA9IChibjEgPj0gYm4yKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9HUkVBVEVSVEhBTk9SRVFVQUw6XG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibjEuY21wKGJuMikgPj0gMCkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9NSU46XG4gICAgICAgICAgICAgIGJuID0gKGJuMS5jbXAoYm4yKSA8IDAgPyBibjEgOiBibjIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX01BWDpcbiAgICAgICAgICAgICAgYm4gPSAoYm4xLmNtcChibjIpID4gMCA/IGJuMSA6IGJuMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvLyBkZWZhdWx0OiAgICAgICAgICAgYXNzZXJ0KCEnaW52YWxpZCBvcGNvZGUnKTsgYnJlYWs7IC8vVE9ETzogZG9lcyB0aGlzIGV2ZXIgb2NjdXI/XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYm4udG9TY3JpcHROdW1CdWZmZXIoKSk7XG5cbiAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfTlVNRVFVQUxWRVJJRlkpIHtcbiAgICAgICAgICAgIC8vIGlmIChDYXN0VG9Cb29sKHN0YWNrdG9wKC0xKSkpXG4gICAgICAgICAgICBpZiAoSW50ZXJwcmV0ZXIuY2FzdFRvQm9vbCh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX05VTUVRVUFMVkVSSUZZJztcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfV0lUSElOOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHggbWluIG1heCAtLSBvdXQpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJuMSA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDNdLCBmUmVxdWlyZU1pbmltYWwpO1xuICAgICAgICAgIGJuMiA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdLCBmUmVxdWlyZU1pbmltYWwpO1xuICAgICAgICAgIHZhciBibjMgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSwgZlJlcXVpcmVNaW5pbWFsKTtcbiAgICAgICAgICAvL2Jvb2wgZlZhbHVlID0gKGJuMiA8PSBibjEgJiYgYm4xIDwgYm4zKTtcbiAgICAgICAgICBmVmFsdWUgPSAoYm4yLmNtcChibjEpIDw9IDApICYmIChibjEuY21wKGJuMykgPCAwKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZlZhbHVlID8gSW50ZXJwcmV0ZXIudHJ1ZSA6IEludGVycHJldGVyLmZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIENyeXB0b1xuICAgICAgICAvL1xuICAgICAgY2FzZSBPcGNvZGUuT1BfUklQRU1EMTYwOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfU0hBMTpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1NIQTI1NjpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0hBU0gxNjA6XG4gICAgICBjYXNlIE9wY29kZS5PUF9IQVNIMjU2OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKGluIC0tIGhhc2gpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAvL3ZhbHR5cGUgdmNoSGFzaCgob3Bjb2RlID09IE9wY29kZS5PUF9SSVBFTUQxNjAgfHxcbiAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgb3Bjb2RlID09IE9wY29kZS5PUF9TSEExIHx8IG9wY29kZSA9PSBPcGNvZGUuT1BfSEFTSDE2MCkgPyAyMCA6IDMyKTtcbiAgICAgICAgICB2YXIgYnVmSGFzaDtcbiAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUklQRU1EMTYwKSB7XG4gICAgICAgICAgICBidWZIYXNoID0gSGFzaC5yaXBlbWQxNjAoYnVmKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1NIQTEpIHtcbiAgICAgICAgICAgIGJ1Zkhhc2ggPSBIYXNoLnNoYTEoYnVmKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1NIQTI1Nikge1xuICAgICAgICAgICAgYnVmSGFzaCA9IEhhc2guc2hhMjU2KGJ1Zik7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9IQVNIMTYwKSB7XG4gICAgICAgICAgICBidWZIYXNoID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAoYnVmKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0hBU0gyNTYpIHtcbiAgICAgICAgICAgIGJ1Zkhhc2ggPSBIYXNoLnNoYTI1NnNoYTI1NihidWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWZIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ09ERVNFUEFSQVRPUjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEhhc2ggc3RhcnRzIGFmdGVyIHRoZSBjb2RlIHNlcGFyYXRvclxuICAgICAgICAgIHRoaXMucGJlZ2luY29kZWhhc2ggPSB0aGlzLnBjO1xuICAgICAgICAgIHRoaXMuZXhlY2RhdGEuY29kZXNlcGFyYXRvclBvcyA9IHRoaXMucGMgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9DSEVDS1NJRzpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0NIRUNLU0lHVkVSSUZZOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHNpZyBwdWJrZXkgLS0gYm9vbClcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBidWZTaWcgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XG4gICAgICAgICAgYnVmUHVia2V5ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgY29uc3QgeyBzdWNjZXNzOiBmU3VjY2VzcywgcmVzdWx0IH0gPSB0aGlzLl9ldmFsQ2hlY2tTaWcoYnVmU2lnLCBidWZQdWJrZXkpO1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgLy8gc3RhY2sucHVzaF9iYWNrKGZTdWNjZXNzID8gdmNoVHJ1ZSA6IHZjaEZhbHNlKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZlN1Y2Nlc3MgPyBJbnRlcnByZXRlci50cnVlIDogSW50ZXJwcmV0ZXIuZmFsc2UpO1xuICAgICAgICAgIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9DSEVDS1NJR1ZFUklGWSkge1xuICAgICAgICAgICAgaWYgKGZTdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0NIRUNLU0lHVkVSSUZZJztcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0NIRUNLU0lHQUREOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gT1BfQ0hFQ0tTSUdBREQgaXMgb25seSBhdmFpbGFibGUgaW4gVGFwc2NyaXB0XG4gICAgICAgICAgaWYgKHRoaXMuc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5CQVNFIHx8IHRoaXMuc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0JBRF9PUENPREUnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIChzaWcgbnVtIHB1YmtleSAtLSBudW0pXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHNpZyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAzXTtcbiAgICAgICAgICBsZXQgbnVtID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIGxldCBwdWJrZXkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBudW0gPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKG51bSwgZlJlcXVpcmVNaW5pbWFsKTtcblxuICAgICAgICAgIGNvbnN0IHsgc3VjY2VzcywgcmVzdWx0IH0gPSB0aGlzLl9ldmFsQ2hlY2tTaWcoc2lnLCBwdWJrZXkpO1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKG51bS5hZGRuKHN1Y2Nlc3MgPyAxIDogMCkudG9TY3JpcHROdW1CdWZmZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE9wY29kZS5PUF9DSEVDS01VTFRJU0lHOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWTpcbiAgICAgICAge1xuICAgICAgICAgIC8vIChbc2lnIC4uLl0gbnVtX29mX3NpZ25hdHVyZXMgW3B1YmtleSAuLi5dIG51bV9vZl9wdWJrZXlzIC0tIGJvb2wpXG5cbiAgICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgaSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5LZXlzQ291bnQgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSBpXSwgZlJlcXVpcmVNaW5pbWFsKS50b051bWJlcigpO1xuICAgICAgICAgIGlmIChuS2V5c0NvdW50IDwgMCB8fCBuS2V5c0NvdW50ID4gMjApIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfUFVCS0VZX0NPVU5UJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uT3BDb3VudCArPSBuS2V5c0NvdW50O1xuICAgICAgICAgIGlmICh0aGlzLm5PcENvdW50ID4gMjAxKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX09QX0NPVU5UJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaW50IGlrZXkgPSArK2k7XG4gICAgICAgICAgdmFyIGlrZXkgPSArK2k7XG4gICAgICAgICAgaSArPSBuS2V5c0NvdW50O1xuXG4gICAgICAgICAgLy8gaWtleTIgaXMgdGhlIHBvc2l0aW9uIG9mIGxhc3Qgbm9uLXNpZ25hdHVyZSBpdGVtIGluXG4gICAgICAgICAgLy8gdGhlIHN0YWNrLiBUb3Agc3RhY2sgaXRlbSA9IDEuIFdpdGhcbiAgICAgICAgICAvLyBTQ1JJUFRfVkVSSUZZX05VTExGQUlMLCB0aGlzIGlzIHVzZWQgZm9yIGNsZWFudXAgaWZcbiAgICAgICAgICAvLyBvcGVyYXRpb24gZmFpbHMuXG4gICAgICAgICAgdmFyIGlrZXkyID0gbktleXNDb3VudCArIDI7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCBpKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgblNpZ3NDb3VudCA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIGldLCBmUmVxdWlyZU1pbmltYWwpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgaWYgKG5TaWdzQ291bnQgPCAwIHx8IG5TaWdzQ291bnQgPiBuS2V5c0NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NJR19DT1VOVCc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGludCBpc2lnID0gKytpO1xuICAgICAgICAgIHZhciBpc2lnID0gKytpO1xuICAgICAgICAgIGkgKz0gblNpZ3NDb3VudDtcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCBpKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdWJzZXQgb2Ygc2NyaXB0IHN0YXJ0aW5nIGF0IHRoZSBtb3N0IHJlY2VudCBjb2Rlc2VwYXJhdG9yXG4gICAgICAgICAgc3Vic2NyaXB0ID0gbmV3IFNjcmlwdCgpLnNldCh7XG4gICAgICAgICAgICBjaHVua3M6IHRoaXMuc2NyaXB0LmNodW5rcy5zbGljZSh0aGlzLnBiZWdpbmNvZGVoYXNoKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRHJvcCB0aGUgc2lnbmF0dXJlcywgc2luY2UgdGhlcmUncyBubyB3YXkgZm9yIGEgc2lnbmF0dXJlIHRvIHNpZ24gaXRzZWxmXG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuU2lnc0NvdW50OyBrKyspIHtcbiAgICAgICAgICAgIGJ1ZlNpZyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSBpc2lnIC0ga107XG4gICAgICAgICAgICBzdWJzY3JpcHQuZmluZEFuZERlbGV0ZShuZXcgU2NyaXB0KCkuYWRkKGJ1ZlNpZykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICB3aGlsZSAoZlN1Y2Nlc3MgJiYgblNpZ3NDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIHZhbHR5cGUmIHZjaFNpZyAgPSBzdGFja3RvcCgtaXNpZyk7XG4gICAgICAgICAgICBidWZTaWcgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gaXNpZ107XG4gICAgICAgICAgICAvLyB2YWx0eXBlJiB2Y2hQdWJLZXkgPSBzdGFja3RvcCgtaWtleSk7XG4gICAgICAgICAgICBidWZQdWJrZXkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gaWtleV07XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1NpZ25hdHVyZUVuY29kaW5nKGJ1ZlNpZykgfHwgIXRoaXMuY2hlY2tQdWJrZXlFbmNvZGluZyhidWZQdWJrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZPaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoYnVmU2lnKTtcbiAgICAgICAgICAgICAgcHVia2V5ID0gUHVibGljS2V5LmZyb21CdWZmZXIoYnVmUHVia2V5LCBmYWxzZSk7XG4gICAgICAgICAgICAgIGZPayA9IHRoaXMudHgudmVyaWZ5U2lnbmF0dXJlKHNpZywgcHVia2V5LCB0aGlzLm5pbiwgc3Vic2NyaXB0LCB0aGlzLnNpZ3ZlcnNpb24sIHRoaXMuc2F0b3NoaXMsIHRoaXMuZXhlY2RhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvL2ludmFsaWQgc2lnIG9yIHB1YmtleVxuICAgICAgICAgICAgICBmT2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZPaykge1xuICAgICAgICAgICAgICBpc2lnKys7XG4gICAgICAgICAgICAgIG5TaWdzQ291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlrZXkrKztcbiAgICAgICAgICAgIG5LZXlzQ291bnQtLTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgc2lnbmF0dXJlcyBsZWZ0IHRoYW4ga2V5cyBsZWZ0LFxuICAgICAgICAgICAgLy8gdGhlbiB0b28gbWFueSBzaWduYXR1cmVzIGhhdmUgZmFpbGVkXG4gICAgICAgICAgICBpZiAoblNpZ3NDb3VudCA+IG5LZXlzQ291bnQpIHtcbiAgICAgICAgICAgICAgZlN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIC8vIENsZWFuIHVwIHN0YWNrIG9mIGFjdHVhbCBhcmd1bWVudHNcbiAgICAgICAgICB3aGlsZSAoaS0tID4gMSkge1xuICAgICAgICAgICAgaWYgKCFmU3VjY2VzcyAmJiAodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfTlVMTEZBSUwpICYmXG4gICAgICAgICAgICAgICFpa2V5MiAmJiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0ubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9OVUxMRkFJTCc7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlrZXkyID4gMCkge1xuICAgICAgICAgICAgICBpa2V5Mi0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEEgYnVnIGNhdXNlcyBDSEVDS01VTFRJU0lHIHRvIGNvbnN1bWUgb25lIGV4dHJhIGFyZ3VtZW50XG4gICAgICAgICAgLy8gd2hvc2UgY29udGVudHMgd2VyZSBub3QgY2hlY2tlZCBpbiBhbnkgd2F5LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSB0aGlzIGlzIGEgcG90ZW50aWFsIHNvdXJjZSBvZiBtdXRhYmlsaXR5LFxuICAgICAgICAgIC8vIHNvIG9wdGlvbmFsbHkgdmVyaWZ5IGl0IGlzIGV4YWN0bHkgZXF1YWwgdG8gemVybyBwcmlvclxuICAgICAgICAgIC8vIHRvIHJlbW92aW5nIGl0IGZyb20gdGhlIHN0YWNrLlxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX05VTExEVU1NWSkgJiYgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TSUdfTlVMTERVTU1ZJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcblxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmU3VjY2VzcyA/IEludGVycHJldGVyLnRydWUgOiBJbnRlcnByZXRlci5mYWxzZSk7XG5cbiAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWSkge1xuICAgICAgICAgICAgaWYgKGZTdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0NIRUNLTVVMVElTSUdWRVJJRlknO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0JBRF9PUENPREUnO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gU2l6ZSBsaW1pdHNcbiAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICsgdGhpcy5hbHRzdGFjay5sZW5ndGggPiBJbnRlcnByZXRlci5NQVhfU1RBQ0tfU0laRSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU1RBQ0tfU0laRSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/script/interpreter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/script/script.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/script/script.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Address = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Opcode = __webpack_require__(/*! ../opcode */ \"(ssr)/./node_modules/bitcore-lib/lib/opcode.js\");\nvar PublicKey = __webpack_require__(/*! ../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Networks = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n/**\n * A bitcoin transaction script. Each transaction's inputs and outputs\n * has a script that is evaluated to validate it's spending.\n *\n * See https://en.bitcoin.it/wiki/Script\n *\n * @constructor\n * @param {Object|string|Buffer=} from optional data to populate script\n */\nvar Script = function Script(from) {\n  if (!(this instanceof Script)) {\n    return new Script(from);\n  }\n  this.chunks = [];\n\n  if (BufferUtil.isBuffer(from)) {\n    return Script.fromBuffer(from);\n  } else if (from instanceof Address) {\n    return Script.fromAddress(from);\n  } else if (from instanceof Script) {\n    return Script.fromBuffer(from.toBuffer());\n  } else if (typeof from === 'string') {\n    return Script.fromString(from);\n  } else if (_.isObject(from) && Array.isArray(from.chunks)) {\n    this.set(from);\n  }\n};\n\n\nScript.prototype.set = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  $.checkArgument(Array.isArray(obj.chunks));\n  this.chunks = obj.chunks;\n  return this;\n};\n\nScript.fromBuffer = function(buffer) {\n  var script = new Script();\n  script.chunks = [];\n\n  var br = new BufferReader(buffer);\n  while (!br.finished()) {\n    try {\n      var opcodenum = br.readUInt8();\n\n      var len, buf;\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        len = opcodenum;\n        script.chunks.push({\n          buf: br.read(len),\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        len = br.readUInt8();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        len = br.readUInt16LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        len = br.readUInt32LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (Opcode.isOpSuccess(opcodenum)) {\n        // OP_SUCCESSx processing overrides everything, including stack element size limits\n        buf = br.readAll();\n        len = buf.length;\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else {\n        script.chunks.push({\n          opcodenum: opcodenum\n        });\n      }\n    } catch (e) {\n      if (e instanceof RangeError) {\n        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));\n      }\n      throw e;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype.toBuffer = function() {\n  var bw = new BufferWriter();\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    var opcodenum = chunk.opcodenum;\n    bw.writeUInt8(chunk.opcodenum);\n    if (chunk.buf) {\n      if (opcodenum < Opcode.OP_PUSHDATA1) {\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        bw.writeUInt8(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        bw.writeUInt16LE(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        bw.writeUInt32LE(chunk.len);\n        bw.write(chunk.buf);\n      } else {\n        // Could reach here if opcodenum is OP_SUCCESSx (see comment in .fromBuffer)\n        bw.write(chunk.buf);\n      }\n    }\n  }\n\n  return bw.concat();\n};\n\nScript.fromASM = function(str) {\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (opcodenum == null) {\n      var buf = Buffer.from(tokens[i], 'hex');\n      script.chunks.push({\n        buf: buf,\n        len: buf.length,\n        opcodenum: buf.length\n      });\n      i = i + 1;\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2], 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.fromHex = function(str) {\n  return new Script(Buffer.from(str, 'hex'));\n};\n\nScript.fromString = function(str) {\n  if (JSUtil.isHexa(str) || str.length === 0) {\n    return new Script(Buffer.from(str, 'hex'));\n  }\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (opcodenum == null) {\n      opcodenum = parseInt(token);\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        script.chunks.push({\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\n          len: opcodenum,\n          opcodenum: opcodenum\n        });\n        i = i + 2;\n      } else {\n        throw new Error('Invalid script: ' + JSON.stringify(str));\n      }\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\n        throw new Error('Pushdata data must start with 0x');\n      }\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.prototype._chunkToString = function(chunk, type) {\n  var opcodenum = chunk.opcodenum;\n  var asm = (type === 'asm');\n  var str = '';\n  if (!chunk.buf) {\n    // no data chunk\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\n      if (asm) {\n        // A few cases where the opcode name differs from reverseMap\n        // aside from 1 to 16 data pushes.\n        if (opcodenum === 0) {\n          // OP_0 -> 0\n          str = str + ' 0';\n        } else if(opcodenum === 79) {\n          // OP_1NEGATE -> 1\n          str = str + ' -1';\n        } else {\n          str = str + ' ' + Opcode(opcodenum).toString();\n        }\n      } else {\n        str = str + ' ' + Opcode(opcodenum).toString();\n      }\n    } else {\n      var numstr = opcodenum.toString(16);\n      if (numstr.length % 2 !== 0) {\n        numstr = '0' + numstr;\n      }\n      if (asm) {\n        str = str + ' ' + numstr;\n      } else {\n        str = str + ' ' + '0x' + numstr;\n      }\n    }\n  } else {\n    // data chunk\n    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      str = str + ' ' + Opcode(opcodenum).toString();\n    }\n    if (chunk.len > 0) {\n      if (asm) {\n        str = str + ' ' + chunk.buf.toString('hex');\n      } else {\n        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');\n      }\n    }\n  }\n  return str;\n};\n\nScript.prototype.toASM = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk, 'asm');\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toString = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk);\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toHex = function() {\n  return this.toBuffer().toString('hex');\n};\n\nScript.prototype.inspect = function() {\n  return '<Script: ' + this.toString() + '>';\n};\n\n// script classification methods\n\n/**\n * @returns {boolean} if this is a pay to pubkey hash output script\n */\nScript.prototype.isPublicKeyHashOut = function() {\n  return !!(this.chunks.length === 5 &&\n    this.chunks[0].opcodenum === Opcode.OP_DUP &&\n    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&\n    this.chunks[2].buf &&\n    this.chunks[2].buf.length === 20 &&\n    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&\n    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\n};\n\n/**\n * @returns {boolean} if this is a pay to public key hash input script\n */\nScript.prototype.isPublicKeyHashIn = function() {\n  if (this.chunks.length === 2) {\n    var signatureBuf = this.chunks[0].buf;\n    var pubkeyBuf = this.chunks[1].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30 &&\n        pubkeyBuf &&\n        pubkeyBuf.length\n       ) {\n      var version = pubkeyBuf[0];\n      if ((version === 0x04 ||\n           version === 0x06 ||\n           version === 0x07) && pubkeyBuf.length === 65) {\n        return true;\n      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nScript.prototype.getPublicKey = function() {\n  $.checkState(this.isPublicKeyOut(), 'Can\\'t retrieve PublicKey from a non-PK output');\n  return this.chunks[0].buf;\n};\n\nScript.prototype.getPublicKeyHash = function() {\n  if (this.isPublicKeyHashOut()) {\n    return this.chunks[2].buf;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    return this.chunks[1].buf;\n  } else if (this.isTaproot()) {\n    return this.chunks[1].buf;\n  } else {\n    throw new Error('Can\\'t retrieve PublicKeyHash from a non-PKH output');\n  }\n};\n\n/**\n * @returns {boolean} if this is a public key output script\n */\nScript.prototype.isPublicKeyOut = function() {\n  if (this.chunks.length === 2 &&\n      this.chunks[0].buf &&\n      this.chunks[0].buf.length &&\n      this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\n    var pubkeyBuf = this.chunks[0].buf;\n    var version = pubkeyBuf[0];\n    var isVersion = false;\n    if ((version === 0x04 ||\n         version === 0x06 ||\n         version === 0x07) && pubkeyBuf.length === 65) {\n      isVersion = true;\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n      isVersion = true;\n    }\n    if (isVersion) {\n      return PublicKey.isValid(pubkeyBuf);\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a pay to public key input script\n */\nScript.prototype.isPublicKeyIn = function() {\n  if (this.chunks.length === 1) {\n    var signatureBuf = this.chunks[0].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh output script\n */\nScript.prototype.isScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 23 &&\n    buf[0] === Opcode.OP_HASH160 &&\n    buf[1] === 0x14 &&\n    buf[buf.length - 1] === Opcode.OP_EQUAL);\n};\n\n/**\n * @returns {boolean} if this is a p2wsh output script\n */\nScript.prototype.isWitnessScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 34 && buf[0] === Opcode.OP_0 && buf[1] === 32);\n};\n\n/**\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessPublicKeyHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 22 && buf[0] === Opcode.OP_0 && buf[1] === 20);\n};\n\n/**\n * @returns {boolean} if this is a p2tr output script\n */\nScript.prototype.isTaproot = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 34 && buf[0] === Opcode.OP_1 && buf[1] === 32);\n}\n\n/**\n * @param {Object=} values - The return values\n * @param {Number} values.version - Set with the witness version\n * @param {Buffer} values.program - Set with the witness program\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessProgram = function(values) {\n  if (!values) {\n    values = {};\n  }\n  var buf = this.toBuffer();\n  if (buf.length < 4 || buf.length > 42) {\n    return false;\n  }\n  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {\n    return false;\n  }\n\n  if (buf.length === buf[1] + 2) {\n    values.version = Opcode.decodeOpN(buf[0]);\n    values.program = buf.slice(2, buf.length);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh input script\n * Note that these are frequently indistinguishable from pubkeyhashin\n */\nScript.prototype.isScriptHashIn = function() {\n  if (this.chunks.length <= 1) {\n    return false;\n  }\n  var redeemChunk = this.chunks[this.chunks.length - 1];\n  var redeemBuf = redeemChunk.buf;\n  if (!redeemBuf) {\n    return false;\n  }\n\n  var redeemScript;\n  try {\n    redeemScript = Script.fromBuffer(redeemBuf);\n  } catch (e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      return false;\n    }\n    throw e;\n  }\n  var type = redeemScript.classify();\n  return type !== Script.types.UNKNOWN;\n};\n\n/**\n * @returns {boolean} if this is a mutlsig output script\n */\nScript.prototype.isMultisigOut = function() {\n  return (this.chunks.length > 3 &&\n    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&\n    this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {\n      return obj.buf && BufferUtil.isBuffer(obj.buf);\n    }) &&\n    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&\n    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG);\n};\n\n\n/**\n * @returns {boolean} if this is a multisig input script\n */\nScript.prototype.isMultisigIn = function() {\n  return this.chunks.length >= 2 &&\n    this.chunks[0].opcodenum === 0 &&\n    this.chunks.slice(1, this.chunks.length).every(function(obj) {\n      return obj.buf &&\n        BufferUtil.isBuffer(obj.buf) &&\n        Signature.isTxDER(obj.buf);\n    });\n};\n\n/**\n * @returns {boolean} true if this is a valid standard OP_RETURN output\n */\nScript.prototype.isDataOut = function() {\n  return this.chunks.length >= 1 &&\n    this.chunks[0].opcodenum === Opcode.OP_RETURN &&\n    (this.chunks.length === 1 ||\n      (this.chunks.length === 2 &&\n        this.chunks[1].buf &&\n        this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE &&\n        this.chunks[1].length === this.chunks.len));\n};\n\n/**\n * Retrieve the associated data for this script.\n * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.\n * In the case of a standard OP_RETURN, return the data\n * @returns {Buffer}\n */\nScript.prototype.getData = function() {\n  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut() || this.isTaproot()) {\n    if (this.chunks[1] == null) {\n      return Buffer.alloc(0);\n    } else {\n      return Buffer.from(this.chunks[1].buf);\n    }\n  }\n  if (this.isPublicKeyHashOut()) {\n    return Buffer.from(this.chunks[2].buf);\n  }\n  throw new Error('Unrecognized script type to get data from');\n};\n\n/**\n * @returns {boolean} if the script is only composed of data pushing\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\n */\nScript.prototype.isPushOnly = function() {\n  return this.chunks.every(function(chunk) {\n    return chunk.opcodenum <= Opcode.OP_16;\n  });\n};\n\n\nScript.types = {};\nScript.types.UNKNOWN = 'Unknown';\nScript.types.PUBKEY_OUT = 'Pay to public key';\nScript.types.PUBKEY_IN = 'Spend from public key';\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\nScript.types.MULTISIG_OUT = 'Pay to multisig';\nScript.types.MULTISIG_IN = 'Spend from multisig';\nScript.types.DATA_OUT = 'Data push';\n\nScript.OP_RETURN_STANDARD_SIZE = 80;\n\n// Tag for input annex. If there are at least two witness elements for a transaction input,\n// and the first byte of the last element is 0x50, this last element is called annex, and\n// has meanings independent of the script\nScript.ANNEX_TAG = 0x50;\n\n// Validation weight per passing signature (Tapscript only, see BIP 342).\nScript.VALIDATION_WEIGHT_PER_SIGOP_PASSED = 50;\n\n// How much weight budget is added to the witness size (Tapscript only, see BIP 342).\nScript.VALIDATION_WEIGHT_OFFSET = 50;\n\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classify = function() {\n  if (this._isInput) {\n    return this.classifyInput();\n  } else if (this._isOutput) {\n    return this.classifyOutput();\n  } else {\n    var outputType = this.classifyOutput();\n    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();\n  }\n};\n\nScript.outputIdentifiers = {};\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyOutput = function() {\n  for (var type in Script.outputIdentifiers) {\n    if (Script.outputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\nScript.inputIdentifiers = {};\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyInput = function() {\n  for (var type in Script.inputIdentifiers) {\n    if (Script.inputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\n\n/**\n * @returns {boolean} if script is one of the known types\n */\nScript.prototype.isStandard = function() {\n  // TODO: Add BIP62 compliance\n  return this.classify() !== Script.types.UNKNOWN;\n};\n\n\n// Script construction methods\n\n/**\n * Adds a script element at the start of the script.\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n */\nScript.prototype.prepend = function(obj) {\n  this._addByType(obj, true);\n  return this;\n};\n\n/**\n * Compares a script with another script\n */\nScript.prototype.equals = function(script) {\n  $.checkState(script instanceof Script, 'Must provide another script');\n  if (this.chunks.length !== script.chunks.length) {\n    return false;\n  }\n  var i;\n  for (i = 0; i < this.chunks.length; i++) {\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\n      return false;\n    }\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\n      return false;\n    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Adds a script element to the end of the script.\n *\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n *\n */\nScript.prototype.add = function(obj) {\n  this._addByType(obj, false);\n  return this;\n};\n\nScript.prototype._addByType = function(obj, prepend) {\n  if (typeof obj === 'string') {\n    this._addOpcode(obj, prepend);\n  } else if (typeof obj === 'number') {\n    this._addOpcode(obj, prepend);\n  } else if (obj instanceof Opcode) {\n    this._addOpcode(obj, prepend);\n  } else if (BufferUtil.isBuffer(obj)) {\n    this._addBuffer(obj, prepend);\n  } else if (obj instanceof Script) {\n    this.chunks = this.chunks.concat(obj.chunks);\n  } else if (typeof obj === 'object') {\n    this._insertAtPosition(obj, prepend);\n  } else {\n    throw new Error('Invalid script chunk');\n  }\n};\n\nScript.prototype._insertAtPosition = function(op, prepend) {\n  if (prepend) {\n    this.chunks.unshift(op);\n  } else {\n    this.chunks.push(op);\n  }\n};\n\nScript.prototype._addOpcode = function(opcode, prepend) {\n  var op;\n  if (typeof opcode === 'number') {\n    op = opcode;\n  } else if (opcode instanceof Opcode) {\n    op = opcode.toNumber();\n  } else {\n    op = Opcode(opcode).toNumber();\n  }\n  this._insertAtPosition({\n    opcodenum: op\n  }, prepend);\n  return this;\n};\n\nScript.prototype._addBuffer = function(buf, prepend) {\n  var opcodenum;\n  var len = buf.length;\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\n    opcodenum = len;\n  } else if (len < Math.pow(2, 8)) {\n    opcodenum = Opcode.OP_PUSHDATA1;\n  } else if (len < Math.pow(2, 16)) {\n    opcodenum = Opcode.OP_PUSHDATA2;\n  } else if (len < Math.pow(2, 32)) {\n    opcodenum = Opcode.OP_PUSHDATA4;\n  } else {\n    throw new Error('You can\\'t push that much data');\n  }\n  this._insertAtPosition({\n    buf: buf,\n    len: len,\n    opcodenum: opcodenum\n  }, prepend);\n  return this;\n};\n\nScript.prototype.hasCodeseparators = function() {\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {\n      return true;\n    }\n  }\n  return false;\n};\n\nScript.prototype.removeCodeseparators = function() {\n  var chunks = [];\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {\n      chunks.push(this.chunks[i]);\n    }\n  }\n  this.chunks = chunks;\n  return this;\n};\n\n// high level script builder methods\n\n/**\n * @returns {Script} a new Multisig output script for given public keys,\n * requiring m of those public keys to spend\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\n * @param {number} threshold - amount of required signatures to spend the output\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true, don't sort the given\n *                      public keys before creating the script\n */\nScript.buildMultisigOut = function(publicKeys, threshold, opts) {\n  $.checkArgument(threshold <= publicKeys.length,\n    'Number of required signatures must be less than or equal to the number of public keys');\n  opts = opts || {};\n  var script = new Script();\n  script.add(Opcode.smallInt(threshold));\n  publicKeys = publicKeys.map(PublicKey);\n  var sorted = publicKeys;\n  if (!opts.noSorting) {\n    sorted = _.sortBy(publicKeys, function(publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n  for (var i = 0; i < sorted.length; i++) {\n    var publicKey = sorted[i];\n    script.add(publicKey.toBuffer());\n  }\n  script.add(Opcode.smallInt(publicKeys.length));\n  script.add(Opcode.OP_CHECKMULTISIG);\n  return script;\n};\n\nScript.buildWitnessMultisigOutFromScript = function(script) {\n  if (script instanceof Script) {\n    var s = new Script();\n    s.add(Opcode.OP_0);\n    s.add(Hash.sha256(script.toBuffer()));\n    return s;\n  } else {\n    throw new TypeError('First argument is expected to be a p2sh script');\n  }\n};\n\n/**\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(Array.isArray(pubkeys));\n  $.checkArgument(!isNaN(threshold));\n  $.checkArgument(Array.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  for (const signature of signatures) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  }\n  return s;\n};\n\n/**\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(Array.isArray(pubkeys));\n  $.checkArgument(!isNaN(threshold));\n  $.checkArgument(Array.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  for (const signature of signatures) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  }\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to public key hash output for the given\n * address or public key\n * @param {(Address|PublicKey)} to - destination address or public key\n */\nScript.buildPublicKeyHashOut = function(to) {\n  $.checkArgument(to != null);\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\n  if (to instanceof PublicKey) {\n    to = to.toAddress();\n  } else if (typeof to === 'string') {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_DUP)\n    .add(Opcode.OP_HASH160)\n    .add(to.hashBuffer)\n    .add(Opcode.OP_EQUALVERIFY)\n    .add(Opcode.OP_CHECKSIG);\n  s._network = to.network;\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to witness v0 output for the given\n * address\n * @param {(Address|PublicKey)} to - destination address\n */\nScript.buildWitnessV0Out = function(to) {\n  $.checkArgument(to != null);\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\n  if (to instanceof PublicKey) {\n    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);\n  } else if (typeof to === 'string') {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_0)\n    .add(to.hashBuffer);\n  s._network = to.network;\n  return s;\n};\n\n\n/**\n * Build Taproot script output\n * @param {PublicKey|Address} to recipient's pubKey or address\n * @param {Array|Object} scriptTree single leaf object OR array of leaves. leaf: { script: String, leafVersion: Integer }\n * @returns {Script}\n */\nScript.buildWitnessV1Out = function(to, scriptTree) {\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\n  $.checkArgument(!scriptTree || Array.isArray(scriptTree) || !!scriptTree.script);\n\n  if (typeof to === 'string') {\n    try {\n      to = PublicKey.fromTaproot(to);\n    } catch {\n      to = Address.fromString(to);\n    }\n  }\n  \n  function buildTree(tree) {\n    if (Array.isArray(tree)) {\n      const [left, leftH] = buildTree(tree[0]);\n      const [right, rightH] = buildTree(tree[1]);\n      const ret = [[[left[0], left[1]], rightH], [[right[0], right[1]], leftH]];\n      const hWriter = TaggedHash.TAPBRANCH;\n      if (leftH.compare(rightH) === 1) {\n        hWriter.write(rightH);\n        hWriter.write(leftH);\n      } else {\n        hWriter.write(leftH);\n        hWriter.write(rightH);\n      }\n      return [ret, hWriter.finalize()];\n    } else {\n      const { leafVersion, script } = tree;\n      const scriptBuf = new Script(script).toBuffer();\n      const leafWriter = TaggedHash.TAPLEAF;\n      leafWriter.writeUInt8(leafVersion);\n      leafWriter.writeUInt8(scriptBuf.length);\n      leafWriter.write(scriptBuf);\n      const h = leafWriter.finalize();\n      return [[Buffer.from([leafVersion]), scriptBuf], h];\n    }\n  }\n\n  let taggedHash = null;\n  if (scriptTree) { \n    const [_, h] = buildTree(scriptTree);\n    taggedHash = h;\n  }\n  \n  let tweakedPubKey;\n  if (to instanceof PublicKey) {\n    tweakedPubKey = to.createTapTweak(taggedHash).tweakedPubKey;\n  } else { // Address\n    tweakedPubKey = to.hashBuffer;\n  }\n  const s = new Script();\n  s.add(Opcode.OP_1);\n  s.add(tweakedPubKey);\n  return s;\n};\n\n\n/**\n * @returns {Script} a new pay to public key output for the given\n *  public key\n */\nScript.buildPublicKeyOut = function(pubkey) {\n  $.checkArgument(pubkey instanceof PublicKey);\n  var s = new Script();\n  s.add(pubkey.toBuffer())\n    .add(Opcode.OP_CHECKSIG);\n  return s;\n};\n\n/**\n * @returns {Script} a new OP_RETURN script with data\n * @param {(string|Buffer)} data - the data to embed in the output\n * @param {(string)} encoding - the type of encoding of the string\n */\nScript.buildDataOut = function(data, encoding) {\n  $.checkArgument(data == null || typeof data === 'string' || BufferUtil.isBuffer(data));\n  if (typeof data === 'string') {\n    data = Buffer.from(data, encoding);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_RETURN);\n  if (data != null) {\n    s.add(data);\n  }\n  return s;\n};\n\n/**\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\n *    It can also be a p2sh address\n * @returns {Script} new pay to script hash script for given script\n */\nScript.buildScriptHashOut = function(script) {\n  $.checkArgument(script instanceof Script ||\n    (script instanceof Address && script.isPayToScriptHash()));\n  var s = new Script();\n  s.add(Opcode.OP_HASH160)\n    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))\n    .add(Opcode.OP_EQUAL);\n\n  s._network = script._network || script.network;\n  return s;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key output script.\n *\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyIn = function(signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(sigtype == null || !isNaN(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script();\n  script.add(BufferUtil.concat([\n    signature,\n    BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n  ]));\n  return script;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key hash\n * output script.\n *\n * @param {Buffer|string|PublicKey} publicKey\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(sigtype == null || !isNaN(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script()\n    .add(BufferUtil.concat([\n      signature,\n      BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n    ]))\n    .add(new PublicKey(publicKey).toBuffer());\n  return script;\n};\n\n/**\n * @returns {Script} an empty script\n */\nScript.empty = function() {\n  return new Script();\n};\n\n/**\n * @returns {Script} a new pay to script hash script that pays to this script\n */\nScript.prototype.toScriptHashOut = function() {\n  return Script.buildScriptHashOut(this);\n};\n\n/**\n * @return {Script} an output script built from the address\n */\nScript.fromAddress = function(address) {\n  address = Address(address);\n  if (address.isPayToScriptHash()) {\n    return Script.buildScriptHashOut(address);\n  } else if (address.isPayToPublicKeyHash()) {\n    return Script.buildPublicKeyHashOut(address);\n  } else if (address.isPayToWitnessPublicKeyHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToWitnessScriptHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToTaproot()) {\n    return Script.buildWitnessV1Out(address);\n  }\n  throw new errors.Script.UnrecognizedAddress(address);\n};\n\n/**\n * Will return the associated address information object\n * @return {Address|boolean}\n */\nScript.prototype.getAddressInfo = function(opts) {\n  if (this._isInput) {\n    return this._getInputAddressInfo();\n  } else if (this._isOutput) {\n    return this._getOutputAddressInfo();\n  } else {\n    var info = this._getOutputAddressInfo();\n    if (!info) {\n      return this._getInputAddressInfo();\n    }\n    return info;\n  }\n};\n\n/**\n * Will return the associated output scriptPubKey address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getOutputAddressInfo = function() {\n  var info = {};\n  if (this.isScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToScriptHash;\n  } else if (this.isPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isWitnessScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessScriptHash;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessPublicKeyHash;\n  } else if (this.isTaproot()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToTaproot;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * Will return the associated input scriptSig address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getInputAddressInfo = function() {\n  var info = {};\n  if (this.isPublicKeyHashIn()) {\n    // hash the publickey found in the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isScriptHashIn()) {\n    // hash the redeemscript found at the end of the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\n    info.type = Address.PayToScriptHash;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * @param {Network=} network\n * @return {Address|boolean} the associated address for this script if possible, or false\n */\nScript.prototype.toAddress = function(network) {\n  var info = this.getAddressInfo();\n  if (!info) {\n    return false;\n  }\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\n  return new Address(info);\n};\n\n/**\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\n * typically used with push data chunks.  Note that this will find and delete\n * not just the same data, but the same data with the same push data op as\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\n * pushdata op, then when you try to remove the data it is pushing, it will not\n * be removed, because they do not use the same pushdata op.\n */\nScript.prototype.findAndDelete = function(script) {\n  var buf = script.toBuffer();\n  var hex = buf.toString('hex');\n  for (var i = 0; i < this.chunks.length; i++) {\n    var script2 = Script({\n      chunks: [this.chunks[i]]\n    });\n    var buf2 = script2.toBuffer();\n    var hex2 = buf2.toString('hex');\n    if (hex === hex2) {\n      this.chunks.splice(i, 1);\n    }\n  }\n  return this;\n};\n\n/**\n * Comes from bitcoind's script interpreter CheckMinimalPush function\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\n */\nScript.prototype.checkMinimalPush = function(i) {\n  var chunk = this.chunks[i];\n  var buf = chunk.buf;\n  var opcodenum = chunk.opcodenum;\n  if (!buf) {\n    return true;\n  }\n  if (buf.length === 0) {\n    // Could have used OP_0.\n    return opcodenum === Opcode.OP_0;\n  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\n    // Could have used OP_1 .. OP_16.\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\n  } else if (buf.length === 1 && buf[0] === 0x81) {\n    // Could have used OP_1NEGATE\n    return opcodenum === Opcode.OP_1NEGATE;\n  } else if (buf.length <= 75) {\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n    return opcodenum === buf.length;\n  } else if (buf.length <= 255) {\n    // Could have used OP_PUSHDATA.\n    return opcodenum === Opcode.OP_PUSHDATA1;\n  } else if (buf.length <= 65535) {\n    // Could have used OP_PUSHDATA2.\n    return opcodenum === Opcode.OP_PUSHDATA2;\n  }\n  return true;\n};\n\n\n/**\n * Comes from bitcoind's script GetSigOpCount(boolean) function\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\n * @returns {number} number of signature operations required by this script\n */\nScript.prototype.getSignatureOperationsCount = function(accurate) {\n  accurate = (accurate == null ? true : accurate);\n  var n = 0;\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\n  for (const chunk of this.chunks) {\n    var opcode = chunk.opcodenum;\n    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {\n      n++;\n    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\n        n += Opcode.decodeOpN(lastOpcode);\n      } else {\n        n += 20;\n      }\n    }\n    lastOpcode = opcode;\n  }\n  return n;\n};\n\nmodule.exports = Script;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3NjcmlwdC9zY3JpcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLG1FQUFZO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDckQsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxhQUFhLG1CQUFPLENBQUMsaUVBQVc7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQWM7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQXFCO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyxxRUFBYTtBQUNwQyxRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxtRUFBWTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBc0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsY0FBYywwREFBMEQ7QUFDbkYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUyxjQUFjLEdBQUc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3NjcmlwdC9zY3JpcHQuanM/NjNmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi4vYWRkcmVzcycpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIE9wY29kZSA9IHJlcXVpcmUoJy4uL29wY29kZScpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4uL3B1YmxpY2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL2NyeXB0by9zaWduYXR1cmUnKTtcbnZhciBOZXR3b3JrcyA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XG5jb25zdCBUYWdnZWRIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL3RhZ2dlZGhhc2gnKTtcblxuLyoqXG4gKiBBIGJpdGNvaW4gdHJhbnNhY3Rpb24gc2NyaXB0LiBFYWNoIHRyYW5zYWN0aW9uJ3MgaW5wdXRzIGFuZCBvdXRwdXRzXG4gKiBoYXMgYSBzY3JpcHQgdGhhdCBpcyBldmFsdWF0ZWQgdG8gdmFsaWRhdGUgaXQncyBzcGVuZGluZy5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvU2NyaXB0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd8QnVmZmVyPX0gZnJvbSBvcHRpb25hbCBkYXRhIHRvIHBvcHVsYXRlIHNjcmlwdFxuICovXG52YXIgU2NyaXB0ID0gZnVuY3Rpb24gU2NyaXB0KGZyb20pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjcmlwdCkpIHtcbiAgICByZXR1cm4gbmV3IFNjcmlwdChmcm9tKTtcbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuXG4gIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKGZyb20pKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5mcm9tQnVmZmVyKGZyb20pO1xuICB9IGVsc2UgaWYgKGZyb20gaW5zdGFuY2VvZiBBZGRyZXNzKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5mcm9tQWRkcmVzcyhmcm9tKTtcbiAgfSBlbHNlIGlmIChmcm9tIGluc3RhbmNlb2YgU2NyaXB0KSB7XG4gICAgcmV0dXJuIFNjcmlwdC5mcm9tQnVmZmVyKGZyb20udG9CdWZmZXIoKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZyb20gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5mcm9tU3RyaW5nKGZyb20pO1xuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZnJvbSkgJiYgQXJyYXkuaXNBcnJheShmcm9tLmNodW5rcykpIHtcbiAgICB0aGlzLnNldChmcm9tKTtcbiAgfVxufTtcblxuXG5TY3JpcHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc09iamVjdChvYmopKTtcbiAgJC5jaGVja0FyZ3VtZW50KEFycmF5LmlzQXJyYXkob2JqLmNodW5rcykpO1xuICB0aGlzLmNodW5rcyA9IG9iai5jaHVua3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuU2NyaXB0LmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHNjcmlwdCA9IG5ldyBTY3JpcHQoKTtcbiAgc2NyaXB0LmNodW5rcyA9IFtdO1xuXG4gIHZhciBiciA9IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKTtcbiAgd2hpbGUgKCFici5maW5pc2hlZCgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcGNvZGVudW0gPSBici5yZWFkVUludDgoKTtcblxuICAgICAgdmFyIGxlbiwgYnVmO1xuICAgICAgaWYgKG9wY29kZW51bSA+IDAgJiYgb3Bjb2RlbnVtIDwgT3Bjb2RlLk9QX1BVU0hEQVRBMSkge1xuICAgICAgICBsZW4gPSBvcGNvZGVudW07XG4gICAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgICAgYnVmOiBici5yZWFkKGxlbiksXG4gICAgICAgICAgbGVuOiBsZW4sXG4gICAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMSkge1xuICAgICAgICBsZW4gPSBici5yZWFkVUludDgoKTtcbiAgICAgICAgYnVmID0gYnIucmVhZChsZW4pO1xuICAgICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xuICAgICAgICAgIGJ1ZjogYnVmLFxuICAgICAgICAgIGxlbjogbGVuLFxuICAgICAgICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTIpIHtcbiAgICAgICAgbGVuID0gYnIucmVhZFVJbnQxNkxFKCk7XG4gICAgICAgIGJ1ZiA9IGJyLnJlYWQobGVuKTtcbiAgICAgICAgc2NyaXB0LmNodW5rcy5wdXNoKHtcbiAgICAgICAgICBidWY6IGJ1ZixcbiAgICAgICAgICBsZW46IGxlbixcbiAgICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEE0KSB7XG4gICAgICAgIGxlbiA9IGJyLnJlYWRVSW50MzJMRSgpO1xuICAgICAgICBidWYgPSBici5yZWFkKGxlbik7XG4gICAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgICAgYnVmOiBidWYsXG4gICAgICAgICAgbGVuOiBsZW4sXG4gICAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9wY29kZS5pc09wU3VjY2VzcyhvcGNvZGVudW0pKSB7XG4gICAgICAgIC8vIE9QX1NVQ0NFU1N4IHByb2Nlc3Npbmcgb3ZlcnJpZGVzIGV2ZXJ5dGhpbmcsIGluY2x1ZGluZyBzdGFjayBlbGVtZW50IHNpemUgbGltaXRzXG4gICAgICAgIGJ1ZiA9IGJyLnJlYWRBbGwoKTtcbiAgICAgICAgbGVuID0gYnVmLmxlbmd0aDtcbiAgICAgICAgc2NyaXB0LmNodW5rcy5wdXNoKHtcbiAgICAgICAgICBidWY6IGJ1ZixcbiAgICAgICAgICBsZW46IGxlbixcbiAgICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuU2NyaXB0LkludmFsaWRCdWZmZXIoYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gdGhpcy5jaHVua3NbaV07XG4gICAgdmFyIG9wY29kZW51bSA9IGNodW5rLm9wY29kZW51bTtcbiAgICBidy53cml0ZVVJbnQ4KGNodW5rLm9wY29kZW51bSk7XG4gICAgaWYgKGNodW5rLmJ1Zikge1xuICAgICAgaWYgKG9wY29kZW51bSA8IE9wY29kZS5PUF9QVVNIREFUQTEpIHtcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEExKSB7XG4gICAgICAgIGJ3LndyaXRlVUludDgoY2h1bmsubGVuKTtcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyKSB7XG4gICAgICAgIGJ3LndyaXRlVUludDE2TEUoY2h1bmsubGVuKTtcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEE0KSB7XG4gICAgICAgIGJ3LndyaXRlVUludDMyTEUoY2h1bmsubGVuKTtcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvdWxkIHJlYWNoIGhlcmUgaWYgb3Bjb2RlbnVtIGlzIE9QX1NVQ0NFU1N4IChzZWUgY29tbWVudCBpbiAuZnJvbUJ1ZmZlcilcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYncuY29uY2F0KCk7XG59O1xuXG5TY3JpcHQuZnJvbUFTTSA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgc2NyaXB0ID0gbmV3IFNjcmlwdCgpO1xuICBzY3JpcHQuY2h1bmtzID0gW107XG5cbiAgdmFyIHRva2VucyA9IHN0ci5zcGxpdCgnICcpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICB2YXIgb3Bjb2RlID0gT3Bjb2RlKHRva2VuKTtcbiAgICB2YXIgb3Bjb2RlbnVtID0gb3Bjb2RlLnRvTnVtYmVyKCk7XG5cbiAgICBpZiAob3Bjb2RlbnVtID09IG51bGwpIHtcbiAgICAgIHZhciBidWYgPSBCdWZmZXIuZnJvbSh0b2tlbnNbaV0sICdoZXgnKTtcbiAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgIGJ1ZjogYnVmLFxuICAgICAgICBsZW46IGJ1Zi5sZW5ndGgsXG4gICAgICAgIG9wY29kZW51bTogYnVmLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBpID0gaSArIDE7XG4gICAgfSBlbHNlIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTEgfHxcbiAgICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMiB8fFxuICAgICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEE0KSB7XG4gICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xuICAgICAgICBidWY6IEJ1ZmZlci5mcm9tKHRva2Vuc1tpICsgMl0sICdoZXgnKSxcbiAgICAgICAgbGVuOiBwYXJzZUludCh0b2tlbnNbaSArIDFdKSxcbiAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgIH0pO1xuICAgICAgaSA9IGkgKyAzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xuICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxuICAgICAgfSk7XG4gICAgICBpID0gaSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG5TY3JpcHQuZnJvbUhleCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gbmV3IFNjcmlwdChCdWZmZXIuZnJvbShzdHIsICdoZXgnKSk7XG59O1xuXG5TY3JpcHQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoSlNVdGlsLmlzSGV4YShzdHIpIHx8IHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IFNjcmlwdChCdWZmZXIuZnJvbShzdHIsICdoZXgnKSk7XG4gIH1cbiAgdmFyIHNjcmlwdCA9IG5ldyBTY3JpcHQoKTtcbiAgc2NyaXB0LmNodW5rcyA9IFtdO1xuXG4gIHZhciB0b2tlbnMgPSBzdHIuc3BsaXQoJyAnKTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgdmFyIG9wY29kZSA9IE9wY29kZSh0b2tlbik7XG4gICAgdmFyIG9wY29kZW51bSA9IG9wY29kZS50b051bWJlcigpO1xuXG4gICAgaWYgKG9wY29kZW51bSA9PSBudWxsKSB7XG4gICAgICBvcGNvZGVudW0gPSBwYXJzZUludCh0b2tlbik7XG4gICAgICBpZiAob3Bjb2RlbnVtID4gMCAmJiBvcGNvZGVudW0gPCBPcGNvZGUuT1BfUFVTSERBVEExKSB7XG4gICAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgICAgYnVmOiBCdWZmZXIuZnJvbSh0b2tlbnNbaSArIDFdLnNsaWNlKDIpLCAnaGV4JyksXG4gICAgICAgICAgbGVuOiBvcGNvZGVudW0sXG4gICAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgICAgfSk7XG4gICAgICAgIGkgPSBpICsgMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzY3JpcHQ6ICcgKyBKU09OLnN0cmluZ2lmeShzdHIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMSB8fFxuICAgICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyIHx8XG4gICAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTQpIHtcbiAgICAgIGlmICh0b2tlbnNbaSArIDJdLnNsaWNlKDAsIDIpICE9PSAnMHgnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHVzaGRhdGEgZGF0YSBtdXN0IHN0YXJ0IHdpdGggMHgnKTtcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgIGJ1ZjogQnVmZmVyLmZyb20odG9rZW5zW2kgKyAyXS5zbGljZSgyKSwgJ2hleCcpLFxuICAgICAgICBsZW46IHBhcnNlSW50KHRva2Vuc1tpICsgMV0pLFxuICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxuICAgICAgfSk7XG4gICAgICBpID0gaSArIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXG4gICAgICB9KTtcbiAgICAgIGkgPSBpICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjcmlwdDtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUuX2NodW5rVG9TdHJpbmcgPSBmdW5jdGlvbihjaHVuaywgdHlwZSkge1xuICB2YXIgb3Bjb2RlbnVtID0gY2h1bmsub3Bjb2RlbnVtO1xuICB2YXIgYXNtID0gKHR5cGUgPT09ICdhc20nKTtcbiAgdmFyIHN0ciA9ICcnO1xuICBpZiAoIWNodW5rLmJ1Zikge1xuICAgIC8vIG5vIGRhdGEgY2h1bmtcbiAgICBpZiAodHlwZW9mIE9wY29kZS5yZXZlcnNlTWFwW29wY29kZW51bV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoYXNtKSB7XG4gICAgICAgIC8vIEEgZmV3IGNhc2VzIHdoZXJlIHRoZSBvcGNvZGUgbmFtZSBkaWZmZXJzIGZyb20gcmV2ZXJzZU1hcFxuICAgICAgICAvLyBhc2lkZSBmcm9tIDEgdG8gMTYgZGF0YSBwdXNoZXMuXG4gICAgICAgIGlmIChvcGNvZGVudW0gPT09IDApIHtcbiAgICAgICAgICAvLyBPUF8wIC0+IDBcbiAgICAgICAgICBzdHIgPSBzdHIgKyAnIDAnO1xuICAgICAgICB9IGVsc2UgaWYob3Bjb2RlbnVtID09PSA3OSkge1xuICAgICAgICAgIC8vIE9QXzFORUdBVEUgLT4gMVxuICAgICAgICAgIHN0ciA9IHN0ciArICcgLTEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0ciArICcgJyArIE9wY29kZShvcGNvZGVudW0pLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IHN0ciArICcgJyArIE9wY29kZShvcGNvZGVudW0pLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBudW1zdHIgPSBvcGNvZGVudW0udG9TdHJpbmcoMTYpO1xuICAgICAgaWYgKG51bXN0ci5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIG51bXN0ciA9ICcwJyArIG51bXN0cjtcbiAgICAgIH1cbiAgICAgIGlmIChhc20pIHtcbiAgICAgICAgc3RyID0gc3RyICsgJyAnICsgbnVtc3RyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gc3RyICsgJyAnICsgJzB4JyArIG51bXN0cjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGF0YSBjaHVua1xuICAgIGlmICghYXNtICYmIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMSB8fFxuICAgICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyIHx8XG4gICAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTQpIHtcbiAgICAgIHN0ciA9IHN0ciArICcgJyArIE9wY29kZShvcGNvZGVudW0pLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChjaHVuay5sZW4gPiAwKSB7XG4gICAgICBpZiAoYXNtKSB7XG4gICAgICAgIHN0ciA9IHN0ciArICcgJyArIGNodW5rLmJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBzdHIgKyAnICcgKyBjaHVuay5sZW4gKyAnICcgKyAnMHgnICsgY2h1bmsuYnVmLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUudG9BU00gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gdGhpcy5jaHVua3NbaV07XG4gICAgc3RyICs9IHRoaXMuX2NodW5rVG9TdHJpbmcoY2h1bmssICdhc20nKTtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyKDEpO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RyID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSB0aGlzLmNodW5rc1tpXTtcbiAgICBzdHIgKz0gdGhpcy5fY2h1bmtUb1N0cmluZyhjaHVuayk7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cigxKTtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8U2NyaXB0OiAnICsgdGhpcy50b1N0cmluZygpICsgJz4nO1xufTtcblxuLy8gc2NyaXB0IGNsYXNzaWZpY2F0aW9uIG1ldGhvZHNcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHBheSB0byBwdWJrZXkgaGFzaCBvdXRwdXQgc2NyaXB0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUuaXNQdWJsaWNLZXlIYXNoT3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhISh0aGlzLmNodW5rcy5sZW5ndGggPT09IDUgJiZcbiAgICB0aGlzLmNodW5rc1swXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9EVVAgJiZcbiAgICB0aGlzLmNodW5rc1sxXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9IQVNIMTYwICYmXG4gICAgdGhpcy5jaHVua3NbMl0uYnVmICYmXG4gICAgdGhpcy5jaHVua3NbMl0uYnVmLmxlbmd0aCA9PT0gMjAgJiZcbiAgICB0aGlzLmNodW5rc1szXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9FUVVBTFZFUklGWSAmJlxuICAgIHRoaXMuY2h1bmtzWzRdLm9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0NIRUNLU0lHKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwYXkgdG8gcHVibGljIGtleSBoYXNoIGlucHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzUHVibGljS2V5SGFzaEluID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2lnbmF0dXJlQnVmID0gdGhpcy5jaHVua3NbMF0uYnVmO1xuICAgIHZhciBwdWJrZXlCdWYgPSB0aGlzLmNodW5rc1sxXS5idWY7XG4gICAgaWYgKHNpZ25hdHVyZUJ1ZiAmJlxuICAgICAgICBzaWduYXR1cmVCdWYubGVuZ3RoICYmXG4gICAgICAgIHNpZ25hdHVyZUJ1ZlswXSA9PT0gMHgzMCAmJlxuICAgICAgICBwdWJrZXlCdWYgJiZcbiAgICAgICAgcHVia2V5QnVmLmxlbmd0aFxuICAgICAgICkge1xuICAgICAgdmFyIHZlcnNpb24gPSBwdWJrZXlCdWZbMF07XG4gICAgICBpZiAoKHZlcnNpb24gPT09IDB4MDQgfHxcbiAgICAgICAgICAgdmVyc2lvbiA9PT0gMHgwNiB8fFxuICAgICAgICAgICB2ZXJzaW9uID09PSAweDA3KSAmJiBwdWJrZXlCdWYubGVuZ3RoID09PSA2NSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoKHZlcnNpb24gPT09IDB4MDMgfHwgdmVyc2lvbiA9PT0gMHgwMikgJiYgcHVia2V5QnVmLmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24oKSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLmlzUHVibGljS2V5T3V0KCksICdDYW5cXCd0IHJldHJpZXZlIFB1YmxpY0tleSBmcm9tIGEgbm9uLVBLIG91dHB1dCcpO1xuICByZXR1cm4gdGhpcy5jaHVua3NbMF0uYnVmO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXlIYXNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzUHVibGljS2V5SGFzaE91dCgpKSB7XG4gICAgcmV0dXJuIHRoaXMuY2h1bmtzWzJdLmJ1ZjtcbiAgfSBlbHNlIGlmICh0aGlzLmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSkge1xuICAgIHJldHVybiB0aGlzLmNodW5rc1sxXS5idWY7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1RhcHJvb3QoKSkge1xuICAgIHJldHVybiB0aGlzLmNodW5rc1sxXS5idWY7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHJldHJpZXZlIFB1YmxpY0tleUhhc2ggZnJvbSBhIG5vbi1QS0ggb3V0cHV0Jyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwdWJsaWMga2V5IG91dHB1dCBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5pc1B1YmxpY0tleU91dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09PSAyICYmXG4gICAgICB0aGlzLmNodW5rc1swXS5idWYgJiZcbiAgICAgIHRoaXMuY2h1bmtzWzBdLmJ1Zi5sZW5ndGggJiZcbiAgICAgIHRoaXMuY2h1bmtzWzFdLm9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0NIRUNLU0lHKSB7XG4gICAgdmFyIHB1YmtleUJ1ZiA9IHRoaXMuY2h1bmtzWzBdLmJ1ZjtcbiAgICB2YXIgdmVyc2lvbiA9IHB1YmtleUJ1ZlswXTtcbiAgICB2YXIgaXNWZXJzaW9uID0gZmFsc2U7XG4gICAgaWYgKCh2ZXJzaW9uID09PSAweDA0IHx8XG4gICAgICAgICB2ZXJzaW9uID09PSAweDA2IHx8XG4gICAgICAgICB2ZXJzaW9uID09PSAweDA3KSAmJiBwdWJrZXlCdWYubGVuZ3RoID09PSA2NSkge1xuICAgICAgaXNWZXJzaW9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCh2ZXJzaW9uID09PSAweDAzIHx8IHZlcnNpb24gPT09IDB4MDIpICYmIHB1YmtleUJ1Zi5sZW5ndGggPT09IDMzKSB7XG4gICAgICBpc1ZlcnNpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNWZXJzaW9uKSB7XG4gICAgICByZXR1cm4gUHVibGljS2V5LmlzVmFsaWQocHVia2V5QnVmKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHBheSB0byBwdWJsaWMga2V5IGlucHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzUHVibGljS2V5SW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzaWduYXR1cmVCdWYgPSB0aGlzLmNodW5rc1swXS5idWY7XG4gICAgaWYgKHNpZ25hdHVyZUJ1ZiAmJlxuICAgICAgICBzaWduYXR1cmVCdWYubGVuZ3RoICYmXG4gICAgICAgIHNpZ25hdHVyZUJ1ZlswXSA9PT0gMHgzMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMnNoIG91dHB1dCBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5pc1NjcmlwdEhhc2hPdXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgcmV0dXJuIChidWYubGVuZ3RoID09PSAyMyAmJlxuICAgIGJ1ZlswXSA9PT0gT3Bjb2RlLk9QX0hBU0gxNjAgJiZcbiAgICBidWZbMV0gPT09IDB4MTQgJiZcbiAgICBidWZbYnVmLmxlbmd0aCAtIDFdID09PSBPcGNvZGUuT1BfRVFVQUwpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHAyd3NoIG91dHB1dCBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5pc1dpdG5lc3NTY3JpcHRIYXNoT3V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gIHJldHVybiAoYnVmLmxlbmd0aCA9PT0gMzQgJiYgYnVmWzBdID09PSBPcGNvZGUuT1BfMCAmJiBidWZbMV0gPT09IDMyKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMndwa2ggb3V0cHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgcmV0dXJuIChidWYubGVuZ3RoID09PSAyMiAmJiBidWZbMF0gPT09IE9wY29kZS5PUF8wICYmIGJ1ZlsxXSA9PT0gMjApO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHAydHIgb3V0cHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzVGFwcm9vdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICByZXR1cm4gKGJ1Zi5sZW5ndGggPT09IDM0ICYmIGJ1ZlswXSA9PT0gT3Bjb2RlLk9QXzEgJiYgYnVmWzFdID09PSAzMik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q9fSB2YWx1ZXMgLSBUaGUgcmV0dXJuIHZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlcy52ZXJzaW9uIC0gU2V0IHdpdGggdGhlIHdpdG5lc3MgdmVyc2lvblxuICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlcy5wcm9ncmFtIC0gU2V0IHdpdGggdGhlIHdpdG5lc3MgcHJvZ3JhbVxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMndwa2ggb3V0cHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzV2l0bmVzc1Byb2dyYW0gPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgaWYgKCF2YWx1ZXMpIHtcbiAgICB2YWx1ZXMgPSB7fTtcbiAgfVxuICB2YXIgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICBpZiAoYnVmLmxlbmd0aCA8IDQgfHwgYnVmLmxlbmd0aCA+IDQyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChidWZbMF0gIT09IE9wY29kZS5PUF8wICYmICEoYnVmWzBdID49IE9wY29kZS5PUF8xICYmIGJ1ZlswXSA8PSBPcGNvZGUuT1BfMTYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1ZlsxXSArIDIpIHtcbiAgICB2YWx1ZXMudmVyc2lvbiA9IE9wY29kZS5kZWNvZGVPcE4oYnVmWzBdKTtcbiAgICB2YWx1ZXMucHJvZ3JhbSA9IGJ1Zi5zbGljZSgyLCBidWYubGVuZ3RoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMnNoIGlucHV0IHNjcmlwdFxuICogTm90ZSB0aGF0IHRoZXNlIGFyZSBmcmVxdWVudGx5IGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gcHVia2V5aGFzaGluXG4gKi9cblNjcmlwdC5wcm90b3R5cGUuaXNTY3JpcHRIYXNoSW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciByZWRlZW1DaHVuayA9IHRoaXMuY2h1bmtzW3RoaXMuY2h1bmtzLmxlbmd0aCAtIDFdO1xuICB2YXIgcmVkZWVtQnVmID0gcmVkZWVtQ2h1bmsuYnVmO1xuICBpZiAoIXJlZGVlbUJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciByZWRlZW1TY3JpcHQ7XG4gIHRyeSB7XG4gICAgcmVkZWVtU2NyaXB0ID0gU2NyaXB0LmZyb21CdWZmZXIocmVkZWVtQnVmKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgZXJyb3JzLlNjcmlwdC5JbnZhbGlkQnVmZmVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbiAgdmFyIHR5cGUgPSByZWRlZW1TY3JpcHQuY2xhc3NpZnkoKTtcbiAgcmV0dXJuIHR5cGUgIT09IFNjcmlwdC50eXBlcy5VTktOT1dOO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIG11dGxzaWcgb3V0cHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzTXVsdGlzaWdPdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLmNodW5rcy5sZW5ndGggPiAzICYmXG4gICAgT3Bjb2RlLmlzU21hbGxJbnRPcCh0aGlzLmNodW5rc1swXS5vcGNvZGVudW0pICYmXG4gICAgdGhpcy5jaHVua3Muc2xpY2UoMSwgdGhpcy5jaHVua3MubGVuZ3RoIC0gMikuZXZlcnkoZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmJ1ZiAmJiBCdWZmZXJVdGlsLmlzQnVmZmVyKG9iai5idWYpO1xuICAgIH0pICYmXG4gICAgT3Bjb2RlLmlzU21hbGxJbnRPcCh0aGlzLmNodW5rc1t0aGlzLmNodW5rcy5sZW5ndGggLSAyXS5vcGNvZGVudW0pICYmXG4gICAgdGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMV0ub3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJRyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBtdWx0aXNpZyBpbnB1dCBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5pc011bHRpc2lnSW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2h1bmtzLmxlbmd0aCA+PSAyICYmXG4gICAgdGhpcy5jaHVua3NbMF0ub3Bjb2RlbnVtID09PSAwICYmXG4gICAgdGhpcy5jaHVua3Muc2xpY2UoMSwgdGhpcy5jaHVua3MubGVuZ3RoKS5ldmVyeShmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmouYnVmICYmXG4gICAgICAgIEJ1ZmZlclV0aWwuaXNCdWZmZXIob2JqLmJ1ZikgJiZcbiAgICAgICAgU2lnbmF0dXJlLmlzVHhERVIob2JqLmJ1Zik7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBzdGFuZGFyZCBPUF9SRVRVUk4gb3V0cHV0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUuaXNEYXRhT3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNodW5rcy5sZW5ndGggPj0gMSAmJlxuICAgIHRoaXMuY2h1bmtzWzBdLm9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1JFVFVSTiAmJlxuICAgICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDEgfHxcbiAgICAgICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgdGhpcy5jaHVua3NbMV0uYnVmICYmXG4gICAgICAgIHRoaXMuY2h1bmtzWzFdLmJ1Zi5sZW5ndGggPD0gU2NyaXB0Lk9QX1JFVFVSTl9TVEFOREFSRF9TSVpFICYmXG4gICAgICAgIHRoaXMuY2h1bmtzWzFdLmxlbmd0aCA9PT0gdGhpcy5jaHVua3MubGVuKSk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhc3NvY2lhdGVkIGRhdGEgZm9yIHRoaXMgc2NyaXB0LlxuICogSW4gdGhlIGNhc2Ugb2YgYSBwYXkgdG8gcHVibGljIGtleSBoYXNoLCBQMlNILCBQMldTSCwgb3IgUDJXUEtILCByZXR1cm4gdGhlIGhhc2guXG4gKiBJbiB0aGUgY2FzZSBvZiBhIHN0YW5kYXJkIE9QX1JFVFVSTiwgcmV0dXJuIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5TY3JpcHQucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNEYXRhT3V0KCkgfHwgdGhpcy5pc1NjcmlwdEhhc2hPdXQoKSB8fCB0aGlzLmlzV2l0bmVzc1NjcmlwdEhhc2hPdXQoKSB8fCB0aGlzLmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSB8fCB0aGlzLmlzVGFwcm9vdCgpKSB7XG4gICAgaWYgKHRoaXMuY2h1bmtzWzFdID09IG51bGwpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmNodW5rc1sxXS5idWYpO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5pc1B1YmxpY0tleUhhc2hPdXQoKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmNodW5rc1syXS5idWYpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIHNjcmlwdCB0eXBlIHRvIGdldCBkYXRhIGZyb20nKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoZSBzY3JpcHQgaXMgb25seSBjb21wb3NlZCBvZiBkYXRhIHB1c2hpbmdcbiAqIG9wY29kZXMgb3Igc21hbGwgaW50IG9wY29kZXMgKE9QXzAsIE9QXzEsIC4uLiwgT1BfMTYpXG4gKi9cblNjcmlwdC5wcm90b3R5cGUuaXNQdXNoT25seSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jaHVua3MuZXZlcnkoZnVuY3Rpb24oY2h1bmspIHtcbiAgICByZXR1cm4gY2h1bmsub3Bjb2RlbnVtIDw9IE9wY29kZS5PUF8xNjtcbiAgfSk7XG59O1xuXG5cblNjcmlwdC50eXBlcyA9IHt9O1xuU2NyaXB0LnR5cGVzLlVOS05PV04gPSAnVW5rbm93bic7XG5TY3JpcHQudHlwZXMuUFVCS0VZX09VVCA9ICdQYXkgdG8gcHVibGljIGtleSc7XG5TY3JpcHQudHlwZXMuUFVCS0VZX0lOID0gJ1NwZW5kIGZyb20gcHVibGljIGtleSc7XG5TY3JpcHQudHlwZXMuUFVCS0VZSEFTSF9PVVQgPSAnUGF5IHRvIHB1YmxpYyBrZXkgaGFzaCc7XG5TY3JpcHQudHlwZXMuUFVCS0VZSEFTSF9JTiA9ICdTcGVuZCBmcm9tIHB1YmxpYyBrZXkgaGFzaCc7XG5TY3JpcHQudHlwZXMuU0NSSVBUSEFTSF9PVVQgPSAnUGF5IHRvIHNjcmlwdCBoYXNoJztcblNjcmlwdC50eXBlcy5TQ1JJUFRIQVNIX0lOID0gJ1NwZW5kIGZyb20gc2NyaXB0IGhhc2gnO1xuU2NyaXB0LnR5cGVzLk1VTFRJU0lHX09VVCA9ICdQYXkgdG8gbXVsdGlzaWcnO1xuU2NyaXB0LnR5cGVzLk1VTFRJU0lHX0lOID0gJ1NwZW5kIGZyb20gbXVsdGlzaWcnO1xuU2NyaXB0LnR5cGVzLkRBVEFfT1VUID0gJ0RhdGEgcHVzaCc7XG5cblNjcmlwdC5PUF9SRVRVUk5fU1RBTkRBUkRfU0laRSA9IDgwO1xuXG4vLyBUYWcgZm9yIGlucHV0IGFubmV4LiBJZiB0aGVyZSBhcmUgYXQgbGVhc3QgdHdvIHdpdG5lc3MgZWxlbWVudHMgZm9yIGEgdHJhbnNhY3Rpb24gaW5wdXQsXG4vLyBhbmQgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIGxhc3QgZWxlbWVudCBpcyAweDUwLCB0aGlzIGxhc3QgZWxlbWVudCBpcyBjYWxsZWQgYW5uZXgsIGFuZFxuLy8gaGFzIG1lYW5pbmdzIGluZGVwZW5kZW50IG9mIHRoZSBzY3JpcHRcblNjcmlwdC5BTk5FWF9UQUcgPSAweDUwO1xuXG4vLyBWYWxpZGF0aW9uIHdlaWdodCBwZXIgcGFzc2luZyBzaWduYXR1cmUgKFRhcHNjcmlwdCBvbmx5LCBzZWUgQklQIDM0MikuXG5TY3JpcHQuVkFMSURBVElPTl9XRUlHSFRfUEVSX1NJR09QX1BBU1NFRCA9IDUwO1xuXG4vLyBIb3cgbXVjaCB3ZWlnaHQgYnVkZ2V0IGlzIGFkZGVkIHRvIHRoZSB3aXRuZXNzIHNpemUgKFRhcHNjcmlwdCBvbmx5LCBzZWUgQklQIDM0MikuXG5TY3JpcHQuVkFMSURBVElPTl9XRUlHSFRfT0ZGU0VUID0gNTA7XG5cblxuLyoqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgU2NyaXB0IHR5cGUgaWYgaXQgaXMgYSBrbm93biBmb3JtLFxuICogb3IgU2NyaXB0LlVOS05PV04gaWYgaXQgaXNuJ3RcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5jbGFzc2lmeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5faXNJbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzaWZ5SW5wdXQoKTtcbiAgfSBlbHNlIGlmICh0aGlzLl9pc091dHB1dCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzaWZ5T3V0cHV0KCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG91dHB1dFR5cGUgPSB0aGlzLmNsYXNzaWZ5T3V0cHV0KCk7XG4gICAgcmV0dXJuIG91dHB1dFR5cGUgIT0gU2NyaXB0LnR5cGVzLlVOS05PV04gPyBvdXRwdXRUeXBlIDogdGhpcy5jbGFzc2lmeUlucHV0KCk7XG4gIH1cbn07XG5cblNjcmlwdC5vdXRwdXRJZGVudGlmaWVycyA9IHt9O1xuU2NyaXB0Lm91dHB1dElkZW50aWZpZXJzLlBVQktFWV9PVVQgPSBTY3JpcHQucHJvdG90eXBlLmlzUHVibGljS2V5T3V0O1xuU2NyaXB0Lm91dHB1dElkZW50aWZpZXJzLlBVQktFWUhBU0hfT1VUID0gU2NyaXB0LnByb3RvdHlwZS5pc1B1YmxpY0tleUhhc2hPdXQ7XG5TY3JpcHQub3V0cHV0SWRlbnRpZmllcnMuTVVMVElTSUdfT1VUID0gU2NyaXB0LnByb3RvdHlwZS5pc011bHRpc2lnT3V0O1xuU2NyaXB0Lm91dHB1dElkZW50aWZpZXJzLlNDUklQVEhBU0hfT1VUID0gU2NyaXB0LnByb3RvdHlwZS5pc1NjcmlwdEhhc2hPdXQ7XG5TY3JpcHQub3V0cHV0SWRlbnRpZmllcnMuREFUQV9PVVQgPSBTY3JpcHQucHJvdG90eXBlLmlzRGF0YU91dDtcblxuLyoqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgU2NyaXB0IHR5cGUgaWYgaXQgaXMgYSBrbm93biBmb3JtLFxuICogb3IgU2NyaXB0LlVOS05PV04gaWYgaXQgaXNuJ3RcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5jbGFzc2lmeU91dHB1dCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0eXBlIGluIFNjcmlwdC5vdXRwdXRJZGVudGlmaWVycykge1xuICAgIGlmIChTY3JpcHQub3V0cHV0SWRlbnRpZmllcnNbdHlwZV0uYmluZCh0aGlzKSgpKSB7XG4gICAgICByZXR1cm4gU2NyaXB0LnR5cGVzW3R5cGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gU2NyaXB0LnR5cGVzLlVOS05PV047XG59O1xuXG5TY3JpcHQuaW5wdXRJZGVudGlmaWVycyA9IHt9O1xuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMuUFVCS0VZX0lOID0gU2NyaXB0LnByb3RvdHlwZS5pc1B1YmxpY0tleUluO1xuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMuUFVCS0VZSEFTSF9JTiA9IFNjcmlwdC5wcm90b3R5cGUuaXNQdWJsaWNLZXlIYXNoSW47XG5TY3JpcHQuaW5wdXRJZGVudGlmaWVycy5NVUxUSVNJR19JTiA9IFNjcmlwdC5wcm90b3R5cGUuaXNNdWx0aXNpZ0luO1xuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMuU0NSSVBUSEFTSF9JTiA9IFNjcmlwdC5wcm90b3R5cGUuaXNTY3JpcHRIYXNoSW47XG5cbi8qKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIFNjcmlwdCB0eXBlIGlmIGl0IGlzIGEga25vd24gZm9ybSxcbiAqIG9yIFNjcmlwdC5VTktOT1dOIGlmIGl0IGlzbid0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUuY2xhc3NpZnlJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0eXBlIGluIFNjcmlwdC5pbnB1dElkZW50aWZpZXJzKSB7XG4gICAgaWYgKFNjcmlwdC5pbnB1dElkZW50aWZpZXJzW3R5cGVdLmJpbmQodGhpcykoKSkge1xuICAgICAgcmV0dXJuIFNjcmlwdC50eXBlc1t0eXBlXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFNjcmlwdC50eXBlcy5VTktOT1dOO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiBzY3JpcHQgaXMgb25lIG9mIHRoZSBrbm93biB0eXBlc1xuICovXG5TY3JpcHQucHJvdG90eXBlLmlzU3RhbmRhcmQgPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETzogQWRkIEJJUDYyIGNvbXBsaWFuY2VcbiAgcmV0dXJuIHRoaXMuY2xhc3NpZnkoKSAhPT0gU2NyaXB0LnR5cGVzLlVOS05PV047XG59O1xuXG5cbi8vIFNjcmlwdCBjb25zdHJ1Y3Rpb24gbWV0aG9kc1xuXG4vKipcbiAqIEFkZHMgYSBzY3JpcHQgZWxlbWVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIHNjcmlwdC5cbiAqIEBwYXJhbSB7Kn0gb2JqIGEgc3RyaW5nLCBudW1iZXIsIE9wY29kZSwgQnVmZmVyLCBvciBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7U2NyaXB0fSB0aGlzIHNjcmlwdCBpbnN0YW5jZVxuICovXG5TY3JpcHQucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5fYWRkQnlUeXBlKG9iaiwgdHJ1ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyBhIHNjcmlwdCB3aXRoIGFub3RoZXIgc2NyaXB0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oc2NyaXB0KSB7XG4gICQuY2hlY2tTdGF0ZShzY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQsICdNdXN0IHByb3ZpZGUgYW5vdGhlciBzY3JpcHQnKTtcbiAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCAhPT0gc2NyaXB0LmNodW5rcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKHRoaXMuY2h1bmtzW2ldLmJ1ZikgJiYgIUJ1ZmZlclV0aWwuaXNCdWZmZXIoc2NyaXB0LmNodW5rc1tpXS5idWYpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKHRoaXMuY2h1bmtzW2ldLmJ1ZikgJiYgIUJ1ZmZlclV0aWwuZXF1YWxzKHRoaXMuY2h1bmtzW2ldLmJ1Ziwgc2NyaXB0LmNodW5rc1tpXS5idWYpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNodW5rc1tpXS5vcGNvZGVudW0gIT09IHNjcmlwdC5jaHVua3NbaV0ub3Bjb2RlbnVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgc2NyaXB0IGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgc2NyaXB0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIGEgc3RyaW5nLCBudW1iZXIsIE9wY29kZSwgQnVmZmVyLCBvciBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7U2NyaXB0fSB0aGlzIHNjcmlwdCBpbnN0YW5jZVxuICpcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5fYWRkQnlUeXBlKG9iaiwgZmFsc2UpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUuX2FkZEJ5VHlwZSA9IGZ1bmN0aW9uKG9iaiwgcHJlcGVuZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9hZGRPcGNvZGUob2JqLCBwcmVwZW5kKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2FkZE9wY29kZShvYmosIHByZXBlbmQpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIE9wY29kZSkge1xuICAgIHRoaXMuX2FkZE9wY29kZShvYmosIHByZXBlbmQpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIob2JqKSkge1xuICAgIHRoaXMuX2FkZEJ1ZmZlcihvYmosIHByZXBlbmQpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFNjcmlwdCkge1xuICAgIHRoaXMuY2h1bmtzID0gdGhpcy5jaHVua3MuY29uY2F0KG9iai5jaHVua3MpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy5faW5zZXJ0QXRQb3NpdGlvbihvYmosIHByZXBlbmQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzY3JpcHQgY2h1bmsnKTtcbiAgfVxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5faW5zZXJ0QXRQb3NpdGlvbiA9IGZ1bmN0aW9uKG9wLCBwcmVwZW5kKSB7XG4gIGlmIChwcmVwZW5kKSB7XG4gICAgdGhpcy5jaHVua3MudW5zaGlmdChvcCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaHVua3MucHVzaChvcCk7XG4gIH1cbn07XG5cblNjcmlwdC5wcm90b3R5cGUuX2FkZE9wY29kZSA9IGZ1bmN0aW9uKG9wY29kZSwgcHJlcGVuZCkge1xuICB2YXIgb3A7XG4gIGlmICh0eXBlb2Ygb3Bjb2RlID09PSAnbnVtYmVyJykge1xuICAgIG9wID0gb3Bjb2RlO1xuICB9IGVsc2UgaWYgKG9wY29kZSBpbnN0YW5jZW9mIE9wY29kZSkge1xuICAgIG9wID0gb3Bjb2RlLnRvTnVtYmVyKCk7XG4gIH0gZWxzZSB7XG4gICAgb3AgPSBPcGNvZGUob3Bjb2RlKS50b051bWJlcigpO1xuICB9XG4gIHRoaXMuX2luc2VydEF0UG9zaXRpb24oe1xuICAgIG9wY29kZW51bTogb3BcbiAgfSwgcHJlcGVuZCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5fYWRkQnVmZmVyID0gZnVuY3Rpb24oYnVmLCBwcmVwZW5kKSB7XG4gIHZhciBvcGNvZGVudW07XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuICBpZiAobGVuID49IDAgJiYgbGVuIDwgT3Bjb2RlLk9QX1BVU0hEQVRBMSkge1xuICAgIG9wY29kZW51bSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPCBNYXRoLnBvdygyLCA4KSkge1xuICAgIG9wY29kZW51bSA9IE9wY29kZS5PUF9QVVNIREFUQTE7XG4gIH0gZWxzZSBpZiAobGVuIDwgTWF0aC5wb3coMiwgMTYpKSB7XG4gICAgb3Bjb2RlbnVtID0gT3Bjb2RlLk9QX1BVU0hEQVRBMjtcbiAgfSBlbHNlIGlmIChsZW4gPCBNYXRoLnBvdygyLCAzMikpIHtcbiAgICBvcGNvZGVudW0gPSBPcGNvZGUuT1BfUFVTSERBVEE0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhblxcJ3QgcHVzaCB0aGF0IG11Y2ggZGF0YScpO1xuICB9XG4gIHRoaXMuX2luc2VydEF0UG9zaXRpb24oe1xuICAgIGJ1ZjogYnVmLFxuICAgIGxlbjogbGVuLFxuICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXG4gIH0sIHByZXBlbmQpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUuaGFzQ29kZXNlcGFyYXRvcnMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmNodW5rc1tpXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9DT0RFU0VQQVJBVE9SKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5yZW1vdmVDb2Rlc2VwYXJhdG9ycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2h1bmtzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5jaHVua3NbaV0ub3Bjb2RlbnVtICE9PSBPcGNvZGUuT1BfQ09ERVNFUEFSQVRPUikge1xuICAgICAgY2h1bmtzLnB1c2godGhpcy5jaHVua3NbaV0pO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IGNodW5rcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBoaWdoIGxldmVsIHNjcmlwdCBidWlsZGVyIG1ldGhvZHNcblxuLyoqXG4gKiBAcmV0dXJucyB7U2NyaXB0fSBhIG5ldyBNdWx0aXNpZyBvdXRwdXQgc2NyaXB0IGZvciBnaXZlbiBwdWJsaWMga2V5cyxcbiAqIHJlcXVpcmluZyBtIG9mIHRob3NlIHB1YmxpYyBrZXlzIHRvIHNwZW5kXG4gKiBAcGFyYW0ge1B1YmxpY0tleVtdfSBwdWJsaWNLZXlzIC0gbGlzdCBvZiBhbGwgcHVibGljIGtleXMgY29udHJvbGxpbmcgdGhlIG91dHB1dFxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCAtIGFtb3VudCBvZiByZXF1aXJlZCBzaWduYXR1cmVzIHRvIHNwZW5kIHRoZSBvdXRwdXRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0cyAtIFNldmVyYWwgb3B0aW9uczpcbiAqICAgICAgICAtIG5vU29ydGluZzogZGVmYXVsdHMgdG8gZmFsc2UsIGlmIHRydWUsIGRvbid0IHNvcnQgdGhlIGdpdmVuXG4gKiAgICAgICAgICAgICAgICAgICAgICBwdWJsaWMga2V5cyBiZWZvcmUgY3JlYXRpbmcgdGhlIHNjcmlwdFxuICovXG5TY3JpcHQuYnVpbGRNdWx0aXNpZ091dCA9IGZ1bmN0aW9uKHB1YmxpY0tleXMsIHRocmVzaG9sZCwgb3B0cykge1xuICAkLmNoZWNrQXJndW1lbnQodGhyZXNob2xkIDw9IHB1YmxpY0tleXMubGVuZ3RoLFxuICAgICdOdW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcyBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHB1YmxpYyBrZXlzJyk7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgc2NyaXB0ID0gbmV3IFNjcmlwdCgpO1xuICBzY3JpcHQuYWRkKE9wY29kZS5zbWFsbEludCh0aHJlc2hvbGQpKTtcbiAgcHVibGljS2V5cyA9IHB1YmxpY0tleXMubWFwKFB1YmxpY0tleSk7XG4gIHZhciBzb3J0ZWQgPSBwdWJsaWNLZXlzO1xuICBpZiAoIW9wdHMubm9Tb3J0aW5nKSB7XG4gICAgc29ydGVkID0gXy5zb3J0QnkocHVibGljS2V5cywgZnVuY3Rpb24ocHVibGljS2V5KSB7XG4gICAgICByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9KTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdWJsaWNLZXkgPSBzb3J0ZWRbaV07XG4gICAgc2NyaXB0LmFkZChwdWJsaWNLZXkudG9CdWZmZXIoKSk7XG4gIH1cbiAgc2NyaXB0LmFkZChPcGNvZGUuc21hbGxJbnQocHVibGljS2V5cy5sZW5ndGgpKTtcbiAgc2NyaXB0LmFkZChPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJRyk7XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG5TY3JpcHQuYnVpbGRXaXRuZXNzTXVsdGlzaWdPdXRGcm9tU2NyaXB0ID0gZnVuY3Rpb24oc2NyaXB0KSB7XG4gIGlmIChzY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQpIHtcbiAgICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcbiAgICBzLmFkZChPcGNvZGUuT1BfMCk7XG4gICAgcy5hZGQoSGFzaC5zaGEyNTYoc2NyaXB0LnRvQnVmZmVyKCkpKTtcbiAgICByZXR1cm4gcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIHAyc2ggc2NyaXB0Jyk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBuZXcgTXVsdGlzaWcgaW5wdXQgc2NyaXB0IGZvciB0aGUgZ2l2ZW4gcHVibGljIGtleXMsIHJlcXVpcmluZyBtIG9mIHRob3NlIHB1YmxpYyBrZXlzIHRvIHNwZW5kXG4gKlxuICogQHBhcmFtIHtQdWJsaWNLZXlbXX0gcHVia2V5cyBsaXN0IG9mIGFsbCBwdWJsaWMga2V5cyBjb250cm9sbGluZyB0aGUgb3V0cHV0XG4gKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIGFtb3VudCBvZiByZXF1aXJlZCBzaWduYXR1cmVzIHRvIHNwZW5kIHRoZSBvdXRwdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHNpZ25hdHVyZXMgYW5kIGFycmF5IG9mIHNpZ25hdHVyZSBidWZmZXJzIHRvIGFwcGVuZCB0byB0aGUgc2NyaXB0XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdHMubm9Tb3J0aW5nIGRvbid0IHNvcnQgdGhlIGdpdmVuIHB1YmxpYyBrZXlzIGJlZm9yZSBjcmVhdGluZyB0aGUgc2NyaXB0IChmYWxzZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIHtTY3JpcHQ9fSBvcHRzLmNhY2hlZE11bHRpc2lnIGRvbid0IHJlY2FsY3VsYXRlIHRoZSByZWRlZW1TY3JpcHRcbiAqXG4gKiBAcmV0dXJucyB7U2NyaXB0fVxuICovXG5TY3JpcHQuYnVpbGRNdWx0aXNpZ0luID0gZnVuY3Rpb24ocHVia2V5cywgdGhyZXNob2xkLCBzaWduYXR1cmVzLCBvcHRzKSB7XG4gICQuY2hlY2tBcmd1bWVudChBcnJheS5pc0FycmF5KHB1YmtleXMpKTtcbiAgJC5jaGVja0FyZ3VtZW50KCFpc05hTih0aHJlc2hvbGQpKTtcbiAgJC5jaGVja0FyZ3VtZW50KEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlcykpO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHMgPSBuZXcgU2NyaXB0KCk7XG4gIHMuYWRkKE9wY29kZS5PUF8wKTtcbiAgZm9yIChjb25zdCBzaWduYXR1cmUgb2Ygc2lnbmF0dXJlcykge1xuICAgICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKHNpZ25hdHVyZSksICdTaWduYXR1cmVzIG11c3QgYmUgYW4gYXJyYXkgb2YgQnVmZmVycycpO1xuICAgIC8vIFRPRE86IGFsbG93IHNpZ25hdHVyZXMgdG8gYmUgYW4gYXJyYXkgb2YgU2lnbmF0dXJlIG9iamVjdHNcbiAgICBzLmFkZChzaWduYXR1cmUpO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBBIG5ldyBQMlNIIE11bHRpc2lnIGlucHV0IHNjcmlwdCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXlzLCByZXF1aXJpbmcgbSBvZiB0aG9zZSBwdWJsaWMga2V5cyB0byBzcGVuZFxuICpcbiAqIEBwYXJhbSB7UHVibGljS2V5W119IHB1YmtleXMgbGlzdCBvZiBhbGwgcHVibGljIGtleXMgY29udHJvbGxpbmcgdGhlIG91dHB1dFxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBhbW91bnQgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcyB0byBzcGVuZCB0aGUgb3V0cHV0XG4gKiBAcGFyYW0ge0FycmF5fSBzaWduYXR1cmVzIGFuZCBhcnJheSBvZiBzaWduYXR1cmUgYnVmZmVycyB0byBhcHBlbmQgdG8gdGhlIHNjcmlwdFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRzLm5vU29ydGluZyBkb24ndCBzb3J0IHRoZSBnaXZlbiBwdWJsaWMga2V5cyBiZWZvcmUgY3JlYXRpbmcgdGhlIHNjcmlwdCAoZmFsc2UgYnkgZGVmYXVsdClcbiAqIEBwYXJhbSB7U2NyaXB0PX0gb3B0cy5jYWNoZWRNdWx0aXNpZyBkb24ndCByZWNhbGN1bGF0ZSB0aGUgcmVkZWVtU2NyaXB0XG4gKlxuICogQHJldHVybnMge1NjcmlwdH1cbiAqL1xuU2NyaXB0LmJ1aWxkUDJTSE11bHRpc2lnSW4gPSBmdW5jdGlvbihwdWJrZXlzLCB0aHJlc2hvbGQsIHNpZ25hdHVyZXMsIG9wdHMpIHtcbiAgJC5jaGVja0FyZ3VtZW50KEFycmF5LmlzQXJyYXkocHVia2V5cykpO1xuICAkLmNoZWNrQXJndW1lbnQoIWlzTmFOKHRocmVzaG9sZCkpO1xuICAkLmNoZWNrQXJndW1lbnQoQXJyYXkuaXNBcnJheShzaWduYXR1cmVzKSk7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcbiAgcy5hZGQoT3Bjb2RlLk9QXzApO1xuICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiBzaWduYXR1cmVzKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoc2lnbmF0dXJlKSwgJ1NpZ25hdHVyZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgLy8gVE9ETzogYWxsb3cgc2lnbmF0dXJlcyB0byBiZSBhbiBhcnJheSBvZiBTaWduYXR1cmUgb2JqZWN0c1xuICAgIHMuYWRkKHNpZ25hdHVyZSk7XG4gIH1cbiAgcy5hZGQoKG9wdHMuY2FjaGVkTXVsdGlzaWcgfHwgU2NyaXB0LmJ1aWxkTXVsdGlzaWdPdXQocHVia2V5cywgdGhyZXNob2xkLCBvcHRzKSkudG9CdWZmZXIoKSk7XG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7U2NyaXB0fSBhIG5ldyBwYXkgdG8gcHVibGljIGtleSBoYXNoIG91dHB1dCBmb3IgdGhlIGdpdmVuXG4gKiBhZGRyZXNzIG9yIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSB7KEFkZHJlc3N8UHVibGljS2V5KX0gdG8gLSBkZXN0aW5hdGlvbiBhZGRyZXNzIG9yIHB1YmxpYyBrZXlcbiAqL1xuU2NyaXB0LmJ1aWxkUHVibGljS2V5SGFzaE91dCA9IGZ1bmN0aW9uKHRvKSB7XG4gICQuY2hlY2tBcmd1bWVudCh0byAhPSBudWxsKTtcbiAgJC5jaGVja0FyZ3VtZW50KHRvIGluc3RhbmNlb2YgUHVibGljS2V5IHx8IHRvIGluc3RhbmNlb2YgQWRkcmVzcyB8fCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnKTtcbiAgaWYgKHRvIGluc3RhbmNlb2YgUHVibGljS2V5KSB7XG4gICAgdG8gPSB0by50b0FkZHJlc3MoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XG4gICAgdG8gPSBuZXcgQWRkcmVzcyh0byk7XG4gIH1cbiAgdmFyIHMgPSBuZXcgU2NyaXB0KCk7XG4gIHMuYWRkKE9wY29kZS5PUF9EVVApXG4gICAgLmFkZChPcGNvZGUuT1BfSEFTSDE2MClcbiAgICAuYWRkKHRvLmhhc2hCdWZmZXIpXG4gICAgLmFkZChPcGNvZGUuT1BfRVFVQUxWRVJJRlkpXG4gICAgLmFkZChPcGNvZGUuT1BfQ0hFQ0tTSUcpO1xuICBzLl9uZXR3b3JrID0gdG8ubmV0d29yaztcbiAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTY3JpcHR9IGEgbmV3IHBheSB0byB3aXRuZXNzIHYwIG91dHB1dCBmb3IgdGhlIGdpdmVuXG4gKiBhZGRyZXNzXG4gKiBAcGFyYW0geyhBZGRyZXNzfFB1YmxpY0tleSl9IHRvIC0gZGVzdGluYXRpb24gYWRkcmVzc1xuICovXG5TY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQgPSBmdW5jdGlvbih0bykge1xuICAkLmNoZWNrQXJndW1lbnQodG8gIT0gbnVsbCk7XG4gICQuY2hlY2tBcmd1bWVudCh0byBpbnN0YW5jZW9mIFB1YmxpY0tleSB8fCB0byBpbnN0YW5jZW9mIEFkZHJlc3MgfHwgdHlwZW9mIHRvID09PSAnc3RyaW5nJyk7XG4gIGlmICh0byBpbnN0YW5jZW9mIFB1YmxpY0tleSkge1xuICAgIHRvID0gdG8udG9BZGRyZXNzKG51bGwsIEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRvID09PSAnc3RyaW5nJykge1xuICAgIHRvID0gbmV3IEFkZHJlc3ModG8pO1xuICB9XG4gIHZhciBzID0gbmV3IFNjcmlwdCgpO1xuICBzLmFkZChPcGNvZGUuT1BfMClcbiAgICAuYWRkKHRvLmhhc2hCdWZmZXIpO1xuICBzLl9uZXR3b3JrID0gdG8ubmV0d29yaztcbiAgcmV0dXJuIHM7XG59O1xuXG5cbi8qKlxuICogQnVpbGQgVGFwcm9vdCBzY3JpcHQgb3V0cHV0XG4gKiBAcGFyYW0ge1B1YmxpY0tleXxBZGRyZXNzfSB0byByZWNpcGllbnQncyBwdWJLZXkgb3IgYWRkcmVzc1xuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHNjcmlwdFRyZWUgc2luZ2xlIGxlYWYgb2JqZWN0IE9SIGFycmF5IG9mIGxlYXZlcy4gbGVhZjogeyBzY3JpcHQ6IFN0cmluZywgbGVhZlZlcnNpb246IEludGVnZXIgfVxuICogQHJldHVybnMge1NjcmlwdH1cbiAqL1xuU2NyaXB0LmJ1aWxkV2l0bmVzc1YxT3V0ID0gZnVuY3Rpb24odG8sIHNjcmlwdFRyZWUpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHRvIGluc3RhbmNlb2YgUHVibGljS2V5IHx8IHRvIGluc3RhbmNlb2YgQWRkcmVzcyB8fCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnKTtcbiAgJC5jaGVja0FyZ3VtZW50KCFzY3JpcHRUcmVlIHx8IEFycmF5LmlzQXJyYXkoc2NyaXB0VHJlZSkgfHwgISFzY3JpcHRUcmVlLnNjcmlwdCk7XG5cbiAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdG8gPSBQdWJsaWNLZXkuZnJvbVRhcHJvb3QodG8pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdG8gPSBBZGRyZXNzLmZyb21TdHJpbmcodG8pO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gYnVpbGRUcmVlKHRyZWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgICAgY29uc3QgW2xlZnQsIGxlZnRIXSA9IGJ1aWxkVHJlZSh0cmVlWzBdKTtcbiAgICAgIGNvbnN0IFtyaWdodCwgcmlnaHRIXSA9IGJ1aWxkVHJlZSh0cmVlWzFdKTtcbiAgICAgIGNvbnN0IHJldCA9IFtbW2xlZnRbMF0sIGxlZnRbMV1dLCByaWdodEhdLCBbW3JpZ2h0WzBdLCByaWdodFsxXV0sIGxlZnRIXV07XG4gICAgICBjb25zdCBoV3JpdGVyID0gVGFnZ2VkSGFzaC5UQVBCUkFOQ0g7XG4gICAgICBpZiAobGVmdEguY29tcGFyZShyaWdodEgpID09PSAxKSB7XG4gICAgICAgIGhXcml0ZXIud3JpdGUocmlnaHRIKTtcbiAgICAgICAgaFdyaXRlci53cml0ZShsZWZ0SCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoV3JpdGVyLndyaXRlKGxlZnRIKTtcbiAgICAgICAgaFdyaXRlci53cml0ZShyaWdodEgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtyZXQsIGhXcml0ZXIuZmluYWxpemUoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgbGVhZlZlcnNpb24sIHNjcmlwdCB9ID0gdHJlZTtcbiAgICAgIGNvbnN0IHNjcmlwdEJ1ZiA9IG5ldyBTY3JpcHQoc2NyaXB0KS50b0J1ZmZlcigpO1xuICAgICAgY29uc3QgbGVhZldyaXRlciA9IFRhZ2dlZEhhc2guVEFQTEVBRjtcbiAgICAgIGxlYWZXcml0ZXIud3JpdGVVSW50OChsZWFmVmVyc2lvbik7XG4gICAgICBsZWFmV3JpdGVyLndyaXRlVUludDgoc2NyaXB0QnVmLmxlbmd0aCk7XG4gICAgICBsZWFmV3JpdGVyLndyaXRlKHNjcmlwdEJ1Zik7XG4gICAgICBjb25zdCBoID0gbGVhZldyaXRlci5maW5hbGl6ZSgpO1xuICAgICAgcmV0dXJuIFtbQnVmZmVyLmZyb20oW2xlYWZWZXJzaW9uXSksIHNjcmlwdEJ1Zl0sIGhdO1xuICAgIH1cbiAgfVxuXG4gIGxldCB0YWdnZWRIYXNoID0gbnVsbDtcbiAgaWYgKHNjcmlwdFRyZWUpIHsgXG4gICAgY29uc3QgW18sIGhdID0gYnVpbGRUcmVlKHNjcmlwdFRyZWUpO1xuICAgIHRhZ2dlZEhhc2ggPSBoO1xuICB9XG4gIFxuICBsZXQgdHdlYWtlZFB1YktleTtcbiAgaWYgKHRvIGluc3RhbmNlb2YgUHVibGljS2V5KSB7XG4gICAgdHdlYWtlZFB1YktleSA9IHRvLmNyZWF0ZVRhcFR3ZWFrKHRhZ2dlZEhhc2gpLnR3ZWFrZWRQdWJLZXk7XG4gIH0gZWxzZSB7IC8vIEFkZHJlc3NcbiAgICB0d2Vha2VkUHViS2V5ID0gdG8uaGFzaEJ1ZmZlcjtcbiAgfVxuICBjb25zdCBzID0gbmV3IFNjcmlwdCgpO1xuICBzLmFkZChPcGNvZGUuT1BfMSk7XG4gIHMuYWRkKHR3ZWFrZWRQdWJLZXkpO1xuICByZXR1cm4gcztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJucyB7U2NyaXB0fSBhIG5ldyBwYXkgdG8gcHVibGljIGtleSBvdXRwdXQgZm9yIHRoZSBnaXZlblxuICogIHB1YmxpYyBrZXlcbiAqL1xuU2NyaXB0LmJ1aWxkUHVibGljS2V5T3V0ID0gZnVuY3Rpb24ocHVia2V5KSB7XG4gICQuY2hlY2tBcmd1bWVudChwdWJrZXkgaW5zdGFuY2VvZiBQdWJsaWNLZXkpO1xuICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcbiAgcy5hZGQocHVia2V5LnRvQnVmZmVyKCkpXG4gICAgLmFkZChPcGNvZGUuT1BfQ0hFQ0tTSUcpO1xuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogQHJldHVybnMge1NjcmlwdH0gYSBuZXcgT1BfUkVUVVJOIHNjcmlwdCB3aXRoIGRhdGFcbiAqIEBwYXJhbSB7KHN0cmluZ3xCdWZmZXIpfSBkYXRhIC0gdGhlIGRhdGEgdG8gZW1iZWQgaW4gdGhlIG91dHB1dFxuICogQHBhcmFtIHsoc3RyaW5nKX0gZW5jb2RpbmcgLSB0aGUgdHlwZSBvZiBlbmNvZGluZyBvZiB0aGUgc3RyaW5nXG4gKi9cblNjcmlwdC5idWlsZERhdGFPdXQgPSBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAkLmNoZWNrQXJndW1lbnQoZGF0YSA9PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKGRhdGEpKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZyk7XG4gIH1cbiAgdmFyIHMgPSBuZXcgU2NyaXB0KCk7XG4gIHMuYWRkKE9wY29kZS5PUF9SRVRVUk4pO1xuICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgcy5hZGQoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U2NyaXB0fEFkZHJlc3N9IHNjcmlwdCAtIHRoZSByZWRlZW1TY3JpcHQgZm9yIHRoZSBuZXcgcDJzaCBvdXRwdXQuXG4gKiAgICBJdCBjYW4gYWxzbyBiZSBhIHAyc2ggYWRkcmVzc1xuICogQHJldHVybnMge1NjcmlwdH0gbmV3IHBheSB0byBzY3JpcHQgaGFzaCBzY3JpcHQgZm9yIGdpdmVuIHNjcmlwdFxuICovXG5TY3JpcHQuYnVpbGRTY3JpcHRIYXNoT3V0ID0gZnVuY3Rpb24oc2NyaXB0KSB7XG4gICQuY2hlY2tBcmd1bWVudChzY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQgfHxcbiAgICAoc2NyaXB0IGluc3RhbmNlb2YgQWRkcmVzcyAmJiBzY3JpcHQuaXNQYXlUb1NjcmlwdEhhc2goKSkpO1xuICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcbiAgcy5hZGQoT3Bjb2RlLk9QX0hBU0gxNjApXG4gICAgLmFkZChzY3JpcHQgaW5zdGFuY2VvZiBBZGRyZXNzID8gc2NyaXB0Lmhhc2hCdWZmZXIgOiBIYXNoLnNoYTI1NnJpcGVtZDE2MChzY3JpcHQudG9CdWZmZXIoKSkpXG4gICAgLmFkZChPcGNvZGUuT1BfRVFVQUwpO1xuXG4gIHMuX25ldHdvcmsgPSBzY3JpcHQuX25ldHdvcmsgfHwgc2NyaXB0Lm5ldHdvcms7XG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBzY3JpcHRTaWcgKGEgc2NyaXB0IGZvciBhbiBpbnB1dCkgdGhhdCBzaWducyBhIHB1YmxpYyBrZXkgb3V0cHV0IHNjcmlwdC5cbiAqXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZ25hdHVyZSAtIGEgU2lnbmF0dXJlIG9iamVjdCwgb3IgdGhlIHNpZ25hdHVyZSBpbiBERVIgY2Fub25pY2FsIGVuY29kaW5nXG4gKiBAcGFyYW0ge251bWJlcj19IHNpZ3R5cGUgLSB0aGUgdHlwZSBvZiB0aGUgc2lnbmF0dXJlIChkZWZhdWx0cyB0byBTSUdIQVNIX0FMTClcbiAqL1xuU2NyaXB0LmJ1aWxkUHVibGljS2V5SW4gPSBmdW5jdGlvbihzaWduYXR1cmUsIHNpZ3R5cGUpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNpZ25hdHVyZSB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAkLmNoZWNrQXJndW1lbnQoc2lndHlwZSA9PSBudWxsIHx8ICFpc05hTihzaWd0eXBlKSk7XG4gIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICBzaWduYXR1cmUgPSBzaWduYXR1cmUudG9CdWZmZXIoKTtcbiAgfVxuICB2YXIgc2NyaXB0ID0gbmV3IFNjcmlwdCgpO1xuICBzY3JpcHQuYWRkKEJ1ZmZlclV0aWwuY29uY2F0KFtcbiAgICBzaWduYXR1cmUsXG4gICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ3R5cGUgfHwgU2lnbmF0dXJlLlNJR0hBU0hfQUxMKVxuICBdKSk7XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNjcmlwdFNpZyAoYSBzY3JpcHQgZm9yIGFuIGlucHV0KSB0aGF0IHNpZ25zIGEgcHVibGljIGtleSBoYXNoXG4gKiBvdXRwdXQgc2NyaXB0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ3xQdWJsaWNLZXl9IHB1YmxpY0tleVxuICogQHBhcmFtIHtTaWduYXR1cmV8QnVmZmVyfSBzaWduYXR1cmUgLSBhIFNpZ25hdHVyZSBvYmplY3QsIG9yIHRoZSBzaWduYXR1cmUgaW4gREVSIGNhbm9uaWNhbCBlbmNvZGluZ1xuICogQHBhcmFtIHtudW1iZXI9fSBzaWd0eXBlIC0gdGhlIHR5cGUgb2YgdGhlIHNpZ25hdHVyZSAoZGVmYXVsdHMgdG8gU0lHSEFTSF9BTEwpXG4gKi9cblNjcmlwdC5idWlsZFB1YmxpY0tleUhhc2hJbiA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgc2lnbmF0dXJlLCBzaWd0eXBlKSB7XG4gICQuY2hlY2tBcmd1bWVudChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUgfHwgQnVmZmVyVXRpbC5pc0J1ZmZlcihzaWduYXR1cmUpKTtcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ3R5cGUgPT0gbnVsbCB8fCAhaXNOYU4oc2lndHlwZSkpO1xuICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnRvQnVmZmVyKCk7XG4gIH1cbiAgdmFyIHNjcmlwdCA9IG5ldyBTY3JpcHQoKVxuICAgIC5hZGQoQnVmZmVyVXRpbC5jb25jYXQoW1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ3R5cGUgfHwgU2lnbmF0dXJlLlNJR0hBU0hfQUxMKVxuICAgIF0pKVxuICAgIC5hZGQobmV3IFB1YmxpY0tleShwdWJsaWNLZXkpLnRvQnVmZmVyKCkpO1xuICByZXR1cm4gc2NyaXB0O1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7U2NyaXB0fSBhbiBlbXB0eSBzY3JpcHRcbiAqL1xuU2NyaXB0LmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2NyaXB0KCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTY3JpcHR9IGEgbmV3IHBheSB0byBzY3JpcHQgaGFzaCBzY3JpcHQgdGhhdCBwYXlzIHRvIHRoaXMgc2NyaXB0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUudG9TY3JpcHRIYXNoT3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBTY3JpcHQuYnVpbGRTY3JpcHRIYXNoT3V0KHRoaXMpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtTY3JpcHR9IGFuIG91dHB1dCBzY3JpcHQgYnVpbHQgZnJvbSB0aGUgYWRkcmVzc1xuICovXG5TY3JpcHQuZnJvbUFkZHJlc3MgPSBmdW5jdGlvbihhZGRyZXNzKSB7XG4gIGFkZHJlc3MgPSBBZGRyZXNzKGFkZHJlc3MpO1xuICBpZiAoYWRkcmVzcy5pc1BheVRvU2NyaXB0SGFzaCgpKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5idWlsZFNjcmlwdEhhc2hPdXQoYWRkcmVzcyk7XG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5pc1BheVRvUHVibGljS2V5SGFzaCgpKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5idWlsZFB1YmxpY0tleUhhc2hPdXQoYWRkcmVzcyk7XG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5pc1BheVRvV2l0bmVzc1B1YmxpY0tleUhhc2goKSkge1xuICAgIHJldHVybiBTY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQoYWRkcmVzcyk7XG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5pc1BheVRvV2l0bmVzc1NjcmlwdEhhc2goKSkge1xuICAgIHJldHVybiBTY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQoYWRkcmVzcyk7XG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5pc1BheVRvVGFwcm9vdCgpKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5idWlsZFdpdG5lc3NWMU91dChhZGRyZXNzKTtcbiAgfVxuICB0aHJvdyBuZXcgZXJyb3JzLlNjcmlwdC5VbnJlY29nbml6ZWRBZGRyZXNzKGFkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0aGUgYXNzb2NpYXRlZCBhZGRyZXNzIGluZm9ybWF0aW9uIG9iamVjdFxuICogQHJldHVybiB7QWRkcmVzc3xib29sZWFufVxuICovXG5TY3JpcHQucHJvdG90eXBlLmdldEFkZHJlc3NJbmZvID0gZnVuY3Rpb24ob3B0cykge1xuICBpZiAodGhpcy5faXNJbnB1dCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRJbnB1dEFkZHJlc3NJbmZvKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5faXNPdXRwdXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0T3V0cHV0QWRkcmVzc0luZm8oKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuX2dldE91dHB1dEFkZHJlc3NJbmZvKCk7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0SW5wdXRBZGRyZXNzSW5mbygpO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0aGUgYXNzb2NpYXRlZCBvdXRwdXQgc2NyaXB0UHViS2V5IGFkZHJlc3MgaW5mb3JtYXRpb24gb2JqZWN0XG4gKiBAcmV0dXJuIHtBZGRyZXNzfGJvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5TY3JpcHQucHJvdG90eXBlLl9nZXRPdXRwdXRBZGRyZXNzSW5mbyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5mbyA9IHt9O1xuICBpZiAodGhpcy5pc1NjcmlwdEhhc2hPdXQoKSkge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIGluZm8udHlwZSA9IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoO1xuICB9IGVsc2UgaWYgKHRoaXMuaXNQdWJsaWNLZXlIYXNoT3V0KCkpIHtcbiAgICBpbmZvLmhhc2hCdWZmZXIgPSB0aGlzLmdldERhdGEoKTtcbiAgICBpbmZvLnR5cGUgPSBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaDtcbiAgfSBlbHNlIGlmICh0aGlzLmlzV2l0bmVzc1NjcmlwdEhhc2hPdXQoKSkge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIGluZm8udHlwZSA9IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaDtcbiAgfSBlbHNlIGlmICh0aGlzLmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSkge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIGluZm8udHlwZSA9IEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaDtcbiAgfSBlbHNlIGlmICh0aGlzLmlzVGFwcm9vdCgpKSB7XG4gICAgaW5mby5oYXNoQnVmZmVyID0gdGhpcy5nZXREYXRhKCk7XG4gICAgaW5mby50eXBlID0gQWRkcmVzcy5QYXlUb1RhcHJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBzY3JpcHRTaWcgYWRkcmVzcyBpbmZvcm1hdGlvbiBvYmplY3RcbiAqIEByZXR1cm4ge0FkZHJlc3N8Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cblNjcmlwdC5wcm90b3R5cGUuX2dldElucHV0QWRkcmVzc0luZm8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaWYgKHRoaXMuaXNQdWJsaWNLZXlIYXNoSW4oKSkge1xuICAgIC8vIGhhc2ggdGhlIHB1YmxpY2tleSBmb3VuZCBpbiB0aGUgc2NyaXB0U2lnXG4gICAgaW5mby5oYXNoQnVmZmVyID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAodGhpcy5jaHVua3NbMV0uYnVmKTtcbiAgICBpbmZvLnR5cGUgPSBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaDtcbiAgfSBlbHNlIGlmICh0aGlzLmlzU2NyaXB0SGFzaEluKCkpIHtcbiAgICAvLyBoYXNoIHRoZSByZWRlZW1zY3JpcHQgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgc2NyaXB0U2lnXG4gICAgaW5mby5oYXNoQnVmZmVyID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAodGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMV0uYnVmKTtcbiAgICBpbmZvLnR5cGUgPSBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0d29yaz19IG5ldHdvcmtcbiAqIEByZXR1cm4ge0FkZHJlc3N8Ym9vbGVhbn0gdGhlIGFzc29jaWF0ZWQgYWRkcmVzcyBmb3IgdGhpcyBzY3JpcHQgaWYgcG9zc2libGUsIG9yIGZhbHNlXG4gKi9cblNjcmlwdC5wcm90b3R5cGUudG9BZGRyZXNzID0gZnVuY3Rpb24obmV0d29yaykge1xuICB2YXIgaW5mbyA9IHRoaXMuZ2V0QWRkcmVzc0luZm8oKTtcbiAgaWYgKCFpbmZvKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGluZm8ubmV0d29yayA9IE5ldHdvcmtzLmdldChuZXR3b3JrKSB8fCB0aGlzLl9uZXR3b3JrIHx8IE5ldHdvcmtzLmRlZmF1bHROZXR3b3JrO1xuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mbyk7XG59O1xuXG4vKipcbiAqIEFuYWxvZ291cyB0byBiaXRjb2luZCdzIEZpbmRBbmREZWxldGUuIEZpbmQgYW5kIGRlbGV0ZSBlcXVpdmFsZW50IGNodW5rcyxcbiAqIHR5cGljYWxseSB1c2VkIHdpdGggcHVzaCBkYXRhIGNodW5rcy4gIE5vdGUgdGhhdCB0aGlzIHdpbGwgZmluZCBhbmQgZGVsZXRlXG4gKiBub3QganVzdCB0aGUgc2FtZSBkYXRhLCBidXQgdGhlIHNhbWUgZGF0YSB3aXRoIHRoZSBzYW1lIHB1c2ggZGF0YSBvcCBhc1xuICogcHJvZHVjZWQgYnkgZGVmYXVsdC4gaS5lLiwgaWYgYSBwdXNoZGF0YSBpbiBhIHR4IGRvZXMgbm90IHVzZSB0aGUgbWluaW1hbFxuICogcHVzaGRhdGEgb3AsIHRoZW4gd2hlbiB5b3UgdHJ5IHRvIHJlbW92ZSB0aGUgZGF0YSBpdCBpcyBwdXNoaW5nLCBpdCB3aWxsIG5vdFxuICogYmUgcmVtb3ZlZCwgYmVjYXVzZSB0aGV5IGRvIG5vdCB1c2UgdGhlIHNhbWUgcHVzaGRhdGEgb3AuXG4gKi9cblNjcmlwdC5wcm90b3R5cGUuZmluZEFuZERlbGV0ZSA9IGZ1bmN0aW9uKHNjcmlwdCkge1xuICB2YXIgYnVmID0gc2NyaXB0LnRvQnVmZmVyKCk7XG4gIHZhciBoZXggPSBidWYudG9TdHJpbmcoJ2hleCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNjcmlwdDIgPSBTY3JpcHQoe1xuICAgICAgY2h1bmtzOiBbdGhpcy5jaHVua3NbaV1dXG4gICAgfSk7XG4gICAgdmFyIGJ1ZjIgPSBzY3JpcHQyLnRvQnVmZmVyKCk7XG4gICAgdmFyIGhleDIgPSBidWYyLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAoaGV4ID09PSBoZXgyKSB7XG4gICAgICB0aGlzLmNodW5rcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21lcyBmcm9tIGJpdGNvaW5kJ3Mgc2NyaXB0IGludGVycHJldGVyIENoZWNrTWluaW1hbFB1c2ggZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiB0aGUgY2h1bmsge2l9IGlzIHRoZSBzbWFsbGVzdCB3YXkgdG8gcHVzaCB0aGF0IHBhcnRpY3VsYXIgZGF0YS5cbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5jaGVja01pbmltYWxQdXNoID0gZnVuY3Rpb24oaSkge1xuICB2YXIgY2h1bmsgPSB0aGlzLmNodW5rc1tpXTtcbiAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZjtcbiAgdmFyIG9wY29kZW51bSA9IGNodW5rLm9wY29kZW51bTtcbiAgaWYgKCFidWYpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIENvdWxkIGhhdmUgdXNlZCBPUF8wLlxuICAgIHJldHVybiBvcGNvZGVudW0gPT09IE9wY29kZS5PUF8wO1xuICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPT09IDEgJiYgYnVmWzBdID49IDEgJiYgYnVmWzBdIDw9IDE2KSB7XG4gICAgLy8gQ291bGQgaGF2ZSB1c2VkIE9QXzEgLi4gT1BfMTYuXG4gICAgcmV0dXJuIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QXzEgKyAoYnVmWzBdIC0gMSk7XG4gIH0gZWxzZSBpZiAoYnVmLmxlbmd0aCA9PT0gMSAmJiBidWZbMF0gPT09IDB4ODEpIHtcbiAgICAvLyBDb3VsZCBoYXZlIHVzZWQgT1BfMU5FR0FURVxuICAgIHJldHVybiBvcGNvZGVudW0gPT09IE9wY29kZS5PUF8xTkVHQVRFO1xuICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPD0gNzUpIHtcbiAgICAvLyBDb3VsZCBoYXZlIHVzZWQgYSBkaXJlY3QgcHVzaCAob3Bjb2RlIGluZGljYXRpbmcgbnVtYmVyIG9mIGJ5dGVzIHB1c2hlZCArIHRob3NlIGJ5dGVzKS5cbiAgICByZXR1cm4gb3Bjb2RlbnVtID09PSBidWYubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPD0gMjU1KSB7XG4gICAgLy8gQ291bGQgaGF2ZSB1c2VkIE9QX1BVU0hEQVRBLlxuICAgIHJldHVybiBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTE7XG4gIH0gZWxzZSBpZiAoYnVmLmxlbmd0aCA8PSA2NTUzNSkge1xuICAgIC8vIENvdWxkIGhhdmUgdXNlZCBPUF9QVVNIREFUQTIuXG4gICAgcmV0dXJuIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMjtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBDb21lcyBmcm9tIGJpdGNvaW5kJ3Mgc2NyaXB0IEdldFNpZ09wQ291bnQoYm9vbGVhbikgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlIGN1cnJlbnQgKHRydWUpIG9yIHByZS12ZXJzaW9uLTAuNiAoZmFsc2UpIGxvZ2ljXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBudW1iZXIgb2Ygc2lnbmF0dXJlIG9wZXJhdGlvbnMgcmVxdWlyZWQgYnkgdGhpcyBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVPcGVyYXRpb25zQ291bnQgPSBmdW5jdGlvbihhY2N1cmF0ZSkge1xuICBhY2N1cmF0ZSA9IChhY2N1cmF0ZSA9PSBudWxsID8gdHJ1ZSA6IGFjY3VyYXRlKTtcbiAgdmFyIG4gPSAwO1xuICB2YXIgbGFzdE9wY29kZSA9IE9wY29kZS5PUF9JTlZBTElET1BDT0RFO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIHRoaXMuY2h1bmtzKSB7XG4gICAgdmFyIG9wY29kZSA9IGNodW5rLm9wY29kZW51bTtcbiAgICBpZiAob3Bjb2RlID09IE9wY29kZS5PUF9DSEVDS1NJRyB8fCBvcGNvZGUgPT0gT3Bjb2RlLk9QX0NIRUNLU0lHVkVSSUZZKSB7XG4gICAgICBuKys7XG4gICAgfSBlbHNlIGlmIChvcGNvZGUgPT0gT3Bjb2RlLk9QX0NIRUNLTVVMVElTSUcgfHwgb3Bjb2RlID09IE9wY29kZS5PUF9DSEVDS01VTFRJU0lHVkVSSUZZKSB7XG4gICAgICBpZiAoYWNjdXJhdGUgJiYgbGFzdE9wY29kZSA+PSBPcGNvZGUuT1BfMSAmJiBsYXN0T3Bjb2RlIDw9IE9wY29kZS5PUF8xNikge1xuICAgICAgICBuICs9IE9wY29kZS5kZWNvZGVPcE4obGFzdE9wY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuICs9IDIwO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0T3Bjb2RlID0gb3Bjb2RlO1xuICB9XG4gIHJldHVybiBuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JpcHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/script/script.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js\");\n\nmodule.exports.Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js\");\nmodule.exports.Output = __webpack_require__(/*! ./output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nmodule.exports.UnspentOutput = __webpack_require__(/*! ./unspentoutput */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/unspentoutput.js\");\nmodule.exports.Signature = __webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\nmodule.exports.Sighash = __webpack_require__(/*! ./sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nmodule.exports.SighashWitness = __webpack_require__(/*! ./sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDRIQUF5Qzs7QUFFekMsNEhBQXlDO0FBQ3pDLHlIQUEyQztBQUMzQyw4SUFBeUQ7QUFDekQsa0lBQWlEO0FBQ2pELDRIQUE2QztBQUM3QyxpSkFBMkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5kZXguanM/OGRmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMuSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSByZXF1aXJlKCcuL291dHB1dCcpO1xubW9kdWxlLmV4cG9ydHMuVW5zcGVudE91dHB1dCA9IHJlcXVpcmUoJy4vdW5zcGVudG91dHB1dCcpO1xubW9kdWxlLmV4cG9ydHMuU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbm1vZHVsZS5leHBvcnRzLlNpZ2hhc2ggPSByZXF1aXJlKCcuL3NpZ2hhc2gnKTtcbm1vZHVsZS5leHBvcnRzLlNpZ2hhc2hXaXRuZXNzID0gcmVxdWlyZSgnLi9zaWdoYXNod2l0bmVzcycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\n\nmodule.exports.PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickey.js\");\nmodule.exports.PublicKeyHash = __webpack_require__(/*! ./publickeyhash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js\");\nmodule.exports.MultiSig = __webpack_require__(/*! ./multisig */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisig.js\");\nmodule.exports.MultiSigScriptHash = __webpack_require__(/*! ./multisigscripthash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js\");\nmodule.exports.Taproot = __webpack_require__(/*! ./taproot */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/taproot.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHNIQUFtQzs7QUFFbkMsd0lBQWlEO0FBQ2pELG9KQUF5RDtBQUN6RCxxSUFBK0M7QUFDL0MsbUtBQW1FO0FBQ25FLGtJQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi90cmFuc2FjdGlvbi9pbnB1dC9pbmRleC5qcz81NTAzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5QdWJsaWNLZXkgPSByZXF1aXJlKCcuL3B1YmxpY2tleScpO1xubW9kdWxlLmV4cG9ydHMuUHVibGljS2V5SGFzaCA9IHJlcXVpcmUoJy4vcHVibGlja2V5aGFzaCcpO1xubW9kdWxlLmV4cG9ydHMuTXVsdGlTaWcgPSByZXF1aXJlKCcuL211bHRpc2lnJyk7XG5tb2R1bGUuZXhwb3J0cy5NdWx0aVNpZ1NjcmlwdEhhc2ggPSByZXF1aXJlKCcuL211bHRpc2lnc2NyaXB0aGFzaCcpO1xubW9kdWxlLmV4cG9ydHMuVGFwcm9vdCA9IHJlcXVpcmUoJy4vdGFwcm9vdCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/input.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst errors = __webpack_require__(/*! ../../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar BufferWriter = __webpack_require__(/*! ../../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\n\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nconst SEQUENCE_LOCKTIME_DISABLE_FLAG =  Math.pow(2,31); // (1 << 31);\nconst SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2,22); // (1 << 22);\nconst SEQUENCE_LOCKTIME_MASK = 0xffff;\nconst SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds\nconst SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2,16)-1; // 16 bits \n\n\nfunction Input(params) {\n  if (!(this instanceof Input)) {\n    return new Input(params);\n  }\n  if (params) {\n    return this._fromObject(params);\n  }\n}\n\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\nInput.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;\n\nObject.defineProperty(Input.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    if (this.isNull()) {\n      return null;\n    }\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n    return this._script;\n  }\n});\n\nInput.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  var input = new Input();\n  return input._fromObject(obj);\n};\n\nInput.prototype._fromObject = function(params) {\n  var prevTxId;\n  if (typeof params.prevTxId === 'string' && JSUtil.isHexa(params.prevTxId)) {\n    prevTxId = Buffer.from(params.prevTxId, 'hex');\n  } else {\n    prevTxId = params.prevTxId;\n  }\n  this.witnesses = [];\n  this.output = params.output ?\n    (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;\n  this.prevTxId = prevTxId || params.txidbuf;\n  this.outputIndex = params.outputIndex == null ? params.txoutnum : params.outputIndex;\n  this.sequenceNumber = params.sequenceNumber == null ?\n    (params.seqnum == null ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber;\n  // null script is allowed in setScript()\n  if (params.script === undefined && params.scriptBuffer === undefined) {\n    throw new errors.Transaction.Input.MissingScript();\n  }\n  this.setScript(params.scriptBuffer || params.script);\n  return this;\n};\n\nInput.prototype.toObject = Input.prototype.toJSON = function toObject() {\n  var obj = {\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    sequenceNumber: this.sequenceNumber,\n    script: this._scriptBuffer.toString('hex'),\n  };\n  // add human readable form if input contains valid script\n  if (this.script) {\n    obj.scriptString = this.script.toString();\n  }\n  if (this.output) {\n    obj.output = this.output.toObject();\n  }\n  return obj;\n};\n\nInput.fromBufferReader = function(br) {\n  var input = new Input();\n  input.prevTxId = br.readReverse(32);\n  input.outputIndex = br.readUInt32LE();\n  input._scriptBuffer = br.readVarLengthBuffer();\n  input.sequenceNumber = br.readUInt32LE();\n  // TODO: return different classes according to which input it is\n  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n  return input;\n};\n\nInput.prototype.toBufferWriter = function(writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n  writer.writeReverse(this.prevTxId);\n  writer.writeUInt32LE(this.outputIndex);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  writer.writeUInt32LE(this.sequenceNumber);\n  return writer;\n};\n\nInput.prototype.setScript = function(script) {\n  this._script = null;\n  if (script instanceof Script) {\n    this._script = script;\n    this._script._isInput = true;\n    this._scriptBuffer = script.toBuffer();\n  } else if (JSUtil.isHexa(script)) {\n    // hex string script\n    this._scriptBuffer = Buffer.from(script, 'hex');\n  } else if (_.isString(script)) {\n    // human readable string script\n    this._script = new Script(script);\n    this._script._isInput = true;\n    this._scriptBuffer = this._script.toBuffer();\n  } else if (BufferUtil.isBuffer(script)) {\n    // buffer script\n    this._scriptBuffer = Buffer.from(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n  return this;\n};\n\n/**\n * Retrieve signatures for the provided PrivateKey.\n *\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key to use when signing\n * @param {number} inputIndex - the index of this input in the provided transaction\n * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n *     public key associated with the private key provided\n * @abstract\n */\nInput.prototype.getSignatures = function() {\n  throw new errors.AbstractMethodInvoked(\n    'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' +\n    ' for input: ' + JSON.stringify(this)\n  );\n};\n\nInput.prototype.getSatoshisBuffer = function() {\n  $.checkState(this.output instanceof Output);\n  $.checkState(this.output._satoshisBN);\n  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();\n};\n\n\nInput.prototype.isFullySigned = function() {\n  throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n};\n\nInput.prototype.isFinal = function() {\n  return this.sequenceNumber !== Input.MAXINT;\n};\n\nInput.prototype.addSignature = function() {\n  throw new errors.AbstractMethodInvoked('Input#addSignature');\n};\n\nInput.prototype.clearSignatures = function() {\n  throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n};\n\nInput.prototype.hasWitnesses = function() {\n  if (this.witnesses && this.witnesses.length > 0) {\n    return true;\n  }\n  return false;\n};\n\nInput.prototype.getWitnesses = function() {\n  return this.witnesses;\n};\n\nInput.prototype.setWitnesses = function(witnesses) {\n  this.witnesses = witnesses;\n};\n\nInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script\n  );\n};\n\n/**\n * @returns true if this is a coinbase input (represents no input)\n */\nInput.prototype.isNull = function() {\n  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&\n    this.outputIndex === 0xffffffff;\n};\n\nInput.prototype._estimateSize = function() {\n  return this.toBufferWriter().toBuffer().length;\n};\n\nInput.prototype._getBaseSize = function() {\n  return 32 + 4 + 4; // outpoint (32 + 4) + sequence (4)\n};\n\n\n/**\n * Sets sequence number so that transaction is not valid until the desired seconds\n *  since the transaction is mined\n *\n * @param {Number} time in seconds\n * @return {Transaction} this\n */\nInput.prototype.lockForSeconds = function(seconds) {\n  $.checkArgument(_.isNumber(seconds));\n  if (seconds < 0 ||  seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {\n    throw new errors.Transaction.Input.LockTimeRange();\n  }\n  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));\n\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 \n  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG ;\n  return this;\n};\n\n/**\n * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined\n *\n * @param {Number} height\n * @return {Transaction} this\n */\nInput.prototype.lockUntilBlockHeight = function(heightDiff) {\n  $.checkArgument(_.isNumber(heightDiff));\n  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {\n    throw new errors.Transaction.Input.BlockHeightOutOfRange();\n  }\n  // SEQUENCE_LOCKTIME_TYPE_FLAG = 0\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0\n  this.sequenceNumber = heightDiff ;\n  return this;\n};\n\n\n/**\n *  Returns a semantic version of the input's sequence nLockTime.\n *  @return {Number|Date}\n *  If sequence lock is disabled  it returns null,\n *  if is set to block height lock, returns a block height (number)\n *  else it returns a Date object.\n */\nInput.prototype.getLockTime = function() {\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return null;\n  }\n\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {\n    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);\n    return seconds;\n  } else {\n    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;\n    return blockHeight;\n  }\n};\n\n\n\n\nmodule.exports = Input;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L2lucHV0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMsNEZBQTBCO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQywwRUFBYztBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyxrR0FBNkI7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsc0VBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDBFQUFjO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQywrRUFBWTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsNkVBQVc7O0FBRWhDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsb0RBQW9EO0FBQ3BEO0FBQ0EsMkNBQTJDO0FBQzNDLG1EQUFtRDs7O0FBR25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L2lucHV0LmpzPzRmYTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uLy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2J1ZmZlcicpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvanMnKTtcbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbnZhciBTaWdoYXNoID0gcmVxdWlyZSgnLi4vc2lnaGFzaCcpO1xudmFyIE91dHB1dCA9IHJlcXVpcmUoJy4uL291dHB1dCcpO1xuXG52YXIgTUFYSU5UID0gMHhmZmZmZmZmZjsgLy8gTWF0aC5wb3coMiwgMzIpIC0gMTtcbnZhciBERUZBVUxUX1NFUU5VTUJFUiA9IE1BWElOVDtcbnZhciBERUZBVUxUX0xPQ0tUSU1FX1NFUU5VTUJFUiA9IE1BWElOVCAtIDE7XG52YXIgREVGQVVMVF9SQkZfU0VRTlVNQkVSID0gTUFYSU5UIC0gMjtcbmNvbnN0IFNFUVVFTkNFX0xPQ0tUSU1FX0RJU0FCTEVfRkxBRyA9ICBNYXRoLnBvdygyLDMxKTsgLy8gKDEgPDwgMzEpO1xuY29uc3QgU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHID0gTWF0aC5wb3coMiwyMik7IC8vICgxIDw8IDIyKTtcbmNvbnN0IFNFUVVFTkNFX0xPQ0tUSU1FX01BU0sgPSAweGZmZmY7XG5jb25zdCBTRVFVRU5DRV9MT0NLVElNRV9HUkFOVUxBUklUWSA9IDUxMjsgLy8gNTEyIHNlY29uZHNcbmNvbnN0IFNFUVVFTkNFX0JMT0NLRElGRl9MSU1JVCA9IE1hdGgucG93KDIsMTYpLTE7IC8vIDE2IGJpdHMgXG5cblxuZnVuY3Rpb24gSW5wdXQocGFyYW1zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnB1dCkpIHtcbiAgICByZXR1cm4gbmV3IElucHV0KHBhcmFtcyk7XG4gIH1cbiAgaWYgKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLl9mcm9tT2JqZWN0KHBhcmFtcyk7XG4gIH1cbn1cblxuSW5wdXQuTUFYSU5UID0gTUFYSU5UO1xuSW5wdXQuREVGQVVMVF9TRVFOVU1CRVIgPSBERUZBVUxUX1NFUU5VTUJFUjtcbklucHV0LkRFRkFVTFRfTE9DS1RJTUVfU0VRTlVNQkVSID0gREVGQVVMVF9MT0NLVElNRV9TRVFOVU1CRVI7XG5JbnB1dC5ERUZBVUxUX1JCRl9TRVFOVU1CRVIgPSBERUZBVUxUX1JCRl9TRVFOVU1CRVI7XG5JbnB1dC5TRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcgPSBTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dC5wcm90b3R5cGUsICdzY3JpcHQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NjcmlwdCkge1xuICAgICAgdGhpcy5fc2NyaXB0ID0gbmV3IFNjcmlwdCh0aGlzLl9zY3JpcHRCdWZmZXIpO1xuICAgICAgdGhpcy5fc2NyaXB0Ll9pc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NjcmlwdDtcbiAgfVxufSk7XG5cbklucHV0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3Qob2JqKSk7XG4gIHZhciBpbnB1dCA9IG5ldyBJbnB1dCgpO1xuICByZXR1cm4gaW5wdXQuX2Zyb21PYmplY3Qob2JqKTtcbn07XG5cbklucHV0LnByb3RvdHlwZS5fZnJvbU9iamVjdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcHJldlR4SWQ7XG4gIGlmICh0eXBlb2YgcGFyYW1zLnByZXZUeElkID09PSAnc3RyaW5nJyAmJiBKU1V0aWwuaXNIZXhhKHBhcmFtcy5wcmV2VHhJZCkpIHtcbiAgICBwcmV2VHhJZCA9IEJ1ZmZlci5mcm9tKHBhcmFtcy5wcmV2VHhJZCwgJ2hleCcpO1xuICB9IGVsc2Uge1xuICAgIHByZXZUeElkID0gcGFyYW1zLnByZXZUeElkO1xuICB9XG4gIHRoaXMud2l0bmVzc2VzID0gW107XG4gIHRoaXMub3V0cHV0ID0gcGFyYW1zLm91dHB1dCA/XG4gICAgKHBhcmFtcy5vdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQgPyBwYXJhbXMub3V0cHV0IDogbmV3IE91dHB1dChwYXJhbXMub3V0cHV0KSkgOiB1bmRlZmluZWQ7XG4gIHRoaXMucHJldlR4SWQgPSBwcmV2VHhJZCB8fCBwYXJhbXMudHhpZGJ1ZjtcbiAgdGhpcy5vdXRwdXRJbmRleCA9IHBhcmFtcy5vdXRwdXRJbmRleCA9PSBudWxsID8gcGFyYW1zLnR4b3V0bnVtIDogcGFyYW1zLm91dHB1dEluZGV4O1xuICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gcGFyYW1zLnNlcXVlbmNlTnVtYmVyID09IG51bGwgP1xuICAgIChwYXJhbXMuc2VxbnVtID09IG51bGwgPyBERUZBVUxUX1NFUU5VTUJFUiA6IHBhcmFtcy5zZXFudW0pIDogcGFyYW1zLnNlcXVlbmNlTnVtYmVyO1xuICAvLyBudWxsIHNjcmlwdCBpcyBhbGxvd2VkIGluIHNldFNjcmlwdCgpXG4gIGlmIChwYXJhbXMuc2NyaXB0ID09PSB1bmRlZmluZWQgJiYgcGFyYW1zLnNjcmlwdEJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5JbnB1dC5NaXNzaW5nU2NyaXB0KCk7XG4gIH1cbiAgdGhpcy5zZXRTY3JpcHQocGFyYW1zLnNjcmlwdEJ1ZmZlciB8fCBwYXJhbXMuc2NyaXB0KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUudG9PYmplY3QgPSBJbnB1dC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHZhciBvYmogPSB7XG4gICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQudG9TdHJpbmcoJ2hleCcpLFxuICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxuICAgIHNlcXVlbmNlTnVtYmVyOiB0aGlzLnNlcXVlbmNlTnVtYmVyLFxuICAgIHNjcmlwdDogdGhpcy5fc2NyaXB0QnVmZmVyLnRvU3RyaW5nKCdoZXgnKSxcbiAgfTtcbiAgLy8gYWRkIGh1bWFuIHJlYWRhYmxlIGZvcm0gaWYgaW5wdXQgY29udGFpbnMgdmFsaWQgc2NyaXB0XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIG9iai5zY3JpcHRTdHJpbmcgPSB0aGlzLnNjcmlwdC50b1N0cmluZygpO1xuICB9XG4gIGlmICh0aGlzLm91dHB1dCkge1xuICAgIG9iai5vdXRwdXQgPSB0aGlzLm91dHB1dC50b09iamVjdCgpO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG5JbnB1dC5mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24oYnIpIHtcbiAgdmFyIGlucHV0ID0gbmV3IElucHV0KCk7XG4gIGlucHV0LnByZXZUeElkID0gYnIucmVhZFJldmVyc2UoMzIpO1xuICBpbnB1dC5vdXRwdXRJbmRleCA9IGJyLnJlYWRVSW50MzJMRSgpO1xuICBpbnB1dC5fc2NyaXB0QnVmZmVyID0gYnIucmVhZFZhckxlbmd0aEJ1ZmZlcigpO1xuICBpbnB1dC5zZXF1ZW5jZU51bWJlciA9IGJyLnJlYWRVSW50MzJMRSgpO1xuICAvLyBUT0RPOiByZXR1cm4gZGlmZmVyZW50IGNsYXNzZXMgYWNjb3JkaW5nIHRvIHdoaWNoIGlucHV0IGl0IGlzXG4gIC8vIGUuZzogQ29pbmJhc2VJbnB1dCwgUHVibGljS2V5SGFzaElucHV0LCBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dCwgZXRjLlxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgaWYgKCF3cml0ZXIpIHtcbiAgICB3cml0ZXIgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gIH1cbiAgd3JpdGVyLndyaXRlUmV2ZXJzZSh0aGlzLnByZXZUeElkKTtcbiAgd3JpdGVyLndyaXRlVUludDMyTEUodGhpcy5vdXRwdXRJbmRleCk7XG4gIHZhciBzY3JpcHQgPSB0aGlzLl9zY3JpcHRCdWZmZXI7XG4gIHdyaXRlci53cml0ZVZhcmludE51bShzY3JpcHQubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKHNjcmlwdCk7XG4gIHdyaXRlci53cml0ZVVJbnQzMkxFKHRoaXMuc2VxdWVuY2VOdW1iZXIpO1xuICByZXR1cm4gd3JpdGVyO1xufTtcblxuSW5wdXQucHJvdG90eXBlLnNldFNjcmlwdCA9IGZ1bmN0aW9uKHNjcmlwdCkge1xuICB0aGlzLl9zY3JpcHQgPSBudWxsO1xuICBpZiAoc2NyaXB0IGluc3RhbmNlb2YgU2NyaXB0KSB7XG4gICAgdGhpcy5fc2NyaXB0ID0gc2NyaXB0O1xuICAgIHRoaXMuX3NjcmlwdC5faXNJbnB1dCA9IHRydWU7XG4gICAgdGhpcy5fc2NyaXB0QnVmZmVyID0gc2NyaXB0LnRvQnVmZmVyKCk7XG4gIH0gZWxzZSBpZiAoSlNVdGlsLmlzSGV4YShzY3JpcHQpKSB7XG4gICAgLy8gaGV4IHN0cmluZyBzY3JpcHRcbiAgICB0aGlzLl9zY3JpcHRCdWZmZXIgPSBCdWZmZXIuZnJvbShzY3JpcHQsICdoZXgnKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHNjcmlwdCkpIHtcbiAgICAvLyBodW1hbiByZWFkYWJsZSBzdHJpbmcgc2NyaXB0XG4gICAgdGhpcy5fc2NyaXB0ID0gbmV3IFNjcmlwdChzY3JpcHQpO1xuICAgIHRoaXMuX3NjcmlwdC5faXNJbnB1dCA9IHRydWU7XG4gICAgdGhpcy5fc2NyaXB0QnVmZmVyID0gdGhpcy5fc2NyaXB0LnRvQnVmZmVyKCk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyVXRpbC5pc0J1ZmZlcihzY3JpcHQpKSB7XG4gICAgLy8gYnVmZmVyIHNjcmlwdFxuICAgIHRoaXMuX3NjcmlwdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNjcmlwdCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCB0eXBlOiBzY3JpcHQnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0cmlldmUgc2lnbmF0dXJlcyBmb3IgdGhlIHByb3ZpZGVkIFByaXZhdGVLZXkuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVLZXkgLSB0aGUgcHJpdmF0ZSBrZXkgdG8gdXNlIHdoZW4gc2lnbmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0SW5kZXggLSB0aGUgaW5kZXggb2YgdGhpcyBpbnB1dCBpbiB0aGUgcHJvdmlkZWQgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWdUeXBlIC0gZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYWRkcmVzc0hhc2ggLSBpZiBwcm92aWRlZCwgZG9uJ3QgY2FsY3VsYXRlIHRoZSBoYXNoIG9mIHRoZVxuICogICAgIHB1YmxpYyBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcml2YXRlIGtleSBwcm92aWRlZFxuICogQGFic3RyYWN0XG4gKi9cbklucHV0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBlcnJvcnMuQWJzdHJhY3RNZXRob2RJbnZva2VkKFxuICAgICdUcnlpbmcgdG8gc2lnbiB1bnN1cHBvcnRlZCBvdXRwdXQgdHlwZSAob25seSBQMlBLSCBhbmQgUDJTSCBtdWx0aXNpZyBpbnB1dHMgYXJlIHN1cHBvcnRlZCknICtcbiAgICAnIGZvciBpbnB1dDogJyArIEpTT04uc3RyaW5naWZ5KHRoaXMpXG4gICk7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuZ2V0U2F0b3NoaXNCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgT3V0cHV0KTtcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0Ll9zYXRvc2hpc0JOKTtcbiAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKS53cml0ZVVJbnQ2NExFQk4odGhpcy5vdXRwdXQuX3NhdG9zaGlzQk4pLnRvQnVmZmVyKCk7XG59O1xuXG5cbklucHV0LnByb3RvdHlwZS5pc0Z1bGx5U2lnbmVkID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBlcnJvcnMuQWJzdHJhY3RNZXRob2RJbnZva2VkKCdJbnB1dCNpc0Z1bGx5U2lnbmVkJyk7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuaXNGaW5hbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zZXF1ZW5jZU51bWJlciAhPT0gSW5wdXQuTUFYSU5UO1xufTtcblxuSW5wdXQucHJvdG90eXBlLmFkZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgZXJyb3JzLkFic3RyYWN0TWV0aG9kSW52b2tlZCgnSW5wdXQjYWRkU2lnbmF0dXJlJyk7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBlcnJvcnMuQWJzdHJhY3RNZXRob2RJbnZva2VkKCdJbnB1dCNjbGVhclNpZ25hdHVyZXMnKTtcbn07XG5cbklucHV0LnByb3RvdHlwZS5oYXNXaXRuZXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMud2l0bmVzc2VzICYmIHRoaXMud2l0bmVzc2VzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuZ2V0V2l0bmVzc2VzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndpdG5lc3Nlcztcbn07XG5cbklucHV0LnByb3RvdHlwZS5zZXRXaXRuZXNzZXMgPSBmdW5jdGlvbih3aXRuZXNzZXMpIHtcbiAgdGhpcy53aXRuZXNzZXMgPSB3aXRuZXNzZXM7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcbiAgLy8gRklYTUU6IFJlZmFjdG9yIHNpZ25hdHVyZSBzbyB0aGlzIGlzIG5vdCBuZWNlc3NhcnlcbiAgc2lnbmF0dXJlLnNpZ25hdHVyZS5uaGFzaHR5cGUgPSBzaWduYXR1cmUuc2lndHlwZTtcbiAgcmV0dXJuIFNpZ2hhc2gudmVyaWZ5KFxuICAgIHRyYW5zYWN0aW9uLFxuICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgc2lnbmF0dXJlLnB1YmxpY0tleSxcbiAgICBzaWduYXR1cmUuaW5wdXRJbmRleCxcbiAgICB0aGlzLm91dHB1dC5zY3JpcHRcbiAgKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgY29pbmJhc2UgaW5wdXQgKHJlcHJlc2VudHMgbm8gaW5wdXQpXG4gKi9cbklucHV0LnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucHJldlR4SWQudG9TdHJpbmcoJ2hleCcpID09PSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgJiZcbiAgICB0aGlzLm91dHB1dEluZGV4ID09PSAweGZmZmZmZmZmO1xufTtcblxuSW5wdXQucHJvdG90eXBlLl9lc3RpbWF0ZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXJXcml0ZXIoKS50b0J1ZmZlcigpLmxlbmd0aDtcbn07XG5cbklucHV0LnByb3RvdHlwZS5fZ2V0QmFzZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDMyICsgNCArIDQ7IC8vIG91dHBvaW50ICgzMiArIDQpICsgc2VxdWVuY2UgKDQpXG59O1xuXG5cbi8qKlxuICogU2V0cyBzZXF1ZW5jZSBudW1iZXIgc28gdGhhdCB0cmFuc2FjdGlvbiBpcyBub3QgdmFsaWQgdW50aWwgdGhlIGRlc2lyZWQgc2Vjb25kc1xuICogIHNpbmNlIHRoZSB0cmFuc2FjdGlvbiBpcyBtaW5lZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGluIHNlY29uZHNcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzXG4gKi9cbklucHV0LnByb3RvdHlwZS5sb2NrRm9yU2Vjb25kcyA9IGZ1bmN0aW9uKHNlY29uZHMpIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNOdW1iZXIoc2Vjb25kcykpO1xuICBpZiAoc2Vjb25kcyA8IDAgfHwgIHNlY29uZHMgPj0gU0VRVUVOQ0VfTE9DS1RJTUVfR1JBTlVMQVJJVFkgKiBTRVFVRU5DRV9MT0NLVElNRV9NQVNLKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5JbnB1dC5Mb2NrVGltZVJhbmdlKCk7XG4gIH1cbiAgc2Vjb25kcyA9IHBhcnNlSW50KE1hdGguZmxvb3Ioc2Vjb25kcyAvIFNFUVVFTkNFX0xPQ0tUSU1FX0dSQU5VTEFSSVRZKSk7XG5cbiAgLy8gU0VRVUVOQ0VfTE9DS1RJTUVfRElTQUJMRV9GTEFHID0gMSBcbiAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IHNlY29uZHMgfCBTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcgO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBzZXF1ZW5jZSBudW1iZXIgc28gdGhhdCB0cmFuc2FjdGlvbiBpcyBub3QgdmFsaWQgdW50aWwgdGhlIGRlc2lyZWQgYmxvY2sgaGVpZ2h0IGRpZmZlcm5lY2Ugc2luY2UgdGhlIHR4IGlzIG1pbmVkXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcbiAqL1xuSW5wdXQucHJvdG90eXBlLmxvY2tVbnRpbEJsb2NrSGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0RGlmZikge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc051bWJlcihoZWlnaHREaWZmKSk7XG4gIGlmIChoZWlnaHREaWZmIDwgMCB8fCBoZWlnaHREaWZmID49IFNFUVVFTkNFX0JMT0NLRElGRl9MSU1JVCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW5wdXQuQmxvY2tIZWlnaHRPdXRPZlJhbmdlKCk7XG4gIH1cbiAgLy8gU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHID0gMFxuICAvLyBTRVFVRU5DRV9MT0NLVElNRV9ESVNBQkxFX0ZMQUcgPSAwXG4gIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSBoZWlnaHREaWZmIDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogIFJldHVybnMgYSBzZW1hbnRpYyB2ZXJzaW9uIG9mIHRoZSBpbnB1dCdzIHNlcXVlbmNlIG5Mb2NrVGltZS5cbiAqICBAcmV0dXJuIHtOdW1iZXJ8RGF0ZX1cbiAqICBJZiBzZXF1ZW5jZSBsb2NrIGlzIGRpc2FibGVkICBpdCByZXR1cm5zIG51bGwsXG4gKiAgaWYgaXMgc2V0IHRvIGJsb2NrIGhlaWdodCBsb2NrLCByZXR1cm5zIGEgYmxvY2sgaGVpZ2h0IChudW1iZXIpXG4gKiAgZWxzZSBpdCByZXR1cm5zIGEgRGF0ZSBvYmplY3QuXG4gKi9cbklucHV0LnByb3RvdHlwZS5nZXRMb2NrVGltZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zZXF1ZW5jZU51bWJlciAmIFNFUVVFTkNFX0xPQ0tUSU1FX0RJU0FCTEVfRkxBRykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuc2VxdWVuY2VOdW1iZXIgJiBTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcpIHtcbiAgICB2YXIgc2Vjb25kcyA9IFNFUVVFTkNFX0xPQ0tUSU1FX0dSQU5VTEFSSVRZICogKHRoaXMuc2VxdWVuY2VOdW1iZXIgJiBTRVFVRU5DRV9MT0NLVElNRV9NQVNLKTtcbiAgICByZXR1cm4gc2Vjb25kcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmxvY2tIZWlnaHQgPSB0aGlzLnNlcXVlbmNlTnVtYmVyICYgU0VRVUVOQ0VfTE9DS1RJTUVfTUFTSztcbiAgICByZXR1cm4gYmxvY2tIZWlnaHQ7XG4gIH1cbn07XG5cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gSW5wdXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisig.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/multisig.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\nvar Transaction = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js\");\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar PublicKey = __webpack_require__(/*! ../../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\n\n/**\n * @constructor\n */\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),\n    'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n  _.each(this.publicKeys, function(publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function(signatures) {\n  return _.map(signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function() {\n  return _.map(this.signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\n/**\n * Get signatures for this input\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer} merkleRoot - unused for this input type\n * @return {Array<TransactionSignature>}\n */\nMultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  const results = [];\n  for (const publicKey of this.publicKeys || []) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\n        sigtype: sigtype\n      }));\n    }\n  }\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()], \"Signature Undefined\"),\n    'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), \"Invalid Signature\");\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function() {\n  this.setScript(Script.buildMultisigIn(\n    this.publicKeys,\n    this.threshold,\n    this._createSignatures()\n  ));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function() {\n  return _.map(\n    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),\n    // Future signature types may need refactor of toDER\n    function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    }\n  );\n};\n\nMultiSigInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function() {\n  return _.reduce(this.signatures, function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function() {\n  var self = this;\n  return _.filter(this.publicKeys, function(publicKey) {\n    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script\n  );\n};\n\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @returns {TransactionSignature[]}\n */\nMultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(\n          transaction,\n          signature.signature,\n          signature.publicKey,\n          signature.inputIndex,\n          input.output.script\n      );\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function() {\n  return this._getBaseSize() + MultiSigInput.OPCODES_SIZE +\n    this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L211bHRpc2lnLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixlQUFlLG1CQUFPLENBQUMsb0ZBQVU7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsdUZBQWdCO0FBQzFDLFlBQVksbUJBQU8sQ0FBQyxnRkFBUztBQUM3QixhQUFhLG1CQUFPLENBQUMsNkVBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLDRGQUEwQjs7QUFFMUMsYUFBYSxtQkFBTyxDQUFDLDBFQUFjO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHdGQUF3QjtBQUNoRCxjQUFjLG1CQUFPLENBQUMsK0VBQVk7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjtBQUM1QywyQkFBMkIsbUJBQU8sQ0FBQyxtRkFBYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhEQUE4RCxtQ0FBbUM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDhCQUE4QjtBQUM5RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsbUNBQW1DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsZ0NBQWdDO0FBQ2hDLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvbXVsdGlzaWcuanM/YWRjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi4vdHJhbnNhY3Rpb24nKTtcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuLi9vdXRwdXQnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi8uLi9jcnlwdG8vc2lnbmF0dXJlJyk7XG52YXIgU2lnaGFzaCA9IHJlcXVpcmUoJy4uL3NpZ2hhc2gnKTtcbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuLi8uLi9wdWJsaWNrZXknKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9idWZmZXInKTtcbnZhciBUcmFuc2FjdGlvblNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL3NpZ25hdHVyZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNdWx0aVNpZ0lucHV0KGlucHV0LCBwdWJrZXlzLCB0aHJlc2hvbGQsIHNpZ25hdHVyZXMsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcHVia2V5cyA9IHB1YmtleXMgfHwgaW5wdXQucHVibGljS2V5cztcbiAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IGlucHV0LnRocmVzaG9sZDtcbiAgc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXMgfHwgaW5wdXQuc2lnbmF0dXJlcztcbiAgaWYgKG9wdHMubm9Tb3J0aW5nKSB7XG4gICAgdGhpcy5wdWJsaWNLZXlzID0gcHVia2V5c1xuICB9IGVsc2UgIHtcbiAgICB0aGlzLnB1YmxpY0tleXMgPSBfLnNvcnRCeShwdWJrZXlzLCBmdW5jdGlvbihwdWJsaWNLZXkpIHsgcmV0dXJuIHB1YmxpY0tleS50b1N0cmluZygnaGV4Jyk7IH0pO1xuICB9XG4gICQuY2hlY2tTdGF0ZShTY3JpcHQuYnVpbGRNdWx0aXNpZ091dCh0aGlzLnB1YmxpY0tleXMsIHRocmVzaG9sZCkuZXF1YWxzKHRoaXMub3V0cHV0LnNjcmlwdCksXG4gICAgJ1Byb3ZpZGVkIHB1YmxpYyBrZXlzIGRvblxcJ3QgbWF0Y2ggdG8gdGhlIHByb3ZpZGVkIG91dHB1dCBzY3JpcHQnKTtcbiAgdGhpcy5wdWJsaWNLZXlJbmRleCA9IHt9O1xuICBfLmVhY2godGhpcy5wdWJsaWNLZXlzLCBmdW5jdGlvbihwdWJsaWNLZXksIGluZGV4KSB7XG4gICAgc2VsZi5wdWJsaWNLZXlJbmRleFtwdWJsaWNLZXkudG9TdHJpbmcoKV0gPSBpbmRleDtcbiAgfSk7XG4gIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAvLyBFbXB0eSBhcnJheSBvZiBzaWduYXR1cmVzXG4gIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXMgPyB0aGlzLl9kZXNlcmlhbGl6ZVNpZ25hdHVyZXMoc2lnbmF0dXJlcykgOiBuZXcgQXJyYXkodGhpcy5wdWJsaWNLZXlzLmxlbmd0aCk7XG59XG5pbmhlcml0cyhNdWx0aVNpZ0lucHV0LCBJbnB1dCk7XG5cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvYmogPSBJbnB1dC5wcm90b3R5cGUudG9PYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgb2JqLnRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkO1xuICBvYmoucHVibGljS2V5cyA9IF8ubWFwKHRoaXMucHVibGljS2V5cywgZnVuY3Rpb24ocHVibGljS2V5KSB7IHJldHVybiBwdWJsaWNLZXkudG9TdHJpbmcoKTsgfSk7XG4gIG9iai5zaWduYXR1cmVzID0gdGhpcy5fc2VyaWFsaXplU2lnbmF0dXJlcygpO1xuICByZXR1cm4gb2JqO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuX2Rlc2VyaWFsaXplU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKHNpZ25hdHVyZXMpIHtcbiAgcmV0dXJuIF8ubWFwKHNpZ25hdHVyZXMsIGZ1bmN0aW9uKHNpZ25hdHVyZSkge1xuICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIH0pO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuX3NlcmlhbGl6ZVNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8ubWFwKHRoaXMuc2lnbmF0dXJlcywgZnVuY3Rpb24oc2lnbmF0dXJlKSB7XG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzaWduYXR1cmUudG9PYmplY3QoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBzaWduYXR1cmVzIGZvciB0aGlzIGlucHV0XG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAtIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBzaWduZWRcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSB3aXRoIHdoaWNoIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGlucHV0IGluIHRoZSB0cmFuc2FjdGlvbiBpbnB1dCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWd0eXBlIC0gdGhlIHR5cGUgb2Ygc2lnbmF0dXJlLCBkZWZhdWx0cyB0byBTaWduYXR1cmUuU0lHSEFTSF9BTExcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoRGF0YSAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCBERVBSRUNBVEVEIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVya2xlUm9vdCAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLmdldFNpZ25hdHVyZXMgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgaW5kZXgsIHNpZ3R5cGUsIGhhc2hEYXRhLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLm91dHB1dCBpbnN0YW5jZW9mIE91dHB1dCk7XG4gIHNpZ3R5cGUgPSBzaWd0eXBlIHx8IFNpZ25hdHVyZS5TSUdIQVNIX0FMTDtcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcblxuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAoY29uc3QgcHVibGljS2V5IG9mIHRoaXMucHVibGljS2V5cyB8fCBbXSkge1xuICAgIGlmIChwdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHJpdmF0ZUtleS5wdWJsaWNLZXkudG9TdHJpbmcoKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKG5ldyBUcmFuc2FjdGlvblNpZ25hdHVyZSh7XG4gICAgICAgIHB1YmxpY0tleTogcHJpdmF0ZUtleS5wdWJsaWNLZXksXG4gICAgICAgIHByZXZUeElkOiB0aGlzLnByZXZUeElkLFxuICAgICAgICBvdXRwdXRJbmRleDogdGhpcy5vdXRwdXRJbmRleCxcbiAgICAgICAgaW5wdXRJbmRleDogaW5kZXgsXG4gICAgICAgIHNpZ25hdHVyZTogU2lnaGFzaC5zaWduKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBzaWd0eXBlLCBpbmRleCwgdGhpcy5vdXRwdXQuc2NyaXB0KSxcbiAgICAgICAgc2lndHlwZTogc2lndHlwZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuYWRkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICAkLmNoZWNrU3RhdGUoIXRoaXMuaXNGdWxseVNpZ25lZCgpLCAnQWxsIG5lZWRlZCBzaWduYXR1cmVzIGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkJyk7XG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZCh0aGlzLnB1YmxpY0tleUluZGV4W3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKV0sIFwiU2lnbmF0dXJlIFVuZGVmaW5lZFwiKSxcbiAgICAnU2lnbmF0dXJlIGhhcyBubyBtYXRjaGluZyBwdWJsaWMga2V5Jyk7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLmlzVmFsaWRTaWduYXR1cmUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCksIFwiSW52YWxpZCBTaWduYXR1cmVcIik7XG4gIHRoaXMuc2lnbmF0dXJlc1t0aGlzLnB1YmxpY0tleUluZGV4W3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKV1dID0gc2lnbmF0dXJlO1xuICB0aGlzLl91cGRhdGVTY3JpcHQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5fdXBkYXRlU2NyaXB0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2V0U2NyaXB0KFNjcmlwdC5idWlsZE11bHRpc2lnSW4oXG4gICAgdGhpcy5wdWJsaWNLZXlzLFxuICAgIHRoaXMudGhyZXNob2xkLFxuICAgIHRoaXMuX2NyZWF0ZVNpZ25hdHVyZXMoKVxuICApKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5fY3JlYXRlU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXy5tYXAoXG4gICAgXy5maWx0ZXIodGhpcy5zaWduYXR1cmVzLCBmdW5jdGlvbihzaWduYXR1cmUpIHsgcmV0dXJuICFfLmlzVW5kZWZpbmVkKHNpZ25hdHVyZSk7IH0pLFxuICAgIC8vIEZ1dHVyZSBzaWduYXR1cmUgdHlwZXMgbWF5IG5lZWQgcmVmYWN0b3Igb2YgdG9ERVJcbiAgICBmdW5jdGlvbihzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiBCdWZmZXJVdGlsLmNvbmNhdChbXG4gICAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9ERVIoKSxcbiAgICAgICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ25hdHVyZS5zaWd0eXBlKVxuICAgICAgXSk7XG4gICAgfVxuICApO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2lnbmF0dXJlcyA9IG5ldyBBcnJheSh0aGlzLnB1YmxpY0tleXMubGVuZ3RoKTtcbiAgdGhpcy5fdXBkYXRlU2NyaXB0KCk7XG59O1xuXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5pc0Z1bGx5U2lnbmVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvdW50U2lnbmF0dXJlcygpID09PSB0aGlzLnRocmVzaG9sZDtcbn07XG5cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLmNvdW50TWlzc2luZ1NpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGhyZXNob2xkIC0gdGhpcy5jb3VudFNpZ25hdHVyZXMoKTtcbn07XG5cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLmNvdW50U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXy5yZWR1Y2UodGhpcy5zaWduYXR1cmVzLCBmdW5jdGlvbihzdW0sIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBzdW0gKyAoISFzaWduYXR1cmUpO1xuICB9LCAwKTtcbn07XG5cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLnB1YmxpY0tleXNXaXRob3V0U2lnbmF0dXJlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIF8uZmlsdGVyKHRoaXMucHVibGljS2V5cywgZnVuY3Rpb24ocHVibGljS2V5KSB7XG4gICAgcmV0dXJuICEoc2VsZi5zaWduYXR1cmVzW3NlbGYucHVibGljS2V5SW5kZXhbcHVibGljS2V5LnRvU3RyaW5nKCldXSk7XG4gIH0pO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcbiAgLy8gRklYTUU6IFJlZmFjdG9yIHNpZ25hdHVyZSBzbyB0aGlzIGlzIG5vdCBuZWNlc3NhcnlcbiAgc2lnbmF0dXJlLnNpZ25hdHVyZS5uaGFzaHR5cGUgPSBzaWduYXR1cmUuc2lndHlwZTtcbiAgcmV0dXJuIFNpZ2hhc2gudmVyaWZ5KFxuICAgIHRyYW5zYWN0aW9uLFxuICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgc2lnbmF0dXJlLnB1YmxpY0tleSxcbiAgICBzaWduYXR1cmUuaW5wdXRJbmRleCxcbiAgICB0aGlzLm91dHB1dC5zY3JpcHRcbiAgKTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IHNpZ25hdHVyZXNcbiAqIEBwYXJhbSB7UHVibGljS2V5W119IHB1YmxpY0tleXNcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGlucHV0SW5kZXhcbiAqIEBwYXJhbSB7SW5wdXR9IGlucHV0XG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCBERVBSRUNBVEVEIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInIChmdXR1cmUgc2lnbmluZyBtZXRob2QpXG4gKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TaWduYXR1cmVbXX1cbiAqL1xuTXVsdGlTaWdJbnB1dC5ub3JtYWxpemVTaWduYXR1cmVzID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIGlucHV0LCBpbnB1dEluZGV4LCBzaWduYXR1cmVzLCBwdWJsaWNLZXlzLCBzaWduaW5nTWV0aG9kKSB7XG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXG5cbiAgcmV0dXJuIHB1YmxpY0tleXMubWFwKGZ1bmN0aW9uIChwdWJLZXkpIHtcbiAgICB2YXIgc2lnbmF0dXJlTWF0Y2ggPSBudWxsO1xuICAgIHNpZ25hdHVyZXMgPSBzaWduYXR1cmVzLmZpbHRlcihmdW5jdGlvbiAoc2lnbmF0dXJlQnVmZmVyKSB7XG4gICAgICBpZiAoc2lnbmF0dXJlTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaWduYXR1cmUgPSBuZXcgVHJhbnNhY3Rpb25TaWduYXR1cmUoe1xuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoc2lnbmF0dXJlQnVmZmVyKSxcbiAgICAgICAgcHVibGljS2V5OiBwdWJLZXksXG4gICAgICAgIHByZXZUeElkOiBpbnB1dC5wcmV2VHhJZCxcbiAgICAgICAgb3V0cHV0SW5kZXg6IGlucHV0Lm91dHB1dEluZGV4LFxuICAgICAgICBpbnB1dEluZGV4OiBpbnB1dEluZGV4LFxuICAgICAgICBzaWd0eXBlOiBTaWduYXR1cmUuU0lHSEFTSF9BTExcbiAgICAgIH0pO1xuXG4gICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLm5oYXNodHlwZSA9IHNpZ25hdHVyZS5zaWd0eXBlO1xuICAgICAgdmFyIGlzTWF0Y2ggPSBTaWdoYXNoLnZlcmlmeShcbiAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxuICAgICAgICAgIHNpZ25hdHVyZS5wdWJsaWNLZXksXG4gICAgICAgICAgc2lnbmF0dXJlLmlucHV0SW5kZXgsXG4gICAgICAgICAgaW5wdXQub3V0cHV0LnNjcmlwdFxuICAgICAgKTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgc2lnbmF0dXJlTWF0Y2ggPSBzaWduYXR1cmU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2lnbmF0dXJlTWF0Y2ggPyBzaWduYXR1cmVNYXRjaCA6IG51bGw7XG4gIH0pO1xufTtcblxuTXVsdGlTaWdJbnB1dC5PUENPREVTX1NJWkUgPSAxOyAvLyAwXG5NdWx0aVNpZ0lucHV0LlNJR05BVFVSRV9TSVpFID0gNzM7IC8vIHNpemUgKDEpICsgREVSICg8PTcyKVxuXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nZXRCYXNlU2l6ZSgpICsgTXVsdGlTaWdJbnB1dC5PUENPREVTX1NJWkUgK1xuICAgIHRoaXMudGhyZXNob2xkICogTXVsdGlTaWdJbnB1dC5TSUdOQVRVUkVfU0laRTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGlTaWdJbnB1dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js":
/*!******************************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* jshint maxparams:5 */\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar Address = __webpack_require__(/*! ../../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar SighashWitness = __webpack_require__(/*! ../sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\nvar BufferWriter = __webpack_require__(/*! ../../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\n\n/**\n * @constructor\n */\nfunction MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {\n  /* jshint maxstatements:20 */\n  opts = opts || {};\n  Input.apply(this, arguments);\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys;\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);\n  var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);\n  if (nested.equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToWitnessScriptHash;\n  } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {\n    this.nestedWitness = true;\n    this.type = Address.PayToScriptHash;\n  } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToScriptHash;\n  } else {\n    throw new Error('Provided public keys don\\'t hash to the provided output');\n  }\n\n  if (this.nestedWitness) {\n    var scriptSig = new Script();\n    scriptSig.add(nested.toBuffer());\n    this.setScript(scriptSig);\n  }\n\n  this.publicKeyIndex = {};\n  for (let index = 0; index < this.publicKeys.length; index++) {\n    const publicKey = this.publicKeys[index];\n    this.publicKeyIndex[publicKey.toString()] = index;\n  }\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigScriptHashInput, Input);\n\nMultiSigScriptHashInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = this.publicKeys.map(function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {\n  return signatures.map(function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigScriptHashInput.prototype._serializeSignatures = function() {\n  return this.signatures.map(function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\nMultiSigScriptHashInput.prototype.getScriptCode = function() {\n  var writer = new BufferWriter();\n  if (!this.redeemScript.hasCodeseparators()) {\n    var redeemScriptBuffer = this.redeemScript.toBuffer();\n    writer.writeVarintNum(redeemScriptBuffer.length);\n    writer.write(redeemScriptBuffer);\n  } else {\n    throw new Error('@TODO');\n  }\n  return writer.toBuffer();\n};\n\nMultiSigScriptHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\n  var hash;\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    hash = SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n  } else  {\n    hash = Sighash.sighash(transaction, sigtype, index, this.redeemScript);\n  }\n  return hash;\n};\n\n/**\n * Get signatures for this input\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer} merkleRoot - unused for this input type\n * @return {Array<TransactionSignature>}\n */\nMultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  const results = [];\n  for (const publicKey of this.publicKeys) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      var signature;\n      if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n        var scriptCode = this.getScriptCode();\n        var satoshisBuffer = this.getSatoshisBuffer();\n        signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer);\n      } else  {\n        signature = Sighash.sign(transaction, privateKey, sigtype, index, this.redeemScript);\n      }\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: signature,\n        sigtype: sigtype\n      }));\n    }\n  }\n  return results;\n};\n\nMultiSigScriptHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] != null,\n                  'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Invalid Signature!');\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._updateScript = function() {\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    var stack = [\n      Buffer.alloc(0),\n    ];\n    var signatures = this._createSignatures();\n    for (var i = 0; i < signatures.length; i++) {\n      stack.push(signatures[i]);\n    }\n    stack.push(this.redeemScript.toBuffer());\n    this.setWitnesses(stack);\n  } else {\n    var scriptSig = Script.buildP2SHMultisigIn(\n      this.publicKeys,\n      this.threshold,\n      this._createSignatures(),\n      { cachedMultisig: this.redeemScript }\n    );\n    this.setScript(scriptSig);\n  }\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._createSignatures = function() {\n  return this.signatures\n    .filter(function(signature) { return signature != null; })\n    .map(function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    });\n};\n\nMultiSigScriptHashInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigScriptHashInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigScriptHashInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigScriptHashInput.prototype.countSignatures = function() {\n  return this.signatures.reduce(function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {\n  return this.publicKeys.filter((publicKey) => {\n    return !(this.signatures[this.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    signature.signature.nhashtype = signature.sigtype;\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      scriptCode,\n      satoshisBuffer\n    );\n  } else {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      this.redeemScript\n    );\n  }\n};\n\nMultiSigScriptHashInput.MAX_OPCODES_SIZE = 8; // serialized size (<=3) + 0 .. OP_PUSHDATAx N .. M OP_CHECKMULTISIG\nMultiSigScriptHashInput.MAX_SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\nMultiSigScriptHashInput.MAX_PUBKEY_SIZE = 34; // size (1) + DER (<=33)\nMultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34; // OP_0 (1) + scriptHash (1 + 32)\n\nMultiSigScriptHashInput.prototype._estimateSize = function() {\n  let result = this._getBaseSize();\n  const WITNESS_DISCOUNT = 4;\n  const witnessSize = MultiSigScriptHashInput.MAX_OPCODES_SIZE +\n    this.threshold * MultiSigScriptHashInput.MAX_SIGNATURE_SIZE +\n    this.publicKeys.length * MultiSigScriptHashInput.MAX_PUBKEY_SIZE;\n  if (this.type === Address.PayToWitnessScriptHash) {\n    result += witnessSize / WITNESS_DISCOUNT;\n  } else if (this.nestedWitness) {\n    result += witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    result += witnessSize;\n  }\n  return result;\n};\n\nmodule.exports = MultiSigScriptHashInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L211bHRpc2lnc2NyaXB0aGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsZUFBZSxtQkFBTyxDQUFDLG9GQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxnRkFBUztBQUM3QixhQUFhLG1CQUFPLENBQUMsNkVBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLDRGQUEwQjs7QUFFMUMsY0FBYyxtQkFBTyxDQUFDLHNFQUFlO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQywwRUFBYztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBd0I7QUFDaEQsY0FBYyxtQkFBTyxDQUFDLCtFQUFZO0FBQ2xDLHFCQUFxQixtQkFBTyxDQUFDLDZGQUFtQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxrR0FBNkI7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsOEVBQW1CO0FBQzVDLDJCQUEyQixtQkFBTyxDQUFDLG1GQUFjOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOERBQThELG1DQUFtQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsOEJBQThCO0FBQzNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDLGlEQUFpRDtBQUNqRCw4Q0FBOEM7QUFDOUMsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L211bHRpc2lnc2NyaXB0aGFzaC5qcz9jMmNiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoganNoaW50IG1heHBhcmFtczo1ICovXG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xudmFyIE91dHB1dCA9IHJlcXVpcmUoJy4uL291dHB1dCcpO1xudmFyICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcblxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi8uLi9hZGRyZXNzJyk7XG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xudmFyIFNpZ2hhc2ggPSByZXF1aXJlKCcuLi9zaWdoYXNoJyk7XG52YXIgU2lnaGFzaFdpdG5lc3MgPSByZXF1aXJlKCcuLi9zaWdoYXNod2l0bmVzcycpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uLy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2J1ZmZlcicpO1xudmFyIFRyYW5zYWN0aW9uU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE11bHRpU2lnU2NyaXB0SGFzaElucHV0KGlucHV0LCBwdWJrZXlzLCB0aHJlc2hvbGQsIHNpZ25hdHVyZXMsIG9wdHMpIHtcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6MjAgKi9cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHB1YmtleXMgPSBwdWJrZXlzIHx8IGlucHV0LnB1YmxpY0tleXM7XG4gIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCBpbnB1dC50aHJlc2hvbGQ7XG4gIHNpZ25hdHVyZXMgPSBzaWduYXR1cmVzIHx8IGlucHV0LnNpZ25hdHVyZXM7XG4gIGlmIChvcHRzLm5vU29ydGluZykge1xuICAgIHRoaXMucHVibGljS2V5cyA9IHB1YmtleXM7XG4gIH0gZWxzZSAge1xuICAgIHRoaXMucHVibGljS2V5cyA9IF8uc29ydEJ5KHB1YmtleXMsIGZ1bmN0aW9uKHB1YmxpY0tleSkgeyByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKTsgfSk7XG4gIH1cbiAgdGhpcy5yZWRlZW1TY3JpcHQgPSBTY3JpcHQuYnVpbGRNdWx0aXNpZ091dCh0aGlzLnB1YmxpY0tleXMsIHRocmVzaG9sZCwgb3B0cyk7XG4gIHZhciBuZXN0ZWQgPSBTY3JpcHQuYnVpbGRXaXRuZXNzTXVsdGlzaWdPdXRGcm9tU2NyaXB0KHRoaXMucmVkZWVtU2NyaXB0KTtcbiAgaWYgKG5lc3RlZC5lcXVhbHModGhpcy5vdXRwdXQuc2NyaXB0KSkge1xuICAgIHRoaXMubmVzdGVkV2l0bmVzcyA9IGZhbHNlO1xuICAgIHRoaXMudHlwZSA9IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaDtcbiAgfSBlbHNlIGlmIChTY3JpcHQuYnVpbGRTY3JpcHRIYXNoT3V0KG5lc3RlZCkuZXF1YWxzKHRoaXMub3V0cHV0LnNjcmlwdCkpIHtcbiAgICB0aGlzLm5lc3RlZFdpdG5lc3MgPSB0cnVlO1xuICAgIHRoaXMudHlwZSA9IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoO1xuICB9IGVsc2UgaWYgKFNjcmlwdC5idWlsZFNjcmlwdEhhc2hPdXQodGhpcy5yZWRlZW1TY3JpcHQpLmVxdWFscyh0aGlzLm91dHB1dC5zY3JpcHQpKSB7XG4gICAgdGhpcy5uZXN0ZWRXaXRuZXNzID0gZmFsc2U7XG4gICAgdGhpcy50eXBlID0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBwdWJsaWMga2V5cyBkb25cXCd0IGhhc2ggdG8gdGhlIHByb3ZpZGVkIG91dHB1dCcpO1xuICB9XG5cbiAgaWYgKHRoaXMubmVzdGVkV2l0bmVzcykge1xuICAgIHZhciBzY3JpcHRTaWcgPSBuZXcgU2NyaXB0KCk7XG4gICAgc2NyaXB0U2lnLmFkZChuZXN0ZWQudG9CdWZmZXIoKSk7XG4gICAgdGhpcy5zZXRTY3JpcHQoc2NyaXB0U2lnKTtcbiAgfVxuXG4gIHRoaXMucHVibGljS2V5SW5kZXggPSB7fTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucHVibGljS2V5cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleXNbaW5kZXhdO1xuICAgIHRoaXMucHVibGljS2V5SW5kZXhbcHVibGljS2V5LnRvU3RyaW5nKCldID0gaW5kZXg7XG4gIH1cbiAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIC8vIEVtcHR5IGFycmF5IG9mIHNpZ25hdHVyZXNcbiAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmF0dXJlcyA/IHRoaXMuX2Rlc2VyaWFsaXplU2lnbmF0dXJlcyhzaWduYXR1cmVzKSA6IG5ldyBBcnJheSh0aGlzLnB1YmxpY0tleXMubGVuZ3RoKTtcbn1cbmluaGVyaXRzKE11bHRpU2lnU2NyaXB0SGFzaElucHV0LCBJbnB1dCk7XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb2JqID0gSW5wdXQucHJvdG90eXBlLnRvT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIG9iai50aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZDtcbiAgb2JqLnB1YmxpY0tleXMgPSB0aGlzLnB1YmxpY0tleXMubWFwKGZ1bmN0aW9uKHB1YmxpY0tleSkgeyByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKCk7IH0pO1xuICBvYmouc2lnbmF0dXJlcyA9IHRoaXMuX3NlcmlhbGl6ZVNpZ25hdHVyZXMoKTtcbiAgcmV0dXJuIG9iajtcbn07XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5fZGVzZXJpYWxpemVTaWduYXR1cmVzID0gZnVuY3Rpb24oc2lnbmF0dXJlcykge1xuICByZXR1cm4gc2lnbmF0dXJlcy5tYXAoZnVuY3Rpb24oc2lnbmF0dXJlKSB7XG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgfSk7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuX3NlcmlhbGl6ZVNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlcy5tYXAoZnVuY3Rpb24oc2lnbmF0dXJlKSB7XG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzaWduYXR1cmUudG9PYmplY3QoKTtcbiAgfSk7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuZ2V0U2NyaXB0Q29kZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICBpZiAoIXRoaXMucmVkZWVtU2NyaXB0Lmhhc0NvZGVzZXBhcmF0b3JzKCkpIHtcbiAgICB2YXIgcmVkZWVtU2NyaXB0QnVmZmVyID0gdGhpcy5yZWRlZW1TY3JpcHQudG9CdWZmZXIoKTtcbiAgICB3cml0ZXIud3JpdGVWYXJpbnROdW0ocmVkZWVtU2NyaXB0QnVmZmVyLmxlbmd0aCk7XG4gICAgd3JpdGVyLndyaXRlKHJlZGVlbVNjcmlwdEJ1ZmZlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdAVE9ETycpO1xuICB9XG4gIHJldHVybiB3cml0ZXIudG9CdWZmZXIoKTtcbn07XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5nZXRTaWdoYXNoID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIGluZGV4LCBzaWd0eXBlKSB7XG4gIHZhciBoYXNoO1xuICBpZiAodGhpcy5uZXN0ZWRXaXRuZXNzIHx8IHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XG4gICAgdmFyIHNjcmlwdENvZGUgPSB0aGlzLmdldFNjcmlwdENvZGUoKTtcbiAgICB2YXIgc2F0b3NoaXNCdWZmZXIgPSB0aGlzLmdldFNhdG9zaGlzQnVmZmVyKCk7XG4gICAgaGFzaCA9IFNpZ2hhc2hXaXRuZXNzLnNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ3R5cGUsIGluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XG4gIH0gZWxzZSAge1xuICAgIGhhc2ggPSBTaWdoYXNoLnNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ3R5cGUsIGluZGV4LCB0aGlzLnJlZGVlbVNjcmlwdCk7XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59O1xuXG4vKipcbiAqIEdldCBzaWduYXR1cmVzIGZvciB0aGlzIGlucHV0XG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAtIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBzaWduZWRcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSB3aXRoIHdoaWNoIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGlucHV0IGluIHRoZSB0cmFuc2FjdGlvbiBpbnB1dCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWd0eXBlIC0gdGhlIHR5cGUgb2Ygc2lnbmF0dXJlLCBkZWZhdWx0cyB0byBTaWduYXR1cmUuU0lHSEFTSF9BTExcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoRGF0YSAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCBERVBSRUNBVEVEIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVya2xlUm9vdCAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVzID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIGluZGV4LCBzaWd0eXBlLCBoYXNoRGF0YSwgc2lnbmluZ01ldGhvZCwgbWVya2xlUm9vdCkge1xuICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQpO1xuICBzaWd0eXBlID0gc2lndHlwZSB8fCBTaWduYXR1cmUuU0lHSEFTSF9BTEw7XG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXG5cbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHB1YmxpY0tleSBvZiB0aGlzLnB1YmxpY0tleXMpIHtcbiAgICBpZiAocHVibGljS2V5LnRvU3RyaW5nKCkgPT09IHByaXZhdGVLZXkucHVibGljS2V5LnRvU3RyaW5nKCkpIHtcbiAgICAgIHZhciBzaWduYXR1cmU7XG4gICAgICBpZiAodGhpcy5uZXN0ZWRXaXRuZXNzIHx8IHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XG4gICAgICAgIHZhciBzY3JpcHRDb2RlID0gdGhpcy5nZXRTY3JpcHRDb2RlKCk7XG4gICAgICAgIHZhciBzYXRvc2hpc0J1ZmZlciA9IHRoaXMuZ2V0U2F0b3NoaXNCdWZmZXIoKTtcbiAgICAgICAgc2lnbmF0dXJlID0gU2lnaGFzaFdpdG5lc3Muc2lnbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgc2lndHlwZSwgaW5kZXgsIHNjcmlwdENvZGUsIHNhdG9zaGlzQnVmZmVyKTtcbiAgICAgIH0gZWxzZSAge1xuICAgICAgICBzaWduYXR1cmUgPSBTaWdoYXNoLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCB0aGlzLnJlZGVlbVNjcmlwdCk7XG4gICAgICB9XG4gICAgICByZXN1bHRzLnB1c2gobmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcbiAgICAgICAgcHVibGljS2V5OiBwcml2YXRlS2V5LnB1YmxpY0tleSxcbiAgICAgICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQsXG4gICAgICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxuICAgICAgICBpbnB1dEluZGV4OiBpbmRleCxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIHNpZ3R5cGU6IHNpZ3R5cGVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuYWRkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICAkLmNoZWNrU3RhdGUoIXRoaXMuaXNGdWxseVNpZ25lZCgpLCAnQWxsIG5lZWRlZCBzaWduYXR1cmVzIGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkJyk7XG4gICQuY2hlY2tBcmd1bWVudCh0aGlzLnB1YmxpY0tleUluZGV4W3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKV0gIT0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICdTaWduYXR1cmUgaGFzIG5vIG1hdGNoaW5nIHB1YmxpYyBrZXknKTtcbiAgJC5jaGVja1N0YXRlKHRoaXMuaXNWYWxpZFNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSwgJ0ludmFsaWQgU2lnbmF0dXJlIScpO1xuICB0aGlzLnNpZ25hdHVyZXNbdGhpcy5wdWJsaWNLZXlJbmRleFtzaWduYXR1cmUucHVibGljS2V5LnRvU3RyaW5nKCldXSA9IHNpZ25hdHVyZTtcbiAgdGhpcy5fdXBkYXRlU2NyaXB0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLl91cGRhdGVTY3JpcHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMubmVzdGVkV2l0bmVzcyB8fCB0aGlzLnR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCkge1xuICAgIHZhciBzdGFjayA9IFtcbiAgICAgIEJ1ZmZlci5hbGxvYygwKSxcbiAgICBdO1xuICAgIHZhciBzaWduYXR1cmVzID0gdGhpcy5fY3JlYXRlU2lnbmF0dXJlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhY2sucHVzaChzaWduYXR1cmVzW2ldKTtcbiAgICB9XG4gICAgc3RhY2sucHVzaCh0aGlzLnJlZGVlbVNjcmlwdC50b0J1ZmZlcigpKTtcbiAgICB0aGlzLnNldFdpdG5lc3NlcyhzdGFjayk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjcmlwdFNpZyA9IFNjcmlwdC5idWlsZFAyU0hNdWx0aXNpZ0luKFxuICAgICAgdGhpcy5wdWJsaWNLZXlzLFxuICAgICAgdGhpcy50aHJlc2hvbGQsXG4gICAgICB0aGlzLl9jcmVhdGVTaWduYXR1cmVzKCksXG4gICAgICB7IGNhY2hlZE11bHRpc2lnOiB0aGlzLnJlZGVlbVNjcmlwdCB9XG4gICAgKTtcbiAgICB0aGlzLnNldFNjcmlwdChzY3JpcHRTaWcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLl9jcmVhdGVTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNpZ25hdHVyZXNcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKHNpZ25hdHVyZSkgeyByZXR1cm4gc2lnbmF0dXJlICE9IG51bGw7IH0pXG4gICAgLm1hcChmdW5jdGlvbihzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiBCdWZmZXJVdGlsLmNvbmNhdChbXG4gICAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9ERVIoKSxcbiAgICAgICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ25hdHVyZS5zaWd0eXBlKVxuICAgICAgXSk7XG4gICAgfSk7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2lnbmF0dXJlcyA9IG5ldyBBcnJheSh0aGlzLnB1YmxpY0tleXMubGVuZ3RoKTtcbiAgdGhpcy5fdXBkYXRlU2NyaXB0KCk7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb3VudFNpZ25hdHVyZXMoKSA9PT0gdGhpcy50aHJlc2hvbGQ7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuY291bnRNaXNzaW5nU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50aHJlc2hvbGQgLSB0aGlzLmNvdW50U2lnbmF0dXJlcygpO1xufTtcblxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLmNvdW50U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zaWduYXR1cmVzLnJlZHVjZShmdW5jdGlvbihzdW0sIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBzdW0gKyAoISFzaWduYXR1cmUpO1xuICB9LCAwKTtcbn07XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5wdWJsaWNLZXlzV2l0aG91dFNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wdWJsaWNLZXlzLmZpbHRlcigocHVibGljS2V5KSA9PiB7XG4gICAgcmV0dXJuICEodGhpcy5zaWduYXR1cmVzW3RoaXMucHVibGljS2V5SW5kZXhbcHVibGljS2V5LnRvU3RyaW5nKCldXSk7XG4gIH0pO1xufTtcblxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSB7XG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXG4gIGlmICh0aGlzLm5lc3RlZFdpdG5lc3MgfHwgdGhpcy50eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2gpIHtcbiAgICBzaWduYXR1cmUuc2lnbmF0dXJlLm5oYXNodHlwZSA9IHNpZ25hdHVyZS5zaWd0eXBlO1xuICAgIHZhciBzY3JpcHRDb2RlID0gdGhpcy5nZXRTY3JpcHRDb2RlKCk7XG4gICAgdmFyIHNhdG9zaGlzQnVmZmVyID0gdGhpcy5nZXRTYXRvc2hpc0J1ZmZlcigpO1xuICAgIHJldHVybiBTaWdoYXNoV2l0bmVzcy52ZXJpZnkoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgICBzaWduYXR1cmUucHVibGljS2V5LFxuICAgICAgc2lnbmF0dXJlLmlucHV0SW5kZXgsXG4gICAgICBzY3JpcHRDb2RlLFxuICAgICAgc2F0b3NoaXNCdWZmZXJcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIEZJWE1FOiBSZWZhY3RvciBzaWduYXR1cmUgc28gdGhpcyBpcyBub3QgbmVjZXNzYXJ5XG4gICAgc2lnbmF0dXJlLnNpZ25hdHVyZS5uaGFzaHR5cGUgPSBzaWduYXR1cmUuc2lndHlwZTtcbiAgICByZXR1cm4gU2lnaGFzaC52ZXJpZnkoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgICBzaWduYXR1cmUucHVibGljS2V5LFxuICAgICAgc2lnbmF0dXJlLmlucHV0SW5kZXgsXG4gICAgICB0aGlzLnJlZGVlbVNjcmlwdFxuICAgICk7XG4gIH1cbn07XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0Lk1BWF9PUENPREVTX1NJWkUgPSA4OyAvLyBzZXJpYWxpemVkIHNpemUgKDw9MykgKyAwIC4uIE9QX1BVU0hEQVRBeCBOIC4uIE0gT1BfQ0hFQ0tNVUxUSVNJR1xuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQuTUFYX1NJR05BVFVSRV9TSVpFID0gNzQ7IC8vIHNpemUgKDEpICsgREVSICg8PTcyKSArIHNpZ2hhc2ggKDEpXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5NQVhfUFVCS0VZX1NJWkUgPSAzNDsgLy8gc2l6ZSAoMSkgKyBERVIgKDw9MzMpXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5SRURFRU1fU0NSSVBUX1NJWkUgPSAzNDsgLy8gT1BfMCAoMSkgKyBzY3JpcHRIYXNoICgxICsgMzIpXG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIGxldCByZXN1bHQgPSB0aGlzLl9nZXRCYXNlU2l6ZSgpO1xuICBjb25zdCBXSVRORVNTX0RJU0NPVU5UID0gNDtcbiAgY29uc3Qgd2l0bmVzc1NpemUgPSBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5NQVhfT1BDT0RFU19TSVpFICtcbiAgICB0aGlzLnRocmVzaG9sZCAqIE11bHRpU2lnU2NyaXB0SGFzaElucHV0Lk1BWF9TSUdOQVRVUkVfU0laRSArXG4gICAgdGhpcy5wdWJsaWNLZXlzLmxlbmd0aCAqIE11bHRpU2lnU2NyaXB0SGFzaElucHV0Lk1BWF9QVUJLRVlfU0laRTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XG4gICAgcmVzdWx0ICs9IHdpdG5lc3NTaXplIC8gV0lUTkVTU19ESVNDT1VOVDtcbiAgfSBlbHNlIGlmICh0aGlzLm5lc3RlZFdpdG5lc3MpIHtcbiAgICByZXN1bHQgKz0gd2l0bmVzc1NpemUgLyBXSVRORVNTX0RJU0NPVU5UICsgTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQuUkVERUVNX1NDUklQVF9TSVpFO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSB3aXRuZXNzU2l6ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickey.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/publickey.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\n\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\n\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\n\n/**\n * Represents a special kind of input of PayToPublicKey kind.\n * @constructor\n */\nfunction PublicKeyInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyInput, Input);\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type \n * @param {String} signingMethod DEPRECATED - method used to sign input - 'ecdsa' or 'schnorr'\n * @return {Array} of objects that can be\n */\nPublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  var publicKey = privateKey.toPublicKey();\n  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\n    return [new TransactionSignature({\n      publicKey: publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyInput} this, for chaining\n */\nPublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyIn(\n    signature.signature.toDER(),\n    signature.sigtype\n  ));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyIn();\n};\n\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\n\nPublicKeyInput.prototype._estimateSize = function() {\n  return this._getBaseSize() + PublicKeyInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3B1YmxpY2tleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0ZBQVU7O0FBRWpDLFFBQVEsbUJBQU8sQ0FBQyw0RkFBMEI7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQW1COztBQUU1QyxZQUFZLG1CQUFPLENBQUMsZ0ZBQVM7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDZFQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQywrRUFBWTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsMEVBQWM7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQXdCO0FBQ2hELDJCQUEyQixtQkFBTyxDQUFDLG1GQUFjOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi90cmFuc2FjdGlvbi9pbnB1dC9wdWJsaWNrZXkuanM/NjczOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciAkID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnVmZmVyJyk7XG5cbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuLi9vdXRwdXQnKTtcbnZhciBTaWdoYXNoID0gcmVxdWlyZSgnLi4vc2lnaGFzaCcpO1xudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uLy4uL2NyeXB0by9zaWduYXR1cmUnKTtcbnZhciBUcmFuc2FjdGlvblNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL3NpZ25hdHVyZScpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzcGVjaWFsIGtpbmQgb2YgaW5wdXQgb2YgUGF5VG9QdWJsaWNLZXkga2luZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQdWJsaWNLZXlJbnB1dCgpIHtcbiAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmluaGVyaXRzKFB1YmxpY0tleUlucHV0LCBJbnB1dCk7XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVLZXkgLSB0aGUgcHJpdmF0ZSBrZXkgd2l0aCB3aGljaCB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBpbnB1dCBpbiB0aGUgdHJhbnNhY3Rpb24gaW5wdXQgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHNpZ25hdHVyZSwgZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaERhdGEgLSB1bnVzZWQgZm9yIHRoaXMgaW5wdXQgdHlwZSBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIERFUFJFQ0FURUQgLSBtZXRob2QgdXNlZCB0byBzaWduIGlucHV0IC0gJ2VjZHNhJyBvciAnc2Nobm9ycidcbiAqIEByZXR1cm4ge0FycmF5fSBvZiBvYmplY3RzIHRoYXQgY2FuIGJlXG4gKi9cblB1YmxpY0tleUlucHV0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVzID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIGluZGV4LCBzaWd0eXBlLCBoYXNoRGF0YSwgc2lnbmluZ01ldGhvZCkge1xuICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQpO1xuICBzaWd0eXBlID0gc2lndHlwZSB8fCBTaWduYXR1cmUuU0lHSEFTSF9BTEw7XG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXG4gIHZhciBwdWJsaWNLZXkgPSBwcml2YXRlS2V5LnRvUHVibGljS2V5KCk7XG4gIGlmIChwdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gdGhpcy5vdXRwdXQuc2NyaXB0LmdldFB1YmxpY0tleSgpLnRvU3RyaW5nKCdoZXgnKSkge1xuICAgIHJldHVybiBbbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcbiAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQsXG4gICAgICBvdXRwdXRJbmRleDogdGhpcy5vdXRwdXRJbmRleCxcbiAgICAgIGlucHV0SW5kZXg6IGluZGV4LFxuICAgICAgc2lnbmF0dXJlOiBTaWdoYXNoLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCB0aGlzLm91dHB1dC5zY3JpcHQpLFxuICAgICAgc2lndHlwZTogc2lndHlwZVxuICAgIH0pXTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHNpZ25hdHVyZS5wdWJsaWNLZXlcbiAqIEBwYXJhbSB7U2lnbmF0dXJlfSBzaWduYXR1cmUuc2lnbmF0dXJlXG4gKiBAcGFyYW0ge251bWJlcj19IHNpZ25hdHVyZS5zaWd0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCAtIG1ldGhvZCB1c2VkIHRvIHNpZ24gLSAnZWNkc2EnIG9yICdzY2hub3JyJyAoZnV0dXJlIHNpZ25pbmcgbWV0aG9kKVxuICogQHJldHVybiB7UHVibGljS2V5SW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5QdWJsaWNLZXlJbnB1dC5wcm90b3R5cGUuYWRkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICAkLmNoZWNrU3RhdGUodGhpcy5pc1ZhbGlkU2lnbmF0dXJlKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpLCAnU2lnbmF0dXJlIGlzIGludmFsaWQnKTtcbiAgdGhpcy5zZXRTY3JpcHQoU2NyaXB0LmJ1aWxkUHVibGljS2V5SW4oXG4gICAgc2lnbmF0dXJlLnNpZ25hdHVyZS50b0RFUigpLFxuICAgIHNpZ25hdHVyZS5zaWd0eXBlXG4gICkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIGlucHV0J3Mgc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtQdWJsaWNLZXlIYXNoSW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5QdWJsaWNLZXlJbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2V0U2NyaXB0KFNjcmlwdC5lbXB0eSgpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXJ5IHdoZXRoZXIgdGhlIGlucHV0IGlzIHNpZ25lZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUHVibGljS2V5SW5wdXQucHJvdG90eXBlLmlzRnVsbHlTaWduZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2NyaXB0LmlzUHVibGljS2V5SW4oKTtcbn07XG5cblB1YmxpY0tleUlucHV0LlNDUklQVF9NQVhfU0laRSA9IDczOyAvLyBzaWdzaXplICgxICsgNzIpXG5cblB1YmxpY0tleUlucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nZXRCYXNlU2l6ZSgpICsgUHVibGljS2V5SW5wdXQuU0NSSVBUX01BWF9TSVpFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQdWJsaWNLZXlJbnB1dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\n\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\n\nvar Address = __webpack_require__(/*! ../../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Hash = __webpack_require__(/*! ../../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar SighashWitness = __webpack_require__(/*! ../sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\nvar BufferWriter = __webpack_require__(/*! ../../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyHashInput, Input);\n\nPublicKeyHashInput.prototype.getRedeemScript = function(publicKey) {\n  if (!this.redeemScript) {\n    var redeemScript = Script.buildWitnessV0Out(publicKey);\n    if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {\n      var scriptSig = new Script();\n      scriptSig.add(redeemScript.toBuffer());\n      this.setScript(scriptSig);\n      this.redeemScript = redeemScript;\n    }\n  }\n  return this.redeemScript;\n};\n\nPublicKeyHashInput.prototype.getScriptCode = function(publicKey) {\n  var writer = new BufferWriter();\n  var script;\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(publicKey);\n  } else {\n    script = this.output.script;\n  }\n  var scriptBuffer = Script.buildPublicKeyHashOut(script.toAddress()).toBuffer();\n  writer.writeVarintNum(scriptBuffer.length);\n  writer.write(scriptBuffer);\n  return writer.toBuffer();\n};\n\nPublicKeyHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\n  var scriptCode = this.getScriptCode(privateKey);\n  var satoshisBuffer = this.getSatoshisBuffer();\n  return SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n};\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer} merkleRoot - unused for this input type\n * @return {Array<TransactionSignature>}\n */\nPublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  var script;\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(privateKey.publicKey);\n  } else {\n    script = this.output.script;\n  }\n\n  if (script && BufferUtil.equals(hashData, script.getPublicKeyHash())) {\n    var signature;\n    if (script.isWitnessPublicKeyHashOut()) {\n      var satoshisBuffer = this.getSatoshisBuffer();\n      var scriptCode = this.getScriptCode(privateKey.publicKey);\n      signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer);\n    } else {\n      signature = Sighash.sign(transaction, privateKey, sigtype, index, this.output.script);\n    }\n\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: signature,\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Transaction} transaction\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    this.setWitnesses([\n      BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]),\n      signature.publicKey.toBuffer()\n    ]);\n  } else {\n    this.setScript(Script.buildPublicKeyHashIn(\n      signature.publicKey,\n      signature.signature.toDER(),\n      signature.sigtype\n    ));\n  }\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  this.setWitnesses([]);\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyHashInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyHashIn() || this.hasWitnesses();\n};\n\nPublicKeyHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      scriptCode,\n      satoshisBuffer\n    );\n  } else {\n    return Sighash.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      this.output.script\n    );\n  }\n};\n\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\nPublicKeyHashInput.REDEEM_SCRIPT_SIZE = 1 + 22; // len (1) OP_0 (1) pubkeyhash (1 + 20)\n\nPublicKeyHashInput.prototype._estimateSize = function() {\n  let result = this._getBaseSize();\n  result += 1; // script size\n  const WITNESS_DISCOUNT = 4;\n  const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;\n  if (this.output.script.isWitnessPublicKeyHashOut()) {\n    result += witnessSize;\n  } else if (this.output.script.isScriptHashOut()) {\n    result += witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    result += PublicKeyHashInput.SCRIPT_MAX_SIZE;\n  }\n  return result;\n};\n\nmodule.exports = PublicKeyHashInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3B1YmxpY2tleWhhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9GQUFVOztBQUVqQyxRQUFRLG1CQUFPLENBQUMsNEZBQTBCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjs7QUFFNUMsY0FBYyxtQkFBTyxDQUFDLHNFQUFlO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLGdGQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyw2RUFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsK0VBQVk7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLGtHQUE2QjtBQUN4RCxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLDBFQUFjO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHdGQUF3QjtBQUNoRCwyQkFBMkIsbUJBQU8sQ0FBQyxtRkFBYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDhDQUE4QztBQUM5QyxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvcHVibGlja2V5aGFzaC5qcz8wNTVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9idWZmZXInKTtcblxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi8uLi9hZGRyZXNzJyk7XG52YXIgSGFzaCA9IHJlcXVpcmUoJy4uLy4uL2NyeXB0by9oYXNoJyk7XG52YXIgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XG52YXIgT3V0cHV0ID0gcmVxdWlyZSgnLi4vb3V0cHV0Jyk7XG52YXIgU2lnaGFzaCA9IHJlcXVpcmUoJy4uL3NpZ2hhc2gnKTtcbnZhciBTaWdoYXNoV2l0bmVzcyA9IHJlcXVpcmUoJy4uL3NpZ2hhc2h3aXRuZXNzJyk7XG52YXIgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnVmZmVyJyk7XG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xudmFyIFRyYW5zYWN0aW9uU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNwZWNpYWwga2luZCBvZiBpbnB1dCBvZiBQYXlUb1B1YmxpY0tleUhhc2gga2luZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQdWJsaWNLZXlIYXNoSW5wdXQoKSB7XG4gIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5pbmhlcml0cyhQdWJsaWNLZXlIYXNoSW5wdXQsIElucHV0KTtcblxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5nZXRSZWRlZW1TY3JpcHQgPSBmdW5jdGlvbihwdWJsaWNLZXkpIHtcbiAgaWYgKCF0aGlzLnJlZGVlbVNjcmlwdCkge1xuICAgIHZhciByZWRlZW1TY3JpcHQgPSBTY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQocHVibGljS2V5KTtcbiAgICBpZiAoU2NyaXB0LmJ1aWxkU2NyaXB0SGFzaE91dChyZWRlZW1TY3JpcHQpLmVxdWFscyh0aGlzLm91dHB1dC5zY3JpcHQpKSB7XG4gICAgICB2YXIgc2NyaXB0U2lnID0gbmV3IFNjcmlwdCgpO1xuICAgICAgc2NyaXB0U2lnLmFkZChyZWRlZW1TY3JpcHQudG9CdWZmZXIoKSk7XG4gICAgICB0aGlzLnNldFNjcmlwdChzY3JpcHRTaWcpO1xuICAgICAgdGhpcy5yZWRlZW1TY3JpcHQgPSByZWRlZW1TY3JpcHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnJlZGVlbVNjcmlwdDtcbn07XG5cblB1YmxpY0tleUhhc2hJbnB1dC5wcm90b3R5cGUuZ2V0U2NyaXB0Q29kZSA9IGZ1bmN0aW9uKHB1YmxpY0tleSkge1xuICB2YXIgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICB2YXIgc2NyaXB0O1xuICBpZiAodGhpcy5vdXRwdXQuc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpKSB7XG4gICAgc2NyaXB0ID0gdGhpcy5nZXRSZWRlZW1TY3JpcHQocHVibGljS2V5KTtcbiAgfSBlbHNlIHtcbiAgICBzY3JpcHQgPSB0aGlzLm91dHB1dC5zY3JpcHQ7XG4gIH1cbiAgdmFyIHNjcmlwdEJ1ZmZlciA9IFNjcmlwdC5idWlsZFB1YmxpY0tleUhhc2hPdXQoc2NyaXB0LnRvQWRkcmVzcygpKS50b0J1ZmZlcigpO1xuICB3cml0ZXIud3JpdGVWYXJpbnROdW0oc2NyaXB0QnVmZmVyLmxlbmd0aCk7XG4gIHdyaXRlci53cml0ZShzY3JpcHRCdWZmZXIpO1xuICByZXR1cm4gd3JpdGVyLnRvQnVmZmVyKCk7XG59O1xuXG5QdWJsaWNLZXlIYXNoSW5wdXQucHJvdG90eXBlLmdldFNpZ2hhc2ggPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgaW5kZXgsIHNpZ3R5cGUpIHtcbiAgdmFyIHNjcmlwdENvZGUgPSB0aGlzLmdldFNjcmlwdENvZGUocHJpdmF0ZUtleSk7XG4gIHZhciBzYXRvc2hpc0J1ZmZlciA9IHRoaXMuZ2V0U2F0b3NoaXNCdWZmZXIoKTtcbiAgcmV0dXJuIFNpZ2hhc2hXaXRuZXNzLnNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ3R5cGUsIGluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIC0gdGhlIHRyYW5zYWN0aW9uIHRvIGJlIHNpZ25lZFxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlS2V5IC0gdGhlIHByaXZhdGUga2V5IHdpdGggd2hpY2ggdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgaW5wdXQgaW4gdGhlIHRyYW5zYWN0aW9uIGlucHV0IHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ3R5cGUgLSB0aGUgdHlwZSBvZiBzaWduYXR1cmUsIGRlZmF1bHRzIHRvIFNpZ25hdHVyZS5TSUdIQVNIX0FMTFxuICogQHBhcmFtIHtCdWZmZXJ9IGhhc2hEYXRhIC0gdGhlIHByZWNhbGN1bGF0ZWQgaGFzaCBvZiB0aGUgcHVibGljIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHByaXZhdGVLZXkgcHJvdmlkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVya2xlUm9vdCAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cblB1YmxpY0tleUhhc2hJbnB1dC5wcm90b3R5cGUuZ2V0U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBpbmRleCwgc2lndHlwZSwgaGFzaERhdGEsIHNpZ25pbmdNZXRob2QsIG1lcmtsZVJvb3QpIHtcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgT3V0cHV0KTtcbiAgaGFzaERhdGEgPSBoYXNoRGF0YSB8fCBIYXNoLnNoYTI1NnJpcGVtZDE2MChwcml2YXRlS2V5LnB1YmxpY0tleS50b0J1ZmZlcigpKTtcbiAgc2lndHlwZSA9IHNpZ3R5cGUgfHwgU2lnbmF0dXJlLlNJR0hBU0hfQUxMO1xuICBzaWduaW5nTWV0aG9kID0gc2lnbmluZ01ldGhvZCB8fCAnZWNkc2EnOyAvLyB1bnVzZWQuIEtlZXBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgbGlic1xuXG4gIHZhciBzY3JpcHQ7XG4gIGlmICh0aGlzLm91dHB1dC5zY3JpcHQuaXNTY3JpcHRIYXNoT3V0KCkpIHtcbiAgICBzY3JpcHQgPSB0aGlzLmdldFJlZGVlbVNjcmlwdChwcml2YXRlS2V5LnB1YmxpY0tleSk7XG4gIH0gZWxzZSB7XG4gICAgc2NyaXB0ID0gdGhpcy5vdXRwdXQuc2NyaXB0O1xuICB9XG5cbiAgaWYgKHNjcmlwdCAmJiBCdWZmZXJVdGlsLmVxdWFscyhoYXNoRGF0YSwgc2NyaXB0LmdldFB1YmxpY0tleUhhc2goKSkpIHtcbiAgICB2YXIgc2lnbmF0dXJlO1xuICAgIGlmIChzY3JpcHQuaXNXaXRuZXNzUHVibGljS2V5SGFzaE91dCgpKSB7XG4gICAgICB2YXIgc2F0b3NoaXNCdWZmZXIgPSB0aGlzLmdldFNhdG9zaGlzQnVmZmVyKCk7XG4gICAgICB2YXIgc2NyaXB0Q29kZSA9IHRoaXMuZ2V0U2NyaXB0Q29kZShwcml2YXRlS2V5LnB1YmxpY0tleSk7XG4gICAgICBzaWduYXR1cmUgPSBTaWdoYXNoV2l0bmVzcy5zaWduKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBzaWd0eXBlLCBpbmRleCwgc2NyaXB0Q29kZSwgc2F0b3NoaXNCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWduYXR1cmUgPSBTaWdoYXNoLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCB0aGlzLm91dHB1dC5zY3JpcHQpO1xuICAgIH1cblxuICAgIHJldHVybiBbbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcbiAgICAgIHB1YmxpY0tleTogcHJpdmF0ZUtleS5wdWJsaWNLZXksXG4gICAgICBwcmV2VHhJZDogdGhpcy5wcmV2VHhJZCxcbiAgICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxuICAgICAgaW5wdXRJbmRleDogaW5kZXgsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgIHNpZ3R5cGU6IHNpZ3R5cGVcbiAgICB9KV07XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcbi8qIGpzaGludCBtYXhwYXJhbXM6IDMgKi9cblxuLyoqXG4gKiBBZGQgdGhlIHByb3ZpZGVkIHNpZ25hdHVyZVxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gc2lnbmF0dXJlLnB1YmxpY0tleVxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZS5zaWduYXR1cmVcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2lnbmF0dXJlLnNpZ3R5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInIChmdXR1cmUgc2lnbmluZyBtZXRob2QpXG4gKiBAcmV0dXJuIHtQdWJsaWNLZXlIYXNoSW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5QdWJsaWNLZXlIYXNoSW5wdXQucHJvdG90eXBlLmFkZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcbiAgJC5jaGVja1N0YXRlKHRoaXMuaXNWYWxpZFNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSwgJ1NpZ25hdHVyZSBpcyBpbnZhbGlkJyk7XG5cbiAgaWYgKHRoaXMub3V0cHV0LnNjcmlwdC5pc1dpdG5lc3NQdWJsaWNLZXlIYXNoT3V0KCkgfHwgdGhpcy5vdXRwdXQuc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpKSB7XG4gICAgdGhpcy5zZXRXaXRuZXNzZXMoW1xuICAgICAgQnVmZmVyVXRpbC5jb25jYXQoW1xuICAgICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLnRvREVSKCksXG4gICAgICAgIEJ1ZmZlclV0aWwuaW50ZWdlckFzU2luZ2xlQnl0ZUJ1ZmZlcihzaWduYXR1cmUuc2lndHlwZSlcbiAgICAgIF0pLFxuICAgICAgc2lnbmF0dXJlLnB1YmxpY0tleS50b0J1ZmZlcigpXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZXRTY3JpcHQoU2NyaXB0LmJ1aWxkUHVibGljS2V5SGFzaEluKFxuICAgICAgc2lnbmF0dXJlLnB1YmxpY0tleSxcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9ERVIoKSxcbiAgICAgIHNpZ25hdHVyZS5zaWd0eXBlXG4gICAgKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBpbnB1dCdzIHNpZ25hdHVyZVxuICogQHJldHVybiB7UHVibGljS2V5SGFzaElucHV0fSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5jbGVhclNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXRTY3JpcHQoU2NyaXB0LmVtcHR5KCkpO1xuICB0aGlzLnNldFdpdG5lc3NlcyhbXSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBRdWVyeSB3aGV0aGVyIHRoZSBpbnB1dCBpcyBzaWduZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblB1YmxpY0tleUhhc2hJbnB1dC5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zY3JpcHQuaXNQdWJsaWNLZXlIYXNoSW4oKSB8fCB0aGlzLmhhc1dpdG5lc3NlcygpO1xufTtcblxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICBzaWduaW5nTWV0aG9kID0gc2lnbmluZ01ldGhvZCB8fCAnZWNkc2EnOyAvLyB1bnVzZWQuIEtlZXBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgbGlic1xuICAvLyBGSVhNRTogUmVmYWN0b3Igc2lnbmF0dXJlIHNvIHRoaXMgaXMgbm90IG5lY2Vzc2FyeVxuICBzaWduYXR1cmUuc2lnbmF0dXJlLm5oYXNodHlwZSA9IHNpZ25hdHVyZS5zaWd0eXBlO1xuICBpZiAodGhpcy5vdXRwdXQuc2NyaXB0LmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSB8fCB0aGlzLm91dHB1dC5zY3JpcHQuaXNTY3JpcHRIYXNoT3V0KCkpIHtcbiAgICB2YXIgc2NyaXB0Q29kZSA9IHRoaXMuZ2V0U2NyaXB0Q29kZSgpO1xuICAgIHZhciBzYXRvc2hpc0J1ZmZlciA9IHRoaXMuZ2V0U2F0b3NoaXNCdWZmZXIoKTtcbiAgICByZXR1cm4gU2lnaGFzaFdpdG5lc3MudmVyaWZ5KFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxuICAgICAgc2lnbmF0dXJlLnB1YmxpY0tleSxcbiAgICAgIHNpZ25hdHVyZS5pbnB1dEluZGV4LFxuICAgICAgc2NyaXB0Q29kZSxcbiAgICAgIHNhdG9zaGlzQnVmZmVyXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gU2lnaGFzaC52ZXJpZnkoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgICBzaWduYXR1cmUucHVibGljS2V5LFxuICAgICAgc2lnbmF0dXJlLmlucHV0SW5kZXgsXG4gICAgICB0aGlzLm91dHB1dC5zY3JpcHRcbiAgICApO1xuICB9XG59O1xuXG5cblB1YmxpY0tleUhhc2hJbnB1dC5TQ1JJUFRfTUFYX1NJWkUgPSA3MyArIDM0OyAvLyBzaWdzaXplICgxICsgNzIpICsgcHVia2V5ICgxICsgMzMpXG5QdWJsaWNLZXlIYXNoSW5wdXQuUkVERUVNX1NDUklQVF9TSVpFID0gMSArIDIyOyAvLyBsZW4gKDEpIE9QXzAgKDEpIHB1YmtleWhhc2ggKDEgKyAyMClcblxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIGxldCByZXN1bHQgPSB0aGlzLl9nZXRCYXNlU2l6ZSgpO1xuICByZXN1bHQgKz0gMTsgLy8gc2NyaXB0IHNpemVcbiAgY29uc3QgV0lUTkVTU19ESVNDT1VOVCA9IDQ7XG4gIGNvbnN0IHdpdG5lc3NTaXplID0gUHVibGljS2V5SGFzaElucHV0LlNDUklQVF9NQVhfU0laRSAvIFdJVE5FU1NfRElTQ09VTlQ7XG4gIGlmICh0aGlzLm91dHB1dC5zY3JpcHQuaXNXaXRuZXNzUHVibGljS2V5SGFzaE91dCgpKSB7XG4gICAgcmVzdWx0ICs9IHdpdG5lc3NTaXplO1xuICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0LnNjcmlwdC5pc1NjcmlwdEhhc2hPdXQoKSkge1xuICAgIHJlc3VsdCArPSB3aXRuZXNzU2l6ZSArIFB1YmxpY0tleUhhc2hJbnB1dC5SRURFRU1fU0NSSVBUX1NJWkU7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IFB1YmxpY0tleUhhc2hJbnB1dC5TQ1JJUFRfTUFYX1NJWkU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHVibGljS2V5SGFzaElucHV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/taproot.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/taproot.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\nconst $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst PubKeyHashInput = __webpack_require__(/*! ./publickeyhash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js\");\nconst SighashSchnorr = __webpack_require__(/*! ../sighashschnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js\");\nconst Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nconst TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\nconst Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nconst PrivateKey = __webpack_require__(/*! ../../privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\n\nfunction TaprootInput() {\n  PubKeyHashInput.apply(this, arguments);\n}\ninherits(TaprootInput, PubKeyHashInput);\n\n/**\n * Get signatures for this input\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type\n * @param {String} signingMethod - always schnorr for taproot\n * @param {Buffer} merkleRoot - the merkle root of the taproot tree\n * @return {Array<TransactionSignature>}\n */\nTaprootInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_DEFAULT;\n  \n  const inputIndex = transaction.inputs.indexOf(this);\n  const tweakedPk = privateKey.createTapTweak(merkleRoot).tweakedPrivKey;\n  const signature = SighashSchnorr.sign(\n    transaction,\n    tweakedPk,\n    sigtype,\n    inputIndex,\n    Signature.Version.TAPROOT,\n    null\n  );\n  if (!signature) {\n    return [];\n  }\n  const txSig = new TransactionSignature({\n    publicKey: privateKey.publicKey,\n    prevTxId: this.prevTxId,\n    outputIndex: this.outputIndex,\n    inputIndex,\n    signature: Signature.fromSchnorr(signature),\n    sigtype: sigtype\n  });\n  return this.isValidSignature(transaction, txSig) ? [txSig] : [];\n};\n\n\nTaprootInput.prototype.isValidSignature = function(transaction, signature) {\n  $.checkState(transaction.inputs.indexOf(this) >= 0, 'Signature has no matching input');\n  $.checkState(this.output instanceof Output, 'output is not instance of Output');\n  \n  if (!this.output.script.isTaproot()) {\n    return false;\n  }\n\n  return SighashSchnorr.verify(\n    transaction,\n    signature.signature,\n    this.output.script.chunks[1].buf,\n    Signature.Version.TAPROOT,\n    transaction.inputs.indexOf(this),\n    null\n  );\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nTaprootInput.prototype.isFullySigned = function() {\n  return this.output.script.isTaproot() && this.hasWitnesses();\n};\n\n/**\n * Add the provided signature\n *\n * @param {Transaction} transaction\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number} signature.sigtype\n * @return {TaprootInput} this, for chaining\n */\nTaprootInput.prototype.addSignature = function(transaction, signature) {\n  if (this.isValidSignature(transaction, signature)) {\n    this.setWitnesses([\n      signature.signature.toBuffer(),\n    ]);\n  }\n  // else... do nothing?\n  // When tx.sign(keys) is called, the given keys are used to try to sign all\n  // inputs. Invalid sigs may be created, in which case we should not add them here.\n  // The flow is kind of weird since this fn name is saying to add the signature.\n  // Maybe the validation check should be upstream to keep the code lexically obedient?\n\n  return this;\n};\n\n\n// TODO verify that this is the correct MAX size.\nTaprootInput.SCRIPT_MAX_SIZE = 66; // numwitnesses (1) + sigsize (1 + 64)\n\nTaprootInput.prototype._estimateSize = function() {\n  let result = this._getBaseSize();\n  result += 1; // script size\n  const WITNESS_DISCOUNT = 4;\n  const witnessSize = TaprootInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;\n  result += witnessSize;\n  return result;\n};\n\n\nmodule.exports = TaprootInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3RhcHJvb3QuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQVU7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLDRGQUEwQjtBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBaUI7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ2xELGtCQUFrQixtQkFBTyxDQUFDLHdGQUF3QjtBQUNsRCw2QkFBNkIsbUJBQU8sQ0FBQyxtRkFBYztBQUNuRCxlQUFlLG1CQUFPLENBQUMsNkVBQVc7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWtCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvdGFwcm9vdC5qcz82M2M3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbmNvbnN0ICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbmNvbnN0IFB1YktleUhhc2hJbnB1dCA9IHJlcXVpcmUoJy4vcHVibGlja2V5aGFzaCcpO1xuY29uc3QgU2lnaGFzaFNjaG5vcnIgPSByZXF1aXJlKCcuLi9zaWdoYXNoc2Nobm9ycicpO1xuY29uc3QgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xuY29uc3QgVHJhbnNhY3Rpb25TaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcbmNvbnN0IE91dHB1dCA9IHJlcXVpcmUoJy4uL291dHB1dCcpO1xuY29uc3QgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uLy4uL3ByaXZhdGVrZXknKTtcblxuZnVuY3Rpb24gVGFwcm9vdElucHV0KCkge1xuICBQdWJLZXlIYXNoSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmluaGVyaXRzKFRhcHJvb3RJbnB1dCwgUHViS2V5SGFzaElucHV0KTtcblxuLyoqXG4gKiBHZXQgc2lnbmF0dXJlcyBmb3IgdGhpcyBpbnB1dFxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVLZXkgLSB0aGUgcHJpdmF0ZSBrZXkgd2l0aCB3aGljaCB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBpbnB1dCBpbiB0aGUgdHJhbnNhY3Rpb24gaW5wdXQgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHNpZ25hdHVyZSwgZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaERhdGEgLSB1bnVzZWQgZm9yIHRoaXMgaW5wdXQgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25pbmdNZXRob2QgLSBhbHdheXMgc2Nobm9yciBmb3IgdGFwcm9vdFxuICogQHBhcmFtIHtCdWZmZXJ9IG1lcmtsZVJvb3QgLSB0aGUgbWVya2xlIHJvb3Qgb2YgdGhlIHRhcHJvb3QgdHJlZVxuICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5UYXByb290SW5wdXQucHJvdG90eXBlLmdldFNpZ25hdHVyZXMgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgaW5kZXgsIHNpZ3R5cGUsIGhhc2hEYXRhLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLm91dHB1dCBpbnN0YW5jZW9mIE91dHB1dCk7XG4gIHNpZ3R5cGUgPSBzaWd0eXBlIHx8IFNpZ25hdHVyZS5TSUdIQVNIX0RFRkFVTFQ7XG4gIFxuICBjb25zdCBpbnB1dEluZGV4ID0gdHJhbnNhY3Rpb24uaW5wdXRzLmluZGV4T2YodGhpcyk7XG4gIGNvbnN0IHR3ZWFrZWRQayA9IHByaXZhdGVLZXkuY3JlYXRlVGFwVHdlYWsobWVya2xlUm9vdCkudHdlYWtlZFByaXZLZXk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ2hhc2hTY2hub3JyLnNpZ24oXG4gICAgdHJhbnNhY3Rpb24sXG4gICAgdHdlYWtlZFBrLFxuICAgIHNpZ3R5cGUsXG4gICAgaW5wdXRJbmRleCxcbiAgICBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09ULFxuICAgIG51bGxcbiAgKTtcbiAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgdHhTaWcgPSBuZXcgVHJhbnNhY3Rpb25TaWduYXR1cmUoe1xuICAgIHB1YmxpY0tleTogcHJpdmF0ZUtleS5wdWJsaWNLZXksXG4gICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQsXG4gICAgb3V0cHV0SW5kZXg6IHRoaXMub3V0cHV0SW5kZXgsXG4gICAgaW5wdXRJbmRleCxcbiAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tU2Nobm9ycihzaWduYXR1cmUpLFxuICAgIHNpZ3R5cGU6IHNpZ3R5cGVcbiAgfSk7XG4gIHJldHVybiB0aGlzLmlzVmFsaWRTaWduYXR1cmUodHJhbnNhY3Rpb24sIHR4U2lnKSA/IFt0eFNpZ10gOiBbXTtcbn07XG5cblxuVGFwcm9vdElucHV0LnByb3RvdHlwZS5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAkLmNoZWNrU3RhdGUodHJhbnNhY3Rpb24uaW5wdXRzLmluZGV4T2YodGhpcykgPj0gMCwgJ1NpZ25hdHVyZSBoYXMgbm8gbWF0Y2hpbmcgaW5wdXQnKTtcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgT3V0cHV0LCAnb3V0cHV0IGlzIG5vdCBpbnN0YW5jZSBvZiBPdXRwdXQnKTtcbiAgXG4gIGlmICghdGhpcy5vdXRwdXQuc2NyaXB0LmlzVGFwcm9vdCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFNpZ2hhc2hTY2hub3JyLnZlcmlmeShcbiAgICB0cmFuc2FjdGlvbixcbiAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxuICAgIHRoaXMub3V0cHV0LnNjcmlwdC5jaHVua3NbMV0uYnVmLFxuICAgIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFJPT1QsXG4gICAgdHJhbnNhY3Rpb24uaW5wdXRzLmluZGV4T2YodGhpcyksXG4gICAgbnVsbFxuICApO1xufTtcblxuLyoqXG4gKiBRdWVyeSB3aGV0aGVyIHRoZSBpbnB1dCBpcyBzaWduZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblRhcHJvb3RJbnB1dC5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vdXRwdXQuc2NyaXB0LmlzVGFwcm9vdCgpICYmIHRoaXMuaGFzV2l0bmVzc2VzKCk7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBzaWduYXR1cmUucHVibGljS2V5XG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlLnNpZ25hdHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ25hdHVyZS5zaWd0eXBlXG4gKiBAcmV0dXJuIHtUYXByb290SW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5UYXByb290SW5wdXQucHJvdG90eXBlLmFkZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgaWYgKHRoaXMuaXNWYWxpZFNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSkge1xuICAgIHRoaXMuc2V0V2l0bmVzc2VzKFtcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9CdWZmZXIoKSxcbiAgICBdKTtcbiAgfVxuICAvLyBlbHNlLi4uIGRvIG5vdGhpbmc/XG4gIC8vIFdoZW4gdHguc2lnbihrZXlzKSBpcyBjYWxsZWQsIHRoZSBnaXZlbiBrZXlzIGFyZSB1c2VkIHRvIHRyeSB0byBzaWduIGFsbFxuICAvLyBpbnB1dHMuIEludmFsaWQgc2lncyBtYXkgYmUgY3JlYXRlZCwgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgbm90IGFkZCB0aGVtIGhlcmUuXG4gIC8vIFRoZSBmbG93IGlzIGtpbmQgb2Ygd2VpcmQgc2luY2UgdGhpcyBmbiBuYW1lIGlzIHNheWluZyB0byBhZGQgdGhlIHNpZ25hdHVyZS5cbiAgLy8gTWF5YmUgdGhlIHZhbGlkYXRpb24gY2hlY2sgc2hvdWxkIGJlIHVwc3RyZWFtIHRvIGtlZXAgdGhlIGNvZGUgbGV4aWNhbGx5IG9iZWRpZW50P1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBUT0RPIHZlcmlmeSB0aGF0IHRoaXMgaXMgdGhlIGNvcnJlY3QgTUFYIHNpemUuXG5UYXByb290SW5wdXQuU0NSSVBUX01BWF9TSVpFID0gNjY7IC8vIG51bXdpdG5lc3NlcyAoMSkgKyBzaWdzaXplICgxICsgNjQpXG5cblRhcHJvb3RJbnB1dC5wcm90b3R5cGUuX2VzdGltYXRlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcmVzdWx0ID0gdGhpcy5fZ2V0QmFzZVNpemUoKTtcbiAgcmVzdWx0ICs9IDE7IC8vIHNjcmlwdCBzaXplXG4gIGNvbnN0IFdJVE5FU1NfRElTQ09VTlQgPSA0O1xuICBjb25zdCB3aXRuZXNzU2l6ZSA9IFRhcHJvb3RJbnB1dC5TQ1JJUFRfTUFYX1NJWkUgLyBXSVRORVNTX0RJU0NPVU5UO1xuICByZXN1bHQgKz0gd2l0bmVzc1NpemU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGFwcm9vdElucHV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/taproot.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js":
/*!************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/output.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar bufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nconst Interpreter = __webpack_require__(/*! ../script/interpreter */ \"(ssr)/./node_modules/bitcore-lib/lib/script/interpreter.js\");\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\nfunction Output(args) {\n  if (!(this instanceof Output)) {\n    return new Output(args);\n  }\n  if (_.isObject(args)) {\n    this.satoshis = args.satoshis;\n    if (bufferUtil.isBuffer(args.script)) {\n      this.setScriptFromBuffer(args.script);\n    } else {\n      var script;\n      if (_.isString(args.script) && JSUtil.isHexa(args.script)) {\n        script = Buffer.from(args.script, 'hex');\n      } else {\n        script = args.script;\n      }\n      this.setScript(script);\n    }\n\n    if (args.type === 'taproot') {\n      this.branch = [];\n      Object.defineProperty(this, 'isValid', {\n        configurable: false,\n        enumerable: false,\n        get: function() {\n          this._isValid || this._branch.length === 0;\n        },\n        set: function(isValid) {\n          this._isValid = isValid;\n        }\n      });\n      Object.defineProperty(this, 'isComplete', {\n        configurable: false,\n        enumerable: false,\n        get: function() {\n          return this.isValid && (this._branch.length === 0 || (this._branch.length === 1 && !!this._branch[0]));\n        }\n      });\n    }\n  } else {\n    throw new TypeError('Unrecognized argument for Output');\n  }\n}\n\nObject.defineProperty(Output.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    if (this._script) {\n      return this._script;\n    } else {\n      this.setScriptFromBuffer(this._scriptBuffer);\n      return this._script;\n    }\n\n  }\n});\n\nObject.defineProperty(Output.prototype, 'satoshis', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    return this._satoshis;\n  },\n  set: function(num) {\n    if (num instanceof BN) {\n      this._satoshisBN = num;\n      this._satoshis = num.toNumber();\n    } else if (_.isString(num)) {\n      this._satoshis = parseInt(num);\n      this._satoshisBN = BN.fromNumber(this._satoshis);\n    } else {\n      $.checkArgument(\n        JSUtil.isNaturalNumber(num),\n        'Output satoshis is not a natural number'\n      );\n      this._satoshisBN = BN.fromNumber(num);\n      this._satoshis = num;\n    }\n    $.checkState(\n      JSUtil.isNaturalNumber(this._satoshis),\n      'Output satoshis is not a natural number'\n    );\n  }\n});\n\nOutput.prototype.invalidSatoshis = function() {\n  if (this._satoshis > MAX_SAFE_INTEGER) {\n    return 'transaction txout satoshis greater than max safe integer';\n  }\n  if (this._satoshis !== this._satoshisBN.toNumber()) {\n    return 'transaction txout satoshis has corrupted value';\n  }\n  if (this._satoshis < 0) {\n    return 'transaction txout negative';\n  }\n  return false;\n};\n\nOutput.prototype.toObject = Output.prototype.toJSON = function toObject() {\n  var obj = {\n    satoshis: this.satoshis\n  };\n  obj.script = this._scriptBuffer.toString('hex');\n  return obj;\n};\n\nOutput.fromObject = function(data) {\n  return new Output(data);\n};\n\nOutput.prototype.setScriptFromBuffer = function(buffer) {\n  this._scriptBuffer = buffer;\n  try {\n    this._script = Script.fromBuffer(this._scriptBuffer);\n    this._script._isOutput = true;\n  } catch(e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      this._script = null;\n    } else {\n      throw e;\n    }\n  }\n};\n\nOutput.prototype.setScript = function(script) {\n  if (script instanceof Script) {\n    this._scriptBuffer = script.toBuffer();\n    this._script = script;\n    this._script._isOutput = true;\n  } else if (_.isString(script)) {\n    this._script = Script.fromString(script);\n    this._scriptBuffer = this._script.toBuffer();\n    this._script._isOutput = true;\n  } else if (bufferUtil.isBuffer(script)) {\n    this.setScriptFromBuffer(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n  return this;\n};\n\nOutput.prototype.inspect = function() {\n  var scriptStr;\n  if (this.script) {\n    scriptStr = this.script.inspect();\n  } else {\n    scriptStr = this._scriptBuffer.toString('hex');\n  }\n  return '<Output (' + this.satoshis + ' sats) ' + scriptStr + '>';\n};\n\nOutput.fromBufferReader = function(br) {\n  var obj = {};\n  obj.satoshis = br.readUInt64LEBN();\n  var size = br.readVarintNum();\n  if (size !== 0) {\n    obj.script = br.read(size);\n  } else {\n    obj.script = Buffer.from([]);\n  }\n  return new Output(obj);\n};\n\nOutput.prototype.toBufferWriter = function(writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n  writer.writeUInt64LEBN(this._satoshisBN);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  return writer;\n};\n\nOutput.prototype.calculateSize = function() {\n  let result = 8; // satoshis\n  result += BufferWriter.varintBufNum(this._scriptBuffer.length).length;\n  result += this._scriptBuffer.length;\n  return result;\n};\n\n/**\n * Taproot only\n * Add a new script at a certain depth in the tree. Add() operations must be called\n *  in depth-first traversal order of binary tree. If track is true, it will be included in\n *  the GetSpendData() output.\n * @param {Number} depth Tree depth at which to insert the node (depth is 0-based)\n * @param {Script} script \n * @param {Number} leafVersion \n * @param {Boolean} track If true, the leaf will be included in GetSpendData() output\n */\nOutput.prototype.add = function(depth, script, leafVersion, track = true) {\n  $.checkArgument((leafVersion & ~Interpreter.TAPROOT_LEAF_MASK) === 0, 'invalid leafVersion');\n  if (!this.isValid) {\n    return;\n  }\n\n  const node = {\n    hash: TaggedHash.TAPLEAF.writeUInt8(leafVersion).write(script.toBuffer()).finalize(),\n    leaves: []\n  };\n  if (track) {\n    const leafInfo = {\n      script,\n      leafVersion,\n      merkleBranch: []\n    };\n    node.leaves.push(leafInfo);\n  }\n  this._insertNode(node, depth);\n  return this;\n};\n\n\nOutput.prototype._insertNode = function(node, depth) {\n  $.checkArgument(depth >= 0 && depth <= Interpreter.TAPROOT_CONTROL_MAX_NODE_COUNT, 'invalid depth');\n  /* We cannot insert a leaf at a lower depth while a deeper branch is unfinished. Doing\n   * so would mean the Add() invocations do not correspond to a DFS traversal of a\n   * binary tree. */\n  if (depth + 1 < this._branch.length) {\n    this.isValid = false;\n    return;\n  }\n  /* As long as an entry in the branch exists at the specified depth, combine it and propagate up.\n   * The 'node' variable is overwritten here with the newly combined node. */\n  while (this.isValid && this._branch.length > depth && this._branch[depth]) {\n    node = this._combineNodes(node, this._branch[depth]);\n    this._branch = this._branch.slice(0, this._branch.length - 2);\n    if (depth == 0) {\n      this.isValid = false; /* Can't propagate further up than the root */\n    }\n    depth--;\n  }\n  if (this.isValid) {\n    /* Make sure the branch is big enough to place the new node. */\n    if (this._branch.length <= depth) {\n      this._branch = this._branch.slice(0, depth + 1);\n    }\n    $.checkState(!this._nodes[depth]);\n    m_branch[depth] = node;\n  }\n};\n\nOutput.prototype._combineNodes = function(a, b) {\n  const ret = {\n    hash: null,\n    leaves: []\n  };\n  /* Iterate over all tracked leaves in a, add b's hash to their Merkle branch, and move them to ret. */\n  for (let leaf of a.leaves) {\n    leaf.merkleBranch.push(b.hash);\n    ret.leaves.push(leaf);\n  }\n  /* Iterate over all tracked leaves in b, add a's hash to their Merkle branch, and move them to ret. */\n  for (let leaf of b.leaves) {\n    leaf.merkleBranch.push(a.hash);\n    ret.leaves.push(leaf);\n  }\n  /* Lexicographically sort a and b's hash, and compute parent hash. */\n  if (a.hash.compare(b.hash) === -1) {\n    ret.hash = TaggedHash.TAPBRANCH.write(a.hash).write(b.hash).finalize();\n  } else {\n    ret.hash = TaggedHash.TAPBRANCH.write(b.hash).write(a.hash).finalize();\n  }\n  return ret;\n};\n\n\n/**\n * Finalize the construction. Can only be called when IsComplete() is true.\n *  internal_key.IsFullyValid() must be true.\n * @param {PublicKey} pubKey \n */\nOutput.prototype.finalize = function(pubKey) {\n  $.checkState(this.isComplete === true, 'finalize can only be called when isComplete is true');\n  const ret = pubKey.createTapTweak(this._branch.length === 0 ? null : this._branch[0].hash);\n\n};\n\nmodule.exports = Output;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL291dHB1dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsU0FBUyxtQkFBTyxDQUFDLHVFQUFjO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsbUVBQVk7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3JELGFBQWEsbUJBQU8sQ0FBQyx1RUFBVztBQUNoQyxRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyx1RUFBVztBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsdUZBQXNCOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL291dHB1dC5qcz80NjY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xudmFyIGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvanMnKTtcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBJbnRlcnByZXRlciA9IHJlcXVpcmUoJy4uL3NjcmlwdC9pbnRlcnByZXRlcicpO1xuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by90YWdnZWRoYXNoJyk7XG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZjtcblxuZnVuY3Rpb24gT3V0cHV0KGFyZ3MpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE91dHB1dCkpIHtcbiAgICByZXR1cm4gbmV3IE91dHB1dChhcmdzKTtcbiAgfVxuICBpZiAoXy5pc09iamVjdChhcmdzKSkge1xuICAgIHRoaXMuc2F0b3NoaXMgPSBhcmdzLnNhdG9zaGlzO1xuICAgIGlmIChidWZmZXJVdGlsLmlzQnVmZmVyKGFyZ3Muc2NyaXB0KSkge1xuICAgICAgdGhpcy5zZXRTY3JpcHRGcm9tQnVmZmVyKGFyZ3Muc2NyaXB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNjcmlwdDtcbiAgICAgIGlmIChfLmlzU3RyaW5nKGFyZ3Muc2NyaXB0KSAmJiBKU1V0aWwuaXNIZXhhKGFyZ3Muc2NyaXB0KSkge1xuICAgICAgICBzY3JpcHQgPSBCdWZmZXIuZnJvbShhcmdzLnNjcmlwdCwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NyaXB0ID0gYXJncy5zY3JpcHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFNjcmlwdChzY3JpcHQpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLnR5cGUgPT09ICd0YXByb290Jykge1xuICAgICAgdGhpcy5icmFuY2ggPSBbXTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNWYWxpZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5faXNWYWxpZCB8fCB0aGlzLl9icmFuY2gubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGlzVmFsaWQpIHtcbiAgICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzQ29tcGxldGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgJiYgKHRoaXMuX2JyYW5jaC5sZW5ndGggPT09IDAgfHwgKHRoaXMuX2JyYW5jaC5sZW5ndGggPT09IDEgJiYgISF0aGlzLl9icmFuY2hbMF0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVjb2duaXplZCBhcmd1bWVudCBmb3IgT3V0cHV0Jyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE91dHB1dC5wcm90b3R5cGUsICdzY3JpcHQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3NjcmlwdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTY3JpcHRGcm9tQnVmZmVyKHRoaXMuX3NjcmlwdEJ1ZmZlcik7XG4gICAgICByZXR1cm4gdGhpcy5fc2NyaXB0O1xuICAgIH1cblxuICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE91dHB1dC5wcm90b3R5cGUsICdzYXRvc2hpcycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2F0b3NoaXM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24obnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICB0aGlzLl9zYXRvc2hpc0JOID0gbnVtO1xuICAgICAgdGhpcy5fc2F0b3NoaXMgPSBudW0udG9OdW1iZXIoKTtcbiAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcobnVtKSkge1xuICAgICAgdGhpcy5fc2F0b3NoaXMgPSBwYXJzZUludChudW0pO1xuICAgICAgdGhpcy5fc2F0b3NoaXNCTiA9IEJOLmZyb21OdW1iZXIodGhpcy5fc2F0b3NoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkLmNoZWNrQXJndW1lbnQoXG4gICAgICAgIEpTVXRpbC5pc05hdHVyYWxOdW1iZXIobnVtKSxcbiAgICAgICAgJ091dHB1dCBzYXRvc2hpcyBpcyBub3QgYSBuYXR1cmFsIG51bWJlcidcbiAgICAgICk7XG4gICAgICB0aGlzLl9zYXRvc2hpc0JOID0gQk4uZnJvbU51bWJlcihudW0pO1xuICAgICAgdGhpcy5fc2F0b3NoaXMgPSBudW07XG4gICAgfVxuICAgICQuY2hlY2tTdGF0ZShcbiAgICAgIEpTVXRpbC5pc05hdHVyYWxOdW1iZXIodGhpcy5fc2F0b3NoaXMpLFxuICAgICAgJ091dHB1dCBzYXRvc2hpcyBpcyBub3QgYSBuYXR1cmFsIG51bWJlcidcbiAgICApO1xuICB9XG59KTtcblxuT3V0cHV0LnByb3RvdHlwZS5pbnZhbGlkU2F0b3NoaXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3NhdG9zaGlzID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHJldHVybiAndHJhbnNhY3Rpb24gdHhvdXQgc2F0b3NoaXMgZ3JlYXRlciB0aGFuIG1heCBzYWZlIGludGVnZXInO1xuICB9XG4gIGlmICh0aGlzLl9zYXRvc2hpcyAhPT0gdGhpcy5fc2F0b3NoaXNCTi50b051bWJlcigpKSB7XG4gICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCBzYXRvc2hpcyBoYXMgY29ycnVwdGVkIHZhbHVlJztcbiAgfVxuICBpZiAodGhpcy5fc2F0b3NoaXMgPCAwKSB7XG4gICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCBuZWdhdGl2ZSc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS50b09iamVjdCA9IE91dHB1dC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHZhciBvYmogPSB7XG4gICAgc2F0b3NoaXM6IHRoaXMuc2F0b3NoaXNcbiAgfTtcbiAgb2JqLnNjcmlwdCA9IHRoaXMuX3NjcmlwdEJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG4gIHJldHVybiBvYmo7XG59O1xuXG5PdXRwdXQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBPdXRwdXQoZGF0YSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldFNjcmlwdEZyb21CdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdGhpcy5fc2NyaXB0QnVmZmVyID0gYnVmZmVyO1xuICB0cnkge1xuICAgIHRoaXMuX3NjcmlwdCA9IFNjcmlwdC5mcm9tQnVmZmVyKHRoaXMuX3NjcmlwdEJ1ZmZlcik7XG4gICAgdGhpcy5fc2NyaXB0Ll9pc091dHB1dCA9IHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgZXJyb3JzLlNjcmlwdC5JbnZhbGlkQnVmZmVyKSB7XG4gICAgICB0aGlzLl9zY3JpcHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRTY3JpcHQgPSBmdW5jdGlvbihzY3JpcHQpIHtcbiAgaWYgKHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCkge1xuICAgIHRoaXMuX3NjcmlwdEJ1ZmZlciA9IHNjcmlwdC50b0J1ZmZlcigpO1xuICAgIHRoaXMuX3NjcmlwdCA9IHNjcmlwdDtcbiAgICB0aGlzLl9zY3JpcHQuX2lzT3V0cHV0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHNjcmlwdCkpIHtcbiAgICB0aGlzLl9zY3JpcHQgPSBTY3JpcHQuZnJvbVN0cmluZyhzY3JpcHQpO1xuICAgIHRoaXMuX3NjcmlwdEJ1ZmZlciA9IHRoaXMuX3NjcmlwdC50b0J1ZmZlcigpO1xuICAgIHRoaXMuX3NjcmlwdC5faXNPdXRwdXQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGJ1ZmZlclV0aWwuaXNCdWZmZXIoc2NyaXB0KSkge1xuICAgIHRoaXMuc2V0U2NyaXB0RnJvbUJ1ZmZlcihzY3JpcHQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgdHlwZTogc2NyaXB0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNjcmlwdFN0cjtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgc2NyaXB0U3RyID0gdGhpcy5zY3JpcHQuaW5zcGVjdCgpO1xuICB9IGVsc2Uge1xuICAgIHNjcmlwdFN0ciA9IHRoaXMuX3NjcmlwdEJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG4gIH1cbiAgcmV0dXJuICc8T3V0cHV0ICgnICsgdGhpcy5zYXRvc2hpcyArICcgc2F0cykgJyArIHNjcmlwdFN0ciArICc+Jztcbn07XG5cbk91dHB1dC5mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24oYnIpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICBvYmouc2F0b3NoaXMgPSBici5yZWFkVUludDY0TEVCTigpO1xuICB2YXIgc2l6ZSA9IGJyLnJlYWRWYXJpbnROdW0oKTtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICBvYmouc2NyaXB0ID0gYnIucmVhZChzaXplKTtcbiAgfSBlbHNlIHtcbiAgICBvYmouc2NyaXB0ID0gQnVmZmVyLmZyb20oW10pO1xuICB9XG4gIHJldHVybiBuZXcgT3V0cHV0KG9iaik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnRvQnVmZmVyV3JpdGVyID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIGlmICghd3JpdGVyKSB7XG4gICAgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICB9XG4gIHdyaXRlci53cml0ZVVJbnQ2NExFQk4odGhpcy5fc2F0b3NoaXNCTik7XG4gIHZhciBzY3JpcHQgPSB0aGlzLl9zY3JpcHRCdWZmZXI7XG4gIHdyaXRlci53cml0ZVZhcmludE51bShzY3JpcHQubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKHNjcmlwdCk7XG4gIHJldHVybiB3cml0ZXI7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmNhbGN1bGF0ZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHJlc3VsdCA9IDg7IC8vIHNhdG9zaGlzXG4gIHJlc3VsdCArPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKHRoaXMuX3NjcmlwdEJ1ZmZlci5sZW5ndGgpLmxlbmd0aDtcbiAgcmVzdWx0ICs9IHRoaXMuX3NjcmlwdEJ1ZmZlci5sZW5ndGg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRhcHJvb3Qgb25seVxuICogQWRkIGEgbmV3IHNjcmlwdCBhdCBhIGNlcnRhaW4gZGVwdGggaW4gdGhlIHRyZWUuIEFkZCgpIG9wZXJhdGlvbnMgbXVzdCBiZSBjYWxsZWRcbiAqICBpbiBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb3JkZXIgb2YgYmluYXJ5IHRyZWUuIElmIHRyYWNrIGlzIHRydWUsIGl0IHdpbGwgYmUgaW5jbHVkZWQgaW5cbiAqICB0aGUgR2V0U3BlbmREYXRhKCkgb3V0cHV0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIFRyZWUgZGVwdGggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBub2RlIChkZXB0aCBpcyAwLWJhc2VkKVxuICogQHBhcmFtIHtTY3JpcHR9IHNjcmlwdCBcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWFmVmVyc2lvbiBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJhY2sgSWYgdHJ1ZSwgdGhlIGxlYWYgd2lsbCBiZSBpbmNsdWRlZCBpbiBHZXRTcGVuZERhdGEoKSBvdXRwdXRcbiAqL1xuT3V0cHV0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihkZXB0aCwgc2NyaXB0LCBsZWFmVmVyc2lvbiwgdHJhY2sgPSB0cnVlKSB7XG4gICQuY2hlY2tBcmd1bWVudCgobGVhZlZlcnNpb24gJiB+SW50ZXJwcmV0ZXIuVEFQUk9PVF9MRUFGX01BU0spID09PSAwLCAnaW52YWxpZCBsZWFmVmVyc2lvbicpO1xuICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgaGFzaDogVGFnZ2VkSGFzaC5UQVBMRUFGLndyaXRlVUludDgobGVhZlZlcnNpb24pLndyaXRlKHNjcmlwdC50b0J1ZmZlcigpKS5maW5hbGl6ZSgpLFxuICAgIGxlYXZlczogW11cbiAgfTtcbiAgaWYgKHRyYWNrKSB7XG4gICAgY29uc3QgbGVhZkluZm8gPSB7XG4gICAgICBzY3JpcHQsXG4gICAgICBsZWFmVmVyc2lvbixcbiAgICAgIG1lcmtsZUJyYW5jaDogW11cbiAgICB9O1xuICAgIG5vZGUubGVhdmVzLnB1c2gobGVhZkluZm8pO1xuICB9XG4gIHRoaXMuX2luc2VydE5vZGUobm9kZSwgZGVwdGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuT3V0cHV0LnByb3RvdHlwZS5faW5zZXJ0Tm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGRlcHRoKSB7XG4gICQuY2hlY2tBcmd1bWVudChkZXB0aCA+PSAwICYmIGRlcHRoIDw9IEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9NQVhfTk9ERV9DT1VOVCwgJ2ludmFsaWQgZGVwdGgnKTtcbiAgLyogV2UgY2Fubm90IGluc2VydCBhIGxlYWYgYXQgYSBsb3dlciBkZXB0aCB3aGlsZSBhIGRlZXBlciBicmFuY2ggaXMgdW5maW5pc2hlZC4gRG9pbmdcbiAgICogc28gd291bGQgbWVhbiB0aGUgQWRkKCkgaW52b2NhdGlvbnMgZG8gbm90IGNvcnJlc3BvbmQgdG8gYSBERlMgdHJhdmVyc2FsIG9mIGFcbiAgICogYmluYXJ5IHRyZWUuICovXG4gIGlmIChkZXB0aCArIDEgPCB0aGlzLl9icmFuY2gubGVuZ3RoKSB7XG4gICAgdGhpcy5pc1ZhbGlkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qIEFzIGxvbmcgYXMgYW4gZW50cnkgaW4gdGhlIGJyYW5jaCBleGlzdHMgYXQgdGhlIHNwZWNpZmllZCBkZXB0aCwgY29tYmluZSBpdCBhbmQgcHJvcGFnYXRlIHVwLlxuICAgKiBUaGUgJ25vZGUnIHZhcmlhYmxlIGlzIG92ZXJ3cml0dGVuIGhlcmUgd2l0aCB0aGUgbmV3bHkgY29tYmluZWQgbm9kZS4gKi9cbiAgd2hpbGUgKHRoaXMuaXNWYWxpZCAmJiB0aGlzLl9icmFuY2gubGVuZ3RoID4gZGVwdGggJiYgdGhpcy5fYnJhbmNoW2RlcHRoXSkge1xuICAgIG5vZGUgPSB0aGlzLl9jb21iaW5lTm9kZXMobm9kZSwgdGhpcy5fYnJhbmNoW2RlcHRoXSk7XG4gICAgdGhpcy5fYnJhbmNoID0gdGhpcy5fYnJhbmNoLnNsaWNlKDAsIHRoaXMuX2JyYW5jaC5sZW5ndGggLSAyKTtcbiAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgdGhpcy5pc1ZhbGlkID0gZmFsc2U7IC8qIENhbid0IHByb3BhZ2F0ZSBmdXJ0aGVyIHVwIHRoYW4gdGhlIHJvb3QgKi9cbiAgICB9XG4gICAgZGVwdGgtLTtcbiAgfVxuICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgLyogTWFrZSBzdXJlIHRoZSBicmFuY2ggaXMgYmlnIGVub3VnaCB0byBwbGFjZSB0aGUgbmV3IG5vZGUuICovXG4gICAgaWYgKHRoaXMuX2JyYW5jaC5sZW5ndGggPD0gZGVwdGgpIHtcbiAgICAgIHRoaXMuX2JyYW5jaCA9IHRoaXMuX2JyYW5jaC5zbGljZSgwLCBkZXB0aCArIDEpO1xuICAgIH1cbiAgICAkLmNoZWNrU3RhdGUoIXRoaXMuX25vZGVzW2RlcHRoXSk7XG4gICAgbV9icmFuY2hbZGVwdGhdID0gbm9kZTtcbiAgfVxufTtcblxuT3V0cHV0LnByb3RvdHlwZS5fY29tYmluZU5vZGVzID0gZnVuY3Rpb24oYSwgYikge1xuICBjb25zdCByZXQgPSB7XG4gICAgaGFzaDogbnVsbCxcbiAgICBsZWF2ZXM6IFtdXG4gIH07XG4gIC8qIEl0ZXJhdGUgb3ZlciBhbGwgdHJhY2tlZCBsZWF2ZXMgaW4gYSwgYWRkIGIncyBoYXNoIHRvIHRoZWlyIE1lcmtsZSBicmFuY2gsIGFuZCBtb3ZlIHRoZW0gdG8gcmV0LiAqL1xuICBmb3IgKGxldCBsZWFmIG9mIGEubGVhdmVzKSB7XG4gICAgbGVhZi5tZXJrbGVCcmFuY2gucHVzaChiLmhhc2gpO1xuICAgIHJldC5sZWF2ZXMucHVzaChsZWFmKTtcbiAgfVxuICAvKiBJdGVyYXRlIG92ZXIgYWxsIHRyYWNrZWQgbGVhdmVzIGluIGIsIGFkZCBhJ3MgaGFzaCB0byB0aGVpciBNZXJrbGUgYnJhbmNoLCBhbmQgbW92ZSB0aGVtIHRvIHJldC4gKi9cbiAgZm9yIChsZXQgbGVhZiBvZiBiLmxlYXZlcykge1xuICAgIGxlYWYubWVya2xlQnJhbmNoLnB1c2goYS5oYXNoKTtcbiAgICByZXQubGVhdmVzLnB1c2gobGVhZik7XG4gIH1cbiAgLyogTGV4aWNvZ3JhcGhpY2FsbHkgc29ydCBhIGFuZCBiJ3MgaGFzaCwgYW5kIGNvbXB1dGUgcGFyZW50IGhhc2guICovXG4gIGlmIChhLmhhc2guY29tcGFyZShiLmhhc2gpID09PSAtMSkge1xuICAgIHJldC5oYXNoID0gVGFnZ2VkSGFzaC5UQVBCUkFOQ0gud3JpdGUoYS5oYXNoKS53cml0ZShiLmhhc2gpLmZpbmFsaXplKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0Lmhhc2ggPSBUYWdnZWRIYXNoLlRBUEJSQU5DSC53cml0ZShiLmhhc2gpLndyaXRlKGEuaGFzaCkuZmluYWxpemUoKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG4vKipcbiAqIEZpbmFsaXplIHRoZSBjb25zdHJ1Y3Rpb24uIENhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIElzQ29tcGxldGUoKSBpcyB0cnVlLlxuICogIGludGVybmFsX2tleS5Jc0Z1bGx5VmFsaWQoKSBtdXN0IGJlIHRydWUuXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcHViS2V5IFxuICovXG5PdXRwdXQucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24ocHViS2V5KSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLmlzQ29tcGxldGUgPT09IHRydWUsICdmaW5hbGl6ZSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiBpc0NvbXBsZXRlIGlzIHRydWUnKTtcbiAgY29uc3QgcmV0ID0gcHViS2V5LmNyZWF0ZVRhcFR3ZWFrKHRoaXMuX2JyYW5jaC5sZW5ndGggPT09IDAgPyBudWxsIDogdGhpcy5fYnJhbmNoWzBdLmhhc2gpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE91dHB1dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js":
/*!*************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/sighash.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Output = __webpack_require__(/*! ./output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar ECDSA = __webpack_require__(/*! ../crypto/ecdsa */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\n  var Transaction = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js\");\n  var Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js\");\n\n  // Convert a string to a number\n  inputNumber = parseInt(inputNumber);\n\n  var i;\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n  subscript.removeCodeseparators();\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter()\n    .write(txcopy.toBuffer())\n    .writeInt32LE(sighashType)\n    .toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript) {\n  let hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\n  return ECDSA.sign(hashbuf, privateKey, 'little').set({ nhashtype: sighashType })\n};\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript) {\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\n  return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n};\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMscUZBQXFCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQyx1RUFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsNEVBQVU7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxTQUFTLG1CQUFPLENBQUMsdUVBQWM7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxZQUFZLG1CQUFPLENBQUMsNkVBQWlCO0FBQ3JDLFFBQVEsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDdkMsUUFBUSxtQkFBTyxDQUFDLHFEQUFROztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFlO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyxnRkFBUzs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi90cmFuc2FjdGlvbi9zaWdoYXNoLmpzPzM4NTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xudmFyIE91dHB1dCA9IHJlcXVpcmUoJy4vb3V0cHV0Jyk7XG52YXIgQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVycmVhZGVyJyk7XG52YXIgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XG52YXIgQk4gPSByZXF1aXJlKCcuLi9jcnlwdG8vYm4nKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcbnZhciBFQ0RTQSA9IHJlcXVpcmUoJy4uL2NyeXB0by9lY2RzYScpO1xudmFyICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBTSUdIQVNIX1NJTkdMRV9CVUcgPSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMSc7XG52YXIgQklUU182NF9PTiA9ICdmZmZmZmZmZmZmZmZmZmZmJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIG9mIGxlbmd0aCAzMiBieXRlcyB3aXRoIHRoZSBoYXNoIHRoYXQgbmVlZHMgdG8gYmUgc2lnbmVkXG4gKiBmb3IgT1BfQ0hFQ0tTSUcuXG4gKlxuICogQG5hbWUgU2lnbmluZy5zaWdoYXNoXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiB0aGUgdHJhbnNhY3Rpb24gdG8gc2lnblxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ2hhc2hUeXBlIHRoZSB0eXBlIG9mIHRoZSBoYXNoXG4gKiBAcGFyYW0ge251bWJlcn0gaW5wdXROdW1iZXIgdGhlIGlucHV0IGluZGV4IGZvciB0aGUgc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1NjcmlwdH0gc3Vic2NyaXB0IHRoZSBzY3JpcHQgdGhhdCB3aWxsIGJlIHNpZ25lZFxuICovXG52YXIgc2lnaGFzaCA9IGZ1bmN0aW9uIHNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dE51bWJlciwgc3Vic2NyaXB0KSB7XG4gIHZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbiAgdmFyIElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuXG4gIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXJcbiAgaW5wdXROdW1iZXIgPSBwYXJzZUludChpbnB1dE51bWJlcik7XG5cbiAgdmFyIGk7XG4gIC8vIENvcHkgdHJhbnNhY3Rpb25cbiAgdmFyIHR4Y29weSA9IFRyYW5zYWN0aW9uLnNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcblxuICAvLyBDb3B5IHNjcmlwdFxuICBzdWJzY3JpcHQgPSBuZXcgU2NyaXB0KHN1YnNjcmlwdCk7XG4gIHN1YnNjcmlwdC5yZW1vdmVDb2Rlc2VwYXJhdG9ycygpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0eGNvcHkuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gQmxhbmsgc2lnbmF0dXJlcyBmb3Igb3RoZXIgaW5wdXRzXG4gICAgdHhjb3B5LmlucHV0c1tpXSA9IG5ldyBJbnB1dCh0eGNvcHkuaW5wdXRzW2ldKS5zZXRTY3JpcHQoU2NyaXB0LmVtcHR5KCkpO1xuICB9XG5cbiAgdHhjb3B5LmlucHV0c1tpbnB1dE51bWJlcl0gPSBuZXcgSW5wdXQodHhjb3B5LmlucHV0c1tpbnB1dE51bWJlcl0pLnNldFNjcmlwdChzdWJzY3JpcHQpO1xuXG4gIGlmICgoc2lnaGFzaFR5cGUgJiAzMSkgPT09IFNpZ25hdHVyZS5TSUdIQVNIX05PTkUgfHxcbiAgICAoc2lnaGFzaFR5cGUgJiAzMSkgPT09IFNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSkge1xuXG4gICAgLy8gY2xlYXIgYWxsIHNlcXVlbmNlTnVtYmVyc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0eGNvcHkuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSAhPT0gaW5wdXROdW1iZXIpIHtcbiAgICAgICAgdHhjb3B5LmlucHV0c1tpXS5zZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzaWdoYXNoVHlwZSAmIDMxKSA9PT0gU2lnbmF0dXJlLlNJR0hBU0hfTk9ORSkge1xuICAgIHR4Y29weS5vdXRwdXRzID0gW107XG5cbiAgfSBlbHNlIGlmICgoc2lnaGFzaFR5cGUgJiAzMSkgPT09IFNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSkge1xuICAgIC8vIFRoZSBTSUdIQVNIX1NJTkdMRSBidWcuXG4gICAgLy8gaHR0cHM6Ly9iaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI2MDU5NS4wXG4gICAgaWYgKGlucHV0TnVtYmVyID49IHR4Y29weS5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFNJR0hBU0hfU0lOR0xFX0JVRywgJ2hleCcpO1xuICAgIH1cblxuICAgIHR4Y29weS5vdXRwdXRzLmxlbmd0aCA9IGlucHV0TnVtYmVyICsgMTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dE51bWJlcjsgaSsrKSB7XG4gICAgICB0eGNvcHkub3V0cHV0c1tpXSA9IG5ldyBPdXRwdXQoe1xuICAgICAgICBzYXRvc2hpczogQk4uZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbShCSVRTXzY0X09OLCAnaGV4JykpLFxuICAgICAgICBzY3JpcHQ6IFNjcmlwdC5lbXB0eSgpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2lnaGFzaFR5cGUgJiBTaWduYXR1cmUuU0lHSEFTSF9BTllPTkVDQU5QQVkpIHtcbiAgICB0eGNvcHkuaW5wdXRzID0gW3R4Y29weS5pbnB1dHNbaW5wdXROdW1iZXJdXTtcbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyV3JpdGVyKClcbiAgICAud3JpdGUodHhjb3B5LnRvQnVmZmVyKCkpXG4gICAgLndyaXRlSW50MzJMRShzaWdoYXNoVHlwZSlcbiAgICAudG9CdWZmZXIoKTtcbiAgdmFyIHJldCA9IEhhc2guc2hhMjU2c2hhMjU2KGJ1Zik7XG4gIHJldCA9IG5ldyBCdWZmZXJSZWFkZXIocmV0KS5yZWFkUmV2ZXJzZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzaWduYXR1cmVcbiAqXG4gKiBAbmFtZSBTaWduaW5nLnNpZ25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWdoYXNoXG4gKiBAcGFyYW0ge251bWJlcn0gaW5wdXRJbmRleFxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdFxuICogQHJldHVybiB7U2lnbmF0dXJlfVxuICovXG5mdW5jdGlvbiBzaWduKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBzaWdoYXNoVHlwZSwgaW5wdXRJbmRleCwgc3Vic2NyaXB0KSB7XG4gIGxldCBoYXNoYnVmID0gc2lnaGFzaCh0cmFuc2FjdGlvbiwgc2lnaGFzaFR5cGUsIGlucHV0SW5kZXgsIHN1YnNjcmlwdCk7XG4gIHJldHVybiBFQ0RTQS5zaWduKGhhc2hidWYsIHByaXZhdGVLZXksICdsaXR0bGUnKS5zZXQoeyBuaGFzaHR5cGU6IHNpZ2hhc2hUeXBlIH0pXG59O1xuXG4vKipcbiAqIFZlcmlmeSBhIHNpZ25hdHVyZVxuICpcbiAqIEBuYW1lIFNpZ25pbmcudmVyaWZ5XG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmxpY0tleVxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0SW5kZXhcbiAqIEBwYXJhbSB7U2NyaXB0fSBzdWJzY3JpcHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZlcmlmeSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBwdWJsaWNLZXksIGlucHV0SW5kZXgsIHN1YnNjcmlwdCkge1xuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQodHJhbnNhY3Rpb24pLCBcIlRyYW5zYWN0aW9uIFVuZGVmaW5lZFwiKTtcbiAgJC5jaGVja0FyZ3VtZW50KCFfLmlzVW5kZWZpbmVkKHNpZ25hdHVyZSkgJiYgIV8uaXNVbmRlZmluZWQoc2lnbmF0dXJlLm5oYXNodHlwZSksIFwiU2lnbmF0dXJlIFVuZGVmaW5lZFwiKTtcblxuICBsZXQgaGFzaGJ1ZiA9IHNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ25hdHVyZS5uaGFzaHR5cGUsIGlucHV0SW5kZXgsIHN1YnNjcmlwdCk7XG4gIHJldHVybiBFQ0RTQS52ZXJpZnkoaGFzaGJ1Ziwgc2lnbmF0dXJlLCBwdWJsaWNLZXksICdsaXR0bGUnKTtcbn07XG5cbi8qKlxuICogQG5hbWVzcGFjZSBTaWduaW5nXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaWdoYXNoOiBzaWdoYXNoLFxuICBzaWduOiBzaWduLFxuICB2ZXJpZnk6IHZlcmlmeVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* jshint maxparams:5 */\n\nconst Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nconst BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nconst Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nconst Schnorr = __webpack_require__(/*! ../crypto/schnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/schnorr.js\");\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\nconst PrivateKey = __webpack_require__(/*! ../privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness v1 programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {Number} sighashType the type of the hash\n * @param {Number} inputNumber the input index for the signature\n * @param {Number} sigversion Taproot or Tapscript version number\n * @param {Object} execdata Object with directives and data for creating the signature hash\n */\nfunction _signatureHash(transaction, sighashType, inputNumber, sigversion, execdata) {\n  let extFlag, keyVersion;\n\n  switch (sigversion) {\n    case Signature.Version.TAPROOT:\n      extFlag = 0;\n      // keyVersion is not used and left uninitialized.\n      break;\n    case Signature.Version.TAPSCRIPT:\n      extFlag = 1;\n      // keyVersion must be 0 for now, representing the current version of\n      // 32-byte public keys in the tapscript signature opcode execution.\n      // An upgradable public key version (with a size not 32-byte) may\n      // request a different keyVersion with a new sigversion.\n      keyVersion = 0;\n      break;\n    default:\n      return false;\n  }\n  $.checkArgument(inputNumber < transaction.inputs.length, 'inputNumber is greater than number of inputs');\n\n  const ss = TaggedHash.TAPSIGHASH;\n\n  // Epoch\n  ss.writeUInt8(0);\n\n  // Hash type\n  const outputType = (sighashType == Signature.SIGHASH_DEFAULT) ? Signature.SIGHASH_ALL : (sighashType & Signature.SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n  const inputType = sighashType & Signature.SIGHASH_INPUT_MASK;\n  if (!(sighashType <= 0x03 || (sighashType >= 0x81 && sighashType <= 0x83))) { // Check valid sighashtype (Signature.SIGHASH_*)\n    return false;\n  }\n  ss.writeUInt8(sighashType);\n\n  // Transaction level data\n  ss.writeInt32LE(transaction.version);\n  ss.writeUInt32LE(transaction.nLockTime);\n  if (inputType !== Signature.SIGHASH_ANYONECANPAY) {\n    const prevoutsBW = new BufferWriter();\n    const spentAmountsBW = new BufferWriter();\n    const spentScriptsBW = new BufferWriter();\n    const sequencesBW = new BufferWriter();\n\n    for(let vin of transaction.inputs) {\n      prevoutsBW.writeReverse(vin.prevTxId);\n      prevoutsBW.writeInt32LE(vin.outputIndex);\n\n      spentAmountsBW.writeUInt64LEBN(vin.output._satoshisBN);\n\n      const scriptBuf = vin.output.script.toBuffer();\n      spentScriptsBW.writeUInt8(scriptBuf.length);\n      spentScriptsBW.write(scriptBuf);\n\n      sequencesBW.writeUInt32LE(vin.sequenceNumber);\n    }\n\n    // ss << cache.m_prevouts_single_hash;\n    const prevoutsSingleHash = Hash.sha256(prevoutsBW.toBuffer());\n    ss.write(prevoutsSingleHash);\n\n    // ss << cache.m_spent_amounts_single_hash;\n    const spentAmountsSingleHash = Hash.sha256(spentAmountsBW.toBuffer());\n    ss.write(spentAmountsSingleHash);\n\n    // ss << cache.m_spent_scripts_single_hash;\n    const spentScriptsSingleHash = Hash.sha256(spentScriptsBW.toBuffer());\n    ss.write(spentScriptsSingleHash);\n\n    // ss << cache.m_sequences_single_hash;\n    const sequencesSingleHash = Hash.sha256(sequencesBW.toBuffer());\n    ss.write(sequencesSingleHash);\n  }\n  if (outputType === Signature.SIGHASH_ALL) {\n    const outputsBW = new BufferWriter();\n    for (let vout of transaction.outputs) {\n      outputsBW.write(vout.toBufferWriter().toBuffer());\n    }\n    // ss << cache.m_outputs_single_hash;\n    const outputsSingleHash = Hash.sha256(outputsBW.toBuffer());\n    ss.write(outputsSingleHash);\n  }\n\n  // Data about the input/prevout being spent\n  $.checkArgument(execdata.annexInit, 'missing or invalid annexInit');\n  const spendType = (extFlag << 1) + (execdata.annexPresent ? 1 : 0); // The low bit indicates whether an annex is present.\n  ss.writeUInt8(spendType);\n  if (inputType === Signature.SIGHASH_ANYONECANPAY) {\n    // ss << tx_to.vin[in_pos].prevout;\n    const buf = new BufferWriter();\n    buf.writeReverse(transaction.inputs[inputNumber].prevTxId);\n    buf.writeInt32LE(transaction.inputs[inputNumber].outputIndex);\n    ss.write(buf.toBuffer());\n    // ss << cache.m_spent_outputs[inputNumber];\n    ss.write(transaction.inputs[inputNumber].output.toBufferWriter().toBuffer());\n    ss.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n  } else {\n    ss.writeUInt32LE(inputNumber);\n  }\n  if (execdata.annexPresent) {\n    ss.write(execdata.annexHash);\n  }\n\n  // Data about the output (if only one).\n  if (outputType === Signature.SIGHASH_SINGLE) {\n    if (inputNumber >= transaction.outputs.length) {\n      return false;\n    }\n    const bw = new BufferWriter();\n    bw.writeUInt64LEBN(transaction.outputs[inputNumber]._satoshisBN);\n    const buf = transaction.outputs[inputNumber].script.toBuffer();\n    bw.writeVarintNum(buf.length);\n    bw.write(buf);\n    ss.write(Hash.sha256(bw.toBuffer()));\n  }\n\n  // Additional data for BIP 342 signatures\n  if (sigversion == Signature.Version.TAPSCRIPT) {\n    $.checkArgument(execdata.tapleafHashInit, 'missing or invalid tapleafHashInit');\n    ss.write(execdata.tapleafHash);\n    ss.writeUInt8(keyVersion);\n    $.checkArgument(execdata.codeseparatorPosInit, 'missing or invalid codeseparatorPosInit');\n    ss.writeUInt32LE(execdata.codeseparatorPos);\n  }\n\n  // Return the SHA256 hash\n  return ss.finalize();\n};\n\n\nfunction _getExecData(sigversion, leafHash) {\n  const execdata = { annexInit: true, annexPresent: false };\n  if (sigversion === Signature.Version.TAPSCRIPT) {\n    execdata.codeseparatorPosInit = true;\n    execdata.codeseparatorPos = 0xFFFFFFFF; // Only support non-OP_CODESEPARATOR BIP342 signing for now.\n    if (!leafHash) return false; // BIP342 signing needs leaf hash.\n    execdata.tapleafHashInit = true;\n    execdata.tapleafHash = leafHash;\n  }\n  return execdata;\n}\n\n\n/**\n * Create a Schnorr signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {Buffer|BN|PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {number} sigversion\n * @param {Buffer} leafHash\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, sigversion, leafHash) {\n  $.checkArgument(sigversion === Signature.Version.TAPROOT || sigversion === Signature.Version.TAPSCRIPT, 'Invalid sigversion');\n  \n  const execdata = _getExecData(sigversion, leafHash);\n  const hashbuf = _signatureHash(transaction, sighashType, inputIndex, sigversion, execdata);\n  if (!hashbuf) {\n    return false;\n  }\n  const sig = Schnorr.sign(privateKey, hashbuf);\n  if (sighashType !== Signature.SIGHASH_DEFAULT) {\n    return Buffer.concat([sig, Buffer.from([sighashType])]); // 65 bytes\n  }\n  return sig; // 64 bytes\n};\n\n\n/**\n * Verify a Schnorr signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {Number} inputIndex\n * @param {object|Buffer|null} execdata If given, can be full execdata object or just the leafHash buffer\n * @return {Boolean}\n */\nfunction verify(transaction, signature, publicKey, sigversion, inputIndex, execdata) {\n  $.checkArgument(transaction != null, 'Transaction Undefined');\n\n  if (!execdata || Buffer.isBuffer(execdata)) {\n    const leafHash = execdata;\n    execdata = _getExecData(sigversion, leafHash);\n  }\n\n  $.checkArgument(execdata.annexInit, 'invalid execdata');\n\n  const hashbuf = _signatureHash(transaction, signature.nhashtype, inputIndex, sigversion, execdata);\n  if (!hashbuf) {\n    return false;\n  }\n  const verified = Schnorr.verify(publicKey, hashbuf, signature);\n  return verified;\n};\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sign: sign,\n  verify: verify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2hzY2hub3JyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFxQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBbUI7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLHlGQUF1QjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMseUVBQWU7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlJQUF5STtBQUN6STtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsY0FBYztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLG9CQUFvQjtBQUMvQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2hzY2hub3JyLmpzP2E1MDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBqc2hpbnQgbWF4cGFyYW1zOjUgKi9cblxuY29uc3QgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xuY29uc3QgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XG5jb25zdCBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcbmNvbnN0IFNjaG5vcnIgPSByZXF1aXJlKCcuLi9jcnlwdG8vc2Nobm9ycicpO1xuY29uc3QgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by90YWdnZWRoYXNoJyk7XG5jb25zdCBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZWtleScpO1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgb2YgbGVuZ3RoIDMyIGJ5dGVzIHdpdGggdGhlIGhhc2ggdGhhdCBuZWVkcyB0byBiZSBzaWduZWRcbiAqIGZvciB3aXRuZXNzIHYxIHByb2dyYW1zIGFzIGRlZmluZWQgYnk6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuICpcbiAqIEBuYW1lIFNpZ25pbmcuc2lnaGFzaFxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gdGhlIHRyYW5zYWN0aW9uIHRvIHNpZ25cbiAqIEBwYXJhbSB7TnVtYmVyfSBzaWdoYXNoVHlwZSB0aGUgdHlwZSBvZiB0aGUgaGFzaFxuICogQHBhcmFtIHtOdW1iZXJ9IGlucHV0TnVtYmVyIHRoZSBpbnB1dCBpbmRleCBmb3IgdGhlIHNpZ25hdHVyZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNpZ3ZlcnNpb24gVGFwcm9vdCBvciBUYXBzY3JpcHQgdmVyc2lvbiBudW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBleGVjZGF0YSBPYmplY3Qgd2l0aCBkaXJlY3RpdmVzIGFuZCBkYXRhIGZvciBjcmVhdGluZyB0aGUgc2lnbmF0dXJlIGhhc2hcbiAqL1xuZnVuY3Rpb24gX3NpZ25hdHVyZUhhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dE51bWJlciwgc2lndmVyc2lvbiwgZXhlY2RhdGEpIHtcbiAgbGV0IGV4dEZsYWcsIGtleVZlcnNpb247XG5cbiAgc3dpdGNoIChzaWd2ZXJzaW9uKSB7XG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09UOlxuICAgICAgZXh0RmxhZyA9IDA7XG4gICAgICAvLyBrZXlWZXJzaW9uIGlzIG5vdCB1c2VkIGFuZCBsZWZ0IHVuaW5pdGlhbGl6ZWQuXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVDpcbiAgICAgIGV4dEZsYWcgPSAxO1xuICAgICAgLy8ga2V5VmVyc2lvbiBtdXN0IGJlIDAgZm9yIG5vdywgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHZlcnNpb24gb2ZcbiAgICAgIC8vIDMyLWJ5dGUgcHVibGljIGtleXMgaW4gdGhlIHRhcHNjcmlwdCBzaWduYXR1cmUgb3Bjb2RlIGV4ZWN1dGlvbi5cbiAgICAgIC8vIEFuIHVwZ3JhZGFibGUgcHVibGljIGtleSB2ZXJzaW9uICh3aXRoIGEgc2l6ZSBub3QgMzItYnl0ZSkgbWF5XG4gICAgICAvLyByZXF1ZXN0IGEgZGlmZmVyZW50IGtleVZlcnNpb24gd2l0aCBhIG5ldyBzaWd2ZXJzaW9uLlxuICAgICAga2V5VmVyc2lvbiA9IDA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gICQuY2hlY2tBcmd1bWVudChpbnB1dE51bWJlciA8IHRyYW5zYWN0aW9uLmlucHV0cy5sZW5ndGgsICdpbnB1dE51bWJlciBpcyBncmVhdGVyIHRoYW4gbnVtYmVyIG9mIGlucHV0cycpO1xuXG4gIGNvbnN0IHNzID0gVGFnZ2VkSGFzaC5UQVBTSUdIQVNIO1xuXG4gIC8vIEVwb2NoXG4gIHNzLndyaXRlVUludDgoMCk7XG5cbiAgLy8gSGFzaCB0eXBlXG4gIGNvbnN0IG91dHB1dFR5cGUgPSAoc2lnaGFzaFR5cGUgPT0gU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVCkgPyBTaWduYXR1cmUuU0lHSEFTSF9BTEwgOiAoc2lnaGFzaFR5cGUgJiBTaWduYXR1cmUuU0lHSEFTSF9PVVRQVVRfTUFTSyk7IC8vIERlZmF1bHQgKG5vIHNpZ2hhc2ggYnl0ZSkgaXMgZXF1aXZhbGVudCB0byBTSUdIQVNIX0FMTFxuICBjb25zdCBpbnB1dFR5cGUgPSBzaWdoYXNoVHlwZSAmIFNpZ25hdHVyZS5TSUdIQVNIX0lOUFVUX01BU0s7XG4gIGlmICghKHNpZ2hhc2hUeXBlIDw9IDB4MDMgfHwgKHNpZ2hhc2hUeXBlID49IDB4ODEgJiYgc2lnaGFzaFR5cGUgPD0gMHg4MykpKSB7IC8vIENoZWNrIHZhbGlkIHNpZ2hhc2h0eXBlIChTaWduYXR1cmUuU0lHSEFTSF8qKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzcy53cml0ZVVJbnQ4KHNpZ2hhc2hUeXBlKTtcblxuICAvLyBUcmFuc2FjdGlvbiBsZXZlbCBkYXRhXG4gIHNzLndyaXRlSW50MzJMRSh0cmFuc2FjdGlvbi52ZXJzaW9uKTtcbiAgc3Mud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5uTG9ja1RpbWUpO1xuICBpZiAoaW5wdXRUeXBlICE9PSBTaWduYXR1cmUuU0lHSEFTSF9BTllPTkVDQU5QQVkpIHtcbiAgICBjb25zdCBwcmV2b3V0c0JXID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgIGNvbnN0IHNwZW50QW1vdW50c0JXID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgIGNvbnN0IHNwZW50U2NyaXB0c0JXID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgIGNvbnN0IHNlcXVlbmNlc0JXID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuXG4gICAgZm9yKGxldCB2aW4gb2YgdHJhbnNhY3Rpb24uaW5wdXRzKSB7XG4gICAgICBwcmV2b3V0c0JXLndyaXRlUmV2ZXJzZSh2aW4ucHJldlR4SWQpO1xuICAgICAgcHJldm91dHNCVy53cml0ZUludDMyTEUodmluLm91dHB1dEluZGV4KTtcblxuICAgICAgc3BlbnRBbW91bnRzQlcud3JpdGVVSW50NjRMRUJOKHZpbi5vdXRwdXQuX3NhdG9zaGlzQk4pO1xuXG4gICAgICBjb25zdCBzY3JpcHRCdWYgPSB2aW4ub3V0cHV0LnNjcmlwdC50b0J1ZmZlcigpO1xuICAgICAgc3BlbnRTY3JpcHRzQlcud3JpdGVVSW50OChzY3JpcHRCdWYubGVuZ3RoKTtcbiAgICAgIHNwZW50U2NyaXB0c0JXLndyaXRlKHNjcmlwdEJ1Zik7XG5cbiAgICAgIHNlcXVlbmNlc0JXLndyaXRlVUludDMyTEUodmluLnNlcXVlbmNlTnVtYmVyKTtcbiAgICB9XG5cbiAgICAvLyBzcyA8PCBjYWNoZS5tX3ByZXZvdXRzX3NpbmdsZV9oYXNoO1xuICAgIGNvbnN0IHByZXZvdXRzU2luZ2xlSGFzaCA9IEhhc2guc2hhMjU2KHByZXZvdXRzQlcudG9CdWZmZXIoKSk7XG4gICAgc3Mud3JpdGUocHJldm91dHNTaW5nbGVIYXNoKTtcblxuICAgIC8vIHNzIDw8IGNhY2hlLm1fc3BlbnRfYW1vdW50c19zaW5nbGVfaGFzaDtcbiAgICBjb25zdCBzcGVudEFtb3VudHNTaW5nbGVIYXNoID0gSGFzaC5zaGEyNTYoc3BlbnRBbW91bnRzQlcudG9CdWZmZXIoKSk7XG4gICAgc3Mud3JpdGUoc3BlbnRBbW91bnRzU2luZ2xlSGFzaCk7XG5cbiAgICAvLyBzcyA8PCBjYWNoZS5tX3NwZW50X3NjcmlwdHNfc2luZ2xlX2hhc2g7XG4gICAgY29uc3Qgc3BlbnRTY3JpcHRzU2luZ2xlSGFzaCA9IEhhc2guc2hhMjU2KHNwZW50U2NyaXB0c0JXLnRvQnVmZmVyKCkpO1xuICAgIHNzLndyaXRlKHNwZW50U2NyaXB0c1NpbmdsZUhhc2gpO1xuXG4gICAgLy8gc3MgPDwgY2FjaGUubV9zZXF1ZW5jZXNfc2luZ2xlX2hhc2g7XG4gICAgY29uc3Qgc2VxdWVuY2VzU2luZ2xlSGFzaCA9IEhhc2guc2hhMjU2KHNlcXVlbmNlc0JXLnRvQnVmZmVyKCkpO1xuICAgIHNzLndyaXRlKHNlcXVlbmNlc1NpbmdsZUhhc2gpO1xuICB9XG4gIGlmIChvdXRwdXRUeXBlID09PSBTaWduYXR1cmUuU0lHSEFTSF9BTEwpIHtcbiAgICBjb25zdCBvdXRwdXRzQlcgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgZm9yIChsZXQgdm91dCBvZiB0cmFuc2FjdGlvbi5vdXRwdXRzKSB7XG4gICAgICBvdXRwdXRzQlcud3JpdGUodm91dC50b0J1ZmZlcldyaXRlcigpLnRvQnVmZmVyKCkpO1xuICAgIH1cbiAgICAvLyBzcyA8PCBjYWNoZS5tX291dHB1dHNfc2luZ2xlX2hhc2g7XG4gICAgY29uc3Qgb3V0cHV0c1NpbmdsZUhhc2ggPSBIYXNoLnNoYTI1NihvdXRwdXRzQlcudG9CdWZmZXIoKSk7XG4gICAgc3Mud3JpdGUob3V0cHV0c1NpbmdsZUhhc2gpO1xuICB9XG5cbiAgLy8gRGF0YSBhYm91dCB0aGUgaW5wdXQvcHJldm91dCBiZWluZyBzcGVudFxuICAkLmNoZWNrQXJndW1lbnQoZXhlY2RhdGEuYW5uZXhJbml0LCAnbWlzc2luZyBvciBpbnZhbGlkIGFubmV4SW5pdCcpO1xuICBjb25zdCBzcGVuZFR5cGUgPSAoZXh0RmxhZyA8PCAxKSArIChleGVjZGF0YS5hbm5leFByZXNlbnQgPyAxIDogMCk7IC8vIFRoZSBsb3cgYml0IGluZGljYXRlcyB3aGV0aGVyIGFuIGFubmV4IGlzIHByZXNlbnQuXG4gIHNzLndyaXRlVUludDgoc3BlbmRUeXBlKTtcbiAgaWYgKGlucHV0VHlwZSA9PT0gU2lnbmF0dXJlLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSB7XG4gICAgLy8gc3MgPDwgdHhfdG8udmluW2luX3Bvc10ucHJldm91dDtcbiAgICBjb25zdCBidWYgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgYnVmLndyaXRlUmV2ZXJzZSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLnByZXZUeElkKTtcbiAgICBidWYud3JpdGVJbnQzMkxFKHRyYW5zYWN0aW9uLmlucHV0c1tpbnB1dE51bWJlcl0ub3V0cHV0SW5kZXgpO1xuICAgIHNzLndyaXRlKGJ1Zi50b0J1ZmZlcigpKTtcbiAgICAvLyBzcyA8PCBjYWNoZS5tX3NwZW50X291dHB1dHNbaW5wdXROdW1iZXJdO1xuICAgIHNzLndyaXRlKHRyYW5zYWN0aW9uLmlucHV0c1tpbnB1dE51bWJlcl0ub3V0cHV0LnRvQnVmZmVyV3JpdGVyKCkudG9CdWZmZXIoKSk7XG4gICAgc3Mud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLnNlcXVlbmNlTnVtYmVyKTtcbiAgfSBlbHNlIHtcbiAgICBzcy53cml0ZVVJbnQzMkxFKGlucHV0TnVtYmVyKTtcbiAgfVxuICBpZiAoZXhlY2RhdGEuYW5uZXhQcmVzZW50KSB7XG4gICAgc3Mud3JpdGUoZXhlY2RhdGEuYW5uZXhIYXNoKTtcbiAgfVxuXG4gIC8vIERhdGEgYWJvdXQgdGhlIG91dHB1dCAoaWYgb25seSBvbmUpLlxuICBpZiAob3V0cHV0VHlwZSA9PT0gU2lnbmF0dXJlLlNJR0hBU0hfU0lOR0xFKSB7XG4gICAgaWYgKGlucHV0TnVtYmVyID49IHRyYW5zYWN0aW9uLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJ3ID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgIGJ3LndyaXRlVUludDY0TEVCTih0cmFuc2FjdGlvbi5vdXRwdXRzW2lucHV0TnVtYmVyXS5fc2F0b3NoaXNCTik7XG4gICAgY29uc3QgYnVmID0gdHJhbnNhY3Rpb24ub3V0cHV0c1tpbnB1dE51bWJlcl0uc2NyaXB0LnRvQnVmZmVyKCk7XG4gICAgYncud3JpdGVWYXJpbnROdW0oYnVmLmxlbmd0aCk7XG4gICAgYncud3JpdGUoYnVmKTtcbiAgICBzcy53cml0ZShIYXNoLnNoYTI1Nihidy50b0J1ZmZlcigpKSk7XG4gIH1cblxuICAvLyBBZGRpdGlvbmFsIGRhdGEgZm9yIEJJUCAzNDIgc2lnbmF0dXJlc1xuICBpZiAoc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQpIHtcbiAgICAkLmNoZWNrQXJndW1lbnQoZXhlY2RhdGEudGFwbGVhZkhhc2hJbml0LCAnbWlzc2luZyBvciBpbnZhbGlkIHRhcGxlYWZIYXNoSW5pdCcpO1xuICAgIHNzLndyaXRlKGV4ZWNkYXRhLnRhcGxlYWZIYXNoKTtcbiAgICBzcy53cml0ZVVJbnQ4KGtleVZlcnNpb24pO1xuICAgICQuY2hlY2tBcmd1bWVudChleGVjZGF0YS5jb2Rlc2VwYXJhdG9yUG9zSW5pdCwgJ21pc3Npbmcgb3IgaW52YWxpZCBjb2Rlc2VwYXJhdG9yUG9zSW5pdCcpO1xuICAgIHNzLndyaXRlVUludDMyTEUoZXhlY2RhdGEuY29kZXNlcGFyYXRvclBvcyk7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIFNIQTI1NiBoYXNoXG4gIHJldHVybiBzcy5maW5hbGl6ZSgpO1xufTtcblxuXG5mdW5jdGlvbiBfZ2V0RXhlY0RhdGEoc2lndmVyc2lvbiwgbGVhZkhhc2gpIHtcbiAgY29uc3QgZXhlY2RhdGEgPSB7IGFubmV4SW5pdDogdHJ1ZSwgYW5uZXhQcmVzZW50OiBmYWxzZSB9O1xuICBpZiAoc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBUKSB7XG4gICAgZXhlY2RhdGEuY29kZXNlcGFyYXRvclBvc0luaXQgPSB0cnVlO1xuICAgIGV4ZWNkYXRhLmNvZGVzZXBhcmF0b3JQb3MgPSAweEZGRkZGRkZGOyAvLyBPbmx5IHN1cHBvcnQgbm9uLU9QX0NPREVTRVBBUkFUT1IgQklQMzQyIHNpZ25pbmcgZm9yIG5vdy5cbiAgICBpZiAoIWxlYWZIYXNoKSByZXR1cm4gZmFsc2U7IC8vIEJJUDM0MiBzaWduaW5nIG5lZWRzIGxlYWYgaGFzaC5cbiAgICBleGVjZGF0YS50YXBsZWFmSGFzaEluaXQgPSB0cnVlO1xuICAgIGV4ZWNkYXRhLnRhcGxlYWZIYXNoID0gbGVhZkhhc2g7XG4gIH1cbiAgcmV0dXJuIGV4ZWNkYXRhO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgU2Nobm9yciBzaWduYXR1cmVcbiAqXG4gKiBAbmFtZSBTaWduaW5nLnNpZ25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcnxCTnxQcml2YXRlS2V5fSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge251bWJlcn0gc2lnaGFzaFxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0SW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWd2ZXJzaW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbGVhZkhhc2hcbiAqIEByZXR1cm4ge1NpZ25hdHVyZX1cbiAqL1xuZnVuY3Rpb24gc2lnbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgc2lnaGFzaFR5cGUsIGlucHV0SW5kZXgsIHNpZ3ZlcnNpb24sIGxlYWZIYXNoKSB7XG4gICQuY2hlY2tBcmd1bWVudChzaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09UIHx8IHNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVCwgJ0ludmFsaWQgc2lndmVyc2lvbicpO1xuICBcbiAgY29uc3QgZXhlY2RhdGEgPSBfZ2V0RXhlY0RhdGEoc2lndmVyc2lvbiwgbGVhZkhhc2gpO1xuICBjb25zdCBoYXNoYnVmID0gX3NpZ25hdHVyZUhhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dEluZGV4LCBzaWd2ZXJzaW9uLCBleGVjZGF0YSk7XG4gIGlmICghaGFzaGJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzaWcgPSBTY2hub3JyLnNpZ24ocHJpdmF0ZUtleSwgaGFzaGJ1Zik7XG4gIGlmIChzaWdoYXNoVHlwZSAhPT0gU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVCkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtzaWcsIEJ1ZmZlci5mcm9tKFtzaWdoYXNoVHlwZV0pXSk7IC8vIDY1IGJ5dGVzXG4gIH1cbiAgcmV0dXJuIHNpZzsgLy8gNjQgYnl0ZXNcbn07XG5cblxuLyoqXG4gKiBWZXJpZnkgYSBTY2hub3JyIHNpZ25hdHVyZVxuICpcbiAqIEBuYW1lIFNpZ25pbmcudmVyaWZ5XG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmxpY0tleVxuICogQHBhcmFtIHtOdW1iZXJ9IGlucHV0SW5kZXhcbiAqIEBwYXJhbSB7b2JqZWN0fEJ1ZmZlcnxudWxsfSBleGVjZGF0YSBJZiBnaXZlbiwgY2FuIGJlIGZ1bGwgZXhlY2RhdGEgb2JqZWN0IG9yIGp1c3QgdGhlIGxlYWZIYXNoIGJ1ZmZlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHB1YmxpY0tleSwgc2lndmVyc2lvbiwgaW5wdXRJbmRleCwgZXhlY2RhdGEpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHRyYW5zYWN0aW9uICE9IG51bGwsICdUcmFuc2FjdGlvbiBVbmRlZmluZWQnKTtcblxuICBpZiAoIWV4ZWNkYXRhIHx8IEJ1ZmZlci5pc0J1ZmZlcihleGVjZGF0YSkpIHtcbiAgICBjb25zdCBsZWFmSGFzaCA9IGV4ZWNkYXRhO1xuICAgIGV4ZWNkYXRhID0gX2dldEV4ZWNEYXRhKHNpZ3ZlcnNpb24sIGxlYWZIYXNoKTtcbiAgfVxuXG4gICQuY2hlY2tBcmd1bWVudChleGVjZGF0YS5hbm5leEluaXQsICdpbnZhbGlkIGV4ZWNkYXRhJyk7XG5cbiAgY29uc3QgaGFzaGJ1ZiA9IF9zaWduYXR1cmVIYXNoKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUubmhhc2h0eXBlLCBpbnB1dEluZGV4LCBzaWd2ZXJzaW9uLCBleGVjZGF0YSk7XG4gIGlmICghaGFzaGJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB2ZXJpZmllZCA9IFNjaG5vcnIudmVyaWZ5KHB1YmxpY0tleSwgaGFzaGJ1Ziwgc2lnbmF0dXJlKTtcbiAgcmV0dXJuIHZlcmlmaWVkO1xufTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIFNpZ25pbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpZ246IHNpZ24sXG4gIHZlcmlmeTogdmVyaWZ5XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/sighashwitness.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* jshint maxparams:5 */\n\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar ECDSA = __webpack_require__(/*! ../crypto/ecdsa */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Buffer} scriptCode\n * @param {Buffer} satoshisBuffer\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n\n  var hashPrevouts = Buffer.alloc(32);\n  var hashSequence = Buffer.alloc(32);\n  var hashOutputs = Buffer.alloc(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.alloc(4);\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\n      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n\n    var sequenceBuffers = [];\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.alloc(4);\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n\n  var outputWriter = new BufferWriter();\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  }\n\n  // Version\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n\n  writer.write(scriptCode);\n\n  writer.write(satoshisBuffer);\n\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // Sighash type\n  writer.writeInt32LE(sighashType);\n\n  return Hash.sha256sha256(writer.toBuffer());\n\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer) {\n  let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n  return ECDSA.sign(hashbuf, privateKey).set({ nhashtype: sighashType });\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer) {\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n  return ECDSA.verify(hashbuf, signature, publicKey);\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2h3aXRuZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFxQjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxXQUFXLG1CQUFPLENBQUMsMkVBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyw2RUFBaUI7QUFDckMsUUFBUSxtQkFBTyxDQUFDLHlGQUF1QjtBQUN2QyxRQUFRLG1CQUFPLENBQUMscURBQVE7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vc2lnaGFzaHdpdG5lc3MuanM/NjkzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIGpzaGludCBtYXhwYXJhbXM6NSAqL1xuXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIEVDRFNBID0gcmVxdWlyZSgnLi4vY3J5cHRvL2VjZHNhJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIG9mIGxlbmd0aCAzMiBieXRlcyB3aXRoIHRoZSBoYXNoIHRoYXQgbmVlZHMgdG8gYmUgc2lnbmVkXG4gKiBmb3Igd2l0bmVzcyBwcm9ncmFtcyBhcyBkZWZpbmVkIGJ5OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0My5tZWRpYXdpa2lcbiAqXG4gKiBAbmFtZSBTaWduaW5nLnNpZ2hhc2hcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIHRoZSB0cmFuc2FjdGlvbiB0byBzaWduXG4gKiBAcGFyYW0ge251bWJlcn0gc2lnaGFzaFR5cGUgdGhlIHR5cGUgb2YgdGhlIGhhc2hcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dE51bWJlciB0aGUgaW5wdXQgaW5kZXggZm9yIHRoZSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBzY3JpcHRDb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2F0b3NoaXNCdWZmZXJcbiAqL1xudmFyIHNpZ2hhc2ggPSBmdW5jdGlvbiBzaWdoYXNoKHRyYW5zYWN0aW9uLCBzaWdoYXNoVHlwZSwgaW5wdXROdW1iZXIsIHNjcmlwdENvZGUsIHNhdG9zaGlzQnVmZmVyKSB7XG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiA1MCAqL1xuXG4gIHZhciBoYXNoUHJldm91dHMgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICB2YXIgaGFzaFNlcXVlbmNlID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgdmFyIGhhc2hPdXRwdXRzID0gQnVmZmVyLmFsbG9jKDMyKTtcblxuICBpZiAoIShzaWdoYXNoVHlwZSAmIFNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSkpIHtcbiAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdHJhbnNhY3Rpb24uaW5wdXRzLmxlbmd0aDsgbisrKSB7XG4gICAgICB2YXIgaW5wdXQgPSB0cmFuc2FjdGlvbi5pbnB1dHNbbl07XG4gICAgICB2YXIgcHJldlR4SWRCdWZmZXIgPSBuZXcgQnVmZmVyUmVhZGVyKGlucHV0LnByZXZUeElkKS5yZWFkUmV2ZXJzZSgpO1xuICAgICAgYnVmZmVycy5wdXNoKHByZXZUeElkQnVmZmVyKTtcbiAgICAgIHZhciBvdXRwdXRJbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgIG91dHB1dEluZGV4QnVmZmVyLndyaXRlVUludDMyTEUoaW5wdXQub3V0cHV0SW5kZXgsIDApO1xuICAgICAgYnVmZmVycy5wdXNoKG91dHB1dEluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgaGFzaFByZXZvdXRzID0gSGFzaC5zaGEyNTZzaGEyNTYoQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XG4gIH1cblxuICBpZiAoIShzaWdoYXNoVHlwZSAmIFNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSkgJiZcbiAgICAgIChzaWdoYXNoVHlwZSAmIDB4MWYpICE9PSBTaWduYXR1cmUuU0lHSEFTSF9TSU5HTEUgJiYgKHNpZ2hhc2hUeXBlICYgMHgxZikgIT09IFNpZ25hdHVyZS5TSUdIQVNIX05PTkUpIHtcblxuICAgIHZhciBzZXF1ZW5jZUJ1ZmZlcnMgPSBbXTtcbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IHRyYW5zYWN0aW9uLmlucHV0cy5sZW5ndGg7IG0rKykge1xuICAgICAgdmFyIHNlcXVlbmNlQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgc2VxdWVuY2VCdWZmZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbbV0uc2VxdWVuY2VOdW1iZXIsIDApO1xuICAgICAgc2VxdWVuY2VCdWZmZXJzLnB1c2goc2VxdWVuY2VCdWZmZXIpO1xuICAgIH1cbiAgICBoYXNoU2VxdWVuY2UgPSBIYXNoLnNoYTI1NnNoYTI1NihCdWZmZXIuY29uY2F0KHNlcXVlbmNlQnVmZmVycykpO1xuICB9XG5cbiAgdmFyIG91dHB1dFdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgaWYgKChzaWdoYXNoVHlwZSAmIDB4MWYpICE9PSBTaWduYXR1cmUuU0lHSEFTSF9TSU5HTEUgJiYgKHNpZ2hhc2hUeXBlICYgMHgxZikgIT09IFNpZ25hdHVyZS5TSUdIQVNIX05PTkUpIHtcbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHRyYW5zYWN0aW9uLm91dHB1dHMubGVuZ3RoOyBwKyspIHtcbiAgICAgIHRyYW5zYWN0aW9uLm91dHB1dHNbcF0udG9CdWZmZXJXcml0ZXIob3V0cHV0V3JpdGVyKTtcbiAgICB9XG4gICAgaGFzaE91dHB1dHMgPSBIYXNoLnNoYTI1NnNoYTI1NihvdXRwdXRXcml0ZXIudG9CdWZmZXIoKSk7XG4gIH0gZWxzZSBpZiAoKHNpZ2hhc2hUeXBlICYgMHgxZikgPT09IFNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSAmJiBpbnB1dE51bWJlciA8IHRyYW5zYWN0aW9uLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgdHJhbnNhY3Rpb24ub3V0cHV0c1tpbnB1dE51bWJlcl0udG9CdWZmZXJXcml0ZXIob3V0cHV0V3JpdGVyKTtcbiAgICBoYXNoT3V0cHV0cyA9IEhhc2guc2hhMjU2c2hhMjU2KG91dHB1dFdyaXRlci50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8vIFZlcnNpb25cbiAgdmFyIHdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgd3JpdGVyLndyaXRlVUludDMyTEUodHJhbnNhY3Rpb24udmVyc2lvbik7XG5cbiAgLy8gSW5wdXQgcHJldm91dHMvblNlcXVlbmNlIChub25lL2FsbCwgZGVwZW5kaW5nIG9uIGZsYWdzKVxuICB3cml0ZXIud3JpdGUoaGFzaFByZXZvdXRzKTtcbiAgd3JpdGVyLndyaXRlKGhhc2hTZXF1ZW5jZSk7XG5cbiAgLy8gVGhlIGlucHV0IGJlaW5nIHNpZ25lZCAocmVwbGFjaW5nIHRoZSBzY3JpcHRTaWcgd2l0aCBzY3JpcHRDb2RlICsgYW1vdW50KVxuICAvLyBUaGUgcHJldm91dCBtYXkgYWxyZWFkeSBiZSBjb250YWluZWQgaW4gaGFzaFByZXZvdXQsIGFuZCB0aGUgblNlcXVlbmNlXG4gIC8vIG1heSBhbHJlYWR5IGJlIGNvbnRhaW4gaW4gaGFzaFNlcXVlbmNlLlxuICB2YXIgb3V0cG9pbnRJZCA9IG5ldyBCdWZmZXJSZWFkZXIodHJhbnNhY3Rpb24uaW5wdXRzW2lucHV0TnVtYmVyXS5wcmV2VHhJZCkucmVhZFJldmVyc2UoKTtcbiAgd3JpdGVyLndyaXRlKG91dHBvaW50SWQpO1xuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLm91dHB1dEluZGV4KTtcblxuICB3cml0ZXIud3JpdGUoc2NyaXB0Q29kZSk7XG5cbiAgd3JpdGVyLndyaXRlKHNhdG9zaGlzQnVmZmVyKTtcblxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLnNlcXVlbmNlTnVtYmVyKTtcblxuICAvLyBPdXRwdXRzIChub25lL29uZS9hbGwsIGRlcGVuZGluZyBvbiBmbGFncylcbiAgd3JpdGVyLndyaXRlKGhhc2hPdXRwdXRzKTtcblxuICAvLyBMb2NrdGltZVxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5uTG9ja1RpbWUpO1xuXG4gIC8vIFNpZ2hhc2ggdHlwZVxuICB3cml0ZXIud3JpdGVJbnQzMkxFKHNpZ2hhc2hUeXBlKTtcblxuICByZXR1cm4gSGFzaC5zaGEyNTZzaGEyNTYod3JpdGVyLnRvQnVmZmVyKCkpO1xuXG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHNpZ25hdHVyZVxuICpcbiAqIEBuYW1lIFNpZ25pbmcuc2lnblxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ2hhc2hcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dEluZGV4XG4gKiBAcGFyYW0ge1NjcmlwdH0gc3Vic2NyaXB0XG4gKiBAcmV0dXJuIHtTaWduYXR1cmV9XG4gKi9cbmZ1bmN0aW9uIHNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ2hhc2hUeXBlLCBpbnB1dEluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcikge1xuICBsZXQgaGFzaGJ1ZiA9IHNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dEluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XG4gIHJldHVybiBFQ0RTQS5zaWduKGhhc2hidWYsIHByaXZhdGVLZXkpLnNldCh7IG5oYXNodHlwZTogc2lnaGFzaFR5cGUgfSk7XG59XG5cbi8qKlxuICogVmVyaWZ5IGEgc2lnbmF0dXJlXG4gKlxuICogQG5hbWUgU2lnbmluZy52ZXJpZnlcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVibGljS2V5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5wdXRJbmRleFxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHB1YmxpY0tleSwgaW5wdXRJbmRleCwgc2NyaXB0Q29kZSwgc2F0b3NoaXNCdWZmZXIpIHtcbiAgJC5jaGVja0FyZ3VtZW50KCFfLmlzVW5kZWZpbmVkKHRyYW5zYWN0aW9uKSwgXCJUcmFuc2FjdGlvbiBVbmRlZmluZWRcIik7XG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZChzaWduYXR1cmUpICYmICFfLmlzVW5kZWZpbmVkKHNpZ25hdHVyZS5uaGFzaHR5cGUpLCBcIlNpZ25hdHVyZSBVbmRlZmluZWRcIik7XG5cbiAgbGV0IGhhc2hidWYgPSBzaWdoYXNoKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUubmhhc2h0eXBlLCBpbnB1dEluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XG4gIHJldHVybiBFQ0RTQS52ZXJpZnkoaGFzaGJ1Ziwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgU2lnbmluZ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2lnaGFzaDogc2lnaGFzaCxcbiAgc2lnbjogc2lnbixcbiAgdmVyaWZ5OiB2ZXJpZnlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js":
/*!***************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/signature.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nvar PublicKey = __webpack_require__(/*! ../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\n\n/**\n * @desc\n * Wrapper around Signature with fields related to signing a transaction specifically\n *\n * @param {Object|string|TransactionSignature} arg\n * @constructor\n */\nfunction TransactionSignature(arg) {\n  if (!(this instanceof TransactionSignature)) {\n    return new TransactionSignature(arg);\n  }\n  if (arg instanceof TransactionSignature) {\n    return arg;\n  }\n  if (arg && typeof arg === 'object') {\n    return this._fromObject(arg);\n  }\n  throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object');\n}\ninherits(TransactionSignature, Signature);\n\nTransactionSignature.prototype._fromObject = function(arg) {\n  this._checkObjectArgs(arg);\n  this.publicKey = new PublicKey(arg.publicKey);\n  this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, 'hex');\n  this.outputIndex = arg.outputIndex;\n  this.inputIndex = arg.inputIndex;\n  this.signature = (arg.signature instanceof Signature) ? arg.signature :\n                     BufferUtil.isBuffer(arg.signature) ? Signature.fromBuffer(arg.signature) :\n                     Signature.fromString(arg.signature);\n  this.sigtype = arg.sigtype;\n  return this;\n};\n\nTransactionSignature.prototype._checkObjectArgs = function(arg) {\n  $.checkArgument(PublicKey(arg.publicKey), 'invalid publicKey');\n  $.checkArgument(arg.inputIndex != null, 'missing inputIndex');\n  $.checkArgument(arg.outputIndex != null, 'missing outputIndex');\n  $.checkState(!isNaN(arg.inputIndex), 'inputIndex must be a number');\n  $.checkState(!isNaN(arg.outputIndex), 'outputIndex must be a number');\n  $.checkArgument(arg.signature, 'missing signature');\n  $.checkArgument(arg.prevTxId, 'missing prevTxId');\n  $.checkState(arg.signature instanceof Signature ||\n               BufferUtil.isBuffer(arg.signature) ||\n               JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value');\n  $.checkState(BufferUtil.isBuffer(arg.prevTxId) ||\n               JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value');\n  $.checkArgument(arg.sigtype != null, 'missing sigtype');\n  $.checkState(!isNaN(arg.sigtype), 'sigtype must be a number');\n};\n\n/**\n * Serializes a transaction to a plain JS object\n * @return {Object}\n */\nTransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject() {\n  return {\n    publicKey: this.publicKey.toString(),\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    inputIndex: this.inputIndex,\n    signature: this.signature.toString(),\n    sigtype: this.sigtype\n  };\n};\n\n/**\n * Builds a TransactionSignature from an object\n * @param {Object} object\n * @return {TransactionSignature}\n */\nTransactionSignature.fromObject = function(object) {\n  $.checkArgument(object);\n  return new TransactionSignature(object);\n};\n\nmodule.exports = TransactionSignature;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxvRkFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLG1FQUFZOztBQUVqQyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBYztBQUN0QyxhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQXFCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vc2lnbmF0dXJlLmpzPzYzYmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XG5cbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuLi9wdWJsaWNrZXknKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi9jcnlwdG8vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogQGRlc2NcbiAqIFdyYXBwZXIgYXJvdW5kIFNpZ25hdHVyZSB3aXRoIGZpZWxkcyByZWxhdGVkIHRvIHNpZ25pbmcgYSB0cmFuc2FjdGlvbiBzcGVjaWZpY2FsbHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd8VHJhbnNhY3Rpb25TaWduYXR1cmV9IGFyZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRyYW5zYWN0aW9uU2lnbmF0dXJlKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNhY3Rpb25TaWduYXR1cmUpKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblNpZ25hdHVyZShhcmcpO1xuICB9XG4gIGlmIChhcmcgaW5zdGFuY2VvZiBUcmFuc2FjdGlvblNpZ25hdHVyZSkge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbiAgaWYgKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0aGlzLl9mcm9tT2JqZWN0KGFyZyk7XG4gIH1cbiAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnQoJ1RyYW5zYWN0aW9uU2lnbmF0dXJlcyBtdXN0IGJlIGluc3RhbnRpYXRlZCBmcm9tIGFuIG9iamVjdCcpO1xufVxuaW5oZXJpdHMoVHJhbnNhY3Rpb25TaWduYXR1cmUsIFNpZ25hdHVyZSk7XG5cblRyYW5zYWN0aW9uU2lnbmF0dXJlLnByb3RvdHlwZS5fZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGFyZykge1xuICB0aGlzLl9jaGVja09iamVjdEFyZ3MoYXJnKTtcbiAgdGhpcy5wdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGFyZy5wdWJsaWNLZXkpO1xuICB0aGlzLnByZXZUeElkID0gQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcucHJldlR4SWQpID8gYXJnLnByZXZUeElkIDogQnVmZmVyLmZyb20oYXJnLnByZXZUeElkLCAnaGV4Jyk7XG4gIHRoaXMub3V0cHV0SW5kZXggPSBhcmcub3V0cHV0SW5kZXg7XG4gIHRoaXMuaW5wdXRJbmRleCA9IGFyZy5pbnB1dEluZGV4O1xuICB0aGlzLnNpZ25hdHVyZSA9IChhcmcuc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSA/IGFyZy5zaWduYXR1cmUgOlxuICAgICAgICAgICAgICAgICAgICAgQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcuc2lnbmF0dXJlKSA/IFNpZ25hdHVyZS5mcm9tQnVmZmVyKGFyZy5zaWduYXR1cmUpIDpcbiAgICAgICAgICAgICAgICAgICAgIFNpZ25hdHVyZS5mcm9tU3RyaW5nKGFyZy5zaWduYXR1cmUpO1xuICB0aGlzLnNpZ3R5cGUgPSBhcmcuc2lndHlwZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2FjdGlvblNpZ25hdHVyZS5wcm90b3R5cGUuX2NoZWNrT2JqZWN0QXJncyA9IGZ1bmN0aW9uKGFyZykge1xuICAkLmNoZWNrQXJndW1lbnQoUHVibGljS2V5KGFyZy5wdWJsaWNLZXkpLCAnaW52YWxpZCBwdWJsaWNLZXknKTtcbiAgJC5jaGVja0FyZ3VtZW50KGFyZy5pbnB1dEluZGV4ICE9IG51bGwsICdtaXNzaW5nIGlucHV0SW5kZXgnKTtcbiAgJC5jaGVja0FyZ3VtZW50KGFyZy5vdXRwdXRJbmRleCAhPSBudWxsLCAnbWlzc2luZyBvdXRwdXRJbmRleCcpO1xuICAkLmNoZWNrU3RhdGUoIWlzTmFOKGFyZy5pbnB1dEluZGV4KSwgJ2lucHV0SW5kZXggbXVzdCBiZSBhIG51bWJlcicpO1xuICAkLmNoZWNrU3RhdGUoIWlzTmFOKGFyZy5vdXRwdXRJbmRleCksICdvdXRwdXRJbmRleCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICQuY2hlY2tBcmd1bWVudChhcmcuc2lnbmF0dXJlLCAnbWlzc2luZyBzaWduYXR1cmUnKTtcbiAgJC5jaGVja0FyZ3VtZW50KGFyZy5wcmV2VHhJZCwgJ21pc3NpbmcgcHJldlR4SWQnKTtcbiAgJC5jaGVja1N0YXRlKGFyZy5zaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUgfHxcbiAgICAgICAgICAgICAgIEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnLnNpZ25hdHVyZSkgfHxcbiAgICAgICAgICAgICAgIEpTVXRpbC5pc0hleGEoYXJnLnNpZ25hdHVyZSksICdzaWduYXR1cmUgbXVzdCBiZSBhIGJ1ZmZlciBvciBoZXhhIHZhbHVlJyk7XG4gICQuY2hlY2tTdGF0ZShCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZy5wcmV2VHhJZCkgfHxcbiAgICAgICAgICAgICAgIEpTVXRpbC5pc0hleGEoYXJnLnByZXZUeElkKSwgJ3ByZXZUeElkIG11c3QgYmUgYSBidWZmZXIgb3IgaGV4YSB2YWx1ZScpO1xuICAkLmNoZWNrQXJndW1lbnQoYXJnLnNpZ3R5cGUgIT0gbnVsbCwgJ21pc3Npbmcgc2lndHlwZScpO1xuICAkLmNoZWNrU3RhdGUoIWlzTmFOKGFyZy5zaWd0eXBlKSwgJ3NpZ3R5cGUgbXVzdCBiZSBhIG51bWJlcicpO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemVzIGEgdHJhbnNhY3Rpb24gdG8gYSBwbGFpbiBKUyBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVHJhbnNhY3Rpb25TaWduYXR1cmUucHJvdG90eXBlLnRvT2JqZWN0ID0gVHJhbnNhY3Rpb25TaWduYXR1cmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkudG9TdHJpbmcoKSxcbiAgICBwcmV2VHhJZDogdGhpcy5wcmV2VHhJZC50b1N0cmluZygnaGV4JyksXG4gICAgb3V0cHV0SW5kZXg6IHRoaXMub3V0cHV0SW5kZXgsXG4gICAgaW5wdXRJbmRleDogdGhpcy5pbnB1dEluZGV4LFxuICAgIHNpZ25hdHVyZTogdGhpcy5zaWduYXR1cmUudG9TdHJpbmcoKSxcbiAgICBzaWd0eXBlOiB0aGlzLnNpZ3R5cGVcbiAgfTtcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgVHJhbnNhY3Rpb25TaWduYXR1cmUgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9uU2lnbmF0dXJlfVxuICovXG5UcmFuc2FjdGlvblNpZ25hdHVyZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICQuY2hlY2tBcmd1bWVudChvYmplY3QpO1xuICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKG9iamVjdCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uU2lnbmF0dXJlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/transaction.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar compare = Buffer.compare || __webpack_require__(/*! buffer-compare */ \"(ssr)/./node_modules/buffer-compare/index.js\");\n\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Sighash = __webpack_require__(/*! ./sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar SighashWitness = __webpack_require__(/*! ./sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\nconst SighashSchnorr = __webpack_require__(/*! ./sighashschnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js\");\n\nvar Address = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar UnspentOutput = __webpack_require__(/*! ./unspentoutput */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/unspentoutput.js\");\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js\");\nvar PublicKeyHashInput = Input.PublicKeyHash;\nvar PublicKeyInput = Input.PublicKey;\nvar MultiSigScriptHashInput = Input.MultiSigScriptHash;\nvar MultiSigInput = Input.MultiSig;\nconst TaprootInput = Input.Taproot;\nvar Output = __webpack_require__(/*! ./output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar PrivateKey = __webpack_require__(/*! ../privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\n\n/**\n * Represents a transaction, a set of inputs and outputs to change ownership of tokens\n *\n * @param {*} serialized\n * @constructor\n */\nfunction Transaction(serialized, opts) {\n  if (!(this instanceof Transaction)) {\n    return new Transaction(serialized);\n  }\n  this.inputs = [];\n  this.outputs = [];\n  this._inputAmount = undefined;\n  this._outputAmount = undefined;\n\n  if (serialized) {\n    if (serialized instanceof Transaction) {\n      return Transaction.shallowCopy(serialized);\n    } else if (JSUtil.isHexa(serialized)) {\n      this.fromString(serialized);\n    } else if (BufferUtil.isBuffer(serialized)) {\n      this.fromBuffer(serialized);\n    } else if (_.isObject(serialized)) {\n      this.fromObject(serialized, opts);\n    } else {\n      throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction');\n    }\n  } else {\n    this._newTransaction();\n  }\n}\nvar CURRENT_VERSION = 2;\nvar DEFAULT_NLOCKTIME = 0;\nvar MAX_BLOCK_SIZE = 1000000;\n\n// Minimum amount for an output for it not to be considered a dust output\nTransaction.DUST_AMOUNT = 546;\n\n// Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big difference\nTransaction.FEE_SECURITY_MARGIN = 150;\n\n// max amount of satoshis in circulation\nTransaction.MAX_MONEY = 21000000 * 1e8;\n\n// nlocktime limit to be considered block height rather than a timestamp\nTransaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;\n\n// Max value for an unsigned 32 bit value\nTransaction.NLOCKTIME_MAX_VALUE = 4294967295;\n\n// Value used for fee estimation (satoshis per kilobyte)\nTransaction.FEE_PER_KB = 100000;\n\n// Safe upper bound for change address script size in bytes\nTransaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;\nTransaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;\n\n/* Constructors and Serialization */\n\n/**\n * Create a 'shallow' copy of the transaction, by serializing and deserializing\n * it dropping any additional information that inputs and outputs may have hold\n *\n * @param {Transaction} transaction\n * @return {Transaction}\n */\nTransaction.shallowCopy = function(transaction) {\n  var copy = new Transaction(transaction.toBuffer());\n  return copy;\n};\n\nvar hashProperty = {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    this._hash = new BufferReader(this._getHash()).readReverse().toString('hex');\n    return this._hash;\n  }\n};\n\nvar witnessHashProperty = {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    return new BufferReader(this._getWitnessHash()).readReverse().toString('hex');\n  }\n};\n\nObject.defineProperty(Transaction.prototype, 'witnessHash', witnessHashProperty);\nObject.defineProperty(Transaction.prototype, 'hash', hashProperty);\nObject.defineProperty(Transaction.prototype, 'id', hashProperty);\n\nvar ioProperty = {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    return this._getInputAmount();\n  }\n};\nObject.defineProperty(Transaction.prototype, 'inputAmount', ioProperty);\nioProperty.get = function() {\n  return this._getOutputAmount();\n};\nObject.defineProperty(Transaction.prototype, 'outputAmount', ioProperty);\n\nObject.defineProperty(Transaction.prototype, 'size', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    return this._calculateSize();\n  }\n});\n\nObject.defineProperty(Transaction.prototype, 'vsize', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    return this._calculateVSize();\n  }\n});\n\nObject.defineProperty(Transaction.prototype, 'weight', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    return this._calculateWeight();\n  }\n});\n\n/**\n * Retrieve the little endian hash of the transaction (used for serialization)\n * @return {Buffer}\n */\nTransaction.prototype._getHash = function() {\n  return Hash.sha256sha256(this.toBuffer(true));\n};\n\n/**\n * Retrieve the little endian hash of the transaction including witness data\n * @return {Buffer}\n */\nTransaction.prototype._getWitnessHash = function() {\n  return Hash.sha256sha256(this.toBuffer(false));\n};\n\n/**\n * Retrieve a hexa string that can be used with bitcoind's CLI interface\n * (decoderawtransaction, sendrawtransaction)\n *\n * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object,\n *   it's expected to contain a set of flags to skip certain tests:\n * * `disableAll`: disable all checks\n * * `disableSmallFees`: disable checking for fees that are too small\n * * `disableLargeFees`: disable checking for fees that are too large\n * * `disableIsFullySigned`: disable checking if all inputs are fully signed\n * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts\n * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than the sum of the input amounts\n * @return {string}\n */\nTransaction.prototype.serialize = function(unsafe) {\n  if (true === unsafe || unsafe && unsafe.disableAll) {\n    return this.uncheckedSerialize();\n  } else {\n    return this.checkedSerialize(unsafe);\n  }\n};\n\nTransaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Retrieve a hexa string that can be used with bitcoind's CLI interface\n * (decoderawtransaction, sendrawtransaction)\n *\n * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n * @return {string}\n */\nTransaction.prototype.checkedSerialize = function(opts) {\n  var serializationError = this.getSerializationError(opts);\n  if (serializationError) {\n    serializationError.message += ' - For more information please see: ' +\n      'https://github.com/bitpay/bitcore/blob/master/packages/bitcore-lib/docs/transaction.md#serialization-checks';\n    throw serializationError;\n  }\n  return this.uncheckedSerialize();\n};\n\nTransaction.prototype.invalidSatoshis = function() {\n  var invalid = false;\n  for (var i = 0; i < this.outputs.length; i++) {\n    if (this.outputs[i].invalidSatoshis()) {\n      invalid = true;\n    }\n  }\n  return invalid;\n};\n\n/**\n * Retrieve a possible error that could appear when trying to serialize and\n * broadcast this transaction.\n *\n * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n * @return {bitcore.Error}\n */\nTransaction.prototype.getSerializationError = function(opts) {\n  opts = opts || {};\n\n  if (this.invalidSatoshis()) {\n    return new errors.Transaction.InvalidSatoshis();\n  }\n\n  var unspent = this._getUnspentValue();\n  var unspentError;\n  if (unspent < 0) {\n    if (!opts.disableMoreOutputThanInput) {\n      unspentError = new errors.Transaction.InvalidOutputAmountSum();\n    }\n  } else {\n    unspentError = this._hasFeeError(opts, unspent);\n  }\n\n  return unspentError ||\n    this._hasDustOutputs(opts) ||\n    this._isMissingSignatures(opts);\n};\n\nTransaction.prototype._hasFeeError = function(opts, unspent) {\n\n  if (this._fee != null && this._fee !== unspent) {\n    return new errors.Transaction.FeeError.Different(\n      'Unspent value is ' + unspent + ' but specified fee is ' + this._fee\n    );\n  }\n\n  if (!opts.disableLargeFees) {\n    var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());\n    if (unspent > maximumFee) {\n      if (this._missingChange()) {\n        return new errors.Transaction.ChangeAddressMissing(\n          'Fee is too large and no change address was provided'\n        );\n      }\n      return new errors.Transaction.FeeError.TooLarge(\n        'expected less than ' + maximumFee + ' but got ' + unspent\n      );\n    }\n  }\n\n  if (!opts.disableSmallFees) {\n    var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);\n    if (unspent < minimumFee) {\n      return new errors.Transaction.FeeError.TooSmall(\n        'expected more than ' + minimumFee + ' but got ' + unspent\n      );\n    }\n  }\n};\n\nTransaction.prototype._missingChange = function() {\n  return !this._changeScript;\n};\n\nTransaction.prototype._hasDustOutputs = function(opts) {\n  if (opts.disableDustOutputs) {\n    return;\n  }\n  var index, output;\n  for (index in this.outputs) {\n    output = this.outputs[index];\n    if (output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut()) {\n      return new errors.Transaction.DustOutputs();\n    }\n  }\n};\n\nTransaction.prototype._isMissingSignatures = function(opts) {\n  if (opts.disableIsFullySigned) {\n    return;\n  }\n  if (!this.isFullySigned()) {\n    return new errors.Transaction.MissingSignatures();\n  }\n};\n\nTransaction.prototype.inspect = function() {\n  return '<Transaction: ' + this.uncheckedSerialize() + '>';\n};\n\nTransaction.prototype.toBuffer = function(noWitness) {\n  var writer = new BufferWriter();\n  return this.toBufferWriter(writer, noWitness).toBuffer();\n};\n\nTransaction.prototype.hasWitnesses = function() {\n  for (var i = 0; i < this.inputs.length; i++) {\n    if (this.inputs[i].hasWitnesses()) {\n      return true;\n    }\n  }\n  return false;\n};\n\nTransaction.prototype.toBufferWriter = function(writer, noWitness) {\n  writer.writeInt32LE(this.version);\n\n  const hasWitnesses = this.hasWitnesses();\n\n  if (hasWitnesses && !noWitness) {\n    writer.write(Buffer.from('0001', 'hex'));\n  }\n\n  writer.writeVarintNum(this.inputs ? this.inputs.length : 0);\n  for (const input of this.inputs || []) {\n    input.toBufferWriter(writer);\n  }\n\n  writer.writeVarintNum(this.outputs ? this.outputs.length : 0);\n  for (const output of this.outputs || []) {\n    output.toBufferWriter(writer);\n  }\n\n  if (hasWitnesses && !noWitness) {\n    for (const input of this.inputs) {\n      const witnesses = input.getWitnesses();\n      writer.writeVarintNum(witnesses.length);\n      for (let j = 0; j < witnesses.length; j++) {\n        writer.writeVarintNum(witnesses[j].length);\n        writer.write(witnesses[j]);\n      }\n    }\n  }\n\n  writer.writeUInt32LE(this.nLockTime);\n  return writer;\n};\n\nTransaction.prototype.fromBuffer = function(buffer) {\n  var reader = new BufferReader(buffer);\n  return this.fromBufferReader(reader);\n};\n\nTransaction.prototype.fromBufferReader = function(reader) {\n  $.checkArgument(!reader.finished(), 'No transaction data received');\n\n  this.version = reader.readInt32LE();\n  var sizeTxIns = reader.readVarintNum();\n\n  // check for segwit\n  var hasWitnesses = false;\n  if (sizeTxIns === 0 && reader.buf[reader.pos] !== 0) {\n    reader.pos += 1;\n    hasWitnesses = true;\n    sizeTxIns = reader.readVarintNum();\n  }\n\n  for (var i = 0; i < sizeTxIns; i++) {\n    var input = Input.fromBufferReader(reader);\n    this.inputs.push(input);\n  }\n\n  var sizeTxOuts = reader.readVarintNum();\n  for (var j = 0; j < sizeTxOuts; j++) {\n    this.outputs.push(Output.fromBufferReader(reader));\n  }\n\n  if (hasWitnesses) {\n    for (var k = 0; k < sizeTxIns; k++) {\n      var itemCount = reader.readVarintNum();\n      var witnesses = [];\n      for (var l = 0; l < itemCount; l++) {\n        var size = reader.readVarintNum();\n        var item = reader.read(size);\n        witnesses.push(item);\n      }\n      this.inputs[k].setWitnesses(witnesses);\n    }\n  }\n\n  this.nLockTime = reader.readUInt32LE();\n  return this;\n};\n\n\nTransaction.prototype.toObject = Transaction.prototype.toJSON = function toObject() {\n  var inputs = [];\n  this.inputs.forEach(function(input) {\n    inputs.push(input.toObject());\n  });\n  var outputs = [];\n  this.outputs.forEach(function(output) {\n    outputs.push(output.toObject());\n  });\n  var obj = {\n    hash: this.hash,\n    version: this.version,\n    inputs: inputs,\n    outputs: outputs,\n    nLockTime: this.nLockTime\n  };\n  if (this._changeScript) {\n    obj.changeScript = this._changeScript.toString();\n  }\n  if (this._changeIndex != null) {\n    obj.changeIndex = this._changeIndex;\n  }\n  if (this._fee != null) {\n    obj.fee = this._fee;\n  }\n  return obj;\n};\n\nTransaction.prototype.fromObject = function fromObject(arg, opts) {\n  /* jshint maxstatements: 20 */\n  $.checkArgument(_.isObject(arg) || arg instanceof Transaction);\n  var transaction;\n  if (arg instanceof Transaction) {\n    transaction = arg.toObject();\n  } else {\n    transaction = arg;\n  }\n  for (const input of transaction.inputs || []) {\n    if (!input.output || !input.output.script) {\n      this.uncheckedAddInput(new Input(input));\n      continue;\n    }\n    var script = new Script(input.output.script);\n    var txin;\n    if ((script.isScriptHashOut() || script.isWitnessScriptHashOut()) && input.publicKeys && input.threshold) {\n      txin = new Input.MultiSigScriptHash(\n        input, input.publicKeys, input.threshold, input.signatures, opts\n      );\n    } else if (script.isPublicKeyHashOut() || script.isWitnessPublicKeyHashOut() || script.isScriptHashOut()) {\n      txin = new Input.PublicKeyHash(input);\n    } else if (script.isPublicKeyOut()) {\n      txin = new Input.PublicKey(input);\n    } else {\n      throw new errors.Transaction.Input.UnsupportedScript(input.output.script);\n    }\n    this.addInput(txin);\n  }\n  for (const output of transaction.outputs || []) {\n    this.addOutput(new Output(output));\n  }\n  if (transaction.changeIndex) {\n    this._changeIndex = transaction.changeIndex;\n  }\n  if (transaction.changeScript) {\n    this._changeScript = new Script(transaction.changeScript);\n  }\n  if (transaction.fee) {\n    this._fee = transaction.fee;\n  }\n  this.nLockTime = transaction.nLockTime;\n  this.version = transaction.version;\n  this._checkConsistency(arg);\n  return this;\n};\n\nTransaction.prototype._checkConsistency = function(arg) {\n  if (this._changeIndex != null) {\n    $.checkState(this._changeScript, 'Change script is expected.');\n    $.checkState(this.outputs[this._changeIndex], 'Change index points to undefined output.');\n    $.checkState(this.outputs[this._changeIndex].script.toString() ===\n      this._changeScript.toString(), 'Change output has an unexpected script.');\n  }\n  if (arg && arg.hash) {\n    $.checkState(arg.hash === this.hash, 'Hash in object does not match transaction hash.');\n  }\n};\n\n/**\n * Sets nLockTime so that transaction is not valid until the desired date(a\n * timestamp in seconds since UNIX epoch is also accepted)\n *\n * @param {Date | Number} time\n * @return {Transaction} this\n */\nTransaction.prototype.lockUntilDate = function(time) {\n  $.checkArgument(time);\n  if (!isNaN(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n    throw new errors.Transaction.LockTimeTooEarly();\n  }\n  if (_.isDate(time)) {\n    time = time.getTime() / 1000;\n  }\n\n  for (var i = 0; i < this.inputs.length; i++) {\n    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){\n      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n    }\n  }\n\n  this.nLockTime = time;\n  return this;\n};\n\n/**\n * Sets nLockTime so that transaction is not valid until the desired block\n * height.\n *\n * @param {Number} height\n * @return {Transaction} this\n */\nTransaction.prototype.lockUntilBlockHeight = function(height) {\n  $.checkArgument(!isNaN(height));\n  if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n    throw new errors.Transaction.BlockHeightTooHigh();\n  }\n  if (height < 0) {\n    throw new errors.Transaction.NLockTimeOutOfRange();\n  }\n\n  for (var i = 0; i < this.inputs.length; i++) {\n    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){\n      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n    }\n  }\n\n\n  this.nLockTime = height;\n  return this;\n};\n\n/**\n *  Returns a semantic version of the transaction's nLockTime.\n *  @return {Number|Date}\n *  If nLockTime is 0, it returns null,\n *  if it is < 500000000, it returns a block height (number)\n *  else it returns a Date object.\n */\nTransaction.prototype.getLockTime = function() {\n  if (!this.nLockTime) {\n    return null;\n  }\n  if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n    return this.nLockTime;\n  }\n  return new Date(1000 * this.nLockTime);\n};\n\nTransaction.prototype.fromString = function(string) {\n  this.fromBuffer(buffer.Buffer.from(string, 'hex'));\n};\n\nTransaction.prototype._newTransaction = function() {\n  this.version = CURRENT_VERSION;\n  this.nLockTime = DEFAULT_NLOCKTIME;\n};\n\n/* Transaction creation interface */\n\n/**\n * @typedef {Object} Transaction~fromObject\n * @property {string} prevTxId\n * @property {number} outputIndex\n * @property {(Buffer|string|Script)} script\n * @property {number} satoshis\n */\n\n/**\n * Add an input to this transaction. This is a high level interface\n * to add an input, for more control, use @{link Transaction#addInput}.\n *\n * Can receive, as output information, the output of bitcoind's `listunspent` command,\n * and a slightly fancier format recognized by bitcore:\n *\n * ```\n * {\n *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',\n *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',\n *  outputIndex: 0,\n *  script: Script.empty(),\n *  satoshis: 1020000\n * }\n * ```\n * Where `address` can be either a string or a bitcore Address object. The\n * same is true for `script`, which can be a string or a bitcore Script.\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @example\n * ```javascript\n * var transaction = new Transaction();\n *\n * // From a pay to public key hash output from bitcoind's listunspent\n * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});\n *\n * // From a pay to public key hash output\n * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});\n *\n * // From a multisig P2SH output\n * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},\n *                  ['03000...', '02000...'], 2);\n * ```\n *\n * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} utxo\n * @param {Array=} pubkeys\n * @param {number=} threshold\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true and is multisig, don't\n *                      sort the given public keys before creating the script\n */\nTransaction.prototype.from = function(utxo, pubkeys, threshold, opts) {\n  if (Array.isArray(utxo)) {\n    for(const u of utxo) {\n      this.from(u, pubkeys, threshold, opts);\n    };\n    return this;\n  }\n  const exists = this.inputs.some(function(input) {\n    // TODO: Maybe prevTxId should be a string? Or defined as read only property?\n    return input.prevTxId.toString('hex') === utxo.txId && input.outputIndex === utxo.outputIndex;\n  });\n  if (exists) {\n    return this;\n  }\n  if (pubkeys && threshold) {\n    this._fromMultisigUtxo(utxo, pubkeys, threshold, opts);\n  } else {\n    this._fromNonP2SH(utxo, opts);\n  }\n  return this;\n};\n\n/**\n * associateInputs - Update inputs with utxos, allowing you to specify value, and pubkey.\n * Populating these inputs allows for them to be signed with .sign(privKeys)\n *\n * @param {Array<Object>} utxos\n * @param {Array<string | PublicKey>} pubkeys\n * @param {number} threshold\n * @param {Object} opts\n * @returns {Array<number>}\n */\nTransaction.prototype.associateInputs = function(utxos, pubkeys, threshold, opts = {}) {\n  let indexes = [];\n  for(let utxo of utxos) {\n    const index = this.inputs.findIndex(i => i.prevTxId.toString('hex') === utxo.txId && i.outputIndex === utxo.outputIndex);\n    indexes.push(index);\n    if(index >= 0) {\n      const sequenceNumber = this.inputs[index].sequenceNumber; // preserve the set sequence number\n      this.inputs[index] = this._getInputFrom(utxo, pubkeys, threshold, opts);\n      this.inputs[index].sequenceNumber = sequenceNumber;\n    }\n  }\n  return indexes;\n}\n\n\nTransaction.prototype._selectInputType = function(utxo, pubkeys, threshold) {\n  var clazz;\n  utxo = new UnspentOutput(utxo);\n  if(pubkeys && threshold) {\n    if (utxo.script.isMultisigOut()) {\n      clazz = MultiSigInput;\n    } else if (utxo.script.isScriptHashOut() || utxo.script.isWitnessScriptHashOut()) {\n      clazz = MultiSigScriptHashInput;\n    }\n  } else if (utxo.script.isPublicKeyHashOut() || utxo.script.isWitnessPublicKeyHashOut() || utxo.script.isScriptHashOut()) {\n    clazz = PublicKeyHashInput;\n  } else if (utxo.script.isTaproot()) {\n    clazz = TaprootInput;\n  } else if (utxo.script.isPublicKeyOut()) {\n    clazz = PublicKeyInput;\n  } else {\n    clazz = Input;\n  }\n  return clazz;\n}\n\n\nTransaction.prototype._getInputFrom = function(utxo, pubkeys, threshold, opts = {}) {\n  utxo = new UnspentOutput(utxo);\n  const InputClass = this._selectInputType(utxo, pubkeys, threshold);\n  const input = {\n    output: new Output({\n      script: utxo.script,\n      satoshis: utxo.satoshis\n    }),\n    prevTxId: utxo.txId,\n    outputIndex: utxo.outputIndex,\n    sequenceNumber: opts.sequenceNumber,\n    script: Script.empty()\n  };\n  let args = pubkeys && threshold ? [pubkeys, threshold, false, opts] : []\n  return new InputClass(input, ...args);\n}\n\nTransaction.prototype._fromNonP2SH = function(utxo, opts) {\n  const input = this._getInputFrom(utxo, null, null, opts);\n  this.addInput(input);\n};\n\nTransaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, opts) {\n  $.checkArgument(threshold <= pubkeys.length,\n    'Number of required signatures must be greater than the number of public keys');\n  const input = this._getInputFrom(utxo, pubkeys, threshold, opts);\n  this.addInput(input);\n};\n\n/**\n * Add an input to this transaction. The input must be an instance of the `Input` class.\n * It should have information about the Output that it's spending, but if it's not already\n * set, two additional parameters, `outputScript` and `satoshis` can be provided.\n *\n * @param {Input} input\n * @param {String|Script} outputScript\n * @param {number} satoshis\n * @return Transaction this, for chaining\n */\nTransaction.prototype.addInput = function(input, outputScript, satoshis) {\n  $.checkArgumentType(input, Input, 'input');\n  if (!input.output && (outputScript == null || satoshis == null)) {\n    throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis');\n  }\n  if (!input.output && outputScript && satoshis != null) {\n    outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);\n    $.checkArgumentType(satoshis, 'number', 'satoshis');\n    input.output = new Output({\n      script: outputScript,\n      satoshis: satoshis\n    });\n  }\n  return this.uncheckedAddInput(input);\n};\n\n/**\n * Add an input to this transaction, without checking that the input has information about\n * the output that it's spending.\n *\n * @param {Input} input\n * @return Transaction this, for chaining\n */\nTransaction.prototype.uncheckedAddInput = function(input) {\n  $.checkArgumentType(input, Input, 'input');\n  this.inputs.push(input);\n  this._inputAmount = undefined;\n  this._updateChangeOutput();\n  return this;\n};\n\n/**\n * Returns true if the transaction has enough info on all inputs to be correctly validated\n *\n * @return {boolean}\n */\nTransaction.prototype.hasAllUtxoInfo = function() {\n  return this.inputs.every(function(input) {\n    return !!input.output;\n  });\n};\n\n/**\n * Manually set the fee for this transaction. Beware that this resets all the signatures\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n * be reset).\n *\n * @param {number} amount satoshis to be sent\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.fee = function(amount) {\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\n  this._fee = amount;\n  this._updateChangeOutput();\n  return this;\n};\n\n/**\n * Manually set the fee per KB for this transaction. Beware that this resets all the signatures\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n * be reset).\n *\n * @param {number} amount satoshis per KB to be sent\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.feePerKb = function(amount) {\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\n  this._feePerKb = amount;\n  this._updateChangeOutput();\n  return this;\n};\n\n/**\n * Manually set the fee per Byte for this transaction. Beware that this resets all the signatures\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n * be reset).\n * fee per Byte will be ignored if fee per KB is set\n *\n * @param {number} amount satoshis per Byte to be sent\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.feePerByte = function (amount) {\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\n  this._feePerByte = amount;\n  this._updateChangeOutput();\n  return this;\n};\n\n/* Output management */\n\n/**\n * Set the change address for this transaction\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @param {Address} address An address for change to be sent to.\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.change = function(address) {\n  $.checkArgument(address, 'address is required');\n  this._changeScript = Script.fromAddress(address);\n  this._updateChangeOutput();\n  return this;\n};\n\n\n/**\n * @return {Output} change output, if it exists\n */\nTransaction.prototype.getChangeOutput = function() {\n  if (this._changeIndex != null) {\n    return this.outputs[this._changeIndex];\n  }\n  return null;\n};\n\n/**\n * @typedef {Object} Transaction~toObject\n * @property {(string|Address)} address\n * @property {number} satoshis\n */\n\n/**\n * Add an output to the transaction.\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @param {(string|Address|Array.<Transaction~toObject>)} address\n * @param {number} amount in satoshis\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.to = function(address, amount) {\n  if (Array.isArray(address)) {\n    for (const to of address) {\n      this.to(to.address, to.satoshis);\n    }\n    return this;\n  }\n\n  $.checkArgument(\n    JSUtil.isNaturalNumber(amount),\n    'Amount is expected to be a positive integer'\n  );\n  this.addOutput(new Output({\n    script: Script(new Address(address)),\n    satoshis: amount\n  }));\n  return this;\n};\n\n/**\n * Add an OP_RETURN output to the transaction.\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @param {Buffer|string} value the data to be stored in the OP_RETURN output.\n *    In case of a string, the UTF-8 representation will be stored\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.addData = function(value) {\n  this.addOutput(new Output({\n    script: Script.buildDataOut(value),\n    satoshis: 0\n  }));\n  return this;\n};\n\n\n/**\n * Add an output to the transaction.\n *\n * @param {Output} output the output to add.\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.addOutput = function(output) {\n  $.checkArgumentType(output, Output, 'output');\n  this._addOutput(output);\n  this._updateChangeOutput();\n  return this;\n};\n\n\n/**\n * Remove all outputs from the transaction.\n *\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.clearOutputs = function() {\n  this.outputs = [];\n  this._clearSignatures();\n  this._outputAmount = undefined;\n  this._changeIndex = undefined;\n  this._updateChangeOutput();\n  return this;\n};\n\n\nTransaction.prototype._addOutput = function(output) {\n  this.outputs.push(output);\n  this._outputAmount = undefined;\n};\n\n\n/**\n * Calculates or gets the total output amount in satoshis\n *\n * @return {Number} the transaction total output amount\n */\nTransaction.prototype._getOutputAmount = function() {\n  if (this._outputAmount == null) {\n    var self = this;\n    this._outputAmount = 0;\n    for (const output of this.outputs || []) {\n      self._outputAmount += output.satoshis;\n    }\n  }\n  return this._outputAmount;\n};\n\n\n/**\n * Calculates or gets the total input amount in satoshis\n *\n * @return {Number} the transaction total input amount\n */\nTransaction.prototype._getInputAmount = function() {\n  if (this._inputAmount == null) {\n    this._inputAmount = _.sumBy(this.inputs, function(input) {\n      if (input.output == null) {\n        throw new errors.Transaction.Input.MissingPreviousOutput();\n      }\n      return input.output.satoshis;\n    });\n  }\n  return this._inputAmount;\n};\n\nTransaction.prototype._updateChangeOutput = function(noClearSigs) {\n  if (!this._changeScript) {\n    return;\n  }\n  if (!noClearSigs) {\n    this._clearSignatures();\n  }\n  if (this._changeIndex != null) {\n    this._removeOutput(this._changeIndex);\n  }\n  var available = this._getUnspentValue();\n  var fee = this.getFee();\n  var changeAmount = available - fee;\n  if (changeAmount > Transaction.DUST_AMOUNT) {\n    this._changeIndex = this.outputs.length;\n    this._addOutput(new Output({\n      script: this._changeScript,\n      satoshis: changeAmount\n    }));\n  } else {\n    this._changeIndex = undefined;\n  }\n};\n/**\n * Calculates the fee of the transaction.\n *\n * If there's a fixed fee set, return that.\n *\n * If there is no change output set, the fee is the\n * total value of the outputs minus inputs. Note that\n * a serialized transaction only specifies the value\n * of its outputs. (The value of inputs are recorded\n * in the previous transaction outputs being spent.)\n * This method therefore raises a \"MissingPreviousOutput\"\n * error when called on a serialized transaction.\n *\n * If there's no fee set and no change address,\n * estimate the fee based on size.\n *\n * @return {Number} fee of this transaction in satoshis\n */\nTransaction.prototype.getFee = function() {\n  if (this.isCoinbase()) {\n    return 0;\n  }\n  if (this._fee != null) {\n    return this._fee;\n  }\n  // if no change output is set, fees should equal all the unspent amount\n  if (!this._changeScript) {\n    return this._getUnspentValue();\n  }\n  return this._estimateFee();\n};\n\n/**\n * Estimates fee from serialized transaction size in bytes.\n */\nTransaction.prototype._estimateFee = function () {\n  const estimatedSize = this._estimateSize();\n  const available = this._getUnspentValue();\n  const feeRate = this._feePerByte || (this._feePerKb || Transaction.FEE_PER_KB) / 1000;\n  function getFee(size) {\n    return size * feeRate;\n  }\n  const fee = Math.ceil(getFee(estimatedSize));\n  const feeWithChange = Math.ceil(getFee(estimatedSize) + getFee(this._estimateSizeOfChangeOutput()));\n  if (!this._changeScript || available <= feeWithChange) {\n    return fee;\n  }\n  return feeWithChange;\n};\n\nTransaction.prototype._estimateSizeOfChangeOutput = function () {\n  if (!this._changeScript) {\n    return 0;\n  }\n  const scriptLen = this._changeScript.toBuffer().length;\n  // 8 bytes for satoshis + script size + actual script size\n  return 8 + BufferWriter.varintBufNum(scriptLen).length + scriptLen;\n};\n\nTransaction.prototype._getUnspentValue = function() {\n  return this._getInputAmount() - this._getOutputAmount();\n};\n\nTransaction.prototype._clearSignatures = function() {\n  for (const input of this.inputs || []) {\n    input.clearSignatures();\n  }\n};\n\n/**\n * Estimate the tx size before input signatures are added.\n */\nTransaction.prototype._estimateSize = function() {\n  let result = 4; // version\n\n  if (this.hasWitnesses()) {\n    result += .5;\n  }\n\n  result += BufferWriter.varintBufNum(this.inputs.length).length;\n  for (const input of this.inputs || []) {\n    result += input._estimateSize();\n  }\n\n  result += BufferWriter.varintBufNum(this.outputs.length).length;\n  for (const output of this.outputs || []) {\n    result += output.calculateSize();\n  }\n\n  result += 4; // nLockTime\n  return Math.ceil(result);\n};\n\nTransaction.prototype._calculateSize = function() {\n  return this.toBuffer().length;\n};\n\nTransaction.prototype._calculateVSize = function(noRound) {\n  const vsize = this._calculateWeight() / 4;\n  return noRound ? vsize : Math.ceil(vsize);\n};\n\nTransaction.prototype._calculateWeight = function() {\n  return (this.toBuffer(true).length * 3) + this.toBuffer(false).length;\n};\n\nTransaction.prototype._removeOutput = function(index) {\n  var output = this.outputs[index];\n  this.outputs = _.without(this.outputs, output);\n  this._outputAmount = undefined;\n};\n\nTransaction.prototype.removeOutput = function(index) {\n  this._removeOutput(index);\n  this._updateChangeOutput();\n};\n\n/**\n * Sort a transaction's inputs and outputs according to BIP69\n *\n * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki}\n * @return {Transaction} this\n */\nTransaction.prototype.sort = function() {\n  this.sortInputs(function(inputs) {\n    var copy = Array.prototype.concat.apply([], inputs);\n    let i = 0;\n    copy.forEach((x) => { x.i = i++});\n    copy.sort(function(first, second) {\n     return compare(first.prevTxId, second.prevTxId)\n        || first.outputIndex - second.outputIndex\n        || first.i - second.i;  // to ensure stable sort\n    });\n    return copy;\n  });\n  this.sortOutputs(function(outputs) {\n    var copy = Array.prototype.concat.apply([], outputs);\n    let i = 0;\n    copy.forEach((x) => { x.i = i++});\n    copy.sort(function(first, second) {\n      return first.satoshis - second.satoshis\n        || compare(first.script.toBuffer(), second.script.toBuffer())\n        || first.i - second.i;  // to ensure stable sort\n    });\n    return copy;\n  });\n  return this;\n};\n\n/**\n * Randomize this transaction's outputs ordering. The shuffling algorithm is a\n * version of the Fisher-Yates shuffle, provided by lodash's _.shuffle().\n *\n * @return {Transaction} this\n */\nTransaction.prototype.shuffleOutputs = function() {\n  return this.sortOutputs(_.shuffle);\n};\n\n/**\n * Sort this transaction's outputs, according to a given sorting function that\n * takes an array as argument and returns a new array, with the same elements\n * but with a different order. The argument function MUST NOT modify the order\n * of the original array\n *\n * @param {Function} sortingFunction\n * @return {Transaction} this\n */\nTransaction.prototype.sortOutputs = function(sortingFunction) {\n  var outs = sortingFunction(this.outputs);\n  return this._newOutputOrder(outs);\n};\n\n/**\n * Sort this transaction's inputs, according to a given sorting function that\n * takes an array as argument and returns a new array, with the same elements\n * but with a different order.\n *\n * @param {Function} sortingFunction\n * @return {Transaction} this\n */\nTransaction.prototype.sortInputs = function(sortingFunction) {\n  this.inputs = sortingFunction(this.inputs);\n  this._clearSignatures();\n  return this;\n};\n\nTransaction.prototype._newOutputOrder = function(newOutputs) {\n  var isInvalidSorting = (this.outputs.length !== newOutputs.length ||\n                          _.difference(this.outputs, newOutputs).length !== 0);\n  if (isInvalidSorting) {\n    throw new errors.Transaction.InvalidSorting();\n  }\n\n  if (this._changeIndex != null) {\n    var changeOutput = this.outputs[this._changeIndex];\n    this._changeIndex = newOutputs.indexOf(changeOutput);\n  }\n\n  this.outputs = newOutputs;\n  return this;\n};\n\nTransaction.prototype.removeInput = function(txId, outputIndex) {\n  var index;\n  if (!outputIndex && !isNaN(txId)) {\n    index = txId;\n  } else {\n    index = this.inputs.findIndex(function(input) {\n      return input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex;\n    });\n  }\n  if (index < 0 || index >= this.inputs.length) {\n    throw new errors.Transaction.InvalidIndex(index, this.inputs.length);\n  }\n  var input = this.inputs[index];\n  this.inputs = _.without(this.inputs, input);\n  this._inputAmount = undefined;\n  this._updateChangeOutput();\n};\n\n/* Signature handling */\n\n/**\n * Sign the transaction using one or more private keys.\n *\n * It tries to sign each input, verifying that the signature will be valid\n * (matches a public key).\n *\n * @param {Array|String|PrivateKey} privateKey\n * @param {number} sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer|String} merkleRoot - merkle root for taproot signing\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.sign = function(privateKey, sigtype, signingMethod, merkleRoot) {\n  $.checkState(this.hasAllUtxoInfo(), 'Not all utxo information is available to sign the transaction.');\n  if (Array.isArray(privateKey)) {\n    for (const pk of privateKey) {\n      this.sign(pk, sigtype, signingMethod, merkleRoot);\n    }\n    return this;\n  }\n  for (const signature of this.getSignatures(privateKey, sigtype, signingMethod, merkleRoot)) {\n    this.applySignature(signature, signingMethod);\n  }\n  return this;\n};\n\nTransaction.prototype.getSignatures = function(privKey, sigtype, signingMethod, merkleRoot) {\n  if (typeof merkleRoot === 'string') {\n    merkleRoot = Buffer.from(merkleRoot, 'hex');\n  }\n  privKey = new PrivateKey(privKey);\n  const results = [];\n  const hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());\n  for (let i = 0; i < this.inputs.length; i++) {\n    const input = this.inputs[i];\n    for (const signature of input.getSignatures(this, privKey, i, sigtype, hashData, signingMethod, merkleRoot)) {\n      results.push(signature);\n    }\n  }\n  return results;\n};\n\n/**\n * Add a signature to the transaction\n *\n * @param {Object} signature\n * @param {number} signature.inputIndex\n * @param {number} signature.sigtype\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {String} signingMethod - 'ecdsa' to sign transaction\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.applySignature = function(signature, signingMethod) {\n  this.inputs[signature.inputIndex].addSignature(this, signature, signingMethod);\n  return this;\n};\n\nTransaction.prototype.isFullySigned = function() {\n  for (const input of this.inputs || []) {\n    if (input.isFullySigned === Input.prototype.isFullySigned) {\n      throw new errors.Transaction.UnableToVerifySignature(\n        'Unrecognized script kind, or not enough information to execute script.' +\n        'This usually happens when creating a transaction from a serialized transaction'\n      );\n    }\n  }\n  return this.inputs.every(function(input) {\n    return input.isFullySigned();\n  });\n};\n\nTransaction.prototype.isValidSignature = function(signature, signingMethod) {\n  if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {\n    throw new errors.Transaction.UnableToVerifySignature(\n      'Unrecognized script kind, or not enough information to execute script.' +\n      'This usually happens when creating a transaction from a serialized transaction'\n    );\n  }\n  return this.inputs[signature.inputIndex].isValidSignature(this, signature, signingMethod);\n};\n\n\n/**\n * Verify ECDSA signature\n * @param {Signature} sig \n * @param {PublicKey} pubkey \n * @param {Number} nin \n * @param {Script} subscript \n * @param {Number} satoshis \n * @returns {Boolean}\n */\nTransaction.prototype.checkEcdsaSignature = function(sig, pubkey, nin, subscript, satoshis) {\n  var subscriptBuffer = subscript.toBuffer();\n  var scriptCodeWriter = new BufferWriter();\n  scriptCodeWriter.writeVarintNum(subscriptBuffer.length);\n  scriptCodeWriter.write(subscriptBuffer);\n\n  var satoshisBuffer;\n  if (satoshis) {\n    $.checkState(JSUtil.isNaturalNumber(satoshis), 'satoshis needs to be a natural number');\n    satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();\n  } else {\n    satoshisBuffer = this.inputs[nin].getSatoshisBuffer();\n  }\n  var verified = SighashWitness.verify(\n    this,\n    sig,\n    pubkey,\n    nin,\n    scriptCodeWriter.toBuffer(),\n    satoshisBuffer\n  );\n  return verified;\n};\n\n\n/**\n * Verify Schnorr signature\n * @param {Signature|Buffer} sig \n * @param {PublicKey|Buffer} pubkey \n * @param {Number} nin \n * @param {Number} sigversion \n * @param {Object} execdata \n * @returns {Boolean}\n */\nTransaction.prototype.checkSchnorrSignature = function(sig, pubkey, nin, sigversion, execdata) {\n  if ($.isType(pubkey, 'PublicKey')) {\n    pubkey = pubkey.point.x.toBuffer();\n  }\n  $.checkArgument(pubkey && pubkey.length === 32, 'Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.');\n\n  if (Buffer.isBuffer(sig)) {\n    if (sig.length !== 64 && sig.length !== 65) {\n      return false;\n    }\n    sig = Signature.fromSchnorr(sig);\n  }\n  // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not\n  // abort script execution). This is implemented in Interpreter.evalChecksigTapscript, which won't invoke\n  // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with\n  // size different from 64 or 65.\n  $.checkArgument(sig.isSchnorr, 'Signature must be schnorr');\n\n  if (!SighashSchnorr.verify(this, sig, pubkey, sigversion, nin, execdata)) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * This is here largely for legacy reasons. However, if the sig type\n * is already known (via sigversion), then it would be better to call\n * checkEcdsaSignature or checkSchnorrSignature directly.\n * @param {Signature|Buffer} sig Signature to verify\n * @param {PublicKey|Buffer} pubkey Public key used to verify sig\n * @param {Number} nin Tx input index to verify signature against\n * @param {Script} subscript ECDSA only\n * @param {Number} sigversion See Signature.Version for valid versions (default: 0 or Signature.Version.BASE)\n * @param {Number} satoshis ECDSA only\n * @param {Object} execdata Schnorr only\n * @returns {Boolean} whether the signature is valid for this transaction input\n */\nTransaction.prototype.verifySignature = function(sig, pubkey, nin, subscript, sigversion, satoshis, execdata) {\n  if (sigversion == null) {\n    sigversion = Signature.Version.BASE;\n  }\n\n  switch(sigversion) {\n    case Signature.Version.WITNESS_V0:\n      return this.checkEcdsaSignature(sig, pubkey, nin, subscript, satoshis);\n    case Signature.Version.TAPROOT:\n    case Signature.Version.TAPSCRIPT:\n      return this.checkSchnorrSignature(sig, pubkey, nin, sigversion, execdata);\n    case Signature.Version.BASE:\n    default:\n      return Sighash.verify(this, sig, pubkey, nin, subscript);\n  }\n};\n\n/**\n * Check that a transaction passes basic sanity tests. If not, return a string\n * describing the error. This function contains the same logic as\n * CheckTransaction in bitcoin core.\n */\nTransaction.prototype.verify = function() {\n  // Basic checks that don't depend on any context\n  if (this.inputs.length === 0) {\n    return 'transaction txins empty';\n  }\n\n  if (this.outputs.length === 0) {\n    return 'transaction txouts empty';\n  }\n\n  // Check for negative or overflow output values\n  var valueoutbn = new BN(0);\n  for (var i = 0; i < this.outputs.length; i++) {\n    var txout = this.outputs[i];\n\n    if (txout.invalidSatoshis()) {\n      return 'transaction txout ' + i + ' satoshis is invalid';\n    }\n    if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {\n      return 'transaction txout ' + i + ' greater than MAX_MONEY';\n    }\n    valueoutbn = valueoutbn.add(txout._satoshisBN);\n    if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {\n      return 'transaction txout ' + i + ' total output greater than MAX_MONEY';\n    }\n  }\n\n  // Size limits\n  if (this.toBuffer().length > MAX_BLOCK_SIZE) {\n    return 'transaction over the maximum block size';\n  }\n\n  // Check for duplicate inputs\n  var txinmap = {};\n  for (i = 0; i < this.inputs.length; i++) {\n    var txin = this.inputs[i];\n\n    var inputid = txin.prevTxId + ':' + txin.outputIndex;\n    if (txinmap[inputid] != null) {\n      return 'transaction input ' + i + ' duplicate input';\n    }\n    txinmap[inputid] = true;\n  }\n\n  var isCoinbase = this.isCoinbase();\n  if (isCoinbase) {\n    var buf = this.inputs[0]._scriptBuffer;\n    if (buf.length < 2 || buf.length > 100) {\n      return 'coinbase transaction script size invalid';\n    }\n  } else {\n    for (i = 0; i < this.inputs.length; i++) {\n      if (this.inputs[i].isNull()) {\n        return 'transaction input ' + i + ' has null input';\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * Analogous to bitcoind's IsCoinBase function in transaction.h\n */\nTransaction.prototype.isCoinbase = function() {\n  return (this.inputs.length === 1 && this.inputs[0].isNull());\n};\n\n/**\n * Determines if this transaction can be replaced in the mempool with another\n * transaction that provides a sufficiently higher fee (RBF).\n */\nTransaction.prototype.isRBF = function() {\n  for (var i = 0; i < this.inputs.length; i++) {\n    var input = this.inputs[i];\n    if (input.sequenceNumber < Input.MAXINT - 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Enable this transaction to be replaced in the mempool (RBF) if a transaction\n * includes a sufficiently higher fee. It will set the sequenceNumber to\n * DEFAULT_RBF_SEQNUMBER for all inputs if the sequence number does not\n * already enable RBF.\n */\nTransaction.prototype.enableRBF = function() {\n  for (var i = 0; i < this.inputs.length; i++) {\n    var input = this.inputs[i];\n    if (input.sequenceNumber >= Input.MAXINT - 1) {\n      input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;\n    }\n  }\n  return this;\n};\n\nTransaction.prototype.setVersion = function(version) {\n  $.checkArgument(\n    JSUtil.isNaturalNumber(version) && version <= CURRENT_VERSION,\n    'Wrong version number');\n  this.version = version;\n  return this;\n};\n\n\n\nmodule.exports = Transaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixnQ0FBZ0MsbUJBQU8sQ0FBQyxvRUFBZ0I7O0FBRXhELGFBQWEsbUJBQU8sQ0FBQyx1RUFBVztBQUNoQyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLG1FQUFZO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDckQsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBcUI7QUFDN0MsY0FBYyxtQkFBTyxDQUFDLDhFQUFXO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLDRGQUFrQjtBQUMvQyx1QkFBdUIsbUJBQU8sQ0FBQyw0RkFBa0I7O0FBRWpELGNBQWMsbUJBQU8sQ0FBQyxtRUFBWTtBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQywwRkFBaUI7QUFDN0MsWUFBWSxtQkFBTyxDQUFDLGdGQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsNEVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHVFQUFXO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFlO0FBQ3hDLFNBQVMsbUJBQU8sQ0FBQyx1RUFBYzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSxvQ0FBb0M7QUFDdkQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSxvQ0FBb0M7QUFDdkQsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0VBQW9FO0FBQ3pGO0FBQ0E7QUFDQSxxQkFBcUIsd0VBQXdFO0FBQzdGO0FBQ0E7QUFDQSxxQkFBcUIsd0VBQXdFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQXlEO0FBQ3BFLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUErQztBQUMxRCxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanM/NDljOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIGNvbXBhcmUgPSBCdWZmZXIuY29tcGFyZSB8fCByZXF1aXJlKCdidWZmZXItY29tcGFyZScpO1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9qcycpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL2NyeXB0by9zaWduYXR1cmUnKTtcbnZhciBTaWdoYXNoID0gcmVxdWlyZSgnLi9zaWdoYXNoJyk7XG52YXIgU2lnaGFzaFdpdG5lc3MgPSByZXF1aXJlKCcuL3NpZ2hhc2h3aXRuZXNzJyk7XG5jb25zdCBTaWdoYXNoU2Nobm9yciA9IHJlcXVpcmUoJy4vc2lnaGFzaHNjaG5vcnInKTtcblxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi9hZGRyZXNzJyk7XG52YXIgVW5zcGVudE91dHB1dCA9IHJlcXVpcmUoJy4vdW5zcGVudG91dHB1dCcpO1xudmFyIElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xudmFyIFB1YmxpY0tleUhhc2hJbnB1dCA9IElucHV0LlB1YmxpY0tleUhhc2g7XG52YXIgUHVibGljS2V5SW5wdXQgPSBJbnB1dC5QdWJsaWNLZXk7XG52YXIgTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQgPSBJbnB1dC5NdWx0aVNpZ1NjcmlwdEhhc2g7XG52YXIgTXVsdGlTaWdJbnB1dCA9IElucHV0Lk11bHRpU2lnO1xuY29uc3QgVGFwcm9vdElucHV0ID0gSW5wdXQuVGFwcm9vdDtcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuL291dHB1dCcpO1xudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRla2V5Jyk7XG52YXIgQk4gPSByZXF1aXJlKCcuLi9jcnlwdG8vYm4nKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24sIGEgc2V0IG9mIGlucHV0cyBhbmQgb3V0cHV0cyB0byBjaGFuZ2Ugb3duZXJzaGlwIG9mIHRva2Vuc1xuICpcbiAqIEBwYXJhbSB7Kn0gc2VyaWFsaXplZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRyYW5zYWN0aW9uKHNlcmlhbGl6ZWQsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oc2VyaWFsaXplZCk7XG4gIH1cbiAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgdGhpcy5vdXRwdXRzID0gW107XG4gIHRoaXMuX2lucHV0QW1vdW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vdXRwdXRBbW91bnQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAoc2VyaWFsaXplZCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gVHJhbnNhY3Rpb24uc2hhbGxvd0NvcHkoc2VyaWFsaXplZCk7XG4gICAgfSBlbHNlIGlmIChKU1V0aWwuaXNIZXhhKHNlcmlhbGl6ZWQpKSB7XG4gICAgICB0aGlzLmZyb21TdHJpbmcoc2VyaWFsaXplZCk7XG4gICAgfSBlbHNlIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKHNlcmlhbGl6ZWQpKSB7XG4gICAgICB0aGlzLmZyb21CdWZmZXIoc2VyaWFsaXplZCk7XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHNlcmlhbGl6ZWQpKSB7XG4gICAgICB0aGlzLmZyb21PYmplY3Qoc2VyaWFsaXplZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50KCdNdXN0IHByb3ZpZGUgYW4gb2JqZWN0IG9yIHN0cmluZyB0byBkZXNlcmlhbGl6ZSBhIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX25ld1RyYW5zYWN0aW9uKCk7XG4gIH1cbn1cbnZhciBDVVJSRU5UX1ZFUlNJT04gPSAyO1xudmFyIERFRkFVTFRfTkxPQ0tUSU1FID0gMDtcbnZhciBNQVhfQkxPQ0tfU0laRSA9IDEwMDAwMDA7XG5cbi8vIE1pbmltdW0gYW1vdW50IGZvciBhbiBvdXRwdXQgZm9yIGl0IG5vdCB0byBiZSBjb25zaWRlcmVkIGEgZHVzdCBvdXRwdXRcblRyYW5zYWN0aW9uLkRVU1RfQU1PVU5UID0gNTQ2O1xuXG4vLyBNYXJnaW4gb2YgZXJyb3IgdG8gYWxsb3cgZmVlcyBpbiB0aGUgdmVjaW5pdHkgb2YgdGhlIGV4cGVjdGVkIHZhbHVlIGJ1dCBkb2Vzbid0IGFsbG93IGEgYmlnIGRpZmZlcmVuY2VcblRyYW5zYWN0aW9uLkZFRV9TRUNVUklUWV9NQVJHSU4gPSAxNTA7XG5cbi8vIG1heCBhbW91bnQgb2Ygc2F0b3NoaXMgaW4gY2lyY3VsYXRpb25cblRyYW5zYWN0aW9uLk1BWF9NT05FWSA9IDIxMDAwMDAwICogMWU4O1xuXG4vLyBubG9ja3RpbWUgbGltaXQgdG8gYmUgY29uc2lkZXJlZCBibG9jayBoZWlnaHQgcmF0aGVyIHRoYW4gYSB0aW1lc3RhbXBcblRyYW5zYWN0aW9uLk5MT0NLVElNRV9CTE9DS0hFSUdIVF9MSU1JVCA9IDVlODtcblxuLy8gTWF4IHZhbHVlIGZvciBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWVcblRyYW5zYWN0aW9uLk5MT0NLVElNRV9NQVhfVkFMVUUgPSA0Mjk0OTY3Mjk1O1xuXG4vLyBWYWx1ZSB1c2VkIGZvciBmZWUgZXN0aW1hdGlvbiAoc2F0b3NoaXMgcGVyIGtpbG9ieXRlKVxuVHJhbnNhY3Rpb24uRkVFX1BFUl9LQiA9IDEwMDAwMDtcblxuLy8gU2FmZSB1cHBlciBib3VuZCBmb3IgY2hhbmdlIGFkZHJlc3Mgc2NyaXB0IHNpemUgaW4gYnl0ZXNcblRyYW5zYWN0aW9uLkNIQU5HRV9PVVRQVVRfTUFYX1NJWkUgPSAyMCArIDQgKyAzNCArIDQ7XG5UcmFuc2FjdGlvbi5NQVhJTVVNX0VYVFJBX1NJWkUgPSA0ICsgOSArIDkgKyA0O1xuXG4vKiBDb25zdHJ1Y3RvcnMgYW5kIFNlcmlhbGl6YXRpb24gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSAnc2hhbGxvdycgY29weSBvZiB0aGUgdHJhbnNhY3Rpb24sIGJ5IHNlcmlhbGl6aW5nIGFuZCBkZXNlcmlhbGl6aW5nXG4gKiBpdCBkcm9wcGluZyBhbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aGF0IGlucHV0cyBhbmQgb3V0cHV0cyBtYXkgaGF2ZSBob2xkXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufVxuICovXG5UcmFuc2FjdGlvbi5zaGFsbG93Q29weSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBjb3B5ID0gbmV3IFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLnRvQnVmZmVyKCkpO1xuICByZXR1cm4gY29weTtcbn07XG5cbnZhciBoYXNoUHJvcGVydHkgPSB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faGFzaCA9IG5ldyBCdWZmZXJSZWFkZXIodGhpcy5fZ2V0SGFzaCgpKS5yZWFkUmV2ZXJzZSgpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgfVxufTtcblxudmFyIHdpdG5lc3NIYXNoUHJvcGVydHkgPSB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJSZWFkZXIodGhpcy5fZ2V0V2l0bmVzc0hhc2goKSkucmVhZFJldmVyc2UoKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsICd3aXRuZXNzSGFzaCcsIHdpdG5lc3NIYXNoUHJvcGVydHkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ2hhc2gnLCBoYXNoUHJvcGVydHkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ2lkJywgaGFzaFByb3BlcnR5KTtcblxudmFyIGlvUHJvcGVydHkgPSB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldElucHV0QW1vdW50KCk7XG4gIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCAnaW5wdXRBbW91bnQnLCBpb1Byb3BlcnR5KTtcbmlvUHJvcGVydHkuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nZXRPdXRwdXRBbW91bnQoKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCAnb3V0cHV0QW1vdW50JywgaW9Qcm9wZXJ0eSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsICdzaXplJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlU2l6ZSgpO1xuICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ3ZzaXplJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlVlNpemUoKTtcbiAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsICd3ZWlnaHQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVXZWlnaHQoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpdHRsZSBlbmRpYW4gaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gKHVzZWQgZm9yIHNlcmlhbGl6YXRpb24pXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZ2V0SGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSGFzaC5zaGEyNTZzaGEyNTYodGhpcy50b0J1ZmZlcih0cnVlKSk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXR0bGUgZW5kaWFuIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGluY2x1ZGluZyB3aXRuZXNzIGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9nZXRXaXRuZXNzSGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSGFzaC5zaGEyNTZzaGEyNTYodGhpcy50b0J1ZmZlcihmYWxzZSkpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGhleGEgc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBiaXRjb2luZCdzIENMSSBpbnRlcmZhY2VcbiAqIChkZWNvZGVyYXd0cmFuc2FjdGlvbiwgc2VuZHJhd3RyYW5zYWN0aW9uKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW49fSB1bnNhZmUgaWYgdHJ1ZSwgc2tpcCBhbGwgdGVzdHMuIGlmIGl0J3MgYW4gb2JqZWN0LFxuICogICBpdCdzIGV4cGVjdGVkIHRvIGNvbnRhaW4gYSBzZXQgb2YgZmxhZ3MgdG8gc2tpcCBjZXJ0YWluIHRlc3RzOlxuICogKiBgZGlzYWJsZUFsbGA6IGRpc2FibGUgYWxsIGNoZWNrc1xuICogKiBgZGlzYWJsZVNtYWxsRmVlc2A6IGRpc2FibGUgY2hlY2tpbmcgZm9yIGZlZXMgdGhhdCBhcmUgdG9vIHNtYWxsXG4gKiAqIGBkaXNhYmxlTGFyZ2VGZWVzYDogZGlzYWJsZSBjaGVja2luZyBmb3IgZmVlcyB0aGF0IGFyZSB0b28gbGFyZ2VcbiAqICogYGRpc2FibGVJc0Z1bGx5U2lnbmVkYDogZGlzYWJsZSBjaGVja2luZyBpZiBhbGwgaW5wdXRzIGFyZSBmdWxseSBzaWduZWRcbiAqICogYGRpc2FibGVEdXN0T3V0cHV0c2A6IGRpc2FibGUgY2hlY2tpbmcgaWYgdGhlcmUgYXJlIG5vIG91dHB1dHMgdGhhdCBhcmUgZHVzdCBhbW91bnRzXG4gKiAqIGBkaXNhYmxlTW9yZU91dHB1dFRoYW5JbnB1dGA6IGRpc2FibGUgY2hlY2tpbmcgaWYgdGhlIHRyYW5zYWN0aW9uIHNwZW5kcyBtb3JlIGJpdGNvaW5zIHRoYW4gdGhlIHN1bSBvZiB0aGUgaW5wdXQgYW1vdW50c1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24odW5zYWZlKSB7XG4gIGlmICh0cnVlID09PSB1bnNhZmUgfHwgdW5zYWZlICYmIHVuc2FmZS5kaXNhYmxlQWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudW5jaGVja2VkU2VyaWFsaXplKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tlZFNlcmlhbGl6ZSh1bnNhZmUpO1xuICB9XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUudW5jaGVja2VkU2VyaWFsaXplID0gVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGhleGEgc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBiaXRjb2luZCdzIENMSSBpbnRlcmZhY2VcbiAqIChkZWNvZGVyYXd0cmFuc2FjdGlvbiwgc2VuZHJhd3RyYW5zYWN0aW9uKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIGFsbG93cyB0byBza2lwIGNlcnRhaW4gdGVzdHMuIHtAc2VlIFRyYW5zYWN0aW9uI3NlcmlhbGl6ZX1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmNoZWNrZWRTZXJpYWxpemUgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciBzZXJpYWxpemF0aW9uRXJyb3IgPSB0aGlzLmdldFNlcmlhbGl6YXRpb25FcnJvcihvcHRzKTtcbiAgaWYgKHNlcmlhbGl6YXRpb25FcnJvcikge1xuICAgIHNlcmlhbGl6YXRpb25FcnJvci5tZXNzYWdlICs9ICcgLSBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlOiAnICtcbiAgICAgICdodHRwczovL2dpdGh1Yi5jb20vYml0cGF5L2JpdGNvcmUvYmxvYi9tYXN0ZXIvcGFja2FnZXMvYml0Y29yZS1saWIvZG9jcy90cmFuc2FjdGlvbi5tZCNzZXJpYWxpemF0aW9uLWNoZWNrcyc7XG4gICAgdGhyb3cgc2VyaWFsaXphdGlvbkVycm9yO1xuICB9XG4gIHJldHVybiB0aGlzLnVuY2hlY2tlZFNlcmlhbGl6ZSgpO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmludmFsaWRTYXRvc2hpcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW52YWxpZCA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLm91dHB1dHNbaV0uaW52YWxpZFNhdG9zaGlzKCkpIHtcbiAgICAgIGludmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW52YWxpZDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYSBwb3NzaWJsZSBlcnJvciB0aGF0IGNvdWxkIGFwcGVhciB3aGVuIHRyeWluZyB0byBzZXJpYWxpemUgYW5kXG4gKiBicm9hZGNhc3QgdGhpcyB0cmFuc2FjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBhbGxvd3MgdG8gc2tpcCBjZXJ0YWluIHRlc3RzLiB7QHNlZSBUcmFuc2FjdGlvbiNzZXJpYWxpemV9XG4gKiBAcmV0dXJuIHtiaXRjb3JlLkVycm9yfVxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0U2VyaWFsaXphdGlvbkVycm9yID0gZnVuY3Rpb24ob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodGhpcy5pbnZhbGlkU2F0b3NoaXMoKSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkludmFsaWRTYXRvc2hpcygpO1xuICB9XG5cbiAgdmFyIHVuc3BlbnQgPSB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcbiAgdmFyIHVuc3BlbnRFcnJvcjtcbiAgaWYgKHVuc3BlbnQgPCAwKSB7XG4gICAgaWYgKCFvcHRzLmRpc2FibGVNb3JlT3V0cHV0VGhhbklucHV0KSB7XG4gICAgICB1bnNwZW50RXJyb3IgPSBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkludmFsaWRPdXRwdXRBbW91bnRTdW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdW5zcGVudEVycm9yID0gdGhpcy5faGFzRmVlRXJyb3Iob3B0cywgdW5zcGVudCk7XG4gIH1cblxuICByZXR1cm4gdW5zcGVudEVycm9yIHx8XG4gICAgdGhpcy5faGFzRHVzdE91dHB1dHMob3B0cykgfHxcbiAgICB0aGlzLl9pc01pc3NpbmdTaWduYXR1cmVzKG9wdHMpO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9oYXNGZWVFcnJvciA9IGZ1bmN0aW9uKG9wdHMsIHVuc3BlbnQpIHtcblxuICBpZiAodGhpcy5fZmVlICE9IG51bGwgJiYgdGhpcy5fZmVlICE9PSB1bnNwZW50KSB7XG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uRmVlRXJyb3IuRGlmZmVyZW50KFxuICAgICAgJ1Vuc3BlbnQgdmFsdWUgaXMgJyArIHVuc3BlbnQgKyAnIGJ1dCBzcGVjaWZpZWQgZmVlIGlzICcgKyB0aGlzLl9mZWVcbiAgICApO1xuICB9XG5cbiAgaWYgKCFvcHRzLmRpc2FibGVMYXJnZUZlZXMpIHtcbiAgICB2YXIgbWF4aW11bUZlZSA9IE1hdGguZmxvb3IoVHJhbnNhY3Rpb24uRkVFX1NFQ1VSSVRZX01BUkdJTiAqIHRoaXMuX2VzdGltYXRlRmVlKCkpO1xuICAgIGlmICh1bnNwZW50ID4gbWF4aW11bUZlZSkge1xuICAgICAgaWYgKHRoaXMuX21pc3NpbmdDaGFuZ2UoKSkge1xuICAgICAgICByZXR1cm4gbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5DaGFuZ2VBZGRyZXNzTWlzc2luZyhcbiAgICAgICAgICAnRmVlIGlzIHRvbyBsYXJnZSBhbmQgbm8gY2hhbmdlIGFkZHJlc3Mgd2FzIHByb3ZpZGVkJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uRmVlRXJyb3IuVG9vTGFyZ2UoXG4gICAgICAgICdleHBlY3RlZCBsZXNzIHRoYW4gJyArIG1heGltdW1GZWUgKyAnIGJ1dCBnb3QgJyArIHVuc3BlbnRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRzLmRpc2FibGVTbWFsbEZlZXMpIHtcbiAgICB2YXIgbWluaW11bUZlZSA9IE1hdGguY2VpbCh0aGlzLl9lc3RpbWF0ZUZlZSgpIC8gVHJhbnNhY3Rpb24uRkVFX1NFQ1VSSVRZX01BUkdJTik7XG4gICAgaWYgKHVuc3BlbnQgPCBtaW5pbXVtRmVlKSB7XG4gICAgICByZXR1cm4gbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5GZWVFcnJvci5Ub29TbWFsbChcbiAgICAgICAgJ2V4cGVjdGVkIG1vcmUgdGhhbiAnICsgbWluaW11bUZlZSArICcgYnV0IGdvdCAnICsgdW5zcGVudFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fbWlzc2luZ0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuX2NoYW5nZVNjcmlwdDtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5faGFzRHVzdE91dHB1dHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIGlmIChvcHRzLmRpc2FibGVEdXN0T3V0cHV0cykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXgsIG91dHB1dDtcbiAgZm9yIChpbmRleCBpbiB0aGlzLm91dHB1dHMpIHtcbiAgICBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaW5kZXhdO1xuICAgIGlmIChvdXRwdXQuc2F0b3NoaXMgPCBUcmFuc2FjdGlvbi5EVVNUX0FNT1VOVCAmJiAhb3V0cHV0LnNjcmlwdC5pc0RhdGFPdXQoKSkge1xuICAgICAgcmV0dXJuIG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uRHVzdE91dHB1dHMoKTtcbiAgICB9XG4gIH1cbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5faXNNaXNzaW5nU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgaWYgKG9wdHMuZGlzYWJsZUlzRnVsbHlTaWduZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF0aGlzLmlzRnVsbHlTaWduZWQoKSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLk1pc3NpbmdTaWduYXR1cmVzKCk7XG4gIH1cbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPFRyYW5zYWN0aW9uOiAnICsgdGhpcy51bmNoZWNrZWRTZXJpYWxpemUoKSArICc+Jztcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKG5vV2l0bmVzcykge1xuICB2YXIgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICByZXR1cm4gdGhpcy50b0J1ZmZlcldyaXRlcih3cml0ZXIsIG5vV2l0bmVzcykudG9CdWZmZXIoKTtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5oYXNXaXRuZXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmlucHV0c1tpXS5oYXNXaXRuZXNzZXMoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS50b0J1ZmZlcldyaXRlciA9IGZ1bmN0aW9uKHdyaXRlciwgbm9XaXRuZXNzKSB7XG4gIHdyaXRlci53cml0ZUludDMyTEUodGhpcy52ZXJzaW9uKTtcblxuICBjb25zdCBoYXNXaXRuZXNzZXMgPSB0aGlzLmhhc1dpdG5lc3NlcygpO1xuXG4gIGlmIChoYXNXaXRuZXNzZXMgJiYgIW5vV2l0bmVzcykge1xuICAgIHdyaXRlci53cml0ZShCdWZmZXIuZnJvbSgnMDAwMScsICdoZXgnKSk7XG4gIH1cblxuICB3cml0ZXIud3JpdGVWYXJpbnROdW0odGhpcy5pbnB1dHMgPyB0aGlzLmlucHV0cy5sZW5ndGggOiAwKTtcbiAgZm9yIChjb25zdCBpbnB1dCBvZiB0aGlzLmlucHV0cyB8fCBbXSkge1xuICAgIGlucHV0LnRvQnVmZmVyV3JpdGVyKHdyaXRlcik7XG4gIH1cblxuICB3cml0ZXIud3JpdGVWYXJpbnROdW0odGhpcy5vdXRwdXRzID8gdGhpcy5vdXRwdXRzLmxlbmd0aCA6IDApO1xuICBmb3IgKGNvbnN0IG91dHB1dCBvZiB0aGlzLm91dHB1dHMgfHwgW10pIHtcbiAgICBvdXRwdXQudG9CdWZmZXJXcml0ZXIod3JpdGVyKTtcbiAgfVxuXG4gIGlmIChoYXNXaXRuZXNzZXMgJiYgIW5vV2l0bmVzcykge1xuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dHMpIHtcbiAgICAgIGNvbnN0IHdpdG5lc3NlcyA9IGlucHV0LmdldFdpdG5lc3NlcygpO1xuICAgICAgd3JpdGVyLndyaXRlVmFyaW50TnVtKHdpdG5lc3Nlcy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aXRuZXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgd3JpdGVyLndyaXRlVmFyaW50TnVtKHdpdG5lc3Nlc1tqXS5sZW5ndGgpO1xuICAgICAgICB3cml0ZXIud3JpdGUod2l0bmVzc2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0aGlzLm5Mb2NrVGltZSk7XG4gIHJldHVybiB3cml0ZXI7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVhZGVyID0gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpO1xuICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyUmVhZGVyKHJlYWRlcik7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZnJvbUJ1ZmZlclJlYWRlciA9IGZ1bmN0aW9uKHJlYWRlcikge1xuICAkLmNoZWNrQXJndW1lbnQoIXJlYWRlci5maW5pc2hlZCgpLCAnTm8gdHJhbnNhY3Rpb24gZGF0YSByZWNlaXZlZCcpO1xuXG4gIHRoaXMudmVyc2lvbiA9IHJlYWRlci5yZWFkSW50MzJMRSgpO1xuICB2YXIgc2l6ZVR4SW5zID0gcmVhZGVyLnJlYWRWYXJpbnROdW0oKTtcblxuICAvLyBjaGVjayBmb3Igc2Vnd2l0XG4gIHZhciBoYXNXaXRuZXNzZXMgPSBmYWxzZTtcbiAgaWYgKHNpemVUeElucyA9PT0gMCAmJiByZWFkZXIuYnVmW3JlYWRlci5wb3NdICE9PSAwKSB7XG4gICAgcmVhZGVyLnBvcyArPSAxO1xuICAgIGhhc1dpdG5lc3NlcyA9IHRydWU7XG4gICAgc2l6ZVR4SW5zID0gcmVhZGVyLnJlYWRWYXJpbnROdW0oKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVR4SW5zOyBpKyspIHtcbiAgICB2YXIgaW5wdXQgPSBJbnB1dC5mcm9tQnVmZmVyUmVhZGVyKHJlYWRlcik7XG4gICAgdGhpcy5pbnB1dHMucHVzaChpbnB1dCk7XG4gIH1cblxuICB2YXIgc2l6ZVR4T3V0cyA9IHJlYWRlci5yZWFkVmFyaW50TnVtKCk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVR4T3V0czsgaisrKSB7XG4gICAgdGhpcy5vdXRwdXRzLnB1c2goT3V0cHV0LmZyb21CdWZmZXJSZWFkZXIocmVhZGVyKSk7XG4gIH1cblxuICBpZiAoaGFzV2l0bmVzc2VzKSB7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaXplVHhJbnM7IGsrKykge1xuICAgICAgdmFyIGl0ZW1Db3VudCA9IHJlYWRlci5yZWFkVmFyaW50TnVtKCk7XG4gICAgICB2YXIgd2l0bmVzc2VzID0gW107XG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGl0ZW1Db3VudDsgbCsrKSB7XG4gICAgICAgIHZhciBzaXplID0gcmVhZGVyLnJlYWRWYXJpbnROdW0oKTtcbiAgICAgICAgdmFyIGl0ZW0gPSByZWFkZXIucmVhZChzaXplKTtcbiAgICAgICAgd2l0bmVzc2VzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlucHV0c1trXS5zZXRXaXRuZXNzZXMod2l0bmVzc2VzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm5Mb2NrVGltZSA9IHJlYWRlci5yZWFkVUludDMyTEUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS50b09iamVjdCA9IFRyYW5zYWN0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgdmFyIGlucHV0cyA9IFtdO1xuICB0aGlzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaW5wdXRzLnB1c2goaW5wdXQudG9PYmplY3QoKSk7XG4gIH0pO1xuICB2YXIgb3V0cHV0cyA9IFtdO1xuICB0aGlzLm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbihvdXRwdXQpIHtcbiAgICBvdXRwdXRzLnB1c2gob3V0cHV0LnRvT2JqZWN0KCkpO1xuICB9KTtcbiAgdmFyIG9iaiA9IHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgIGlucHV0czogaW5wdXRzLFxuICAgIG91dHB1dHM6IG91dHB1dHMsXG4gICAgbkxvY2tUaW1lOiB0aGlzLm5Mb2NrVGltZVxuICB9O1xuICBpZiAodGhpcy5fY2hhbmdlU2NyaXB0KSB7XG4gICAgb2JqLmNoYW5nZVNjcmlwdCA9IHRoaXMuX2NoYW5nZVNjcmlwdC50b1N0cmluZygpO1xuICB9XG4gIGlmICh0aGlzLl9jaGFuZ2VJbmRleCAhPSBudWxsKSB7XG4gICAgb2JqLmNoYW5nZUluZGV4ID0gdGhpcy5fY2hhbmdlSW5kZXg7XG4gIH1cbiAgaWYgKHRoaXMuX2ZlZSAhPSBudWxsKSB7XG4gICAgb2JqLmZlZSA9IHRoaXMuX2ZlZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KGFyZywgb3B0cykge1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3QoYXJnKSB8fCBhcmcgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbik7XG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgaWYgKGFyZyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgdHJhbnNhY3Rpb24gPSBhcmcudG9PYmplY3QoKTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2FjdGlvbiA9IGFyZztcbiAgfVxuICBmb3IgKGNvbnN0IGlucHV0IG9mIHRyYW5zYWN0aW9uLmlucHV0cyB8fCBbXSkge1xuICAgIGlmICghaW5wdXQub3V0cHV0IHx8ICFpbnB1dC5vdXRwdXQuc2NyaXB0KSB7XG4gICAgICB0aGlzLnVuY2hlY2tlZEFkZElucHV0KG5ldyBJbnB1dChpbnB1dCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBzY3JpcHQgPSBuZXcgU2NyaXB0KGlucHV0Lm91dHB1dC5zY3JpcHQpO1xuICAgIHZhciB0eGluO1xuICAgIGlmICgoc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpIHx8IHNjcmlwdC5pc1dpdG5lc3NTY3JpcHRIYXNoT3V0KCkpICYmIGlucHV0LnB1YmxpY0tleXMgJiYgaW5wdXQudGhyZXNob2xkKSB7XG4gICAgICB0eGluID0gbmV3IElucHV0Lk11bHRpU2lnU2NyaXB0SGFzaChcbiAgICAgICAgaW5wdXQsIGlucHV0LnB1YmxpY0tleXMsIGlucHV0LnRocmVzaG9sZCwgaW5wdXQuc2lnbmF0dXJlcywgb3B0c1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHNjcmlwdC5pc1B1YmxpY0tleUhhc2hPdXQoKSB8fCBzY3JpcHQuaXNXaXRuZXNzUHVibGljS2V5SGFzaE91dCgpIHx8IHNjcmlwdC5pc1NjcmlwdEhhc2hPdXQoKSkge1xuICAgICAgdHhpbiA9IG5ldyBJbnB1dC5QdWJsaWNLZXlIYXNoKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHNjcmlwdC5pc1B1YmxpY0tleU91dCgpKSB7XG4gICAgICB0eGluID0gbmV3IElucHV0LlB1YmxpY0tleShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW5wdXQuVW5zdXBwb3J0ZWRTY3JpcHQoaW5wdXQub3V0cHV0LnNjcmlwdCk7XG4gICAgfVxuICAgIHRoaXMuYWRkSW5wdXQodHhpbik7XG4gIH1cbiAgZm9yIChjb25zdCBvdXRwdXQgb2YgdHJhbnNhY3Rpb24ub3V0cHV0cyB8fCBbXSkge1xuICAgIHRoaXMuYWRkT3V0cHV0KG5ldyBPdXRwdXQob3V0cHV0KSk7XG4gIH1cbiAgaWYgKHRyYW5zYWN0aW9uLmNoYW5nZUluZGV4KSB7XG4gICAgdGhpcy5fY2hhbmdlSW5kZXggPSB0cmFuc2FjdGlvbi5jaGFuZ2VJbmRleDtcbiAgfVxuICBpZiAodHJhbnNhY3Rpb24uY2hhbmdlU2NyaXB0KSB7XG4gICAgdGhpcy5fY2hhbmdlU2NyaXB0ID0gbmV3IFNjcmlwdCh0cmFuc2FjdGlvbi5jaGFuZ2VTY3JpcHQpO1xuICB9XG4gIGlmICh0cmFuc2FjdGlvbi5mZWUpIHtcbiAgICB0aGlzLl9mZWUgPSB0cmFuc2FjdGlvbi5mZWU7XG4gIH1cbiAgdGhpcy5uTG9ja1RpbWUgPSB0cmFuc2FjdGlvbi5uTG9ja1RpbWU7XG4gIHRoaXMudmVyc2lvbiA9IHRyYW5zYWN0aW9uLnZlcnNpb247XG4gIHRoaXMuX2NoZWNrQ29uc2lzdGVuY3koYXJnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2NoZWNrQ29uc2lzdGVuY3kgPSBmdW5jdGlvbihhcmcpIHtcbiAgaWYgKHRoaXMuX2NoYW5nZUluZGV4ICE9IG51bGwpIHtcbiAgICAkLmNoZWNrU3RhdGUodGhpcy5fY2hhbmdlU2NyaXB0LCAnQ2hhbmdlIHNjcmlwdCBpcyBleHBlY3RlZC4nKTtcbiAgICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXRzW3RoaXMuX2NoYW5nZUluZGV4XSwgJ0NoYW5nZSBpbmRleCBwb2ludHMgdG8gdW5kZWZpbmVkIG91dHB1dC4nKTtcbiAgICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXRzW3RoaXMuX2NoYW5nZUluZGV4XS5zY3JpcHQudG9TdHJpbmcoKSA9PT1cbiAgICAgIHRoaXMuX2NoYW5nZVNjcmlwdC50b1N0cmluZygpLCAnQ2hhbmdlIG91dHB1dCBoYXMgYW4gdW5leHBlY3RlZCBzY3JpcHQuJyk7XG4gIH1cbiAgaWYgKGFyZyAmJiBhcmcuaGFzaCkge1xuICAgICQuY2hlY2tTdGF0ZShhcmcuaGFzaCA9PT0gdGhpcy5oYXNoLCAnSGFzaCBpbiBvYmplY3QgZG9lcyBub3QgbWF0Y2ggdHJhbnNhY3Rpb24gaGFzaC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIG5Mb2NrVGltZSBzbyB0aGF0IHRyYW5zYWN0aW9uIGlzIG5vdCB2YWxpZCB1bnRpbCB0aGUgZGVzaXJlZCBkYXRlKGFcbiAqIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIFVOSVggZXBvY2ggaXMgYWxzbyBhY2NlcHRlZClcbiAqXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXJ9IHRpbWVcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5sb2NrVW50aWxEYXRlID0gZnVuY3Rpb24odGltZSkge1xuICAkLmNoZWNrQXJndW1lbnQodGltZSk7XG4gIGlmICghaXNOYU4odGltZSkgJiYgdGltZSA8IFRyYW5zYWN0aW9uLk5MT0NLVElNRV9CTE9DS0hFSUdIVF9MSU1JVCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uTG9ja1RpbWVUb29FYXJseSgpO1xuICB9XG4gIGlmIChfLmlzRGF0ZSh0aW1lKSkge1xuICAgIHRpbWUgPSB0aW1lLmdldFRpbWUoKSAvIDEwMDA7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuaW5wdXRzW2ldLnNlcXVlbmNlTnVtYmVyID09PSBJbnB1dC5ERUZBVUxUX1NFUU5VTUJFUil7XG4gICAgICB0aGlzLmlucHV0c1tpXS5zZXF1ZW5jZU51bWJlciA9IElucHV0LkRFRkFVTFRfTE9DS1RJTUVfU0VRTlVNQkVSO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubkxvY2tUaW1lID0gdGltZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgbkxvY2tUaW1lIHNvIHRoYXQgdHJhbnNhY3Rpb24gaXMgbm90IHZhbGlkIHVudGlsIHRoZSBkZXNpcmVkIGJsb2NrXG4gKiBoZWlnaHQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmxvY2tVbnRpbEJsb2NrSGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICQuY2hlY2tBcmd1bWVudCghaXNOYU4oaGVpZ2h0KSk7XG4gIGlmIChoZWlnaHQgPj0gVHJhbnNhY3Rpb24uTkxPQ0tUSU1FX0JMT0NLSEVJR0hUX0xJTUlUKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5CbG9ja0hlaWdodFRvb0hpZ2goKTtcbiAgfVxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uTkxvY2tUaW1lT3V0T2ZSYW5nZSgpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmlucHV0c1tpXS5zZXF1ZW5jZU51bWJlciA9PT0gSW5wdXQuREVGQVVMVF9TRVFOVU1CRVIpe1xuICAgICAgdGhpcy5pbnB1dHNbaV0uc2VxdWVuY2VOdW1iZXIgPSBJbnB1dC5ERUZBVUxUX0xPQ0tUSU1FX1NFUU5VTUJFUjtcbiAgICB9XG4gIH1cblxuXG4gIHRoaXMubkxvY2tUaW1lID0gaGVpZ2h0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogIFJldHVybnMgYSBzZW1hbnRpYyB2ZXJzaW9uIG9mIHRoZSB0cmFuc2FjdGlvbidzIG5Mb2NrVGltZS5cbiAqICBAcmV0dXJuIHtOdW1iZXJ8RGF0ZX1cbiAqICBJZiBuTG9ja1RpbWUgaXMgMCwgaXQgcmV0dXJucyBudWxsLFxuICogIGlmIGl0IGlzIDwgNTAwMDAwMDAwLCBpdCByZXR1cm5zIGEgYmxvY2sgaGVpZ2h0IChudW1iZXIpXG4gKiAgZWxzZSBpdCByZXR1cm5zIGEgRGF0ZSBvYmplY3QuXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXRMb2NrVGltZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMubkxvY2tUaW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHRoaXMubkxvY2tUaW1lIDwgVHJhbnNhY3Rpb24uTkxPQ0tUSU1FX0JMT0NLSEVJR0hUX0xJTUlUKSB7XG4gICAgcmV0dXJuIHRoaXMubkxvY2tUaW1lO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZSgxMDAwICogdGhpcy5uTG9ja1RpbWUpO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlci5CdWZmZXIuZnJvbShzdHJpbmcsICdoZXgnKSk7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX25ld1RyYW5zYWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudmVyc2lvbiA9IENVUlJFTlRfVkVSU0lPTjtcbiAgdGhpcy5uTG9ja1RpbWUgPSBERUZBVUxUX05MT0NLVElNRTtcbn07XG5cbi8qIFRyYW5zYWN0aW9uIGNyZWF0aW9uIGludGVyZmFjZSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYW5zYWN0aW9ufmZyb21PYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcmV2VHhJZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG91dHB1dEluZGV4XG4gKiBAcHJvcGVydHkgeyhCdWZmZXJ8c3RyaW5nfFNjcmlwdCl9IHNjcmlwdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNhdG9zaGlzXG4gKi9cblxuLyoqXG4gKiBBZGQgYW4gaW5wdXQgdG8gdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBhIGhpZ2ggbGV2ZWwgaW50ZXJmYWNlXG4gKiB0byBhZGQgYW4gaW5wdXQsIGZvciBtb3JlIGNvbnRyb2wsIHVzZSBAe2xpbmsgVHJhbnNhY3Rpb24jYWRkSW5wdXR9LlxuICpcbiAqIENhbiByZWNlaXZlLCBhcyBvdXRwdXQgaW5mb3JtYXRpb24sIHRoZSBvdXRwdXQgb2YgYml0Y29pbmQncyBgbGlzdHVuc3BlbnRgIGNvbW1hbmQsXG4gKiBhbmQgYSBzbGlnaHRseSBmYW5jaWVyIGZvcm1hdCByZWNvZ25pemVkIGJ5IGJpdGNvcmU6XG4gKlxuICogYGBgXG4gKiB7XG4gKiAgYWRkcmVzczogJ21zellxVm5xS29ReDRqY1RkSlh4d0tBaXNzRTNKYnJyYzEnLFxuICogIHR4SWQ6ICdhNDc3YWY2YjI2NjdjMjk2NzA0NjdlNGUwNzI4YjY4NWVlMDdiMjQwMjM1NzcxODYyMzE4ZTI5ZGRiZTU4NDU4JyxcbiAqICBvdXRwdXRJbmRleDogMCxcbiAqICBzY3JpcHQ6IFNjcmlwdC5lbXB0eSgpLFxuICogIHNhdG9zaGlzOiAxMDIwMDAwXG4gKiB9XG4gKiBgYGBcbiAqIFdoZXJlIGBhZGRyZXNzYCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgYml0Y29yZSBBZGRyZXNzIG9iamVjdC4gVGhlXG4gKiBzYW1lIGlzIHRydWUgZm9yIGBzY3JpcHRgLCB3aGljaCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBiaXRjb3JlIFNjcmlwdC5cbiAqXG4gKiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXMgZm9yIGlucHV0cyAoaW4gZnVydGhlciB2ZXJzaW9ucyxcbiAqIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90IGJlIHJlc2V0KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gKlxuICogLy8gRnJvbSBhIHBheSB0byBwdWJsaWMga2V5IGhhc2ggb3V0cHV0IGZyb20gYml0Y29pbmQncyBsaXN0dW5zcGVudFxuICogdHJhbnNhY3Rpb24uZnJvbSh7J3R4aWQnOiAnMDAwMC4uLicsIHZvdXQ6IDAsIGFtb3VudDogMC4xLCBzY3JpcHRQdWJLZXk6ICdPUF9EVVAgLi4uJ30pO1xuICpcbiAqIC8vIEZyb20gYSBwYXkgdG8gcHVibGljIGtleSBoYXNoIG91dHB1dFxuICogdHJhbnNhY3Rpb24uZnJvbSh7J3R4SWQnOiAnMDAwMC4uLicsIG91dHB1dEluZGV4OiAwLCBzYXRvc2hpczogMTAwMCwgc2NyaXB0OiAnT1BfRFVQIC4uLid9KTtcbiAqXG4gKiAvLyBGcm9tIGEgbXVsdGlzaWcgUDJTSCBvdXRwdXRcbiAqIHRyYW5zYWN0aW9uLmZyb20oeyd0eElkJzogJzAwMDAuLi4nLCBpbnB1dEluZGV4OiAwLCBzYXRvc2hpczogMTAwMCwgc2NyaXB0OiAnLi4uIE9QX0hBU0gnfSxcbiAqICAgICAgICAgICAgICAgICAgWycwMzAwMC4uLicsICcwMjAwMC4uLiddLCAyKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7KEFycmF5LjxUcmFuc2FjdGlvbn5mcm9tT2JqZWN0PnxUcmFuc2FjdGlvbn5mcm9tT2JqZWN0KX0gdXR4b1xuICogQHBhcmFtIHtBcnJheT19IHB1YmtleXNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gdGhyZXNob2xkXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdHMgLSBTZXZlcmFsIG9wdGlvbnM6XG4gKiAgICAgICAgLSBub1NvcnRpbmc6IGRlZmF1bHRzIHRvIGZhbHNlLCBpZiB0cnVlIGFuZCBpcyBtdWx0aXNpZywgZG9uJ3RcbiAqICAgICAgICAgICAgICAgICAgICAgIHNvcnQgdGhlIGdpdmVuIHB1YmxpYyBrZXlzIGJlZm9yZSBjcmVhdGluZyB0aGUgc2NyaXB0XG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mcm9tID0gZnVuY3Rpb24odXR4bywgcHVia2V5cywgdGhyZXNob2xkLCBvcHRzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHV0eG8pKSB7XG4gICAgZm9yKGNvbnN0IHUgb2YgdXR4bykge1xuICAgICAgdGhpcy5mcm9tKHUsIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb25zdCBleGlzdHMgPSB0aGlzLmlucHV0cy5zb21lKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgLy8gVE9ETzogTWF5YmUgcHJldlR4SWQgc2hvdWxkIGJlIGEgc3RyaW5nPyBPciBkZWZpbmVkIGFzIHJlYWQgb25seSBwcm9wZXJ0eT9cbiAgICByZXR1cm4gaW5wdXQucHJldlR4SWQudG9TdHJpbmcoJ2hleCcpID09PSB1dHhvLnR4SWQgJiYgaW5wdXQub3V0cHV0SW5kZXggPT09IHV0eG8ub3V0cHV0SW5kZXg7XG4gIH0pO1xuICBpZiAoZXhpc3RzKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHB1YmtleXMgJiYgdGhyZXNob2xkKSB7XG4gICAgdGhpcy5fZnJvbU11bHRpc2lnVXR4byh1dHhvLCBwdWJrZXlzLCB0aHJlc2hvbGQsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2Zyb21Ob25QMlNIKHV0eG8sIG9wdHMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBhc3NvY2lhdGVJbnB1dHMgLSBVcGRhdGUgaW5wdXRzIHdpdGggdXR4b3MsIGFsbG93aW5nIHlvdSB0byBzcGVjaWZ5IHZhbHVlLCBhbmQgcHVia2V5LlxuICogUG9wdWxhdGluZyB0aGVzZSBpbnB1dHMgYWxsb3dzIGZvciB0aGVtIHRvIGJlIHNpZ25lZCB3aXRoIC5zaWduKHByaXZLZXlzKVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gdXR4b3NcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nIHwgUHVibGljS2V5Pn0gcHVia2V5c1xuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fVxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuYXNzb2NpYXRlSW5wdXRzID0gZnVuY3Rpb24odXR4b3MsIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyA9IHt9KSB7XG4gIGxldCBpbmRleGVzID0gW107XG4gIGZvcihsZXQgdXR4byBvZiB1dHhvcykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbnB1dHMuZmluZEluZGV4KGkgPT4gaS5wcmV2VHhJZC50b1N0cmluZygnaGV4JykgPT09IHV0eG8udHhJZCAmJiBpLm91dHB1dEluZGV4ID09PSB1dHhvLm91dHB1dEluZGV4KTtcbiAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIGlmKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gdGhpcy5pbnB1dHNbaW5kZXhdLnNlcXVlbmNlTnVtYmVyOyAvLyBwcmVzZXJ2ZSB0aGUgc2V0IHNlcXVlbmNlIG51bWJlclxuICAgICAgdGhpcy5pbnB1dHNbaW5kZXhdID0gdGhpcy5fZ2V0SW5wdXRGcm9tKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyk7XG4gICAgICB0aGlzLmlucHV0c1tpbmRleF0uc2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4ZXM7XG59XG5cblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9zZWxlY3RJbnB1dFR5cGUgPSBmdW5jdGlvbih1dHhvLCBwdWJrZXlzLCB0aHJlc2hvbGQpIHtcbiAgdmFyIGNsYXp6O1xuICB1dHhvID0gbmV3IFVuc3BlbnRPdXRwdXQodXR4byk7XG4gIGlmKHB1YmtleXMgJiYgdGhyZXNob2xkKSB7XG4gICAgaWYgKHV0eG8uc2NyaXB0LmlzTXVsdGlzaWdPdXQoKSkge1xuICAgICAgY2xhenogPSBNdWx0aVNpZ0lucHV0O1xuICAgIH0gZWxzZSBpZiAodXR4by5zY3JpcHQuaXNTY3JpcHRIYXNoT3V0KCkgfHwgdXR4by5zY3JpcHQuaXNXaXRuZXNzU2NyaXB0SGFzaE91dCgpKSB7XG4gICAgICBjbGF6eiA9IE11bHRpU2lnU2NyaXB0SGFzaElucHV0O1xuICAgIH1cbiAgfSBlbHNlIGlmICh1dHhvLnNjcmlwdC5pc1B1YmxpY0tleUhhc2hPdXQoKSB8fCB1dHhvLnNjcmlwdC5pc1dpdG5lc3NQdWJsaWNLZXlIYXNoT3V0KCkgfHwgdXR4by5zY3JpcHQuaXNTY3JpcHRIYXNoT3V0KCkpIHtcbiAgICBjbGF6eiA9IFB1YmxpY0tleUhhc2hJbnB1dDtcbiAgfSBlbHNlIGlmICh1dHhvLnNjcmlwdC5pc1RhcHJvb3QoKSkge1xuICAgIGNsYXp6ID0gVGFwcm9vdElucHV0O1xuICB9IGVsc2UgaWYgKHV0eG8uc2NyaXB0LmlzUHVibGljS2V5T3V0KCkpIHtcbiAgICBjbGF6eiA9IFB1YmxpY0tleUlucHV0O1xuICB9IGVsc2Uge1xuICAgIGNsYXp6ID0gSW5wdXQ7XG4gIH1cbiAgcmV0dXJuIGNsYXp6O1xufVxuXG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZ2V0SW5wdXRGcm9tID0gZnVuY3Rpb24odXR4bywgcHVia2V5cywgdGhyZXNob2xkLCBvcHRzID0ge30pIHtcbiAgdXR4byA9IG5ldyBVbnNwZW50T3V0cHV0KHV0eG8pO1xuICBjb25zdCBJbnB1dENsYXNzID0gdGhpcy5fc2VsZWN0SW5wdXRUeXBlKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCk7XG4gIGNvbnN0IGlucHV0ID0ge1xuICAgIG91dHB1dDogbmV3IE91dHB1dCh7XG4gICAgICBzY3JpcHQ6IHV0eG8uc2NyaXB0LFxuICAgICAgc2F0b3NoaXM6IHV0eG8uc2F0b3NoaXNcbiAgICB9KSxcbiAgICBwcmV2VHhJZDogdXR4by50eElkLFxuICAgIG91dHB1dEluZGV4OiB1dHhvLm91dHB1dEluZGV4LFxuICAgIHNlcXVlbmNlTnVtYmVyOiBvcHRzLnNlcXVlbmNlTnVtYmVyLFxuICAgIHNjcmlwdDogU2NyaXB0LmVtcHR5KClcbiAgfTtcbiAgbGV0IGFyZ3MgPSBwdWJrZXlzICYmIHRocmVzaG9sZCA/IFtwdWJrZXlzLCB0aHJlc2hvbGQsIGZhbHNlLCBvcHRzXSA6IFtdXG4gIHJldHVybiBuZXcgSW5wdXRDbGFzcyhpbnB1dCwgLi4uYXJncyk7XG59XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZnJvbU5vblAyU0ggPSBmdW5jdGlvbih1dHhvLCBvcHRzKSB7XG4gIGNvbnN0IGlucHV0ID0gdGhpcy5fZ2V0SW5wdXRGcm9tKHV0eG8sIG51bGwsIG51bGwsIG9wdHMpO1xuICB0aGlzLmFkZElucHV0KGlucHV0KTtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZnJvbU11bHRpc2lnVXR4byA9IGZ1bmN0aW9uKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cykge1xuICAkLmNoZWNrQXJndW1lbnQodGhyZXNob2xkIDw9IHB1YmtleXMubGVuZ3RoLFxuICAgICdOdW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHB1YmxpYyBrZXlzJyk7XG4gIGNvbnN0IGlucHV0ID0gdGhpcy5fZ2V0SW5wdXRGcm9tKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyk7XG4gIHRoaXMuYWRkSW5wdXQoaW5wdXQpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gaW5wdXQgdG8gdGhpcyB0cmFuc2FjdGlvbi4gVGhlIGlucHV0IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgdGhlIGBJbnB1dGAgY2xhc3MuXG4gKiBJdCBzaG91bGQgaGF2ZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgT3V0cHV0IHRoYXQgaXQncyBzcGVuZGluZywgYnV0IGlmIGl0J3Mgbm90IGFscmVhZHlcbiAqIHNldCwgdHdvIGFkZGl0aW9uYWwgcGFyYW1ldGVycywgYG91dHB1dFNjcmlwdGAgYW5kIGBzYXRvc2hpc2AgY2FuIGJlIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSB7SW5wdXR9IGlucHV0XG4gKiBAcGFyYW0ge1N0cmluZ3xTY3JpcHR9IG91dHB1dFNjcmlwdFxuICogQHBhcmFtIHtudW1iZXJ9IHNhdG9zaGlzXG4gKiBAcmV0dXJuIFRyYW5zYWN0aW9uIHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuYWRkSW5wdXQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0U2NyaXB0LCBzYXRvc2hpcykge1xuICAkLmNoZWNrQXJndW1lbnRUeXBlKGlucHV0LCBJbnB1dCwgJ2lucHV0Jyk7XG4gIGlmICghaW5wdXQub3V0cHV0ICYmIChvdXRwdXRTY3JpcHQgPT0gbnVsbCB8fCBzYXRvc2hpcyA9PSBudWxsKSkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uTmVlZE1vcmVJbmZvKCdOZWVkIGluZm9ybWF0aW9uIGFib3V0IHRoZSBVVFhPIHNjcmlwdCBhbmQgc2F0b3NoaXMnKTtcbiAgfVxuICBpZiAoIWlucHV0Lm91dHB1dCAmJiBvdXRwdXRTY3JpcHQgJiYgc2F0b3NoaXMgIT0gbnVsbCkge1xuICAgIG91dHB1dFNjcmlwdCA9IG91dHB1dFNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCA/IG91dHB1dFNjcmlwdCA6IG5ldyBTY3JpcHQob3V0cHV0U2NyaXB0KTtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKHNhdG9zaGlzLCAnbnVtYmVyJywgJ3NhdG9zaGlzJyk7XG4gICAgaW5wdXQub3V0cHV0ID0gbmV3IE91dHB1dCh7XG4gICAgICBzY3JpcHQ6IG91dHB1dFNjcmlwdCxcbiAgICAgIHNhdG9zaGlzOiBzYXRvc2hpc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLnVuY2hlY2tlZEFkZElucHV0KGlucHV0KTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGlucHV0IHRvIHRoaXMgdHJhbnNhY3Rpb24sIHdpdGhvdXQgY2hlY2tpbmcgdGhhdCB0aGUgaW5wdXQgaGFzIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgb3V0cHV0IHRoYXQgaXQncyBzcGVuZGluZy5cbiAqXG4gKiBAcGFyYW0ge0lucHV0fSBpbnB1dFxuICogQHJldHVybiBUcmFuc2FjdGlvbiB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnVuY2hlY2tlZEFkZElucHV0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgJC5jaGVja0FyZ3VtZW50VHlwZShpbnB1dCwgSW5wdXQsICdpbnB1dCcpO1xuICB0aGlzLmlucHV0cy5wdXNoKGlucHV0KTtcbiAgdGhpcy5faW5wdXRBbW91bnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3VwZGF0ZUNoYW5nZU91dHB1dCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgZW5vdWdoIGluZm8gb24gYWxsIGlucHV0cyB0byBiZSBjb3JyZWN0bHkgdmFsaWRhdGVkXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmhhc0FsbFV0eG9JbmZvID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlucHV0cy5ldmVyeShmdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiAhIWlucHV0Lm91dHB1dDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIE1hbnVhbGx5IHNldCB0aGUgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXNcbiAqIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90XG4gKiBiZSByZXNldCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBzYXRvc2hpcyB0byBiZSBzZW50XG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mZWUgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgJC5jaGVja0FyZ3VtZW50KCFpc05hTihhbW91bnQpLCAnYW1vdW50IG11c3QgYmUgYSBudW1iZXInKTtcbiAgdGhpcy5fZmVlID0gYW1vdW50O1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1hbnVhbGx5IHNldCB0aGUgZmVlIHBlciBLQiBmb3IgdGhpcyB0cmFuc2FjdGlvbi4gQmV3YXJlIHRoYXQgdGhpcyByZXNldHMgYWxsIHRoZSBzaWduYXR1cmVzXG4gKiBmb3IgaW5wdXRzIChpbiBmdXJ0aGVyIHZlcnNpb25zLCBTSUdIQVNIX1NJTkdMRSBvciBTSUdIQVNIX05PTkUgc2lnbmF0dXJlcyB3aWxsIG5vdFxuICogYmUgcmVzZXQpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgc2F0b3NoaXMgcGVyIEtCIHRvIGJlIHNlbnRcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZlZVBlcktiID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICQuY2hlY2tBcmd1bWVudCghaXNOYU4oYW1vdW50KSwgJ2Ftb3VudCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIHRoaXMuX2ZlZVBlcktiID0gYW1vdW50O1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1hbnVhbGx5IHNldCB0aGUgZmVlIHBlciBCeXRlIGZvciB0aGlzIHRyYW5zYWN0aW9uLiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXNcbiAqIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90XG4gKiBiZSByZXNldCkuXG4gKiBmZWUgcGVyIEJ5dGUgd2lsbCBiZSBpZ25vcmVkIGlmIGZlZSBwZXIgS0IgaXMgc2V0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBzYXRvc2hpcyBwZXIgQnl0ZSB0byBiZSBzZW50XG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mZWVQZXJCeXRlID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAkLmNoZWNrQXJndW1lbnQoIWlzTmFOKGFtb3VudCksICdhbW91bnQgbXVzdCBiZSBhIG51bWJlcicpO1xuICB0aGlzLl9mZWVQZXJCeXRlID0gYW1vdW50O1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiBPdXRwdXQgbWFuYWdlbWVudCAqL1xuXG4vKipcbiAqIFNldCB0aGUgY2hhbmdlIGFkZHJlc3MgZm9yIHRoaXMgdHJhbnNhY3Rpb25cbiAqXG4gKiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXMgZm9yIGlucHV0cyAoaW4gZnVydGhlciB2ZXJzaW9ucyxcbiAqIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90IGJlIHJlc2V0KS5cbiAqXG4gKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHJlc3MgQW4gYWRkcmVzcyBmb3IgY2hhbmdlIHRvIGJlIHNlbnQgdG8uXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbihhZGRyZXNzKSB7XG4gICQuY2hlY2tBcmd1bWVudChhZGRyZXNzLCAnYWRkcmVzcyBpcyByZXF1aXJlZCcpO1xuICB0aGlzLl9jaGFuZ2VTY3JpcHQgPSBTY3JpcHQuZnJvbUFkZHJlc3MoYWRkcmVzcyk7XG4gIHRoaXMuX3VwZGF0ZUNoYW5nZU91dHB1dCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtPdXRwdXR9IGNoYW5nZSBvdXRwdXQsIGlmIGl0IGV4aXN0c1xuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0Q2hhbmdlT3V0cHV0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9jaGFuZ2VJbmRleCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0c1t0aGlzLl9jaGFuZ2VJbmRleF07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYW5zYWN0aW9ufnRvT2JqZWN0XG4gKiBAcHJvcGVydHkgeyhzdHJpbmd8QWRkcmVzcyl9IGFkZHJlc3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzYXRvc2hpc1xuICovXG5cbi8qKlxuICogQWRkIGFuIG91dHB1dCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogQmV3YXJlIHRoYXQgdGhpcyByZXNldHMgYWxsIHRoZSBzaWduYXR1cmVzIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsXG4gKiBTSUdIQVNIX1NJTkdMRSBvciBTSUdIQVNIX05PTkUgc2lnbmF0dXJlcyB3aWxsIG5vdCBiZSByZXNldCkuXG4gKlxuICogQHBhcmFtIHsoc3RyaW5nfEFkZHJlc3N8QXJyYXkuPFRyYW5zYWN0aW9ufnRvT2JqZWN0Pil9IGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgaW4gc2F0b3NoaXNcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24oYWRkcmVzcywgYW1vdW50KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFkZHJlc3MpKSB7XG4gICAgZm9yIChjb25zdCB0byBvZiBhZGRyZXNzKSB7XG4gICAgICB0aGlzLnRvKHRvLmFkZHJlc3MsIHRvLnNhdG9zaGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAkLmNoZWNrQXJndW1lbnQoXG4gICAgSlNVdGlsLmlzTmF0dXJhbE51bWJlcihhbW91bnQpLFxuICAgICdBbW91bnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICApO1xuICB0aGlzLmFkZE91dHB1dChuZXcgT3V0cHV0KHtcbiAgICBzY3JpcHQ6IFNjcmlwdChuZXcgQWRkcmVzcyhhZGRyZXNzKSksXG4gICAgc2F0b3NoaXM6IGFtb3VudFxuICB9KSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gT1BfUkVUVVJOIG91dHB1dCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogQmV3YXJlIHRoYXQgdGhpcyByZXNldHMgYWxsIHRoZSBzaWduYXR1cmVzIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsXG4gKiBTSUdIQVNIX1NJTkdMRSBvciBTSUdIQVNIX05PTkUgc2lnbmF0dXJlcyB3aWxsIG5vdCBiZSByZXNldCkuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSB2YWx1ZSB0aGUgZGF0YSB0byBiZSBzdG9yZWQgaW4gdGhlIE9QX1JFVFVSTiBvdXRwdXQuXG4gKiAgICBJbiBjYXNlIG9mIGEgc3RyaW5nLCB0aGUgVVRGLTggcmVwcmVzZW50YXRpb24gd2lsbCBiZSBzdG9yZWRcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFkZERhdGEgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLmFkZE91dHB1dChuZXcgT3V0cHV0KHtcbiAgICBzY3JpcHQ6IFNjcmlwdC5idWlsZERhdGFPdXQodmFsdWUpLFxuICAgIHNhdG9zaGlzOiAwXG4gIH0pKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQWRkIGFuIG91dHB1dCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPdXRwdXR9IG91dHB1dCB0aGUgb3V0cHV0IHRvIGFkZC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFkZE91dHB1dCA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAkLmNoZWNrQXJndW1lbnRUeXBlKG91dHB1dCwgT3V0cHV0LCAnb3V0cHV0Jyk7XG4gIHRoaXMuX2FkZE91dHB1dChvdXRwdXQpO1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFsbCBvdXRwdXRzIGZyb20gdGhlIHRyYW5zYWN0aW9uLlxuICpcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmNsZWFyT3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgdGhpcy5fY2xlYXJTaWduYXR1cmVzKCk7XG4gIHRoaXMuX291dHB1dEFtb3VudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fY2hhbmdlSW5kZXggPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3VwZGF0ZUNoYW5nZU91dHB1dCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9hZGRPdXRwdXQgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgdGhpcy5vdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgdGhpcy5fb3V0cHV0QW1vdW50ID0gdW5kZWZpbmVkO1xufTtcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgb3IgZ2V0cyB0aGUgdG90YWwgb3V0cHV0IGFtb3VudCBpbiBzYXRvc2hpc1xuICpcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIHRyYW5zYWN0aW9uIHRvdGFsIG91dHB1dCBhbW91bnRcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9nZXRPdXRwdXRBbW91bnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX291dHB1dEFtb3VudCA9PSBudWxsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX291dHB1dEFtb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBvdXRwdXQgb2YgdGhpcy5vdXRwdXRzIHx8IFtdKSB7XG4gICAgICBzZWxmLl9vdXRwdXRBbW91bnQgKz0gb3V0cHV0LnNhdG9zaGlzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5fb3V0cHV0QW1vdW50O1xufTtcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgb3IgZ2V0cyB0aGUgdG90YWwgaW5wdXQgYW1vdW50IGluIHNhdG9zaGlzXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgdHJhbnNhY3Rpb24gdG90YWwgaW5wdXQgYW1vdW50XG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZ2V0SW5wdXRBbW91bnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2lucHV0QW1vdW50ID09IG51bGwpIHtcbiAgICB0aGlzLl9pbnB1dEFtb3VudCA9IF8uc3VtQnkodGhpcy5pbnB1dHMsIGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQub3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5JbnB1dC5NaXNzaW5nUHJldmlvdXNPdXRwdXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dC5vdXRwdXQuc2F0b3NoaXM7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2lucHV0QW1vdW50O1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl91cGRhdGVDaGFuZ2VPdXRwdXQgPSBmdW5jdGlvbihub0NsZWFyU2lncykge1xuICBpZiAoIXRoaXMuX2NoYW5nZVNjcmlwdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIW5vQ2xlYXJTaWdzKSB7XG4gICAgdGhpcy5fY2xlYXJTaWduYXR1cmVzKCk7XG4gIH1cbiAgaWYgKHRoaXMuX2NoYW5nZUluZGV4ICE9IG51bGwpIHtcbiAgICB0aGlzLl9yZW1vdmVPdXRwdXQodGhpcy5fY2hhbmdlSW5kZXgpO1xuICB9XG4gIHZhciBhdmFpbGFibGUgPSB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcbiAgdmFyIGZlZSA9IHRoaXMuZ2V0RmVlKCk7XG4gIHZhciBjaGFuZ2VBbW91bnQgPSBhdmFpbGFibGUgLSBmZWU7XG4gIGlmIChjaGFuZ2VBbW91bnQgPiBUcmFuc2FjdGlvbi5EVVNUX0FNT1VOVCkge1xuICAgIHRoaXMuX2NoYW5nZUluZGV4ID0gdGhpcy5vdXRwdXRzLmxlbmd0aDtcbiAgICB0aGlzLl9hZGRPdXRwdXQobmV3IE91dHB1dCh7XG4gICAgICBzY3JpcHQ6IHRoaXMuX2NoYW5nZVNjcmlwdCxcbiAgICAgIHNhdG9zaGlzOiBjaGFuZ2VBbW91bnRcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY2hhbmdlSW5kZXggPSB1bmRlZmluZWQ7XG4gIH1cbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGZlZSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogSWYgdGhlcmUncyBhIGZpeGVkIGZlZSBzZXQsIHJldHVybiB0aGF0LlxuICpcbiAqIElmIHRoZXJlIGlzIG5vIGNoYW5nZSBvdXRwdXQgc2V0LCB0aGUgZmVlIGlzIHRoZVxuICogdG90YWwgdmFsdWUgb2YgdGhlIG91dHB1dHMgbWludXMgaW5wdXRzLiBOb3RlIHRoYXRcbiAqIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvbmx5IHNwZWNpZmllcyB0aGUgdmFsdWVcbiAqIG9mIGl0cyBvdXRwdXRzLiAoVGhlIHZhbHVlIG9mIGlucHV0cyBhcmUgcmVjb3JkZWRcbiAqIGluIHRoZSBwcmV2aW91cyB0cmFuc2FjdGlvbiBvdXRwdXRzIGJlaW5nIHNwZW50LilcbiAqIFRoaXMgbWV0aG9kIHRoZXJlZm9yZSByYWlzZXMgYSBcIk1pc3NpbmdQcmV2aW91c091dHB1dFwiXG4gKiBlcnJvciB3aGVuIGNhbGxlZCBvbiBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKlxuICogSWYgdGhlcmUncyBubyBmZWUgc2V0IGFuZCBubyBjaGFuZ2UgYWRkcmVzcyxcbiAqIGVzdGltYXRlIHRoZSBmZWUgYmFzZWQgb24gc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGZlZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGluIHNhdG9zaGlzXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXRGZWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNDb2luYmFzZSgpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRoaXMuX2ZlZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZlZTtcbiAgfVxuICAvLyBpZiBubyBjaGFuZ2Ugb3V0cHV0IGlzIHNldCwgZmVlcyBzaG91bGQgZXF1YWwgYWxsIHRoZSB1bnNwZW50IGFtb3VudFxuICBpZiAoIXRoaXMuX2NoYW5nZVNjcmlwdCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXN0aW1hdGVGZWUoKTtcbn07XG5cbi8qKlxuICogRXN0aW1hdGVzIGZlZSBmcm9tIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gc2l6ZSBpbiBieXRlcy5cbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9lc3RpbWF0ZUZlZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IHRoaXMuX2VzdGltYXRlU2l6ZSgpO1xuICBjb25zdCBhdmFpbGFibGUgPSB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcbiAgY29uc3QgZmVlUmF0ZSA9IHRoaXMuX2ZlZVBlckJ5dGUgfHwgKHRoaXMuX2ZlZVBlcktiIHx8IFRyYW5zYWN0aW9uLkZFRV9QRVJfS0IpIC8gMTAwMDtcbiAgZnVuY3Rpb24gZ2V0RmVlKHNpemUpIHtcbiAgICByZXR1cm4gc2l6ZSAqIGZlZVJhdGU7XG4gIH1cbiAgY29uc3QgZmVlID0gTWF0aC5jZWlsKGdldEZlZShlc3RpbWF0ZWRTaXplKSk7XG4gIGNvbnN0IGZlZVdpdGhDaGFuZ2UgPSBNYXRoLmNlaWwoZ2V0RmVlKGVzdGltYXRlZFNpemUpICsgZ2V0RmVlKHRoaXMuX2VzdGltYXRlU2l6ZU9mQ2hhbmdlT3V0cHV0KCkpKTtcbiAgaWYgKCF0aGlzLl9jaGFuZ2VTY3JpcHQgfHwgYXZhaWxhYmxlIDw9IGZlZVdpdGhDaGFuZ2UpIHtcbiAgICByZXR1cm4gZmVlO1xuICB9XG4gIHJldHVybiBmZWVXaXRoQ2hhbmdlO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9lc3RpbWF0ZVNpemVPZkNoYW5nZU91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9jaGFuZ2VTY3JpcHQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBzY3JpcHRMZW4gPSB0aGlzLl9jaGFuZ2VTY3JpcHQudG9CdWZmZXIoKS5sZW5ndGg7XG4gIC8vIDggYnl0ZXMgZm9yIHNhdG9zaGlzICsgc2NyaXB0IHNpemUgKyBhY3R1YWwgc2NyaXB0IHNpemVcbiAgcmV0dXJuIDggKyBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKHNjcmlwdExlbikubGVuZ3RoICsgc2NyaXB0TGVuO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9nZXRVbnNwZW50VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2dldElucHV0QW1vdW50KCkgLSB0aGlzLl9nZXRPdXRwdXRBbW91bnQoKTtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dHMgfHwgW10pIHtcbiAgICBpbnB1dC5jbGVhclNpZ25hdHVyZXMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgdHggc2l6ZSBiZWZvcmUgaW5wdXQgc2lnbmF0dXJlcyBhcmUgYWRkZWQuXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIGxldCByZXN1bHQgPSA0OyAvLyB2ZXJzaW9uXG5cbiAgaWYgKHRoaXMuaGFzV2l0bmVzc2VzKCkpIHtcbiAgICByZXN1bHQgKz0gLjU7XG4gIH1cblxuICByZXN1bHQgKz0gQnVmZmVyV3JpdGVyLnZhcmludEJ1Zk51bSh0aGlzLmlucHV0cy5sZW5ndGgpLmxlbmd0aDtcbiAgZm9yIChjb25zdCBpbnB1dCBvZiB0aGlzLmlucHV0cyB8fCBbXSkge1xuICAgIHJlc3VsdCArPSBpbnB1dC5fZXN0aW1hdGVTaXplKCk7XG4gIH1cblxuICByZXN1bHQgKz0gQnVmZmVyV3JpdGVyLnZhcmludEJ1Zk51bSh0aGlzLm91dHB1dHMubGVuZ3RoKS5sZW5ndGg7XG4gIGZvciAoY29uc3Qgb3V0cHV0IG9mIHRoaXMub3V0cHV0cyB8fCBbXSkge1xuICAgIHJlc3VsdCArPSBvdXRwdXQuY2FsY3VsYXRlU2l6ZSgpO1xuICB9XG5cbiAgcmVzdWx0ICs9IDQ7IC8vIG5Mb2NrVGltZVxuICByZXR1cm4gTWF0aC5jZWlsKHJlc3VsdCk7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2NhbGN1bGF0ZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS5sZW5ndGg7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2NhbGN1bGF0ZVZTaXplID0gZnVuY3Rpb24obm9Sb3VuZCkge1xuICBjb25zdCB2c2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZVdlaWdodCgpIC8gNDtcbiAgcmV0dXJuIG5vUm91bmQgPyB2c2l6ZSA6IE1hdGguY2VpbCh2c2l6ZSk7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2NhbGN1bGF0ZVdlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMudG9CdWZmZXIodHJ1ZSkubGVuZ3RoICogMykgKyB0aGlzLnRvQnVmZmVyKGZhbHNlKS5sZW5ndGg7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX3JlbW92ZU91dHB1dCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaW5kZXhdO1xuICB0aGlzLm91dHB1dHMgPSBfLndpdGhvdXQodGhpcy5vdXRwdXRzLCBvdXRwdXQpO1xuICB0aGlzLl9vdXRwdXRBbW91bnQgPSB1bmRlZmluZWQ7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUucmVtb3ZlT3V0cHV0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdGhpcy5fcmVtb3ZlT3V0cHV0KGluZGV4KTtcbiAgdGhpcy5fdXBkYXRlQ2hhbmdlT3V0cHV0KCk7XG59O1xuXG4vKipcbiAqIFNvcnQgYSB0cmFuc2FjdGlvbidzIGlucHV0cyBhbmQgb3V0cHV0cyBhY2NvcmRpbmcgdG8gQklQNjlcbiAqXG4gKiBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY5Lm1lZGlhd2lraX1cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc29ydElucHV0cyhmdW5jdGlvbihpbnB1dHMpIHtcbiAgICB2YXIgY29weSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGlucHV0cyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvcHkuZm9yRWFjaCgoeCkgPT4geyB4LmkgPSBpKyt9KTtcbiAgICBjb3B5LnNvcnQoZnVuY3Rpb24oZmlyc3QsIHNlY29uZCkge1xuICAgICByZXR1cm4gY29tcGFyZShmaXJzdC5wcmV2VHhJZCwgc2Vjb25kLnByZXZUeElkKVxuICAgICAgICB8fCBmaXJzdC5vdXRwdXRJbmRleCAtIHNlY29uZC5vdXRwdXRJbmRleFxuICAgICAgICB8fCBmaXJzdC5pIC0gc2Vjb25kLmk7ICAvLyB0byBlbnN1cmUgc3RhYmxlIHNvcnRcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbiAgfSk7XG4gIHRoaXMuc29ydE91dHB1dHMoZnVuY3Rpb24ob3V0cHV0cykge1xuICAgIHZhciBjb3B5ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgb3V0cHV0cyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvcHkuZm9yRWFjaCgoeCkgPT4geyB4LmkgPSBpKyt9KTtcbiAgICBjb3B5LnNvcnQoZnVuY3Rpb24oZmlyc3QsIHNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0LnNhdG9zaGlzIC0gc2Vjb25kLnNhdG9zaGlzXG4gICAgICAgIHx8IGNvbXBhcmUoZmlyc3Quc2NyaXB0LnRvQnVmZmVyKCksIHNlY29uZC5zY3JpcHQudG9CdWZmZXIoKSlcbiAgICAgICAgfHwgZmlyc3QuaSAtIHNlY29uZC5pOyAgLy8gdG8gZW5zdXJlIHN0YWJsZSBzb3J0XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmFuZG9taXplIHRoaXMgdHJhbnNhY3Rpb24ncyBvdXRwdXRzIG9yZGVyaW5nLiBUaGUgc2h1ZmZsaW5nIGFsZ29yaXRobSBpcyBhXG4gKiB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXMgc2h1ZmZsZSwgcHJvdmlkZWQgYnkgbG9kYXNoJ3MgXy5zaHVmZmxlKCkuXG4gKlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNodWZmbGVPdXRwdXRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNvcnRPdXRwdXRzKF8uc2h1ZmZsZSk7XG59O1xuXG4vKipcbiAqIFNvcnQgdGhpcyB0cmFuc2FjdGlvbidzIG91dHB1dHMsIGFjY29yZGluZyB0byBhIGdpdmVuIHNvcnRpbmcgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4gYXJyYXkgYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYSBuZXcgYXJyYXksIHdpdGggdGhlIHNhbWUgZWxlbWVudHNcbiAqIGJ1dCB3aXRoIGEgZGlmZmVyZW50IG9yZGVyLiBUaGUgYXJndW1lbnQgZnVuY3Rpb24gTVVTVCBOT1QgbW9kaWZ5IHRoZSBvcmRlclxuICogb2YgdGhlIG9yaWdpbmFsIGFycmF5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydGluZ0Z1bmN0aW9uXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpc1xuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuc29ydE91dHB1dHMgPSBmdW5jdGlvbihzb3J0aW5nRnVuY3Rpb24pIHtcbiAgdmFyIG91dHMgPSBzb3J0aW5nRnVuY3Rpb24odGhpcy5vdXRwdXRzKTtcbiAgcmV0dXJuIHRoaXMuX25ld091dHB1dE9yZGVyKG91dHMpO1xufTtcblxuLyoqXG4gKiBTb3J0IHRoaXMgdHJhbnNhY3Rpb24ncyBpbnB1dHMsIGFjY29yZGluZyB0byBhIGdpdmVuIHNvcnRpbmcgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4gYXJyYXkgYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYSBuZXcgYXJyYXksIHdpdGggdGhlIHNhbWUgZWxlbWVudHNcbiAqIGJ1dCB3aXRoIGEgZGlmZmVyZW50IG9yZGVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRpbmdGdW5jdGlvblxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNvcnRJbnB1dHMgPSBmdW5jdGlvbihzb3J0aW5nRnVuY3Rpb24pIHtcbiAgdGhpcy5pbnB1dHMgPSBzb3J0aW5nRnVuY3Rpb24odGhpcy5pbnB1dHMpO1xuICB0aGlzLl9jbGVhclNpZ25hdHVyZXMoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX25ld091dHB1dE9yZGVyID0gZnVuY3Rpb24obmV3T3V0cHV0cykge1xuICB2YXIgaXNJbnZhbGlkU29ydGluZyA9ICh0aGlzLm91dHB1dHMubGVuZ3RoICE9PSBuZXdPdXRwdXRzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBfLmRpZmZlcmVuY2UodGhpcy5vdXRwdXRzLCBuZXdPdXRwdXRzKS5sZW5ndGggIT09IDApO1xuICBpZiAoaXNJbnZhbGlkU29ydGluZykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW52YWxpZFNvcnRpbmcoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9jaGFuZ2VJbmRleCAhPSBudWxsKSB7XG4gICAgdmFyIGNoYW5nZU91dHB1dCA9IHRoaXMub3V0cHV0c1t0aGlzLl9jaGFuZ2VJbmRleF07XG4gICAgdGhpcy5fY2hhbmdlSW5kZXggPSBuZXdPdXRwdXRzLmluZGV4T2YoY2hhbmdlT3V0cHV0KTtcbiAgfVxuXG4gIHRoaXMub3V0cHV0cyA9IG5ld091dHB1dHM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlbW92ZUlucHV0ID0gZnVuY3Rpb24odHhJZCwgb3V0cHV0SW5kZXgpIHtcbiAgdmFyIGluZGV4O1xuICBpZiAoIW91dHB1dEluZGV4ICYmICFpc05hTih0eElkKSkge1xuICAgIGluZGV4ID0gdHhJZDtcbiAgfSBlbHNlIHtcbiAgICBpbmRleCA9IHRoaXMuaW5wdXRzLmZpbmRJbmRleChmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0LnByZXZUeElkLnRvU3RyaW5nKCdoZXgnKSA9PT0gdHhJZCAmJiBpbnB1dC5vdXRwdXRJbmRleCA9PT0gb3V0cHV0SW5kZXg7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkludmFsaWRJbmRleChpbmRleCwgdGhpcy5pbnB1dHMubGVuZ3RoKTtcbiAgfVxuICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpbmRleF07XG4gIHRoaXMuaW5wdXRzID0gXy53aXRob3V0KHRoaXMuaW5wdXRzLCBpbnB1dCk7XG4gIHRoaXMuX2lucHV0QW1vdW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbn07XG5cbi8qIFNpZ25hdHVyZSBoYW5kbGluZyAqL1xuXG4vKipcbiAqIFNpZ24gdGhlIHRyYW5zYWN0aW9uIHVzaW5nIG9uZSBvciBtb3JlIHByaXZhdGUga2V5cy5cbiAqXG4gKiBJdCB0cmllcyB0byBzaWduIGVhY2ggaW5wdXQsIHZlcmlmeWluZyB0aGF0IHRoZSBzaWduYXR1cmUgd2lsbCBiZSB2YWxpZFxuICogKG1hdGNoZXMgYSBwdWJsaWMga2V5KS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xQcml2YXRlS2V5fSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25pbmdNZXRob2QgLSBtZXRob2QgdXNlZCB0byBzaWduIC0gJ2VjZHNhJyBvciAnc2Nobm9ycidcbiAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gbWVya2xlUm9vdCAtIG1lcmtsZSByb290IGZvciB0YXByb290IHNpZ25pbmdcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbihwcml2YXRlS2V5LCBzaWd0eXBlLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLmhhc0FsbFV0eG9JbmZvKCksICdOb3QgYWxsIHV0eG8gaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uLicpO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcml2YXRlS2V5KSkge1xuICAgIGZvciAoY29uc3QgcGsgb2YgcHJpdmF0ZUtleSkge1xuICAgICAgdGhpcy5zaWduKHBrLCBzaWd0eXBlLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZm9yIChjb25zdCBzaWduYXR1cmUgb2YgdGhpcy5nZXRTaWduYXR1cmVzKHByaXZhdGVLZXksIHNpZ3R5cGUsIHNpZ25pbmdNZXRob2QsIG1lcmtsZVJvb3QpKSB7XG4gICAgdGhpcy5hcHBseVNpZ25hdHVyZShzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldFNpZ25hdHVyZXMgPSBmdW5jdGlvbihwcml2S2V5LCBzaWd0eXBlLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSB7XG4gIGlmICh0eXBlb2YgbWVya2xlUm9vdCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXJrbGVSb290ID0gQnVmZmVyLmZyb20obWVya2xlUm9vdCwgJ2hleCcpO1xuICB9XG4gIHByaXZLZXkgPSBuZXcgUHJpdmF0ZUtleShwcml2S2V5KTtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCBoYXNoRGF0YSA9IEhhc2guc2hhMjU2cmlwZW1kMTYwKHByaXZLZXkucHVibGljS2V5LnRvQnVmZmVyKCkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcbiAgICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiBpbnB1dC5nZXRTaWduYXR1cmVzKHRoaXMsIHByaXZLZXksIGksIHNpZ3R5cGUsIGhhc2hEYXRhLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaWduYXR1cmUgdG8gdGhlIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ25hdHVyZS5pbnB1dEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gc2lnbmF0dXJlLnNpZ3R5cGVcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBzaWduYXR1cmUucHVibGljS2V5XG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlLnNpZ25hdHVyZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25pbmdNZXRob2QgLSAnZWNkc2EnIHRvIHNpZ24gdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFwcGx5U2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSB7XG4gIHRoaXMuaW5wdXRzW3NpZ25hdHVyZS5pbnB1dEluZGV4XS5hZGRTaWduYXR1cmUodGhpcywgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKGNvbnN0IGlucHV0IG9mIHRoaXMuaW5wdXRzIHx8IFtdKSB7XG4gICAgaWYgKGlucHV0LmlzRnVsbHlTaWduZWQgPT09IElucHV0LnByb3RvdHlwZS5pc0Z1bGx5U2lnbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLlVuYWJsZVRvVmVyaWZ5U2lnbmF0dXJlKFxuICAgICAgICAnVW5yZWNvZ25pemVkIHNjcmlwdCBraW5kLCBvciBub3QgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGV4ZWN1dGUgc2NyaXB0LicgK1xuICAgICAgICAnVGhpcyB1c3VhbGx5IGhhcHBlbnMgd2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuaW5wdXRzLmV2ZXJ5KGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LmlzRnVsbHlTaWduZWQoKTtcbiAgfSk7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICBpZiAodGhpcy5pbnB1dHNbc2lnbmF0dXJlLmlucHV0SW5kZXhdLmlzVmFsaWRTaWduYXR1cmUgPT09IElucHV0LnByb3RvdHlwZS5pc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5VbmFibGVUb1ZlcmlmeVNpZ25hdHVyZShcbiAgICAgICdVbnJlY29nbml6ZWQgc2NyaXB0IGtpbmQsIG9yIG5vdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZXhlY3V0ZSBzY3JpcHQuJyArXG4gICAgICAnVGhpcyB1c3VhbGx5IGhhcHBlbnMgd2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uJ1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaW5wdXRzW3NpZ25hdHVyZS5pbnB1dEluZGV4XS5pc1ZhbGlkU2lnbmF0dXJlKHRoaXMsIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCk7XG59O1xuXG5cbi8qKlxuICogVmVyaWZ5IEVDRFNBIHNpZ25hdHVyZVxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZyBcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgXG4gKiBAcGFyYW0ge051bWJlcn0gbmluIFxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdCBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYXRvc2hpcyBcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuY2hlY2tFY2RzYVNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZywgcHVia2V5LCBuaW4sIHN1YnNjcmlwdCwgc2F0b3NoaXMpIHtcbiAgdmFyIHN1YnNjcmlwdEJ1ZmZlciA9IHN1YnNjcmlwdC50b0J1ZmZlcigpO1xuICB2YXIgc2NyaXB0Q29kZVdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgc2NyaXB0Q29kZVdyaXRlci53cml0ZVZhcmludE51bShzdWJzY3JpcHRCdWZmZXIubGVuZ3RoKTtcbiAgc2NyaXB0Q29kZVdyaXRlci53cml0ZShzdWJzY3JpcHRCdWZmZXIpO1xuXG4gIHZhciBzYXRvc2hpc0J1ZmZlcjtcbiAgaWYgKHNhdG9zaGlzKSB7XG4gICAgJC5jaGVja1N0YXRlKEpTVXRpbC5pc05hdHVyYWxOdW1iZXIoc2F0b3NoaXMpLCAnc2F0b3NoaXMgbmVlZHMgdG8gYmUgYSBuYXR1cmFsIG51bWJlcicpO1xuICAgIHNhdG9zaGlzQnVmZmVyID0gbmV3IEJ1ZmZlcldyaXRlcigpLndyaXRlVUludDY0TEVCTihuZXcgQk4oc2F0b3NoaXMpKS50b0J1ZmZlcigpO1xuICB9IGVsc2Uge1xuICAgIHNhdG9zaGlzQnVmZmVyID0gdGhpcy5pbnB1dHNbbmluXS5nZXRTYXRvc2hpc0J1ZmZlcigpO1xuICB9XG4gIHZhciB2ZXJpZmllZCA9IFNpZ2hhc2hXaXRuZXNzLnZlcmlmeShcbiAgICB0aGlzLFxuICAgIHNpZyxcbiAgICBwdWJrZXksXG4gICAgbmluLFxuICAgIHNjcmlwdENvZGVXcml0ZXIudG9CdWZmZXIoKSxcbiAgICBzYXRvc2hpc0J1ZmZlclxuICApO1xuICByZXR1cm4gdmVyaWZpZWQ7XG59O1xuXG5cbi8qKlxuICogVmVyaWZ5IFNjaG5vcnIgc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZyBcbiAqIEBwYXJhbSB7UHVibGljS2V5fEJ1ZmZlcn0gcHVia2V5IFxuICogQHBhcmFtIHtOdW1iZXJ9IG5pbiBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaWd2ZXJzaW9uIFxuICogQHBhcmFtIHtPYmplY3R9IGV4ZWNkYXRhIFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5jaGVja1NjaG5vcnJTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcsIHB1YmtleSwgbmluLCBzaWd2ZXJzaW9uLCBleGVjZGF0YSkge1xuICBpZiAoJC5pc1R5cGUocHVia2V5LCAnUHVibGljS2V5JykpIHtcbiAgICBwdWJrZXkgPSBwdWJrZXkucG9pbnQueC50b0J1ZmZlcigpO1xuICB9XG4gICQuY2hlY2tBcmd1bWVudChwdWJrZXkgJiYgcHVia2V5Lmxlbmd0aCA9PT0gMzIsICdTY2hub3JyIHNpZ25hdHVyZXMgaGF2ZSAzMi1ieXRlIHB1YmxpYyBrZXlzLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbmZvcmNpbmcgdGhpcy4nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNpZykpIHtcbiAgICBpZiAoc2lnLmxlbmd0aCAhPT0gNjQgJiYgc2lnLmxlbmd0aCAhPT0gNjUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2lnID0gU2lnbmF0dXJlLmZyb21TY2hub3JyKHNpZyk7XG4gIH1cbiAgLy8gTm90ZSB0aGF0IGluIFRhcHNjcmlwdCBldmFsdWF0aW9uLCBlbXB0eSBzaWduYXR1cmVzIGFyZSB0cmVhdGVkIHNwZWNpYWxseSAoaW52YWxpZCBzaWduYXR1cmUgdGhhdCBkb2VzIG5vdFxuICAvLyBhYm9ydCBzY3JpcHQgZXhlY3V0aW9uKS4gVGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBJbnRlcnByZXRlci5ldmFsQ2hlY2tzaWdUYXBzY3JpcHQsIHdoaWNoIHdvbid0IGludm9rZVxuICAvLyBDaGVja1NjaG5vcnJTaWduYXR1cmUgaW4gdGhhdCBjYXNlLiBJbiBvdGhlciBjb250ZXh0cywgdGhleSBhcmUgaW52YWxpZCBsaWtlIGV2ZXJ5IG90aGVyIHNpZ25hdHVyZSB3aXRoXG4gIC8vIHNpemUgZGlmZmVyZW50IGZyb20gNjQgb3IgNjUuXG4gICQuY2hlY2tBcmd1bWVudChzaWcuaXNTY2hub3JyLCAnU2lnbmF0dXJlIG11c3QgYmUgc2Nobm9ycicpO1xuXG4gIGlmICghU2lnaGFzaFNjaG5vcnIudmVyaWZ5KHRoaXMsIHNpZywgcHVia2V5LCBzaWd2ZXJzaW9uLCBuaW4sIGV4ZWNkYXRhKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBoZXJlIGxhcmdlbHkgZm9yIGxlZ2FjeSByZWFzb25zLiBIb3dldmVyLCBpZiB0aGUgc2lnIHR5cGVcbiAqIGlzIGFscmVhZHkga25vd24gKHZpYSBzaWd2ZXJzaW9uKSwgdGhlbiBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gY2FsbFxuICogY2hlY2tFY2RzYVNpZ25hdHVyZSBvciBjaGVja1NjaG5vcnJTaWduYXR1cmUgZGlyZWN0bHkuXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZyBTaWduYXR1cmUgdG8gdmVyaWZ5XG4gKiBAcGFyYW0ge1B1YmxpY0tleXxCdWZmZXJ9IHB1YmtleSBQdWJsaWMga2V5IHVzZWQgdG8gdmVyaWZ5IHNpZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG5pbiBUeCBpbnB1dCBpbmRleCB0byB2ZXJpZnkgc2lnbmF0dXJlIGFnYWluc3RcbiAqIEBwYXJhbSB7U2NyaXB0fSBzdWJzY3JpcHQgRUNEU0Egb25seVxuICogQHBhcmFtIHtOdW1iZXJ9IHNpZ3ZlcnNpb24gU2VlIFNpZ25hdHVyZS5WZXJzaW9uIGZvciB2YWxpZCB2ZXJzaW9ucyAoZGVmYXVsdDogMCBvciBTaWduYXR1cmUuVmVyc2lvbi5CQVNFKVxuICogQHBhcmFtIHtOdW1iZXJ9IHNhdG9zaGlzIEVDRFNBIG9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBleGVjZGF0YSBTY2hub3JyIG9ubHlcbiAqIEByZXR1cm5zIHtCb29sZWFufSB3aGV0aGVyIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQgZm9yIHRoaXMgdHJhbnNhY3Rpb24gaW5wdXRcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnZlcmlmeVNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZywgcHVia2V5LCBuaW4sIHN1YnNjcmlwdCwgc2lndmVyc2lvbiwgc2F0b3NoaXMsIGV4ZWNkYXRhKSB7XG4gIGlmIChzaWd2ZXJzaW9uID09IG51bGwpIHtcbiAgICBzaWd2ZXJzaW9uID0gU2lnbmF0dXJlLlZlcnNpb24uQkFTRTtcbiAgfVxuXG4gIHN3aXRjaChzaWd2ZXJzaW9uKSB7XG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwOlxuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFY2RzYVNpZ25hdHVyZShzaWcsIHB1YmtleSwgbmluLCBzdWJzY3JpcHQsIHNhdG9zaGlzKTtcbiAgICBjYXNlIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFJPT1Q6XG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQ6XG4gICAgICByZXR1cm4gdGhpcy5jaGVja1NjaG5vcnJTaWduYXR1cmUoc2lnLCBwdWJrZXksIG5pbiwgc2lndmVyc2lvbiwgZXhlY2RhdGEpO1xuICAgIGNhc2UgU2lnbmF0dXJlLlZlcnNpb24uQkFTRTpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFNpZ2hhc2gudmVyaWZ5KHRoaXMsIHNpZywgcHVia2V5LCBuaW4sIHN1YnNjcmlwdCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgdGhhdCBhIHRyYW5zYWN0aW9uIHBhc3NlcyBiYXNpYyBzYW5pdHkgdGVzdHMuIElmIG5vdCwgcmV0dXJuIGEgc3RyaW5nXG4gKiBkZXNjcmliaW5nIHRoZSBlcnJvci4gVGhpcyBmdW5jdGlvbiBjb250YWlucyB0aGUgc2FtZSBsb2dpYyBhc1xuICogQ2hlY2tUcmFuc2FjdGlvbiBpbiBiaXRjb2luIGNvcmUuXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbigpIHtcbiAgLy8gQmFzaWMgY2hlY2tzIHRoYXQgZG9uJ3QgZGVwZW5kIG9uIGFueSBjb250ZXh0XG4gIGlmICh0aGlzLmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIHR4aW5zIGVtcHR5JztcbiAgfVxuXG4gIGlmICh0aGlzLm91dHB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dHMgZW1wdHknO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIG9yIG92ZXJmbG93IG91dHB1dCB2YWx1ZXNcbiAgdmFyIHZhbHVlb3V0Ym4gPSBuZXcgQk4oMCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR4b3V0ID0gdGhpcy5vdXRwdXRzW2ldO1xuXG4gICAgaWYgKHR4b3V0LmludmFsaWRTYXRvc2hpcygpKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIHR4b3V0ICcgKyBpICsgJyBzYXRvc2hpcyBpcyBpbnZhbGlkJztcbiAgICB9XG4gICAgaWYgKHR4b3V0Ll9zYXRvc2hpc0JOLmd0KG5ldyBCTihUcmFuc2FjdGlvbi5NQVhfTU9ORVksIDEwKSkpIHtcbiAgICAgIHJldHVybiAndHJhbnNhY3Rpb24gdHhvdXQgJyArIGkgKyAnIGdyZWF0ZXIgdGhhbiBNQVhfTU9ORVknO1xuICAgIH1cbiAgICB2YWx1ZW91dGJuID0gdmFsdWVvdXRibi5hZGQodHhvdXQuX3NhdG9zaGlzQk4pO1xuICAgIGlmICh2YWx1ZW91dGJuLmd0KG5ldyBCTihUcmFuc2FjdGlvbi5NQVhfTU9ORVkpKSkge1xuICAgICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCAnICsgaSArICcgdG90YWwgb3V0cHV0IGdyZWF0ZXIgdGhhbiBNQVhfTU9ORVknO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNpemUgbGltaXRzXG4gIGlmICh0aGlzLnRvQnVmZmVyKCkubGVuZ3RoID4gTUFYX0JMT0NLX1NJWkUpIHtcbiAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIG92ZXIgdGhlIG1heGltdW0gYmxvY2sgc2l6ZSc7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGlucHV0c1xuICB2YXIgdHhpbm1hcCA9IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHhpbiA9IHRoaXMuaW5wdXRzW2ldO1xuXG4gICAgdmFyIGlucHV0aWQgPSB0eGluLnByZXZUeElkICsgJzonICsgdHhpbi5vdXRwdXRJbmRleDtcbiAgICBpZiAodHhpbm1hcFtpbnB1dGlkXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIGlucHV0ICcgKyBpICsgJyBkdXBsaWNhdGUgaW5wdXQnO1xuICAgIH1cbiAgICB0eGlubWFwW2lucHV0aWRdID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc0NvaW5iYXNlID0gdGhpcy5pc0NvaW5iYXNlKCk7XG4gIGlmIChpc0NvaW5iYXNlKSB7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuaW5wdXRzWzBdLl9zY3JpcHRCdWZmZXI7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPCAyIHx8IGJ1Zi5sZW5ndGggPiAxMDApIHtcbiAgICAgIHJldHVybiAnY29pbmJhc2UgdHJhbnNhY3Rpb24gc2NyaXB0IHNpemUgaW52YWxpZCc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuaW5wdXRzW2ldLmlzTnVsbCgpKSB7XG4gICAgICAgIHJldHVybiAndHJhbnNhY3Rpb24gaW5wdXQgJyArIGkgKyAnIGhhcyBudWxsIGlucHV0JztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFuYWxvZ291cyB0byBiaXRjb2luZCdzIElzQ29pbkJhc2UgZnVuY3Rpb24gaW4gdHJhbnNhY3Rpb24uaFxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuaXNDb2luYmFzZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmlucHV0c1swXS5pc051bGwoKSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhpcyB0cmFuc2FjdGlvbiBjYW4gYmUgcmVwbGFjZWQgaW4gdGhlIG1lbXBvb2wgd2l0aCBhbm90aGVyXG4gKiB0cmFuc2FjdGlvbiB0aGF0IHByb3ZpZGVzIGEgc3VmZmljaWVudGx5IGhpZ2hlciBmZWUgKFJCRikuXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5pc1JCRiA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XG4gICAgaWYgKGlucHV0LnNlcXVlbmNlTnVtYmVyIDwgSW5wdXQuTUFYSU5UIC0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRoaXMgdHJhbnNhY3Rpb24gdG8gYmUgcmVwbGFjZWQgaW4gdGhlIG1lbXBvb2wgKFJCRikgaWYgYSB0cmFuc2FjdGlvblxuICogaW5jbHVkZXMgYSBzdWZmaWNpZW50bHkgaGlnaGVyIGZlZS4gSXQgd2lsbCBzZXQgdGhlIHNlcXVlbmNlTnVtYmVyIHRvXG4gKiBERUZBVUxUX1JCRl9TRVFOVU1CRVIgZm9yIGFsbCBpbnB1dHMgaWYgdGhlIHNlcXVlbmNlIG51bWJlciBkb2VzIG5vdFxuICogYWxyZWFkeSBlbmFibGUgUkJGLlxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZW5hYmxlUkJGID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcbiAgICBpZiAoaW5wdXQuc2VxdWVuY2VOdW1iZXIgPj0gSW5wdXQuTUFYSU5UIC0gMSkge1xuICAgICAgaW5wdXQuc2VxdWVuY2VOdW1iZXIgPSBJbnB1dC5ERUZBVUxUX1JCRl9TRVFOVU1CRVI7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNldFZlcnNpb24gPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gICQuY2hlY2tBcmd1bWVudChcbiAgICBKU1V0aWwuaXNOYXR1cmFsTnVtYmVyKHZlcnNpb24pICYmIHZlcnNpb24gPD0gQ1VSUkVOVF9WRVJTSU9OLFxuICAgICdXcm9uZyB2ZXJzaW9uIG51bWJlcicpO1xuICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/unspentoutput.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/unspentoutput.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Address = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Unit = __webpack_require__(/*! ../unit */ \"(ssr)/./node_modules/bitcore-lib/lib/unit.js\");\n\n/**\n * Represents an unspent output information: its script, associated amount and address,\n * transaction id and output index.\n *\n * @constructor\n * @param {object} data\n * @param {string} data.txid the previous transaction id\n * @param {string=} data.txId alias for `txid`\n * @param {number} data.vout the index in the transaction\n * @param {number=} data.outputIndex alias for `vout`\n * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds\n * @param {string|Script=} data.script alias for `scriptPubKey`\n * @param {number} data.amount amount of bitcoins associated\n * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis (1 BTC = 1e8 satoshis)\n * @param {string|Address=} data.address the associated address to the script, if provided\n */\nfunction UnspentOutput(data) {\n  /* jshint maxcomplexity: 20 */\n  /* jshint maxstatements: 20 */\n  if (!(this instanceof UnspentOutput)) {\n    return new UnspentOutput(data);\n  }\n  $.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');\n  var address = data.address ? new Address(data.address) : undefined;\n  var txId = data.txid ? data.txid : data.txId;\n  if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {\n    // TODO: Use the errors library\n    throw new Error('Invalid TXID in object', data);\n  }\n  var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;\n  if (!_.isNumber(outputIndex)) {\n    throw new Error('Invalid outputIndex, received ' + outputIndex);\n  }\n  $.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script),\n                  'Must provide the scriptPubKey for that output!');\n  var script = new Script(data.scriptPubKey || data.script);\n  $.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis),\n                      'Must provide an amount for the output');\n  var amount = !_.isUndefined(data.amount) ? new Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;\n  $.checkArgument(_.isNumber(amount), 'Amount must be a number');\n  JSUtil.defineImmutable(this, {\n    address: address,\n    txId: txId,\n    outputIndex: outputIndex,\n    script: script,\n    satoshis: amount\n  });\n}\n\n/**\n * Provide an informative output when displaying this object in the console\n * @returns string\n */\nUnspentOutput.prototype.inspect = function() {\n  return '<UnspentOutput: ' + this.txId + ':' + this.outputIndex +\n         ', satoshis: ' + this.satoshis + ', address: ' + this.address + '>';\n};\n\n/**\n * String representation: just \"txid:index\"\n * @returns string\n */\nUnspentOutput.prototype.toString = function() {\n  return this.txId + ':' + this.outputIndex;\n};\n\n/**\n * Deserialize an UnspentOutput from an object\n * @param {object|string} data\n * @return UnspentOutput\n */\nUnspentOutput.fromObject = function(data) {\n  return new UnspentOutput(data);\n};\n\n/**\n * Returns a plain object (no prototype or methods) with the associated info for this output\n * @return {object}\n */\nUnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject() {\n  return {\n    address: this.address ? this.address.toString() : undefined,\n    txid: this.txId,\n    vout: this.outputIndex,\n    scriptPubKey: this.script.toBuffer().toString('hex'),\n    amount: Unit.fromSatoshis(this.satoshis).toBTC()\n  };\n};\n\nmodule.exports = UnspentOutput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3Vuc3BlbnRvdXRwdXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFRO0FBQ3hCLFFBQVEsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLG1FQUFZOztBQUVqQyxhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLG1FQUFZO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyw2REFBUzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi90cmFuc2FjdGlvbi91bnNwZW50b3V0cHV0LmpzPzlhOWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XG5cbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi4vYWRkcmVzcycpO1xudmFyIFVuaXQgPSByZXF1aXJlKCcuLi91bml0Jyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiB1bnNwZW50IG91dHB1dCBpbmZvcm1hdGlvbjogaXRzIHNjcmlwdCwgYXNzb2NpYXRlZCBhbW91bnQgYW5kIGFkZHJlc3MsXG4gKiB0cmFuc2FjdGlvbiBpZCBhbmQgb3V0cHV0IGluZGV4LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhLnR4aWQgdGhlIHByZXZpb3VzIHRyYW5zYWN0aW9uIGlkXG4gKiBAcGFyYW0ge3N0cmluZz19IGRhdGEudHhJZCBhbGlhcyBmb3IgYHR4aWRgXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YS52b3V0IHRoZSBpbmRleCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyPX0gZGF0YS5vdXRwdXRJbmRleCBhbGlhcyBmb3IgYHZvdXRgXG4gKiBAcGFyYW0ge3N0cmluZ3xTY3JpcHR9IGRhdGEuc2NyaXB0UHViS2V5IHRoZSBzY3JpcHQgdGhhdCBtdXN0IGJlIHJlc29sdmVkIHRvIHJlbGVhc2UgdGhlIGZ1bmRzXG4gKiBAcGFyYW0ge3N0cmluZ3xTY3JpcHQ9fSBkYXRhLnNjcmlwdCBhbGlhcyBmb3IgYHNjcmlwdFB1YktleWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFtb3VudCBhbW91bnQgb2YgYml0Y29pbnMgYXNzb2NpYXRlZFxuICogQHBhcmFtIHtudW1iZXI9fSBkYXRhLnNhdG9zaGlzIGFsaWFzIGZvciBgYW1vdW50YCwgYnV0IGV4cHJlc3NlZCBpbiBzYXRvc2hpcyAoMSBCVEMgPSAxZTggc2F0b3NoaXMpXG4gKiBAcGFyYW0ge3N0cmluZ3xBZGRyZXNzPX0gZGF0YS5hZGRyZXNzIHRoZSBhc3NvY2lhdGVkIGFkZHJlc3MgdG8gdGhlIHNjcmlwdCwgaWYgcHJvdmlkZWRcbiAqL1xuZnVuY3Rpb24gVW5zcGVudE91dHB1dChkYXRhKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAyMCAqL1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVuc3BlbnRPdXRwdXQpKSB7XG4gICAgcmV0dXJuIG5ldyBVbnNwZW50T3V0cHV0KGRhdGEpO1xuICB9XG4gICQuY2hlY2tBcmd1bWVudChfLmlzT2JqZWN0KGRhdGEpLCAnTXVzdCBwcm92aWRlIGFuIG9iamVjdCBmcm9tIHdoZXJlIHRvIGV4dHJhY3QgZGF0YScpO1xuICB2YXIgYWRkcmVzcyA9IGRhdGEuYWRkcmVzcyA/IG5ldyBBZGRyZXNzKGRhdGEuYWRkcmVzcykgOiB1bmRlZmluZWQ7XG4gIHZhciB0eElkID0gZGF0YS50eGlkID8gZGF0YS50eGlkIDogZGF0YS50eElkO1xuICBpZiAoIXR4SWQgfHwgIUpTVXRpbC5pc0hleGFTdHJpbmcodHhJZCkgfHwgdHhJZC5sZW5ndGggPiA2NCkge1xuICAgIC8vIFRPRE86IFVzZSB0aGUgZXJyb3JzIGxpYnJhcnlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVFhJRCBpbiBvYmplY3QnLCBkYXRhKTtcbiAgfVxuICB2YXIgb3V0cHV0SW5kZXggPSBfLmlzVW5kZWZpbmVkKGRhdGEudm91dCkgPyBkYXRhLm91dHB1dEluZGV4IDogZGF0YS52b3V0O1xuICBpZiAoIV8uaXNOdW1iZXIob3V0cHV0SW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG91dHB1dEluZGV4LCByZWNlaXZlZCAnICsgb3V0cHV0SW5kZXgpO1xuICB9XG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZChkYXRhLnNjcmlwdFB1YktleSkgfHwgIV8uaXNVbmRlZmluZWQoZGF0YS5zY3JpcHQpLFxuICAgICAgICAgICAgICAgICAgJ011c3QgcHJvdmlkZSB0aGUgc2NyaXB0UHViS2V5IGZvciB0aGF0IG91dHB1dCEnKTtcbiAgdmFyIHNjcmlwdCA9IG5ldyBTY3JpcHQoZGF0YS5zY3JpcHRQdWJLZXkgfHwgZGF0YS5zY3JpcHQpO1xuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQoZGF0YS5hbW91bnQpIHx8ICFfLmlzVW5kZWZpbmVkKGRhdGEuc2F0b3NoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICdNdXN0IHByb3ZpZGUgYW4gYW1vdW50IGZvciB0aGUgb3V0cHV0Jyk7XG4gIHZhciBhbW91bnQgPSAhXy5pc1VuZGVmaW5lZChkYXRhLmFtb3VudCkgPyBuZXcgVW5pdC5mcm9tQlRDKGRhdGEuYW1vdW50KS50b1NhdG9zaGlzKCkgOiBkYXRhLnNhdG9zaGlzO1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc051bWJlcihhbW91bnQpLCAnQW1vdW50IG11c3QgYmUgYSBudW1iZXInKTtcbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XG4gICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICB0eElkOiB0eElkLFxuICAgIG91dHB1dEluZGV4OiBvdXRwdXRJbmRleCxcbiAgICBzY3JpcHQ6IHNjcmlwdCxcbiAgICBzYXRvc2hpczogYW1vdW50XG4gIH0pO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgYW4gaW5mb3JtYXRpdmUgb3V0cHV0IHdoZW4gZGlzcGxheWluZyB0aGlzIG9iamVjdCBpbiB0aGUgY29uc29sZVxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cblVuc3BlbnRPdXRwdXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8VW5zcGVudE91dHB1dDogJyArIHRoaXMudHhJZCArICc6JyArIHRoaXMub3V0cHV0SW5kZXggK1xuICAgICAgICAgJywgc2F0b3NoaXM6ICcgKyB0aGlzLnNhdG9zaGlzICsgJywgYWRkcmVzczogJyArIHRoaXMuYWRkcmVzcyArICc+Jztcbn07XG5cbi8qKlxuICogU3RyaW5nIHJlcHJlc2VudGF0aW9uOiBqdXN0IFwidHhpZDppbmRleFwiXG4gKiBAcmV0dXJucyBzdHJpbmdcbiAqL1xuVW5zcGVudE91dHB1dC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHhJZCArICc6JyArIHRoaXMub3V0cHV0SW5kZXg7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplIGFuIFVuc3BlbnRPdXRwdXQgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gZGF0YVxuICogQHJldHVybiBVbnNwZW50T3V0cHV0XG4gKi9cblVuc3BlbnRPdXRwdXQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBVbnNwZW50T3V0cHV0KGRhdGEpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IChubyBwcm90b3R5cGUgb3IgbWV0aG9kcykgd2l0aCB0aGUgYXNzb2NpYXRlZCBpbmZvIGZvciB0aGlzIG91dHB1dFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5VbnNwZW50T3V0cHV0LnByb3RvdHlwZS50b09iamVjdCA9IFVuc3BlbnRPdXRwdXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyA/IHRoaXMuYWRkcmVzcy50b1N0cmluZygpIDogdW5kZWZpbmVkLFxuICAgIHR4aWQ6IHRoaXMudHhJZCxcbiAgICB2b3V0OiB0aGlzLm91dHB1dEluZGV4LFxuICAgIHNjcmlwdFB1YktleTogdGhpcy5zY3JpcHQudG9CdWZmZXIoKS50b1N0cmluZygnaGV4JyksXG4gICAgYW1vdW50OiBVbml0LmZyb21TYXRvc2hpcyh0aGlzLnNhdG9zaGlzKS50b0JUQygpXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuc3BlbnRPdXRwdXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/unspentoutput.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/unit.js":
/*!**********************************************!*\
  !*** ./node_modules/bitcore-lib/lib/unit.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar UNITS = {\n  'BTC'      : [1e8, 8],\n  'mBTC'     : [1e5, 5],\n  'uBTC'     : [1e2, 2],\n  'bits'     : [1e2, 2],\n  'satoshis' : [1, 0]\n};\n\n/**\n * Utility for handling and converting bitcoins units. The supported units are\n * BTC, mBTC, bits (also named uBTC) and satoshis. A unit instance can be created with an\n * amount and a unit code, or alternatively using static methods like {fromBTC}.\n * It also allows to be created from a fiat amount and the exchange rate, or\n * alternatively using the {fromFiat} static method.\n * You can consult for different representation of a unit instance using it's\n * {to} method, the fixed unit methods like {toSatoshis} or alternatively using\n * the unit accessors. It also can be converted to a fiat amount by providing the\n * corresponding BTC/fiat exchange rate.\n *\n * @example\n * ```javascript\n * var sats = Unit.fromBTC(1.3).toSatoshis();\n * var mili = Unit.fromBits(1.3).to(Unit.mBTC);\n * var bits = Unit.fromFiat(1.3, 350).bits;\n * var btc = new Unit(1.3, Unit.bits).BTC;\n * ```\n *\n * @param {Number} amount - The amount to be represented\n * @param {String|Number} code - The unit of the amount or the exchange rate\n * @returns {Unit} A new instance of an Unit\n * @constructor\n */\nfunction Unit(amount, code) {\n  if (!(this instanceof Unit)) {\n    return new Unit(amount, code);\n  }\n\n  // convert fiat to BTC\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n    amount = amount / code;\n    code = Unit.BTC;\n  }\n\n  this._value = this._from(amount, code);\n\n  var self = this;\n  var defineAccesor = function(key) {\n    Object.defineProperty(self, key, {\n      get: function() { return self.to(key); },\n      enumerable: true,\n    });\n  };\n\n  Object.keys(UNITS).forEach(defineAccesor);\n}\n\nObject.keys(UNITS).forEach(function(key) {\n  Unit[key] = key;\n});\n\n/**\n * Returns a Unit instance created from JSON string or object\n *\n * @param {String|Object} json - JSON with keys: amount and code\n * @returns {Unit} A Unit instance\n */\nUnit.fromObject = function fromObject(data){\n  $.checkArgument(_.isObject(data), 'Argument is expected to be an object');\n  return new Unit(data.amount, data.code);\n};\n\n/**\n * Returns a Unit instance created from an amount in BTC\n *\n * @param {Number} amount - The amount in BTC\n * @returns {Unit} A Unit instance\n */\nUnit.fromBTC = function(amount) {\n  return new Unit(amount, Unit.BTC);\n};\n\n/**\n * Returns a Unit instance created from an amount in mBTC\n *\n * @param {Number} amount - The amount in mBTC\n * @returns {Unit} A Unit instance\n */\nUnit.fromMillis = Unit.fromMilis = function(amount) {\n  return new Unit(amount, Unit.mBTC);\n};\n\n/**\n * Returns a Unit instance created from an amount in bits\n *\n * @param {Number} amount - The amount in bits\n * @returns {Unit} A Unit instance\n */\nUnit.fromMicros = Unit.fromBits = function(amount) {\n  return new Unit(amount, Unit.bits);\n};\n\n/**\n * Returns a Unit instance created from an amount in satoshis\n *\n * @param {Number} amount - The amount in satoshis\n * @returns {Unit} A Unit instance\n */\nUnit.fromSatoshis = function(amount) {\n  return new Unit(amount, Unit.satoshis);\n};\n\n/**\n * Returns a Unit instance created from a fiat amount and exchange rate.\n *\n * @param {Number} amount - The amount in fiat\n * @param {Number} rate - The exchange rate BTC/fiat\n * @returns {Unit} A Unit instance\n */\nUnit.fromFiat = function(amount, rate) {\n  return new Unit(amount, rate);\n};\n\nUnit.prototype._from = function(amount, code) {\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n  return parseInt((amount * UNITS[code][0]).toFixed());\n};\n\n/**\n * Returns the value represented in the specified unit\n *\n * @param {String|Number} code - The unit code or exchange rate\n * @returns {Number} The converted value\n */\nUnit.prototype.to = function(code) {\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n    return parseFloat((this.BTC * code).toFixed(2));\n  }\n\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n\n  var value = this._value / UNITS[code][0];\n  return parseFloat(value.toFixed(UNITS[code][1]));\n};\n\n/**\n * Returns the value represented in BTC\n *\n * @returns {Number} The value converted to BTC\n */\nUnit.prototype.toBTC = function() {\n  return this.to(Unit.BTC);\n};\n\n/**\n * Returns the value represented in mBTC\n *\n * @returns {Number} The value converted to mBTC\n */\nUnit.prototype.toMillis = Unit.prototype.toMilis = function() {\n  return this.to(Unit.mBTC);\n};\n\n/**\n * Returns the value represented in bits\n *\n * @returns {Number} The value converted to bits\n */\nUnit.prototype.toMicros = Unit.prototype.toBits = function() {\n  return this.to(Unit.bits);\n};\n\n/**\n * Returns the value represented in satoshis\n *\n * @returns {Number} The value converted to satoshis\n */\nUnit.prototype.toSatoshis = function() {\n  return this.to(Unit.satoshis);\n};\n\n/**\n * Returns the value represented in fiat\n *\n * @param {string} rate - The exchange rate between BTC/currency\n * @returns {Number} The value converted to satoshis\n */\nUnit.prototype.atRate = function(rate) {\n  return this.to(rate);\n};\n\n/**\n * Returns a the string representation of the value in satoshis\n *\n * @returns {string} the value in satoshis\n */\nUnit.prototype.toString = function() {\n  return this.satoshis + ' satoshis';\n};\n\n/**\n * Returns a plain object representation of the Unit\n *\n * @returns {Object} An object with the keys: amount and code\n */\nUnit.prototype.toObject = Unit.prototype.toJSON = function toObject() {\n  return {\n    amount: this.BTC,\n    code: Unit.BTC\n  };\n};\n\n/**\n * Returns a string formatted for the console\n *\n * @returns {string} the value in satoshis\n */\nUnit.prototype.inspect = function() {\n  return '<Unit: ' + this.toString() + '>';\n};\n\nmodule.exports = Unit;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3VuaXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFROztBQUV4QixhQUFhLG1CQUFPLENBQUMsc0VBQVU7QUFDL0IsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBLElBQUksSUFBSSxxQ0FBcUMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi91bml0LmpzPzI2ODUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciAkID0gcmVxdWlyZSgnLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcblxudmFyIFVOSVRTID0ge1xuICAnQlRDJyAgICAgIDogWzFlOCwgOF0sXG4gICdtQlRDJyAgICAgOiBbMWU1LCA1XSxcbiAgJ3VCVEMnICAgICA6IFsxZTIsIDJdLFxuICAnYml0cycgICAgIDogWzFlMiwgMl0sXG4gICdzYXRvc2hpcycgOiBbMSwgMF1cbn07XG5cbi8qKlxuICogVXRpbGl0eSBmb3IgaGFuZGxpbmcgYW5kIGNvbnZlcnRpbmcgYml0Y29pbnMgdW5pdHMuIFRoZSBzdXBwb3J0ZWQgdW5pdHMgYXJlXG4gKiBCVEMsIG1CVEMsIGJpdHMgKGFsc28gbmFtZWQgdUJUQykgYW5kIHNhdG9zaGlzLiBBIHVuaXQgaW5zdGFuY2UgY2FuIGJlIGNyZWF0ZWQgd2l0aCBhblxuICogYW1vdW50IGFuZCBhIHVuaXQgY29kZSwgb3IgYWx0ZXJuYXRpdmVseSB1c2luZyBzdGF0aWMgbWV0aG9kcyBsaWtlIHtmcm9tQlRDfS5cbiAqIEl0IGFsc28gYWxsb3dzIHRvIGJlIGNyZWF0ZWQgZnJvbSBhIGZpYXQgYW1vdW50IGFuZCB0aGUgZXhjaGFuZ2UgcmF0ZSwgb3JcbiAqIGFsdGVybmF0aXZlbHkgdXNpbmcgdGhlIHtmcm9tRmlhdH0gc3RhdGljIG1ldGhvZC5cbiAqIFlvdSBjYW4gY29uc3VsdCBmb3IgZGlmZmVyZW50IHJlcHJlc2VudGF0aW9uIG9mIGEgdW5pdCBpbnN0YW5jZSB1c2luZyBpdCdzXG4gKiB7dG99IG1ldGhvZCwgdGhlIGZpeGVkIHVuaXQgbWV0aG9kcyBsaWtlIHt0b1NhdG9zaGlzfSBvciBhbHRlcm5hdGl2ZWx5IHVzaW5nXG4gKiB0aGUgdW5pdCBhY2Nlc3NvcnMuIEl0IGFsc28gY2FuIGJlIGNvbnZlcnRlZCB0byBhIGZpYXQgYW1vdW50IGJ5IHByb3ZpZGluZyB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgQlRDL2ZpYXQgZXhjaGFuZ2UgcmF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHNhdHMgPSBVbml0LmZyb21CVEMoMS4zKS50b1NhdG9zaGlzKCk7XG4gKiB2YXIgbWlsaSA9IFVuaXQuZnJvbUJpdHMoMS4zKS50byhVbml0Lm1CVEMpO1xuICogdmFyIGJpdHMgPSBVbml0LmZyb21GaWF0KDEuMywgMzUwKS5iaXRzO1xuICogdmFyIGJ0YyA9IG5ldyBVbml0KDEuMywgVW5pdC5iaXRzKS5CVEM7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gVGhlIGFtb3VudCB0byBiZSByZXByZXNlbnRlZFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBjb2RlIC0gVGhlIHVuaXQgb2YgdGhlIGFtb3VudCBvciB0aGUgZXhjaGFuZ2UgcmF0ZVxuICogQHJldHVybnMge1VuaXR9IEEgbmV3IGluc3RhbmNlIG9mIGFuIFVuaXRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVbml0KGFtb3VudCwgY29kZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW5pdCkpIHtcbiAgICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCBjb2RlKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgZmlhdCB0byBCVENcbiAgaWYgKF8uaXNOdW1iZXIoY29kZSkpIHtcbiAgICBpZiAoY29kZSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLlVuaXQuSW52YWxpZFJhdGUoY29kZSk7XG4gICAgfVxuICAgIGFtb3VudCA9IGFtb3VudCAvIGNvZGU7XG4gICAgY29kZSA9IFVuaXQuQlRDO1xuICB9XG5cbiAgdGhpcy5fdmFsdWUgPSB0aGlzLl9mcm9tKGFtb3VudCwgY29kZSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZGVmaW5lQWNjZXNvciA9IGZ1bmN0aW9uKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLnRvKGtleSk7IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH0pO1xuICB9O1xuXG4gIE9iamVjdC5rZXlzKFVOSVRTKS5mb3JFYWNoKGRlZmluZUFjY2Vzb3IpO1xufVxuXG5PYmplY3Qua2V5cyhVTklUUykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgVW5pdFtrZXldID0ga2V5O1xufSk7XG5cbi8qKlxuICogUmV0dXJucyBhIFVuaXQgaW5zdGFuY2UgY3JlYXRlZCBmcm9tIEpTT04gc3RyaW5nIG9yIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ganNvbiAtIEpTT04gd2l0aCBrZXlzOiBhbW91bnQgYW5kIGNvZGVcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcbiAqL1xuVW5pdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChkYXRhKXtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3QoZGF0YSksICdBcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QnKTtcbiAgcmV0dXJuIG5ldyBVbml0KGRhdGEuYW1vdW50LCBkYXRhLmNvZGUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgVW5pdCBpbnN0YW5jZSBjcmVhdGVkIGZyb20gYW4gYW1vdW50IGluIEJUQ1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSBUaGUgYW1vdW50IGluIEJUQ1xuICogQHJldHVybnMge1VuaXR9IEEgVW5pdCBpbnN0YW5jZVxuICovXG5Vbml0LmZyb21CVEMgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgcmV0dXJuIG5ldyBVbml0KGFtb3VudCwgVW5pdC5CVEMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgVW5pdCBpbnN0YW5jZSBjcmVhdGVkIGZyb20gYW4gYW1vdW50IGluIG1CVENcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gVGhlIGFtb3VudCBpbiBtQlRDXG4gKiBAcmV0dXJucyB7VW5pdH0gQSBVbml0IGluc3RhbmNlXG4gKi9cblVuaXQuZnJvbU1pbGxpcyA9IFVuaXQuZnJvbU1pbGlzID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gIHJldHVybiBuZXcgVW5pdChhbW91bnQsIFVuaXQubUJUQyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBVbml0IGluc3RhbmNlIGNyZWF0ZWQgZnJvbSBhbiBhbW91bnQgaW4gYml0c1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSBUaGUgYW1vdW50IGluIGJpdHNcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcbiAqL1xuVW5pdC5mcm9tTWljcm9zID0gVW5pdC5mcm9tQml0cyA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCBVbml0LmJpdHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgVW5pdCBpbnN0YW5jZSBjcmVhdGVkIGZyb20gYW4gYW1vdW50IGluIHNhdG9zaGlzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIFRoZSBhbW91bnQgaW4gc2F0b3NoaXNcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcbiAqL1xuVW5pdC5mcm9tU2F0b3NoaXMgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgcmV0dXJuIG5ldyBVbml0KGFtb3VudCwgVW5pdC5zYXRvc2hpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBVbml0IGluc3RhbmNlIGNyZWF0ZWQgZnJvbSBhIGZpYXQgYW1vdW50IGFuZCBleGNoYW5nZSByYXRlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSBUaGUgYW1vdW50IGluIGZpYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYXRlIC0gVGhlIGV4Y2hhbmdlIHJhdGUgQlRDL2ZpYXRcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcbiAqL1xuVW5pdC5mcm9tRmlhdCA9IGZ1bmN0aW9uKGFtb3VudCwgcmF0ZSkge1xuICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCByYXRlKTtcbn07XG5cblVuaXQucHJvdG90eXBlLl9mcm9tID0gZnVuY3Rpb24oYW1vdW50LCBjb2RlKSB7XG4gIGlmICghVU5JVFNbY29kZV0pIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlVuaXQuVW5rbm93bkNvZGUoY29kZSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSW50KChhbW91bnQgKiBVTklUU1tjb2RlXVswXSkudG9GaXhlZCgpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgaW4gdGhlIHNwZWNpZmllZCB1bml0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBjb2RlIC0gVGhlIHVuaXQgY29kZSBvciBleGNoYW5nZSByYXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgY29udmVydGVkIHZhbHVlXG4gKi9cblVuaXQucHJvdG90eXBlLnRvID0gZnVuY3Rpb24oY29kZSkge1xuICBpZiAoXy5pc051bWJlcihjb2RlKSkge1xuICAgIGlmIChjb2RlIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuVW5pdC5JbnZhbGlkUmF0ZShjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoKHRoaXMuQlRDICogY29kZSkudG9GaXhlZCgyKSk7XG4gIH1cblxuICBpZiAoIVVOSVRTW2NvZGVdKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Vbml0LlVua25vd25Db2RlKGNvZGUpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWUgLyBVTklUU1tjb2RlXVswXTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZChVTklUU1tjb2RlXVsxXSkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBpbiBCVENcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIEJUQ1xuICovXG5Vbml0LnByb3RvdHlwZS50b0JUQyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50byhVbml0LkJUQyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIG1CVENcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIG1CVENcbiAqL1xuVW5pdC5wcm90b3R5cGUudG9NaWxsaXMgPSBVbml0LnByb3RvdHlwZS50b01pbGlzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvKFVuaXQubUJUQyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIGJpdHNcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIGJpdHNcbiAqL1xuVW5pdC5wcm90b3R5cGUudG9NaWNyb3MgPSBVbml0LnByb3RvdHlwZS50b0JpdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG8oVW5pdC5iaXRzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgaW4gc2F0b3NoaXNcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIHNhdG9zaGlzXG4gKi9cblVuaXQucHJvdG90eXBlLnRvU2F0b3NoaXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG8oVW5pdC5zYXRvc2hpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIGZpYXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF0ZSAtIFRoZSBleGNoYW5nZSByYXRlIGJldHdlZW4gQlRDL2N1cnJlbmN5XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIHNhdG9zaGlzXG4gKi9cblVuaXQucHJvdG90eXBlLmF0UmF0ZSA9IGZ1bmN0aW9uKHJhdGUpIHtcbiAgcmV0dXJuIHRoaXMudG8ocmF0ZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSBpbiBzYXRvc2hpc1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB2YWx1ZSBpbiBzYXRvc2hpc1xuICovXG5Vbml0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zYXRvc2hpcyArICcgc2F0b3NoaXMnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBVbml0XG4gKlxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGtleXM6IGFtb3VudCBhbmQgY29kZVxuICovXG5Vbml0LnByb3RvdHlwZS50b09iamVjdCA9IFVuaXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIGFtb3VudDogdGhpcy5CVEMsXG4gICAgY29kZTogVW5pdC5CVENcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyBmb3JtYXR0ZWQgZm9yIHRoZSBjb25zb2xlXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHZhbHVlIGluIHNhdG9zaGlzXG4gKi9cblVuaXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8VW5pdDogJyArIHRoaXMudG9TdHJpbmcoKSArICc+Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/unit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/uri.js":
/*!*********************************************!*\
  !*** ./node_modules/bitcore-lib/lib/uri.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar URL = __webpack_require__(/*! url */ \"url\");\n\nvar Address = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Unit = __webpack_require__(/*! ./unit */ \"(ssr)/./node_modules/bitcore-lib/lib/unit.js\");\n\n/**\n * Bitcore URI\n *\n * Instantiate an URI from a bitcoin URI String or an Object. An URI instance\n * can be created with a bitcoin uri string or an object. All instances of\n * URI are valid, the static method isValid allows checking before instantiation.\n *\n * All standard parameters can be found as members of the class, the address\n * is represented using an {Address} instance and the amount is represented in\n * satoshis. Any other non-standard parameters can be found under the extra member.\n *\n * @example\n * ```javascript\n *\n * var uri = new URI('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');\n * console.log(uri.address, uri.amount);\n * ```\n *\n * @param {string|Object} data - A bitcoin URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n * @returns {URI} A new valid and frozen instance of URI\n * @constructor\n */\nvar URI = function(data, knownParams) {\n  if (!(this instanceof URI)) {\n    return new URI(data, knownParams);\n  }\n\n  this.extras = {};\n  this.knownParams = knownParams || [];\n  this.address = this.network = this.amount = this.message = null;\n\n  if (typeof(data) === 'string') {\n    var params = URI.parse(data);\n    if (params.amount) {\n      params.amount = this._parseAmount(params.amount);\n    }\n    this._fromObject(params);\n  } else if (typeof(data) === 'object') {\n    this._fromObject(data);\n  } else {\n    throw new TypeError('Unrecognized data format.');\n  }\n};\n\n/**\n * Instantiate a URI from a String\n *\n * @param {string} str - JSON string or object of the URI\n * @returns {URI} A new instance of a URI\n */\nURI.fromString = function fromString(str) {\n  if (typeof(str) !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return new URI(str);\n};\n\n/**\n * Instantiate a URI from an Object\n *\n * @param {Object} data - object of the URI\n * @returns {URI} A new instance of a URI\n */\nURI.fromObject = function fromObject(json) {\n  return new URI(json);\n};\n\n/**\n * Check if an bitcoin URI string is valid\n *\n * @example\n * ```javascript\n *\n * var valid = URI.isValid('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');\n * // true\n * ```\n *\n * @param {string|Object} data - A bitcoin URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @returns {boolean} Result of uri validation\n */\nURI.isValid = function(arg, knownParams) {\n  try {\n    new URI(arg, knownParams);\n  } catch (err) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Convert a bitcoin URI string into a simple object.\n *\n * @param {string} uri - A bitcoin URI string\n * @throws {TypeError} Invalid bitcoin URI\n * @returns {Object} An object with the parsed params\n */\nURI.parse = function(uri) {\n  var info = URL.parse(uri, true);\n\n  if (info.protocol !== 'bitcoin:') {\n    throw new TypeError('Invalid bitcoin URI');\n  }\n\n  // workaround to host insensitiveness\n  var group = /[^:]*:\\/?\\/?([^?]*)/.exec(uri);\n  info.query.address = group && group[1] || undefined;\n\n  return info.query;\n};\n\nURI.Members = ['address', 'amount', 'message', 'label', 'r'];\n\n/**\n * Internal function to load the URI instance with an object.\n *\n * @param {Object} obj - Object with the information\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n */\nURI.prototype._fromObject = function(obj) {\n  /* jshint maxcomplexity: 10 */\n\n  if (!Address.isValid(obj.address)) {\n    throw new TypeError('Invalid bitcoin address');\n  }\n\n  this.address = new Address(obj.address);\n  this.network = this.address.network;\n  this.amount = obj.amount;\n\n  for (var key in obj) {\n    if (key === 'address' || key === 'amount') {\n      continue;\n    }\n\n    if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {\n      throw Error('Unknown required argument ' + key);\n    }\n\n    var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;\n    destination[key] = obj[key];\n  }\n};\n\n/**\n * Internal function to transform a BTC string amount into satoshis\n *\n * @param {string} amount - Amount BTC string\n * @throws {TypeError} Invalid amount\n * @returns {Object} Amount represented in satoshis\n */\nURI.prototype._parseAmount = function(amount) {\n  amount = Number(amount);\n  if (isNaN(amount)) {\n    throw new TypeError('Invalid amount');\n  }\n  return Unit.fromBTC(amount).toSatoshis();\n};\n\nURI.prototype.toObject = URI.prototype.toJSON = function toObject() {\n  var json = {};\n  for (var i = 0; i < URI.Members.length; i++) {\n    var m = URI.Members[i];\n    if (this.hasOwnProperty(m) && typeof(this[m]) !== 'undefined') {\n      json[m] = this[m].toString();\n    }\n  }\n  _.extend(json, this.extras);\n  return json;\n};\n\n/**\n * Will return a the string representation of the URI\n *\n * @returns {string} Bitcoin URI string\n */\nURI.prototype.toString = function() {\n  var query = {};\n  if (this.amount) {\n    query.amount = Unit.fromSatoshis(this.amount).toBTC();\n  }\n  if (this.message) {\n    query.message = this.message;\n  }\n  if (this.label) {\n    query.label = this.label;\n  }\n  if (this.r) {\n    query.r = this.r;\n  }\n  _.extend(query, this.extras);\n\n  return URL.format({\n    protocol: 'bitcoin:',\n    host: this.address,\n    query: query\n  });\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin URI\n */\nURI.prototype.inspect = function() {\n  return '<URI: ' + this.toString() + '>';\n};\n\nmodule.exports = URI;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3VyaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsVUFBVSxtQkFBTyxDQUFDLGdCQUFLOztBQUV2QixjQUFjLG1CQUFPLENBQUMsa0VBQVc7QUFDakMsV0FBVyxtQkFBTyxDQUFDLDREQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksV0FBVztBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdXJpLmpzPzk4N2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIFVSTCA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xudmFyIFVuaXQgPSByZXF1aXJlKCcuL3VuaXQnKTtcblxuLyoqXG4gKiBCaXRjb3JlIFVSSVxuICpcbiAqIEluc3RhbnRpYXRlIGFuIFVSSSBmcm9tIGEgYml0Y29pbiBVUkkgU3RyaW5nIG9yIGFuIE9iamVjdC4gQW4gVVJJIGluc3RhbmNlXG4gKiBjYW4gYmUgY3JlYXRlZCB3aXRoIGEgYml0Y29pbiB1cmkgc3RyaW5nIG9yIGFuIG9iamVjdC4gQWxsIGluc3RhbmNlcyBvZlxuICogVVJJIGFyZSB2YWxpZCwgdGhlIHN0YXRpYyBtZXRob2QgaXNWYWxpZCBhbGxvd3MgY2hlY2tpbmcgYmVmb3JlIGluc3RhbnRpYXRpb24uXG4gKlxuICogQWxsIHN0YW5kYXJkIHBhcmFtZXRlcnMgY2FuIGJlIGZvdW5kIGFzIG1lbWJlcnMgb2YgdGhlIGNsYXNzLCB0aGUgYWRkcmVzc1xuICogaXMgcmVwcmVzZW50ZWQgdXNpbmcgYW4ge0FkZHJlc3N9IGluc3RhbmNlIGFuZCB0aGUgYW1vdW50IGlzIHJlcHJlc2VudGVkIGluXG4gKiBzYXRvc2hpcy4gQW55IG90aGVyIG5vbi1zdGFuZGFyZCBwYXJhbWV0ZXJzIGNhbiBiZSBmb3VuZCB1bmRlciB0aGUgZXh0cmEgbWVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKlxuICogdmFyIHVyaSA9IG5ldyBVUkkoJ2JpdGNvaW46MTJBMU15ZlhiVzZSaGRSQVpFcW9mYWM1akNRUWp3RVBCdT9hbW91bnQ9MS4yJyk7XG4gKiBjb25zb2xlLmxvZyh1cmkuYWRkcmVzcywgdXJpLmFtb3VudCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGRhdGEgLSBBIGJpdGNvaW4gVVJJIHN0cmluZyBvciBhbiBPYmplY3RcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSBrbm93blBhcmFtcyAtIFJlcXVpcmVkIG5vbi1zdGFuZGFyZCBwYXJhbXNcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBiaXRjb2luIGFkZHJlc3NcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBhbW91bnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBVbmtub3duIHJlcXVpcmVkIGFyZ3VtZW50XG4gKiBAcmV0dXJucyB7VVJJfSBBIG5ldyB2YWxpZCBhbmQgZnJvemVuIGluc3RhbmNlIG9mIFVSSVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBVUkkgPSBmdW5jdGlvbihkYXRhLCBrbm93blBhcmFtcykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVVJJKSkge1xuICAgIHJldHVybiBuZXcgVVJJKGRhdGEsIGtub3duUGFyYW1zKTtcbiAgfVxuXG4gIHRoaXMuZXh0cmFzID0ge307XG4gIHRoaXMua25vd25QYXJhbXMgPSBrbm93blBhcmFtcyB8fCBbXTtcbiAgdGhpcy5hZGRyZXNzID0gdGhpcy5uZXR3b3JrID0gdGhpcy5hbW91bnQgPSB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuXG4gIGlmICh0eXBlb2YoZGF0YSkgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHBhcmFtcyA9IFVSSS5wYXJzZShkYXRhKTtcbiAgICBpZiAocGFyYW1zLmFtb3VudCkge1xuICAgICAgcGFyYW1zLmFtb3VudCA9IHRoaXMuX3BhcnNlQW1vdW50KHBhcmFtcy5hbW91bnQpO1xuICAgIH1cbiAgICB0aGlzLl9mcm9tT2JqZWN0KHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuX2Zyb21PYmplY3QoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0LicpO1xuICB9XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgVVJJIGZyb20gYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gSlNPTiBzdHJpbmcgb3Igb2JqZWN0IG9mIHRoZSBVUklcbiAqIEByZXR1cm5zIHtVUkl9IEEgbmV3IGluc3RhbmNlIG9mIGEgVVJJXG4gKi9cblVSSS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgaWYgKHR5cGVvZihzdHIpICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkkoc3RyKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYSBVUkkgZnJvbSBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIG9iamVjdCBvZiB0aGUgVVJJXG4gKiBAcmV0dXJucyB7VVJJfSBBIG5ldyBpbnN0YW5jZSBvZiBhIFVSSVxuICovXG5VUkkuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3QoanNvbikge1xuICByZXR1cm4gbmV3IFVSSShqc29uKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYml0Y29pbiBVUkkgc3RyaW5nIGlzIHZhbGlkXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqXG4gKiB2YXIgdmFsaWQgPSBVUkkuaXNWYWxpZCgnYml0Y29pbjoxMkExTXlmWGJXNlJoZFJBWkVxb2ZhYzVqQ1FRandFUEJ1Jyk7XG4gKiAvLyB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGRhdGEgLSBBIGJpdGNvaW4gVVJJIHN0cmluZyBvciBhbiBPYmplY3RcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSBrbm93blBhcmFtcyAtIFJlcXVpcmVkIG5vbi1zdGFuZGFyZCBwYXJhbXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXN1bHQgb2YgdXJpIHZhbGlkYXRpb25cbiAqL1xuVVJJLmlzVmFsaWQgPSBmdW5jdGlvbihhcmcsIGtub3duUGFyYW1zKSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSSShhcmcsIGtub3duUGFyYW1zKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgYml0Y29pbiBVUkkgc3RyaW5nIGludG8gYSBzaW1wbGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBBIGJpdGNvaW4gVVJJIHN0cmluZ1xuICogQHRocm93cyB7VHlwZUVycm9yfSBJbnZhbGlkIGJpdGNvaW4gVVJJXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgcGFyc2VkIHBhcmFtc1xuICovXG5VUkkucGFyc2UgPSBmdW5jdGlvbih1cmkpIHtcbiAgdmFyIGluZm8gPSBVUkwucGFyc2UodXJpLCB0cnVlKTtcblxuICBpZiAoaW5mby5wcm90b2NvbCAhPT0gJ2JpdGNvaW46Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYml0Y29pbiBVUkknKTtcbiAgfVxuXG4gIC8vIHdvcmthcm91bmQgdG8gaG9zdCBpbnNlbnNpdGl2ZW5lc3NcbiAgdmFyIGdyb3VwID0gL1teOl0qOlxcLz9cXC8/KFteP10qKS8uZXhlYyh1cmkpO1xuICBpbmZvLnF1ZXJ5LmFkZHJlc3MgPSBncm91cCAmJiBncm91cFsxXSB8fCB1bmRlZmluZWQ7XG5cbiAgcmV0dXJuIGluZm8ucXVlcnk7XG59O1xuXG5VUkkuTWVtYmVycyA9IFsnYWRkcmVzcycsICdhbW91bnQnLCAnbWVzc2FnZScsICdsYWJlbCcsICdyJ107XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gbG9hZCB0aGUgVVJJIGluc3RhbmNlIHdpdGggYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3Qgd2l0aCB0aGUgaW5mb3JtYXRpb25cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBiaXRjb2luIGFkZHJlc3NcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBhbW91bnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBVbmtub3duIHJlcXVpcmVkIGFyZ3VtZW50XG4gKi9cblVSSS5wcm90b3R5cGUuX2Zyb21PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG5cbiAgaWYgKCFBZGRyZXNzLmlzVmFsaWQob2JqLmFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBiaXRjb2luIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRoaXMuYWRkcmVzcyA9IG5ldyBBZGRyZXNzKG9iai5hZGRyZXNzKTtcbiAgdGhpcy5uZXR3b3JrID0gdGhpcy5hZGRyZXNzLm5ldHdvcms7XG4gIHRoaXMuYW1vdW50ID0gb2JqLmFtb3VudDtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGtleSA9PT0gJ2FkZHJlc3MnIHx8IGtleSA9PT0gJ2Ftb3VudCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgvXnJlcS0vLmV4ZWMoa2V5KSAmJiB0aGlzLmtub3duUGFyYW1zLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHJlcXVpcmVkIGFyZ3VtZW50ICcgKyBrZXkpO1xuICAgIH1cblxuICAgIHZhciBkZXN0aW5hdGlvbiA9IFVSSS5NZW1iZXJzLmluZGV4T2Yoa2V5KSA+IC0xID8gdGhpcyA6IHRoaXMuZXh0cmFzO1xuICAgIGRlc3RpbmF0aW9uW2tleV0gPSBvYmpba2V5XTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBCVEMgc3RyaW5nIGFtb3VudCBpbnRvIHNhdG9zaGlzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIEFtb3VudCBCVEMgc3RyaW5nXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IEludmFsaWQgYW1vdW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbW91bnQgcmVwcmVzZW50ZWQgaW4gc2F0b3NoaXNcbiAqL1xuVVJJLnByb3RvdHlwZS5fcGFyc2VBbW91bnQgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgYW1vdW50ID0gTnVtYmVyKGFtb3VudCk7XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhbW91bnQnKTtcbiAgfVxuICByZXR1cm4gVW5pdC5mcm9tQlRDKGFtb3VudCkudG9TYXRvc2hpcygpO1xufTtcblxuVVJJLnByb3RvdHlwZS50b09iamVjdCA9IFVSSS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHZhciBqc29uID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVVJJLk1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IFVSSS5NZW1iZXJzW2ldO1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KG0pICYmIHR5cGVvZih0aGlzW21dKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGpzb25bbV0gPSB0aGlzW21dLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIF8uZXh0ZW5kKGpzb24sIHRoaXMuZXh0cmFzKTtcbiAgcmV0dXJuIGpzb247XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVVJJXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gQml0Y29pbiBVUkkgc3RyaW5nXG4gKi9cblVSSS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHF1ZXJ5ID0ge307XG4gIGlmICh0aGlzLmFtb3VudCkge1xuICAgIHF1ZXJ5LmFtb3VudCA9IFVuaXQuZnJvbVNhdG9zaGlzKHRoaXMuYW1vdW50KS50b0JUQygpO1xuICB9XG4gIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICBxdWVyeS5tZXNzYWdlID0gdGhpcy5tZXNzYWdlO1xuICB9XG4gIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgcXVlcnkubGFiZWwgPSB0aGlzLmxhYmVsO1xuICB9XG4gIGlmICh0aGlzLnIpIHtcbiAgICBxdWVyeS5yID0gdGhpcy5yO1xuICB9XG4gIF8uZXh0ZW5kKHF1ZXJ5LCB0aGlzLmV4dHJhcyk7XG5cbiAgcmV0dXJuIFVSTC5mb3JtYXQoe1xuICAgIHByb3RvY29sOiAnYml0Y29pbjonLFxuICAgIGhvc3Q6IHRoaXMuYWRkcmVzcyxcbiAgICBxdWVyeTogcXVlcnlcbiAgfSk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCaXRjb2luIFVSSVxuICovXG5VUkkucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8VVJJOiAnICsgdGhpcy50b1N0cmluZygpICsgJz4nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVUkk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/uri.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/util/buffer.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\nvar js = __webpack_require__(/*! ./js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar $ = __webpack_require__(/*! ./preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nfunction equals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = {\n  /**\n   * Fill a buffer with a value.\n   *\n   * @param {Buffer} buffer\n   * @param {number} value\n   * @return {Buffer}\n   */\n  fill: function fill(buffer, value) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    $.checkArgumentType(value, 'number', 'value');\n    var length = buffer.length;\n    for (var i = 0; i < length; i++) {\n      buffer[i] = value;\n    }\n    return buffer;\n  },\n\n  /**\n   * Return a copy of a buffer\n   *\n   * @param {Buffer} original\n   * @return {Buffer}\n   */\n  copy: function(original) {\n    var buffer = Buffer.alloc(original.length);\n    original.copy(buffer);\n    return buffer;\n  },\n\n  /**\n   * Returns true if the given argument is an instance of a buffer. Tests for\n   * both node's Buffer and Uint8Array\n   *\n   * @param {*} arg\n   * @return {boolean}\n   */\n  isBuffer: function isBuffer(arg) {\n    return buffer.Buffer.isBuffer(arg) || arg instanceof Uint8Array;\n  },\n\n  /**\n   * Returns a zero-filled byte array\n   *\n   * @param {number} bytes\n   * @return {Buffer}\n   */\n  emptyBuffer: function emptyBuffer(bytes) {\n    $.checkArgumentType(bytes, 'number', 'bytes');\n    var result = Buffer.alloc(bytes);\n    for (var i = 0; i < bytes; i++) {\n      result.write('\\0', i);\n    }\n    return result;\n  },\n\n  /**\n   * Concatenates a buffer\n   *\n   * Shortcut for <tt>buffer.Buffer.concat</tt>\n   */\n  concat: buffer.Buffer.concat,\n\n  equals: equals,\n  equal: equals,\n\n  /**\n   * Transforms a number from 0 to 255 into a Buffer of size 1 with that value\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {\n    $.checkArgumentType(integer, 'number', 'integer');\n    return Buffer.from([integer & 0xff]);\n  },\n\n  /**\n   * Transform a 4-byte integer into a Buffer of length 4.\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsBuffer: function integerAsBuffer(integer) {\n    $.checkArgumentType(integer, 'number', 'integer');\n    var bytes = [];\n    bytes.push((integer >> 24) & 0xff);\n    bytes.push((integer >> 16) & 0xff);\n    bytes.push((integer >> 8) & 0xff);\n    bytes.push(integer & 0xff);\n    return Buffer.from(bytes);\n  },\n\n  /**\n   * Transform the first 4 values of a Buffer into a number, in little endian encoding\n   *\n   * @param {Buffer} buffer\n   * @return {number}\n   */\n  integerFromBuffer: function integerFromBuffer(buffer) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    return buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];\n  },\n\n  /**\n   * Transforms the first byte of an array into a number ranging from -128 to 127\n   * @param {Buffer} buffer\n   * @return {number}\n   */\n  integerFromSingleByteBuffer: function integerFromBuffer(buffer) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    return buffer[0];\n  },\n\n  /**\n   * Transforms a buffer into a string with a number in hexa representation\n   *\n   * Shorthand for <tt>buffer.toString('hex')</tt>\n   *\n   * @param {Buffer} buffer\n   * @return {string}\n   */\n  bufferToHex: function bufferToHex(buffer) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    return buffer.toString('hex');\n  },\n\n  /**\n   * Reverse a buffer\n   * @param {Buffer} param\n   * @return {Buffer}\n   */\n  reverse: function reverse(param) {\n    return (Buffer.from(param)).reverse();\n  },\n};\n\nmodule.exports.NULL_HASH = module.exports.fill(Buffer.alloc(32), 0);\nmodule.exports.EMPTY_BUFFER = Buffer.alloc(0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3V0aWwvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7O0FBRTdCLFNBQVMsbUJBQU8sQ0FBQyw2REFBTTtBQUN2QixRQUFRLG1CQUFPLENBQUMsbUZBQWlCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsd0JBQXdCO0FBQ3hCLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi91dGlsL2J1ZmZlci5qcz9hNTZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIganMgPSByZXF1aXJlKCcuL2pzJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vcHJlY29uZGl0aW9ucycpO1xuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsZW5ndGggPSBhLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEZpbGwgYSBidWZmZXIgd2l0aCBhIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAqL1xuICBmaWxsOiBmdW5jdGlvbiBmaWxsKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGJ1ZmZlciwgJ0J1ZmZlcicsICdidWZmZXInKTtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKHZhbHVlLCAnbnVtYmVyJywgJ3ZhbHVlJyk7XG4gICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmZmVyW2ldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvcHkgb2YgYSBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IG9yaWdpbmFsXG4gICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhvcmlnaW5hbC5sZW5ndGgpO1xuICAgIG9yaWdpbmFsLmNvcHkoYnVmZmVyKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGEgYnVmZmVyLiBUZXN0cyBmb3JcbiAgICogYm90aCBub2RlJ3MgQnVmZmVyIGFuZCBVaW50OEFycmF5XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYXJnXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0J1ZmZlcjogZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYXJnKSB8fCBhcmcgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgemVyby1maWxsZWQgYnl0ZSBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNcbiAgICogQHJldHVybiB7QnVmZmVyfVxuICAgKi9cbiAgZW1wdHlCdWZmZXI6IGZ1bmN0aW9uIGVtcHR5QnVmZmVyKGJ5dGVzKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50VHlwZShieXRlcywgJ251bWJlcicsICdieXRlcycpO1xuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MoYnl0ZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykge1xuICAgICAgcmVzdWx0LndyaXRlKCdcXDAnLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGEgYnVmZmVyXG4gICAqXG4gICAqIFNob3J0Y3V0IGZvciA8dHQ+YnVmZmVyLkJ1ZmZlci5jb25jYXQ8L3R0PlxuICAgKi9cbiAgY29uY2F0OiBidWZmZXIuQnVmZmVyLmNvbmNhdCxcblxuICBlcXVhbHM6IGVxdWFscyxcbiAgZXF1YWw6IGVxdWFscyxcblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIG51bWJlciBmcm9tIDAgdG8gMjU1IGludG8gYSBCdWZmZXIgb2Ygc2l6ZSAxIHdpdGggdGhhdCB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZWdlclxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAqL1xuICBpbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyOiBmdW5jdGlvbiBpbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKGludGVnZXIpIHtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGludGVnZXIsICdudW1iZXInLCAnaW50ZWdlcicpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShbaW50ZWdlciAmIDB4ZmZdKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhbnNmb3JtIGEgNC1ieXRlIGludGVnZXIgaW50byBhIEJ1ZmZlciBvZiBsZW5ndGggNC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVnZXJcbiAgICogQHJldHVybiB7QnVmZmVyfVxuICAgKi9cbiAgaW50ZWdlckFzQnVmZmVyOiBmdW5jdGlvbiBpbnRlZ2VyQXNCdWZmZXIoaW50ZWdlcikge1xuICAgICQuY2hlY2tBcmd1bWVudFR5cGUoaW50ZWdlciwgJ251bWJlcicsICdpbnRlZ2VyJyk7XG4gICAgdmFyIGJ5dGVzID0gW107XG4gICAgYnl0ZXMucHVzaCgoaW50ZWdlciA+PiAyNCkgJiAweGZmKTtcbiAgICBieXRlcy5wdXNoKChpbnRlZ2VyID4+IDE2KSAmIDB4ZmYpO1xuICAgIGJ5dGVzLnB1c2goKGludGVnZXIgPj4gOCkgJiAweGZmKTtcbiAgICBieXRlcy5wdXNoKGludGVnZXIgJiAweGZmKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIGZpcnN0IDQgdmFsdWVzIG9mIGEgQnVmZmVyIGludG8gYSBudW1iZXIsIGluIGxpdHRsZSBlbmRpYW4gZW5jb2RpbmdcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBpbnRlZ2VyRnJvbUJ1ZmZlcjogZnVuY3Rpb24gaW50ZWdlckZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50VHlwZShidWZmZXIsICdCdWZmZXInLCAnYnVmZmVyJyk7XG4gICAgcmV0dXJuIGJ1ZmZlclswXSA8PCAyNCB8IGJ1ZmZlclsxXSA8PCAxNiB8IGJ1ZmZlclsyXSA8PCA4IHwgYnVmZmVyWzNdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoZSBmaXJzdCBieXRlIG9mIGFuIGFycmF5IGludG8gYSBudW1iZXIgcmFuZ2luZyBmcm9tIC0xMjggdG8gMTI3XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgaW50ZWdlckZyb21TaW5nbGVCeXRlQnVmZmVyOiBmdW5jdGlvbiBpbnRlZ2VyRnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGJ1ZmZlciwgJ0J1ZmZlcicsICdidWZmZXInKTtcbiAgICByZXR1cm4gYnVmZmVyWzBdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgYnVmZmVyIGludG8gYSBzdHJpbmcgd2l0aCBhIG51bWJlciBpbiBoZXhhIHJlcHJlc2VudGF0aW9uXG4gICAqXG4gICAqIFNob3J0aGFuZCBmb3IgPHR0PmJ1ZmZlci50b1N0cmluZygnaGV4Jyk8L3R0PlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGJ1ZmZlclRvSGV4OiBmdW5jdGlvbiBidWZmZXJUb0hleChidWZmZXIpIHtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGJ1ZmZlciwgJ0J1ZmZlcicsICdidWZmZXInKTtcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV2ZXJzZSBhIGJ1ZmZlclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcGFyYW1cbiAgICogQHJldHVybiB7QnVmZmVyfVxuICAgKi9cbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZShwYXJhbSkge1xuICAgIHJldHVybiAoQnVmZmVyLmZyb20ocGFyYW0pKS5yZXZlcnNlKCk7XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5OVUxMX0hBU0ggPSBtb2R1bGUuZXhwb3J0cy5maWxsKEJ1ZmZlci5hbGxvYygzMiksIDApO1xubW9kdWxlLmV4cG9ydHMuRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jKDApO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/util/js.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/util/js.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\n/**\n * Determines whether a string contains only hexadecimal values\n *\n * @name JSUtil.isHexa\n * @param {string} value\n * @return {boolean} true if the string is the hexa representation of a number\n */\nvar isHexa = function isHexa(value) {\n  if (!_.isString(value)) {\n    return false;\n  }\n  return /^[0-9a-fA-F]+$/.test(value);\n};\n\n/**\n * @namespace JSUtil\n */\nmodule.exports = {\n  /**\n   * Test if an argument is a valid JSON object. If it is, returns a truthy\n   * value (the json object decoded), so no double JSON.parse call is necessary\n   *\n   * @param {string} arg\n   * @return {Object|boolean} false if the argument is not a JSON string.\n   */\n  isValidJSON: function isValidJSON(arg) {\n    var parsed;\n    if (!_.isString(arg)) {\n      return false;\n    }\n    try {\n      parsed = JSON.parse(arg);\n    } catch (e) {\n      return false;\n    }\n    if (typeof(parsed) === 'object') {\n      return true;\n    }\n    return false;\n  },\n  isHexa: isHexa,\n  isHexaString: isHexa,\n\n  /**\n   * Clone an array\n   */\n  cloneArray: function(array) {\n    return [].concat(array);\n  },\n\n  /**\n   * Define immutable properties on a target object\n   *\n   * @param {Object} target - An object to be extended\n   * @param {Object} values - An object of properties\n   * @return {Object} The target object\n   */\n  defineImmutable: function defineImmutable(target, values) {\n    Object.keys(values).forEach(function(key){\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        value: values[key]\n      });\n    });\n    return target;\n  },\n  /**\n   * Checks that a value is a natural number, a positive integer or zero.\n   *\n   * @param {*} value\n   * @return {Boolean}\n   */\n  isNaturalNumber: function isNaturalNumber(value) {\n    return typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value &&\n      value >= 0;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3V0aWwvanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFROztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdXRpbC9qcy5qcz9hMDEwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgY29udGFpbnMgb25seSBoZXhhZGVjaW1hbCB2YWx1ZXNcbiAqXG4gKiBAbmFtZSBKU1V0aWwuaXNIZXhhXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHN0cmluZyBpcyB0aGUgaGV4YSByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlclxuICovXG52YXIgaXNIZXhhID0gZnVuY3Rpb24gaXNIZXhhKHZhbHVlKSB7XG4gIGlmICghXy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIC9eWzAtOWEtZkEtRl0rJC8udGVzdCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSlNVdGlsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVGVzdCBpZiBhbiBhcmd1bWVudCBpcyBhIHZhbGlkIEpTT04gb2JqZWN0LiBJZiBpdCBpcywgcmV0dXJucyBhIHRydXRoeVxuICAgKiB2YWx1ZSAodGhlIGpzb24gb2JqZWN0IGRlY29kZWQpLCBzbyBubyBkb3VibGUgSlNPTi5wYXJzZSBjYWxsIGlzIG5lY2Vzc2FyeVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnXG4gICAqIEByZXR1cm4ge09iamVjdHxib29sZWFufSBmYWxzZSBpZiB0aGUgYXJndW1lbnQgaXMgbm90IGEgSlNPTiBzdHJpbmcuXG4gICAqL1xuICBpc1ZhbGlkSlNPTjogZnVuY3Rpb24gaXNWYWxpZEpTT04oYXJnKSB7XG4gICAgdmFyIHBhcnNlZDtcbiAgICBpZiAoIV8uaXNTdHJpbmcoYXJnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShhcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZihwYXJzZWQpID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgaXNIZXhhOiBpc0hleGEsXG4gIGlzSGV4YVN0cmluZzogaXNIZXhhLFxuXG4gIC8qKlxuICAgKiBDbG9uZSBhbiBhcnJheVxuICAgKi9cbiAgY2xvbmVBcnJheTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGFycmF5KTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmaW5lIGltbXV0YWJsZSBwcm9wZXJ0aWVzIG9uIGEgdGFyZ2V0IG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gQW4gb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YXJnZXQgb2JqZWN0XG4gICAqL1xuICBkZWZpbmVJbW11dGFibGU6IGZ1bmN0aW9uIGRlZmluZUltbXV0YWJsZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZXNba2V5XVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgLyoqXG4gICAqIENoZWNrcyB0aGF0IGEgdmFsdWUgaXMgYSBuYXR1cmFsIG51bWJlciwgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8uXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzTmF0dXJhbE51bWJlcjogZnVuY3Rpb24gaXNOYXR1cmFsTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgIGlzRmluaXRlKHZhbHVlKSAmJlxuICAgICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlICYmXG4gICAgICB2YWx1ZSA+PSAwO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/util/js.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js":
/*!************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/util/preconditions.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nmodule.exports = {\n  checkState: function(condition, message) {\n    if (!condition) {\n      throw new errors.InvalidState(message);\n    }\n  },\n  checkArgument: function(condition, argumentName, message, docsPath) {\n    if (!condition) {\n      throw new errors.InvalidArgument(argumentName, message, docsPath);\n    }\n  },\n  checkArgumentType: function(argument, type, argumentName) {\n    argumentName = argumentName || '(unknown name)';\n    if (_.isString(type)) {\n      if (type === 'Buffer') {\n        var buffer = __webpack_require__(/*! buffer */ \"buffer\"); // './buffer' fails on cordova & RN\n        if (!buffer.Buffer.isBuffer(argument)) {\n          throw new errors.InvalidArgumentType(argument, type, argumentName);\n        }\n      } else if (typeof argument !== type && (argument && argument.constructor && argument.constructor.name !== type)) {\n        // Note that the constructor check is more reliable than the `instanceof` check below.\n        throw new errors.InvalidArgumentType(argument, type, argumentName);\n      }\n    } else {\n      if (!(argument instanceof type)) {\n        throw new errors.InvalidArgumentType(argument, type.name, argumentName);\n      }\n    }\n  },\n  isType: function(argument, type, argumentName) {\n    try {\n      this.checkArgumentType(argument, type, argumentName);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3V0aWwvcHJlY29uZGl0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLHFEQUFROztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsc0JBQVEsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3V0aWwvcHJlY29uZGl0aW9ucy5qcz83NTg5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoZWNrU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRTdGF0ZShtZXNzYWdlKTtcbiAgICB9XG4gIH0sXG4gIGNoZWNrQXJndW1lbnQ6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYXJndW1lbnROYW1lLCBtZXNzYWdlLCBkb2NzUGF0aCkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudChhcmd1bWVudE5hbWUsIG1lc3NhZ2UsIGRvY3NQYXRoKTtcbiAgICB9XG4gIH0sXG4gIGNoZWNrQXJndW1lbnRUeXBlOiBmdW5jdGlvbihhcmd1bWVudCwgdHlwZSwgYXJndW1lbnROYW1lKSB7XG4gICAgYXJndW1lbnROYW1lID0gYXJndW1lbnROYW1lIHx8ICcodW5rbm93biBuYW1lKSc7XG4gICAgaWYgKF8uaXNTdHJpbmcodHlwZSkpIHtcbiAgICAgIGlmICh0eXBlID09PSAnQnVmZmVyJykge1xuICAgICAgICB2YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7IC8vICcuL2J1ZmZlcicgZmFpbHMgb24gY29yZG92YSAmIFJOXG4gICAgICAgIGlmICghYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihhcmd1bWVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudFR5cGUoYXJndW1lbnQsIHR5cGUsIGFyZ3VtZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50ICE9PSB0eXBlICYmIChhcmd1bWVudCAmJiBhcmd1bWVudC5jb25zdHJ1Y3RvciAmJiBhcmd1bWVudC5jb25zdHJ1Y3Rvci5uYW1lICE9PSB0eXBlKSkge1xuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGNvbnN0cnVjdG9yIGNoZWNrIGlzIG1vcmUgcmVsaWFibGUgdGhhbiB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJlbG93LlxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudFR5cGUoYXJndW1lbnQsIHR5cGUsIGFyZ3VtZW50TmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKGFyZ3VtZW50IGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnRUeXBlKGFyZ3VtZW50LCB0eXBlLm5hbWUsIGFyZ3VtZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpc1R5cGU6IGZ1bmN0aW9uKGFyZ3VtZW50LCB0eXBlLCBhcmd1bWVudE5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jaGVja0FyZ3VtZW50VHlwZShhcmd1bWVudCwgdHlwZSwgYXJndW1lbnROYW1lKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/node_modules/bn.js/lib/bn.js":
/*!***************************************************************!*\
  !*** ./node_modules/bitcore-lib/node_modules/bn.js/lib/bn.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this.strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        r |= c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        r |= c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r |= c & 0xf;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toBuffer = function toBuffer (endian, length) {\n    assert(typeof Buffer !== 'undefined');\n    return this.toArrayLike(Buffer, endian, length);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new ArrayType(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      r.strip();\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxvREFBd0I7QUFDckMsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixrQkFBa0IsYUFBYTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUEsbUNBQW1DO0FBQ25DLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsY0FBYztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxNQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL25vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanM/NmQxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleCAoc3RyLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgPDw9IDQ7XG5cbiAgICAgIC8vICdhJyAtICdmJ1xuICAgICAgaWYgKGMgPj0gNDkgJiYgYyA8PSA1NCkge1xuICAgICAgICByIHw9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnIC0gJ0YnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcgJiYgYyA8PSAyMikge1xuICAgICAgICByIHw9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByIHw9IGMgJiAweGY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCkge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuICAgIHZhciBvZmYgPSAwO1xuICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSA2LCBqID0gMDsgaSA+PSBzdGFydDsgaSAtPSA2KSB7XG4gICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBpLCBpICsgNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAvLyBOT1RFOiBgMHgzZmZmZmZgIGlzIGludGVudGlvbmFsIGhlcmUsIDI2Yml0cyBtYXggc2hpZnQgKyAyNGJpdCBoZXggbGltYlxuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgICAgb2ZmICs9IDI0O1xuICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgKyA2ICE9PSBzdGFydCkge1xuICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgc3RhcnQsIGkgKyA2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgciArPSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgIHIgKz0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgKz0gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG4gICAgICBsaW1iTGVuKys7XG4gICAgfVxuICAgIGxpbWJMZW4tLTtcbiAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gICAgdmFyIHdvcmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgIHZhciBwb3cgPSAxO1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcbiAgICAgICAgcG93ICo9IGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+JztcbiAgfTtcblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2RuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSByICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG4gICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG4gICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuICAgIHZhciBsaXR0bGVFbmRpYW4gPSBlbmRpYW4gPT09ICdsZSc7XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheVR5cGUocmVxTGVuZ3RoKTtcblxuICAgIHZhciBiLCBpO1xuICAgIHZhciBxID0gdGhpcy5jbG9uZSgpO1xuICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG4gICAgICAvLyBBc3N1bWUgYmlnLWVuZGlhblxuICAgICAgZm9yIChpID0gMDsgaSA8IHJlcUxlbmd0aCAtIGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbcmVxTGVuZ3RoIC0gaSAtIDFdID0gYjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW2ldID0gYjtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCByZXFMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgaWYgKE1hdGguY2x6MzIpIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHZhciB0ID0gdztcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgICByICs9IDEzO1xuICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDQwKSB7XG4gICAgICAgIHIgKz0gNztcbiAgICAgICAgdCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgICAgciArPSA0O1xuICAgICAgICB0ID4+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgICAgciArPSAyO1xuICAgICAgICB0ID4+Pj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByICsgdDtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuICAgIC8vIFNob3J0LWN1dFxuICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgICByICs9IDc7XG4gICAgICB0ID4+Pj0gNztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbiAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG4gICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdICYgKDEgPDwgd2JpdCkpID4+PiB3Yml0O1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcbiAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuICB9O1xuXG4gIC8vIFNldCBgYml0YCBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4gIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG4gIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBhID0gc2VsZi53b3JkcztcbiAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICB2YXIgbyA9IG91dC53b3JkcztcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIGxvO1xuICAgIHZhciBtaWQ7XG4gICAgdmFyIGhpO1xuICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcbiAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcbiAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcbiAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcbiAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcbiAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcbiAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcbiAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgIHZhciBhNyA9IGFbN10gfCAwO1xuICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcbiAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcbiAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcbiAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcbiAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcbiAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcbiAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgIHZhciBiMyA9IGJbM10gfCAwO1xuICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcbiAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcbiAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcbiAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcbiAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICAgIHZhciBiNyA9IGJbN10gfCAwO1xuICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcbiAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcbiAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcbiAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gMTk7XG4gICAgLyogayA9IDAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcbiAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcbiAgICB3MCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG4gICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG4gICAgdzEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcbiAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcbiAgICB3MiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcbiAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcbiAgICB3MyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG4gICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG4gICAgdzQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcbiAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgICB3NSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcbiAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgICB3NiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG4gICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG4gICAgdzcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcbiAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgICB3OCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDkgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgICB3OSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuICAgIHcxMCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDExICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gICAgdzExICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuICAgIHcxMiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuICAgIHcxMyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuICAgIHcxNSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuICAgIHcxNiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gICAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcbiAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuICAgIHcxOCAmPSAweDNmZmZmZmY7XG4gICAgb1swXSA9IHcwO1xuICAgIG9bMV0gPSB3MTtcbiAgICBvWzJdID0gdzI7XG4gICAgb1szXSA9IHczO1xuICAgIG9bNF0gPSB3NDtcbiAgICBvWzVdID0gdzU7XG4gICAgb1s2XSA9IHc2O1xuICAgIG9bN10gPSB3NztcbiAgICBvWzhdID0gdzg7XG4gICAgb1s5XSA9IHc5O1xuICAgIG9bMTBdID0gdzEwO1xuICAgIG9bMTFdID0gdzExO1xuICAgIG9bMTJdID0gdzEyO1xuICAgIG9bMTNdID0gdzEzO1xuICAgIG9bMTRdID0gdzE0O1xuICAgIG9bMTVdID0gdzE1O1xuICAgIG9bMTZdID0gdzE2O1xuICAgIG9bMTddID0gdzE3O1xuICAgIG9bMThdID0gdzE4O1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBvWzE5XSA9IGM7XG4gICAgICBvdXQubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgLy8gUG9seWZpbGwgY29tYlxuICBpZiAoIU1hdGguaW11bCkge1xuICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGhuY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgICAgaG5jYXJyeSA9IDA7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgY2FycnkgPSBuY2Fycnk7XG4gICAgICBuY2FycnkgPSBobmNhcnJ5O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gIH1cblxuICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcbiAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbiAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcbiAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG4gICAgdmFyIHJiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcbiAgICAgIHggPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJiO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cbiAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cbiAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cbiAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICAgIHJvID0gcng7XG5cbiAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcbiAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgcnR3ZGZfID0gcng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcbiAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcbiAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG4gICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICAgIHQgPSBpd3NbaV07XG5cbiAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICBjYXJyeTtcblxuICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cztcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICByd3NbaV0gPSAwO1xuICAgIH1cblxuICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcGhbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwaDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG4gICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgICBybXdzLmxlbmd0aCA9IE47XG5cbiAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgIHJ3c3RbaV0gPSByeDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcbiAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cbiAgICAvLyBDYXJyeVxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnRcbiAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0XG4gIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcbiAgfTtcblxuICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICAgIHJldHVybiAhISh3ICYgcSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbiAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHMrKztcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuICB9O1xuXG4gIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDwgbnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pc3VibihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcbiAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAgIC8vIENhcnJ5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYXJyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzICgpIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuICAgIHZhciB3O1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcbiAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB2YXIgcTtcblxuICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIGEgPSBkaWZmO1xuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAgIC8vICgweDdmZmZmZmYpXG4gICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBxai0tO1xuICAgICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocSkge1xuICAgICAgcS5zdHJpcCgpO1xuICAgIH1cbiAgICBhLnN0cmlwKCk7XG5cbiAgICAvLyBEZW5vcm1hbGl6ZVxuICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuICAgICAgYS5pdXNocm4oc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgIG1vZDogYVxuICAgIH07XG4gIH07XG5cbiAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcbiAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG4gIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2RcbiAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcbiAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiBuZXcgQk4oMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRpdiwgbW9kLCByZXM7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaWFkZChudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiByZXMubW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlzdWIobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG4gICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbiAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuICBCTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG4gIH07XG5cbiAgLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcbiAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICAgIHZhciBoYWxmID0gbnVtLnVzaHJuKDEpO1xuICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcbiAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAgIC8vIFJvdW5kIGRvd25cbiAgICBpZiAoY21wIDwgMCB8fCByMiA9PT0gMSAmJiBjbXAgPT09IDApIHJldHVybiBkbS5kaXY7XG5cbiAgICAvLyBSb3VuZCB1cFxuICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuICBCTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2biAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIHggPSB0aGlzO1xuICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKHgubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHggPSB4LnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQSAqIHggKyBCICogeSA9IHhcbiAgICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG4gICAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgICB2YXIgZyA9IDA7XG5cbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgICB4Lml1c2hybigxKTtcbiAgICAgIHkuaXVzaHJuKDEpO1xuICAgICAgKytnO1xuICAgIH1cblxuICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgeC5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEEuaXNPZGQoKSB8fCBCLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEEuaWFkZCh5cCk7XG4gICAgICAgICAgICBCLmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEEuaXVzaHJuKDEpO1xuICAgICAgICAgIEIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgeS5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEMuaWFkZCh5cCk7XG4gICAgICAgICAgICBELmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEMuaXVzaHJuKDEpO1xuICAgICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICAgIHguaXN1Yih5KTtcbiAgICAgICAgQS5pc3ViKEMpO1xuICAgICAgICBCLmlzdWIoRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LmlzdWIoeCk7XG4gICAgICAgIEMuaXN1YihBKTtcbiAgICAgICAgRC5pc3ViKEIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhOiBDLFxuICAgICAgYjogRCxcbiAgICAgIGdjZDogeS5pdXNobG4oZylcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbiAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcbiAgQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGEgPSBhLnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICAgIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYS5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGIuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG4gICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4Mi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgICAgYS5pc3ViKGIpO1xuICAgICAgICB4MS5pc3ViKHgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIuaXN1YihhKTtcbiAgICAgICAgeDIuaXN1Yih4MSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcztcbiAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG4gICAgICByZXMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0geDI7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIG51bS5hYnMoKTtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtLmNsb25lKCk7XG4gICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgYi5uZWdhdGl2ZSA9IDA7XG5cbiAgICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cbiAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgICAgYS5pdXNocm4oMSk7XG4gICAgICBiLml1c2hybigxKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICBhLml1c2hybigxKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgICB2YXIgdCA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGEuaXN1YihiKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG4gIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbiAgfTtcblxuICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG4gIEJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcbiAgfTtcblxuICAvLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG4gIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG4gICAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICAgIHZhciBjYXJyeSA9IHE7XG4gICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdyArPSBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG4gICAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbiAobnVtKSB7XG4gICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKSByZXR1cm4gMTtcblxuICAgIHRoaXMuc3RyaXAoKTtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG51bSA9IC1udW07XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbiAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cbiAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbiAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJlcyA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4gIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuICAvL1xuICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcbiAgICB0aGlzLnJlZCA9IGN0eDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgfTtcblxuICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcbiAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG4gIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuICB9O1xuXG4gIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG4gIHZhciBwcmltZXMgPSB7XG4gICAgazI1NjogbnVsbCxcbiAgICBwMjI0OiBudWxsLFxuICAgIHAxOTI6IG51bGwsXG4gICAgcDI1NTE5OiBudWxsXG4gIH07XG5cbiAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG4gIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuICAgIC8vIFAgPSAyIF4gTiAtIEtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICB9XG5cbiAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG4gICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcbiAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICAgIHZhciByID0gbnVtO1xuICAgIHZhciBybGVuO1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgci53b3Jkc1swXSA9IDA7XG4gICAgICByLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICByLmlzdWIodGhpcy5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5zdHJpcCgpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcbiAgfTtcblxuICBmdW5jdGlvbiBLMjU2ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnazI1NicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbiAgfVxuICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG4gIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cbiAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG4gICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICB9XG4gICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG4gICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG4gICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHByZXYgPj4+PSAyMjtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcbiAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICB9XG4gIH07XG5cbiAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICAgIHZhciBsbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcbiAgICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBmdW5jdGlvbiBQMjI0ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDIyNCcsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbiAgfVxuICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAxOTIgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMTkyJyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuICB9XG4gIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcbiAgICAvLyAyIF4gMjU1IC0gMTlcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnMjU1MTknLFxuICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbiAgfVxuICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cbiAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxM1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcbiAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgICAgaGkgPj4+PSAyNjtcblxuICAgICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgICBjYXJyeSA9IGhpO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG4gIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG4gICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gICAgdmFyIHByaW1lO1xuICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcbiAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gICAgcmV0dXJuIHByaW1lO1xuICB9O1xuXG4gIC8vXG4gIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuICAvL1xuICBmdW5jdGlvbiBSZWQgKG0pIHtcbiAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcbiAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG4gICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICAgIHJldHVybiBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/node_modules/bn.js/lib/bn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/node_modules/bs58/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/bitcore-lib/node_modules/bs58/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/bitcore-lib/node_modules/bs58/node_modules/base-x/src/index.js\")\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxtQkFBTyxDQUFDLG1HQUFRO0FBQzVCOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/MDU5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/node_modules/bs58/node_modules/base-x/src/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/bitcore-lib/node_modules/bs58/node_modules/base-x/src/index.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbm9kZV9tb2R1bGVzL2JzNTgvbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRGQUE2QjtBQUMzQztBQUNBLGdDQUFnQztBQUNoQztBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxxQ0FBcUM7QUFDckMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL25vZGVfbW9kdWxlcy9iczU4L25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzPzY2OGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbi8vIEB0cy1pZ25vcmVcbnZhciBfQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7IHNvdXJjZSA9IF9CdWZmZXIuZnJvbShzb3VyY2UpIH1cbiAgICBpZiAoIV9CdWZmZXIuaXNCdWZmZXIoc291cmNlKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBCdWZmZXInKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gX0J1ZmZlci5hbGxvYygwKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAocHN6IDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbc291cmNlLmNoYXJDb2RlQXQocHN6KV1cbiAgICAgICAgICAgIC8vIEludmFsaWQgY2hhcmFjdGVyXG4gICAgICBpZiAoY2FycnkgPT09IDI1NSkgeyByZXR1cm4gfVxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDBcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYjI1Ni5cbiAgICB2YXIgaXQ0ID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrK1xuICAgIH1cbiAgICB2YXIgdmNoID0gX0J1ZmZlci5hbGxvY1Vuc2FmZSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmNoLmZpbGwoMHgwMCwgMCwgemVyb2VzKVxuICAgIHZhciBqID0gemVyb2VzXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXVxuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZylcbiAgICBpZiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2UnICsgQkFTRSArICcgY2hhcmFjdGVyJylcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/node_modules/bs58/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcore-lib/node_modules/inherits/inherits.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! util */ \"util\").inherits\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlFQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0cy5qcz8zNjM2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/package.json":
/*!***********************************************!*\
  !*** ./node_modules/bitcore-lib/package.json ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"bitcore-lib","version":"10.3.0","description":"A pure and powerful JavaScript Bitcoin library.","author":"BitPay <dev@bitpay.com>","main":"index.js","scripts":{"test":"gulp test","test:ci":"npm run test","coverage":"gulp coverage","build":"gulp","pub":"npm run build && npm publish"},"keywords":["bitcoin","transaction","address","p2p","ecies","cryptocurrency","blockchain","payment","bip21","bip32","bip37","bip69","bip70","multisig"],"repository":{"type":"git","url":"https://github.com/bitpay/bitcore/tree/master/packages/bitcore-lib"},"browser":{"request":"browser-request"},"dependencies":{"bech32":"=2.0.0","bn.js":"=4.11.8","bs58":"^4.0.1","buffer-compare":"=1.1.1","elliptic":"^6.5.3","inherits":"=2.0.1","lodash":"^4.17.20"},"devDependencies":{"bitcore-build":"^10.0.21","brfs":"^2.0.1","chai":"^4.2.0","gulp":"^4.0.0","sinon":"^7.1.1"},"license":"MIT","gitHead":"eafcf339de16d7b29642597c65670388825c306c"}');

/***/ })

};
;
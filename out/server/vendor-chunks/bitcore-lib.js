/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bitcore-lib";
exports.ids = ["vendor-chunks/bitcore-lib"];
exports.modules = {

/***/ "(ssr)/./node_modules/bitcore-lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bitcore-lib/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bitcore = module.exports;\n\n// module information\nbitcore.version = 'v' + (__webpack_require__(/*! ./package.json */ \"(ssr)/./node_modules/bitcore-lib/package.json\").version);\nbitcore.versionGuard = function(version) {\n  if (version !== undefined) {\n    var message = 'More than one instance of bitcore-lib found. ' +\n      'Please make sure to require bitcore-lib and check that submodules do' +\n      ' not also include their own bitcore-lib dependency.';\n    throw new Error(message);\n  }\n};\nbitcore.versionGuard(global._bitcore);\nglobal._bitcore = bitcore.version;\n\n// crypto\nbitcore.crypto = {};\nbitcore.crypto.BN = __webpack_require__(/*! ./lib/crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nbitcore.crypto.ECDSA = __webpack_require__(/*! ./lib/crypto/ecdsa */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\");\nbitcore.crypto.Schnorr = __webpack_require__(/*! ./lib/crypto/schnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/schnorr.js\");\nbitcore.crypto.Hash = __webpack_require__(/*! ./lib/crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nbitcore.crypto.Random = __webpack_require__(/*! ./lib/crypto/random */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\");\nbitcore.crypto.Point = __webpack_require__(/*! ./lib/crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nbitcore.crypto.Signature = __webpack_require__(/*! ./lib/crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nbitcore.crypto.TaggedHash = __webpack_require__(/*! ./lib/crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n// encoding\nbitcore.encoding = {};\nbitcore.encoding.Base58 = __webpack_require__(/*! ./lib/encoding/base58 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\");\nbitcore.encoding.Base58Check = __webpack_require__(/*! ./lib/encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nbitcore.encoding.BufferReader = __webpack_require__(/*! ./lib/encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nbitcore.encoding.BufferWriter = __webpack_require__(/*! ./lib/encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nbitcore.encoding.Varint = __webpack_require__(/*! ./lib/encoding/varint */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/varint.js\");\n\n// utilities\nbitcore.util = {};\nbitcore.util.buffer = __webpack_require__(/*! ./lib/util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nbitcore.util.js = __webpack_require__(/*! ./lib/util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nbitcore.util.preconditions = __webpack_require__(/*! ./lib/util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\n// errors thrown by the library\nbitcore.errors = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\n\n// main bitcoin library\nbitcore.Address = __webpack_require__(/*! ./lib/address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nbitcore.Block = __webpack_require__(/*! ./lib/block */ \"(ssr)/./node_modules/bitcore-lib/lib/block/index.js\");\nbitcore.MerkleBlock = __webpack_require__(/*! ./lib/block/merkleblock */ \"(ssr)/./node_modules/bitcore-lib/lib/block/merkleblock.js\");\nbitcore.BlockHeader = __webpack_require__(/*! ./lib/block/blockheader */ \"(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\");\nbitcore.HDPrivateKey = __webpack_require__(/*! ./lib/hdprivatekey.js */ \"(ssr)/./node_modules/bitcore-lib/lib/hdprivatekey.js\");\nbitcore.HDPublicKey = __webpack_require__(/*! ./lib/hdpublickey.js */ \"(ssr)/./node_modules/bitcore-lib/lib/hdpublickey.js\");\nbitcore.Message = __webpack_require__(/*! ./lib/message */ \"(ssr)/./node_modules/bitcore-lib/lib/message.js\");\nbitcore.Networks = __webpack_require__(/*! ./lib/networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nbitcore.Opcode = __webpack_require__(/*! ./lib/opcode */ \"(ssr)/./node_modules/bitcore-lib/lib/opcode.js\");\nbitcore.PrivateKey = __webpack_require__(/*! ./lib/privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\nbitcore.PublicKey = __webpack_require__(/*! ./lib/publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nbitcore.Script = __webpack_require__(/*! ./lib/script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nbitcore.Transaction = __webpack_require__(/*! ./lib/transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\");\nbitcore.URI = __webpack_require__(/*! ./lib/uri */ \"(ssr)/./node_modules/bitcore-lib/lib/uri.js\");\nbitcore.Unit = __webpack_require__(/*! ./lib/unit */ \"(ssr)/./node_modules/bitcore-lib/lib/unit.js\");\n\n// dependencies, subject to change\nbitcore.deps = {};\nbitcore.deps.bnjs = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nbitcore.deps.bs58 = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/index.js\");\nbitcore.deps.Buffer = Buffer;\nbitcore.deps.elliptic = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\nbitcore.deps._ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\n// Internal usage, exposed for testing/advanced tweaking\nbitcore.Transaction.sighash = __webpack_require__(/*! ./lib/transaction/sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQSx3QkFBd0Isb0dBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBaUI7QUFDN0MsdUJBQXVCLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ25ELHlCQUF5QixtQkFBTyxDQUFDLG9GQUFzQjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQXFCO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLGdGQUFvQjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyx3RkFBd0I7QUFDM0QsNEJBQTRCLG1CQUFPLENBQUMsMEZBQXlCOztBQUU3RDtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsc0ZBQXVCO0FBQ3pELCtCQUErQixtQkFBTyxDQUFDLGdHQUE0QjtBQUNuRSxnQ0FBZ0MsbUJBQU8sQ0FBQyxrR0FBNkI7QUFDckUsZ0NBQWdDLG1CQUFPLENBQUMsa0dBQTZCO0FBQ3JFLDBCQUEwQixtQkFBTyxDQUFDLHNGQUF1Qjs7QUFFekQ7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLDhFQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBZTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyw0RkFBMEI7O0FBRS9EO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWM7O0FBRXZDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsc0VBQWU7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWE7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsMEZBQXlCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDBGQUF5QjtBQUN2RCx1QkFBdUIsbUJBQU8sQ0FBQyxtRkFBdUI7QUFDdEQsc0JBQXNCLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3BELGtCQUFrQixtQkFBTyxDQUFDLHNFQUFlO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFnQjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBYztBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsMEVBQWlCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFjO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFtQjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsOERBQVc7QUFDakMsZUFBZSxtQkFBTyxDQUFDLGdFQUFZOztBQUVuQztBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsbURBQU87QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsZ0RBQU07QUFDbEM7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQywrREFBVTtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUTs7QUFFakM7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQyw4RkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9pbmRleC5qcz8yYjQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJpdGNvcmUgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8gbW9kdWxlIGluZm9ybWF0aW9uXG5iaXRjb3JlLnZlcnNpb24gPSAndicgKyByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5iaXRjb3JlLnZlcnNpb25HdWFyZCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ01vcmUgdGhhbiBvbmUgaW5zdGFuY2Ugb2YgYml0Y29yZS1saWIgZm91bmQuICcgK1xuICAgICAgJ1BsZWFzZSBtYWtlIHN1cmUgdG8gcmVxdWlyZSBiaXRjb3JlLWxpYiBhbmQgY2hlY2sgdGhhdCBzdWJtb2R1bGVzIGRvJyArXG4gICAgICAnIG5vdCBhbHNvIGluY2x1ZGUgdGhlaXIgb3duIGJpdGNvcmUtbGliIGRlcGVuZGVuY3kuJztcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5iaXRjb3JlLnZlcnNpb25HdWFyZChnbG9iYWwuX2JpdGNvcmUpO1xuZ2xvYmFsLl9iaXRjb3JlID0gYml0Y29yZS52ZXJzaW9uO1xuXG4vLyBjcnlwdG9cbmJpdGNvcmUuY3J5cHRvID0ge307XG5iaXRjb3JlLmNyeXB0by5CTiA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9ibicpO1xuYml0Y29yZS5jcnlwdG8uRUNEU0EgPSByZXF1aXJlKCcuL2xpYi9jcnlwdG8vZWNkc2EnKTtcbmJpdGNvcmUuY3J5cHRvLlNjaG5vcnIgPSByZXF1aXJlKCcuL2xpYi9jcnlwdG8vc2Nobm9ycicpO1xuYml0Y29yZS5jcnlwdG8uSGFzaCA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9oYXNoJyk7XG5iaXRjb3JlLmNyeXB0by5SYW5kb20gPSByZXF1aXJlKCcuL2xpYi9jcnlwdG8vcmFuZG9tJyk7XG5iaXRjb3JlLmNyeXB0by5Qb2ludCA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by9wb2ludCcpO1xuYml0Y29yZS5jcnlwdG8uU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9saWIvY3J5cHRvL3NpZ25hdHVyZScpO1xuYml0Y29yZS5jcnlwdG8uVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4vbGliL2NyeXB0by90YWdnZWRoYXNoJyk7XG5cbi8vIGVuY29kaW5nXG5iaXRjb3JlLmVuY29kaW5nID0ge307XG5iaXRjb3JlLmVuY29kaW5nLkJhc2U1OCA9IHJlcXVpcmUoJy4vbGliL2VuY29kaW5nL2Jhc2U1OCcpO1xuYml0Y29yZS5lbmNvZGluZy5CYXNlNThDaGVjayA9IHJlcXVpcmUoJy4vbGliL2VuY29kaW5nL2Jhc2U1OGNoZWNrJyk7XG5iaXRjb3JlLmVuY29kaW5nLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4vbGliL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xuYml0Y29yZS5lbmNvZGluZy5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuL2xpYi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcbmJpdGNvcmUuZW5jb2RpbmcuVmFyaW50ID0gcmVxdWlyZSgnLi9saWIvZW5jb2RpbmcvdmFyaW50Jyk7XG5cbi8vIHV0aWxpdGllc1xuYml0Y29yZS51dGlsID0ge307XG5iaXRjb3JlLnV0aWwuYnVmZmVyID0gcmVxdWlyZSgnLi9saWIvdXRpbC9idWZmZXInKTtcbmJpdGNvcmUudXRpbC5qcyA9IHJlcXVpcmUoJy4vbGliL3V0aWwvanMnKTtcbmJpdGNvcmUudXRpbC5wcmVjb25kaXRpb25zID0gcmVxdWlyZSgnLi9saWIvdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbi8vIGVycm9ycyB0aHJvd24gYnkgdGhlIGxpYnJhcnlcbmJpdGNvcmUuZXJyb3JzID0gcmVxdWlyZSgnLi9saWIvZXJyb3JzJyk7XG5cbi8vIG1haW4gYml0Y29pbiBsaWJyYXJ5XG5iaXRjb3JlLkFkZHJlc3MgPSByZXF1aXJlKCcuL2xpYi9hZGRyZXNzJyk7XG5iaXRjb3JlLkJsb2NrID0gcmVxdWlyZSgnLi9saWIvYmxvY2snKTtcbmJpdGNvcmUuTWVya2xlQmxvY2sgPSByZXF1aXJlKCcuL2xpYi9ibG9jay9tZXJrbGVibG9jaycpO1xuYml0Y29yZS5CbG9ja0hlYWRlciA9IHJlcXVpcmUoJy4vbGliL2Jsb2NrL2Jsb2NraGVhZGVyJyk7XG5iaXRjb3JlLkhEUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vbGliL2hkcHJpdmF0ZWtleS5qcycpO1xuYml0Y29yZS5IRFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vbGliL2hkcHVibGlja2V5LmpzJyk7XG5iaXRjb3JlLk1lc3NhZ2UgPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlJyk7XG5iaXRjb3JlLk5ldHdvcmtzID0gcmVxdWlyZSgnLi9saWIvbmV0d29ya3MnKTtcbmJpdGNvcmUuT3Bjb2RlID0gcmVxdWlyZSgnLi9saWIvb3Bjb2RlJyk7XG5iaXRjb3JlLlByaXZhdGVLZXkgPSByZXF1aXJlKCcuL2xpYi9wcml2YXRla2V5Jyk7XG5iaXRjb3JlLlB1YmxpY0tleSA9IHJlcXVpcmUoJy4vbGliL3B1YmxpY2tleScpO1xuYml0Y29yZS5TY3JpcHQgPSByZXF1aXJlKCcuL2xpYi9zY3JpcHQnKTtcbmJpdGNvcmUuVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL2xpYi90cmFuc2FjdGlvbicpO1xuYml0Y29yZS5VUkkgPSByZXF1aXJlKCcuL2xpYi91cmknKTtcbmJpdGNvcmUuVW5pdCA9IHJlcXVpcmUoJy4vbGliL3VuaXQnKTtcblxuLy8gZGVwZW5kZW5jaWVzLCBzdWJqZWN0IHRvIGNoYW5nZVxuYml0Y29yZS5kZXBzID0ge307XG5iaXRjb3JlLmRlcHMuYm5qcyA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5iaXRjb3JlLmRlcHMuYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKTtcbmJpdGNvcmUuZGVwcy5CdWZmZXIgPSBCdWZmZXI7XG5iaXRjb3JlLmRlcHMuZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpO1xuYml0Y29yZS5kZXBzLl8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuLy8gSW50ZXJuYWwgdXNhZ2UsIGV4cG9zZWQgZm9yIHRlc3RpbmcvYWR2YW5jZWQgdHdlYWtpbmdcbmJpdGNvcmUuVHJhbnNhY3Rpb24uc2lnaGFzaCA9IHJlcXVpcmUoJy4vbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2gnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/address.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/address.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar errors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nvar Bech32 = __webpack_require__(/*! ./encoding/bech32 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bech32.js\");\nvar Networks = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is one of\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),\n * `Address.PayToScriptHash` (the string `'scripthash'`),\n * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),\n * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).\n * The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,\n * and `isPayToWitnessScriptHash`.\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash, 'witnesspubkeyhash', or 'taproot'\n * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type, multisigType) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type, false, multisigType);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n\n  if (type && (\n    type !== Address.PayToPublicKeyHash\n    && type !== Address.PayToScriptHash\n    && type !== Address.PayToWitnessPublicKeyHash\n    && type !== Address.PayToWitnessScriptHash\n    && type !== Address.PayToTaproot)) {\n    throw new TypeError('Third argument must be \"pubkeyhash\", \"scripthash\", \"witnesspubkeyhash\", \"witnessscripthash\", or \"taproot\".');\n  }\n\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function(data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {\n    return Address._transformHash(data, network, type);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data, network, type);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof(data) === 'string') {\n    return Address._transformString(data, network, type);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n/** @static */\nAddress.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';\n/** @static */\nAddress.PayToWitnessScriptHash = 'witnessscripthash';\n/** @static */\nAddress.PayToTaproot = 'taproot';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} network - the name of the network associated\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function(hash, network, type) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20 && hash.length !== 32) {\n    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');\n  }\n  info.hashBuffer = hash;\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.type = type;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function(data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function(buffer) {\n  var version = {};\n\n  if (buffer.length > 21) {\n    var info = Bech32.decode(buffer.toString('utf8'));\n    if (info.version !== 0 && info.version !== 1) { // v1 == taproot\n      throw new TypeError('Only witness v0 and v1 addresses are supported.');\n    }\n\n    if (info.version === 0) {\n      if (info.data.length === 20) {\n        version.type = Address.PayToWitnessPublicKeyHash;\n      } else if (info.data.length === 32) {\n        version.type = Address.PayToWitnessScriptHash;\n      } else {\n        throw new TypeError('Witness data must be either 20 or 32 bytes.')\n      }\n    } else if (info.version === 1) {\n      if (info.data.length === 32) {\n        version.type = Address.PayToTaproot;\n      } else {\n        throw new TypeError('Witness data must be 32 bytes for v1');\n      }\n    } else {\n    }\n    version.network = Networks.get(info.prefix, 'bech32prefix');\n  } else {\n\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n    if (pubkeyhashNetwork) {\n      version.network = pubkeyhashNetwork;\n      version.type = Address.PayToPublicKeyHash;\n    } else if (scripthashNetwork) {\n      version.network = scripthashNetwork;\n      version.type = Address.PayToScriptHash;\n    }\n  }\n\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function(buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (buffer.length < 21) {\n    throw new TypeError('Address buffer is incorrect length.');\n  }\n\n  var networkObj = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (!bufferVersion.network || (networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey)) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  if (buffer.length > 21) {\n    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;\n  } else {\n    info.hashBuffer = buffer.slice(1);\n  }\n  info.network = networkObj || bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', 'scripthash', or 'taproot'\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function(pubkey, network, type) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash && type !== Address.PayToTaproot) {\n    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, scripthash, or taproot to transform public key.');\n  }\n  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {\n    throw new TypeError('Witness addresses must use compressed public keys.');\n  }\n  if (type === Address.PayToScriptHash) {\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());\n  } else if (type === Address.PayToTaproot) {\n    info.hashBuffer = pubkey.createTapTweak().tweakedPubKey;\n  } else {\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  }\n  info.type = type || Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored\n * @return {Address}\n */\nAddress.createMultisig = function(publicKeys, threshold, network, nestedWitness, type) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {\n    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');\n  }\n  if (nestedWitness || type === Address.PayToWitnessScriptHash) {\n    publicKeys = _.map(publicKeys, PublicKey);\n    for (var i = 0; i < publicKeys.length; i++) {\n      if (!publicKeys[i].compressed) {\n        throw new TypeError('Witness addresses must use compressed public keys.');\n      }\n    }\n  }\n  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);\n  if (nestedWitness) {\n    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);\n  }\n  return Address.payingTo(redeemScript, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function(data, network, type) {\n  if (typeof(data) !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n\n  if(data.length > 100) {\n    throw new TypeError('address string is too long');\n  }\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Unknown network');\n  }\n\n  data = data.trim();\n\n  try {\n    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);\n    return info;\n  } catch (e) {\n    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash || type === Address.PayToTaproot) {\n      throw e;\n    }\n  }\n\n  var addressBuffer = Base58Check.decode(data);\n  var info = Address._transformBuffer(addressBuffer, network, type);\n  return info;\n};\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function(data, network, type) {\n  var info = Address._transformPublicKey(data, network, type);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function(hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function(hash, network, type) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {\n      throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');\n  }\n  var type = type || Address.PayToScriptHash;\n  return new Address(info.hashBuffer, network, type);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function(script, network, type) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  var hash;\n  if (type === Address.PayToWitnessScriptHash) {\n    hash = Hash.sha256(script.toBuffer());\n  } else {\n    hash = Hash.sha256ripemd160(script.toBuffer());\n  }\n  var type = type || Address.PayToScriptHash;\n  return Address.fromScriptHash(hash, network, type);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function(buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function(str, network, type) {\n  var info = Address._transformString(str, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(\n    JSUtil.isHexa(obj.hash),\n    'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.'\n  );\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function(data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function(data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function() {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function() {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to witness public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessPublicKeyHash = function() {\n  return this.type === Address.PayToWitnessPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to witness script hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessScriptHash = function() {\n  return this.type === Address.PayToWitnessScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to Taproot script hash type\n * @returns {boolean}\n */\nAddress.prototype.isPayToTaproot = function() {\n  return this.type === Address.PayToTaproot;\n}\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\n    return Buffer.from(this.toString(), 'utf8')\n  }\n  var version = Buffer.from([this.network[this.type]]);\n  return Buffer.concat([version, this.hashBuffer]);\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a the string representation of the address\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toString = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash() || this.isPayToTaproot()) {\n    let prefix = this.network.bech32prefix;\n    let version = 0;\n    let encoding = Bech32.encodings.BECH32;\n    if (this.isPayToTaproot()) {\n      version = 1;\n      encoding = Bech32.encodings.BECH32M;\n    }\n    return Bech32.encode(prefix, version, this.hashBuffer, encoding);\n  }\n  return Base58Check.encode(this.toBuffer());\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function() {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\nmodule.exports = Address;\n\nvar Script = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFRO0FBQ3hCLFFBQVEsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLHNFQUFVO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDRGQUF3QjtBQUNsRCxhQUFhLG1CQUFPLENBQUMsa0ZBQW1CO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyxvRUFBWTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsMEVBQWU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFhOztBQUVyQztBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQixJQUFJLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxzRUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9hZGRyZXNzLmpzPzhiODAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyICQgPSByZXF1aXJlKCcuL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgQmFzZTU4Q2hlY2sgPSByZXF1aXJlKCcuL2VuY29kaW5nL2Jhc2U1OGNoZWNrJyk7XG52YXIgQmVjaDMyID0gcmVxdWlyZSgnLi9lbmNvZGluZy9iZWNoMzInKTtcbnZhciBOZXR3b3JrcyA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9jcnlwdG8vaGFzaCcpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9qcycpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vcHVibGlja2V5Jyk7XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYW4gYWRkcmVzcyBmcm9tIGFuIGFkZHJlc3MgU3RyaW5nIG9yIEJ1ZmZlciwgYSBwdWJsaWMga2V5IG9yIHNjcmlwdCBoYXNoIEJ1ZmZlcixcbiAqIG9yIGFuIGluc3RhbmNlIG9mIHtAbGluayBQdWJsaWNLZXl9IG9yIHtAbGluayBTY3JpcHR9LlxuICpcbiAqIFRoaXMgaXMgYW4gaW1tdXRhYmxlIGNsYXNzLCBhbmQgaWYgdGhlIGZpcnN0IHBhcmFtZXRlciBwcm92aWRlZCB0byB0aGlzIGNvbnN0cnVjdG9yIGlzIGFuXG4gKiBgQWRkcmVzc2AgaW5zdGFuY2UsIHRoZSBzYW1lIGFyZ3VtZW50IHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQW4gYWRkcmVzcyBoYXMgdHdvIGtleSBwcm9wZXJ0aWVzOiBgbmV0d29ya2AgYW5kIGB0eXBlYC4gVGhlIHR5cGUgaXMgb25lIG9mXG4gKiBgQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2hgICh2YWx1ZSBpcyB0aGUgYCdwdWJrZXloYXNoJ2Agc3RyaW5nKSxcbiAqIGBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaGAgKHRoZSBzdHJpbmcgYCdzY3JpcHRoYXNoJ2ApLFxuICogYEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaGAgKHRoZSBzdHJpbmcgYCd3aXRuZXNzcHVia2V5aGFzaCdgKSxcbiAqIG9yIGBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2hgICh0aGUgc3RyaW5nIGAnd2l0bmVzc3NjcmlwdGhhc2gnYCkuXG4gKiBUaGUgbmV0d29yayBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgTmV0d29ya30uXG4gKiBZb3UgY2FuIHF1aWNrbHkgY2hlY2sgd2hldGhlciBhbiBhZGRyZXNzIGlzIG9mIGEgZ2l2ZW4ga2luZCBieSB1c2luZyB0aGUgbWV0aG9kc1xuICogYGlzUGF5VG9QdWJsaWNLZXlIYXNoYCwgYGlzUGF5VG9TY3JpcHRIYXNoYCwgYGlzUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaGAsXG4gKiBhbmQgYGlzUGF5VG9XaXRuZXNzU2NyaXB0SGFzaGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIHZhbGlkYXRlIHRoYXQgYW4gaW5wdXQgZmllbGQgaXMgdmFsaWRcbiAqIHZhciBlcnJvciA9IEFkZHJlc3MuZ2V0VmFsaWRhdGlvbkVycm9yKGlucHV0LCAndGVzdG5ldCcpO1xuICogaWYgKCFlcnJvcikge1xuICogICB2YXIgYWRkcmVzcyA9IEFkZHJlc3MoaW5wdXQsICd0ZXN0bmV0Jyk7XG4gKiB9IGVsc2Uge1xuICogICAvLyBpbnZhbGlkIG5ldHdvcmsgb3IgY2hlY2tzdW0gKHR5cG8/KVxuICogICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NzYWdlO1xuICogfVxuICpcbiAqIC8vIGdldCBhbiBhZGRyZXNzIGZyb20gYSBwdWJsaWMga2V5XG4gKiB2YXIgYWRkcmVzcyA9IEFkZHJlc3MocHVibGljS2V5LCAndGVzdG5ldCcpLnRvU3RyaW5nKCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICogQHBhcmFtIHtOZXR3b3JrfFN0cmluZ3xudW1iZXI9fSBuZXR3b3JrIC0gVGhlIG5ldHdvcms6ICdsaXZlbmV0JyBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIFRoZSB0eXBlIG9mIGFkZHJlc3M6ICdzY3JpcHRoYXNoJywgJ3B1YmtleWhhc2gnLCB3aXRuZXNzc2NyaXB0aGFzaCwgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3RhcHJvb3QnXG4gKiBAcGFyYW0ge3N0cmluZz19IG11bHRpc2lnVHlwZSAtIFRoZSB0eXBlIG9mIG11bHRpc2lnOiAnc2NyaXB0aGFzaCcgb3IgJ3dpdG5lc3NzY3JpcHRoYXNoJ1xuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFkZHJlc3MoZGF0YSwgbmV0d29yaywgdHlwZSwgbXVsdGlzaWdUeXBlKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMiAqL1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWRkcmVzcykpIHtcbiAgICByZXR1cm4gbmV3IEFkZHJlc3MoZGF0YSwgbmV0d29yaywgdHlwZSk7XG4gIH1cblxuICBpZiAoXy5pc0FycmF5KGRhdGEpICYmIF8uaXNOdW1iZXIobmV0d29yaykpIHtcbiAgICByZXR1cm4gQWRkcmVzcy5jcmVhdGVNdWx0aXNpZyhkYXRhLCBuZXR3b3JrLCB0eXBlLCBmYWxzZSwgbXVsdGlzaWdUeXBlKTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQWRkcmVzcykge1xuICAgIC8vIEltbXV0YWJsZSBpbnN0YW5jZVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgJC5jaGVja0FyZ3VtZW50KGRhdGEsICdGaXJzdCBhcmd1bWVudCBpcyByZXF1aXJlZCwgcGxlYXNlIGluY2x1ZGUgYWRkcmVzcyBkYXRhLicsICdndWlkZS9hZGRyZXNzLmh0bWwnKTtcblxuICBpZiAobmV0d29yayAmJiAhTmV0d29ya3MuZ2V0KG5ldHdvcmspKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCIuJyk7XG4gIH1cblxuICBpZiAodHlwZSAmJiAoXG4gICAgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2hcbiAgICAmJiB0eXBlICE9PSBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaFxuICAgICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaFxuICAgICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaFxuICAgICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9UYXByb290KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXJkIGFyZ3VtZW50IG11c3QgYmUgXCJwdWJrZXloYXNoXCIsIFwic2NyaXB0aGFzaFwiLCBcIndpdG5lc3NwdWJrZXloYXNoXCIsIFwid2l0bmVzc3NjcmlwdGhhc2hcIiwgb3IgXCJ0YXByb290XCIuJyk7XG4gIH1cblxuICB2YXIgaW5mbyA9IHRoaXMuX2NsYXNzaWZ5QXJndW1lbnRzKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xuXG4gIC8vIHNldCBkZWZhdWx0cyBpZiBub3Qgc2V0XG4gIGluZm8ubmV0d29yayA9IGluZm8ubmV0d29yayB8fCBOZXR3b3Jrcy5nZXQobmV0d29yaykgfHwgTmV0d29ya3MuZGVmYXVsdE5ldHdvcms7XG4gIGluZm8udHlwZSA9IGluZm8udHlwZSB8fCB0eXBlIHx8IEFkZHJlc3MuUGF5VG9QdWJsaWNLZXlIYXNoO1xuXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xuICAgIGhhc2hCdWZmZXI6IGluZm8uaGFzaEJ1ZmZlcixcbiAgICBuZXR3b3JrOiBpbmZvLm5ldHdvcmssXG4gICAgdHlwZTogaW5mby50eXBlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gc3BsaXQgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50cyBvZiB0aGUgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Kn0gZGF0YSAtIFRoZSBlbmNvZGVkIGRhdGEgaW4gdmFyaW91cyBmb3JtYXRzXG4gKiBAcGFyYW0ge05ldHdvcmt8U3RyaW5nfG51bWJlcj19IG5ldHdvcmsgLSBUaGUgbmV0d29yazogJ2xpdmVuZXQnIG9yICd0ZXN0bmV0J1xuICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIFwiaW5mb1wiIG9iamVjdCB3aXRoIFwidHlwZVwiLCBcIm5ldHdvcmtcIiwgYW5kIFwiaGFzaEJ1ZmZlclwiXG4gKi9cbkFkZHJlc3MucHJvdG90eXBlLl9jbGFzc2lmeUFyZ3VtZW50cyA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmssIHR5cGUpIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG4gIC8vIHRyYW5zZm9ybSBhbmQgdmFsaWRhdGUgaW5wdXQgZGF0YVxuICBpZiAoKGRhdGEgaW5zdGFuY2VvZiBCdWZmZXIgfHwgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmIChkYXRhLmxlbmd0aCA9PT0gMjAgfHwgZGF0YS5sZW5ndGggPT09IDMyKSkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1IYXNoKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xuICB9IGVsc2UgaWYgKChkYXRhIGluc3RhbmNlb2YgQnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJiBkYXRhLmxlbmd0aCA+PSAyMSkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1CdWZmZXIoZGF0YSwgbmV0d29yaywgdHlwZSk7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFB1YmxpY0tleSkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1QdWJsaWNLZXkoZGF0YSwgbmV0d29yaywgdHlwZSk7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFNjcmlwdCkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1TY3JpcHQoZGF0YSwgbmV0d29yayk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKGRhdGEpID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1TdHJpbmcoZGF0YSwgbmV0d29yaywgdHlwZSk7XG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChkYXRhKSkge1xuICAgIHJldHVybiBBZGRyZXNzLl90cmFuc2Zvcm1PYmplY3QoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgaXMgYW4gdW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0LicpO1xuICB9XG59O1xuXG4vKiogQHN0YXRpYyAqL1xuQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2ggPSAncHVia2V5aGFzaCc7XG4vKiogQHN0YXRpYyAqL1xuQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2ggPSAnc2NyaXB0aGFzaCc7XG4vKiogQHN0YXRpYyAqL1xuQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoID0gJ3dpdG5lc3NwdWJrZXloYXNoJztcbi8qKiBAc3RhdGljICovXG5BZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2ggPSAnd2l0bmVzc3NjcmlwdGhhc2gnO1xuLyoqIEBzdGF0aWMgKi9cbkFkZHJlc3MuUGF5VG9UYXByb290ID0gJ3RhcHJvb3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoIC0gQW4gaW5zdGFuY2Ugb2YgYSBoYXNoIEJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBlaXRoZXIgJ3B1YmtleWhhc2gnLCAnc2NyaXB0aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsIG9yICd3aXRuZXNzc2NyaXB0aGFzaCdcbiAqIEBwYXJhbSB7TmV0d29yaz19IG5ldHdvcmsgLSB0aGUgbmFtZSBvZiB0aGUgbmV0d29yayBhc3NvY2lhdGVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyXG4gKiBAcHJpdmF0ZVxuICovXG5BZGRyZXNzLl90cmFuc2Zvcm1IYXNoID0gZnVuY3Rpb24oaGFzaCwgbmV0d29yaywgdHlwZSkge1xuICB2YXIgaW5mbyA9IHt9O1xuICBpZiAoIShoYXNoIGluc3RhbmNlb2YgQnVmZmVyKSAmJiAhKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3Mgc3VwcGxpZWQgaXMgbm90IGEgYnVmZmVyLicpO1xuICB9XG4gIGlmIChoYXNoLmxlbmd0aCAhPT0gMjAgJiYgaGFzaC5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRkcmVzcyBoYXNoYnVmZmVycyBtdXN0IGJlIGVpdGhlciAyMCBvciAzMiBieXRlcy4nKTtcbiAgfVxuICBpbmZvLmhhc2hCdWZmZXIgPSBoYXNoO1xuICBpbmZvLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQobmV0d29yaykgfHwgTmV0d29ya3MuZGVmYXVsdE5ldHdvcms7XG4gIGluZm8udHlwZSA9IHR5cGU7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYW4gYWRkcmVzcyBzZXJpYWxpemVkIHRocm91Z2ggYEFkZHJlc3MjdG9PYmplY3QoKWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YS5oYXNoIC0gdGhlIGhhc2ggdGhhdCB0aGlzIGFkZHJlc3MgZW5jb2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEudHlwZSAtIGVpdGhlciAncHVia2V5aGFzaCcsICdzY3JpcHRoYXNoJywgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3dpdG5lc3NzY3JpcHRoYXNoJ1xuICogQHBhcmFtIHtOZXR3b3JrPX0gZGF0YS5uZXR3b3JrIC0gdGhlIG5hbWUgb2YgdGhlIG5ldHdvcmsgYXNzb2NpYXRlZFxuICogQHJldHVybiB7QWRkcmVzc31cbiAqL1xuQWRkcmVzcy5fdHJhbnNmb3JtT2JqZWN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAkLmNoZWNrQXJndW1lbnQoZGF0YS5oYXNoIHx8IGRhdGEuaGFzaEJ1ZmZlciwgJ011c3QgcHJvdmlkZSBhIGBoYXNoYCBvciBgaGFzaEJ1ZmZlcmAgcHJvcGVydHknKTtcbiAgJC5jaGVja0FyZ3VtZW50KGRhdGEudHlwZSwgJ011c3QgcHJvdmlkZSBhIGB0eXBlYCBwcm9wZXJ0eScpO1xuICByZXR1cm4ge1xuICAgIGhhc2hCdWZmZXI6IGRhdGEuaGFzaCA/IEJ1ZmZlci5mcm9tKGRhdGEuaGFzaCwgJ2hleCcpIDogZGF0YS5oYXNoQnVmZmVyLFxuICAgIG5ldHdvcms6IE5ldHdvcmtzLmdldChkYXRhLm5ldHdvcmspIHx8IE5ldHdvcmtzLmRlZmF1bHROZXR3b3JrLFxuICAgIHR5cGU6IGRhdGEudHlwZVxuICB9O1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBkaXNjb3ZlciB0aGUgbmV0d29yayBhbmQgdHlwZSBiYXNlZCBvbiB0aGUgZmlyc3QgZGF0YSBieXRlXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIEFuIGluc3RhbmNlIG9mIGEgaGV4IGVuY29kZWQgYWRkcmVzcyBCdWZmZXJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IG5ldHdvcmsgYW5kIHR5cGVcbiAqIEBwcml2YXRlXG4gKi9cbkFkZHJlc3MuX2NsYXNzaWZ5RnJvbVZlcnNpb24gPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHZlcnNpb24gPSB7fTtcblxuICBpZiAoYnVmZmVyLmxlbmd0aCA+IDIxKSB7XG4gICAgdmFyIGluZm8gPSBCZWNoMzIuZGVjb2RlKGJ1ZmZlci50b1N0cmluZygndXRmOCcpKTtcbiAgICBpZiAoaW5mby52ZXJzaW9uICE9PSAwICYmIGluZm8udmVyc2lvbiAhPT0gMSkgeyAvLyB2MSA9PSB0YXByb290XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPbmx5IHdpdG5lc3MgdjAgYW5kIHYxIGFkZHJlc3NlcyBhcmUgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIGlmIChpbmZvLnZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmIChpbmZvLmRhdGEubGVuZ3RoID09PSAyMCkge1xuICAgICAgICB2ZXJzaW9uLnR5cGUgPSBBZGRyZXNzLlBheVRvV2l0bmVzc1B1YmxpY0tleUhhc2g7XG4gICAgICB9IGVsc2UgaWYgKGluZm8uZGF0YS5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgIHZlcnNpb24udHlwZSA9IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgZGF0YSBtdXN0IGJlIGVpdGhlciAyMCBvciAzMiBieXRlcy4nKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5mby52ZXJzaW9uID09PSAxKSB7XG4gICAgICBpZiAoaW5mby5kYXRhLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgdmVyc2lvbi50eXBlID0gQWRkcmVzcy5QYXlUb1RhcHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGRhdGEgbXVzdCBiZSAzMiBieXRlcyBmb3IgdjEnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgIH1cbiAgICB2ZXJzaW9uLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQoaW5mby5wcmVmaXgsICdiZWNoMzJwcmVmaXgnKTtcbiAgfSBlbHNlIHtcblxuICAgIHZhciBwdWJrZXloYXNoTmV0d29yayA9IE5ldHdvcmtzLmdldChidWZmZXJbMF0sICdwdWJrZXloYXNoJyk7XG4gICAgdmFyIHNjcmlwdGhhc2hOZXR3b3JrID0gTmV0d29ya3MuZ2V0KGJ1ZmZlclswXSwgJ3NjcmlwdGhhc2gnKTtcblxuICAgIGlmIChwdWJrZXloYXNoTmV0d29yaykge1xuICAgICAgdmVyc2lvbi5uZXR3b3JrID0gcHVia2V5aGFzaE5ldHdvcms7XG4gICAgICB2ZXJzaW9uLnR5cGUgPSBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaDtcbiAgICB9IGVsc2UgaWYgKHNjcmlwdGhhc2hOZXR3b3JrKSB7XG4gICAgICB2ZXJzaW9uLm5ldHdvcmsgPSBzY3JpcHRoYXNoTmV0d29yaztcbiAgICAgIHZlcnNpb24udHlwZSA9IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBiaXRjb2luIGFkZHJlc3MgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIEFuIGluc3RhbmNlIG9mIGEgaGV4IGVuY29kZWQgYWRkcmVzcyBCdWZmZXJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmV0d29yayAtIFRoZSBuZXR3b3JrOiAnbGl2ZW5ldCcgb3IgJ3Rlc3RuZXQnXG4gKiBAcGFyYW0ge3N0cmluZz19IHR5cGUgLSBUaGUgdHlwZTogJ3B1YmtleWhhc2gnLCAnc2NyaXB0aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsIG9yICd3aXRuZXNzc2NyaXB0aGFzaCdcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IGhhc2hCdWZmZXIsIG5ldHdvcmsgYW5kIHR5cGVcbiAqIEBwcml2YXRlXG4gKi9cbkFkZHJlc3MuX3RyYW5zZm9ybUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlciwgbmV0d29yaywgdHlwZSkge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogOSAqL1xuICB2YXIgaW5mbyA9IHt9O1xuICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpICYmICEoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBZGRyZXNzIHN1cHBsaWVkIGlzIG5vdCBhIGJ1ZmZlci4nKTtcbiAgfVxuXG4gIGlmIChidWZmZXIubGVuZ3RoIDwgMjEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBZGRyZXNzIGJ1ZmZlciBpcyBpbmNvcnJlY3QgbGVuZ3RoLicpO1xuICB9XG5cbiAgdmFyIG5ldHdvcmtPYmogPSBOZXR3b3Jrcy5nZXQobmV0d29yayk7XG4gIHZhciBidWZmZXJWZXJzaW9uID0gQWRkcmVzcy5fY2xhc3NpZnlGcm9tVmVyc2lvbihidWZmZXIpO1xuXG4gIGlmIChuZXR3b3JrICYmICFuZXR3b3JrT2JqKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBuZXR3b3JrJyk7XG4gIH1cblxuICBpZiAoIWJ1ZmZlclZlcnNpb24ubmV0d29yayB8fCAobmV0d29ya09iaiAmJiBuZXR3b3JrT2JqLnhwdWJrZXkgIT09IGJ1ZmZlclZlcnNpb24ubmV0d29yay54cHVia2V5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3MgaGFzIG1pc21hdGNoZWQgbmV0d29yayB0eXBlLicpO1xuICB9XG5cbiAgaWYgKCFidWZmZXJWZXJzaW9uLnR5cGUgfHwgKHR5cGUgJiYgdHlwZSAhPT0gYnVmZmVyVmVyc2lvbi50eXBlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3MgaGFzIG1pc21hdGNoZWQgdHlwZS4nKTtcbiAgfVxuXG4gIGlmIChidWZmZXIubGVuZ3RoID4gMjEpIHtcbiAgICBpbmZvLmhhc2hCdWZmZXIgPSBCZWNoMzIuZGVjb2RlKGJ1ZmZlci50b1N0cmluZygndXRmOCcpKS5kYXRhO1xuICB9IGVsc2Uge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgxKTtcbiAgfVxuICBpbmZvLm5ldHdvcmsgPSBuZXR3b3JrT2JqIHx8IGJ1ZmZlclZlcnNpb24ubmV0d29yaztcbiAgaW5mby50eXBlID0gYnVmZmVyVmVyc2lvbi50eXBlO1xuICByZXR1cm4gaW5mbztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGEge0BsaW5rIFB1YmxpY0tleX1cbiAqXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVia2V5IC0gQW4gaW5zdGFuY2Ugb2YgUHVibGljS2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEVpdGhlciAncHVia2V5aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsICdzY3JpcHRoYXNoJywgb3IgJ3RhcHJvb3QnXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyLCB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5BZGRyZXNzLl90cmFuc2Zvcm1QdWJsaWNLZXkgPSBmdW5jdGlvbihwdWJrZXksIG5ldHdvcmssIHR5cGUpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaWYgKCEocHVia2V5IGluc3RhbmNlb2YgUHVibGljS2V5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkZHJlc3MgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQdWJsaWNLZXkuJyk7XG4gIH1cbiAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2ggJiYgdHlwZSAhPT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9QdWJsaWNLZXlIYXNoICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9UYXByb290KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHlwZSBtdXN0IGJlIGVpdGhlciBwdWJrZXloYXNoLCB3aXRuZXNzcHVia2V5aGFzaCwgc2NyaXB0aGFzaCwgb3IgdGFwcm9vdCB0byB0cmFuc2Zvcm0gcHVibGljIGtleS4nKTtcbiAgfVxuICBpZiAoIXB1YmtleS5jb21wcmVzc2VkICYmICh0eXBlID09PSBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaCB8fCB0eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1B1YmxpY0tleUhhc2gpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBhZGRyZXNzZXMgbXVzdCB1c2UgY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2gpIHtcbiAgICBpbmZvLmhhc2hCdWZmZXIgPSBIYXNoLnNoYTI1NnJpcGVtZDE2MChTY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQocHVia2V5KS50b0J1ZmZlcigpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBBZGRyZXNzLlBheVRvVGFwcm9vdCkge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHB1YmtleS5jcmVhdGVUYXBUd2VhaygpLnR3ZWFrZWRQdWJLZXk7XG4gIH0gZWxzZSB7XG4gICAgaW5mby5oYXNoQnVmZmVyID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAocHVia2V5LnRvQnVmZmVyKCkpO1xuICB9XG4gIGluZm8udHlwZSA9IHR5cGUgfHwgQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2g7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSB7QGxpbmsgU2NyaXB0fSBpbnRvIGEgYGluZm9gIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1NjcmlwdH0gc2NyaXB0IC0gQW4gaW5zdGFuY2Ugb2YgU2NyaXB0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyLCB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5BZGRyZXNzLl90cmFuc2Zvcm1TY3JpcHQgPSBmdW5jdGlvbihzY3JpcHQsIG5ldHdvcmspIHtcbiAgJC5jaGVja0FyZ3VtZW50KHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCwgJ3NjcmlwdCBtdXN0IGJlIGEgU2NyaXB0IGluc3RhbmNlJyk7XG4gIHZhciBpbmZvID0gc2NyaXB0LmdldEFkZHJlc3NJbmZvKG5ldHdvcmspO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlNjcmlwdC5DYW50RGVyaXZlQWRkcmVzcyhzY3JpcHQpO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUDJTSCBhZGRyZXNzIGZyb20gYSBzZXQgb2YgcHVibGljIGtleXMgYW5kIGEgdGhyZXNob2xkLlxuICpcbiAqIFRoZSBhZGRyZXNzZXMgd2lsbCBiZSBzb3J0ZWQgbGV4aWNvZ3JhcGhpY2FsbHksIGFzIHRoYXQgaXMgdGhlIHRyZW5kIGluIGJpdGNvaW4uXG4gKiBUbyBjcmVhdGUgYW4gYWRkcmVzcyBmcm9tIHVuc29ydGVkIHB1YmxpYyBrZXlzLCB1c2UgdGhlIHtAbGluayBTY3JpcHQjYnVpbGRNdWx0aXNpZ091dH1cbiAqIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwdWJsaWNLZXlzIC0gYSBzZXQgb2YgcHVibGljIGtleXMgdG8gY3JlYXRlIGFuIGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGQgLSB0aGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgbmVlZGVkIHRvIHJlbGVhc2UgdGhlIGZ1bmRzXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5lc3RlZFdpdG5lc3MgLSBpZiB0aGUgYWRkcmVzcyB1c2VzIGEgbmVzdGVkIHAyc2ggd2l0bmVzc1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBFaXRoZXIgJ3NjcmlwdGhhc2gnIG9yICd3aXRuZXNzc2NyaXB0aGFzaCcuIElmIG5lc3RlZFdpdG5lc3MgaXMgc2V0LCB0aGVuIHRoaXMgaXMgaWdub3JlZFxuICogQHJldHVybiB7QWRkcmVzc31cbiAqL1xuQWRkcmVzcy5jcmVhdGVNdWx0aXNpZyA9IGZ1bmN0aW9uKHB1YmxpY0tleXMsIHRocmVzaG9sZCwgbmV0d29yaywgbmVzdGVkV2l0bmVzcywgdHlwZSkge1xuICBuZXR3b3JrID0gbmV0d29yayB8fCBwdWJsaWNLZXlzWzBdLm5ldHdvcmsgfHwgTmV0d29ya3MuZGVmYXVsdE5ldHdvcms7XG4gIGlmICh0eXBlICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoICYmIHR5cGUgIT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGUgbXVzdCBiZSBlaXRoZXIgc2NyaXB0aGFzaCBvciB3aXRuZXNzc2NyaXB0aGFzaCB0byBjcmVhdGUgbXVsdGlzaWcuJyk7XG4gIH1cbiAgaWYgKG5lc3RlZFdpdG5lc3MgfHwgdHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XG4gICAgcHVibGljS2V5cyA9IF8ubWFwKHB1YmxpY0tleXMsIFB1YmxpY0tleSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdWJsaWNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXB1YmxpY0tleXNbaV0uY29tcHJlc3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGFkZHJlc3NlcyBtdXN0IHVzZSBjb21wcmVzc2VkIHB1YmxpYyBrZXlzLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmVkZWVtU2NyaXB0ID0gU2NyaXB0LmJ1aWxkTXVsdGlzaWdPdXQocHVibGljS2V5cywgdGhyZXNob2xkKTtcbiAgaWYgKG5lc3RlZFdpdG5lc3MpIHtcbiAgICByZXR1cm4gQWRkcmVzcy5wYXlpbmdUbyhTY3JpcHQuYnVpbGRXaXRuZXNzTXVsdGlzaWdPdXRGcm9tU2NyaXB0KHJlZGVlbVNjcmlwdCksIG5ldHdvcmspO1xuICB9XG4gIHJldHVybiBBZGRyZXNzLnBheWluZ1RvKHJlZGVlbVNjcmlwdCwgbmV0d29yaywgdHlwZSk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIGJpdGNvaW4gYWRkcmVzcyBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBlaXRoZXIgYSBOZXR3b3JrIGluc3RhbmNlLCAnbGl2ZW5ldCcsIG9yICd0ZXN0bmV0J1xuICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIC0gVGhlIHR5cGU6ICdwdWJrZXloYXNoJywgJ3NjcmlwdGhhc2gnLCAnd2l0bmVzc3B1YmtleWhhc2gnLCBvciAnd2l0bmVzc3NjcmlwdGhhc2gnXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBoYXNoQnVmZmVyLCBuZXR3b3JrIGFuZCB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5BZGRyZXNzLl90cmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YoZGF0YSkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBwYXJhbWV0ZXIgc3VwcGxpZWQgaXMgbm90IGEgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYoZGF0YS5sZW5ndGggPiAxMDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhZGRyZXNzIHN0cmluZyBpcyB0b28gbG9uZycpO1xuICB9XG5cbiAgaWYgKG5ldHdvcmsgJiYgIU5ldHdvcmtzLmdldChuZXR3b3JrKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gbmV0d29yaycpO1xuICB9XG5cbiAgZGF0YSA9IGRhdGEudHJpbSgpO1xuXG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1CdWZmZXIoQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKSwgbmV0d29yaywgdHlwZSk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoIHx8IHR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCB8fCB0eXBlID09PSBBZGRyZXNzLlBheVRvVGFwcm9vdCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICB2YXIgYWRkcmVzc0J1ZmZlciA9IEJhc2U1OENoZWNrLmRlY29kZShkYXRhKTtcbiAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1CdWZmZXIoYWRkcmVzc0J1ZmZlciwgbmV0d29yaywgdHlwZSk7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhbiBhZGRyZXNzIGZyb20gYSBQdWJsaWNLZXkgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gZGF0YVxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29ya30gbmV0d29yayAtIGVpdGhlciBhIE5ldHdvcmsgaW5zdGFuY2UsICdsaXZlbmV0Jywgb3IgJ3Rlc3RuZXQnXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEVpdGhlciAncHVia2V5aGFzaCcsICd3aXRuZXNzcHVia2V5aGFzaCcsIG9yICdzY3JpcHRoYXNoJ1xuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xuICovXG5BZGRyZXNzLmZyb21QdWJsaWNLZXkgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrLCB0eXBlKSB7XG4gIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtUHVibGljS2V5KGRhdGEsIG5ldHdvcmssIHR5cGUpO1xuICBuZXR3b3JrID0gbmV0d29yayB8fCBOZXR3b3Jrcy5kZWZhdWx0TmV0d29yaztcbiAgcmV0dXJuIG5ldyBBZGRyZXNzKGluZm8uaGFzaEJ1ZmZlciwgbmV0d29yaywgaW5mby50eXBlKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYW4gYWRkcmVzcyBmcm9tIGEgcmlwZW1kMTYwIHB1YmxpYyBrZXkgaGFzaFxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoIC0gQW4gaW5zdGFuY2Ugb2YgYnVmZmVyIG9mIHRoZSBoYXNoXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBIG5ldyB2YWxpZCBhbmQgZnJvemVuIGluc3RhbmNlIG9mIGFuIEFkZHJlc3NcbiAqL1xuQWRkcmVzcy5mcm9tUHVibGljS2V5SGFzaCA9IGZ1bmN0aW9uKGhhc2gsIG5ldHdvcmspIHtcbiAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1IYXNoKGhhc2gpO1xuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mby5oYXNoQnVmZmVyLCBuZXR3b3JrLCBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaCk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhIHJpcGVtZDE2MCBzY3JpcHQgaGFzaFxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoIC0gQW4gaW5zdGFuY2Ugb2YgYnVmZmVyIG9mIHRoZSBoYXNoXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gRWl0aGVyICdzY3JpcHRoYXNoJyBvciAnd2l0bmVzc3NjcmlwdGhhc2gnXG4gKiBAcmV0dXJucyB7QWRkcmVzc30gQSBuZXcgdmFsaWQgYW5kIGZyb3plbiBpbnN0YW5jZSBvZiBhbiBBZGRyZXNzXG4gKi9cbkFkZHJlc3MuZnJvbVNjcmlwdEhhc2ggPSBmdW5jdGlvbihoYXNoLCBuZXR3b3JrLCB0eXBlKSB7XG4gICQuY2hlY2tBcmd1bWVudChoYXNoLCAnaGFzaCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgdmFyIGluZm8gPSBBZGRyZXNzLl90cmFuc2Zvcm1IYXNoKGhhc2gpO1xuICBpZiAodHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoICYmIGhhc2gubGVuZ3RoICE9PSAzMikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRkcmVzcyBoYXNoYnVmZmVyIG11c3QgYmUgZXhhY3RseSAzMiBieXRlcyBmb3IgdjAgd2l0bmVzcyBzY3JpcHQgaGFzaC4nKTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGUgfHwgQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XG4gIHJldHVybiBuZXcgQWRkcmVzcyhpbmZvLmhhc2hCdWZmZXIsIG5ldHdvcmssIHR5cGUpO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBwMnNoIGFkZHJlc3MgcGF5aW5nIHRvIHNjcmlwdC4gVGhpcyB3aWxsIGhhc2ggdGhlIHNjcmlwdCBhbmRcbiAqIHVzZSB0aGF0IHRvIGNyZWF0ZSB0aGUgYWRkcmVzcy5cbiAqIElmIHlvdSB3YW50IHRvIGV4dHJhY3QgYW4gYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggYSBzY3JpcHQgaW5zdGVhZCxcbiAqIHNlZSB7e0FkZHJlc3MjZnJvbVNjcmlwdH19XG4gKlxuICogQHBhcmFtIHtTY3JpcHR9IHNjcmlwdCAtIEFuIGluc3RhbmNlIG9mIFNjcmlwdFxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29ya30gbmV0d29yayAtIGVpdGhlciBhIE5ldHdvcmsgaW5zdGFuY2UsICdsaXZlbmV0Jywgb3IgJ3Rlc3RuZXQnXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEVpdGhlciAnc2NyaXB0aGFzaCcgb3IgJ3dpdG5lc3NzY3JpcHRoYXNoJ1xuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xuICovXG5BZGRyZXNzLnBheWluZ1RvID0gZnVuY3Rpb24oc2NyaXB0LCBuZXR3b3JrLCB0eXBlKSB7XG4gICQuY2hlY2tBcmd1bWVudChzY3JpcHQsICdzY3JpcHQgaXMgcmVxdWlyZWQnKTtcbiAgJC5jaGVja0FyZ3VtZW50KHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCwgJ3NjcmlwdCBtdXN0IGJlIGluc3RhbmNlIG9mIFNjcmlwdCcpO1xuICB2YXIgaGFzaDtcbiAgaWYgKHR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCkge1xuICAgIGhhc2ggPSBIYXNoLnNoYTI1NihzY3JpcHQudG9CdWZmZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgaGFzaCA9IEhhc2guc2hhMjU2cmlwZW1kMTYwKHNjcmlwdC50b0J1ZmZlcigpKTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGUgfHwgQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XG4gIHJldHVybiBBZGRyZXNzLmZyb21TY3JpcHRIYXNoKGhhc2gsIG5ldHdvcmssIHR5cGUpO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0IGFkZHJlc3MgZnJvbSBhIFNjcmlwdC4gVGhlIHNjcmlwdCBtdXN0IGJlIG9mIG9uZVxuICogb2YgdGhlIGZvbGxvd2luZyB0eXBlczogcDJwa2ggaW5wdXQsIHAycGtoIG91dHB1dCwgcDJzaCBpbnB1dFxuICogb3IgcDJzaCBvdXRwdXQuXG4gKiBUaGlzIHdpbGwgYW5hbHl6ZSB0aGUgc2NyaXB0IGFuZCBleHRyYWN0IGFkZHJlc3MgaW5mb3JtYXRpb24gZnJvbSBpdC5cbiAqIElmIHlvdSB3YW50IHRvIHRyYW5zZm9ybSBhbnkgc2NyaXB0IHRvIGEgcDJzaCBBZGRyZXNzIHBheWluZ1xuICogdG8gdGhhdCBzY3JpcHQncyBoYXNoIGluc3RlYWQsIHVzZSB7e0FkZHJlc3MjcGF5aW5nVG99fVxuICpcbiAqIEBwYXJhbSB7U2NyaXB0fSBzY3JpcHQgLSBBbiBpbnN0YW5jZSBvZiBTY3JpcHRcbiAqIEBwYXJhbSB7U3RyaW5nfE5ldHdvcmt9IG5ldHdvcmsgLSBlaXRoZXIgYSBOZXR3b3JrIGluc3RhbmNlLCAnbGl2ZW5ldCcsIG9yICd0ZXN0bmV0J1xuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGFuZCBmcm96ZW4gaW5zdGFuY2Ugb2YgYW4gQWRkcmVzc1xuICovXG5BZGRyZXNzLmZyb21TY3JpcHQgPSBmdW5jdGlvbihzY3JpcHQsIG5ldHdvcmspIHtcbiAgJC5jaGVja0FyZ3VtZW50KHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCwgJ3NjcmlwdCBtdXN0IGJlIGEgU2NyaXB0IGluc3RhbmNlJyk7XG4gIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtU2NyaXB0KHNjcmlwdCwgbmV0d29yayk7XG4gIHJldHVybiBuZXcgQWRkcmVzcyhpbmZvLmhhc2hCdWZmZXIsIG5ldHdvcmssIGluZm8udHlwZSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhIGJ1ZmZlciBvZiB0aGUgYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgLSBBbiBpbnN0YW5jZSBvZiBidWZmZXIgb2YgdGhlIGFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfE5ldHdvcms9fSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIFRoZSB0eXBlIG9mIGFkZHJlc3M6ICdzY3JpcHQnIG9yICdwdWJrZXknXG4gKiBAcmV0dXJucyB7QWRkcmVzc30gQSBuZXcgdmFsaWQgYW5kIGZyb3plbiBpbnN0YW5jZSBvZiBhbiBBZGRyZXNzXG4gKi9cbkFkZHJlc3MuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlciwgbmV0d29yaywgdHlwZSkge1xuICB2YXIgaW5mbyA9IEFkZHJlc3MuX3RyYW5zZm9ybUJ1ZmZlcihidWZmZXIsIG5ldHdvcmssIHR5cGUpO1xuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mby5oYXNoQnVmZmVyLCBpbmZvLm5ldHdvcmssIGluZm8udHlwZSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGFuIGFkZHJlc3MgZnJvbSBhbiBhZGRyZXNzIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBBbiBzdHJpbmcgb2YgdGhlIGJpdGNvaW4gYWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBlaXRoZXIgYSBOZXR3b3JrIGluc3RhbmNlLCAnbGl2ZW5ldCcsIG9yICd0ZXN0bmV0J1xuICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBIG5ldyB2YWxpZCBhbmQgZnJvemVuIGluc3RhbmNlIG9mIGFuIEFkZHJlc3NcbiAqL1xuQWRkcmVzcy5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBuZXR3b3JrLCB0eXBlKSB7XG4gIHZhciBpbmZvID0gQWRkcmVzcy5fdHJhbnNmb3JtU3RyaW5nKHN0ciwgbmV0d29yaywgdHlwZSk7XG4gIHJldHVybiBuZXcgQWRkcmVzcyhpbmZvLmhhc2hCdWZmZXIsIGluZm8ubmV0d29yaywgaW5mby50eXBlKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYW4gYWRkcmVzcyBmcm9tIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc29uIC0gQW4gSlNPTiBzdHJpbmcgb3IgT2JqZWN0IHdpdGgga2V5czogaGFzaCwgbmV0d29yayBhbmQgdHlwZVxuICogQHJldHVybnMge0FkZHJlc3N9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIGFuIEFkZHJlc3NcbiAqL1xuQWRkcmVzcy5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcbiAgJC5jaGVja1N0YXRlKFxuICAgIEpTVXRpbC5pc0hleGEob2JqLmhhc2gpLFxuICAgICdVbmV4cGVjdGVkIGhhc2ggcHJvcGVydHksIFwiJyArIG9iai5oYXNoICsgJ1wiLCBleHBlY3RlZCB0byBiZSBoZXguJ1xuICApO1xuICB2YXIgaGFzaEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG9iai5oYXNoLCAnaGV4Jyk7XG4gIHJldHVybiBuZXcgQWRkcmVzcyhoYXNoQnVmZmVyLCBvYmoubmV0d29yaywgb2JqLnR5cGUpO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIHZhbGlkYXRpb24gZXJyb3IgaWYgZXhpc3RzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIGEgbmV0d29yayBtaXNtYXRjaCBlcnJvclxuICogdmFyIGVycm9yID0gQWRkcmVzcy5nZXRWYWxpZGF0aW9uRXJyb3IoJzE1dmtjS2Y3Z0IyM3dMQW5aTG1iVnVNaWlWRGMxTm00YTInLCAndGVzdG5ldCcpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcbiAqIEByZXR1cm5zIHtudWxsfEVycm9yfSBUaGUgY29ycmVzcG9uZGluZyBlcnJvciBtZXNzYWdlXG4gKi9cbkFkZHJlc3MuZ2V0VmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaywgdHlwZSkge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgLyoganNoaW50IG5vbmV3OiBmYWxzZSAqL1xuICAgIG5ldyBBZGRyZXNzKGRhdGEsIG5ldHdvcmssIHR5cGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYSBib29sZWFuIGlmIGFuIGFkZHJlc3MgaXMgdmFsaWRcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogYXNzZXJ0KEFkZHJlc3MuaXNWYWxpZCgnMTV2a2NLZjdnQjIzd0xBblpMbWJWdU1paVZEYzFObTRhMicsICdsaXZlbmV0JykpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ3xOZXR3b3JrfSBuZXR3b3JrIC0gZWl0aGVyIGEgTmV0d29yayBpbnN0YW5jZSwgJ2xpdmVuZXQnLCBvciAndGVzdG5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzczogJ3NjcmlwdCcgb3IgJ3B1YmtleSdcbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgY29ycmVzcG9uZGluZyBlcnJvciBtZXNzYWdlXG4gKi9cbkFkZHJlc3MuaXNWYWxpZCA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmssIHR5cGUpIHtcbiAgcmV0dXJuICFBZGRyZXNzLmdldFZhbGlkYXRpb25FcnJvcihkYXRhLCBuZXR3b3JrLCB0eXBlKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGFkZHJlc3MgaXMgb2YgcGF5IHRvIHB1YmxpYyBrZXkgaGFzaCB0eXBlXG4gKiBAcmV0dXJuIGJvb2xlYW5cbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUuaXNQYXlUb1B1YmxpY0tleUhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1B1YmxpY0tleUhhc2g7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhZGRyZXNzIGlzIG9mIHBheSB0byBzY3JpcHQgaGFzaCB0eXBlXG4gKiBAcmV0dXJuIGJvb2xlYW5cbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUuaXNQYXlUb1NjcmlwdEhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhZGRyZXNzIGlzIG9mIHBheSB0byB3aXRuZXNzIHB1YmxpYyBrZXkgaGFzaCB0eXBlXG4gKiBAcmV0dXJuIGJvb2xlYW5cbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUuaXNQYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGFkZHJlc3MgaXMgb2YgcGF5IHRvIHdpdG5lc3Mgc2NyaXB0IGhhc2ggdHlwZVxuICogQHJldHVybiBib29sZWFuXG4gKi9cbkFkZHJlc3MucHJvdG90eXBlLmlzUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2g7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhZGRyZXNzIGlzIG9mIHBheSB0byBUYXByb290IHNjcmlwdCBoYXNoIHR5cGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5BZGRyZXNzLnByb3RvdHlwZS5pc1BheVRvVGFwcm9vdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSBBZGRyZXNzLlBheVRvVGFwcm9vdDtcbn1cblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xuICpcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEJpdGNvaW4gYWRkcmVzcyBidWZmZXJcbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNQYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoKCkgfHwgdGhpcy5pc1BheVRvV2l0bmVzc1NjcmlwdEhhc2goKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLnRvU3RyaW5nKCksICd1dGY4JylcbiAgfVxuICB2YXIgdmVyc2lvbiA9IEJ1ZmZlci5mcm9tKFt0aGlzLm5ldHdvcmtbdGhpcy50eXBlXV0pO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdmVyc2lvbiwgdGhpcy5oYXNoQnVmZmVyXSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcGxhaW4gb2JqZWN0IHdpdGggdGhlIGFkZHJlc3MgaW5mb3JtYXRpb25cbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUudG9PYmplY3QgPSBBZGRyZXNzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBoYXNoOiB0aGlzLmhhc2hCdWZmZXIudG9TdHJpbmcoJ2hleCcpLFxuICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmsudG9TdHJpbmcoKVxuICB9O1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZHJlc3NcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCaXRjb2luIGFkZHJlc3NcbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNQYXlUb1dpdG5lc3NQdWJsaWNLZXlIYXNoKCkgfHwgdGhpcy5pc1BheVRvV2l0bmVzc1NjcmlwdEhhc2goKSB8fCB0aGlzLmlzUGF5VG9UYXByb290KCkpIHtcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5uZXR3b3JrLmJlY2gzMnByZWZpeDtcbiAgICBsZXQgdmVyc2lvbiA9IDA7XG4gICAgbGV0IGVuY29kaW5nID0gQmVjaDMyLmVuY29kaW5ncy5CRUNIMzI7XG4gICAgaWYgKHRoaXMuaXNQYXlUb1RhcHJvb3QoKSkge1xuICAgICAgdmVyc2lvbiA9IDE7XG4gICAgICBlbmNvZGluZyA9IEJlY2gzMi5lbmNvZGluZ3MuQkVDSDMyTTtcbiAgICB9XG4gICAgcmV0dXJuIEJlY2gzMi5lbmNvZGUocHJlZml4LCB2ZXJzaW9uLCB0aGlzLmhhc2hCdWZmZXIsIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gQmFzZTU4Q2hlY2suZW5jb2RlKHRoaXMudG9CdWZmZXIoKSk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCaXRjb2luIGFkZHJlc3NcbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxBZGRyZXNzOiAnICsgdGhpcy50b1N0cmluZygpICsgJywgdHlwZTogJyArIHRoaXMudHlwZSArICcsIG5ldHdvcms6ICcgKyB0aGlzLm5ldHdvcmsgKyAnPic7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFkZHJlc3M7XG5cbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/block/block.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/block/block.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar BlockHeader = __webpack_require__(/*! ./blockheader */ \"(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Transaction = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\n/**\n * Instantiate a Block from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {Block}\n * @constructor\n */\nfunction Block(arg) {\n  if (!(this instanceof Block)) {\n    return new Block(arg);\n  }\n  _.extend(this, Block._from(arg));\n  return this;\n}\n\n// https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14\nBlock.MAX_BLOCK_SIZE = 1000000;\n\n/**\n * @param {*} - A Buffer, JSON string or Object\n * @returns {Object} - An object representing block data\n * @throws {TypeError} - If the argument was not recognized\n * @private\n */\nBlock._from = function _from(arg) {\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = Block._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    info = Block._fromObject(arg);\n  } else {\n    throw new TypeError('Unrecognized argument for Block');\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Object} - An object representing block data\n * @private\n */\nBlock._fromObject = function _fromObject(data) {\n  var transactions = [];\n  data.transactions.forEach(function(tx) {\n    if (tx instanceof Transaction) {\n      transactions.push(tx);\n    } else {\n      transactions.push(Transaction().fromObject(tx));\n    }\n  });\n  var info = {\n    header: BlockHeader.fromObject(data.header),\n    transactions: transactions\n  };\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nBlock.fromObject = function fromObject(obj) {\n  var info = Block._fromObject(obj);\n  return new Block(info);\n};\n\n/**\n * @param {BufferReader} - Block data\n * @returns {Object} - An object representing the block data\n * @private\n */\nBlock._fromBufferReader = function _fromBufferReader(br) {\n  var info = {};\n  $.checkState(!br.finished(), 'No block data received');\n  info.header = BlockHeader.fromBufferReader(br);\n  var transactions = br.readVarintNum();\n  info.transactions = [];\n  for (var i = 0; i < transactions; i++) {\n    info.transactions.push(Transaction().fromBufferReader(br));\n  }\n  return info;\n};\n\n/**\n * @param {BufferReader} - A buffer reader of the block\n * @returns {Block} - An instance of block\n */\nBlock.fromBufferReader = function fromBufferReader(br) {\n  $.checkArgument(br, 'br is required');\n  var info = Block._fromBufferReader(br);\n  return new Block(info);\n};\n\n/**\n * @param {Buffer} - A buffer of the block\n * @returns {Block} - An instance of block\n */\nBlock.fromBuffer = function fromBuffer(buf) {\n  return Block.fromBufferReader(new BufferReader(buf));\n};\n\n/**\n * @param {string} - str - A hex encoded string of the block\n * @returns {Block} - A hex encoded string of the block\n */\nBlock.fromString = function fromString(str) {\n  var buf = Buffer.from(str, 'hex');\n  return Block.fromBuffer(buf);\n};\n\n/**\n * @param {Binary} - Raw block binary data or buffer\n * @returns {Block} - An instance of block\n */\nBlock.fromRawBlock = function fromRawBlock(data) {\n  if (!BufferUtil.isBuffer(data)) {\n    data = Buffer.from(data, 'binary');\n  }\n  var br = BufferReader(data);\n  br.pos = Block.Values.START_OF_BLOCK;\n  var info = Block._fromBufferReader(br);\n  return new Block(info);\n};\n\n/**\n * @returns {Object} - A plain object with the block properties\n */\nBlock.prototype.toObject = Block.prototype.toJSON = function toObject() {\n  var transactions = [];\n  this.transactions.forEach(function(tx) {\n    transactions.push(tx.toObject());\n  });\n  return {\n    header: this.header.toObject(),\n    transactions: transactions\n  };\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @returns {string} - A hex encoded string of the block\n */\nBlock.prototype.toString = function toString() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the Block\n */\nBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeVarintNum(this.transactions.length);\n  for (var i = 0; i < this.transactions.length; i++) {\n    this.transactions[i].toBufferWriter(bw);\n  }\n  return bw;\n};\n\n/**\n * Will iterate through each transaction and return an array of hashes\n * @returns {Array} - An array with transaction hashes\n */\nBlock.prototype.getTransactionHashes = function getTransactionHashes() {\n  var hashes = [];\n  if (this.transactions.length === 0) {\n    return [Block.Values.NULL_HASH];\n  }\n  for (var t = 0; t < this.transactions.length; t++) {\n    hashes.push(this.transactions[t]._getHash());\n  }\n  return hashes;\n};\n\n/**\n * Will build a merkle tree of all the transactions, ultimately arriving at\n * a single point, the merkle root.\n * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees\n * @returns {Array} - An array with each level of the tree after the other.\n */\nBlock.prototype.getMerkleTree = function getMerkleTree() {\n\n  var tree = this.getTransactionHashes();\n\n  var j = 0;\n  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {\n    for (var i = 0; i < size; i += 2) {\n      var i2 = Math.min(i + 1, size - 1);\n      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);\n      tree.push(Hash.sha256sha256(buf));\n    }\n    j += size;\n  }\n\n  return tree;\n};\n\n/**\n * Calculates the merkleRoot from the transactions.\n * @returns {Buffer} - A buffer of the merkle root hash\n */\nBlock.prototype.getMerkleRoot = function getMerkleRoot() {\n  var tree = this.getMerkleTree();\n  return tree[tree.length - 1];\n};\n\n/**\n * Verifies that the transactions in the block match the header merkle root\n * @returns {Boolean} - If the merkle roots match\n */\nBlock.prototype.validMerkleRoot = function validMerkleRoot() {\n\n  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');\n  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');\n\n  if (h.cmp(c) !== 0) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * @returns {Buffer} - The little endian hash buffer of the header\n */\nBlock.prototype._getHash = function() {\n  return this.header._getHash();\n};\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get: function() {\n    if (!this._id) {\n      this._id = this.header.id;\n    }\n    return this._id;\n  },\n  set: _.noop\n};\nObject.defineProperty(Block.prototype, 'id', idProperty);\nObject.defineProperty(Block.prototype, 'hash', idProperty);\n\n/**\n * @returns {string} - A string formatted for the console\n */\nBlock.prototype.inspect = function inspect() {\n  return '<Block ' + this.id + '>';\n};\n\nBlock.Values = {\n  START_OF_BLOCK: 8, // Start of block in raw block data\n  NULL_HASH: Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\n\nmodule.exports = Block;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL2Jsb2NrLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUN6QyxTQUFTLG1CQUFPLENBQUMsdUVBQWM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDckQsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDMUMsUUFBUSxtQkFBTyxDQUFDLHlGQUF1Qjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3RELG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvYmxvY2svYmxvY2suanM/MjFmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgQmxvY2tIZWFkZXIgPSByZXF1aXJlKCcuL2Jsb2NraGVhZGVyJyk7XG52YXIgQk4gPSByZXF1aXJlKCcuLi9jcnlwdG8vYm4nKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcbnZhciBCdWZmZXJSZWFkZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJyZWFkZXInKTtcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgQmxvY2sgZnJvbSBhIEJ1ZmZlciwgSlNPTiBvYmplY3QsIG9yIE9iamVjdCB3aXRoXG4gKiB0aGUgcHJvcGVydGllcyBvZiB0aGUgQmxvY2tcbiAqXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nLCBvciBPYmplY3RcbiAqIEByZXR1cm5zIHtCbG9ja31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCbG9jayhhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJsb2NrKSkge1xuICAgIHJldHVybiBuZXcgQmxvY2soYXJnKTtcbiAgfVxuICBfLmV4dGVuZCh0aGlzLCBCbG9jay5fZnJvbShhcmcpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpdGNvaW4vYmxvYi9iNWZhMTMyMzI5ZjAzNzdkNzg3YTRhMjFjMTY4NjYwOWMyYmZhZWNlL3NyYy9wcmltaXRpdmVzL2Jsb2NrLmgjTDE0XG5CbG9jay5NQVhfQkxPQ0tfU0laRSA9IDEwMDAwMDA7XG5cbi8qKlxuICogQHBhcmFtIHsqfSAtIEEgQnVmZmVyLCBKU09OIHN0cmluZyBvciBPYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBibG9jayBkYXRhXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IC0gSWYgdGhlIGFyZ3VtZW50IHdhcyBub3QgcmVjb2duaXplZFxuICogQHByaXZhdGVcbiAqL1xuQmxvY2suX2Zyb20gPSBmdW5jdGlvbiBfZnJvbShhcmcpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnKSkge1xuICAgIGluZm8gPSBCbG9jay5fZnJvbUJ1ZmZlclJlYWRlcihCdWZmZXJSZWFkZXIoYXJnKSk7XG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChhcmcpKSB7XG4gICAgaW5mbyA9IEJsb2NrLl9mcm9tT2JqZWN0KGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIGFyZ3VtZW50IGZvciBCbG9jaycpO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gLSBBIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYmxvY2sgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuQmxvY2suX2Zyb21PYmplY3QgPSBmdW5jdGlvbiBfZnJvbU9iamVjdChkYXRhKSB7XG4gIHZhciB0cmFuc2FjdGlvbnMgPSBbXTtcbiAgZGF0YS50cmFuc2FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbih0eCkge1xuICAgIGlmICh0eCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgICB0cmFuc2FjdGlvbnMucHVzaCh0eCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKFRyYW5zYWN0aW9uKCkuZnJvbU9iamVjdCh0eCkpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBpbmZvID0ge1xuICAgIGhlYWRlcjogQmxvY2tIZWFkZXIuZnJvbU9iamVjdChkYXRhLmhlYWRlciksXG4gICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnNcbiAgfTtcbiAgcmV0dXJuIGluZm87XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSAtIEEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RcbiAqIEByZXR1cm5zIHtCbG9ja30gLSBBbiBpbnN0YW5jZSBvZiBibG9ja1xuICovXG5CbG9jay5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcbiAgdmFyIGluZm8gPSBCbG9jay5fZnJvbU9iamVjdChvYmopO1xuICByZXR1cm4gbmV3IEJsb2NrKGluZm8pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlclJlYWRlcn0gLSBCbG9jayBkYXRhXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJsb2NrIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbkJsb2NrLl9mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24gX2Zyb21CdWZmZXJSZWFkZXIoYnIpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgJC5jaGVja1N0YXRlKCFici5maW5pc2hlZCgpLCAnTm8gYmxvY2sgZGF0YSByZWNlaXZlZCcpO1xuICBpbmZvLmhlYWRlciA9IEJsb2NrSGVhZGVyLmZyb21CdWZmZXJSZWFkZXIoYnIpO1xuICB2YXIgdHJhbnNhY3Rpb25zID0gYnIucmVhZFZhcmludE51bSgpO1xuICBpbmZvLnRyYW5zYWN0aW9ucyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zYWN0aW9uczsgaSsrKSB7XG4gICAgaW5mby50cmFuc2FjdGlvbnMucHVzaChUcmFuc2FjdGlvbigpLmZyb21CdWZmZXJSZWFkZXIoYnIpKTtcbiAgfVxuICByZXR1cm4gaW5mbztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJSZWFkZXJ9IC0gQSBidWZmZXIgcmVhZGVyIG9mIHRoZSBibG9ja1xuICogQHJldHVybnMge0Jsb2NrfSAtIEFuIGluc3RhbmNlIG9mIGJsb2NrXG4gKi9cbkJsb2NrLmZyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyUmVhZGVyKGJyKSB7XG4gICQuY2hlY2tBcmd1bWVudChiciwgJ2JyIGlzIHJlcXVpcmVkJyk7XG4gIHZhciBpbmZvID0gQmxvY2suX2Zyb21CdWZmZXJSZWFkZXIoYnIpO1xuICByZXR1cm4gbmV3IEJsb2NrKGluZm8pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgYmxvY2tcbiAqIEByZXR1cm5zIHtCbG9ja30gLSBBbiBpbnN0YW5jZSBvZiBibG9ja1xuICovXG5CbG9jay5mcm9tQnVmZmVyID0gZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgcmV0dXJuIEJsb2NrLmZyb21CdWZmZXJSZWFkZXIobmV3IEJ1ZmZlclJlYWRlcihidWYpKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IC0gc3RyIC0gQSBoZXggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJsb2NrXG4gKiBAcmV0dXJucyB7QmxvY2t9IC0gQSBoZXggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJsb2NrXG4gKi9cbkJsb2NrLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xuICB2YXIgYnVmID0gQnVmZmVyLmZyb20oc3RyLCAnaGV4Jyk7XG4gIHJldHVybiBCbG9jay5mcm9tQnVmZmVyKGJ1Zik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QmluYXJ5fSAtIFJhdyBibG9jayBiaW5hcnkgZGF0YSBvciBidWZmZXJcbiAqIEByZXR1cm5zIHtCbG9ja30gLSBBbiBpbnN0YW5jZSBvZiBibG9ja1xuICovXG5CbG9jay5mcm9tUmF3QmxvY2sgPSBmdW5jdGlvbiBmcm9tUmF3QmxvY2soZGF0YSkge1xuICBpZiAoIUJ1ZmZlclV0aWwuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ2JpbmFyeScpO1xuICB9XG4gIHZhciBiciA9IEJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgYnIucG9zID0gQmxvY2suVmFsdWVzLlNUQVJUX09GX0JMT0NLO1xuICB2YXIgaW5mbyA9IEJsb2NrLl9mcm9tQnVmZmVyUmVhZGVyKGJyKTtcbiAgcmV0dXJuIG5ldyBCbG9jayhpbmZvKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge09iamVjdH0gLSBBIHBsYWluIG9iamVjdCB3aXRoIHRoZSBibG9jayBwcm9wZXJ0aWVzXG4gKi9cbkJsb2NrLnByb3RvdHlwZS50b09iamVjdCA9IEJsb2NrLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgdmFyIHRyYW5zYWN0aW9ucyA9IFtdO1xuICB0aGlzLnRyYW5zYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHR4KSB7XG4gICAgdHJhbnNhY3Rpb25zLnB1c2godHgudG9PYmplY3QoKSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGhlYWRlcjogdGhpcy5oZWFkZXIudG9PYmplY3QoKSxcbiAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9uc1xuICB9O1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIEEgYnVmZmVyIG9mIHRoZSBibG9ja1xuICovXG5CbG9jay5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXJXcml0ZXIoKS5jb25jYXQoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gLSBBIGhleCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYmxvY2tcbiAqL1xuQmxvY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcldyaXRlcn0gLSBBbiBleGlzdGluZyBpbnN0YW5jZSBvZiBCdWZmZXJXcml0ZXJcbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgQnVmZmVyV3JpdGVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCbG9ja1xuICovXG5CbG9jay5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcldyaXRlcihidykge1xuICBpZiAoIWJ3KSB7XG4gICAgYncgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gIH1cbiAgYncud3JpdGUodGhpcy5oZWFkZXIudG9CdWZmZXIoKSk7XG4gIGJ3LndyaXRlVmFyaW50TnVtKHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS50b0J1ZmZlcldyaXRlcihidyk7XG4gIH1cbiAgcmV0dXJuIGJ3O1xufTtcblxuLyoqXG4gKiBXaWxsIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHRyYW5zYWN0aW9uIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgaGFzaGVzXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgd2l0aCB0cmFuc2FjdGlvbiBoYXNoZXNcbiAqL1xuQmxvY2sucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uSGFzaGVzID0gZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25IYXNoZXMoKSB7XG4gIHZhciBoYXNoZXMgPSBbXTtcbiAgaWYgKHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbQmxvY2suVmFsdWVzLk5VTExfSEFTSF07XG4gIH1cbiAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGg7IHQrKykge1xuICAgIGhhc2hlcy5wdXNoKHRoaXMudHJhbnNhY3Rpb25zW3RdLl9nZXRIYXNoKCkpO1xuICB9XG4gIHJldHVybiBoYXNoZXM7XG59O1xuXG4vKipcbiAqIFdpbGwgYnVpbGQgYSBtZXJrbGUgdHJlZSBvZiBhbGwgdGhlIHRyYW5zYWN0aW9ucywgdWx0aW1hdGVseSBhcnJpdmluZyBhdFxuICogYSBzaW5nbGUgcG9pbnQsIHRoZSBtZXJrbGUgcm9vdC5cbiAqIEBsaW5rIGh0dHBzOi8vZW4uYml0Y29pbi5pdC93aWtpL1Byb3RvY29sX3NwZWNpZmljYXRpb24jTWVya2xlX1RyZWVzXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgd2l0aCBlYWNoIGxldmVsIG9mIHRoZSB0cmVlIGFmdGVyIHRoZSBvdGhlci5cbiAqL1xuQmxvY2sucHJvdG90eXBlLmdldE1lcmtsZVRyZWUgPSBmdW5jdGlvbiBnZXRNZXJrbGVUcmVlKCkge1xuXG4gIHZhciB0cmVlID0gdGhpcy5nZXRUcmFuc2FjdGlvbkhhc2hlcygpO1xuXG4gIHZhciBqID0gMDtcbiAgZm9yICh2YXIgc2l6ZSA9IHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aDsgc2l6ZSA+IDE7IHNpemUgPSBNYXRoLmZsb29yKChzaXplICsgMSkgLyAyKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAyKSB7XG4gICAgICB2YXIgaTIgPSBNYXRoLm1pbihpICsgMSwgc2l6ZSAtIDEpO1xuICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3RyZWVbaiArIGldLCB0cmVlW2ogKyBpMl1dKTtcbiAgICAgIHRyZWUucHVzaChIYXNoLnNoYTI1NnNoYTI1NihidWYpKTtcbiAgICB9XG4gICAgaiArPSBzaXplO1xuICB9XG5cbiAgcmV0dXJuIHRyZWU7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1lcmtsZVJvb3QgZnJvbSB0aGUgdHJhbnNhY3Rpb25zLlxuICogQHJldHVybnMge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgbWVya2xlIHJvb3QgaGFzaFxuICovXG5CbG9jay5wcm90b3R5cGUuZ2V0TWVya2xlUm9vdCA9IGZ1bmN0aW9uIGdldE1lcmtsZVJvb3QoKSB7XG4gIHZhciB0cmVlID0gdGhpcy5nZXRNZXJrbGVUcmVlKCk7XG4gIHJldHVybiB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIHRyYW5zYWN0aW9ucyBpbiB0aGUgYmxvY2sgbWF0Y2ggdGhlIGhlYWRlciBtZXJrbGUgcm9vdFxuICogQHJldHVybnMge0Jvb2xlYW59IC0gSWYgdGhlIG1lcmtsZSByb290cyBtYXRjaFxuICovXG5CbG9jay5wcm90b3R5cGUudmFsaWRNZXJrbGVSb290ID0gZnVuY3Rpb24gdmFsaWRNZXJrbGVSb290KCkge1xuXG4gIHZhciBoID0gbmV3IEJOKHRoaXMuaGVhZGVyLm1lcmtsZVJvb3QudG9TdHJpbmcoJ2hleCcpLCAnaGV4Jyk7XG4gIHZhciBjID0gbmV3IEJOKHRoaXMuZ2V0TWVya2xlUm9vdCgpLnRvU3RyaW5nKCdoZXgnKSwgJ2hleCcpO1xuXG4gIGlmIChoLmNtcChjKSAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIFRoZSBsaXR0bGUgZW5kaWFuIGhhc2ggYnVmZmVyIG9mIHRoZSBoZWFkZXJcbiAqL1xuQmxvY2sucHJvdG90eXBlLl9nZXRIYXNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlci5fZ2V0SGFzaCgpO1xufTtcblxudmFyIGlkUHJvcGVydHkgPSB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBiaWcgZW5kaWFuIGhhc2ggYnVmZmVyIG9mIHRoZSBoZWFkZXJcbiAgICovXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pZCkge1xuICAgICAgdGhpcy5faWQgPSB0aGlzLmhlYWRlci5pZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9LFxuICBzZXQ6IF8ubm9vcFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9jay5wcm90b3R5cGUsICdpZCcsIGlkUHJvcGVydHkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrLnByb3RvdHlwZSwgJ2hhc2gnLCBpZFByb3BlcnR5KTtcblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqL1xuQmxvY2sucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICByZXR1cm4gJzxCbG9jayAnICsgdGhpcy5pZCArICc+Jztcbn07XG5cbkJsb2NrLlZhbHVlcyA9IHtcbiAgU1RBUlRfT0ZfQkxPQ0s6IDgsIC8vIFN0YXJ0IG9mIGJsb2NrIGluIHJhdyBibG9jayBkYXRhXG4gIE5VTExfSEFTSDogQnVmZmVyLmZyb20oJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAnaGV4Jylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmxvY2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/block/block.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/block/blockheader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar GENESIS_BITS = 0x1d00ffff;\n\n/**\n * Instantiate a BlockHeader from a Buffer, JSON object, or Object with\n * the properties of the BlockHeader\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {BlockHeader} - An instance of block header\n * @constructor\n */\nvar BlockHeader = function BlockHeader(arg) {\n  if (!(this instanceof BlockHeader)) {\n    return new BlockHeader(arg);\n  }\n  var info = BlockHeader._from(arg);\n  this.version = info.version;\n  this.prevHash = info.prevHash;\n  this.merkleRoot = info.merkleRoot;\n  this.time = info.time;\n  this.timestamp = info.time;\n  this.bits = info.bits;\n  this.nonce = info.nonce;\n\n  if (info.hash) {\n    $.checkState(\n      this.hash === info.hash,\n      'Argument object hash property does not match block hash.'\n    );\n  }\n\n  return this;\n};\n\n/**\n * @param {*} - A Buffer, JSON string or Object\n * @returns {Object} - An object representing block header data\n * @throws {TypeError} - If the argument was not recognized\n * @private\n */\nBlockHeader._from = function _from(arg) {\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = BlockHeader._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    info = BlockHeader._fromObject(arg);\n  } else {\n    throw new TypeError('Unrecognized argument for BlockHeader');\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A JSON string\n * @returns {Object} - An object representing block header data\n * @private\n */\nBlockHeader._fromObject = function _fromObject(data) {\n  $.checkArgument(data, 'data is required');\n  var prevHash = data.prevHash;\n  var merkleRoot = data.merkleRoot;\n  if (_.isString(data.prevHash)) {\n    prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, 'hex'));\n  }\n  if (_.isString(data.merkleRoot)) {\n    merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, 'hex'));\n  }\n  var info = {\n    hash: data.hash,\n    version: data.version,\n    prevHash: prevHash,\n    merkleRoot: merkleRoot,\n    time: data.time,\n    timestamp: data.time,\n    bits: data.bits,\n    nonce: data.nonce\n  };\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromObject = function fromObject(obj) {\n  var info = BlockHeader._fromObject(obj);\n  return new BlockHeader(info);\n};\n\n/**\n * @param {Binary} - Raw block binary data or buffer\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromRawBlock = function fromRawBlock(data) {\n  if (!BufferUtil.isBuffer(data)) {\n    data = Buffer.from(data, 'binary');\n  }\n  var br = BufferReader(data);\n  br.pos = BlockHeader.Constants.START_OF_HEADER;\n  var info = BlockHeader._fromBufferReader(br);\n  return new BlockHeader(info);\n};\n\n/**\n * @param {Buffer} - A buffer of the block header\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromBuffer = function fromBuffer(buf) {\n  var info = BlockHeader._fromBufferReader(BufferReader(buf));\n  return new BlockHeader(info);\n};\n\n/**\n * @param {string} - A hex encoded buffer of the block header\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromString = function fromString(str) {\n  var buf = Buffer.from(str, 'hex');\n  return BlockHeader.fromBuffer(buf);\n};\n\n/**\n * @param {BufferReader} - A BufferReader of the block header\n * @returns {Object} - An object representing block header data\n * @private\n */\nBlockHeader._fromBufferReader = function _fromBufferReader(br) {\n  var info = {};\n  info.version = br.readInt32LE();\n  info.prevHash = br.read(32);\n  info.merkleRoot = br.read(32);\n  info.time = br.readUInt32LE();\n  info.bits = br.readUInt32LE();\n  info.nonce = br.readUInt32LE();\n  return info;\n};\n\n/**\n * @param {BufferReader} - A BufferReader of the block header\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromBufferReader = function fromBufferReader(br) {\n  var info = BlockHeader._fromBufferReader(br);\n  return new BlockHeader(info);\n};\n\n/**\n * @returns {Object} - A plain object of the BlockHeader\n */\nBlockHeader.prototype.toObject = BlockHeader.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hash,\n    version: this.version,\n    prevHash: BufferUtil.reverse(this.prevHash).toString('hex'),\n    merkleRoot: BufferUtil.reverse(this.merkleRoot).toString('hex'),\n    time: this.time,\n    bits: this.bits,\n    nonce: this.nonce\n  };\n};\n\n/**\n * @returns {Buffer} - A Buffer of the BlockHeader\n */\nBlockHeader.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @returns {string} - A hex encoded string of the BlockHeader\n */\nBlockHeader.prototype.toString = function toString() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * @param {BufferWriter} - An existing instance BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader\n */\nBlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.writeInt32LE(this.version);\n  bw.write(this.prevHash);\n  bw.write(this.merkleRoot);\n  bw.writeUInt32LE(this.time);\n  bw.writeUInt32LE(this.bits);\n  bw.writeUInt32LE(this.nonce);\n  return bw;\n};\n\n/**\n * Returns the target difficulty for this block\n * @param {Number} bits\n * @returns {BN} An instance of BN with the decoded difficulty bits\n */\nBlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(bits) {\n  bits = bits || this.bits;\n\n  var target = new BN(bits & 0xffffff);\n  var mov = 8 * ((bits >>> 24) - 3);\n  while (mov-- > 0) {\n    target = target.mul(new BN(2));\n  }\n  return target;\n};\n\n/**\n * @link https://en.bitcoin.it/wiki/Difficulty\n * @return {Number}\n */\nBlockHeader.prototype.getDifficulty = function getDifficulty() {\n  var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(Math.pow(10, 8)));\n  var currentTargetBN = this.getTargetDifficulty();\n\n  var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);\n  var decimalPos = difficultyString.length - 8;\n  difficultyString = difficultyString.slice(0, decimalPos) + '.' + difficultyString.slice(decimalPos);\n\n  return parseFloat(difficultyString);\n};\n\n/**\n * @returns {Buffer} - The little endian hash buffer of the header\n */\nBlockHeader.prototype._getHash = function hash() {\n  var buf = this.toBuffer();\n  return Hash.sha256sha256(buf);\n};\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get: function() {\n    if (!this._id) {\n      this._id = BufferReader(this._getHash()).readReverse().toString('hex');\n    }\n    return this._id;\n  },\n  set: _.noop\n};\nObject.defineProperty(BlockHeader.prototype, 'id', idProperty);\nObject.defineProperty(BlockHeader.prototype, 'hash', idProperty);\n\n/**\n * @returns {Boolean} - If timestamp is not too far in the future\n */\nBlockHeader.prototype.validTimestamp = function validTimestamp() {\n  var currentTime = Math.round(new Date().getTime() / 1000);\n  if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty\n */\nBlockHeader.prototype.validProofOfWork = function validProofOfWork() {\n  var pow = new BN(this.id, 'hex');\n  var target = this.getTargetDifficulty();\n\n  if (pow.cmp(target) > 0) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns {string} - A string formatted for the console\n */\nBlockHeader.prototype.inspect = function inspect() {\n  return '<BlockHeader ' + this.id + '>';\n};\n\nBlockHeader.Constants = {\n  START_OF_HEADER: 8, // Start buffer position in raw block data\n  MAX_TIME_OFFSET: 2 * 60 * 60, // The max a timestamp can be in the future\n  LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\n\nmodule.exports = BlockHeader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL2Jsb2NraGVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixTQUFTLG1CQUFPLENBQUMsdUVBQWM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDckQsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxhQUFhLG1CQUFPLENBQUMsbUVBQVk7QUFDakMsUUFBUSxtQkFBTyxDQUFDLHlGQUF1Qjs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9ibG9jay9ibG9ja2hlYWRlci5qcz9lZjBhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvanMnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbnZhciBHRU5FU0lTX0JJVFMgPSAweDFkMDBmZmZmO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgQmxvY2tIZWFkZXIgZnJvbSBhIEJ1ZmZlciwgSlNPTiBvYmplY3QsIG9yIE9iamVjdCB3aXRoXG4gKiB0aGUgcHJvcGVydGllcyBvZiB0aGUgQmxvY2tIZWFkZXJcbiAqXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nLCBvciBPYmplY3RcbiAqIEByZXR1cm5zIHtCbG9ja0hlYWRlcn0gLSBBbiBpbnN0YW5jZSBvZiBibG9jayBoZWFkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQmxvY2tIZWFkZXIgPSBmdW5jdGlvbiBCbG9ja0hlYWRlcihhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJsb2NrSGVhZGVyKSkge1xuICAgIHJldHVybiBuZXcgQmxvY2tIZWFkZXIoYXJnKTtcbiAgfVxuICB2YXIgaW5mbyA9IEJsb2NrSGVhZGVyLl9mcm9tKGFyZyk7XG4gIHRoaXMudmVyc2lvbiA9IGluZm8udmVyc2lvbjtcbiAgdGhpcy5wcmV2SGFzaCA9IGluZm8ucHJldkhhc2g7XG4gIHRoaXMubWVya2xlUm9vdCA9IGluZm8ubWVya2xlUm9vdDtcbiAgdGhpcy50aW1lID0gaW5mby50aW1lO1xuICB0aGlzLnRpbWVzdGFtcCA9IGluZm8udGltZTtcbiAgdGhpcy5iaXRzID0gaW5mby5iaXRzO1xuICB0aGlzLm5vbmNlID0gaW5mby5ub25jZTtcblxuICBpZiAoaW5mby5oYXNoKSB7XG4gICAgJC5jaGVja1N0YXRlKFxuICAgICAgdGhpcy5oYXNoID09PSBpbmZvLmhhc2gsXG4gICAgICAnQXJndW1lbnQgb2JqZWN0IGhhc2ggcHJvcGVydHkgZG9lcyBub3QgbWF0Y2ggYmxvY2sgaGFzaC4nXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nIG9yIE9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gLSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGJsb2NrIGhlYWRlciBkYXRhXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IC0gSWYgdGhlIGFyZ3VtZW50IHdhcyBub3QgcmVjb2duaXplZFxuICogQHByaXZhdGVcbiAqL1xuQmxvY2tIZWFkZXIuX2Zyb20gPSBmdW5jdGlvbiBfZnJvbShhcmcpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnKSkge1xuICAgIGluZm8gPSBCbG9ja0hlYWRlci5fZnJvbUJ1ZmZlclJlYWRlcihCdWZmZXJSZWFkZXIoYXJnKSk7XG4gIH0gZWxzZSBpZiAoXy5pc09iamVjdChhcmcpKSB7XG4gICAgaW5mbyA9IEJsb2NrSGVhZGVyLl9mcm9tT2JqZWN0KGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIGFyZ3VtZW50IGZvciBCbG9ja0hlYWRlcicpO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gLSBBIEpTT04gc3RyaW5nXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYmxvY2sgaGVhZGVyIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbkJsb2NrSGVhZGVyLl9mcm9tT2JqZWN0ID0gZnVuY3Rpb24gX2Zyb21PYmplY3QoZGF0YSkge1xuICAkLmNoZWNrQXJndW1lbnQoZGF0YSwgJ2RhdGEgaXMgcmVxdWlyZWQnKTtcbiAgdmFyIHByZXZIYXNoID0gZGF0YS5wcmV2SGFzaDtcbiAgdmFyIG1lcmtsZVJvb3QgPSBkYXRhLm1lcmtsZVJvb3Q7XG4gIGlmIChfLmlzU3RyaW5nKGRhdGEucHJldkhhc2gpKSB7XG4gICAgcHJldkhhc2ggPSBCdWZmZXJVdGlsLnJldmVyc2UoQnVmZmVyLmZyb20oZGF0YS5wcmV2SGFzaCwgJ2hleCcpKTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhkYXRhLm1lcmtsZVJvb3QpKSB7XG4gICAgbWVya2xlUm9vdCA9IEJ1ZmZlclV0aWwucmV2ZXJzZShCdWZmZXIuZnJvbShkYXRhLm1lcmtsZVJvb3QsICdoZXgnKSk7XG4gIH1cbiAgdmFyIGluZm8gPSB7XG4gICAgaGFzaDogZGF0YS5oYXNoLFxuICAgIHZlcnNpb246IGRhdGEudmVyc2lvbixcbiAgICBwcmV2SGFzaDogcHJldkhhc2gsXG4gICAgbWVya2xlUm9vdDogbWVya2xlUm9vdCxcbiAgICB0aW1lOiBkYXRhLnRpbWUsXG4gICAgdGltZXN0YW1wOiBkYXRhLnRpbWUsXG4gICAgYml0czogZGF0YS5iaXRzLFxuICAgIG5vbmNlOiBkYXRhLm5vbmNlXG4gIH07XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gLSBBIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0XG4gKiBAcmV0dXJucyB7QmxvY2tIZWFkZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2sgaGVhZGVyXG4gKi9cbkJsb2NrSGVhZGVyLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikge1xuICB2YXIgaW5mbyA9IEJsb2NrSGVhZGVyLl9mcm9tT2JqZWN0KG9iaik7XG4gIHJldHVybiBuZXcgQmxvY2tIZWFkZXIoaW5mbyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QmluYXJ5fSAtIFJhdyBibG9jayBiaW5hcnkgZGF0YSBvciBidWZmZXJcbiAqIEByZXR1cm5zIHtCbG9ja0hlYWRlcn0gLSBBbiBpbnN0YW5jZSBvZiBibG9jayBoZWFkZXJcbiAqL1xuQmxvY2tIZWFkZXIuZnJvbVJhd0Jsb2NrID0gZnVuY3Rpb24gZnJvbVJhd0Jsb2NrKGRhdGEpIHtcbiAgaWYgKCFCdWZmZXJVdGlsLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiaW5hcnknKTtcbiAgfVxuICB2YXIgYnIgPSBCdWZmZXJSZWFkZXIoZGF0YSk7XG4gIGJyLnBvcyA9IEJsb2NrSGVhZGVyLkNvbnN0YW50cy5TVEFSVF9PRl9IRUFERVI7XG4gIHZhciBpbmZvID0gQmxvY2tIZWFkZXIuX2Zyb21CdWZmZXJSZWFkZXIoYnIpO1xuICByZXR1cm4gbmV3IEJsb2NrSGVhZGVyKGluZm8pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgYmxvY2sgaGVhZGVyXG4gKiBAcmV0dXJucyB7QmxvY2tIZWFkZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2sgaGVhZGVyXG4gKi9cbkJsb2NrSGVhZGVyLmZyb21CdWZmZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1Zikge1xuICB2YXIgaW5mbyA9IEJsb2NrSGVhZGVyLl9mcm9tQnVmZmVyUmVhZGVyKEJ1ZmZlclJlYWRlcihidWYpKTtcbiAgcmV0dXJuIG5ldyBCbG9ja0hlYWRlcihpbmZvKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IC0gQSBoZXggZW5jb2RlZCBidWZmZXIgb2YgdGhlIGJsb2NrIGhlYWRlclxuICogQHJldHVybnMge0Jsb2NrSGVhZGVyfSAtIEFuIGluc3RhbmNlIG9mIGJsb2NrIGhlYWRlclxuICovXG5CbG9ja0hlYWRlci5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0ciwgJ2hleCcpO1xuICByZXR1cm4gQmxvY2tIZWFkZXIuZnJvbUJ1ZmZlcihidWYpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlclJlYWRlcn0gLSBBIEJ1ZmZlclJlYWRlciBvZiB0aGUgYmxvY2sgaGVhZGVyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYmxvY2sgaGVhZGVyIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbkJsb2NrSGVhZGVyLl9mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24gX2Zyb21CdWZmZXJSZWFkZXIoYnIpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby52ZXJzaW9uID0gYnIucmVhZEludDMyTEUoKTtcbiAgaW5mby5wcmV2SGFzaCA9IGJyLnJlYWQoMzIpO1xuICBpbmZvLm1lcmtsZVJvb3QgPSBici5yZWFkKDMyKTtcbiAgaW5mby50aW1lID0gYnIucmVhZFVJbnQzMkxFKCk7XG4gIGluZm8uYml0cyA9IGJyLnJlYWRVSW50MzJMRSgpO1xuICBpbmZvLm5vbmNlID0gYnIucmVhZFVJbnQzMkxFKCk7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlclJlYWRlcn0gLSBBIEJ1ZmZlclJlYWRlciBvZiB0aGUgYmxvY2sgaGVhZGVyXG4gKiBAcmV0dXJucyB7QmxvY2tIZWFkZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2sgaGVhZGVyXG4gKi9cbkJsb2NrSGVhZGVyLmZyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyUmVhZGVyKGJyKSB7XG4gIHZhciBpbmZvID0gQmxvY2tIZWFkZXIuX2Zyb21CdWZmZXJSZWFkZXIoYnIpO1xuICByZXR1cm4gbmV3IEJsb2NrSGVhZGVyKGluZm8pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIEEgcGxhaW4gb2JqZWN0IG9mIHRoZSBCbG9ja0hlYWRlclxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9PYmplY3QgPSBCbG9ja0hlYWRlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICBwcmV2SGFzaDogQnVmZmVyVXRpbC5yZXZlcnNlKHRoaXMucHJldkhhc2gpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICBtZXJrbGVSb290OiBCdWZmZXJVdGlsLnJldmVyc2UodGhpcy5tZXJrbGVSb290KS50b1N0cmluZygnaGV4JyksXG4gICAgdGltZTogdGhpcy50aW1lLFxuICAgIGJpdHM6IHRoaXMuYml0cyxcbiAgICBub25jZTogdGhpcy5ub25jZVxuICB9O1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIEEgQnVmZmVyIG9mIHRoZSBCbG9ja0hlYWRlclxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXJXcml0ZXIoKS5jb25jYXQoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gLSBBIGhleCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgQmxvY2tIZWFkZXJcbiAqL1xuQmxvY2tIZWFkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcldyaXRlcn0gLSBBbiBleGlzdGluZyBpbnN0YW5jZSBCdWZmZXJXcml0ZXJcbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ9IC0gQW4gaW5zdGFuY2Ugb2YgQnVmZmVyV3JpdGVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCbG9ja0hlYWRlclxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcldyaXRlcihidykge1xuICBpZiAoIWJ3KSB7XG4gICAgYncgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gIH1cbiAgYncud3JpdGVJbnQzMkxFKHRoaXMudmVyc2lvbik7XG4gIGJ3LndyaXRlKHRoaXMucHJldkhhc2gpO1xuICBidy53cml0ZSh0aGlzLm1lcmtsZVJvb3QpO1xuICBidy53cml0ZVVJbnQzMkxFKHRoaXMudGltZSk7XG4gIGJ3LndyaXRlVUludDMyTEUodGhpcy5iaXRzKTtcbiAgYncud3JpdGVVSW50MzJMRSh0aGlzLm5vbmNlKTtcbiAgcmV0dXJuIGJ3O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0YXJnZXQgZGlmZmljdWx0eSBmb3IgdGhpcyBibG9ja1xuICogQHBhcmFtIHtOdW1iZXJ9IGJpdHNcbiAqIEByZXR1cm5zIHtCTn0gQW4gaW5zdGFuY2Ugb2YgQk4gd2l0aCB0aGUgZGVjb2RlZCBkaWZmaWN1bHR5IGJpdHNcbiAqL1xuQmxvY2tIZWFkZXIucHJvdG90eXBlLmdldFRhcmdldERpZmZpY3VsdHkgPSBmdW5jdGlvbiBnZXRUYXJnZXREaWZmaWN1bHR5KGJpdHMpIHtcbiAgYml0cyA9IGJpdHMgfHwgdGhpcy5iaXRzO1xuXG4gIHZhciB0YXJnZXQgPSBuZXcgQk4oYml0cyAmIDB4ZmZmZmZmKTtcbiAgdmFyIG1vdiA9IDggKiAoKGJpdHMgPj4+IDI0KSAtIDMpO1xuICB3aGlsZSAobW92LS0gPiAwKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0Lm11bChuZXcgQk4oMikpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEBsaW5rIGh0dHBzOi8vZW4uYml0Y29pbi5pdC93aWtpL0RpZmZpY3VsdHlcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQmxvY2tIZWFkZXIucHJvdG90eXBlLmdldERpZmZpY3VsdHkgPSBmdW5jdGlvbiBnZXREaWZmaWN1bHR5KCkge1xuICB2YXIgZGlmZmljdWx0eTFUYXJnZXRCTiA9IHRoaXMuZ2V0VGFyZ2V0RGlmZmljdWx0eShHRU5FU0lTX0JJVFMpLm11bChuZXcgQk4oTWF0aC5wb3coMTAsIDgpKSk7XG4gIHZhciBjdXJyZW50VGFyZ2V0Qk4gPSB0aGlzLmdldFRhcmdldERpZmZpY3VsdHkoKTtcblxuICB2YXIgZGlmZmljdWx0eVN0cmluZyA9IGRpZmZpY3VsdHkxVGFyZ2V0Qk4uZGl2KGN1cnJlbnRUYXJnZXRCTikudG9TdHJpbmcoMTApO1xuICB2YXIgZGVjaW1hbFBvcyA9IGRpZmZpY3VsdHlTdHJpbmcubGVuZ3RoIC0gODtcbiAgZGlmZmljdWx0eVN0cmluZyA9IGRpZmZpY3VsdHlTdHJpbmcuc2xpY2UoMCwgZGVjaW1hbFBvcykgKyAnLicgKyBkaWZmaWN1bHR5U3RyaW5nLnNsaWNlKGRlY2ltYWxQb3MpO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KGRpZmZpY3VsdHlTdHJpbmcpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSAtIFRoZSBsaXR0bGUgZW5kaWFuIGhhc2ggYnVmZmVyIG9mIHRoZSBoZWFkZXJcbiAqL1xuQmxvY2tIZWFkZXIucHJvdG90eXBlLl9nZXRIYXNoID0gZnVuY3Rpb24gaGFzaCgpIHtcbiAgdmFyIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgcmV0dXJuIEhhc2guc2hhMjU2c2hhMjU2KGJ1Zik7XG59O1xuXG52YXIgaWRQcm9wZXJ0eSA9IHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGJpZyBlbmRpYW4gaGFzaCBidWZmZXIgb2YgdGhlIGhlYWRlclxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lkKSB7XG4gICAgICB0aGlzLl9pZCA9IEJ1ZmZlclJlYWRlcih0aGlzLl9nZXRIYXNoKCkpLnJlYWRSZXZlcnNlKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH0sXG4gIHNldDogXy5ub29wXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrSGVhZGVyLnByb3RvdHlwZSwgJ2lkJywgaWRQcm9wZXJ0eSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvY2tIZWFkZXIucHJvdG90eXBlLCAnaGFzaCcsIGlkUHJvcGVydHkpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIHRpbWVzdGFtcCBpcyBub3QgdG9vIGZhciBpbiB0aGUgZnV0dXJlXG4gKi9cbkJsb2NrSGVhZGVyLnByb3RvdHlwZS52YWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHZhbGlkVGltZXN0YW1wKCkge1xuICB2YXIgY3VycmVudFRpbWUgPSBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gIGlmICh0aGlzLnRpbWUgPiBjdXJyZW50VGltZSArIEJsb2NrSGVhZGVyLkNvbnN0YW50cy5NQVhfVElNRV9PRkZTRVQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIElmIHRoZSBwcm9vZi1vZi13b3JrIGhhc2ggc2F0aXNmaWVzIHRoZSB0YXJnZXQgZGlmZmljdWx0eVxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUudmFsaWRQcm9vZk9mV29yayA9IGZ1bmN0aW9uIHZhbGlkUHJvb2ZPZldvcmsoKSB7XG4gIHZhciBwb3cgPSBuZXcgQk4odGhpcy5pZCwgJ2hleCcpO1xuICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXREaWZmaWN1bHR5KCk7XG5cbiAgaWYgKHBvdy5jbXAodGFyZ2V0KSA+IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQSBzdHJpbmcgZm9ybWF0dGVkIGZvciB0aGUgY29uc29sZVxuICovXG5CbG9ja0hlYWRlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAnPEJsb2NrSGVhZGVyICcgKyB0aGlzLmlkICsgJz4nO1xufTtcblxuQmxvY2tIZWFkZXIuQ29uc3RhbnRzID0ge1xuICBTVEFSVF9PRl9IRUFERVI6IDgsIC8vIFN0YXJ0IGJ1ZmZlciBwb3NpdGlvbiBpbiByYXcgYmxvY2sgZGF0YVxuICBNQVhfVElNRV9PRkZTRVQ6IDIgKiA2MCAqIDYwLCAvLyBUaGUgbWF4IGEgdGltZXN0YW1wIGNhbiBiZSBpbiB0aGUgZnV0dXJlXG4gIExBUkdFU1RfSEFTSDogbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsICdoZXgnKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCbG9ja0hlYWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/block/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/block/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./block */ \"(ssr)/./node_modules/bitcore-lib/lib/block/block.js\");\n\nmodule.exports.BlockHeader = __webpack_require__(/*! ./blockheader */ \"(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\");\nmodule.exports.MerkleBlock = __webpack_require__(/*! ./merkleblock */ \"(ssr)/./node_modules/bitcore-lib/lib/block/merkleblock.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDBHQUFtQzs7QUFFbkMsa0lBQXFEO0FBQ3JELGtJQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9ibG9jay9pbmRleC5qcz83ZjhmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ibG9jaycpO1xuXG5tb2R1bGUuZXhwb3J0cy5CbG9ja0hlYWRlciA9IHJlcXVpcmUoJy4vYmxvY2toZWFkZXInKTtcbm1vZHVsZS5leHBvcnRzLk1lcmtsZUJsb2NrID0gcmVxdWlyZSgnLi9tZXJrbGVibG9jaycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/block/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/block/merkleblock.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/block/merkleblock.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar BlockHeader = __webpack_require__(/*! ./blockheader */ \"(ssr)/./node_modules/bitcore-lib/lib/block/blockheader.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar Transaction = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n    if(arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n  _.extend(this,info);\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n\n  return this;\n}\n\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(Buffer.from(this.hashes[i], 'hex'));\n  }\n  bw.writeVarintNum(this.flags.length);\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n  return bw;\n};\n\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    return false;\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var root = this._traverseMerkleTree(height, 0, opts);\n  if(opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n\n/**\n * Return a list of all the txs hash that match the filter\n * @returns {Array} - txs hash that match the filter\n */\nMerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // If there is only one hash the filter do not match any txs in the block\n  if(this.hashes.length === 1) {\n    return [];\n  };\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var txs = this._traverseMerkleTree(height, 0, opts, true);\n  if(opts.hashesUsed !== this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n  return txs;\n};\n\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @returns {Array} - transactions found during traversal that match the filter\n * @private\n */\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {\n  /* jshint maxcomplexity:  12*/\n  /* jshint maxstatements: 20 */\n\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n  var checkForTxs = checkForTxs || false;\n\n  if(opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;\n  if(depth === 0 || !isParentOfMatch) {\n    if(opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n    var hash = this.hashes[opts.hashesUsed++];\n    if(depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n    return Buffer.from(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth-1, pos*2, opts);\n    var right = left;\n    if(pos*2+1 < this._calcTreeWidth(depth-1)) {\n      right = this._traverseMerkleTree(depth-1, pos*2+1, opts);\n    }\n    if (checkForTxs){\n      return opts.txs;\n    } else {\n      return Hash.sha256sha256(new Buffer.concat([left, right]));\n    };\n  }\n};\n\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return (this.numTransactions + (1 << height) - 1) >> height;\n};\n\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n  return height;\n};\n\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string',\n      'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n\n  var hash = tx;\n  if(tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\n  }\n\n  var txs = [];\n  var height = this._calcTreeHeight();\n  this._traverseMerkleTree(height, 0, { txs: txs });\n  return txs.indexOf(hash) !== -1;\n};\n\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\n\nmodule.exports = MerkleBlock;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL21lcmtsZWJsb2NrLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxXQUFXLG1CQUFPLENBQUMsMkVBQWdCO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxtRUFBWTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLHVFQUFXO0FBQ2hDLFFBQVEsbUJBQU8sQ0FBQyx5RkFBdUI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsYUFBYTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Jsb2NrL21lcmtsZWJsb2NrLmpzP2M3NDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIEJsb2NrSGVhZGVyID0gcmVxdWlyZSgnLi9ibG9ja2hlYWRlcicpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvanMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgTWVya2xlQmxvY2sgZnJvbSBhIEJ1ZmZlciwgSlNPTiBvYmplY3QsIG9yIE9iamVjdCB3aXRoXG4gKiB0aGUgcHJvcGVydGllcyBvZiB0aGUgQmxvY2tcbiAqXG4gKiBAcGFyYW0geyp9IC0gQSBCdWZmZXIsIEpTT04gc3RyaW5nLCBvciBPYmplY3QgcmVwcmVzZW50aW5nIGEgTWVya2xlQmxvY2tcbiAqIEByZXR1cm5zIHtNZXJrbGVCbG9ja31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNZXJrbGVCbG9jayhhcmcpIHtcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDE4ICovXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1lcmtsZUJsb2NrKSkge1xuICAgIHJldHVybiBuZXcgTWVya2xlQmxvY2soYXJnKTtcbiAgfVxuXG4gIHZhciBpbmZvID0ge307XG4gIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZykpIHtcbiAgICBpbmZvID0gTWVya2xlQmxvY2suX2Zyb21CdWZmZXJSZWFkZXIoQnVmZmVyUmVhZGVyKGFyZykpO1xuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoYXJnKSkge1xuICAgIHZhciBoZWFkZXI7XG4gICAgaWYoYXJnLmhlYWRlciBpbnN0YW5jZW9mIEJsb2NrSGVhZGVyKSB7XG4gICAgICBoZWFkZXIgPSBhcmcuaGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgPSBCbG9ja0hlYWRlci5mcm9tT2JqZWN0KGFyZy5oZWFkZXIpO1xuICAgIH1cbiAgICBpbmZvID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBNZXJrbGVCbG9jayNoZWFkZXJcbiAgICAgICAqIEB0eXBlIHtCbG9ja0hlYWRlcn1cbiAgICAgICAqL1xuICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIE1lcmtsZUJsb2NrI251bVRyYW5zYWN0aW9uc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgbnVtVHJhbnNhY3Rpb25zOiBhcmcubnVtVHJhbnNhY3Rpb25zLFxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBNZXJrbGVCbG9jayNoYXNoZXNcbiAgICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgICAqL1xuICAgICAgaGFzaGVzOiBhcmcuaGFzaGVzLFxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBNZXJrbGVCbG9jayNmbGFnc1xuICAgICAgICogQHR5cGUge051bWJlcltdfVxuICAgICAgICovXG4gICAgICBmbGFnczogYXJnLmZsYWdzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlY29nbml6ZWQgYXJndW1lbnQgZm9yIE1lcmtsZUJsb2NrJyk7XG4gIH1cbiAgXy5leHRlbmQodGhpcyxpbmZvKTtcbiAgdGhpcy5fZmxhZ0JpdHNVc2VkID0gMDtcbiAgdGhpcy5faGFzaGVzVXNlZCA9IDA7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IC0gTWVya2xlQmxvY2sgZGF0YSBpbiBhIEJ1ZmZlciBvYmplY3RcbiAqIEByZXR1cm5zIHtNZXJrbGVCbG9ja30gLSBBIE1lcmtsZUJsb2NrIG9iamVjdFxuICovXG5NZXJrbGVCbG9jay5mcm9tQnVmZmVyID0gZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgcmV0dXJuIE1lcmtsZUJsb2NrLmZyb21CdWZmZXJSZWFkZXIoQnVmZmVyUmVhZGVyKGJ1ZikpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlclJlYWRlcn0gLSBNZXJrbGVCbG9jayBkYXRhIGluIGEgQnVmZmVyUmVhZGVyIG9iamVjdFxuICogQHJldHVybnMge01lcmtsZUJsb2NrfSAtIEEgTWVya2xlQmxvY2sgb2JqZWN0XG4gKi9cbk1lcmtsZUJsb2NrLmZyb21CdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyUmVhZGVyKGJyKSB7XG4gIHJldHVybiBuZXcgTWVya2xlQmxvY2soTWVya2xlQmxvY2suX2Zyb21CdWZmZXJSZWFkZXIoYnIpKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0J1ZmZlcn0gLSBBIGJ1ZmZlciBvZiB0aGUgYmxvY2tcbiAqL1xuTWVya2xlQmxvY2sucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyV3JpdGVyKCkuY29uY2F0KCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyV3JpdGVyfSAtIEFuIGV4aXN0aW5nIGluc3RhbmNlIG9mIEJ1ZmZlcldyaXRlclxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcn0gLSBBbiBpbnN0YW5jZSBvZiBCdWZmZXJXcml0ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIE1lcmtsZUJsb2NrXG4gKi9cbk1lcmtsZUJsb2NrLnByb3RvdHlwZS50b0J1ZmZlcldyaXRlciA9IGZ1bmN0aW9uIHRvQnVmZmVyV3JpdGVyKGJ3KSB7XG4gIGlmICghYncpIHtcbiAgICBidyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgfVxuICBidy53cml0ZSh0aGlzLmhlYWRlci50b0J1ZmZlcigpKTtcbiAgYncud3JpdGVVSW50MzJMRSh0aGlzLm51bVRyYW5zYWN0aW9ucyk7XG4gIGJ3LndyaXRlVmFyaW50TnVtKHRoaXMuaGFzaGVzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oYXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBidy53cml0ZShCdWZmZXIuZnJvbSh0aGlzLmhhc2hlc1tpXSwgJ2hleCcpKTtcbiAgfVxuICBidy53cml0ZVZhcmludE51bSh0aGlzLmZsYWdzLmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZsYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgYncud3JpdGVVSW50OCh0aGlzLmZsYWdzW2ldKTtcbiAgfVxuICByZXR1cm4gYnc7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgTWVya2xlQmxvY2sgcHJvcGVydGllc1xuICovXG5NZXJrbGVCbG9jay5wcm90b3R5cGUudG9PYmplY3QgPSBNZXJrbGVCbG9jay5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgaGVhZGVyOiB0aGlzLmhlYWRlci50b09iamVjdCgpLFxuICAgIG51bVRyYW5zYWN0aW9uczogdGhpcy5udW1UcmFuc2FjdGlvbnMsXG4gICAgaGFzaGVzOiB0aGlzLmhhc2hlcyxcbiAgICBmbGFnczogdGhpcy5mbGFnc1xuICB9O1xufTtcblxuLyoqXG4gKiBWZXJpZnkgdGhhdCB0aGUgTWVya2xlQmxvY2sgaXMgdmFsaWRcbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIFRydWUvRmFsc2Ugd2hldGhlciB0aGlzIE1lcmtsZUJsb2NrIGlzIFZhbGlkXG4gKi9cbk1lcmtsZUJsb2NrLnByb3RvdHlwZS52YWxpZE1lcmtsZVRyZWUgPSBmdW5jdGlvbiB2YWxpZE1lcmtsZVRyZWUoKSB7XG4gICQuY2hlY2tTdGF0ZShfLmlzQXJyYXkodGhpcy5mbGFncyksICdNZXJrbGVCbG9jayBmbGFncyBpcyBub3QgYW4gYXJyYXknKTtcbiAgJC5jaGVja1N0YXRlKF8uaXNBcnJheSh0aGlzLmhhc2hlcyksICdNZXJrbGVCbG9jayBoYXNoZXMgaXMgbm90IGFuIGFycmF5Jyk7XG5cbiAgLy8gQ2FuJ3QgaGF2ZSBtb3JlIGhhc2hlcyB0aGFuIG51bVRyYW5zYWN0aW9uc1xuICBpZih0aGlzLmhhc2hlcy5sZW5ndGggPiB0aGlzLm51bVRyYW5zYWN0aW9ucykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENhbid0IGhhdmUgbW9yZSBmbGFnIGJpdHMgdGhhbiBudW0gaGFzaGVzXG4gIGlmKHRoaXMuZmxhZ3MubGVuZ3RoICogOCA8IHRoaXMuaGFzaGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBoZWlnaHQgPSB0aGlzLl9jYWxjVHJlZUhlaWdodCgpO1xuICB2YXIgb3B0cyA9IHsgaGFzaGVzVXNlZDogMCwgZmxhZ0JpdHNVc2VkOiAwIH07XG4gIHZhciByb290ID0gdGhpcy5fdHJhdmVyc2VNZXJrbGVUcmVlKGhlaWdodCwgMCwgb3B0cyk7XG4gIGlmKG9wdHMuaGFzaGVzVXNlZCAhPT0gdGhpcy5oYXNoZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBCdWZmZXJVdGlsLmVxdWFscyhyb290LCB0aGlzLmhlYWRlci5tZXJrbGVSb290KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgbGlzdCBvZiBhbGwgdGhlIHR4cyBoYXNoIHRoYXQgbWF0Y2ggdGhlIGZpbHRlclxuICogQHJldHVybnMge0FycmF5fSAtIHR4cyBoYXNoIHRoYXQgbWF0Y2ggdGhlIGZpbHRlclxuICovXG5NZXJrbGVCbG9jay5wcm90b3R5cGUuZmlsdGVyZFR4c0hhc2ggPSBmdW5jdGlvbiBmaWx0ZXJkVHhzSGFzaCgpIHtcbiAgJC5jaGVja1N0YXRlKF8uaXNBcnJheSh0aGlzLmZsYWdzKSwgJ01lcmtsZUJsb2NrIGZsYWdzIGlzIG5vdCBhbiBhcnJheScpO1xuICAkLmNoZWNrU3RhdGUoXy5pc0FycmF5KHRoaXMuaGFzaGVzKSwgJ01lcmtsZUJsb2NrIGhhc2hlcyBpcyBub3QgYW4gYXJyYXknKTtcblxuICAvLyBDYW4ndCBoYXZlIG1vcmUgaGFzaGVzIHRoYW4gbnVtVHJhbnNhY3Rpb25zXG4gIGlmKHRoaXMuaGFzaGVzLmxlbmd0aCA+IHRoaXMubnVtVHJhbnNhY3Rpb25zKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5NZXJrbGVCbG9jay5JbnZhbGlkTWVya2xlVHJlZSgpO1xuICB9XG5cbiAgLy8gQ2FuJ3QgaGF2ZSBtb3JlIGZsYWcgYml0cyB0aGFuIG51bSBoYXNoZXNcbiAgaWYodGhpcy5mbGFncy5sZW5ndGggKiA4IDwgdGhpcy5oYXNoZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5NZXJrbGVCbG9jay5JbnZhbGlkTWVya2xlVHJlZSgpO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgaGFzaCB0aGUgZmlsdGVyIGRvIG5vdCBtYXRjaCBhbnkgdHhzIGluIHRoZSBibG9ja1xuICBpZih0aGlzLmhhc2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgdmFyIGhlaWdodCA9IHRoaXMuX2NhbGNUcmVlSGVpZ2h0KCk7XG4gIHZhciBvcHRzID0geyBoYXNoZXNVc2VkOiAwLCBmbGFnQml0c1VzZWQ6IDAgfTtcbiAgdmFyIHR4cyA9IHRoaXMuX3RyYXZlcnNlTWVya2xlVHJlZShoZWlnaHQsIDAsIG9wdHMsIHRydWUpO1xuICBpZihvcHRzLmhhc2hlc1VzZWQgIT09IHRoaXMuaGFzaGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuTWVya2xlQmxvY2suSW52YWxpZE1lcmtsZVRyZWUoKTtcbiAgfVxuICByZXR1cm4gdHhzO1xufTtcblxuLyoqXG4gKiBUcmF2ZXJzZSBhIHRoZSB0cmVlIGluIHRoaXMgTWVya2xlQmxvY2ssIHZhbGlkYXRpbmcgaXQgYWxvbmcgdGhlIHdheVxuICogTW9kZWxlZCBhZnRlciBCaXRjb2luIENvcmUgbWVya2xlYmxvY2suY3BwIFRyYXZlcnNlQW5kRXh0cmFjdCgpXG4gKiBAcGFyYW0ge051bWJlcn0gLSBkZXB0aCAtIEN1cnJlbnQgaGVpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0gLSBwb3MgLSBDdXJyZW50IHBvc2l0aW9uIGluIHRoZSB0cmVlXG4gKiBAcGFyYW0ge09iamVjdH0gLSBvcHRzIC0gT2JqZWN0IHdpdGggdmFsdWVzIHRoYXQgbmVlZCB0byBiZSBtdXRhdGVkIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogQHBhcmFtIHtCb29sZWFufSAtIGNoZWNrRm9yVHhzIC0gaWYgdHJ1ZSByZXR1cm4gb3B0cy50eHMgZWxzZSByZXR1cm4gdGhlIE1lcmtsZSBIYXNoXG4gKiBAcGFyYW0ge051bWJlcn0gLSBvcHRzLmZsYWdCaXRzVXNlZCAtIE51bWJlciBvZiBmbGFnIGJpdHMgdXNlZCwgc2hvdWxkIHN0YXJ0IGF0IDBcbiAqIEBwYXJhbSB7TnVtYmVyfSAtIG9wdHMuaGFzaGVzVXNlZCAtIE51bWJlciBvZiBoYXNoZXMgdXNlZCwgc2hvdWxkIHN0YXJ0IGF0IDBcbiAqIEBwYXJhbSB7QXJyYXl9IC0gb3B0cy50eHMgLSBXaWxsIGZpbmlzaCBwb3B1bGF0ZWQgYnkgdHJhbnNhY3Rpb25zIGZvdW5kIGR1cmluZyB0cmF2ZXJzYWwgdGhhdCBtYXRjaCB0aGUgZmlsdGVyXG4gKiBAcmV0dXJucyB7QnVmZmVyfG51bGx9IC0gQnVmZmVyIGNvbnRhaW5pbmcgdGhlIE1lcmtsZSBIYXNoIGZvciB0aGF0IGhlaWdodFxuICogQHJldHVybnMge0FycmF5fSAtIHRyYW5zYWN0aW9ucyBmb3VuZCBkdXJpbmcgdHJhdmVyc2FsIHRoYXQgbWF0Y2ggdGhlIGZpbHRlclxuICogQHByaXZhdGVcbiAqL1xuTWVya2xlQmxvY2sucHJvdG90eXBlLl90cmF2ZXJzZU1lcmtsZVRyZWUgPSBmdW5jdGlvbiB0cmF2ZXJzZU1lcmtsZVRyZWUoZGVwdGgsIHBvcywgb3B0cywgY2hlY2tGb3JUeHMpIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6ICAxMiovXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnR4cyA9IG9wdHMudHhzIHx8IFtdO1xuICBvcHRzLmZsYWdCaXRzVXNlZCA9IG9wdHMuZmxhZ0JpdHNVc2VkIHx8IDA7XG4gIG9wdHMuaGFzaGVzVXNlZCA9IG9wdHMuaGFzaGVzVXNlZCB8fCAwO1xuICB2YXIgY2hlY2tGb3JUeHMgPSBjaGVja0ZvclR4cyB8fCBmYWxzZTtcblxuICBpZihvcHRzLmZsYWdCaXRzVXNlZCA+IHRoaXMuZmxhZ3MubGVuZ3RoICogOCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpc1BhcmVudE9mTWF0Y2ggPSAodGhpcy5mbGFnc1tvcHRzLmZsYWdCaXRzVXNlZCA+PiAzXSA+Pj4gKG9wdHMuZmxhZ0JpdHNVc2VkKysgJiA3KSkgJiAxO1xuICBpZihkZXB0aCA9PT0gMCB8fCAhaXNQYXJlbnRPZk1hdGNoKSB7XG4gICAgaWYob3B0cy5oYXNoZXNVc2VkID49IHRoaXMuaGFzaGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBoYXNoID0gdGhpcy5oYXNoZXNbb3B0cy5oYXNoZXNVc2VkKytdO1xuICAgIGlmKGRlcHRoID09PSAwICYmIGlzUGFyZW50T2ZNYXRjaCkge1xuICAgICAgb3B0cy50eHMucHVzaChoYXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhhc2gsICdoZXgnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVmdCA9IHRoaXMuX3RyYXZlcnNlTWVya2xlVHJlZShkZXB0aC0xLCBwb3MqMiwgb3B0cyk7XG4gICAgdmFyIHJpZ2h0ID0gbGVmdDtcbiAgICBpZihwb3MqMisxIDwgdGhpcy5fY2FsY1RyZWVXaWR0aChkZXB0aC0xKSkge1xuICAgICAgcmlnaHQgPSB0aGlzLl90cmF2ZXJzZU1lcmtsZVRyZWUoZGVwdGgtMSwgcG9zKjIrMSwgb3B0cyk7XG4gICAgfVxuICAgIGlmIChjaGVja0ZvclR4cyl7XG4gICAgICByZXR1cm4gb3B0cy50eHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBIYXNoLnNoYTI1NnNoYTI1NihuZXcgQnVmZmVyLmNvbmNhdChbbGVmdCwgcmlnaHRdKSk7XG4gICAgfTtcbiAgfVxufTtcblxuLyoqIENhbGN1bGF0ZXMgdGhlIHdpZHRoIG9mIGEgbWVya2xlIHRyZWUgYXQgYSBnaXZlbiBoZWlnaHQuXG4gKiAgTW9kZWxlZCBhZnRlciBCaXRjb2luIENvcmUgbWVya2xlYmxvY2suaCBDYWxjVHJlZVdpZHRoKClcbiAqIEBwYXJhbSB7TnVtYmVyfSAtIEhlaWdodCBhdCB3aGljaCB3ZSB3YW50IHRoZSB0cmVlIHdpZHRoXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIFdpZHRoIG9mIHRoZSB0cmVlIGF0IGEgZ2l2ZW4gaGVpZ2h0XG4gKiBAcHJpdmF0ZVxuICovXG5NZXJrbGVCbG9jay5wcm90b3R5cGUuX2NhbGNUcmVlV2lkdGggPSBmdW5jdGlvbiBjYWxjVHJlZVdpZHRoKGhlaWdodCkge1xuICByZXR1cm4gKHRoaXMubnVtVHJhbnNhY3Rpb25zICsgKDEgPDwgaGVpZ2h0KSAtIDEpID4+IGhlaWdodDtcbn07XG5cbi8qKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIG1lcmtsZSB0cmVlIGluIHRoaXMgTWVya2xlQmxvY2tcbiAqIEBwYXJhbSB7TnVtYmVyfSAtIEhlaWdodCBhdCB3aGljaCB3ZSB3YW50IHRoZSB0cmVlIHdpZHRoXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIEhlaWdodCBvZiB0aGUgbWVya2xlIHRyZWUgaW4gdGhpcyBNZXJrbGVCbG9ja1xuICogQHByaXZhdGVcbiAqL1xuTWVya2xlQmxvY2sucHJvdG90eXBlLl9jYWxjVHJlZUhlaWdodCA9IGZ1bmN0aW9uIGNhbGNUcmVlSGVpZ2h0KCkge1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgd2hpbGUgKHRoaXMuX2NhbGNUcmVlV2lkdGgoaGVpZ2h0KSA+IDEpIHtcbiAgICBoZWlnaHQrKztcbiAgfVxuICByZXR1cm4gaGVpZ2h0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufFN0cmluZ30gLSBUcmFuc2FjdGlvbiBvciBUcmFuc2FjdGlvbiBJRCBIYXNoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSByZXR1cm4gdHJ1ZS9mYWxzZSBpZiB0aGlzIE1lcmtsZUJsb2NrIGhhcyB0aGUgVFggb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5NZXJrbGVCbG9jay5wcm90b3R5cGUuaGFzVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBoYXNUcmFuc2FjdGlvbih0eCkge1xuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQodHgpLCAndHggY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuICAkLmNoZWNrQXJndW1lbnQodHggaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiB8fCB0eXBlb2YgdHggPT09ICdzdHJpbmcnLFxuICAgICAgJ0ludmFsaWQgdHggZ2l2ZW4sIHR4IG11c3QgYmUgYSBcInN0cmluZ1wiIG9yIFwiVHJhbnNhY3Rpb25cIicpO1xuXG4gIHZhciBoYXNoID0gdHg7XG4gIGlmKHR4IGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pIHtcbiAgICAvLyBXZSBuZWVkIHRvIHJldmVyc2UgdGhlIGlkIGhhc2ggZm9yIHRoZSBsb29rdXBcbiAgICBoYXNoID0gQnVmZmVyVXRpbC5yZXZlcnNlKEJ1ZmZlci5mcm9tKHR4LmlkLCAnaGV4JykpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIHZhciB0eHMgPSBbXTtcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2NhbGNUcmVlSGVpZ2h0KCk7XG4gIHRoaXMuX3RyYXZlcnNlTWVya2xlVHJlZShoZWlnaHQsIDAsIHsgdHhzOiB0eHMgfSk7XG4gIHJldHVybiB0eHMuaW5kZXhPZihoYXNoKSAhPT0gLTE7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSAtIE1lcmtsZUJsb2NrIGRhdGFcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQW4gT2JqZWN0IHJlcHJlc2VudGluZyBtZXJrbGVibG9jayBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5NZXJrbGVCbG9jay5fZnJvbUJ1ZmZlclJlYWRlciA9IGZ1bmN0aW9uIF9mcm9tQnVmZmVyUmVhZGVyKGJyKSB7XG4gICQuY2hlY2tTdGF0ZSghYnIuZmluaXNoZWQoKSwgJ05vIG1lcmtsZWJsb2NrIGRhdGEgcmVjZWl2ZWQnKTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5oZWFkZXIgPSBCbG9ja0hlYWRlci5mcm9tQnVmZmVyUmVhZGVyKGJyKTtcbiAgaW5mby5udW1UcmFuc2FjdGlvbnMgPSBici5yZWFkVUludDMyTEUoKTtcbiAgdmFyIG51bUhhc2hlcyA9IGJyLnJlYWRWYXJpbnROdW0oKTtcbiAgaW5mby5oYXNoZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1IYXNoZXM7IGkrKykge1xuICAgIGluZm8uaGFzaGVzLnB1c2goYnIucmVhZCgzMikudG9TdHJpbmcoJ2hleCcpKTtcbiAgfVxuICB2YXIgbnVtRmxhZ3MgPSBici5yZWFkVmFyaW50TnVtKCk7XG4gIGluZm8uZmxhZ3MgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IG51bUZsYWdzOyBpKyspIHtcbiAgICBpbmZvLmZsYWdzLnB1c2goYnIucmVhZFVJbnQ4KCkpO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gLSBBIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0XG4gKiBAcmV0dXJucyB7QmxvY2t9IC0gQW4gaW5zdGFuY2Ugb2YgYmxvY2tcbiAqL1xuTWVya2xlQmxvY2suZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7XG4gIHJldHVybiBuZXcgTWVya2xlQmxvY2sob2JqKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVya2xlQmxvY2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/block/merkleblock.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js":
/*!***************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/bn.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nconst BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\n\nvar reversebuf = function(buf) {\n  var buf2 = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function(n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function(str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function(buf, opts) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'first argument should be a buffer');\n  buf = Buffer.from(buf); // ensure Uint8Array is converted to Buffer\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function(buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\n\n\nBN.prototype.toNumber = function() {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function(opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function() {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n  return buf;\n};\n\nBN.prototype.toSM = function(opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function() {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.trim = function(buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function(buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\n\nmodule.exports = BN;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9ibi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsbURBQU87QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHlGQUF1QjtBQUN2QyxRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWdCOztBQUUzQztBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL2JuLmpzPzYzMzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcblxudmFyIHJldmVyc2VidWYgPSBmdW5jdGlvbihidWYpIHtcbiAgdmFyIGJ1ZjIgPSBCdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmMltpXSA9IGJ1ZltidWYubGVuZ3RoIC0gMSAtIGldO1xuICB9XG4gIHJldHVybiBidWYyO1xufTtcblxuQk4uWmVybyA9IG5ldyBCTigwKTtcbkJOLk9uZSA9IG5ldyBCTigxKTtcbkJOLk1pbnVzMSA9IG5ldyBCTigtMSk7XG5cbkJOLmZyb21OdW1iZXIgPSBmdW5jdGlvbihuKSB7XG4gICQuY2hlY2tBcmd1bWVudChfLmlzTnVtYmVyKG4pKTtcbiAgcmV0dXJuIG5ldyBCTihuKTtcbn07XG5cbkJOLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIsIGJhc2UpIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcoc3RyKSk7XG4gIHJldHVybiBuZXcgQk4oc3RyLCBiYXNlKTtcbn07XG5cbkJOLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWYsIG9wdHMpIHtcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSwgJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhIGJ1ZmZlcicpO1xuICBidWYgPSBCdWZmZXIuZnJvbShidWYpOyAvLyBlbnN1cmUgVWludDhBcnJheSBpcyBjb252ZXJ0ZWQgdG8gQnVmZmVyXG4gIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5lbmRpYW4gPT09ICdsaXR0bGUnKSB7XG4gICAgYnVmID0gcmV2ZXJzZWJ1ZihidWYpO1xuICB9XG4gIHZhciBoZXggPSBidWYudG9TdHJpbmcoJ2hleCcpO1xuICB2YXIgYm4gPSBuZXcgQk4oaGV4LCAxNik7XG4gIHJldHVybiBibjtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYSBCaWdOdW1iZXIgZnJvbSBhIFwic2lnbmVkIG1hZ25pdHVkZSBidWZmZXJcIlxuICogKGEgYnVmZmVyIHdoZXJlIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCByZXByZXNlbnRzIHRoZSBzaWduICgwID0gcG9zaXRpdmUsIC0xID0gbmVnYXRpdmUpKVxuICovXG5CTi5mcm9tU00gPSBmdW5jdGlvbihidWYsIG9wdHMpIHtcbiAgdmFyIHJldDtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQk4uZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbShbMF0pKTtcbiAgfVxuXG4gIHZhciBlbmRpYW4gPSAnYmlnJztcbiAgaWYgKG9wdHMpIHtcbiAgICBlbmRpYW4gPSBvcHRzLmVuZGlhbjtcbiAgfVxuICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJykge1xuICAgIGJ1ZiA9IHJldmVyc2VidWYoYnVmKTtcbiAgfVxuXG4gIGlmIChidWZbMF0gJiAweDgwKSB7XG4gICAgYnVmWzBdID0gYnVmWzBdICYgMHg3ZjtcbiAgICByZXQgPSBCTi5mcm9tQnVmZmVyKGJ1Zik7XG4gICAgcmV0Lm5lZygpLmNvcHkocmV0KTtcbiAgfSBlbHNlIHtcbiAgICByZXQgPSBCTi5mcm9tQnVmZmVyKGJ1Zik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwYXJzZUludCh0aGlzLnRvU3RyaW5nKDEwKSwgMTApO1xufTtcblxuQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgYnVmLCBoZXg7XG4gIGlmIChvcHRzICYmIG9wdHMuc2l6ZSkge1xuICAgIGhleCA9IHRoaXMudG9TdHJpbmcoMTYsIDIpO1xuICAgIHZhciBuYXRsZW4gPSBoZXgubGVuZ3RoIC8gMjtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcblxuICAgIGlmIChuYXRsZW4gPT09IG9wdHMuc2l6ZSkge1xuICAgICAgYnVmID0gYnVmO1xuICAgIH0gZWxzZSBpZiAobmF0bGVuID4gb3B0cy5zaXplKSB7XG4gICAgICBidWYgPSBCTi50cmltKGJ1ZiwgbmF0bGVuKTtcbiAgICB9IGVsc2UgaWYgKG5hdGxlbiA8IG9wdHMuc2l6ZSkge1xuICAgICAgYnVmID0gQk4ucGFkKGJ1ZiwgbmF0bGVuLCBvcHRzLnNpemUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoZXggPSB0aGlzLnRvU3RyaW5nKDE2LCAyKTtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5lbmRpYW4gPT09ICdsaXR0bGUnKSB7XG4gICAgYnVmID0gcmV2ZXJzZWJ1ZihidWYpO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbkJOLnByb3RvdHlwZS50b1NNQmlnRW5kaWFuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWY7XG4gIGlmICh0aGlzLmNtcChCTi5aZXJvKSA9PT0gLTEpIHtcbiAgICBidWYgPSB0aGlzLm5lZygpLnRvQnVmZmVyKCk7XG4gICAgaWYgKGJ1ZlswXSAmIDB4ODApIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFsweDgwXSksIGJ1Zl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZbMF0gPSBidWZbMF0gfCAweDgwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgaWYgKGJ1ZlswXSAmIDB4ODApIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFsweDAwXSksIGJ1Zl0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChidWYubGVuZ3RoID09PSAxICYgYnVmWzBdID09PSAwKSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oW10pO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5CTi5wcm90b3R5cGUudG9TTSA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgdmFyIGVuZGlhbiA9IG9wdHMgPyBvcHRzLmVuZGlhbiA6ICdiaWcnO1xuICB2YXIgYnVmID0gdGhpcy50b1NNQmlnRW5kaWFuKCk7XG5cbiAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpIHtcbiAgICBidWYgPSByZXZlcnNlYnVmKGJ1Zik7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgQk4gZnJvbSBhIFwiU2NyaXB0TnVtXCI6XG4gKiBUaGlzIGlzIGFuYWxvZ291cyB0byB0aGUgY29uc3RydWN0b3IgZm9yIENTY3JpcHROdW0gaW4gYml0Y29pbmQuIE1hbnkgb3BzIGluXG4gKiBiaXRjb2luZCdzIHNjcmlwdCBpbnRlcnByZXRlciB1c2UgQ1NjcmlwdE51bSwgd2hpY2ggaXMgbm90IHJlYWxseSBhIHByb3BlclxuICogYmlnbnVtLiBJbnN0ZWFkLCBhbiBlcnJvciBpcyB0aHJvd24gaWYgdHJ5aW5nIHRvIGlucHV0IGEgbnVtYmVyIGJpZ2dlciB0aGFuXG4gKiA0IGJ5dGVzLiBXZSBjb3B5IHRoYXQgYmVoYXZpb3IgaGVyZS4gQSB0aGlyZCBhcmd1bWVudCwgYHNpemVgLCBpcyBwcm92aWRlZCB0b1xuICogZXh0ZW5kIHRoZSBoYXJkIGxpbWl0IG9mIDQgYnl0ZXMsIGFzIHNvbWUgdXNhZ2VzIHJlcXVpcmUgbW9yZSB0aGFuIDQgYnl0ZXMuXG4gKi9cbkJOLmZyb21TY3JpcHROdW1CdWZmZXIgPSBmdW5jdGlvbihidWYsIGZSZXF1aXJlTWluaW1hbCwgc2l6ZSkge1xuICB2YXIgbk1heE51bVNpemUgPSBzaXplIHx8IDQ7XG4gICQuY2hlY2tBcmd1bWVudChidWYubGVuZ3RoIDw9IG5NYXhOdW1TaXplLCBuZXcgRXJyb3IoJ3NjcmlwdCBudW1iZXIgb3ZlcmZsb3cnKSk7XG4gIGlmIChmUmVxdWlyZU1pbmltYWwgJiYgYnVmLmxlbmd0aCA+IDApIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBudW1iZXIgaXMgZW5jb2RlZCB3aXRoIHRoZSBtaW5pbXVtIHBvc3NpYmxlXG4gICAgLy8gbnVtYmVyIG9mIGJ5dGVzLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIG1vc3Qtc2lnbmlmaWNhbnQtYnl0ZSAtIGV4Y2x1ZGluZyB0aGUgc2lnbiBiaXQgLSBpcyB6ZXJvXG4gICAgLy8gdGhlbiB3ZSdyZSBub3QgbWluaW1hbC4gTm90ZSBob3cgdGhpcyB0ZXN0IGFsc28gcmVqZWN0cyB0aGVcbiAgICAvLyBuZWdhdGl2ZS16ZXJvIGVuY29kaW5nLCAweDgwLlxuICAgIGlmICgoYnVmW2J1Zi5sZW5ndGggLSAxXSAmIDB4N2YpID09PSAwKSB7XG4gICAgICAvLyBPbmUgZXhjZXB0aW9uOiBpZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUgYnl0ZSBhbmQgdGhlIG1vc3RcbiAgICAgIC8vIHNpZ25pZmljYW50IGJpdCBvZiB0aGUgc2Vjb25kLW1vc3Qtc2lnbmlmaWNhbnQtYnl0ZSBpcyBzZXRcbiAgICAgIC8vIGl0IHdvdWxkIGNvbmZsaWN0IHdpdGggdGhlIHNpZ24gYml0LiBBbiBleGFtcGxlIG9mIHRoaXMgY2FzZVxuICAgICAgLy8gaXMgKy0yNTUsIHdoaWNoIGVuY29kZSB0byAweGZmMDAgYW5kIDB4ZmY4MCByZXNwZWN0aXZlbHkuXG4gICAgICAvLyAoYmlnLWVuZGlhbikuXG4gICAgICBpZiAoYnVmLmxlbmd0aCA8PSAxIHx8IChidWZbYnVmLmxlbmd0aCAtIDJdICYgMHg4MCkgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub24tbWluaW1hbGx5IGVuY29kZWQgc2NyaXB0IG51bWJlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gQk4uZnJvbVNNKGJ1Ziwge1xuICAgIGVuZGlhbjogJ2xpdHRsZSdcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoZSBjb3JvbGxhcnkgdG8gdGhlIGFib3ZlLCB3aXRoIHRoZSBub3RhYmxlIGV4Y2VwdGlvbiB0aGF0IHdlIGRvIG5vdCB0aHJvd1xuICogYW4gZXJyb3IgaWYgdGhlIG91dHB1dCBpcyBsYXJnZXIgdGhhbiBmb3VyIGJ5dGVzLiAoV2hpY2ggY2FuIGhhcHBlbiBpZlxuICogcGVyZm9ybWluZyBhIG51bWVyaWNhbCBvcGVyYXRpb24gdGhhdCByZXN1bHRzIGluIGFuIG92ZXJmbG93IHRvIG1vcmUgdGhhbiA0XG4gKiBieXRlcykuXG4gKi9cbkJOLnByb3RvdHlwZS50b1NjcmlwdE51bUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b1NNKHtcbiAgICBlbmRpYW46ICdsaXR0bGUnXG4gIH0pO1xufTtcblxuQk4udHJpbSA9IGZ1bmN0aW9uKGJ1ZiwgbmF0bGVuKSB7XG4gIHJldHVybiBidWYuc2xpY2UobmF0bGVuIC0gYnVmLmxlbmd0aCwgYnVmLmxlbmd0aCk7XG59O1xuXG5CTi5wYWQgPSBmdW5jdGlvbihidWYsIG5hdGxlbiwgc2l6ZSkge1xuICB2YXIgcmJ1ZiA9IEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICByYnVmW3JidWYubGVuZ3RoIC0gMSAtIGldID0gYnVmW2J1Zi5sZW5ndGggLSAxIC0gaV07XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHNpemUgLSBuYXRsZW47IGkrKykge1xuICAgIHJidWZbaV0gPSAwO1xuICB9XG4gIHJldHVybiByYnVmO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCTjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/ecdsa.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst BN = __webpack_require__(/*! ./bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nconst Point = __webpack_require__(/*! ./point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nconst Signature = __webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nconst PublicKey = __webpack_require__(/*! ../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nconst Random = __webpack_require__(/*! ./random */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\");\nconst Hash = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nconst BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\n\n/**\n * Attach the recovery factor i to an ECDSA signature.\n * @param {Buffer} hashbuf\n * @param {Signature} sig\n * @param {PulicKey} pubkey\n * @returns {Signature}\n */\nconst calci = function(hashbuf, sig, pubkey) {\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = getPublicKey(hashbuf, sig, i);\n    } catch (e) {\n      console.error(e);\n      continue;\n    }\n\n    if (Qprime.point.eq(pubkey.point)) {\n      sig.i = i;\n      sig.compressed = pubkey.compressed;\n      return sig;\n    }\n  }\n\n  throw new Error('Unable to find valid recovery factor');\n};\n\n/**\n * Information about public key recovery:\n * https://bitcointalk.org/index.php?topic=6430.0\n * http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k \n * @param {Buffer} hashbuf\n * @param {Signature} sig\n * @param {Number} i\n * @returns {PublicKey}\n */\nconst getPublicKey = function(hashbuf, sig, i) {\n  /* jshint maxstatements: 25 */\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\n\n  var e = BN.fromBuffer(hashbuf);\n  var r = sig.r;\n  var s = sig.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n\n  var n = Point.getN();\n  var G = Point.getG();\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.mul(n);\n\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  }\n\n  // Compute -e from e\n  var eNeg = e.neg().umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n  var rInv = r.invm(n);\n\n  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n\n  var pubkey = PublicKey.fromPoint(Q, sig.compressed);\n\n  return pubkey;\n};\n\n\n/**\n * Recover a public key from a signature.\n * @param {Buffer} hashbuf\n * @param {Signature} sig Signature with the recovery factor i.\n * @returns {PublicKey}\n */\nconst recoverPublicKey = function(hashbuf, sig) {\n  return getPublicKey(hashbuf, sig, sig.i);\n};\n\n\n/**\n * Generate a random k\n * @returns {BN}\n */\nconst getRandomK = function() {\n  var N = Point.getN();\n  var k;\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n  return k;\n};\n\n\n/**\n * Generate a deterministic k\n * REF: https://tools.ietf.org/html/rfc6979#section-3.2\n * @param {Buffer} hashbuf\n * @param {PrivateKey} privkey\n * @param {Number} badrs Increment until a valid k is found\n * @returns {BN}\n */\nconst getDeterministicK = function(hashbuf, privkey, badrs) {\n  /* jshint maxstatements: 25 */\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (!badrs) {\n    badrs = 0;\n  }\n  var v = Buffer.alloc(32);\n  v.fill(0x01);\n  var k = Buffer.alloc(32);\n  k.fill(0x00);\n  var x = privkey.bn.toBuffer({\n    size: 32\n  });\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);\n  // double hash v\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN();\n\n  // also explained in 3.2, we must ensure T is in the proper range (0, N)\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\n    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);\n    // double hash v\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n\n  return T;\n};\n\n\n/**\n * Convert s to a low s\n * see BIP 62, \"low S values in signatures\"\n * @param {BN} s\n * @returns {BN}\n */\nconst toLowS = function(s) {\n  if (s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    s = Point.getN().sub(s);\n  }\n  return s;\n};\n\n\n/**\n * Sign a hash with a private key.\n * @param {Buffer|Uint8Array} hashbuf\n * @param {PrivateKey} privkey\n * @param {Object|undefined} opts An object of optional parameters\n * @param {String} opts.endian 'big' or 'little' (default: big)\n * @param {Boolean} opts.randomK Use a random value for k - produces a non-deterministic signature (default: false)\n * @returns {Signature}\n */\nconst sign = function(hashbuf, privkey, opts) {\n  const { endian = 'big', randomK = false } = opts || {};\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, 'hashbuf must be a 32 byte buffer');\n  $.checkState(privkey && privkey.bn, 'privkey must be a PrivateKey');\n  \n  var d = privkey.bn;\n  hashbuf = Buffer.from(hashbuf);\n  if (endian === 'little') {\n    hashbuf.reverse();\n  }\n\n  var e = BN.fromBuffer(hashbuf);\n  var N = Point.getN();\n  var G = Point.getG();\n  // try different values of k until r, s are valid\n  var badrs = 0;\n  var k, Q, r, s;\n  do {\n    k = randomK ? getRandomK() : getDeterministicK(hashbuf, privkey, badrs);\n    badrs++;\n    Q = G.mul(k);\n    r = Q.x.umod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n\n  s = toLowS(s);\n\n  return new Signature({\n    s: BN.fromBuffer(s.toBuffer()),\n    r: BN.fromBuffer(r.toBuffer()),\n    compressed: privkey.publicKey.compressed\n  });\n};\n\n\n/**\n * Get signature verification error string\n * @param {Buffer} hashbuf\n * @param {Signature} sig\n * @param {PublicKey} pubkey\n * @param {Object|undefined} opts An object of optional parameters\n * @param {String} opts.endian 'big' or 'little' (default: big)\n * @returns {String|undefined} Returns an error string, or undefined if there is no error\n */\nconst verificationError = function(hashbuf, sig, pubkey, opts) {\n  const { endian = 'big' } = opts || {};\n\n  if (!BufferUtil.isBuffer(hashbuf) || hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  var r = sig.r;\n  var s = sig.s;\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n\n  var e = BN.fromBuffer(hashbuf, { endian });\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).umod(n);\n  var u2 = sinv.mul(r).umod(n);\n\n  var p = Point.getG().mulAdd(u1, pubkey.point, u2);\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n\n  if (p.getX().umod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  }\n\n  return; // no error\n};\n\n\n/**\n * Verify a signature\n * @param {Buffer} hashbuf\n * @param {Signature} sig\n * @param {PublicKey} pubkey\n * @param {Object|undefined} opts An object of optional parameters\n * @param {String} opts.endian 'big' or 'little' (default: big)\n * @returns {Boolean}\n */\nconst verify = function(hashbuf, sig, pubkey, opts) {\n  if (!pubkey) {\n    throw new Error('pubkey required for signature verification');\n  }\n  pubkey = new PublicKey(pubkey);\n  \n  if (!sig) {\n    throw new Error('signature required for verification');\n  }\n  sig = new Signature(sig);\n\n  return !verificationError(hashbuf, sig, pubkey, opts);\n};\n\nmodule.exports = {\n  sign,\n  verify,\n  verificationError,\n \n  // pubkey recovery methods\n  calci,\n  recoverPublicKey,\n};\n\nmodule.exports.__testing__ = {\n  getDeterministicK,\n  getPublicKey,\n  getRandomK,\n  toLowS,\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9lY2RzYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsK0RBQU07QUFDekIsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFjO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsbUVBQVE7QUFDN0IsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWdCO0FBQzNDLFVBQVUsbUJBQU8sQ0FBQyx5RkFBdUI7OztBQUd6QztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDBDQUEwQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVLGtDQUFrQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBLFVBQVUsaUJBQWlCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9lY2RzYS5qcz81NTIyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQk4gPSByZXF1aXJlKCcuL2JuJyk7XG5jb25zdCBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKTtcbmNvbnN0IFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5jb25zdCBQdWJsaWNLZXkgPSByZXF1aXJlKCcuLi9wdWJsaWNrZXknKTtcbmNvbnN0IFJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tJyk7XG5jb25zdCBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG5jb25zdCBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcbmNvbnN0ICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcblxuXG4vKipcbiAqIEF0dGFjaCB0aGUgcmVjb3ZlcnkgZmFjdG9yIGkgdG8gYW4gRUNEU0Egc2lnbmF0dXJlLlxuICogQHBhcmFtIHtCdWZmZXJ9IGhhc2hidWZcbiAqIEBwYXJhbSB7U2lnbmF0dXJlfSBzaWdcbiAqIEBwYXJhbSB7UHVsaWNLZXl9IHB1YmtleVxuICogQHJldHVybnMge1NpZ25hdHVyZX1cbiAqL1xuY29uc3QgY2FsY2kgPSBmdW5jdGlvbihoYXNoYnVmLCBzaWcsIHB1YmtleSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IGdldFB1YmxpY0tleShoYXNoYnVmLCBzaWcsIGkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoUXByaW1lLnBvaW50LmVxKHB1YmtleS5wb2ludCkpIHtcbiAgICAgIHNpZy5pID0gaTtcbiAgICAgIHNpZy5jb21wcmVzc2VkID0gcHVia2V5LmNvbXByZXNzZWQ7XG4gICAgICByZXR1cm4gc2lnO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59O1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHB1YmxpYyBrZXkgcmVjb3Zlcnk6XG4gKiBodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9NjQzMC4wXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5NjY1NDkxL2hvdy1kby1pLWdldC1hbi1lY2RzYS1wdWJsaWMta2V5LWZyb20tanVzdC1hLWJpdGNvaW4tc2lnbmF0dXJlLXNlYzEtNC0xLTYtayBcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoYnVmXG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybnMge1B1YmxpY0tleX1cbiAqL1xuY29uc3QgZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24oaGFzaGJ1Ziwgc2lnLCBpKSB7XG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyNSAqL1xuICAkLmNoZWNrQXJndW1lbnQoaSA9PT0gMCB8fCBpID09PSAxIHx8IGkgPT09IDIgfHwgaSA9PT0gMywgbmV3IEVycm9yKCdpIG11c3QgYmUgZXF1YWwgdG8gMCwgMSwgMiwgb3IgMycpKTtcblxuICB2YXIgZSA9IEJOLmZyb21CdWZmZXIoaGFzaGJ1Zik7XG4gIHZhciByID0gc2lnLnI7XG4gIHZhciBzID0gc2lnLnM7XG5cbiAgLy8gQSBzZXQgTFNCIHNpZ25pZmllcyB0aGF0IHRoZSB5LWNvb3JkaW5hdGUgaXMgb2RkXG4gIHZhciBpc1lPZGQgPSBpICYgMTtcblxuICAvLyBUaGUgbW9yZSBzaWduaWZpY2FudCBiaXQgc3BlY2lmaWVzIHdoZXRoZXIgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgLy8gZmlyc3Qgb3Igc2Vjb25kIGNhbmRpZGF0ZSBrZXkuXG4gIHZhciBpc1NlY29uZEtleSA9IGkgPj4gMTtcblxuICB2YXIgbiA9IFBvaW50LmdldE4oKTtcbiAgdmFyIEcgPSBQb2ludC5nZXRHKCk7XG5cbiAgLy8gMS4xIExldCB4ID0gciArIGpuXG4gIHZhciB4ID0gaXNTZWNvbmRLZXkgPyByLmFkZChuKSA6IHI7XG4gIHZhciBSID0gUG9pbnQuZnJvbVgoaXNZT2RkLCB4KTtcblxuICAvLyAxLjQgQ2hlY2sgdGhhdCBuUiBpcyBhdCBpbmZpbml0eVxuICB2YXIgblIgPSBSLm11bChuKTtcblxuICBpZiAoIW5SLmlzSW5maW5pdHkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignblIgaXMgbm90IGEgdmFsaWQgY3VydmUgcG9pbnQnKTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgLWUgZnJvbSBlXG4gIHZhciBlTmVnID0gZS5uZWcoKS51bW9kKG4pO1xuXG4gIC8vIDEuNi4xIENvbXB1dGUgUSA9IHJeLTEgKHNSIC0gZUcpXG4gIC8vIFEgPSByXi0xIChzUiArIC1lRylcbiAgdmFyIHJJbnYgPSByLmludm0obik7XG5cbiAgLy92YXIgUSA9IFIubXVsdGlwbHlUd28ocywgRywgZU5lZykubXVsKHJJbnYpO1xuICB2YXIgUSA9IFIubXVsKHMpLmFkZChHLm11bChlTmVnKSkubXVsKHJJbnYpO1xuXG4gIHZhciBwdWJrZXkgPSBQdWJsaWNLZXkuZnJvbVBvaW50KFEsIHNpZy5jb21wcmVzc2VkKTtcblxuICByZXR1cm4gcHVia2V5O1xufTtcblxuXG4vKipcbiAqIFJlY292ZXIgYSBwdWJsaWMga2V5IGZyb20gYSBzaWduYXR1cmUuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaGJ1ZlxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZyBTaWduYXR1cmUgd2l0aCB0aGUgcmVjb3ZlcnkgZmFjdG9yIGkuXG4gKiBAcmV0dXJucyB7UHVibGljS2V5fVxuICovXG5jb25zdCByZWNvdmVyUHVibGljS2V5ID0gZnVuY3Rpb24oaGFzaGJ1Ziwgc2lnKSB7XG4gIHJldHVybiBnZXRQdWJsaWNLZXkoaGFzaGJ1Ziwgc2lnLCBzaWcuaSk7XG59O1xuXG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20ga1xuICogQHJldHVybnMge0JOfVxuICovXG5jb25zdCBnZXRSYW5kb21LID0gZnVuY3Rpb24oKSB7XG4gIHZhciBOID0gUG9pbnQuZ2V0TigpO1xuICB2YXIgaztcbiAgZG8ge1xuICAgIGsgPSBCTi5mcm9tQnVmZmVyKFJhbmRvbS5nZXRSYW5kb21CdWZmZXIoMzIpKTtcbiAgfSB3aGlsZSAoIShrLmx0KE4pICYmIGsuZ3QoQk4uWmVybykpKTtcbiAgcmV0dXJuIGs7XG59O1xuXG5cbi8qKlxuICogR2VuZXJhdGUgYSBkZXRlcm1pbmlzdGljIGtcbiAqIFJFRjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5Nzkjc2VjdGlvbi0zLjJcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoYnVmXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZrZXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBiYWRycyBJbmNyZW1lbnQgdW50aWwgYSB2YWxpZCBrIGlzIGZvdW5kXG4gKiBAcmV0dXJucyB7Qk59XG4gKi9cbmNvbnN0IGdldERldGVybWluaXN0aWNLID0gZnVuY3Rpb24oaGFzaGJ1ZiwgcHJpdmtleSwgYmFkcnMpIHtcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDI1ICovXG4gIC8vIGlmIHIgb3IgcyB3ZXJlIGludmFsaWQgd2hlbiB0aGlzIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHNpZ25pbmcsXG4gIC8vIHdlIGRvIG5vdCB3YW50IHRvIGFjdHVhbGx5IGNvbXB1dGUgciwgcyBoZXJlIGZvciBlZmZpY2llbmN5LCBzbyxcbiAgLy8gd2UgY2FuIGluY3JlbWVudCBiYWRycy4gZXhwbGFpbmVkIGF0IGVuZCBvZiBSRkMgNjk3OSBzZWN0aW9uIDMuMlxuICBpZiAoIWJhZHJzKSB7XG4gICAgYmFkcnMgPSAwO1xuICB9XG4gIHZhciB2ID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgdi5maWxsKDB4MDEpO1xuICB2YXIgayA9IEJ1ZmZlci5hbGxvYygzMik7XG4gIGsuZmlsbCgweDAwKTtcbiAgdmFyIHggPSBwcml2a2V5LmJuLnRvQnVmZmVyKHtcbiAgICBzaXplOiAzMlxuICB9KTtcbiAgayA9IEhhc2guc2hhMjU2aG1hYyhCdWZmZXIuY29uY2F0KFt2LCBCdWZmZXIuZnJvbShbMHgwMF0pLCB4LCBoYXNoYnVmXSksIGspO1xuICB2ID0gSGFzaC5zaGEyNTZobWFjKHYsIGspO1xuICBrID0gSGFzaC5zaGEyNTZobWFjKEJ1ZmZlci5jb25jYXQoW3YsIEJ1ZmZlci5mcm9tKFsweDAxXSksIHgsIGhhc2hidWZdKSwgayk7XG4gIC8vIGRvdWJsZSBoYXNoIHZcbiAgdiA9IEhhc2guc2hhMjU2aG1hYyh2LCBrKTtcbiAgdiA9IEhhc2guc2hhMjU2aG1hYyh2LCBrKTtcbiAgdmFyIFQgPSBCTi5mcm9tQnVmZmVyKHYpO1xuICB2YXIgTiA9IFBvaW50LmdldE4oKTtcblxuICAvLyBhbHNvIGV4cGxhaW5lZCBpbiAzLjIsIHdlIG11c3QgZW5zdXJlIFQgaXMgaW4gdGhlIHByb3BlciByYW5nZSAoMCwgTilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYWRycyB8fCAhKFQubHQoTikgJiYgVC5ndChCTi5aZXJvKSk7IGkrKykge1xuICAgIGsgPSBIYXNoLnNoYTI1NmhtYWMoQnVmZmVyLmNvbmNhdChbdiwgQnVmZmVyLmZyb20oWzB4MDBdKV0pLCBrKTtcbiAgICAvLyBkb3VibGUgaGFzaCB2XG4gICAgdiA9IEhhc2guc2hhMjU2aG1hYyh2LCBrKTtcbiAgICB2ID0gSGFzaC5zaGEyNTZobWFjKHYsIGspO1xuICAgIFQgPSBCTi5mcm9tQnVmZmVyKHYpO1xuICB9XG5cbiAgcmV0dXJuIFQ7XG59O1xuXG5cbi8qKlxuICogQ29udmVydCBzIHRvIGEgbG93IHNcbiAqIHNlZSBCSVAgNjIsIFwibG93IFMgdmFsdWVzIGluIHNpZ25hdHVyZXNcIlxuICogQHBhcmFtIHtCTn0gc1xuICogQHJldHVybnMge0JOfVxuICovXG5jb25zdCB0b0xvd1MgPSBmdW5jdGlvbihzKSB7XG4gIGlmIChzLmd0KG5ldyBCTignN0ZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY1RDU3NkU3MzU3QTQ1MDFEREZFOTJGNDY2ODFCMjBBMCcsICdoZXgnKSkpIHtcbiAgICBzID0gUG9pbnQuZ2V0TigpLnN1YihzKTtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cblxuLyoqXG4gKiBTaWduIGEgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0ge0J1ZmZlcnxVaW50OEFycmF5fSBoYXNoYnVmXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gb3B0cyBBbiBvYmplY3Qgb2Ygb3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuZW5kaWFuICdiaWcnIG9yICdsaXR0bGUnIChkZWZhdWx0OiBiaWcpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdHMucmFuZG9tSyBVc2UgYSByYW5kb20gdmFsdWUgZm9yIGsgLSBwcm9kdWNlcyBhIG5vbi1kZXRlcm1pbmlzdGljIHNpZ25hdHVyZSAoZGVmYXVsdDogZmFsc2UpXG4gKiBAcmV0dXJucyB7U2lnbmF0dXJlfVxuICovXG5jb25zdCBzaWduID0gZnVuY3Rpb24oaGFzaGJ1ZiwgcHJpdmtleSwgb3B0cykge1xuICBjb25zdCB7IGVuZGlhbiA9ICdiaWcnLCByYW5kb21LID0gZmFsc2UgfSA9IG9wdHMgfHwge307XG4gICQuY2hlY2tTdGF0ZShCdWZmZXJVdGlsLmlzQnVmZmVyKGhhc2hidWYpICYmIGhhc2hidWYubGVuZ3RoID09PSAzMiwgJ2hhc2hidWYgbXVzdCBiZSBhIDMyIGJ5dGUgYnVmZmVyJyk7XG4gICQuY2hlY2tTdGF0ZShwcml2a2V5ICYmIHByaXZrZXkuYm4sICdwcml2a2V5IG11c3QgYmUgYSBQcml2YXRlS2V5Jyk7XG4gIFxuICB2YXIgZCA9IHByaXZrZXkuYm47XG4gIGhhc2hidWYgPSBCdWZmZXIuZnJvbShoYXNoYnVmKTtcbiAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpIHtcbiAgICBoYXNoYnVmLnJldmVyc2UoKTtcbiAgfVxuXG4gIHZhciBlID0gQk4uZnJvbUJ1ZmZlcihoYXNoYnVmKTtcbiAgdmFyIE4gPSBQb2ludC5nZXROKCk7XG4gIHZhciBHID0gUG9pbnQuZ2V0RygpO1xuICAvLyB0cnkgZGlmZmVyZW50IHZhbHVlcyBvZiBrIHVudGlsIHIsIHMgYXJlIHZhbGlkXG4gIHZhciBiYWRycyA9IDA7XG4gIHZhciBrLCBRLCByLCBzO1xuICBkbyB7XG4gICAgayA9IHJhbmRvbUsgPyBnZXRSYW5kb21LKCkgOiBnZXREZXRlcm1pbmlzdGljSyhoYXNoYnVmLCBwcml2a2V5LCBiYWRycyk7XG4gICAgYmFkcnMrKztcbiAgICBRID0gRy5tdWwoayk7XG4gICAgciA9IFEueC51bW9kKE4pO1xuICAgIHMgPSBrLmludm0oTikubXVsKGUuYWRkKGQubXVsKHIpKSkudW1vZChOKTtcbiAgfSB3aGlsZSAoci5jbXAoQk4uWmVybykgPD0gMCB8fCBzLmNtcChCTi5aZXJvKSA8PSAwKTtcblxuICBzID0gdG9Mb3dTKHMpO1xuXG4gIHJldHVybiBuZXcgU2lnbmF0dXJlKHtcbiAgICBzOiBCTi5mcm9tQnVmZmVyKHMudG9CdWZmZXIoKSksXG4gICAgcjogQk4uZnJvbUJ1ZmZlcihyLnRvQnVmZmVyKCkpLFxuICAgIGNvbXByZXNzZWQ6IHByaXZrZXkucHVibGljS2V5LmNvbXByZXNzZWRcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogR2V0IHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZXJyb3Igc3RyaW5nXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaGJ1ZlxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ1xuICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmtleVxuICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBvcHRzIEFuIG9iamVjdCBvZiBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5lbmRpYW4gJ2JpZycgb3IgJ2xpdHRsZScgKGRlZmF1bHQ6IGJpZylcbiAqIEByZXR1cm5zIHtTdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIGFuIGVycm9yIHN0cmluZywgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIGVycm9yXG4gKi9cbmNvbnN0IHZlcmlmaWNhdGlvbkVycm9yID0gZnVuY3Rpb24oaGFzaGJ1Ziwgc2lnLCBwdWJrZXksIG9wdHMpIHtcbiAgY29uc3QgeyBlbmRpYW4gPSAnYmlnJyB9ID0gb3B0cyB8fCB7fTtcblxuICBpZiAoIUJ1ZmZlclV0aWwuaXNCdWZmZXIoaGFzaGJ1ZikgfHwgaGFzaGJ1Zi5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuICdoYXNoYnVmIG11c3QgYmUgYSAzMiBieXRlIGJ1ZmZlcic7XG4gIH1cblxuICB2YXIgciA9IHNpZy5yO1xuICB2YXIgcyA9IHNpZy5zO1xuICBpZiAoIShyLmd0KEJOLlplcm8pICYmIHIubHQoUG9pbnQuZ2V0TigpKSkgfHwgIShzLmd0KEJOLlplcm8pICYmIHMubHQoUG9pbnQuZ2V0TigpKSkpIHtcbiAgICByZXR1cm4gJ3IgYW5kIHMgbm90IGluIHJhbmdlJztcbiAgfVxuXG4gIHZhciBlID0gQk4uZnJvbUJ1ZmZlcihoYXNoYnVmLCB7IGVuZGlhbiB9KTtcbiAgdmFyIG4gPSBQb2ludC5nZXROKCk7XG4gIHZhciBzaW52ID0gcy5pbnZtKG4pO1xuICB2YXIgdTEgPSBzaW52Lm11bChlKS51bW9kKG4pO1xuICB2YXIgdTIgPSBzaW52Lm11bChyKS51bW9kKG4pO1xuXG4gIHZhciBwID0gUG9pbnQuZ2V0RygpLm11bEFkZCh1MSwgcHVia2V5LnBvaW50LCB1Mik7XG4gIGlmIChwLmlzSW5maW5pdHkoKSkge1xuICAgIHJldHVybiAncCBpcyBpbmZpbml0eSc7XG4gIH1cblxuICBpZiAocC5nZXRYKCkudW1vZChuKS5jbXAocikgIT09IDApIHtcbiAgICByZXR1cm4gJ0ludmFsaWQgc2lnbmF0dXJlJztcbiAgfVxuXG4gIHJldHVybjsgLy8gbm8gZXJyb3Jcbn07XG5cblxuLyoqXG4gKiBWZXJpZnkgYSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoYnVmXG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVia2V5XG4gKiBAcGFyYW0ge09iamVjdHx1bmRlZmluZWR9IG9wdHMgQW4gb2JqZWN0IG9mIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmVuZGlhbiAnYmlnJyBvciAnbGl0dGxlJyAoZGVmYXVsdDogYmlnKVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmNvbnN0IHZlcmlmeSA9IGZ1bmN0aW9uKGhhc2hidWYsIHNpZywgcHVia2V5LCBvcHRzKSB7XG4gIGlmICghcHVia2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwdWJrZXkgcmVxdWlyZWQgZm9yIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24nKTtcbiAgfVxuICBwdWJrZXkgPSBuZXcgUHVibGljS2V5KHB1YmtleSk7XG4gIFxuICBpZiAoIXNpZykge1xuICAgIHRocm93IG5ldyBFcnJvcignc2lnbmF0dXJlIHJlcXVpcmVkIGZvciB2ZXJpZmljYXRpb24nKTtcbiAgfVxuICBzaWcgPSBuZXcgU2lnbmF0dXJlKHNpZyk7XG5cbiAgcmV0dXJuICF2ZXJpZmljYXRpb25FcnJvcihoYXNoYnVmLCBzaWcsIHB1YmtleSwgb3B0cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2lnbixcbiAgdmVyaWZ5LFxuICB2ZXJpZmljYXRpb25FcnJvcixcbiBcbiAgLy8gcHVia2V5IHJlY292ZXJ5IG1ldGhvZHNcbiAgY2FsY2ksXG4gIHJlY292ZXJQdWJsaWNLZXksXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fX3Rlc3RpbmdfXyA9IHtcbiAgZ2V0RGV0ZXJtaW5pc3RpY0ssXG4gIGdldFB1YmxpY0tleSxcbiAgZ2V0UmFuZG9tSyxcbiAgdG9Mb3dTLFxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/hash.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar Hash = module.exports;\n\nHash.sha1 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha1').update(buf).digest();\n};\n\nHash.sha1.blocksize = 512;\n\nHash.sha256 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha256').update(buf).digest();\n};\n\nHash.sha256.blocksize = 512;\n\nHash.sha256sha256 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.sha256(Hash.sha256(buf));\n};\n\nHash.ripemd160 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('ripemd160').update(buf).digest();\n};\n\nHash.sha256ripemd160 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.ripemd160(Hash.sha256(buf));\n};\n\nHash.sha512 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha512').update(buf).digest();\n};\n\nHash.sha512.blocksize = 1024;\n\nHash.hmac = function(hashf, data, key) {\n  //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\n  //http://tools.ietf.org/html/rfc4868#section-2\n  $.checkArgument(BufferUtil.isBuffer(data));\n  $.checkArgument(BufferUtil.isBuffer(key));\n  $.checkArgument(hashf.blocksize);\n\n  var blocksize = hashf.blocksize / 8;\n\n  if (key.length > blocksize) {\n    key = hashf(key);\n  } else if (key < blocksize) {\n    var fill = Buffer.alloc(blocksize);\n    fill.fill(0);\n    key.copy(fill);\n    key = fill;\n  }\n\n  var o_key = Buffer.alloc(blocksize);\n  o_key.fill(0x5c);\n\n  var i_key = Buffer.alloc(blocksize);\n  i_key.fill(0x36);\n\n  var o_key_pad = Buffer.alloc(blocksize);\n  var i_key_pad = Buffer.alloc(blocksize);\n  for (var i = 0; i < blocksize; i++) {\n    o_key_pad[i] = o_key[i] ^ key[i];\n    i_key_pad[i] = i_key[i] ^ key[i];\n  }\n\n  return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));\n};\n\nHash.sha256hmac = function(data, key) {\n  return Hash.hmac(Hash.sha256, data, key);\n};\n\nHash.sha512hmac = function(data, key) {\n  return Hash.hmac(Hash.sha512, data, key);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9oYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsUUFBUSxtQkFBTyxDQUFDLHlGQUF1Qjs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL2hhc2guanM/MmJiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbnZhciBIYXNoID0gbW9kdWxlLmV4cG9ydHM7XG5cbkhhc2guc2hhMSA9IGZ1bmN0aW9uKGJ1Zikge1xuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihidWYpKTtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGJ1ZikuZGlnZXN0KCk7XG59O1xuXG5IYXNoLnNoYTEuYmxvY2tzaXplID0gNTEyO1xuXG5IYXNoLnNoYTI1NiA9IGZ1bmN0aW9uKGJ1Zikge1xuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihidWYpKTtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYnVmKS5kaWdlc3QoKTtcbn07XG5cbkhhc2guc2hhMjU2LmJsb2Nrc2l6ZSA9IDUxMjtcblxuSGFzaC5zaGEyNTZzaGEyNTYgPSBmdW5jdGlvbihidWYpIHtcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHJldHVybiBIYXNoLnNoYTI1NihIYXNoLnNoYTI1NihidWYpKTtcbn07XG5cbkhhc2gucmlwZW1kMTYwID0gZnVuY3Rpb24oYnVmKSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZikpO1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3JpcGVtZDE2MCcpLnVwZGF0ZShidWYpLmRpZ2VzdCgpO1xufTtcblxuSGFzaC5zaGEyNTZyaXBlbWQxNjAgPSBmdW5jdGlvbihidWYpIHtcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHJldHVybiBIYXNoLnJpcGVtZDE2MChIYXNoLnNoYTI1NihidWYpKTtcbn07XG5cbkhhc2guc2hhNTEyID0gZnVuY3Rpb24oYnVmKSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZikpO1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTUxMicpLnVwZGF0ZShidWYpLmRpZ2VzdCgpO1xufTtcblxuSGFzaC5zaGE1MTIuYmxvY2tzaXplID0gMTAyNDtcblxuSGFzaC5obWFjID0gZnVuY3Rpb24oaGFzaGYsIGRhdGEsIGtleSkge1xuICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFzaC1iYXNlZF9tZXNzYWdlX2F1dGhlbnRpY2F0aW9uX2NvZGVcbiAgLy9odHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0ODY4I3NlY3Rpb24tMlxuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihkYXRhKSk7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGtleSkpO1xuICAkLmNoZWNrQXJndW1lbnQoaGFzaGYuYmxvY2tzaXplKTtcblxuICB2YXIgYmxvY2tzaXplID0gaGFzaGYuYmxvY2tzaXplIC8gODtcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGhhc2hmKGtleSk7XG4gIH0gZWxzZSBpZiAoa2V5IDwgYmxvY2tzaXplKSB7XG4gICAgdmFyIGZpbGwgPSBCdWZmZXIuYWxsb2MoYmxvY2tzaXplKTtcbiAgICBmaWxsLmZpbGwoMCk7XG4gICAga2V5LmNvcHkoZmlsbCk7XG4gICAga2V5ID0gZmlsbDtcbiAgfVxuXG4gIHZhciBvX2tleSA9IEJ1ZmZlci5hbGxvYyhibG9ja3NpemUpO1xuICBvX2tleS5maWxsKDB4NWMpO1xuXG4gIHZhciBpX2tleSA9IEJ1ZmZlci5hbGxvYyhibG9ja3NpemUpO1xuICBpX2tleS5maWxsKDB4MzYpO1xuXG4gIHZhciBvX2tleV9wYWQgPSBCdWZmZXIuYWxsb2MoYmxvY2tzaXplKTtcbiAgdmFyIGlfa2V5X3BhZCA9IEJ1ZmZlci5hbGxvYyhibG9ja3NpemUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgb19rZXlfcGFkW2ldID0gb19rZXlbaV0gXiBrZXlbaV07XG4gICAgaV9rZXlfcGFkW2ldID0gaV9rZXlbaV0gXiBrZXlbaV07XG4gIH1cblxuICByZXR1cm4gaGFzaGYoQnVmZmVyLmNvbmNhdChbb19rZXlfcGFkLCBoYXNoZihCdWZmZXIuY29uY2F0KFtpX2tleV9wYWQsIGRhdGFdKSldKSk7XG59O1xuXG5IYXNoLnNoYTI1NmhtYWMgPSBmdW5jdGlvbihkYXRhLCBrZXkpIHtcbiAgcmV0dXJuIEhhc2guaG1hYyhIYXNoLnNoYTI1NiwgZGF0YSwga2V5KTtcbn07XG5cbkhhc2guc2hhNTEyaG1hYyA9IGZ1bmN0aW9uKGRhdGEsIGtleSkge1xuICByZXR1cm4gSGFzaC5obWFjKEhhc2guc2hhNTEyLCBkYXRhLCBrZXkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/point.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! ./bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\n\nvar EC = (__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\").ec);\nvar ec = new EC('secp256k1');\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\nvar Point = function Point(x, y, isRed) {\n  try {\n    var point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid Point');\n  }\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\nPoint.fromX = function fromX(odd, x){\n  try {\n    var point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid X');\n  }\n  point.validate();\n  return point;\n};\n\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n * (A.K.A curve order)\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\n/**\n * Secp256k1 field size\n * @returns {BN} A BN instance of the field size\n */\nPoint.getP = function() {\n  return ec.curve.p.clone();\n};\n\nPoint.prototype._getX = Point.prototype.getX;\n\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nPoint.prototype._getY = Point.prototype.getY;\n\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\nPoint.prototype.validate = function validate() {\n\n  if (this.isInfinity()){\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  var p2;\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n\n\n  //todo: needs test case\n  if (!(this.mul(Point.getN()).isInfinity())) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({size: 32});\n  var ybuf = point.getY().toBuffer({size: 32});\n\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n  return BufferUtil.concat([prefix, xbuf]);\n};\n\n\nPoint.prototype.liftX = function() {\n  const fieldSize = Point.getP();\n  const zero = new BN(0);\n  const one = new BN(1);\n  const two = new BN(2);\n  const three = new BN(3);\n  const four = new BN(4);\n  const seven = new BN(7);\n  const red = BN.red('k256');\n\n  const c = this.x.pow(three).add(seven).mod(fieldSize);\n  const y = c.toRed(red).redPow(fieldSize.add(one).div(four)).mod(fieldSize);\n  \n  if (!c.eq(y.pow(two).mod(fieldSize))) {\n    throw new Error('liftX failed');\n  }\n  \n  const pointX = this.x.red ? this.x.fromRed() : this.x;\n  const pointY = y.mod(two).eq(zero) ? y.fromRed() : fieldSize.sub(y)\n  return new Point(pointX, pointY, true);\n};\n\nmodule.exports = Point;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9wb2ludC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsK0RBQU07QUFDdkIsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWdCOztBQUV6QyxTQUFTLHlGQUFzQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFdBQVc7QUFDdEIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0Msb0NBQW9DLFNBQVM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9jcnlwdG8vcG9pbnQuanM/ZmU1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJy4vYm4nKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcblxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lYztcbnZhciBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJyk7XG52YXIgZWNQb2ludCA9IGVjLmN1cnZlLnBvaW50LmJpbmQoZWMuY3VydmUpO1xudmFyIGVjUG9pbnRGcm9tWCA9IGVjLmN1cnZlLnBvaW50RnJvbVguYmluZChlYy5jdXJ2ZSk7XG5cbi8qKlxuICpcbiAqIEluc3RhbnRpYXRlIGEgdmFsaWQgc2VjcDI1NmsxIFBvaW50IGZyb20gdGhlIFggYW5kIFkgY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtCTnxTdHJpbmd9IHggLSBUaGUgWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge0JOfFN0cmluZ30geSAtIFRoZSBZIGNvb3JkaW5hdGVcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljXG4gKiBAYXVnbWVudHMgZWxsaXB0aWMuY3VydmUucG9pbnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBBIHZhbGlkYXRpb24gZXJyb3IgaWYgZXhpc3RzXG4gKiBAcmV0dXJucyB7UG9pbnR9IEFuIGluc3RhbmNlIG9mIFBvaW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFBvaW50ID0gZnVuY3Rpb24gUG9pbnQoeCwgeSwgaXNSZWQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcG9pbnQgPSBlY1BvaW50KHgsIHksIGlzUmVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQb2ludCcpO1xuICB9XG4gIHBvaW50LnZhbGlkYXRlKCk7XG4gIHJldHVybiBwb2ludDtcbn07XG5cblBvaW50LnByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihlYy5jdXJ2ZS5wb2ludCgpKTtcblxuLyoqXG4gKlxuICogSW5zdGFudGlhdGUgYSB2YWxpZCBzZWNwMjU2azEgUG9pbnQgZnJvbSBvbmx5IHRoZSBYIGNvb3JkaW5hdGVcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9kZCAtIElmIHRoZSBZIGNvb3JkaW5hdGUgaXMgb2RkXG4gKiBAcGFyYW0ge0JOfFN0cmluZ30geCAtIFRoZSBYIGNvb3JkaW5hdGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBBIHZhbGlkYXRpb24gZXJyb3IgaWYgZXhpc3RzXG4gKiBAcmV0dXJucyB7UG9pbnR9IEFuIGluc3RhbmNlIG9mIFBvaW50XG4gKi9cblBvaW50LmZyb21YID0gZnVuY3Rpb24gZnJvbVgob2RkLCB4KXtcbiAgdHJ5IHtcbiAgICB2YXIgcG9pbnQgPSBlY1BvaW50RnJvbVgoeCwgb2RkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBYJyk7XG4gIH1cbiAgcG9pbnQudmFsaWRhdGUoKTtcbiAgcmV0dXJuIHBvaW50O1xufTtcblxuLyoqXG4gKlxuICogV2lsbCByZXR1cm4gYSBzZWNwMjU2azEgRUNEU0EgYmFzZSBwb2ludC5cbiAqXG4gKiBAbGluayBodHRwczovL2VuLmJpdGNvaW4uaXQvd2lraS9TZWNwMjU2azFcbiAqIEByZXR1cm5zIHtQb2ludH0gQW4gaW5zdGFuY2Ugb2YgdGhlIGJhc2UgcG9pbnQuXG4gKi9cblBvaW50LmdldEcgPSBmdW5jdGlvbiBnZXRHKCkge1xuICByZXR1cm4gZWMuY3VydmUuZztcbn07XG5cbi8qKlxuICpcbiAqIFdpbGwgcmV0dXJuIHRoZSBtYXggb2YgcmFuZ2Ugb2YgdmFsaWQgcHJpdmF0ZSBrZXlzIGFzIGdvdmVybmVkIGJ5IHRoZSBzZWNwMjU2azEgRUNEU0Egc3RhbmRhcmQuXG4gKiAoQS5LLkEgY3VydmUgb3JkZXIpXG4gKiBAbGluayBodHRwczovL2VuLmJpdGNvaW4uaXQvd2lraS9Qcml2YXRlX2tleSNSYW5nZV9vZl92YWxpZF9FQ0RTQV9wcml2YXRlX2tleXNcbiAqIEByZXR1cm5zIHtCTn0gQSBCTiBpbnN0YW5jZSBvZiB0aGUgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVcbiAqL1xuUG9pbnQuZ2V0TiA9IGZ1bmN0aW9uIGdldE4oKSB7XG4gIHJldHVybiBuZXcgQk4oZWMuY3VydmUubi50b0FycmF5KCkpO1xufTtcblxuLyoqXG4gKiBTZWNwMjU2azEgZmllbGQgc2l6ZVxuICogQHJldHVybnMge0JOfSBBIEJOIGluc3RhbmNlIG9mIHRoZSBmaWVsZCBzaXplXG4gKi9cblBvaW50LmdldFAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGVjLmN1cnZlLnAuY2xvbmUoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0WCA9IFBvaW50LnByb3RvdHlwZS5nZXRYO1xuXG4vKipcbiAqXG4gKiBXaWxsIHJldHVybiB0aGUgWCBjb29yZGluYXRlIG9mIHRoZSBQb2ludFxuICpcbiAqIEByZXR1cm5zIHtCTn0gQSBCTiBpbnN0YW5jZSBvZiB0aGUgWCBjb29yZGluYXRlXG4gKi9cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIG5ldyBCTih0aGlzLl9nZXRYKCkudG9BcnJheSgpKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0WSA9IFBvaW50LnByb3RvdHlwZS5nZXRZO1xuXG4vKipcbiAqXG4gKiBXaWxsIHJldHVybiB0aGUgWSBjb29yZGluYXRlIG9mIHRoZSBQb2ludFxuICpcbiAqIEByZXR1cm5zIHtCTn0gQSBCTiBpbnN0YW5jZSBvZiB0aGUgWSBjb29yZGluYXRlXG4gKi9cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgcmV0dXJuIG5ldyBCTih0aGlzLl9nZXRZKCkudG9BcnJheSgpKTtcbn07XG5cbi8qKlxuICpcbiAqIFdpbGwgZGV0ZXJtaW5lIGlmIHRoZSBwb2ludCBpcyB2YWxpZFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vd3d3LmlhY3Iub3JnL2FyY2hpdmUvcGtjMjAwMy8yNTY3MDIxMS8yNTY3MDIxMS5wZGZcbiAqIEBwYXJhbSB7UG9pbnR9IEFuIGluc3RhbmNlIG9mIFBvaW50XG4gKiBAdGhyb3dzIHtFcnJvcn0gQSB2YWxpZGF0aW9uIGVycm9yIGlmIGV4aXN0c1xuICogQHJldHVybnMge1BvaW50fSBBbiBpbnN0YW5jZSBvZiB0aGUgc2FtZSBQb2ludFxuICovXG5Qb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcblxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpe1xuICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgY2Fubm90IGJlIGVxdWFsIHRvIEluZmluaXR5Jyk7XG4gIH1cblxuICB2YXIgcDI7XG4gIHRyeSB7XG4gICAgcDIgPSBlY1BvaW50RnJvbVgodGhpcy5nZXRYKCksIHRoaXMuZ2V0WSgpLmlzT2RkKCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBkb2VzIG5vdCBsaWUgb24gdGhlIGN1cnZlJyk7XG4gIH1cblxuICBpZiAocDIueS5jbXAodGhpcy55KSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB5IHZhbHVlIGZvciBjdXJ2ZS4nKTtcbiAgfVxuXG5cbiAgLy90b2RvOiBuZWVkcyB0ZXN0IGNhc2VcbiAgaWYgKCEodGhpcy5tdWwoUG9pbnQuZ2V0TigpKS5pc0luZmluaXR5KCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCB0aW1lcyBOIG11c3QgYmUgaW5maW5pdHknKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xuXG59O1xuXG5Qb2ludC5wb2ludFRvQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIHBvaW50VG9Db21wcmVzc2VkKHBvaW50KSB7XG4gIHZhciB4YnVmID0gcG9pbnQuZ2V0WCgpLnRvQnVmZmVyKHtzaXplOiAzMn0pO1xuICB2YXIgeWJ1ZiA9IHBvaW50LmdldFkoKS50b0J1ZmZlcih7c2l6ZTogMzJ9KTtcblxuICB2YXIgcHJlZml4O1xuICB2YXIgb2RkID0geWJ1Zlt5YnVmLmxlbmd0aCAtIDFdICUgMjtcbiAgaWYgKG9kZCkge1xuICAgIHByZWZpeCA9IEJ1ZmZlci5mcm9tKFsweDAzXSk7XG4gIH0gZWxzZSB7XG4gICAgcHJlZml4ID0gQnVmZmVyLmZyb20oWzB4MDJdKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyVXRpbC5jb25jYXQoW3ByZWZpeCwgeGJ1Zl0pO1xufTtcblxuXG5Qb2ludC5wcm90b3R5cGUubGlmdFggPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZmllbGRTaXplID0gUG9pbnQuZ2V0UCgpO1xuICBjb25zdCB6ZXJvID0gbmV3IEJOKDApO1xuICBjb25zdCBvbmUgPSBuZXcgQk4oMSk7XG4gIGNvbnN0IHR3byA9IG5ldyBCTigyKTtcbiAgY29uc3QgdGhyZWUgPSBuZXcgQk4oMyk7XG4gIGNvbnN0IGZvdXIgPSBuZXcgQk4oNCk7XG4gIGNvbnN0IHNldmVuID0gbmV3IEJOKDcpO1xuICBjb25zdCByZWQgPSBCTi5yZWQoJ2syNTYnKTtcblxuICBjb25zdCBjID0gdGhpcy54LnBvdyh0aHJlZSkuYWRkKHNldmVuKS5tb2QoZmllbGRTaXplKTtcbiAgY29uc3QgeSA9IGMudG9SZWQocmVkKS5yZWRQb3coZmllbGRTaXplLmFkZChvbmUpLmRpdihmb3VyKSkubW9kKGZpZWxkU2l6ZSk7XG4gIFxuICBpZiAoIWMuZXEoeS5wb3codHdvKS5tb2QoZmllbGRTaXplKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpZnRYIGZhaWxlZCcpO1xuICB9XG4gIFxuICBjb25zdCBwb2ludFggPSB0aGlzLngucmVkID8gdGhpcy54LmZyb21SZWQoKSA6IHRoaXMueDtcbiAgY29uc3QgcG9pbnRZID0geS5tb2QodHdvKS5lcSh6ZXJvKSA/IHkuZnJvbVJlZCgpIDogZmllbGRTaXplLnN1Yih5KVxuICByZXR1cm4gbmV3IFBvaW50KHBvaW50WCwgcG9pbnRZLCB0cnVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/random.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction Random() {\n}\n\n/* secure random bytes that sometimes throws an error due to lack of entropy */\nRandom.getRandomBuffer = function(size) {\n  if (false)\n    {}\n  else\n    return Random.getRandomBufferNode(size);\n};\n\nRandom.getRandomBufferNode = function(size) {\n  var crypto = __webpack_require__(/*! crypto */ \"crypto\");\n  return crypto.randomBytes(size);\n};\n\nRandom.getRandomBufferBrowser = function(size) {\n  if (!window.crypto && !window.msCrypto)\n    throw new Error('window.crypto not available');\n\n  if (window.crypto && window.crypto.getRandomValues)\n    var crypto = window.crypto;\n  else if (window.msCrypto && window.msCrypto.getRandomValues) //internet explorer\n    var crypto = window.msCrypto;\n  else\n    throw new Error('window.crypto.getRandomValues not available');\n\n  var bbuf = new Uint8Array(size);\n  crypto.getRandomValues(bbuf);\n  var buf = Buffer.from(bbuf);\n\n  return buf;\n};\n\n/* insecure random bytes, but it never fails */\nRandom.getPseudoRandomBuffer = function(size) {\n  var b32 = 0x100000000;\n  var b = Buffer.alloc(size);\n  var r;\n\n  for (var i = 0; i <= size; i++) {\n    var j = Math.floor(i / 4);\n    var k = i - j * 4;\n    if (k === 0) {\n      r = Math.random() * b32;\n      b[i] = r & 0xff;\n    } else {\n      b[i] = (r = r >>> 8) & 0xff;\n    }\n  }\n\n  return b;\n};\n\nmodule.exports = Random;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9yYW5kb20uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFlO0FBQ3JCLElBQUksRUFBMkM7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL3JhbmRvbS5qcz84Zjk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gUmFuZG9tKCkge1xufVxuXG4vKiBzZWN1cmUgcmFuZG9tIGJ5dGVzIHRoYXQgc29tZXRpbWVzIHRocm93cyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBlbnRyb3B5ICovXG5SYW5kb20uZ2V0UmFuZG9tQnVmZmVyID0gZnVuY3Rpb24oc2l6ZSkge1xuICBpZiAocHJvY2Vzcy5icm93c2VyKVxuICAgIHJldHVybiBSYW5kb20uZ2V0UmFuZG9tQnVmZmVyQnJvd3NlcihzaXplKTtcbiAgZWxzZVxuICAgIHJldHVybiBSYW5kb20uZ2V0UmFuZG9tQnVmZmVyTm9kZShzaXplKTtcbn07XG5cblJhbmRvbS5nZXRSYW5kb21CdWZmZXJOb2RlID0gZnVuY3Rpb24oc2l6ZSkge1xuICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoc2l6ZSk7XG59O1xuXG5SYW5kb20uZ2V0UmFuZG9tQnVmZmVyQnJvd3NlciA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKCF3aW5kb3cuY3J5cHRvICYmICF3aW5kb3cubXNDcnlwdG8pXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3aW5kb3cuY3J5cHRvIG5vdCBhdmFpbGFibGUnKTtcblxuICBpZiAod2luZG93LmNyeXB0byAmJiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcylcbiAgICB2YXIgY3J5cHRvID0gd2luZG93LmNyeXB0bztcbiAgZWxzZSBpZiAod2luZG93Lm1zQ3J5cHRvICYmIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIC8vaW50ZXJuZXQgZXhwbG9yZXJcbiAgICB2YXIgY3J5cHRvID0gd2luZG93Lm1zQ3J5cHRvO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBub3QgYXZhaWxhYmxlJyk7XG5cbiAgdmFyIGJidWYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhiYnVmKTtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJidWYpO1xuXG4gIHJldHVybiBidWY7XG59O1xuXG4vKiBpbnNlY3VyZSByYW5kb20gYnl0ZXMsIGJ1dCBpdCBuZXZlciBmYWlscyAqL1xuUmFuZG9tLmdldFBzZXVkb1JhbmRvbUJ1ZmZlciA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdmFyIGIzMiA9IDB4MTAwMDAwMDAwO1xuICB2YXIgYiA9IEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgdmFyIHI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2l6ZTsgaSsrKSB7XG4gICAgdmFyIGogPSBNYXRoLmZsb29yKGkgLyA0KTtcbiAgICB2YXIgayA9IGkgLSBqICogNDtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgciA9IE1hdGgucmFuZG9tKCkgKiBiMzI7XG4gICAgICBiW2ldID0gciAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJbaV0gPSAociA9IHIgPj4+IDgpICYgMHhmZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/schnorr.js":
/*!********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/schnorr.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst JS = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nconst BN = __webpack_require__(/*! ./bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nconst Point = __webpack_require__(/*! ./point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nconst TaggedHash = __webpack_require__(/*! ./taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\nconst Schnorr = function Schnorr() {\n  if (!(this instanceof Schnorr)) {\n    return new Schnorr();\n  }\n  return this;\n};\n\nSchnorr.prototype.set = function() {};\n\n/**\n * Create a schnorr signature\n * @param {PrivateKey|Buffer|BN} privateKey\n * @param {String|Buffer} message Hex string or buffer\n * @param {String|Buffer} aux Hex string or buffer\n * @returns {Buffer}\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Default_Signing\n */\nSchnorr.sign = function(privateKey, message, aux) {\n  privateKey = Buffer.isBuffer(privateKey) ? privateKey : privateKey.toBuffer();\n  if (privateKey.length !== 32) {\n    throw new Error('Private key should be 32 bytes for schnorr signatures');\n  }\n\n  if (typeof message === 'string') {\n    $.checkArgument(JS.isHexaString(message), 'Schnorr message string is not hex');\n    message = Buffer.from(message, 'hex')\n  }\n  $.checkArgument($.isType(message, 'Buffer'), 'Schnorr message must be a hex string or buffer');\n\n  if (!aux) {\n    aux = crypto.randomBytes(32);\n  }\n  if (typeof aux === 'string') {\n    $.checkArgument(JS.isHexaString(aux), 'Schnorr aux string is not hex');\n    aux = Buffer.from(aux, 'hex')\n  }\n  $.checkArgument($.isType(aux, 'Buffer'), 'Schnorr aux must be a hex string or buffer');\n\n  const G = Point.getG();\n  const n = Point.getN();\n\n  const dPrime = new BN(privateKey);\n  if (dPrime.eqn(0) || dPrime.gte(n)) {\n    throw new Error('Invalid private key for schnorr signing');\n  }\n  const P = G.mul(dPrime);\n  const Pbuf = Buffer.from(P.encodeCompressed().slice(1)); // slice(1) removes the encoding prefix byte\n  const d = P.y.isEven() ? dPrime : n.sub(dPrime);\n  const t = d.xor(new BN(new TaggedHash('BIP0340/aux', aux).finalize()));\n  const rand = new TaggedHash('BIP0340/nonce', Buffer.concat([t.toBuffer(), Pbuf, message])).finalize();\n  const kPrime = new BN(rand).mod(n);\n  if (kPrime.eqn(0)) {\n    throw new Error('Error creating schnorr signature');\n  }\n  const R = G.mul(kPrime);\n  const Rbuf = Buffer.from(R.encodeCompressed().slice(1)); // slice(1) removes the encoding prefix byte\n  const k = R.y.isEven() ? kPrime : n.sub(kPrime);\n  const e = new BN(new TaggedHash('BIP0340/challenge', Buffer.concat([Rbuf, Pbuf, message])).finalize()).mod(n);\n  const sig = Buffer.concat([Rbuf, k.add(e.mul(d)).mod(n).toBuffer({ size: 32 })]);\n\n  if (!Schnorr.verify(Pbuf, message, sig)) {\n    throw new Error('Error creating schnorr signature. Verification failed');\n  }\n  return sig;\n};\n\n\n/**\n * Verify a schnorr signature\n * @param {PublicKey|Buffer} publicKey\n * @param {String|Buffer} message Hex string or buffer\n * @param {String|Signature|Buffer} signature Hex string, Signature instance, or buffer\n * @returns {Boolean}\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Verification\n */\nSchnorr.verify = function(publicKey, message, signature) {\n  if ($.isType(publicKey, 'PublicKey')) {\n    publicKey = publicKey.point.x.toBuffer();\n  }\n  if (publicKey.length !== 32) {\n    throw new Error('Public key should be 32 bytes for schnorr signatures');\n  }\n\n  if (typeof message === 'string') {\n    $.checkArgument(JS.isHexaString(message), 'Schnorr message string is not hex');\n    message = Buffer.from(message, 'hex');\n  }\n  if (message.length !== 32) {\n    throw new Error('Message should be a 32 byte buffer');\n  }\n\n  if (typeof signature === 'string') {\n    $.checkArgument(JS.isHexaString(signature), 'Schnorr signature string is not hex');\n    signature = Buffer.from(signature, 'hex');\n  }\n  if (typeof signature.toBuffer === 'function') {\n    signature = signature.toBuffer();\n    if (signature.length === 65) {\n      signature = signature.slice(0, 64); // remove the sighashType byte\n    }\n  }\n  if (signature.length !== 64) {\n    throw new Error('Signature should be a 64 byte buffer. Got ' + signature.length + ' bytes');\n  }\n\n  try {\n    const p = Point.getP();\n    const n = Point.getN();\n\n    const P = Point.fromX(false, publicKey).liftX();\n    const r = new BN(signature.slice(0, 32));\n    const s = new BN(signature.slice(32, 64));\n    if (r.gte(p) || s.gte(n)) {\n      return false;\n    }\n    const e = getE(r, P, message);\n    const G = Point.getG();\n    const R = G.mul(s).add(P.mul(e).neg());\n    if (R.inf || !R.y.isEven() || !R.x.eq(r)) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n/* Utility function used in Verify() */\nconst getE = function(r, P, message) {\n  const n = Point.getN();\n  const hash = new TaggedHash('BIP0340/challenge', Buffer.concat([r.toBuffer({ size: 32 }), P.x.toBuffer({ size: 32 }), message])).finalize();\n  return new BN(hash).mod(n);\n};\n\nmodule.exports = Schnorr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9zY2hub3JyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixVQUFVLG1CQUFPLENBQUMseUZBQXVCO0FBQ3pDLFdBQVcsbUJBQU8sQ0FBQyxtRUFBWTtBQUMvQixXQUFXLG1CQUFPLENBQUMsK0RBQU07QUFDekIsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFjOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EscUVBQXFFLFVBQVU7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGVBQWU7QUFDMUIsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFVBQVUsa0JBQWtCLFVBQVU7QUFDckg7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9jcnlwdG8vc2Nobm9yci5qcz84NjMyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuY29uc3QgSlMgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XG5jb25zdCBCTiA9IHJlcXVpcmUoJy4vYm4nKTtcbmNvbnN0IFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpO1xuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4vdGFnZ2VkaGFzaCcpO1xuXG5jb25zdCBTY2hub3JyID0gZnVuY3Rpb24gU2Nobm9ycigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjaG5vcnIpKSB7XG4gICAgcmV0dXJuIG5ldyBTY2hub3JyKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5TY2hub3JyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIENyZWF0ZSBhIHNjaG5vcnIgc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl8QnVmZmVyfEJOfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IG1lc3NhZ2UgSGV4IHN0cmluZyBvciBidWZmZXJcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gYXV4IEhleCBzdHJpbmcgb3IgYnVmZmVyXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2kjRGVmYXVsdF9TaWduaW5nXG4gKi9cblNjaG5vcnIuc2lnbiA9IGZ1bmN0aW9uKHByaXZhdGVLZXksIG1lc3NhZ2UsIGF1eCkge1xuICBwcml2YXRlS2V5ID0gQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXkpID8gcHJpdmF0ZUtleSA6IHByaXZhdGVLZXkudG9CdWZmZXIoKTtcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJpdmF0ZSBrZXkgc2hvdWxkIGJlIDMyIGJ5dGVzIGZvciBzY2hub3JyIHNpZ25hdHVyZXMnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAkLmNoZWNrQXJndW1lbnQoSlMuaXNIZXhhU3RyaW5nKG1lc3NhZ2UpLCAnU2Nobm9yciBtZXNzYWdlIHN0cmluZyBpcyBub3QgaGV4Jyk7XG4gICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsICdoZXgnKVxuICB9XG4gICQuY2hlY2tBcmd1bWVudCgkLmlzVHlwZShtZXNzYWdlLCAnQnVmZmVyJyksICdTY2hub3JyIG1lc3NhZ2UgbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYnVmZmVyJyk7XG5cbiAgaWYgKCFhdXgpIHtcbiAgICBhdXggPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpO1xuICB9XG4gIGlmICh0eXBlb2YgYXV4ID09PSAnc3RyaW5nJykge1xuICAgICQuY2hlY2tBcmd1bWVudChKUy5pc0hleGFTdHJpbmcoYXV4KSwgJ1NjaG5vcnIgYXV4IHN0cmluZyBpcyBub3QgaGV4Jyk7XG4gICAgYXV4ID0gQnVmZmVyLmZyb20oYXV4LCAnaGV4JylcbiAgfVxuICAkLmNoZWNrQXJndW1lbnQoJC5pc1R5cGUoYXV4LCAnQnVmZmVyJyksICdTY2hub3JyIGF1eCBtdXN0IGJlIGEgaGV4IHN0cmluZyBvciBidWZmZXInKTtcblxuICBjb25zdCBHID0gUG9pbnQuZ2V0RygpO1xuICBjb25zdCBuID0gUG9pbnQuZ2V0TigpO1xuXG4gIGNvbnN0IGRQcmltZSA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKGRQcmltZS5lcW4oMCkgfHwgZFByaW1lLmd0ZShuKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIGtleSBmb3Igc2Nobm9yciBzaWduaW5nJyk7XG4gIH1cbiAgY29uc3QgUCA9IEcubXVsKGRQcmltZSk7XG4gIGNvbnN0IFBidWYgPSBCdWZmZXIuZnJvbShQLmVuY29kZUNvbXByZXNzZWQoKS5zbGljZSgxKSk7IC8vIHNsaWNlKDEpIHJlbW92ZXMgdGhlIGVuY29kaW5nIHByZWZpeCBieXRlXG4gIGNvbnN0IGQgPSBQLnkuaXNFdmVuKCkgPyBkUHJpbWUgOiBuLnN1YihkUHJpbWUpO1xuICBjb25zdCB0ID0gZC54b3IobmV3IEJOKG5ldyBUYWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGF1eCkuZmluYWxpemUoKSkpO1xuICBjb25zdCByYW5kID0gbmV3IFRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCBCdWZmZXIuY29uY2F0KFt0LnRvQnVmZmVyKCksIFBidWYsIG1lc3NhZ2VdKSkuZmluYWxpemUoKTtcbiAgY29uc3Qga1ByaW1lID0gbmV3IEJOKHJhbmQpLm1vZChuKTtcbiAgaWYgKGtQcmltZS5lcW4oMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHNjaG5vcnIgc2lnbmF0dXJlJyk7XG4gIH1cbiAgY29uc3QgUiA9IEcubXVsKGtQcmltZSk7XG4gIGNvbnN0IFJidWYgPSBCdWZmZXIuZnJvbShSLmVuY29kZUNvbXByZXNzZWQoKS5zbGljZSgxKSk7IC8vIHNsaWNlKDEpIHJlbW92ZXMgdGhlIGVuY29kaW5nIHByZWZpeCBieXRlXG4gIGNvbnN0IGsgPSBSLnkuaXNFdmVuKCkgPyBrUHJpbWUgOiBuLnN1YihrUHJpbWUpO1xuICBjb25zdCBlID0gbmV3IEJOKG5ldyBUYWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIEJ1ZmZlci5jb25jYXQoW1JidWYsIFBidWYsIG1lc3NhZ2VdKSkuZmluYWxpemUoKSkubW9kKG4pO1xuICBjb25zdCBzaWcgPSBCdWZmZXIuY29uY2F0KFtSYnVmLCBrLmFkZChlLm11bChkKSkubW9kKG4pLnRvQnVmZmVyKHsgc2l6ZTogMzIgfSldKTtcblxuICBpZiAoIVNjaG5vcnIudmVyaWZ5KFBidWYsIG1lc3NhZ2UsIHNpZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHNjaG5vcnIgc2lnbmF0dXJlLiBWZXJpZmljYXRpb24gZmFpbGVkJyk7XG4gIH1cbiAgcmV0dXJuIHNpZztcbn07XG5cblxuLyoqXG4gKiBWZXJpZnkgYSBzY2hub3JyIHNpZ25hdHVyZVxuICogQHBhcmFtIHtQdWJsaWNLZXl8QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gbWVzc2FnZSBIZXggc3RyaW5nIG9yIGJ1ZmZlclxuICogQHBhcmFtIHtTdHJpbmd8U2lnbmF0dXJlfEJ1ZmZlcn0gc2lnbmF0dXJlIEhleCBzdHJpbmcsIFNpZ25hdHVyZSBpbnN0YW5jZSwgb3IgYnVmZmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpI1ZlcmlmaWNhdGlvblxuICovXG5TY2hub3JyLnZlcmlmeSA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgbWVzc2FnZSwgc2lnbmF0dXJlKSB7XG4gIGlmICgkLmlzVHlwZShwdWJsaWNLZXksICdQdWJsaWNLZXknKSkge1xuICAgIHB1YmxpY0tleSA9IHB1YmxpY0tleS5wb2ludC54LnRvQnVmZmVyKCk7XG4gIH1cbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQdWJsaWMga2V5IHNob3VsZCBiZSAzMiBieXRlcyBmb3Igc2Nobm9yciBzaWduYXR1cmVzJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50KEpTLmlzSGV4YVN0cmluZyhtZXNzYWdlKSwgJ1NjaG5vcnIgbWVzc2FnZSBzdHJpbmcgaXMgbm90IGhleCcpO1xuICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlLCAnaGV4Jyk7XG4gIH1cbiAgaWYgKG1lc3NhZ2UubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBzaG91bGQgYmUgYSAzMiBieXRlIGJ1ZmZlcicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50KEpTLmlzSGV4YVN0cmluZyhzaWduYXR1cmUpLCAnU2Nobm9yciBzaWduYXR1cmUgc3RyaW5nIGlzIG5vdCBoZXgnKTtcbiAgICBzaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUsICdoZXgnKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpZ25hdHVyZS50b0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS50b0J1ZmZlcigpO1xuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSA2NSkge1xuICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnNsaWNlKDAsIDY0KTsgLy8gcmVtb3ZlIHRoZSBzaWdoYXNoVHlwZSBieXRlXG4gICAgfVxuICB9XG4gIGlmIChzaWduYXR1cmUubGVuZ3RoICE9PSA2NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIHNob3VsZCBiZSBhIDY0IGJ5dGUgYnVmZmVyLiBHb3QgJyArIHNpZ25hdHVyZS5sZW5ndGggKyAnIGJ5dGVzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHAgPSBQb2ludC5nZXRQKCk7XG4gICAgY29uc3QgbiA9IFBvaW50LmdldE4oKTtcblxuICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tWChmYWxzZSwgcHVibGljS2V5KS5saWZ0WCgpO1xuICAgIGNvbnN0IHIgPSBuZXcgQk4oc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IG5ldyBCTihzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSk7XG4gICAgaWYgKHIuZ3RlKHApIHx8IHMuZ3RlKG4pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGUgPSBnZXRFKHIsIFAsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IEcgPSBQb2ludC5nZXRHKCk7XG4gICAgY29uc3QgUiA9IEcubXVsKHMpLmFkZChQLm11bChlKS5uZWcoKSk7XG4gICAgaWYgKFIuaW5mIHx8ICFSLnkuaXNFdmVuKCkgfHwgIVIueC5lcShyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyogVXRpbGl0eSBmdW5jdGlvbiB1c2VkIGluIFZlcmlmeSgpICovXG5jb25zdCBnZXRFID0gZnVuY3Rpb24ociwgUCwgbWVzc2FnZSkge1xuICBjb25zdCBuID0gUG9pbnQuZ2V0TigpO1xuICBjb25zdCBoYXNoID0gbmV3IFRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgQnVmZmVyLmNvbmNhdChbci50b0J1ZmZlcih7IHNpemU6IDMyIH0pLCBQLngudG9CdWZmZXIoeyBzaXplOiAzMiB9KSwgbWVzc2FnZV0pKS5maW5hbGl6ZSgpO1xuICByZXR1cm4gbmV3IEJOKGhhc2gpLm1vZChuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nobm9ycjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/schnorr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/signature.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! ./bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nvar Signature = function Signature(r, s, isSchnorr) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s, isSchnorr);\n  }\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s,\n      isSchnorr: isSchnorr\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 7 */\nSignature.prototype.set = function(obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n\n  // public key recovery parameter in range [0, 3]\n  this.i = typeof obj.i === 'undefined' ? this.i : obj.i;\n  // whether the recovered pubkey is compressed\n  this.compressed = typeof obj.compressed === 'undefined' ? this.compressed : obj.compressed;\n  this.isSchnorr = typeof obj.isSchnorr === 'undefined' ? this.isSchnorr : obj.isSchnorr;\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n\n  var sig = new Signature();\n\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function(buf, strict) {\n  var sig = new Signature();\n\n  // Schnorr Signatures use 65 byte for in tx r [len] 32 , s [len] 32, nhashtype\n  // NOTE: this check is not very reliable. You should use .fromSchnorr directly if you know it's a schnorr sig.\n  if((buf.length === 64 || buf.length === 65) && buf[0] != 0x30) {\n    return Signature.fromSchnorr(buf);\n  }\n  \n  $.checkArgument(!(buf.length === 64 && buf[0] === 0x30), new Error('64 DER (ecdsa) signatures not allowed'));\n  \n  var obj = Signature.parseDER(buf, strict);\n\n  sig.r = obj.r;\n  sig.s = obj.s;\n\n  return sig;\n};\n\n// The format used in a tx\nSignature.fromTxFormat = function(buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function(str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n\n\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\nSignature.parseDER = function(buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n\n  length = length < buflength ? length : buflength;\n\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n\n  return obj;\n};\n\n\nSignature.prototype.toCompact = function(i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n  if (compressed === false) {\n    val = val - 4;\n  }\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\n/**\n * Returns either a DER encoded buffer or a Schnorr encoded buffer if isSchnor == true\n */\nSignature.prototype.toBuffer = Signature.prototype.toDER = function() {\n  if(this.isSchnorr) {\n    const hashTypeBuf = !this.nhashtype || this.nhashtype === Signature.SIGHASH_DEFAULT ? Buffer.alloc(0) : Buffer.from([this.nhashtype]);\n    return Buffer.concat([this.r.toBuffer({ size: 32 }), this.s.toBuffer({ size: 32 }), hashTypeBuf]);\n  }\n\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function() {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\nSignature.isTxDER = function(buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n  var nLenR = buf[3];\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n  var nLenS = buf[5 + nLenR];\n  if ((nLenR + nLenS + 7) !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n  return true;\n};\n\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\nSignature.prototype.hasLowS = function() {\n  if (this.s.lt(new BN(1)) ||\n    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\nSignature.prototype.hasDefinedHashtype = function() {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  }\n  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n  return true;\n};\n\nSignature.prototype.toTxFormat = function() {\n  var derbuf = this.toDER();\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\n/**\n * Creates a Signature instance from a Schnorr sig\n * @param {Buffer} buf Schnorr signature buffer\n * @returns {Signature}\n */\nSignature.fromSchnorr = function(buf) {\n  $.checkArgument(Buffer.isBuffer(buf), 'Schnorr signature argument must be a buffer');\n  $.checkArgument(buf.length === 64 || buf.length === 65, 'Schnorr signatures must be 64 or 65 bytes');\n\n  const sig = new Signature();\n  let r = buf.slice(0,32);\n  let s = buf.slice(32, 64);\n  if (buf.length === 65) {\n    sig.nhashtype = buf[buf.length - 1];\n    $.checkState(sig.nhashtype !== Signature.SIGHASH_DEFAULT, new Error('invalid hashtype'));\n  } else {\n    sig.nhashtype = Signature.SIGHASH_DEFAULT;\n  }\n  sig.r = BN.fromBuffer(r);\n  sig.s = BN.fromBuffer(s);\n  sig.isSchnorr = true;\n  return sig;\n};\n\nSignature.SIGHASH_DEFAULT       = 0x00; //!< Taproot only; implied when sighash byte is missing, and equivalent to SIGHASH_ALL\nSignature.SIGHASH_ALL           = 0x01;\nSignature.SIGHASH_NONE          = 0x02;\nSignature.SIGHASH_SINGLE        = 0x03;\nSignature.SIGHASH_ANYONECANPAY  = 0x80;\n\nSignature.SIGHASH_OUTPUT_MASK = 3;\nSignature.SIGHASH_INPUT_MASK  = 128; // 0x80,\n\nSignature.Version = {};\nSignature.Version.BASE       = 0;\nSignature.Version.WITNESS_V0 = 1;\nSignature.Version.TAPROOT    = 2;\nSignature.Version.TAPSCRIPT  = 3;\n\nmodule.exports = Signature;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by9zaWduYXR1cmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsU0FBUyxtQkFBTyxDQUFDLCtEQUFNO0FBQ3ZCLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsbUVBQVk7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVLHFCQUFxQixVQUFVO0FBQ3JGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvY3J5cHRvL3NpZ25hdHVyZS5qcz8yOGEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnLi9ibicpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9qcycpO1xuXG52YXIgU2lnbmF0dXJlID0gZnVuY3Rpb24gU2lnbmF0dXJlKHIsIHMsIGlzU2Nobm9ycikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2lnbmF0dXJlKSkge1xuICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMsIGlzU2Nobm9ycik7XG4gIH1cbiAgaWYgKHIgaW5zdGFuY2VvZiBCTikge1xuICAgIHRoaXMuc2V0KHtcbiAgICAgIHI6IHIsXG4gICAgICBzOiBzLFxuICAgICAgaXNTY2hub3JyOiBpc1NjaG5vcnJcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChyKSB7XG4gICAgdmFyIG9iaiA9IHI7XG4gICAgdGhpcy5zZXQob2JqKTtcbiAgfVxufTtcblxuLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDcgKi9cblNpZ25hdHVyZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHRoaXMuciA9IG9iai5yIHx8IHRoaXMuciB8fCB1bmRlZmluZWQ7XG4gIHRoaXMucyA9IG9iai5zIHx8IHRoaXMucyB8fCB1bmRlZmluZWQ7XG5cbiAgLy8gcHVibGljIGtleSByZWNvdmVyeSBwYXJhbWV0ZXIgaW4gcmFuZ2UgWzAsIDNdXG4gIHRoaXMuaSA9IHR5cGVvZiBvYmouaSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmkgOiBvYmouaTtcbiAgLy8gd2hldGhlciB0aGUgcmVjb3ZlcmVkIHB1YmtleSBpcyBjb21wcmVzc2VkXG4gIHRoaXMuY29tcHJlc3NlZCA9IHR5cGVvZiBvYmouY29tcHJlc3NlZCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvbXByZXNzZWQgOiBvYmouY29tcHJlc3NlZDtcbiAgdGhpcy5pc1NjaG5vcnIgPSB0eXBlb2Ygb2JqLmlzU2Nobm9yciA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmlzU2Nobm9yciA6IG9iai5pc1NjaG5vcnI7XG4gIHRoaXMubmhhc2h0eXBlID0gb2JqLm5oYXNodHlwZSB8fCB0aGlzLm5oYXNodHlwZSB8fCB1bmRlZmluZWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuU2lnbmF0dXJlLmZyb21Db21wYWN0ID0gZnVuY3Rpb24oYnVmKSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZiksICdBcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIEJ1ZmZlcicpO1xuXG4gIHZhciBzaWcgPSBuZXcgU2lnbmF0dXJlKCk7XG5cbiAgdmFyIGNvbXByZXNzZWQgPSB0cnVlO1xuICB2YXIgaSA9IGJ1Zi5zbGljZSgwLCAxKVswXSAtIDI3IC0gNDtcbiAgaWYgKGkgPCAwKSB7XG4gICAgY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIGkgPSBpICsgNDtcbiAgfVxuXG4gIHZhciBiMiA9IGJ1Zi5zbGljZSgxLCAzMyk7XG4gIHZhciBiMyA9IGJ1Zi5zbGljZSgzMywgNjUpO1xuXG4gICQuY2hlY2tBcmd1bWVudChpID09PSAwIHx8IGkgPT09IDEgfHwgaSA9PT0gMiB8fCBpID09PSAzLCBuZXcgRXJyb3IoJ2kgbXVzdCBiZSAwLCAxLCAyLCBvciAzJykpO1xuICAkLmNoZWNrQXJndW1lbnQoYjIubGVuZ3RoID09PSAzMiwgbmV3IEVycm9yKCdyIG11c3QgYmUgMzIgYnl0ZXMnKSk7XG4gICQuY2hlY2tBcmd1bWVudChiMy5sZW5ndGggPT09IDMyLCBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAzMiBieXRlcycpKTtcblxuICBzaWcuY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XG4gIHNpZy5pID0gaTtcbiAgc2lnLnIgPSBCTi5mcm9tQnVmZmVyKGIyKTtcbiAgc2lnLnMgPSBCTi5mcm9tQnVmZmVyKGIzKTtcblxuICByZXR1cm4gc2lnO1xufTtcblxuU2lnbmF0dXJlLmZyb21ERVIgPSBTaWduYXR1cmUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1Ziwgc3RyaWN0KSB7XG4gIHZhciBzaWcgPSBuZXcgU2lnbmF0dXJlKCk7XG5cbiAgLy8gU2Nobm9yciBTaWduYXR1cmVzIHVzZSA2NSBieXRlIGZvciBpbiB0eCByIFtsZW5dIDMyICwgcyBbbGVuXSAzMiwgbmhhc2h0eXBlXG4gIC8vIE5PVEU6IHRoaXMgY2hlY2sgaXMgbm90IHZlcnkgcmVsaWFibGUuIFlvdSBzaG91bGQgdXNlIC5mcm9tU2Nobm9yciBkaXJlY3RseSBpZiB5b3Uga25vdyBpdCdzIGEgc2Nobm9yciBzaWcuXG4gIGlmKChidWYubGVuZ3RoID09PSA2NCB8fCBidWYubGVuZ3RoID09PSA2NSkgJiYgYnVmWzBdICE9IDB4MzApIHtcbiAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21TY2hub3JyKGJ1Zik7XG4gIH1cbiAgXG4gICQuY2hlY2tBcmd1bWVudCghKGJ1Zi5sZW5ndGggPT09IDY0ICYmIGJ1ZlswXSA9PT0gMHgzMCksIG5ldyBFcnJvcignNjQgREVSIChlY2RzYSkgc2lnbmF0dXJlcyBub3QgYWxsb3dlZCcpKTtcbiAgXG4gIHZhciBvYmogPSBTaWduYXR1cmUucGFyc2VERVIoYnVmLCBzdHJpY3QpO1xuXG4gIHNpZy5yID0gb2JqLnI7XG4gIHNpZy5zID0gb2JqLnM7XG5cbiAgcmV0dXJuIHNpZztcbn07XG5cbi8vIFRoZSBmb3JtYXQgdXNlZCBpbiBhIHR4XG5TaWduYXR1cmUuZnJvbVR4Rm9ybWF0ID0gZnVuY3Rpb24oYnVmKSB7XG4gIHZhciBuaGFzaHR5cGUgPSBidWYucmVhZFVJbnQ4KGJ1Zi5sZW5ndGggLSAxKTtcbiAgdmFyIGRlcmJ1ZiA9IGJ1Zi5zbGljZSgwLCBidWYubGVuZ3RoIC0gMSk7XG4gIHZhciBzaWcgPSBuZXcgU2lnbmF0dXJlLmZyb21ERVIoZGVyYnVmLCBmYWxzZSk7XG4gIHNpZy5uaGFzaHR5cGUgPSBuaGFzaHR5cGU7XG4gIHJldHVybiBzaWc7XG59O1xuXG5TaWduYXR1cmUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgYnVmID0gQnVmZmVyLmZyb20oc3RyLCAnaGV4Jyk7XG4gIHJldHVybiBTaWduYXR1cmUuZnJvbURFUihidWYpO1xufTtcblxuXG4vKipcbiAqIEluIG9yZGVyIHRvIG1pbWljIHRoZSBub24tc3RyaWN0IERFUiBlbmNvZGluZyBvZiBPcGVuU1NMLCBzZXQgc3RyaWN0ID0gZmFsc2UuXG4gKi9cblNpZ25hdHVyZS5wYXJzZURFUiA9IGZ1bmN0aW9uKGJ1Ziwgc3RyaWN0KSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKGJ1ZiksIG5ldyBFcnJvcignREVSIGZvcm1hdHRlZCBzaWduYXR1cmUgc2hvdWxkIGJlIGEgYnVmZmVyJykpO1xuICBpZiAoXy5pc1VuZGVmaW5lZChzdHJpY3QpKSB7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoZWFkZXIgPSBidWZbMF07XG4gICQuY2hlY2tBcmd1bWVudChoZWFkZXIgPT09IDB4MzAsIG5ldyBFcnJvcignSGVhZGVyIGJ5dGUgc2hvdWxkIGJlIDB4MzAnKSk7XG5cbiAgdmFyIGxlbmd0aCA9IGJ1ZlsxXTtcbiAgdmFyIGJ1Zmxlbmd0aCA9IGJ1Zi5zbGljZSgyKS5sZW5ndGg7XG4gICQuY2hlY2tBcmd1bWVudCghc3RyaWN0IHx8IGxlbmd0aCA9PT0gYnVmbGVuZ3RoLCBuZXcgRXJyb3IoJ0xlbmd0aCBieXRlIHNob3VsZCBsZW5ndGggb2Ygd2hhdCBmb2xsb3dzJykpO1xuXG4gIGxlbmd0aCA9IGxlbmd0aCA8IGJ1Zmxlbmd0aCA/IGxlbmd0aCA6IGJ1Zmxlbmd0aDtcblxuICB2YXIgcmhlYWRlciA9IGJ1ZlsyICsgMF07XG4gICQuY2hlY2tBcmd1bWVudChyaGVhZGVyID09PSAweDAyLCBuZXcgRXJyb3IoJ0ludGVnZXIgYnl0ZSBmb3IgciBzaG91bGQgYmUgMHgwMicpKTtcblxuICB2YXIgcmxlbmd0aCA9IGJ1ZlsyICsgMV07XG4gIHZhciByYnVmID0gYnVmLnNsaWNlKDIgKyAyLCAyICsgMiArIHJsZW5ndGgpO1xuICB2YXIgciA9IEJOLmZyb21CdWZmZXIocmJ1Zik7XG4gIHZhciBybmVnID0gYnVmWzIgKyAxICsgMV0gPT09IDB4MDAgPyB0cnVlIDogZmFsc2U7XG4gICQuY2hlY2tBcmd1bWVudChybGVuZ3RoID09PSByYnVmLmxlbmd0aCwgbmV3IEVycm9yKCdMZW5ndGggb2YgciBpbmNvcnJlY3QnKSk7XG5cbiAgdmFyIHNoZWFkZXIgPSBidWZbMiArIDIgKyBybGVuZ3RoICsgMF07XG4gICQuY2hlY2tBcmd1bWVudChzaGVhZGVyID09PSAweDAyLCBuZXcgRXJyb3IoJ0ludGVnZXIgYnl0ZSBmb3IgcyBzaG91bGQgYmUgMHgwMicpKTtcblxuICB2YXIgc2xlbmd0aCA9IGJ1ZlsyICsgMiArIHJsZW5ndGggKyAxXTtcbiAgdmFyIHNidWYgPSBidWYuc2xpY2UoMiArIDIgKyBybGVuZ3RoICsgMiwgMiArIDIgKyBybGVuZ3RoICsgMiArIHNsZW5ndGgpO1xuICB2YXIgcyA9IEJOLmZyb21CdWZmZXIoc2J1Zik7XG4gIHZhciBzbmVnID0gYnVmWzIgKyAyICsgcmxlbmd0aCArIDIgKyAyXSA9PT0gMHgwMCA/IHRydWUgOiBmYWxzZTtcbiAgJC5jaGVja0FyZ3VtZW50KHNsZW5ndGggPT09IHNidWYubGVuZ3RoLCBuZXcgRXJyb3IoJ0xlbmd0aCBvZiBzIGluY29ycmVjdCcpKTtcblxuICB2YXIgc3VtbGVuZ3RoID0gMiArIDIgKyBybGVuZ3RoICsgMiArIHNsZW5ndGg7XG4gICQuY2hlY2tBcmd1bWVudChsZW5ndGggPT09IHN1bWxlbmd0aCAtIDIsIG5ldyBFcnJvcignTGVuZ3RoIG9mIHNpZ25hdHVyZSBpbmNvcnJlY3QnKSk7XG5cbiAgdmFyIG9iaiA9IHtcbiAgICBoZWFkZXI6IGhlYWRlcixcbiAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICByaGVhZGVyOiByaGVhZGVyLFxuICAgIHJsZW5ndGg6IHJsZW5ndGgsXG4gICAgcm5lZzogcm5lZyxcbiAgICByYnVmOiByYnVmLFxuICAgIHI6IHIsXG4gICAgc2hlYWRlcjogc2hlYWRlcixcbiAgICBzbGVuZ3RoOiBzbGVuZ3RoLFxuICAgIHNuZWc6IHNuZWcsXG4gICAgc2J1Zjogc2J1ZixcbiAgICBzOiBzXG4gIH07XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0NvbXBhY3QgPSBmdW5jdGlvbihpLCBjb21wcmVzc2VkKSB7XG4gIGkgPSB0eXBlb2YgaSA9PT0gJ251bWJlcicgPyBpIDogdGhpcy5pO1xuICBjb21wcmVzc2VkID0gdHlwZW9mIGNvbXByZXNzZWQgPT09ICdib29sZWFuJyA/IGNvbXByZXNzZWQgOiB0aGlzLmNvbXByZXNzZWQ7XG5cbiAgaWYgKCEoaSA9PT0gMCB8fCBpID09PSAxIHx8IGkgPT09IDIgfHwgaSA9PT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2kgbXVzdCBiZSBlcXVhbCB0byAwLCAxLCAyLCBvciAzJyk7XG4gIH1cblxuICB2YXIgdmFsID0gaSArIDI3ICsgNDtcbiAgaWYgKGNvbXByZXNzZWQgPT09IGZhbHNlKSB7XG4gICAgdmFsID0gdmFsIC0gNDtcbiAgfVxuICB2YXIgYjEgPSBCdWZmZXIuZnJvbShbdmFsXSk7XG4gIHZhciBiMiA9IHRoaXMuci50b0J1ZmZlcih7XG4gICAgc2l6ZTogMzJcbiAgfSk7XG4gIHZhciBiMyA9IHRoaXMucy50b0J1ZmZlcih7XG4gICAgc2l6ZTogMzJcbiAgfSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtiMSwgYjIsIGIzXSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZWl0aGVyIGEgREVSIGVuY29kZWQgYnVmZmVyIG9yIGEgU2Nobm9yciBlbmNvZGVkIGJ1ZmZlciBpZiBpc1NjaG5vciA9PSB0cnVlXG4gKi9cblNpZ25hdHVyZS5wcm90b3R5cGUudG9CdWZmZXIgPSBTaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuaXNTY2hub3JyKSB7XG4gICAgY29uc3QgaGFzaFR5cGVCdWYgPSAhdGhpcy5uaGFzaHR5cGUgfHwgdGhpcy5uaGFzaHR5cGUgPT09IFNpZ25hdHVyZS5TSUdIQVNIX0RFRkFVTFQgPyBCdWZmZXIuYWxsb2MoMCkgOiBCdWZmZXIuZnJvbShbdGhpcy5uaGFzaHR5cGVdKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy5yLnRvQnVmZmVyKHsgc2l6ZTogMzIgfSksIHRoaXMucy50b0J1ZmZlcih7IHNpemU6IDMyIH0pLCBoYXNoVHlwZUJ1Zl0pO1xuICB9XG5cbiAgdmFyIHJuYnVmID0gdGhpcy5yLnRvQnVmZmVyKCk7XG4gIHZhciBzbmJ1ZiA9IHRoaXMucy50b0J1ZmZlcigpO1xuXG4gIHZhciBybmVnID0gcm5idWZbMF0gJiAweDgwID8gdHJ1ZSA6IGZhbHNlO1xuICB2YXIgc25lZyA9IHNuYnVmWzBdICYgMHg4MCA/IHRydWUgOiBmYWxzZTtcblxuICB2YXIgcmJ1ZiA9IHJuZWcgPyBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMHgwMF0pLCBybmJ1Zl0pIDogcm5idWY7XG4gIHZhciBzYnVmID0gc25lZyA/IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFsweDAwXSksIHNuYnVmXSkgOiBzbmJ1ZjtcblxuICB2YXIgcmxlbmd0aCA9IHJidWYubGVuZ3RoO1xuICB2YXIgc2xlbmd0aCA9IHNidWYubGVuZ3RoO1xuICB2YXIgbGVuZ3RoID0gMiArIHJsZW5ndGggKyAyICsgc2xlbmd0aDtcbiAgdmFyIHJoZWFkZXIgPSAweDAyO1xuICB2YXIgc2hlYWRlciA9IDB4MDI7XG4gIHZhciBoZWFkZXIgPSAweDMwO1xuXG4gIHZhciBkZXIgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbaGVhZGVyLCBsZW5ndGgsIHJoZWFkZXIsIHJsZW5ndGhdKSwgcmJ1ZiwgQnVmZmVyLmZyb20oW3NoZWFkZXIsIHNsZW5ndGhdKSwgc2J1Zl0pO1xuICByZXR1cm4gZGVyO1xufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVmID0gdGhpcy50b0RFUigpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0cmFuc2xhdGVkIGZyb20gYml0Y29pbmQncyBJc0RFUlNpZ25hdHVyZSBhbmQgaXMgdXNlZCBpblxuICogdGhlIHNjcmlwdCBpbnRlcnByZXRlci4gIFRoaXMgXCJERVJcIiBmb3JtYXQgYWN0dWFsbHkgaW5jbHVkZXMgYW4gZXh0cmEgYnl0ZSxcbiAqIHRoZSBuaGFzaHR5cGUsIGF0IHRoZSBlbmQuIEl0IGlzIHJlYWxseSB0aGUgdHggZm9ybWF0LCBub3QgREVSIGZvcm1hdC5cbiAqXG4gKiBBIGNhbm9uaWNhbCBzaWduYXR1cmUgZXhpc3RzIG9mOiBbMzBdIFt0b3RhbCBsZW5dIFswMl0gW2xlbiBSXSBbUl0gWzAyXSBbbGVuIFNdIFtTXSBbaGFzaHR5cGVdXG4gKiBXaGVyZSBSIGFuZCBTIGFyZSBub3QgbmVnYXRpdmUgKHRoZWlyIGZpcnN0IGJ5dGUgaGFzIGl0cyBoaWdoZXN0IGJpdCBub3Qgc2V0KSwgYW5kIG5vdFxuICogZXhjZXNzaXZlbHkgcGFkZGVkIChkbyBub3Qgc3RhcnQgd2l0aCBhIDAgYnl0ZSwgdW5sZXNzIGFuIG90aGVyd2lzZSBuZWdhdGl2ZSBudW1iZXIgZm9sbG93cyxcbiAqIGluIHdoaWNoIGNhc2UgYSBzaW5nbGUgMCBieXRlIGlzIG5lY2Vzc2FyeSBhbmQgZXZlbiByZXF1aXJlZCkuXG4gKlxuICogU2VlIGh0dHBzOi8vYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz04MzkyLm1zZzEyNzYyMyNtc2cxMjc2MjNcbiAqL1xuU2lnbmF0dXJlLmlzVHhERVIgPSBmdW5jdGlvbihidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPCA5KSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB0b28gc2hvcnRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGJ1Zi5sZW5ndGggPiA3Mykge1xuICAgIC8vIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB0b28gbG9uZ1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYnVmWzBdICE9PSAweDMwKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB3cm9uZyB0eXBlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChidWZbMV0gIT09IGJ1Zi5sZW5ndGggLSAzKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiB3cm9uZyBsZW5ndGggbWFya2VyXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBuTGVuUiA9IGJ1ZlszXTtcbiAgaWYgKDUgKyBuTGVuUiA+PSBidWYubGVuZ3RoKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBTIGxlbmd0aCBtaXNwbGFjZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG5MZW5TID0gYnVmWzUgKyBuTGVuUl07XG4gIGlmICgobkxlblIgKyBuTGVuUyArIDcpICE9PSBidWYubGVuZ3RoKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBSK1MgbGVuZ3RoIG1pc21hdGNoXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIFIgPSBidWYuc2xpY2UoNCk7XG4gIGlmIChidWZbNCAtIDJdICE9PSAweDAyKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBSIHZhbHVlIHR5cGUgbWlzbWF0Y2hcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5MZW5SID09PSAwKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBSIGxlbmd0aCBpcyB6ZXJvXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChSWzBdICYgMHg4MCkge1xuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUiB2YWx1ZSBuZWdhdGl2ZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobkxlblIgPiAxICYmIChSWzBdID09PSAweDAwKSAmJiAhKFJbMV0gJiAweDgwKSkge1xuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUiB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgUyA9IGJ1Zi5zbGljZSg2ICsgbkxlblIpO1xuICBpZiAoYnVmWzYgKyBuTGVuUiAtIDJdICE9PSAweDAyKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBTIHZhbHVlIHR5cGUgbWlzbWF0Y2hcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5MZW5TID09PSAwKSB7XG4gICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBTIGxlbmd0aCBpcyB6ZXJvXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChTWzBdICYgMHg4MCkge1xuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUyB2YWx1ZSBuZWdhdGl2ZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobkxlblMgPiAxICYmIChTWzBdID09PSAweDAwKSAmJiAhKFNbMV0gJiAweDgwKSkge1xuICAgIC8vICBOb24tY2Fub25pY2FsIHNpZ25hdHVyZTogUyB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRvIGJpdGNvaW5kJ3MgSXNMb3dERVJTaWduYXR1cmVcbiAqIFNlZSBhbHNvIEVDRFNBIHNpZ25hdHVyZSBhbGdvcml0aG0gd2hpY2ggZW5mb3JjZXMgdGhpcy5cbiAqIFNlZSBhbHNvIEJJUCA2MiwgXCJsb3cgUyB2YWx1ZXMgaW4gc2lnbmF0dXJlc1wiXG4gKi9cblNpZ25hdHVyZS5wcm90b3R5cGUuaGFzTG93UyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zLmx0KG5ldyBCTigxKSkgfHxcbiAgICB0aGlzLnMuZ3QobmV3IEJOKCc3RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjVENTc2RTczNTdBNDUwMURERkU5MkY0NjY4MUIyMEEwJywgJ2hleCcpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbmhhc2h0eXBlIGlzIGV4YWN0bHkgZXF1YWwgdG8gb25lIG9mIHRoZSBzdGFuZGFyZCBvcHRpb25zIG9yIGNvbWJpbmF0aW9ucyB0aGVyZW9mLlxuICogVHJhbnNsYXRlZCBmcm9tIGJpdGNvaW5kJ3MgSXNEZWZpbmVkSGFzaHR5cGVTaWduYXR1cmVcbiAqL1xuU2lnbmF0dXJlLnByb3RvdHlwZS5oYXNEZWZpbmVkSGFzaHR5cGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFKU1V0aWwuaXNOYXR1cmFsTnVtYmVyKHRoaXMubmhhc2h0eXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBhY2NlcHQgd2l0aCBvciB3aXRob3V0IFNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSBieSBpZ25vcmluZyB0aGUgYml0XG4gIHZhciB0ZW1wID0gdGhpcy5uaGFzaHR5cGUgJiB+U2lnbmF0dXJlLlNJR0hBU0hfQU5ZT05FQ0FOUEFZO1xuICBpZiAodGVtcCA8IFNpZ25hdHVyZS5TSUdIQVNIX0FMTCB8fCB0ZW1wID4gU2lnbmF0dXJlLlNJR0hBU0hfU0lOR0xFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b1R4Rm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkZXJidWYgPSB0aGlzLnRvREVSKCk7XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoMSk7XG4gIGJ1Zi53cml0ZVVJbnQ4KHRoaXMubmhhc2h0eXBlLCAwKTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2RlcmJ1ZiwgYnVmXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTaWduYXR1cmUgaW5zdGFuY2UgZnJvbSBhIFNjaG5vcnIgc2lnXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFNjaG5vcnIgc2lnbmF0dXJlIGJ1ZmZlclxuICogQHJldHVybnMge1NpZ25hdHVyZX1cbiAqL1xuU2lnbmF0dXJlLmZyb21TY2hub3JyID0gZnVuY3Rpb24oYnVmKSB7XG4gICQuY2hlY2tBcmd1bWVudChCdWZmZXIuaXNCdWZmZXIoYnVmKSwgJ1NjaG5vcnIgc2lnbmF0dXJlIGFyZ3VtZW50IG11c3QgYmUgYSBidWZmZXInKTtcbiAgJC5jaGVja0FyZ3VtZW50KGJ1Zi5sZW5ndGggPT09IDY0IHx8IGJ1Zi5sZW5ndGggPT09IDY1LCAnU2Nobm9yciBzaWduYXR1cmVzIG11c3QgYmUgNjQgb3IgNjUgYnl0ZXMnKTtcblxuICBjb25zdCBzaWcgPSBuZXcgU2lnbmF0dXJlKCk7XG4gIGxldCByID0gYnVmLnNsaWNlKDAsMzIpO1xuICBsZXQgcyA9IGJ1Zi5zbGljZSgzMiwgNjQpO1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gNjUpIHtcbiAgICBzaWcubmhhc2h0eXBlID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAkLmNoZWNrU3RhdGUoc2lnLm5oYXNodHlwZSAhPT0gU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVCwgbmV3IEVycm9yKCdpbnZhbGlkIGhhc2h0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHNpZy5uaGFzaHR5cGUgPSBTaWduYXR1cmUuU0lHSEFTSF9ERUZBVUxUO1xuICB9XG4gIHNpZy5yID0gQk4uZnJvbUJ1ZmZlcihyKTtcbiAgc2lnLnMgPSBCTi5mcm9tQnVmZmVyKHMpO1xuICBzaWcuaXNTY2hub3JyID0gdHJ1ZTtcbiAgcmV0dXJuIHNpZztcbn07XG5cblNpZ25hdHVyZS5TSUdIQVNIX0RFRkFVTFQgICAgICAgPSAweDAwOyAvLyE8IFRhcHJvb3Qgb25seTsgaW1wbGllZCB3aGVuIHNpZ2hhc2ggYnl0ZSBpcyBtaXNzaW5nLCBhbmQgZXF1aXZhbGVudCB0byBTSUdIQVNIX0FMTFxuU2lnbmF0dXJlLlNJR0hBU0hfQUxMICAgICAgICAgICA9IDB4MDE7XG5TaWduYXR1cmUuU0lHSEFTSF9OT05FICAgICAgICAgID0gMHgwMjtcblNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSAgICAgICAgPSAweDAzO1xuU2lnbmF0dXJlLlNJR0hBU0hfQU5ZT05FQ0FOUEFZICA9IDB4ODA7XG5cblNpZ25hdHVyZS5TSUdIQVNIX09VVFBVVF9NQVNLID0gMztcblNpZ25hdHVyZS5TSUdIQVNIX0lOUFVUX01BU0sgID0gMTI4OyAvLyAweDgwLFxuXG5TaWduYXR1cmUuVmVyc2lvbiA9IHt9O1xuU2lnbmF0dXJlLlZlcnNpb24uQkFTRSAgICAgICA9IDA7XG5TaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwID0gMTtcblNpZ25hdHVyZS5WZXJzaW9uLlRBUFJPT1QgICAgPSAyO1xuU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBUICA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/crypto/taggedhash.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Hash = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nconst BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nconst inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\n\n/**\n * Creates a tag hash to ensure uniqueness of a message between purposes.\n * For example, if there's a potential for a collision of messages between\n *   multiple purposes, a tag can be added to guard against such collisions.\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Design (see 'Tagged Hashes')\n * @param {String} tag The tag to prevent message collisions. Should uniquely reflect the purpose of the message.\n * @param {Buffer|String} message (optional)\n * @param {String} messageEncoding (default: 'hex') If `message` is a string, provide the encoding\n * @returns {TaggedHash} Instance of a BufferWriter with the written tag and `finalize` method\n */\nfunction TaggedHash(tag, message, messageEncoding = 'hex') {\n  if (!(this instanceof TaggedHash)) {\n    return new TaggedHash(tag, message, messageEncoding);\n  }\n  BufferWriter.apply(this);\n  tag = Buffer.from(tag);\n\n  const taghash = Hash.sha256(tag);\n  this.write(taghash);\n  this.write(taghash);\n  if (message) {\n    message = Buffer.isBuffer(message) ? message : Buffer.from(message, messageEncoding);\n    this.write(message);\n  }\n  return this;\n};\n\ninherits(TaggedHash, BufferWriter);\n\n/**\n * Returns a 32-byte SHA256 hash of the double tagged hashes concat'd with the message\n * as defined by BIP-340: SHA256(SHA256(tag), SHA256(tag), message)\n * @returns {Buffer}\n */\nTaggedHash.prototype.finalize = function() {\n  return Buffer.from(Hash.sha256(this.toBuffer()));\n};\n\n/**\n * Commonly used tags\n */\nObject.defineProperties(TaggedHash, {\n  TAPSIGHASH: { get: () => new TaggedHash('TapSighash') },\n  TAPLEAF:    { get: () => new TaggedHash('TapLeaf') },\n  TAPBRANCH:  { get: () => new TaggedHash('TapBranch') }\n});\n\nmodule.exports = TaggedHash;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2NyeXB0by90YWdnZWRoYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxtRUFBUTtBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDdkQsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQVU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQsZ0JBQWdCLHNDQUFzQztBQUN0RCxnQkFBZ0I7QUFDaEIsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9jcnlwdG8vdGFnZ2VkaGFzaC5qcz9hYWI1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcbmNvbnN0IEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0YWcgaGFzaCB0byBlbnN1cmUgdW5pcXVlbmVzcyBvZiBhIG1lc3NhZ2UgYmV0d2VlbiBwdXJwb3Nlcy5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGVyZSdzIGEgcG90ZW50aWFsIGZvciBhIGNvbGxpc2lvbiBvZiBtZXNzYWdlcyBiZXR3ZWVuXG4gKiAgIG11bHRpcGxlIHB1cnBvc2VzLCBhIHRhZyBjYW4gYmUgYWRkZWQgdG8gZ3VhcmQgYWdhaW5zdCBzdWNoIGNvbGxpc2lvbnMuXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraSNEZXNpZ24gKHNlZSAnVGFnZ2VkIEhhc2hlcycpXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFnIFRoZSB0YWcgdG8gcHJldmVudCBtZXNzYWdlIGNvbGxpc2lvbnMuIFNob3VsZCB1bmlxdWVseSByZWZsZWN0IHRoZSBwdXJwb3NlIG9mIHRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBtZXNzYWdlIChvcHRpb25hbClcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlRW5jb2RpbmcgKGRlZmF1bHQ6ICdoZXgnKSBJZiBgbWVzc2FnZWAgaXMgYSBzdHJpbmcsIHByb3ZpZGUgdGhlIGVuY29kaW5nXG4gKiBAcmV0dXJucyB7VGFnZ2VkSGFzaH0gSW5zdGFuY2Ugb2YgYSBCdWZmZXJXcml0ZXIgd2l0aCB0aGUgd3JpdHRlbiB0YWcgYW5kIGBmaW5hbGl6ZWAgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIFRhZ2dlZEhhc2godGFnLCBtZXNzYWdlLCBtZXNzYWdlRW5jb2RpbmcgPSAnaGV4Jykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGFnZ2VkSGFzaCkpIHtcbiAgICByZXR1cm4gbmV3IFRhZ2dlZEhhc2godGFnLCBtZXNzYWdlLCBtZXNzYWdlRW5jb2RpbmcpO1xuICB9XG4gIEJ1ZmZlcldyaXRlci5hcHBseSh0aGlzKTtcbiAgdGFnID0gQnVmZmVyLmZyb20odGFnKTtcblxuICBjb25zdCB0YWdoYXNoID0gSGFzaC5zaGEyNTYodGFnKTtcbiAgdGhpcy53cml0ZSh0YWdoYXNoKTtcbiAgdGhpcy53cml0ZSh0YWdoYXNoKTtcbiAgaWYgKG1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpID8gbWVzc2FnZSA6IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIG1lc3NhZ2VFbmNvZGluZyk7XG4gICAgdGhpcy53cml0ZShtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmluaGVyaXRzKFRhZ2dlZEhhc2gsIEJ1ZmZlcldyaXRlcik7XG5cbi8qKlxuICogUmV0dXJucyBhIDMyLWJ5dGUgU0hBMjU2IGhhc2ggb2YgdGhlIGRvdWJsZSB0YWdnZWQgaGFzaGVzIGNvbmNhdCdkIHdpdGggdGhlIG1lc3NhZ2VcbiAqIGFzIGRlZmluZWQgYnkgQklQLTM0MDogU0hBMjU2KFNIQTI1Nih0YWcpLCBTSEEyNTYodGFnKSwgbWVzc2FnZSlcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cblRhZ2dlZEhhc2gucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShIYXNoLnNoYTI1Nih0aGlzLnRvQnVmZmVyKCkpKTtcbn07XG5cbi8qKlxuICogQ29tbW9ubHkgdXNlZCB0YWdzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRhZ2dlZEhhc2gsIHtcbiAgVEFQU0lHSEFTSDogeyBnZXQ6ICgpID0+IG5ldyBUYWdnZWRIYXNoKCdUYXBTaWdoYXNoJykgfSxcbiAgVEFQTEVBRjogICAgeyBnZXQ6ICgpID0+IG5ldyBUYWdnZWRIYXNoKCdUYXBMZWFmJykgfSxcbiAgVEFQQlJBTkNIOiAgeyBnZXQ6ICgpID0+IG5ldyBUYWdnZWRIYXNoKCdUYXBCcmFuY2gnKSB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWdnZWRIYXNoOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/base58.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar bs58 = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/index.js\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\n\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');\n\nvar Base58 = function Base58(obj) {\n  /* jshint maxcomplexity: 8 */\n  if (!(this instanceof Base58)) {\n    return new Base58(obj);\n  }\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58.validCharacters = function validCharacters(chars) {\n  if (buffer.Buffer.isBuffer(chars)) {\n    chars = chars.toString();\n  }\n  return _.every(_.map(chars, function(char) { return _.includes(ALPHABET, char); }));\n};\n\nBase58.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58.encode = function(buf) {\n  if (!buffer.Buffer.isBuffer(buf)) {\n    throw new Error('Input should be a buffer');\n  }\n  return bs58.encode(buf);\n};\n\nBase58.decode = function(str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n  return Buffer.from(bs58.decode(str));\n};\n\nBase58.prototype.fromBuffer = function(buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.fromString = function(str) {\n  var buf = Base58.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.toBuffer = function() {\n  return this.buf;\n};\n\nBase58.prototype.toString = function() {\n  return Base58.encode(this.buf);\n};\n\nmodule.exports = Base58;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2Jhc2U1OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsV0FBVyxtQkFBTyxDQUFDLGdEQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQ0FBb0M7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvZW5jb2RpbmcvYmFzZTU4LmpzP2E2MjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGJzNTggPSByZXF1aXJlKCdiczU4Jyk7XG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5cbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jy5zcGxpdCgnJyk7XG5cbnZhciBCYXNlNTggPSBmdW5jdGlvbiBCYXNlNTgob2JqKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCYXNlNTgpKSB7XG4gICAgcmV0dXJuIG5ldyBCYXNlNTgob2JqKTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgYnVmID0gb2JqO1xuICAgIHRoaXMuZnJvbUJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHN0ciA9IG9iajtcbiAgICB0aGlzLmZyb21TdHJpbmcoc3RyKTtcbiAgfSBlbHNlIGlmIChvYmopIHtcbiAgICB0aGlzLnNldChvYmopO1xuICB9XG59O1xuXG5CYXNlNTgudmFsaWRDaGFyYWN0ZXJzID0gZnVuY3Rpb24gdmFsaWRDaGFyYWN0ZXJzKGNoYXJzKSB7XG4gIGlmIChidWZmZXIuQnVmZmVyLmlzQnVmZmVyKGNoYXJzKSkge1xuICAgIGNoYXJzID0gY2hhcnMudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gXy5ldmVyeShfLm1hcChjaGFycywgZnVuY3Rpb24oY2hhcikgeyByZXR1cm4gXy5pbmNsdWRlcyhBTFBIQUJFVCwgY2hhcik7IH0pKTtcbn07XG5cbkJhc2U1OC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHRoaXMuYnVmID0gb2JqLmJ1ZiB8fCB0aGlzLmJ1ZiB8fCB1bmRlZmluZWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQmFzZTU4LmVuY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICBpZiAoIWJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hvdWxkIGJlIGEgYnVmZmVyJyk7XG4gIH1cbiAgcmV0dXJuIGJzNTguZW5jb2RlKGJ1Zik7XG59O1xuXG5CYXNlNTguZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJzNTguZGVjb2RlKHN0cikpO1xufTtcblxuQmFzZTU4LnByb3RvdHlwZS5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG4gIHRoaXMuYnVmID0gYnVmO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2U1OC5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgYnVmID0gQmFzZTU4LmRlY29kZShzdHIpO1xuICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlNTgucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJ1Zjtcbn07XG5cbkJhc2U1OC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEJhc2U1OC5lbmNvZGUodGhpcy5idWYpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlNTg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js":
/*!**************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/base58check.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar Base58 = __webpack_require__(/*! ./base58 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar sha256sha256 = (__webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\").sha256sha256);\n\nvar Base58Check = function Base58Check(obj) {\n  if (!(this instanceof Base58Check))\n    return new Base58Check(obj);\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58Check.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58Check.validChecksum = function validChecksum(data, checksum) {\n  if (_.isString(data)) {\n    data = Buffer.from(Base58.decode(data));\n  }\n  if (_.isString(checksum)) {\n    checksum =  Buffer.from(Base58.decode(checksum));\n  }\n  if (!checksum) {\n    checksum = data.slice(-4);\n    data = data.slice(0, -4);\n  }\n  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex');\n};\n\nBase58Check.decode = function(s) {\n  if (typeof s !== 'string')\n    throw new Error('Input must be a string');\n\n  var buf = Buffer.from(Base58.decode(s));\n\n  if (buf.length < 4)\n    throw new Error(\"Input string too short\");\n\n  var data = buf.slice(0, -4);\n  var csum = buf.slice(-4);\n\n  var hash = sha256sha256(data);\n  var hash4 = hash.slice(0, 4);\n\n  if (csum.toString('hex') !== hash4.toString('hex'))\n    throw new Error(\"Checksum mismatch\");\n\n  return data;\n};\n\nBase58Check.checksum = function(buffer) {\n  return sha256sha256(buffer).slice(0, 4);\n};\n\nBase58Check.encode = function(buf) {\n  if (!Buffer.isBuffer(buf))\n    throw new Error('Input must be a buffer');\n  var checkedBuf = Buffer.alloc(buf.length + 4);\n  var hash = Base58Check.checksum(buf);\n  buf.copy(checkedBuf);\n  hash.copy(checkedBuf, buf.length);\n  return Base58.encode(checkedBuf);\n};\n\nBase58Check.prototype.fromBuffer = function(buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.fromString = function(str) {\n  var buf = Base58Check.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.toBuffer = function() {\n  return this.buf;\n};\n\nBase58Check.prototype.toString = function() {\n  return Base58Check.encode(this.buf);\n};\n\nmodule.exports = Base58Check;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2Jhc2U1OGNoZWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixhQUFhLG1CQUFPLENBQUMseUVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLG1CQUFtQiwrR0FBc0M7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2Jhc2U1OGNoZWNrLmpzPzE5YzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIEJhc2U1OCA9IHJlcXVpcmUoJy4vYmFzZTU4Jyk7XG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgc2hhMjU2c2hhMjU2ID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKS5zaGEyNTZzaGEyNTY7XG5cbnZhciBCYXNlNThDaGVjayA9IGZ1bmN0aW9uIEJhc2U1OENoZWNrKG9iaikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmFzZTU4Q2hlY2spKVxuICAgIHJldHVybiBuZXcgQmFzZTU4Q2hlY2sob2JqKTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGJ1ZiA9IG9iajtcbiAgICB0aGlzLmZyb21CdWZmZXIoYnVmKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzdHIgPSBvYmo7XG4gICAgdGhpcy5mcm9tU3RyaW5nKHN0cik7XG4gIH0gZWxzZSBpZiAob2JqKSB7XG4gICAgdGhpcy5zZXQob2JqKTtcbiAgfVxufTtcblxuQmFzZTU4Q2hlY2sucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xuICB0aGlzLmJ1ZiA9IG9iai5idWYgfHwgdGhpcy5idWYgfHwgdW5kZWZpbmVkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2U1OENoZWNrLnZhbGlkQ2hlY2tzdW0gPSBmdW5jdGlvbiB2YWxpZENoZWNrc3VtKGRhdGEsIGNoZWNrc3VtKSB7XG4gIGlmIChfLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKEJhc2U1OC5kZWNvZGUoZGF0YSkpO1xuICB9XG4gIGlmIChfLmlzU3RyaW5nKGNoZWNrc3VtKSkge1xuICAgIGNoZWNrc3VtID0gIEJ1ZmZlci5mcm9tKEJhc2U1OC5kZWNvZGUoY2hlY2tzdW0pKTtcbiAgfVxuICBpZiAoIWNoZWNrc3VtKSB7XG4gICAgY2hlY2tzdW0gPSBkYXRhLnNsaWNlKC00KTtcbiAgICBkYXRhID0gZGF0YS5zbGljZSgwLCAtNCk7XG4gIH1cbiAgcmV0dXJuIEJhc2U1OENoZWNrLmNoZWNrc3VtKGRhdGEpLnRvU3RyaW5nKCdoZXgnKSA9PT0gY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpO1xufTtcblxuQmFzZTU4Q2hlY2suZGVjb2RlID0gZnVuY3Rpb24ocykge1xuICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG4gIHZhciBidWYgPSBCdWZmZXIuZnJvbShCYXNlNTguZGVjb2RlKHMpKTtcblxuICBpZiAoYnVmLmxlbmd0aCA8IDQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc3RyaW5nIHRvbyBzaG9ydFwiKTtcblxuICB2YXIgZGF0YSA9IGJ1Zi5zbGljZSgwLCAtNCk7XG4gIHZhciBjc3VtID0gYnVmLnNsaWNlKC00KTtcblxuICB2YXIgaGFzaCA9IHNoYTI1NnNoYTI1NihkYXRhKTtcbiAgdmFyIGhhc2g0ID0gaGFzaC5zbGljZSgwLCA0KTtcblxuICBpZiAoY3N1bS50b1N0cmluZygnaGV4JykgIT09IGhhc2g0LnRvU3RyaW5nKCdoZXgnKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGVja3N1bSBtaXNtYXRjaFwiKTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cbkJhc2U1OENoZWNrLmNoZWNrc3VtID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHJldHVybiBzaGEyNTZzaGEyNTYoYnVmZmVyKS5zbGljZSgwLCA0KTtcbn07XG5cbkJhc2U1OENoZWNrLmVuY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKVxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIGJ1ZmZlcicpO1xuICB2YXIgY2hlY2tlZEJ1ZiA9IEJ1ZmZlci5hbGxvYyhidWYubGVuZ3RoICsgNCk7XG4gIHZhciBoYXNoID0gQmFzZTU4Q2hlY2suY2hlY2tzdW0oYnVmKTtcbiAgYnVmLmNvcHkoY2hlY2tlZEJ1Zik7XG4gIGhhc2guY29weShjaGVja2VkQnVmLCBidWYubGVuZ3RoKTtcbiAgcmV0dXJuIEJhc2U1OC5lbmNvZGUoY2hlY2tlZEJ1Zik7XG59O1xuXG5CYXNlNThDaGVjay5wcm90b3R5cGUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xuICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlNThDaGVjay5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgYnVmID0gQmFzZTU4Q2hlY2suZGVjb2RlKHN0cik7XG4gIHRoaXMuYnVmID0gYnVmO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2U1OENoZWNrLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5idWY7XG59O1xuXG5CYXNlNThDaGVjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEJhc2U1OENoZWNrLmVuY29kZSh0aGlzLmJ1Zik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U1OENoZWNrO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/bech32.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/bech32.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bech32 = __webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/bech32/dist/index.js\");\n\n/**\n * Decode bech32/bech32m string\n * @param {String} str String to decode\n * @returns {Object} Decoded string info\n */\nvar decode = function(str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n\n  var decoded;\n  let fromWords = bech32.bech32.fromWords;\n  let encoding = encodings.BECH32;\n  try {\n    decoded = bech32.bech32.decode(str);\n  } catch (e) {\n    if (e.message.indexOf('Invalid checksum') > -1) {\n      decoded = bech32.bech32m.decode(str);\n      encoding = encodings.BECH32M;\n      fromWords = bech32.bech32m.fromWords;\n    } else {\n      throw e;\n    }\n  }\n\n  const version = decoded.words[0];\n  if (version >= 1 && encoding !== encodings.BECH32M) {\n    throw new Error('Version 1+ witness address must use Bech32m checksum');\n  }\n\n  return {\n    prefix: decoded.prefix,\n    data: Buffer.from(fromWords(decoded.words.slice(1))),\n    version\n  };\n};\n\n/**\n * Encode using BECH32 encoding\n * @param {String} prefix bech32 prefix\n * @param {Number} version\n * @param {String|Buffer} data \n * @param {String|Number} encoding (optional, default=bech32) Valid encodings are 'bech32', 'bech32m', 0, and 1.\n * @returns {String} encoded string\n */\nvar encode = function(prefix, version, data, encoding) {\n\tif (typeof prefix !== 'string') {\n\t\tthrow new Error('Prefix should be a string');\n\t}\n\tif (typeof version !== 'number') {\n\t\tthrow new Error('version should be a number');\n\t}\n  // convert string to number\n  if (encoding && typeof encoding == 'string') {\n    encoding = encodings[encoding.toUpperCase()] || -1; // fallback to -1 so it throws invalid encoding below\n  }\n  if (encoding && !(encoding == encodings.BECH32 || encoding == encodings.BECH32M)) {\n    throw new Error('Invalid encoding specified');\n  }\n  \n  let b32Variety = encoding == encodings.BECH32M ? bech32.bech32m : bech32.bech32;\n  let words = b32Variety.toWords(data);\n\n  words.unshift(version);\n\treturn b32Variety.encode(prefix, words);\n}\n\nconst encodings = {\n  BECH32: 1,\n  BECH32M: 2\n}\n\nmodule.exports = { decode: decode, encode: encode, encodings };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2JlY2gzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMseURBQVE7O0FBRTdCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvZW5jb2RpbmcvYmVjaDMyLmpzPzY2NmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmVjaDMyID0gcmVxdWlyZSgnYmVjaDMyJyk7XG5cbi8qKlxuICogRGVjb2RlIGJlY2gzMi9iZWNoMzJtIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBEZWNvZGVkIHN0cmluZyBpbmZvXG4gKi9cbnZhciBkZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBkZWNvZGVkO1xuICBsZXQgZnJvbVdvcmRzID0gYmVjaDMyLmJlY2gzMi5mcm9tV29yZHM7XG4gIGxldCBlbmNvZGluZyA9IGVuY29kaW5ncy5CRUNIMzI7XG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IGJlY2gzMi5iZWNoMzIuZGVjb2RlKHN0cik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5tZXNzYWdlLmluZGV4T2YoJ0ludmFsaWQgY2hlY2tzdW0nKSA+IC0xKSB7XG4gICAgICBkZWNvZGVkID0gYmVjaDMyLmJlY2gzMm0uZGVjb2RlKHN0cik7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5ncy5CRUNIMzJNO1xuICAgICAgZnJvbVdvcmRzID0gYmVjaDMyLmJlY2gzMm0uZnJvbVdvcmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHZlcnNpb24gPSBkZWNvZGVkLndvcmRzWzBdO1xuICBpZiAodmVyc2lvbiA+PSAxICYmIGVuY29kaW5nICE9PSBlbmNvZGluZ3MuQkVDSDMyTSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmVyc2lvbiAxKyB3aXRuZXNzIGFkZHJlc3MgbXVzdCB1c2UgQmVjaDMybSBjaGVja3N1bScpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwcmVmaXg6IGRlY29kZWQucHJlZml4LFxuICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGZyb21Xb3JkcyhkZWNvZGVkLndvcmRzLnNsaWNlKDEpKSksXG4gICAgdmVyc2lvblxuICB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGUgdXNpbmcgQkVDSDMyIGVuY29kaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IGJlY2gzMiBwcmVmaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGRhdGEgXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGVuY29kaW5nIChvcHRpb25hbCwgZGVmYXVsdD1iZWNoMzIpIFZhbGlkIGVuY29kaW5ncyBhcmUgJ2JlY2gzMicsICdiZWNoMzJtJywgMCwgYW5kIDEuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBlbmNvZGVkIHN0cmluZ1xuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24ocHJlZml4LCB2ZXJzaW9uLCBkYXRhLCBlbmNvZGluZykge1xuXHRpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZWZpeCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcblx0fVxuXHRpZiAodHlwZW9mIHZlcnNpb24gIT09ICdudW1iZXInKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd2ZXJzaW9uIHNob3VsZCBiZSBhIG51bWJlcicpO1xuXHR9XG4gIC8vIGNvbnZlcnQgc3RyaW5nIHRvIG51bWJlclxuICBpZiAoZW5jb2RpbmcgJiYgdHlwZW9mIGVuY29kaW5nID09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZ3NbZW5jb2RpbmcudG9VcHBlckNhc2UoKV0gfHwgLTE7IC8vIGZhbGxiYWNrIHRvIC0xIHNvIGl0IHRocm93cyBpbnZhbGlkIGVuY29kaW5nIGJlbG93XG4gIH1cbiAgaWYgKGVuY29kaW5nICYmICEoZW5jb2RpbmcgPT0gZW5jb2RpbmdzLkJFQ0gzMiB8fCBlbmNvZGluZyA9PSBlbmNvZGluZ3MuQkVDSDMyTSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2Rpbmcgc3BlY2lmaWVkJyk7XG4gIH1cbiAgXG4gIGxldCBiMzJWYXJpZXR5ID0gZW5jb2RpbmcgPT0gZW5jb2RpbmdzLkJFQ0gzMk0gPyBiZWNoMzIuYmVjaDMybSA6IGJlY2gzMi5iZWNoMzI7XG4gIGxldCB3b3JkcyA9IGIzMlZhcmlldHkudG9Xb3JkcyhkYXRhKTtcblxuICB3b3Jkcy51bnNoaWZ0KHZlcnNpb24pO1xuXHRyZXR1cm4gYjMyVmFyaWV0eS5lbmNvZGUocHJlZml4LCB3b3Jkcyk7XG59XG5cbmNvbnN0IGVuY29kaW5ncyA9IHtcbiAgQkVDSDMyOiAxLFxuICBCRUNIMzJNOiAyXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWNvZGU6IGRlY29kZSwgZW5jb2RlOiBlbmNvZGUsIGVuY29kaW5ncyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/bech32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js":
/*!***************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/bufferreader.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\n\nvar BufferReader = function BufferReader(buf) {\n  if (!(this instanceof BufferReader)) {\n    return new BufferReader(buf);\n  }\n  if (_.isUndefined(buf)) {\n    return;\n  }\n  if (Buffer.isBuffer(buf)) {\n    this.set({\n      buf: buf\n    });\n  } else if (_.isString(buf)) {\n    this.set({\n      buf: Buffer.from(buf, 'hex'),\n    });\n  } else if (_.isObject(buf)) {\n    var obj = buf;\n    this.set(obj);\n  } else {\n    throw new TypeError('Unrecognized argument for BufferReader');\n  }\n};\n\nBufferReader.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  this.pos = obj.pos || this.pos || 0;\n  return this;\n};\n\nBufferReader.prototype.eof = function() {\n  if(this.buf) {\n    return this.pos >= this.buf.length;\n  } else {\n    return true;\n  }\n};\n\nBufferReader.prototype.finished = BufferReader.prototype.eof;\n\nBufferReader.prototype.read = function(len) {\n  $.checkArgument(!_.isUndefined(len), 'Must specify a length');\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos = this.pos + len;\n  return buf;\n};\n\nBufferReader.prototype.readAll = function() {\n  var buf = this.buf.slice(this.pos, this.buf.length);\n  this.pos = this.buf.length;\n  return buf;\n};\n\nBufferReader.prototype.readUInt8 = function() {\n  var val = this.buf.readUInt8(this.pos);\n  this.pos = this.pos + 1;\n  return val;\n};\n\nBufferReader.prototype.readUInt16BE = function() {\n  var val = this.buf.readUInt16BE(this.pos);\n  this.pos = this.pos + 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt16LE = function() {\n  var val = this.buf.readUInt16LE(this.pos);\n  this.pos = this.pos + 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt32BE = function() {\n  var val = this.buf.readUInt32BE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt32LE = function() {\n  var val = this.buf.readUInt32LE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readInt32LE = function() {\n  var val = this.buf.readInt32LE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt64BEBN = function() {\n  var buf = this.buf.slice(this.pos, this.pos + 8);\n  var bn = BN.fromBuffer(buf);\n  this.pos = this.pos + 8;\n  return bn;\n};\n\nBufferReader.prototype.readUInt64LEBN = function() {\n  var second = this.buf.readUInt32LE(this.pos);\n  var first = this.buf.readUInt32LE(this.pos + 4);\n  var combined = (first * 0x100000000) + second;\n  // Instantiating an instance of BN with a number is faster than with an\n  // array or string. However, the maximum safe number for a double precision\n  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use\n  // non-floating point numbers less than this amount (52 bits). And in the case\n  // that the number is larger, we can instatiate an instance of BN by passing\n  // an array from the buffer (slower) and specifying the endianness.\n  var bn;\n  if (combined <= 0x1fffffffffffff) {\n    bn = new BN(combined);\n  } else {\n    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);\n    bn = new BN(data, 10, 'le');\n  }\n  this.pos = this.pos + 8;\n  return bn;\n};\n\nBufferReader.prototype.readVarintNum = function() {\n  var first = this.readUInt8();\n  switch (first) {\n    case 0xFD:\n      return this.readUInt16LE();\n    case 0xFE:\n      return this.readUInt32LE();\n    case 0xFF:\n      var bn = this.readUInt64LEBN();\n      var n = bn.toNumber();\n      if (n <= Math.pow(2, 53)) {\n        return n;\n      } else {\n        throw new Error('number too large to retain precision - use readVarintBN');\n      }\n      break;\n    default:\n      return first;\n  }\n};\n\n/**\n * reads a length prepended buffer\n */\nBufferReader.prototype.readVarLengthBuffer = function() {\n  var len = this.readVarintNum();\n  var buf = this.read(len);\n  $.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' +\n    'Expected to read: ' + len + ' and read ' + buf.length);\n  return buf;\n};\n\nBufferReader.prototype.readVarintBuf = function() {\n  var first = this.buf.readUInt8(this.pos);\n  switch (first) {\n    case 0xFD:\n      return this.read(1 + 2);\n    case 0xFE:\n      return this.read(1 + 4);\n    case 0xFF:\n      return this.read(1 + 8);\n    default:\n      return this.read(1);\n  }\n};\n\nBufferReader.prototype.readVarintBN = function() {\n  var first = this.readUInt8();\n  switch (first) {\n    case 0xFD:\n      return new BN(this.readUInt16LE());\n    case 0xFE:\n      return new BN(this.readUInt32LE());\n    case 0xFF:\n      return this.readUInt64LEBN();\n    default:\n      return new BN(first);\n  }\n};\n\nBufferReader.prototype.reverse = function() {\n  var buf = Buffer.alloc(this.buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf[i] = this.buf[this.buf.length - 1 - i];\n  }\n  this.buf = buf;\n  return this;\n};\n\nBufferReader.prototype.readReverse = function(len) {\n  if (_.isUndefined(len)) {\n    len = this.buf.length;\n  }\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos = this.pos + len;\n  return BufferUtil.reverse(buf);\n};\n\nmodule.exports = BufferReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2J1ZmZlcnJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHlGQUF1QjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsU0FBUyxtQkFBTyxDQUFDLHVFQUFjOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9lbmNvZGluZy9idWZmZXJyZWFkZXIuanM/NzdhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xudmFyIEJOID0gcmVxdWlyZSgnLi4vY3J5cHRvL2JuJyk7XG5cbnZhciBCdWZmZXJSZWFkZXIgPSBmdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXJSZWFkZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJSZWFkZXIoYnVmKTtcbiAgfVxuICBpZiAoXy5pc1VuZGVmaW5lZChidWYpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRoaXMuc2V0KHtcbiAgICAgIGJ1ZjogYnVmXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhidWYpKSB7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgYnVmOiBCdWZmZXIuZnJvbShidWYsICdoZXgnKSxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KGJ1ZikpIHtcbiAgICB2YXIgb2JqID0gYnVmO1xuICAgIHRoaXMuc2V0KG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIGFyZ3VtZW50IGZvciBCdWZmZXJSZWFkZXInKTtcbiAgfVxufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5idWYgPSBvYmouYnVmIHx8IHRoaXMuYnVmIHx8IHVuZGVmaW5lZDtcbiAgdGhpcy5wb3MgPSBvYmoucG9zIHx8IHRoaXMucG9zIHx8IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5lb2YgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5idWYpIHtcbiAgICByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5idWYubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLmZpbmlzaGVkID0gQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5lb2Y7XG5cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGxlbikge1xuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQobGVuKSwgJ011c3Qgc3BlY2lmeSBhIGxlbmd0aCcpO1xuICB2YXIgYnVmID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgbGVuKTtcbiAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbjtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZEFsbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVmID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIHRoaXMuYnVmLmxlbmd0aCk7XG4gIHRoaXMucG9zID0gdGhpcy5idWYubGVuZ3RoO1xuICByZXR1cm4gYnVmO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50OCh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyAxO1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MTZCRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyAyO1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MTZMRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyAyO1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJCRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyA0O1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyA0O1xuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEludDMyTEUodGhpcy5wb3MpO1xuICB0aGlzLnBvcyA9IHRoaXMucG9zICsgNDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZFVJbnQ2NEJFQk4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZiA9IHRoaXMuYnVmLnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIDgpO1xuICB2YXIgYm4gPSBCTi5mcm9tQnVmZmVyKGJ1Zik7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyA4O1xuICByZXR1cm4gYm47XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRVSW50NjRMRUJOID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWNvbmQgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpO1xuICB2YXIgZmlyc3QgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MgKyA0KTtcbiAgdmFyIGNvbWJpbmVkID0gKGZpcnN0ICogMHgxMDAwMDAwMDApICsgc2Vjb25kO1xuICAvLyBJbnN0YW50aWF0aW5nIGFuIGluc3RhbmNlIG9mIEJOIHdpdGggYSBudW1iZXIgaXMgZmFzdGVyIHRoYW4gd2l0aCBhblxuICAvLyBhcnJheSBvciBzdHJpbmcuIEhvd2V2ZXIsIHRoZSBtYXhpbXVtIHNhZmUgbnVtYmVyIGZvciBhIGRvdWJsZSBwcmVjaXNpb25cbiAgLy8gZmxvYXRpbmcgcG9pbnQgaXMgMiBeIDUyIC0gMSAoMHgxZmZmZmZmZmZmZmZmZiksIHRodXMgd2UgY2FuIHNhZmVseSB1c2VcbiAgLy8gbm9uLWZsb2F0aW5nIHBvaW50IG51bWJlcnMgbGVzcyB0aGFuIHRoaXMgYW1vdW50ICg1MiBiaXRzKS4gQW5kIGluIHRoZSBjYXNlXG4gIC8vIHRoYXQgdGhlIG51bWJlciBpcyBsYXJnZXIsIHdlIGNhbiBpbnN0YXRpYXRlIGFuIGluc3RhbmNlIG9mIEJOIGJ5IHBhc3NpbmdcbiAgLy8gYW4gYXJyYXkgZnJvbSB0aGUgYnVmZmVyIChzbG93ZXIpIGFuZCBzcGVjaWZ5aW5nIHRoZSBlbmRpYW5uZXNzLlxuICB2YXIgYm47XG4gIGlmIChjb21iaW5lZCA8PSAweDFmZmZmZmZmZmZmZmZmKSB7XG4gICAgYm4gPSBuZXcgQk4oY29tYmluZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5idWYsIHRoaXMucG9zLCB0aGlzLnBvcyArIDgpO1xuICAgIGJuID0gbmV3IEJOKGRhdGEsIDEwLCAnbGUnKTtcbiAgfVxuICB0aGlzLnBvcyA9IHRoaXMucG9zICsgODtcbiAgcmV0dXJuIGJuO1xufTtcblxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkVmFyaW50TnVtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmaXJzdCA9IHRoaXMucmVhZFVJbnQ4KCk7XG4gIHN3aXRjaCAoZmlyc3QpIHtcbiAgICBjYXNlIDB4RkQ6XG4gICAgICByZXR1cm4gdGhpcy5yZWFkVUludDE2TEUoKTtcbiAgICBjYXNlIDB4RkU6XG4gICAgICByZXR1cm4gdGhpcy5yZWFkVUludDMyTEUoKTtcbiAgICBjYXNlIDB4RkY6XG4gICAgICB2YXIgYm4gPSB0aGlzLnJlYWRVSW50NjRMRUJOKCk7XG4gICAgICB2YXIgbiA9IGJuLnRvTnVtYmVyKCk7XG4gICAgICBpZiAobiA8PSBNYXRoLnBvdygyLCA1MykpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciB0b28gbGFyZ2UgdG8gcmV0YWluIHByZWNpc2lvbiAtIHVzZSByZWFkVmFyaW50Qk4nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gIH1cbn07XG5cbi8qKlxuICogcmVhZHMgYSBsZW5ndGggcHJlcGVuZGVkIGJ1ZmZlclxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRWYXJMZW5ndGhCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxlbiA9IHRoaXMucmVhZFZhcmludE51bSgpO1xuICB2YXIgYnVmID0gdGhpcy5yZWFkKGxlbik7XG4gICQuY2hlY2tTdGF0ZShidWYubGVuZ3RoID09PSBsZW4sICdJbnZhbGlkIGxlbmd0aCB3aGlsZSByZWFkaW5nIHZhcmxlbmd0aCBidWZmZXIuICcgK1xuICAgICdFeHBlY3RlZCB0byByZWFkOiAnICsgbGVuICsgJyBhbmQgcmVhZCAnICsgYnVmLmxlbmd0aCk7XG4gIHJldHVybiBidWY7XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRWYXJpbnRCdWYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpcnN0ID0gdGhpcy5idWYucmVhZFVJbnQ4KHRoaXMucG9zKTtcbiAgc3dpdGNoIChmaXJzdCkge1xuICAgIGNhc2UgMHhGRDpcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoMSArIDIpO1xuICAgIGNhc2UgMHhGRTpcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoMSArIDQpO1xuICAgIGNhc2UgMHhGRjpcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoMSArIDgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKDEpO1xuICB9XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRWYXJpbnRCTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlyc3QgPSB0aGlzLnJlYWRVSW50OCgpO1xuICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgY2FzZSAweEZEOlxuICAgICAgcmV0dXJuIG5ldyBCTih0aGlzLnJlYWRVSW50MTZMRSgpKTtcbiAgICBjYXNlIDB4RkU6XG4gICAgICByZXR1cm4gbmV3IEJOKHRoaXMucmVhZFVJbnQzMkxFKCkpO1xuICAgIGNhc2UgMHhGRjpcbiAgICAgIHJldHVybiB0aGlzLnJlYWRVSW50NjRMRUJOKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgQk4oZmlyc3QpO1xuICB9XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyh0aGlzLmJ1Zi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZltpXSA9IHRoaXMuYnVmW3RoaXMuYnVmLmxlbmd0aCAtIDEgLSBpXTtcbiAgfVxuICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWRSZXZlcnNlID0gZnVuY3Rpb24obGVuKSB7XG4gIGlmIChfLmlzVW5kZWZpbmVkKGxlbikpIHtcbiAgICBsZW4gPSB0aGlzLmJ1Zi5sZW5ndGg7XG4gIH1cbiAgdmFyIGJ1ZiA9IHRoaXMuYnVmLnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIGxlbik7XG4gIHRoaXMucG9zID0gdGhpcy5wb3MgKyBsZW47XG4gIHJldHVybiBCdWZmZXJVdGlsLnJldmVyc2UoYnVmKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js":
/*!***************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/bufferwriter.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\nvar BufferWriter = function BufferWriter(obj) {\n  if (!(this instanceof BufferWriter))\n    return new BufferWriter(obj);\n  this.bufLen = 0;\n  if (obj)\n    this.set(obj);\n  else\n    this.bufs = [];\n};\n\nBufferWriter.prototype.set = function(obj) {\n  this.bufs = obj.bufs || this.bufs || [];\n  this.bufLen = this.bufs.reduce(function(prev, buf){ return prev + buf.length; }, 0);\n  return this;\n};\n\nBufferWriter.prototype.toBuffer = function() {\n  return this.concat();\n};\n\nBufferWriter.prototype.concat = function() {\n  return Buffer.concat(this.bufs, this.bufLen);\n};\n\nBufferWriter.prototype.write = function(buf) {\n  assert(bufferUtil.isBuffer(buf));\n  this.bufs.push(buf);\n  this.bufLen += buf.length;\n  return this;\n};\n\nBufferWriter.prototype.writeReverse = function(buf) {\n  assert(bufferUtil.isBuffer(buf));\n  this.bufs.push(bufferUtil.reverse(buf));\n  this.bufLen += buf.length;\n  return this;\n};\n\nBufferWriter.prototype.writeUInt8 = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16BE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16LE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32BE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeInt32LE = function(n) {\n  var buf = Buffer.alloc(4);\n  buf.writeInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32LE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64BEBN = function(bn) {\n  var buf = bn.toBuffer({size: 8});\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64LEBN = function(bn) {\n  var buf = bn.toBuffer({size: 8});\n  this.writeReverse(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintNum = function(n) {\n  var buf = BufferWriter.varintBufNum(n);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintBN = function(bn) {\n  var buf = BufferWriter.varintBufBN(bn);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.varintBufNum = function(n) {\n  var buf = undefined;\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    buf = Buffer.alloc(1 + 8);\n    buf.writeUInt8(255, 0);\n    buf.writeInt32LE(n & -1, 1);\n    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);\n  }\n  return buf;\n};\n\nBufferWriter.varintBufBN = function(bn) {\n  var buf = undefined;\n  var n = bn.toNumber();\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    var bw = new BufferWriter();\n    bw.writeUInt8(255);\n    bw.writeUInt64LEBN(bn);\n    var buf = bw.concat();\n  }\n  return buf;\n};\n\nmodule.exports = BufferWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL2J1ZmZlcndyaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHNCQUFROztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCwyQkFBMkI7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvZW5jb2RpbmcvYnVmZmVyd3JpdGVyLmpzPzA2NTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBCdWZmZXJXcml0ZXIgPSBmdW5jdGlvbiBCdWZmZXJXcml0ZXIob2JqKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXJXcml0ZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKG9iaik7XG4gIHRoaXMuYnVmTGVuID0gMDtcbiAgaWYgKG9iailcbiAgICB0aGlzLnNldChvYmopO1xuICBlbHNlXG4gICAgdGhpcy5idWZzID0gW107XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xuICB0aGlzLmJ1ZnMgPSBvYmouYnVmcyB8fCB0aGlzLmJ1ZnMgfHwgW107XG4gIHRoaXMuYnVmTGVuID0gdGhpcy5idWZzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBidWYpeyByZXR1cm4gcHJldiArIGJ1Zi5sZW5ndGg7IH0sIDApO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29uY2F0KCk7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZnMsIHRoaXMuYnVmTGVuKTtcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWYpIHtcbiAgYXNzZXJ0KGJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHRoaXMuYnVmcy5wdXNoKGJ1Zik7XG4gIHRoaXMuYnVmTGVuICs9IGJ1Zi5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVJldmVyc2UgPSBmdW5jdGlvbihidWYpIHtcbiAgYXNzZXJ0KGJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHRoaXMuYnVmcy5wdXNoKGJ1ZmZlclV0aWwucmV2ZXJzZShidWYpKTtcbiAgdGhpcy5idWZMZW4gKz0gYnVmLmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbihuKSB7XG4gIGlmIChuIDwgMCkge1xuICAgIG4gPSBuID4+PiAwOyAvLyBDb252ZXJ0IHNpZ25lZCBpbnQgdG8gdW5zaWduZWQgaW50XG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgYnVmLndyaXRlVUludDgobiwgMCk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbihuKSB7XG4gIGlmIChuIDwgMCkge1xuICAgIG4gPSBuID4+PiAwOyAvLyBDb252ZXJ0IHNpZ25lZCBpbnQgdG8gdW5zaWduZWQgaW50XG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygyKTtcbiAgYnVmLndyaXRlVUludDE2QkUobiwgMCk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbihuKSB7XG4gIGlmIChuIDwgMCkge1xuICAgIG4gPSBuID4+PiAwOyAvLyBDb252ZXJ0IHNpZ25lZCBpbnQgdG8gdW5zaWduZWQgaW50XG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygyKTtcbiAgYnVmLndyaXRlVUludDE2TEUobiwgMCk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbihuKSB7XG4gIGlmIChuIDwgMCkge1xuICAgIG4gPSBuID4+PiAwOyAvLyBDb252ZXJ0IHNpZ25lZCBpbnQgdG8gdW5zaWduZWQgaW50XG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgYnVmLndyaXRlVUludDMyQkUobiwgMCk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgYnVmLndyaXRlSW50MzJMRShuLCAwKTtcbiAgdGhpcy53cml0ZShidWYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKG4gPCAwKSB7XG4gICAgbiA9IG4gPj4+IDA7IC8vIENvbnZlcnQgc2lnbmVkIGludCB0byB1bnNpZ25lZCBpbnRcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKDQpO1xuICBidWYud3JpdGVVSW50MzJMRShuLCAwKTtcbiAgdGhpcy53cml0ZShidWYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVVSW50NjRCRUJOID0gZnVuY3Rpb24oYm4pIHtcbiAgdmFyIGJ1ZiA9IGJuLnRvQnVmZmVyKHtzaXplOiA4fSk7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLndyaXRlVUludDY0TEVCTiA9IGZ1bmN0aW9uKGJuKSB7XG4gIHZhciBidWYgPSBibi50b0J1ZmZlcih7c2l6ZTogOH0pO1xuICB0aGlzLndyaXRlUmV2ZXJzZShidWYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUud3JpdGVWYXJpbnROdW0gPSBmdW5jdGlvbihuKSB7XG4gIHZhciBidWYgPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKG4pO1xuICB0aGlzLndyaXRlKGJ1Zik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS53cml0ZVZhcmludEJOID0gZnVuY3Rpb24oYm4pIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlcldyaXRlci52YXJpbnRCdWZCTihibik7XG4gIHRoaXMud3JpdGUoYnVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtID0gZnVuY3Rpb24obikge1xuICB2YXIgYnVmID0gdW5kZWZpbmVkO1xuICBpZiAobiA8IDI1Mykge1xuICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICBidWYud3JpdGVVSW50OChuLCAwKTtcbiAgfSBlbHNlIGlmIChuIDwgMHgxMDAwMCkge1xuICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxICsgMik7XG4gICAgYnVmLndyaXRlVUludDgoMjUzLCAwKTtcbiAgICBidWYud3JpdGVVSW50MTZMRShuLCAxKTtcbiAgfSBlbHNlIGlmIChuIDwgMHgxMDAwMDAwMDApIHtcbiAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSArIDQpO1xuICAgIGJ1Zi53cml0ZVVJbnQ4KDI1NCwgMCk7XG4gICAgYnVmLndyaXRlVUludDMyTEUobiwgMSk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmFsbG9jKDEgKyA4KTtcbiAgICBidWYud3JpdGVVSW50OCgyNTUsIDApO1xuICAgIGJ1Zi53cml0ZUludDMyTEUobiAmIC0xLCAxKTtcbiAgICBidWYud3JpdGVVSW50MzJMRShNYXRoLmZsb29yKG4gLyAweDEwMDAwMDAwMCksIDUpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5CdWZmZXJXcml0ZXIudmFyaW50QnVmQk4gPSBmdW5jdGlvbihibikge1xuICB2YXIgYnVmID0gdW5kZWZpbmVkO1xuICB2YXIgbiA9IGJuLnRvTnVtYmVyKCk7XG4gIGlmIChuIDwgMjUzKSB7XG4gICAgYnVmID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgIGJ1Zi53cml0ZVVJbnQ4KG4sIDApO1xuICB9IGVsc2UgaWYgKG4gPCAweDEwMDAwKSB7XG4gICAgYnVmID0gQnVmZmVyLmFsbG9jKDEgKyAyKTtcbiAgICBidWYud3JpdGVVSW50OCgyNTMsIDApO1xuICAgIGJ1Zi53cml0ZVVJbnQxNkxFKG4sIDEpO1xuICB9IGVsc2UgaWYgKG4gPCAweDEwMDAwMDAwMCkge1xuICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxICsgNCk7XG4gICAgYnVmLndyaXRlVUludDgoMjU0LCAwKTtcbiAgICBidWYud3JpdGVVSW50MzJMRShuLCAxKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYncgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgYncud3JpdGVVSW50OCgyNTUpO1xuICAgIGJ3LndyaXRlVUludDY0TEVCTihibik7XG4gICAgdmFyIGJ1ZiA9IGJ3LmNvbmNhdCgpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/encoding/varint.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/encoding/varint.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BufferWriter = __webpack_require__(/*! ./bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar BufferReader = __webpack_require__(/*! ./bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\n\nvar Varint = function Varint(buf) {\n  if (!(this instanceof Varint))\n    return new Varint(buf);\n  if (Buffer.isBuffer(buf)) {\n    this.buf = buf;\n  } else if (typeof buf === 'number') {\n    var num = buf;\n    this.fromNumber(num);\n  } else if (buf instanceof BN) {\n    var bn = buf;\n    this.fromBN(bn);\n  } else if (buf) {\n    var obj = buf;\n    this.set(obj);\n  }\n};\n\nVarint.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf;\n  return this;\n};\n\nVarint.prototype.fromString = function(str) {\n  this.set({\n    buf: Buffer.from(str, 'hex')\n  });\n  return this;\n};\n\nVarint.prototype.toString = function() {\n  return this.buf.toString('hex');\n};\n\nVarint.prototype.fromBuffer = function(buf) {\n  this.buf = buf;\n  return this;\n};\n\nVarint.prototype.fromBufferReader = function(br) {\n  this.buf = br.readVarintBuf();\n  return this;\n};\n\nVarint.prototype.fromBN = function(bn) {\n  this.buf = BufferWriter().writeVarintBN(bn).concat();\n  return this;\n};\n\nVarint.prototype.fromNumber = function(num) {\n  this.buf = BufferWriter().writeVarintNum(num).concat();\n  return this;\n};\n\nVarint.prototype.toBuffer = function() {\n  return this.buf;\n};\n\nVarint.prototype.toBN = function() {\n  return BufferReader(this.buf).readVarintBN();\n};\n\nVarint.prototype.toNumber = function() {\n  return BufferReader(this.buf).readVarintNum();\n};\n\nmodule.exports = Varint;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL3ZhcmludC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBZ0I7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMscUZBQWdCO0FBQzNDLFNBQVMsbUJBQU8sQ0FBQyx1RUFBYzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2VuY29kaW5nL3ZhcmludC5qcz8yYzAzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4vYnVmZmVyd3JpdGVyJyk7XG52YXIgQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9idWZmZXJyZWFkZXInKTtcbnZhciBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xuXG52YXIgVmFyaW50ID0gZnVuY3Rpb24gVmFyaW50KGJ1Zikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVmFyaW50KSlcbiAgICByZXR1cm4gbmV3IFZhcmludChidWYpO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnVmID09PSAnbnVtYmVyJykge1xuICAgIHZhciBudW0gPSBidWY7XG4gICAgdGhpcy5mcm9tTnVtYmVyKG51bSk7XG4gIH0gZWxzZSBpZiAoYnVmIGluc3RhbmNlb2YgQk4pIHtcbiAgICB2YXIgYm4gPSBidWY7XG4gICAgdGhpcy5mcm9tQk4oYm4pO1xuICB9IGVsc2UgaWYgKGJ1Zikge1xuICAgIHZhciBvYmogPSBidWY7XG4gICAgdGhpcy5zZXQob2JqKTtcbiAgfVxufTtcblxuVmFyaW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5idWYgPSBvYmouYnVmIHx8IHRoaXMuYnVmO1xuICByZXR1cm4gdGhpcztcbn07XG5cblZhcmludC5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICB0aGlzLnNldCh7XG4gICAgYnVmOiBCdWZmZXIuZnJvbShzdHIsICdoZXgnKVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WYXJpbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJ1Zi50b1N0cmluZygnaGV4Jyk7XG59O1xuXG5WYXJpbnQucHJvdG90eXBlLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcbiAgdGhpcy5idWYgPSBidWY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVmFyaW50LnByb3RvdHlwZS5mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24oYnIpIHtcbiAgdGhpcy5idWYgPSBici5yZWFkVmFyaW50QnVmKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVmFyaW50LnByb3RvdHlwZS5mcm9tQk4gPSBmdW5jdGlvbihibikge1xuICB0aGlzLmJ1ZiA9IEJ1ZmZlcldyaXRlcigpLndyaXRlVmFyaW50Qk4oYm4pLmNvbmNhdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblZhcmludC5wcm90b3R5cGUuZnJvbU51bWJlciA9IGZ1bmN0aW9uKG51bSkge1xuICB0aGlzLmJ1ZiA9IEJ1ZmZlcldyaXRlcigpLndyaXRlVmFyaW50TnVtKG51bSkuY29uY2F0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVmFyaW50LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5idWY7XG59O1xuXG5WYXJpbnQucHJvdG90eXBlLnRvQk4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEJ1ZmZlclJlYWRlcih0aGlzLmJ1ZikucmVhZFZhcmludEJOKCk7XG59O1xuXG5WYXJpbnQucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBCdWZmZXJSZWFkZXIodGhpcy5idWYpLnJlYWRWYXJpbnROdW0oKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFyaW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/encoding/varint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/errors/index.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/errors/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nfunction format(message, args) {\n  return message\n    .replace('{0}', args[0])\n    .replace('{1}', args[1])\n    .replace('{2}', args[2]);\n}\nvar traverseNode = function(parent, errorDefinition) {\n  var NodeError = function() {\n    if (_.isString(errorDefinition.message)) {\n      this.message = format(errorDefinition.message, arguments);\n    } else if (_.isFunction(errorDefinition.message)) {\n      this.message = errorDefinition.message.apply(null, arguments);\n    } else {\n      throw new Error('Invalid error definition for ' + errorDefinition.name);\n    }\n    this.stack = this.message + '\\n' + (new Error()).stack;\n  };\n  NodeError.prototype = Object.create(parent.prototype);\n  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;\n  parent[errorDefinition.name] = NodeError;\n  if (errorDefinition.errors) {\n    childDefinitions(NodeError, errorDefinition.errors);\n  }\n  return NodeError;\n};\n\n/* jshint latedef: false */\nvar childDefinitions = function(parent, childDefinitions) {\n  _.each(childDefinitions, function(childDefinition) {\n    traverseNode(parent, childDefinition);\n  });\n};\n/* jshint latedef: true */\n\nvar traverseRoot = function(parent, errorsDefinition) {\n  childDefinitions(parent, errorsDefinition);\n  return parent;\n};\n\n\nvar bitcore = {};\nbitcore.Error = function() {\n  this.message = 'Internal error';\n  this.stack = this.message + '\\n' + (new Error()).stack;\n};\nbitcore.Error.prototype = Object.create(Error.prototype);\nbitcore.Error.prototype.name = 'bitcore.Error';\n\n\nvar data = __webpack_require__(/*! ./spec */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/spec.js\");\ntraverseRoot(bitcore.Error, data);\n\nmodule.exports = bitcore.Error;\n\nmodule.exports.extend = function(spec) {\n  return traverseNode(bitcore.Error, spec);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Vycm9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7O0FBRXhCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsV0FBVyxtQkFBTyxDQUFDLG1FQUFRO0FBQzNCOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Vycm9ycy9pbmRleC5qcz84Mzc5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuZnVuY3Rpb24gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpIHtcbiAgcmV0dXJuIG1lc3NhZ2VcbiAgICAucmVwbGFjZSgnezB9JywgYXJnc1swXSlcbiAgICAucmVwbGFjZSgnezF9JywgYXJnc1sxXSlcbiAgICAucmVwbGFjZSgnezJ9JywgYXJnc1syXSk7XG59XG52YXIgdHJhdmVyc2VOb2RlID0gZnVuY3Rpb24ocGFyZW50LCBlcnJvckRlZmluaXRpb24pIHtcbiAgdmFyIE5vZGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChfLmlzU3RyaW5nKGVycm9yRGVmaW5pdGlvbi5tZXNzYWdlKSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gZm9ybWF0KGVycm9yRGVmaW5pdGlvbi5tZXNzYWdlLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKGVycm9yRGVmaW5pdGlvbi5tZXNzYWdlKSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JEZWZpbml0aW9uLm1lc3NhZ2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVycm9yIGRlZmluaXRpb24gZm9yICcgKyBlcnJvckRlZmluaXRpb24ubmFtZSk7XG4gICAgfVxuICAgIHRoaXMuc3RhY2sgPSB0aGlzLm1lc3NhZ2UgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gIH07XG4gIE5vZGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBwYXJlbnQucHJvdG90eXBlLm5hbWUgKyBlcnJvckRlZmluaXRpb24ubmFtZTtcbiAgcGFyZW50W2Vycm9yRGVmaW5pdGlvbi5uYW1lXSA9IE5vZGVFcnJvcjtcbiAgaWYgKGVycm9yRGVmaW5pdGlvbi5lcnJvcnMpIHtcbiAgICBjaGlsZERlZmluaXRpb25zKE5vZGVFcnJvciwgZXJyb3JEZWZpbml0aW9uLmVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIE5vZGVFcnJvcjtcbn07XG5cbi8qIGpzaGludCBsYXRlZGVmOiBmYWxzZSAqL1xudmFyIGNoaWxkRGVmaW5pdGlvbnMgPSBmdW5jdGlvbihwYXJlbnQsIGNoaWxkRGVmaW5pdGlvbnMpIHtcbiAgXy5lYWNoKGNoaWxkRGVmaW5pdGlvbnMsIGZ1bmN0aW9uKGNoaWxkRGVmaW5pdGlvbikge1xuICAgIHRyYXZlcnNlTm9kZShwYXJlbnQsIGNoaWxkRGVmaW5pdGlvbik7XG4gIH0pO1xufTtcbi8qIGpzaGludCBsYXRlZGVmOiB0cnVlICovXG5cbnZhciB0cmF2ZXJzZVJvb3QgPSBmdW5jdGlvbihwYXJlbnQsIGVycm9yc0RlZmluaXRpb24pIHtcbiAgY2hpbGREZWZpbml0aW9ucyhwYXJlbnQsIGVycm9yc0RlZmluaXRpb24pO1xuICByZXR1cm4gcGFyZW50O1xufTtcblxuXG52YXIgYml0Y29yZSA9IHt9O1xuYml0Y29yZS5FcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm1lc3NhZ2UgPSAnSW50ZXJuYWwgZXJyb3InO1xuICB0aGlzLnN0YWNrID0gdGhpcy5tZXNzYWdlICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrO1xufTtcbmJpdGNvcmUuRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuYml0Y29yZS5FcnJvci5wcm90b3R5cGUubmFtZSA9ICdiaXRjb3JlLkVycm9yJztcblxuXG52YXIgZGF0YSA9IHJlcXVpcmUoJy4vc3BlYycpO1xudHJhdmVyc2VSb290KGJpdGNvcmUuRXJyb3IsIGRhdGEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpdGNvcmUuRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgcmV0dXJuIHRyYXZlcnNlTm9kZShiaXRjb3JlLkVycm9yLCBzcGVjKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/errors/spec.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/errors/spec.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar docsURL = 'http://bitcore.io/';\n\nmodule.exports = [{\n  name: 'InvalidB58Char',\n  message: 'Invalid Base58 character: {0} in {1}'\n}, {\n  name: 'InvalidB58Checksum',\n  message: 'Invalid Base58 checksum for {0}'\n}, {\n  name: 'InvalidNetwork',\n  message: 'Invalid version for network: got {0}'\n}, {\n  name: 'InvalidState',\n  message: 'Invalid state: {0}'\n}, {\n  name: 'NotImplemented',\n  message: 'Function {0} was not implemented yet'\n}, {\n  name: 'InvalidNetworkArgument',\n  message: 'Invalid network: must be \"livenet\" or \"testnet\", got {0}'\n}, {\n  name: 'InvalidArgument',\n  message: function() {\n    return 'Invalid Argument' + (arguments[0] ? (': ' + arguments[0]) : '') +\n      (arguments[1] ? (' Documentation: ' + docsURL + arguments[1]) : '');\n  }\n}, {\n  name: 'AbstractMethodInvoked',\n  message: 'Abstract Method Invocation: {0}'\n}, {\n  name: 'InvalidArgumentType',\n  message: function() {\n    return 'Invalid Argument for ' + arguments[2] + ', expected ' + arguments[1] + ' but got ' + typeof arguments[0];\n  }\n}, {\n  name: 'Unit',\n  message: 'Internal Error on Unit {0}',\n  errors: [{\n    'name': 'UnknownCode',\n    'message': 'Unrecognized unit code: {0}'\n  }, {\n    'name': 'InvalidRate',\n    'message': 'Invalid exchange rate: {0}'\n  }]\n}, {\n  name: 'MerkleBlock',\n  message: 'Internal Error on MerkleBlock {0}',\n  errors: [{\n    'name': 'InvalidMerkleTree',\n    'message': 'This MerkleBlock contain an invalid Merkle Tree'\n  }]\n}, {\n  name: 'Transaction',\n  message: 'Internal Error on Transaction {0}',\n  errors: [{\n    name: 'Input',\n    message: 'Internal Error on Input {0}',\n    errors: [{\n      name: 'MissingScript',\n      message: 'Need a script to create an input'\n    }, {\n      name: 'UnsupportedScript',\n      message: 'Unsupported input script type: {0}'\n    }, {\n      name: 'MissingPreviousOutput',\n      message: 'No previous output information.'\n    }, {\n      name: 'BlockHeightOutOfRange',\n      message: 'Block Height can only be between 0 and 65535'\n    } , {\n      name: 'LockTimeRange',\n      message: 'Seconds needs to be more that 0 and less that 33553920'\n    }\n    ]\n  }, {\n    name: 'NeedMoreInfo',\n    message: '{0}'\n  }, {\n    name: 'InvalidSorting',\n    message: 'The sorting function provided did not return the change output as one of the array elements'\n  }, {\n    name: 'InvalidOutputAmountSum',\n    message: '{0}'\n  }, {\n    name: 'MissingSignatures',\n    message: 'Some inputs have not been fully signed'\n  }, {\n    name: 'InvalidIndex',\n    message: 'Invalid index: {0} is not between 0, {1}'\n  }, {\n    name: 'UnableToVerifySignature',\n    message: 'Unable to verify signature: {0}'\n  }, {\n    name: 'DustOutputs',\n    message: 'Dust amount detected in one output'\n  }, {\n    name: 'InvalidSatoshis',\n    message: 'Output satoshis are invalid',\n  }, {\n    name: 'FeeError',\n    message: 'Internal Error on Fee {0}',\n    errors: [{\n      name: 'TooSmall',\n      message: 'Fee is too small: {0}',\n    }, {\n      name: 'TooLarge',\n      message: 'Fee is too large: {0}',\n    }, {\n      name: 'Different',\n      message: 'Unspent value is different from specified fee: {0}',\n    }]\n  }, {\n    name: 'ChangeAddressMissing',\n    message: 'Change address is missing'\n  }, {\n    name: 'BlockHeightTooHigh',\n    message: 'Block Height can be at most 2^32 -1'\n  }, {\n    name: 'NLockTimeOutOfRange',\n    message: 'Block Height can only be between 0 and 499 999 999'\n  }, {\n    name: 'LockTimeTooEarly',\n    message: 'Lock Time can\\'t be earlier than UNIX date 500 000 000'\n  }]\n}, {\n  name: 'Script',\n  message: 'Internal Error on Script {0}',\n  errors: [{\n    name: 'UnrecognizedAddress',\n    message: 'Expected argument {0} to be an address'\n  }, {\n    name: 'CantDeriveAddress',\n    message: 'Can\\'t derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.'\n  }, {\n    name: 'InvalidBuffer',\n    message: 'Invalid script buffer: can\\'t parse valid script from given buffer {0}'\n  }]\n}, {\n  name: 'HDPrivateKey',\n  message: 'Internal Error on HDPrivateKey {0}',\n  errors: [{\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument {0}, expected string, or number and boolean'\n  }, {\n    name: 'InvalidEntropyArgument',\n    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',\n    errors: [{\n      name: 'TooMuchEntropy',\n      message: 'Invalid entropy: more than 512 bits is non standard, got \"{0}\"'\n    }, {\n      name: 'NotEnoughEntropy',\n      message: 'Invalid entropy: at least 128 bits needed, got \"{0}\"'\n    }]\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xprivkey string in {0}'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path: {0}'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got \"{0}\"'\n  }]\n}, {\n  name: 'HDPublicKey',\n  message: 'Internal Error on HDPublicKey {0}',\n  errors: [{\n    name: 'ArgumentIsPrivateExtended',\n    message: 'Argument is an extended private key: {0}'\n  }, {\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument: got {0}'\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xpubkey: got \"{0}\"'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path, it should look like: \"m/1/100\", got \"{0}\"'\n  }, {\n    name: 'InvalidIndexCantDeriveHardened',\n    message: 'Invalid argument: creating a hardened path requires an HDPrivateKey'\n  }, {\n    name: 'MustSupplyArgument',\n    message: 'Must supply an argument to create a HDPublicKey'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument for creation, must be string, json, buffer, or object'\n  }]\n}];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2Vycm9ycy9zcGVjLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRyxJQUFJLEVBQUU7QUFDaEQsQ0FBQztBQUNEO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0MsQ0FBQztBQUNEO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLEVBQUU7QUFDOUIsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLEdBQUc7QUFDekIsQ0FBQztBQUNEO0FBQ0Esa0VBQWtFLEVBQUU7QUFDcEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5Q0FBeUMsRUFBRTtBQUMzQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0MsR0FBRztBQUNIO0FBQ0Esd0NBQXdDLEVBQUU7QUFDMUMsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsRUFBRTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsRUFBRTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixHQUFHLG1CQUFtQixFQUFFO0FBQ3RELEdBQUc7QUFDSDtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QztBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckMsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckMsS0FBSztBQUNMO0FBQ0EsZ0VBQWdFLEVBQUU7QUFDbEUsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLHNDQUFzQyxFQUFFO0FBQ3hDO0FBQ0E7QUFDQSxpQ0FBaUMsR0FBRztBQUNwQyxHQUFHO0FBQ0g7QUFDQSw0REFBNEQsRUFBRTtBQUM5RCxHQUFHO0FBQ0g7QUFDQSxrRkFBa0YsRUFBRTtBQUNwRixHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDLEdBQUc7QUFDSDtBQUNBLDZFQUE2RSxFQUFFO0FBQy9FO0FBQ0E7QUFDQSwyRUFBMkUsRUFBRTtBQUM3RSxLQUFLO0FBQ0w7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EscURBQXFELEVBQUU7QUFDdkQsR0FBRztBQUNIO0FBQ0Esd0NBQXdDLEVBQUU7QUFDMUMsR0FBRztBQUNIO0FBQ0EseUdBQXlHLEVBQUU7QUFDM0csR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RCxHQUFHO0FBQ0g7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRCxHQUFHO0FBQ0g7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRCxHQUFHO0FBQ0g7QUFDQSw2RUFBNkUsRUFBRTtBQUMvRSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9lcnJvcnMvc3BlYy5qcz9kMWU5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGRvY3NVUkwgPSAnaHR0cDovL2JpdGNvcmUuaW8vJztcblxubW9kdWxlLmV4cG9ydHMgPSBbe1xuICBuYW1lOiAnSW52YWxpZEI1OENoYXInLFxuICBtZXNzYWdlOiAnSW52YWxpZCBCYXNlNTggY2hhcmFjdGVyOiB7MH0gaW4gezF9J1xufSwge1xuICBuYW1lOiAnSW52YWxpZEI1OENoZWNrc3VtJyxcbiAgbWVzc2FnZTogJ0ludmFsaWQgQmFzZTU4IGNoZWNrc3VtIGZvciB7MH0nXG59LCB7XG4gIG5hbWU6ICdJbnZhbGlkTmV0d29yaycsXG4gIG1lc3NhZ2U6ICdJbnZhbGlkIHZlcnNpb24gZm9yIG5ldHdvcms6IGdvdCB7MH0nXG59LCB7XG4gIG5hbWU6ICdJbnZhbGlkU3RhdGUnLFxuICBtZXNzYWdlOiAnSW52YWxpZCBzdGF0ZTogezB9J1xufSwge1xuICBuYW1lOiAnTm90SW1wbGVtZW50ZWQnLFxuICBtZXNzYWdlOiAnRnVuY3Rpb24gezB9IHdhcyBub3QgaW1wbGVtZW50ZWQgeWV0J1xufSwge1xuICBuYW1lOiAnSW52YWxpZE5ldHdvcmtBcmd1bWVudCcsXG4gIG1lc3NhZ2U6ICdJbnZhbGlkIG5ldHdvcms6IG11c3QgYmUgXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCIsIGdvdCB7MH0nXG59LCB7XG4gIG5hbWU6ICdJbnZhbGlkQXJndW1lbnQnLFxuICBtZXNzYWdlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ0ludmFsaWQgQXJndW1lbnQnICsgKGFyZ3VtZW50c1swXSA/ICgnOiAnICsgYXJndW1lbnRzWzBdKSA6ICcnKSArXG4gICAgICAoYXJndW1lbnRzWzFdID8gKCcgRG9jdW1lbnRhdGlvbjogJyArIGRvY3NVUkwgKyBhcmd1bWVudHNbMV0pIDogJycpO1xuICB9XG59LCB7XG4gIG5hbWU6ICdBYnN0cmFjdE1ldGhvZEludm9rZWQnLFxuICBtZXNzYWdlOiAnQWJzdHJhY3QgTWV0aG9kIEludm9jYXRpb246IHswfSdcbn0sIHtcbiAgbmFtZTogJ0ludmFsaWRBcmd1bWVudFR5cGUnLFxuICBtZXNzYWdlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ0ludmFsaWQgQXJndW1lbnQgZm9yICcgKyBhcmd1bWVudHNbMl0gKyAnLCBleHBlY3RlZCAnICsgYXJndW1lbnRzWzFdICsgJyBidXQgZ290ICcgKyB0eXBlb2YgYXJndW1lbnRzWzBdO1xuICB9XG59LCB7XG4gIG5hbWU6ICdVbml0JyxcbiAgbWVzc2FnZTogJ0ludGVybmFsIEVycm9yIG9uIFVuaXQgezB9JyxcbiAgZXJyb3JzOiBbe1xuICAgICduYW1lJzogJ1Vua25vd25Db2RlJyxcbiAgICAnbWVzc2FnZSc6ICdVbnJlY29nbml6ZWQgdW5pdCBjb2RlOiB7MH0nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdJbnZhbGlkUmF0ZScsXG4gICAgJ21lc3NhZ2UnOiAnSW52YWxpZCBleGNoYW5nZSByYXRlOiB7MH0nXG4gIH1dXG59LCB7XG4gIG5hbWU6ICdNZXJrbGVCbG9jaycsXG4gIG1lc3NhZ2U6ICdJbnRlcm5hbCBFcnJvciBvbiBNZXJrbGVCbG9jayB7MH0nLFxuICBlcnJvcnM6IFt7XG4gICAgJ25hbWUnOiAnSW52YWxpZE1lcmtsZVRyZWUnLFxuICAgICdtZXNzYWdlJzogJ1RoaXMgTWVya2xlQmxvY2sgY29udGFpbiBhbiBpbnZhbGlkIE1lcmtsZSBUcmVlJ1xuICB9XVxufSwge1xuICBuYW1lOiAnVHJhbnNhY3Rpb24nLFxuICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3Igb24gVHJhbnNhY3Rpb24gezB9JyxcbiAgZXJyb3JzOiBbe1xuICAgIG5hbWU6ICdJbnB1dCcsXG4gICAgbWVzc2FnZTogJ0ludGVybmFsIEVycm9yIG9uIElucHV0IHswfScsXG4gICAgZXJyb3JzOiBbe1xuICAgICAgbmFtZTogJ01pc3NpbmdTY3JpcHQnLFxuICAgICAgbWVzc2FnZTogJ05lZWQgYSBzY3JpcHQgdG8gY3JlYXRlIGFuIGlucHV0J1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdVbnN1cHBvcnRlZFNjcmlwdCcsXG4gICAgICBtZXNzYWdlOiAnVW5zdXBwb3J0ZWQgaW5wdXQgc2NyaXB0IHR5cGU6IHswfSdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnTWlzc2luZ1ByZXZpb3VzT3V0cHV0JyxcbiAgICAgIG1lc3NhZ2U6ICdObyBwcmV2aW91cyBvdXRwdXQgaW5mb3JtYXRpb24uJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdCbG9ja0hlaWdodE91dE9mUmFuZ2UnLFxuICAgICAgbWVzc2FnZTogJ0Jsb2NrIEhlaWdodCBjYW4gb25seSBiZSBiZXR3ZWVuIDAgYW5kIDY1NTM1J1xuICAgIH0gLCB7XG4gICAgICBuYW1lOiAnTG9ja1RpbWVSYW5nZScsXG4gICAgICBtZXNzYWdlOiAnU2Vjb25kcyBuZWVkcyB0byBiZSBtb3JlIHRoYXQgMCBhbmQgbGVzcyB0aGF0IDMzNTUzOTIwJ1xuICAgIH1cbiAgICBdXG4gIH0sIHtcbiAgICBuYW1lOiAnTmVlZE1vcmVJbmZvJyxcbiAgICBtZXNzYWdlOiAnezB9J1xuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWRTb3J0aW5nJyxcbiAgICBtZXNzYWdlOiAnVGhlIHNvcnRpbmcgZnVuY3Rpb24gcHJvdmlkZWQgZGlkIG5vdCByZXR1cm4gdGhlIGNoYW5nZSBvdXRwdXQgYXMgb25lIG9mIHRoZSBhcnJheSBlbGVtZW50cydcbiAgfSwge1xuICAgIG5hbWU6ICdJbnZhbGlkT3V0cHV0QW1vdW50U3VtJyxcbiAgICBtZXNzYWdlOiAnezB9J1xuICB9LCB7XG4gICAgbmFtZTogJ01pc3NpbmdTaWduYXR1cmVzJyxcbiAgICBtZXNzYWdlOiAnU29tZSBpbnB1dHMgaGF2ZSBub3QgYmVlbiBmdWxseSBzaWduZWQnXG4gIH0sIHtcbiAgICBuYW1lOiAnSW52YWxpZEluZGV4JyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBpbmRleDogezB9IGlzIG5vdCBiZXR3ZWVuIDAsIHsxfSdcbiAgfSwge1xuICAgIG5hbWU6ICdVbmFibGVUb1ZlcmlmeVNpZ25hdHVyZScsXG4gICAgbWVzc2FnZTogJ1VuYWJsZSB0byB2ZXJpZnkgc2lnbmF0dXJlOiB7MH0nXG4gIH0sIHtcbiAgICBuYW1lOiAnRHVzdE91dHB1dHMnLFxuICAgIG1lc3NhZ2U6ICdEdXN0IGFtb3VudCBkZXRlY3RlZCBpbiBvbmUgb3V0cHV0J1xuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWRTYXRvc2hpcycsXG4gICAgbWVzc2FnZTogJ091dHB1dCBzYXRvc2hpcyBhcmUgaW52YWxpZCcsXG4gIH0sIHtcbiAgICBuYW1lOiAnRmVlRXJyb3InLFxuICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBFcnJvciBvbiBGZWUgezB9JyxcbiAgICBlcnJvcnM6IFt7XG4gICAgICBuYW1lOiAnVG9vU21hbGwnLFxuICAgICAgbWVzc2FnZTogJ0ZlZSBpcyB0b28gc21hbGw6IHswfScsXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1Rvb0xhcmdlJyxcbiAgICAgIG1lc3NhZ2U6ICdGZWUgaXMgdG9vIGxhcmdlOiB7MH0nLFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdEaWZmZXJlbnQnLFxuICAgICAgbWVzc2FnZTogJ1Vuc3BlbnQgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gc3BlY2lmaWVkIGZlZTogezB9JyxcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ0NoYW5nZUFkZHJlc3NNaXNzaW5nJyxcbiAgICBtZXNzYWdlOiAnQ2hhbmdlIGFkZHJlc3MgaXMgbWlzc2luZydcbiAgfSwge1xuICAgIG5hbWU6ICdCbG9ja0hlaWdodFRvb0hpZ2gnLFxuICAgIG1lc3NhZ2U6ICdCbG9jayBIZWlnaHQgY2FuIGJlIGF0IG1vc3QgMl4zMiAtMSdcbiAgfSwge1xuICAgIG5hbWU6ICdOTG9ja1RpbWVPdXRPZlJhbmdlJyxcbiAgICBtZXNzYWdlOiAnQmxvY2sgSGVpZ2h0IGNhbiBvbmx5IGJlIGJldHdlZW4gMCBhbmQgNDk5IDk5OSA5OTknXG4gIH0sIHtcbiAgICBuYW1lOiAnTG9ja1RpbWVUb29FYXJseScsXG4gICAgbWVzc2FnZTogJ0xvY2sgVGltZSBjYW5cXCd0IGJlIGVhcmxpZXIgdGhhbiBVTklYIGRhdGUgNTAwIDAwMCAwMDAnXG4gIH1dXG59LCB7XG4gIG5hbWU6ICdTY3JpcHQnLFxuICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3Igb24gU2NyaXB0IHswfScsXG4gIGVycm9yczogW3tcbiAgICBuYW1lOiAnVW5yZWNvZ25pemVkQWRkcmVzcycsXG4gICAgbWVzc2FnZTogJ0V4cGVjdGVkIGFyZ3VtZW50IHswfSB0byBiZSBhbiBhZGRyZXNzJ1xuICB9LCB7XG4gICAgbmFtZTogJ0NhbnREZXJpdmVBZGRyZXNzJyxcbiAgICBtZXNzYWdlOiAnQ2FuXFwndCBkZXJpdmUgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggc2NyaXB0IHswfSwgbmVlZHMgdG8gYmUgcDJwa2ggaW4sIHAycGtoIG91dCwgcDJzaCBpbiwgb3IgcDJzaCBvdXQuJ1xuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWRCdWZmZXInLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHNjcmlwdCBidWZmZXI6IGNhblxcJ3QgcGFyc2UgdmFsaWQgc2NyaXB0IGZyb20gZ2l2ZW4gYnVmZmVyIHswfSdcbiAgfV1cbn0sIHtcbiAgbmFtZTogJ0hEUHJpdmF0ZUtleScsXG4gIG1lc3NhZ2U6ICdJbnRlcm5hbCBFcnJvciBvbiBIRFByaXZhdGVLZXkgezB9JyxcbiAgZXJyb3JzOiBbe1xuICAgIG5hbWU6ICdJbnZhbGlkRGVyaXZhdGlvbkFyZ3VtZW50JyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBkZXJpdmF0aW9uIGFyZ3VtZW50IHswfSwgZXhwZWN0ZWQgc3RyaW5nLCBvciBudW1iZXIgYW5kIGJvb2xlYW4nXG4gIH0sIHtcbiAgICBuYW1lOiAnSW52YWxpZEVudHJvcHlBcmd1bWVudCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgZW50cm9weTogbXVzdCBiZSBhbiBoZXhhIHN0cmluZyBvciBiaW5hcnkgYnVmZmVyLCBnb3QgezB9JyxcbiAgICBlcnJvcnM6IFt7XG4gICAgICBuYW1lOiAnVG9vTXVjaEVudHJvcHknLFxuICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZW50cm9weTogbW9yZSB0aGFuIDUxMiBiaXRzIGlzIG5vbiBzdGFuZGFyZCwgZ290IFwiezB9XCInXG4gICAgfSwge1xuICAgICAgbmFtZTogJ05vdEVub3VnaEVudHJvcHknLFxuICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZW50cm9weTogYXQgbGVhc3QgMTI4IGJpdHMgbmVlZGVkLCBnb3QgXCJ7MH1cIidcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWRMZW5ndGgnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGxlbmd0aCBmb3IgeHByaXZrZXkgc3RyaW5nIGluIHswfSdcbiAgfSwge1xuICAgIG5hbWU6ICdJbnZhbGlkUGF0aCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXRoOiB7MH0nXG4gIH0sIHtcbiAgICBuYW1lOiAnVW5yZWNvZ25pemVkQXJndW1lbnQnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGFyZ3VtZW50OiBjcmVhdGluZyBhIEhEUHJpdmF0ZUtleSByZXF1aXJlcyBhIHN0cmluZywgYnVmZmVyLCBqc29uIG9yIG9iamVjdCwgZ290IFwiezB9XCInXG4gIH1dXG59LCB7XG4gIG5hbWU6ICdIRFB1YmxpY0tleScsXG4gIG1lc3NhZ2U6ICdJbnRlcm5hbCBFcnJvciBvbiBIRFB1YmxpY0tleSB7MH0nLFxuICBlcnJvcnM6IFt7XG4gICAgbmFtZTogJ0FyZ3VtZW50SXNQcml2YXRlRXh0ZW5kZWQnLFxuICAgIG1lc3NhZ2U6ICdBcmd1bWVudCBpcyBhbiBleHRlbmRlZCBwcml2YXRlIGtleTogezB9J1xuICB9LCB7XG4gICAgbmFtZTogJ0ludmFsaWREZXJpdmF0aW9uQXJndW1lbnQnLFxuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGRlcml2YXRpb24gYXJndW1lbnQ6IGdvdCB7MH0nXG4gIH0sIHtcbiAgICBuYW1lOiAnSW52YWxpZExlbmd0aCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgbGVuZ3RoIGZvciB4cHVia2V5OiBnb3QgXCJ7MH1cIidcbiAgfSwge1xuICAgIG5hbWU6ICdJbnZhbGlkUGF0aCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXRoLCBpdCBzaG91bGQgbG9vayBsaWtlOiBcIm0vMS8xMDBcIiwgZ290IFwiezB9XCInXG4gIH0sIHtcbiAgICBuYW1lOiAnSW52YWxpZEluZGV4Q2FudERlcml2ZUhhcmRlbmVkJyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBhcmd1bWVudDogY3JlYXRpbmcgYSBoYXJkZW5lZCBwYXRoIHJlcXVpcmVzIGFuIEhEUHJpdmF0ZUtleSdcbiAgfSwge1xuICAgIG5hbWU6ICdNdXN0U3VwcGx5QXJndW1lbnQnLFxuICAgIG1lc3NhZ2U6ICdNdXN0IHN1cHBseSBhbiBhcmd1bWVudCB0byBjcmVhdGUgYSBIRFB1YmxpY0tleSdcbiAgfSwge1xuICAgIG5hbWU6ICdVbnJlY29nbml6ZWRBcmd1bWVudCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgYXJndW1lbnQgZm9yIGNyZWF0aW9uLCBtdXN0IGJlIHN0cmluZywganNvbiwgYnVmZmVyLCBvciBvYmplY3QnXG4gIH1dXG59XTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/errors/spec.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/hdprivatekey.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/hdprivatekey.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar Base58 = __webpack_require__(/*! ./encoding/base58 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\");\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Network = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar Point = __webpack_require__(/*! ./crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nvar PrivateKey = __webpack_require__(/*! ./privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\nvar Random = __webpack_require__(/*! ./crypto/random */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar hdErrors = errors.HDPrivateKey;\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n\n\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\nHDPrivateKey.isValidPath = function(arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\nHDPrivateKey._getDerivationIndexes = function(path) {\n  var steps = path.split('/');\n\n  // Special cases:\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function(step) {\n    var isHardened = step.slice(-1) === '\\'';\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n    var index = +step; // cast to number\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n\n  return _.some(indexes, isNaN) ? null : indexes;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.derive = function(arg, hardened) {\n  return this.deriveNonCompliantChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32});\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index, null, nonCompliant);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPrivateKey.isValidSerialized = function(data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\nHDPrivateKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(0, 4);\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPrivateKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function(arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? Buffer.from(arg.privateKey,'hex') : arg.privateKey,\n    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,\n      HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function(network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\nHDPrivateKey.fromSeed = function(hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = Buffer.from(hexa, 'hex');\n  }\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n  const hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\n\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\nHDPrivateKey.prototype._calcHDPublicKey = function() {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = __webpack_require__(/*! ./hdpublickey */ \"(ssr)/./node_modules/bitcore-lib/lib/hdpublickey.js\");\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.privateKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\nHDPrivateKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    BufferUtil.emptyBuffer(1), arg.privateKey\n  ];\n  var concat = buffer.Buffer.concat(sequence);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\n  arg.xprivkey = Buffer.from(xprivkey);\n\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  this._hdPublicKey = null;\n\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\nHDPrivateKey.prototype.toString = function() {\n  return this.xprivkey;\n};\n\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\nHDPrivateKey.prototype.inspect = function() {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\nHDPrivateKey.fromBuffer = function(arg) {\n  return new HDPrivateKey(arg.toString());\n};\n\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\nHDPrivateKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\n\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\n\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\n\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\n\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\n\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\n\nmodule.exports = HDPrivateKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2hkcHJpdmF0ZWtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7O0FBR2IsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjs7QUFFdEMsU0FBUyxtQkFBTyxDQUFDLHNFQUFhO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsNEZBQXdCO0FBQ2xELFdBQVcsbUJBQU8sQ0FBQywwRUFBZTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsb0VBQVk7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBYztBQUN2QyxhQUFhLG1CQUFPLENBQUMsOEVBQWlCOztBQUV0QyxhQUFhLG1CQUFPLENBQUMsc0VBQVU7QUFDL0I7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBZTtBQUN4QyxhQUFhLG1CQUFPLENBQUMsa0VBQVc7O0FBRWhDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQywwRUFBZTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2hkcHJpdmF0ZWtleS5qcz8yMmY5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyICQgPSByZXF1aXJlKCcuL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuXG52YXIgQk4gPSByZXF1aXJlKCcuL2NyeXB0by9ibicpO1xudmFyIEJhc2U1OCA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYmFzZTU4Jyk7XG52YXIgQmFzZTU4Q2hlY2sgPSByZXF1aXJlKCcuL2VuY29kaW5nL2Jhc2U1OGNoZWNrJyk7XG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vY3J5cHRvL2hhc2gnKTtcbnZhciBOZXR3b3JrID0gcmVxdWlyZSgnLi9uZXR3b3JrcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9jcnlwdG8vcG9pbnQnKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRla2V5Jyk7XG52YXIgUmFuZG9tID0gcmVxdWlyZSgnLi9jcnlwdG8vcmFuZG9tJyk7XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGhkRXJyb3JzID0gZXJyb3JzLkhEUHJpdmF0ZUtleTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi91dGlsL2J1ZmZlcicpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9qcycpO1xuXG52YXIgTUlOSU1VTV9FTlRST1BZX0JJVFMgPSAxMjg7XG52YXIgQklUU19UT19CWVRFUyA9IDEgLyA4O1xudmFyIE1BWElNVU1fRU5UUk9QWV9CSVRTID0gNTEyO1xuXG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhbiBoaWVyYXJjaGljYWxseSBkZXJpdmVkIHByaXZhdGUga2V5LlxuICpcbiAqIE1vcmUgaW5mbyBvbiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDMyLm1lZGlhd2lraVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfE9iamVjdH0gYXJnXG4gKi9cbmZ1bmN0aW9uIEhEUHJpdmF0ZUtleShhcmcpIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG4gIGlmIChhcmcgaW5zdGFuY2VvZiBIRFByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIRFByaXZhdGVLZXkpKSB7XG4gICAgcmV0dXJuIG5ldyBIRFByaXZhdGVLZXkoYXJnKTtcbiAgfVxuICBpZiAoIWFyZykge1xuICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVJhbmRvbWx5KCk7XG4gIH1cblxuICBpZiAoTmV0d29yay5nZXQoYXJnKSkge1xuICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVJhbmRvbWx5KGFyZyk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhhcmcpIHx8IEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnKSkge1xuICAgIGlmIChIRFByaXZhdGVLZXkuaXNWYWxpZFNlcmlhbGl6ZWQoYXJnKSkge1xuICAgICAgdGhpcy5fYnVpbGRGcm9tU2VyaWFsaXplZChhcmcpO1xuICAgIH0gZWxzZSBpZiAoSlNVdGlsLmlzVmFsaWRKU09OKGFyZykpIHtcbiAgICAgIHRoaXMuX2J1aWxkRnJvbUpTT04oYXJnKTtcbiAgICB9IGVsc2UgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnKSAmJiBIRFByaXZhdGVLZXkuaXNWYWxpZFNlcmlhbGl6ZWQoYXJnLnRvU3RyaW5nKCkpKSB7XG4gICAgICB0aGlzLl9idWlsZEZyb21TZXJpYWxpemVkKGFyZy50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgSERQcml2YXRlS2V5LmdldFNlcmlhbGl6ZWRFcnJvcihhcmcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KGFyZykpIHtcbiAgICB0aGlzLl9idWlsZEZyb21PYmplY3QoYXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuVW5yZWNvZ25pemVkQXJndW1lbnQoYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgYSBnaXZlbiBwYXRoIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXJnXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBoYXJkZW5lZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuSERQcml2YXRlS2V5LmlzVmFsaWRQYXRoID0gZnVuY3Rpb24oYXJnLCBoYXJkZW5lZCkge1xuICBpZiAoXy5pc1N0cmluZyhhcmcpKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBIRFByaXZhdGVLZXkuX2dldERlcml2YXRpb25JbmRleGVzKGFyZyk7XG4gICAgcmV0dXJuIGluZGV4ZXMgIT09IG51bGwgJiYgXy5ldmVyeShpbmRleGVzLCBIRFByaXZhdGVLZXkuaXNWYWxpZFBhdGgpO1xuICB9XG5cbiAgaWYgKF8uaXNOdW1iZXIoYXJnKSkge1xuICAgIGlmIChhcmcgPCBIRFByaXZhdGVLZXkuSGFyZGVuZWQgJiYgaGFyZGVuZWQgPT09IHRydWUpIHtcbiAgICAgIGFyZyArPSBIRFByaXZhdGVLZXkuSGFyZGVuZWQ7XG4gICAgfVxuICAgIHJldHVybiBhcmcgPj0gMCAmJiBhcmcgPCBIRFByaXZhdGVLZXkuTWF4SW5kZXg7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgc3BsaXRzIGEgc3RyaW5nIHBhdGggaW50byBhIGRlcml2YXRpb24gaW5kZXggYXJyYXkuXG4gKiBJdCB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBzdHJpbmcgcGF0aCBpcyBtYWxmb3JtZWQuXG4gKiBJdCBkb2VzIG5vdCB2YWxpZGF0ZSBpZiBpbmRleGVzIGFyZSBpbiBib3VuZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5IRFByaXZhdGVLZXkuX2dldERlcml2YXRpb25JbmRleGVzID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgc3RlcHMgPSBwYXRoLnNwbGl0KCcvJyk7XG5cbiAgLy8gU3BlY2lhbCBjYXNlczpcbiAgaWYgKF8uaW5jbHVkZXMoSERQcml2YXRlS2V5LlJvb3RFbGVtZW50QWxpYXMsIHBhdGgpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKCFfLmluY2x1ZGVzKEhEUHJpdmF0ZUtleS5Sb290RWxlbWVudEFsaWFzLCBzdGVwc1swXSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpbmRleGVzID0gc3RlcHMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgaXNIYXJkZW5lZCA9IHN0ZXAuc2xpY2UoLTEpID09PSAnXFwnJztcbiAgICBpZiAoaXNIYXJkZW5lZCkge1xuICAgICAgc3RlcCA9IHN0ZXAuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICBpZiAoIXN0ZXAgfHwgc3RlcFswXSA9PT0gJy0nKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSArc3RlcDsgLy8gY2FzdCB0byBudW1iZXJcbiAgICBpZiAoaXNIYXJkZW5lZCkge1xuICAgICAgaW5kZXggKz0gSERQcml2YXRlS2V5LkhhcmRlbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfSk7XG5cbiAgcmV0dXJuIF8uc29tZShpbmRleGVzLCBpc05hTikgPyBudWxsIDogaW5kZXhlcztcbn07XG5cbi8qKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gVXNlIGRlcml2ZUNoaWxkIG9yIGRlcml2ZU5vbkNvbXBsaWFudENoaWxkIGluc3RlYWQuIFRoaXMgaXMgbm90IEJJUDMyIGNvbXBsaWFudFxuICpcbiAqXG4gKiBHZXQgYSBkZXJpdmVkIGNoaWxkIGJhc2VkIG9uIGEgc3RyaW5nIG9yIG51bWJlci5cbiAqXG4gKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIGl0J3MgcGFyc2VkIGFzIHRoZSBmdWxsIHBhdGggb2ZcbiAqIGRlcml2YXRpb24uIFZhbGlkIHZhbHVlcyBmb3IgdGhpcyBhcmd1bWVudCBpbmNsdWRlIFwibVwiICh3aGljaCByZXR1cm5zIHRoZVxuICogc2FtZSBwcml2YXRlIGtleSksIFwibS8wLzEvNDAvMicvMTAwMFwiLCB3aGVyZSB0aGUgJyBxdW90ZSBtZWFucyBhIGhhcmRlbmVkXG4gKiBkZXJpdmF0aW9uLlxuICpcbiAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIG51bWJlciwgdGhlIGNoaWxkIHdpdGggdGhhdCBpbmRleCB3aWxsIGJlXG4gKiBkZXJpdmVkLiBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRydXRoeSwgdGhlIGhhcmRlbmVkIHZlcnNpb24gd2lsbCBiZVxuICogZGVyaXZlZC4gU2VlIHRoZSBleGFtcGxlIHVzYWdlIGZvciBjbGFyaWZpY2F0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFyZW50ID0gbmV3IEhEUHJpdmF0ZUtleSgneHBydi4uLicpO1xuICogdmFyIGNoaWxkXzBfMV8yaCA9IHBhcmVudC5kZXJpdmUoMCkuZGVyaXZlKDEpLmRlcml2ZSgyLCB0cnVlKTtcbiAqIHZhciBjb3B5X29mX2NoaWxkXzBfMV8yaCA9IHBhcmVudC5kZXJpdmUoXCJtLzAvMS8yJ1wiKTtcbiAqIGFzc2VydChjaGlsZF8wXzFfMmgueHByaXZrZXkgPT09IGNvcHlfb2ZfY2hpbGRfMF8xXzJoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXJnXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBoYXJkZW5lZFxuICovXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uKGFyZywgaGFyZGVuZWQpIHtcbiAgcmV0dXJuIHRoaXMuZGVyaXZlTm9uQ29tcGxpYW50Q2hpbGQoYXJnLCBoYXJkZW5lZCk7XG59O1xuXG4vKipcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgbm90IGJlIG9mZmljaWFsbHkgc3VwcG9ydGVkIHVudGlsIHYxLjAuMC5cbiAqXG4gKlxuICogR2V0IGEgZGVyaXZlZCBjaGlsZCBiYXNlZCBvbiBhIHN0cmluZyBvciBudW1iZXIuXG4gKlxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nLCBpdCdzIHBhcnNlZCBhcyB0aGUgZnVsbCBwYXRoIG9mXG4gKiBkZXJpdmF0aW9uLiBWYWxpZCB2YWx1ZXMgZm9yIHRoaXMgYXJndW1lbnQgaW5jbHVkZSBcIm1cIiAod2hpY2ggcmV0dXJucyB0aGVcbiAqIHNhbWUgcHJpdmF0ZSBrZXkpLCBcIm0vMC8xLzQwLzInLzEwMDBcIiwgd2hlcmUgdGhlICcgcXVvdGUgbWVhbnMgYSBoYXJkZW5lZFxuICogZGVyaXZhdGlvbi5cbiAqXG4gKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBudW1iZXIsIHRoZSBjaGlsZCB3aXRoIHRoYXQgaW5kZXggd2lsbCBiZVxuICogZGVyaXZlZC4gSWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyB0cnV0aHksIHRoZSBoYXJkZW5lZCB2ZXJzaW9uIHdpbGwgYmVcbiAqIGRlcml2ZWQuIFNlZSB0aGUgZXhhbXBsZSB1c2FnZSBmb3IgY2xhcmlmaWNhdGlvbi5cbiAqXG4gKiBXQVJOSU5HOiBUaGUgYG5vbkNvbXBsaWFudGAgb3B0aW9uIHNob3VsZCBOT1QgYmUgdXNlZCwgZXhjZXB0IGZvciBvbGRlciBpbXBsZW1lbnRhdGlvblxuICogdGhhdCB1c2VkIGEgZGVyaXZhdGlvbiBzdHJhdGVneSB0aGF0IHVzZWQgYSBub24temVybyBwYWRkZWQgcHJpdmF0ZSBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYXJlbnQgPSBuZXcgSERQcml2YXRlS2V5KCd4cHJ2Li4uJyk7XG4gKiB2YXIgY2hpbGRfMF8xXzJoID0gcGFyZW50LmRlcml2ZUNoaWxkKDApLmRlcml2ZUNoaWxkKDEpLmRlcml2ZUNoaWxkKDIsIHRydWUpO1xuICogdmFyIGNvcHlfb2ZfY2hpbGRfMF8xXzJoID0gcGFyZW50LmRlcml2ZUNoaWxkKFwibS8wLzEvMidcIik7XG4gKiBhc3NlcnQoY2hpbGRfMF8xXzJoLnhwcml2a2V5ID09PSBjb3B5X29mX2NoaWxkXzBfMV8yaCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGFyZ1xuICogQHBhcmFtIHtib29sZWFuP30gaGFyZGVuZWRcbiAqL1xuSERQcml2YXRlS2V5LnByb3RvdHlwZS5kZXJpdmVDaGlsZCA9IGZ1bmN0aW9uKGFyZywgaGFyZGVuZWQpIHtcbiAgaWYgKF8uaXNOdW1iZXIoYXJnKSkge1xuICAgIHJldHVybiB0aGlzLl9kZXJpdmVXaXRoTnVtYmVyKGFyZywgaGFyZGVuZWQpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYXJnKSkge1xuICAgIHJldHVybiB0aGlzLl9kZXJpdmVGcm9tU3RyaW5nKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWREZXJpdmF0aW9uQXJndW1lbnQoYXJnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCB3aWxsIG5vdCBiZSBvZmZpY2lhbGx5IHN1cHBvcnRlZCB1bnRpbCB2MS4wLjBcbiAqXG4gKlxuICogV0FSTklORzogSWYgdGhpcyBpcyBhIG5ldyBpbXBsZW1lbnRhdGlvbiB5b3Ugc2hvdWxkIE5PVCB1c2UgdGhpcyBtZXRob2QsIHlvdSBzaG91bGQgYmUgdXNpbmdcbiAqIGBkZXJpdmVgIGluc3RlYWQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgZXhwbGljaXRseSBmb3IgdXNlIGFuZCBjb21wYXRpYmlsaXR5IHdpdGggYW4gaW1wbGVtZW50YXRpb24gdGhhdFxuICogd2FzIG5vdCBjb21wbGlhbnQgd2l0aCBCSVAzMiByZWdhcmRpbmcgdGhlIGRlcml2YXRpb24gYWxnb3JpdGhtLiBUaGUgcHJpdmF0ZSBrZXlcbiAqIG11c3QgYmUgMzIgYnl0ZXMgaGFzaGluZywgYW5kIHRoaXMgaW1wbGVtZW50YXRpb24gd2lsbCB1c2UgdGhlIG5vbi16ZXJvIHBhZGRlZFxuICogc2VyaWFsaXphdGlvbiBvZiBhIHByaXZhdGUga2V5LCBzdWNoIHRoYXQgaXQncyBzdGlsbCBwb3NzaWJsZSB0byBkZXJpdmUgdGhlIHByaXZhdGVLZXlcbiAqIHRvIHJlY292ZXIgdGhvc2UgZnVuZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBhcmdcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGhhcmRlbmVkXG4gKi9cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuZGVyaXZlTm9uQ29tcGxpYW50Q2hpbGQgPSBmdW5jdGlvbihhcmcsIGhhcmRlbmVkKSB7XG4gIGlmIChfLmlzTnVtYmVyKGFyZykpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVyaXZlV2l0aE51bWJlcihhcmcsIGhhcmRlbmVkLCB0cnVlKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGFyZykpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVyaXZlRnJvbVN0cmluZyhhcmcsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkRGVyaXZhdGlvbkFyZ3VtZW50KGFyZyk7XG4gIH1cbn07XG5cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuX2Rlcml2ZVdpdGhOdW1iZXIgPSBmdW5jdGlvbihpbmRleCwgaGFyZGVuZWQsIG5vbkNvbXBsaWFudCkge1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG4gIGlmICghSERQcml2YXRlS2V5LmlzVmFsaWRQYXRoKGluZGV4LCBoYXJkZW5lZCkpIHtcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuSW52YWxpZFBhdGgoaW5kZXgpO1xuICB9XG5cbiAgaGFyZGVuZWQgPSBpbmRleCA+PSBIRFByaXZhdGVLZXkuSGFyZGVuZWQgPyB0cnVlIDogaGFyZGVuZWQ7XG4gIGlmIChpbmRleCA8IEhEUHJpdmF0ZUtleS5IYXJkZW5lZCAmJiBoYXJkZW5lZCA9PT0gdHJ1ZSkge1xuICAgIGluZGV4ICs9IEhEUHJpdmF0ZUtleS5IYXJkZW5lZDtcbiAgfVxuXG4gIHZhciBpbmRleEJ1ZmZlciA9IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGluZGV4KTtcbiAgdmFyIGRhdGE7XG4gIGlmIChoYXJkZW5lZCAmJiBub25Db21wbGlhbnQpIHtcbiAgICAvLyBUaGUgcHJpdmF0ZSBrZXkgc2VyaWFsaXphdGlvbiBpbiB0aGlzIGNhc2Ugd2lsbCBub3QgYmUgZXhhY3RseSAzMiBieXRlcyBhbmQgY2FuIGJlXG4gICAgLy8gYW55IHZhbHVlIGxlc3MsIGFuZCB0aGUgdmFsdWUgaXMgbm90IHplcm8tcGFkZGVkLlxuICAgIHZhciBub25aZXJvUGFkZGVkID0gdGhpcy5wcml2YXRlS2V5LmJuLnRvQnVmZmVyKCk7XG4gICAgZGF0YSA9IEJ1ZmZlclV0aWwuY29uY2F0KFtCdWZmZXIuZnJvbShbMF0pLCBub25aZXJvUGFkZGVkLCBpbmRleEJ1ZmZlcl0pO1xuICB9IGVsc2UgaWYgKGhhcmRlbmVkKSB7XG4gICAgLy8gVGhpcyB3aWxsIHVzZSBhIDMyIGJ5dGUgemVybyBwYWRkZWQgc2VyaWFsaXphdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXlcbiAgICB2YXIgcHJpdmF0ZUtleUJ1ZmZlciA9IHRoaXMucHJpdmF0ZUtleS5ibi50b0J1ZmZlcih7c2l6ZTogMzJ9KTtcbiAgICBhc3NlcnQocHJpdmF0ZUtleUJ1ZmZlci5sZW5ndGggPT09IDMyLCAnbGVuZ3RoIG9mIHByaXZhdGUga2V5IGJ1ZmZlciBpcyBleHBlY3RlZCB0byBiZSAzMiBieXRlcycpO1xuICAgIGRhdGEgPSBCdWZmZXJVdGlsLmNvbmNhdChbQnVmZmVyLmZyb20oWzBdKSwgcHJpdmF0ZUtleUJ1ZmZlciwgaW5kZXhCdWZmZXJdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gQnVmZmVyVXRpbC5jb25jYXQoW3RoaXMucHVibGljS2V5LnRvQnVmZmVyKCksIGluZGV4QnVmZmVyXSk7XG4gIH1cbiAgdmFyIGhhc2ggPSBIYXNoLnNoYTUxMmhtYWMoZGF0YSwgdGhpcy5fYnVmZmVycy5jaGFpbkNvZGUpO1xuICB2YXIgbGVmdFBhcnQgPSBCTi5mcm9tQnVmZmVyKGhhc2guc2xpY2UoMCwgMzIpLCB7XG4gICAgc2l6ZTogMzJcbiAgfSk7XG4gIHZhciBjaGFpbkNvZGUgPSBoYXNoLnNsaWNlKDMyLCA2NCk7XG5cbiAgdmFyIHByaXZhdGVLZXkgPSBsZWZ0UGFydC5hZGQodGhpcy5wcml2YXRlS2V5LnRvQmlnTnVtYmVyKCkpLnVtb2QoUG9pbnQuZ2V0TigpKS50b0J1ZmZlcih7XG4gICAgc2l6ZTogMzJcbiAgfSk7XG5cbiAgaWYgKCFQcml2YXRlS2V5LmlzVmFsaWQocHJpdmF0ZUtleSkpIHtcbiAgICAvLyBJbmRleCBhdCB0aGlzIHBvaW50IGlzIGFscmVhZHkgaGFyZGVuZWQsIHdlIGNhbiBwYXNzIG51bGwgYXMgdGhlIGhhcmRlbmVkIGFyZ1xuICAgIHJldHVybiB0aGlzLl9kZXJpdmVXaXRoTnVtYmVyKGluZGV4ICsgMSwgbnVsbCwgbm9uQ29tcGxpYW50KTtcbiAgfVxuXG4gIHZhciBkZXJpdmVkID0gbmV3IEhEUHJpdmF0ZUtleSh7XG4gICAgbmV0d29yazogdGhpcy5uZXR3b3JrLFxuICAgIGRlcHRoOiB0aGlzLmRlcHRoICsgMSxcbiAgICBwYXJlbnRGaW5nZXJQcmludDogdGhpcy5maW5nZXJQcmludCxcbiAgICBjaGlsZEluZGV4OiBpbmRleCxcbiAgICBjaGFpbkNvZGU6IGNoYWluQ29kZSxcbiAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5XG4gIH0pO1xuXG4gIHJldHVybiBkZXJpdmVkO1xufTtcblxuSERQcml2YXRlS2V5LnByb3RvdHlwZS5fZGVyaXZlRnJvbVN0cmluZyA9IGZ1bmN0aW9uKHBhdGgsIG5vbkNvbXBsaWFudCkge1xuICBpZiAoIUhEUHJpdmF0ZUtleS5pc1ZhbGlkUGF0aChwYXRoKSkge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkUGF0aChwYXRoKTtcbiAgfVxuXG4gIHZhciBpbmRleGVzID0gSERQcml2YXRlS2V5Ll9nZXREZXJpdmF0aW9uSW5kZXhlcyhwYXRoKTtcbiAgdmFyIGRlcml2ZWQgPSBpbmRleGVzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBpbmRleCkge1xuICAgIHJldHVybiBwcmV2Ll9kZXJpdmVXaXRoTnVtYmVyKGluZGV4LCBudWxsLCBub25Db21wbGlhbnQpO1xuICB9LCB0aGlzKTtcblxuICByZXR1cm4gZGVyaXZlZDtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBhIGdpdmVuIHNlcmlhbGl6ZWQgcHJpdmF0ZSBrZXkgaW4gYmFzZTU4IHdpdGggY2hlY2tzdW0gZm9ybWF0XG4gKiBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGRhdGEgLSB0aGUgc2VyaWFsaXplZCBwcml2YXRlIGtleVxuICogQHBhcmFtIHtzdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBvcHRpb25hbCwgaWYgcHJlc2VudCwgY2hlY2tzIHRoYXQgdGhlXG4gKiAgICAgbmV0d29yayBwcm92aWRlZCBtYXRjaGVzIHRoZSBuZXR3b3JrIHNlcmlhbGl6ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5IRFByaXZhdGVLZXkuaXNWYWxpZFNlcmlhbGl6ZWQgPSBmdW5jdGlvbihkYXRhLCBuZXR3b3JrKSB7XG4gIHJldHVybiAhSERQcml2YXRlS2V5LmdldFNlcmlhbGl6ZWRFcnJvcihkYXRhLCBuZXR3b3JrKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoYXQncyB0aGUgZXJyb3IgdGhhdCBjYXVzZXMgdGhlIHZhbGlkYXRpb24gb2YgYSBzZXJpYWxpemVkIHByaXZhdGUga2V5XG4gKiBpbiBiYXNlNTggd2l0aCBjaGVja3N1bSB0byBmYWlsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSAtIHRoZSBzZXJpYWxpemVkIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xOZXR3b3JrPX0gbmV0d29yayAtIG9wdGlvbmFsLCBpZiBwcmVzZW50LCBjaGVja3MgdGhhdCB0aGVcbiAqICAgICBuZXR3b3JrIHByb3ZpZGVkIG1hdGNoZXMgdGhlIG5ldHdvcmsgc2VyaWFsaXplZC5cbiAqIEByZXR1cm4ge2Vycm9ycy5JbnZhbGlkQXJndW1lbnR8bnVsbH1cbiAqL1xuSERQcml2YXRlS2V5LmdldFNlcmlhbGl6ZWRFcnJvciA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmspIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG4gIGlmICghKF8uaXNTdHJpbmcoZGF0YSkgfHwgQnVmZmVyVXRpbC5pc0J1ZmZlcihkYXRhKSkpIHtcbiAgICByZXR1cm4gbmV3IGhkRXJyb3JzLlVucmVjb2duaXplZEFyZ3VtZW50KCdFeHBlY3RlZCBzdHJpbmcgb3IgYnVmZmVyJyk7XG4gIH1cbiAgaWYgKCFCYXNlNTgudmFsaWRDaGFyYWN0ZXJzKGRhdGEpKSB7XG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuSW52YWxpZEI1OENoYXIoJyh1bmtub3duKScsIGRhdGEpO1xuICB9XG4gIHRyeSB7XG4gICAgZGF0YSA9IEJhc2U1OENoZWNrLmRlY29kZShkYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWRCNThDaGVja3N1bShkYXRhKTtcbiAgfVxuICBpZiAoZGF0YS5sZW5ndGggIT09IEhEUHJpdmF0ZUtleS5EYXRhTGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBoZEVycm9ycy5JbnZhbGlkTGVuZ3RoKGRhdGEpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChuZXR3b3JrKSkge1xuICAgIHZhciBlcnJvciA9IEhEUHJpdmF0ZUtleS5fdmFsaWRhdGVOZXR3b3JrKGRhdGEsIG5ldHdvcmspO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbkhEUHJpdmF0ZUtleS5fdmFsaWRhdGVOZXR3b3JrID0gZnVuY3Rpb24oZGF0YSwgbmV0d29ya0FyZykge1xuICB2YXIgbmV0d29yayA9IE5ldHdvcmsuZ2V0KG5ldHdvcmtBcmcpO1xuICBpZiAoIW5ldHdvcmspIHtcbiAgICByZXR1cm4gbmV3IGVycm9ycy5JbnZhbGlkTmV0d29ya0FyZ3VtZW50KG5ldHdvcmtBcmcpO1xuICB9XG4gIHZhciB2ZXJzaW9uID0gZGF0YS5zbGljZSgwLCA0KTtcbiAgaWYgKEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodmVyc2lvbikgIT09IG5ldHdvcmsueHByaXZrZXkpIHtcbiAgICByZXR1cm4gbmV3IGVycm9ycy5JbnZhbGlkTmV0d29yayh2ZXJzaW9uKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbkhEUHJpdmF0ZUtleS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oYXJnKSB7XG4gICQuY2hlY2tBcmd1bWVudChfLmlzU3RyaW5nKGFyZyksICdObyB2YWxpZCBzdHJpbmcgd2FzIHByb3ZpZGVkJyk7XG4gIHJldHVybiBuZXcgSERQcml2YXRlS2V5KGFyZyk7XG59O1xuXG5IRFByaXZhdGVLZXkuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGFyZykge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc09iamVjdChhcmcpLCAnTm8gdmFsaWQgYXJndW1lbnQgd2FzIHByb3ZpZGVkJyk7XG4gIHJldHVybiBuZXcgSERQcml2YXRlS2V5KGFyZyk7XG59O1xuXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLl9idWlsZEZyb21KU09OID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0aGlzLl9idWlsZEZyb21PYmplY3QoSlNPTi5wYXJzZShhcmcpKTtcbn07XG5cbkhEUHJpdmF0ZUtleS5wcm90b3R5cGUuX2J1aWxkRnJvbU9iamVjdCA9IGZ1bmN0aW9uKGFyZykge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTIgKi9cbiAgLy8gVE9ETzogVHlwZSB2YWxpZGF0aW9uXG4gIHZhciBidWZmZXJzID0ge1xuICAgIHZlcnNpb246IGFyZy5uZXR3b3JrID8gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoTmV0d29yay5nZXQoYXJnLm5ldHdvcmspLnhwcml2a2V5KSA6IGFyZy52ZXJzaW9uLFxuICAgIGRlcHRoOiBfLmlzTnVtYmVyKGFyZy5kZXB0aCkgPyBCdWZmZXJVdGlsLmludGVnZXJBc1NpbmdsZUJ5dGVCdWZmZXIoYXJnLmRlcHRoKSA6IGFyZy5kZXB0aCxcbiAgICBwYXJlbnRGaW5nZXJQcmludDogXy5pc051bWJlcihhcmcucGFyZW50RmluZ2VyUHJpbnQpID8gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoYXJnLnBhcmVudEZpbmdlclByaW50KSA6IGFyZy5wYXJlbnRGaW5nZXJQcmludCxcbiAgICBjaGlsZEluZGV4OiBfLmlzTnVtYmVyKGFyZy5jaGlsZEluZGV4KSA/IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGFyZy5jaGlsZEluZGV4KSA6IGFyZy5jaGlsZEluZGV4LFxuICAgIGNoYWluQ29kZTogXy5pc1N0cmluZyhhcmcuY2hhaW5Db2RlKSA/IEJ1ZmZlci5mcm9tKGFyZy5jaGFpbkNvZGUsJ2hleCcpIDogYXJnLmNoYWluQ29kZSxcbiAgICBwcml2YXRlS2V5OiAoXy5pc1N0cmluZyhhcmcucHJpdmF0ZUtleSkgJiYgSlNVdGlsLmlzSGV4YShhcmcucHJpdmF0ZUtleSkpID8gQnVmZmVyLmZyb20oYXJnLnByaXZhdGVLZXksJ2hleCcpIDogYXJnLnByaXZhdGVLZXksXG4gICAgY2hlY2tzdW06IGFyZy5jaGVja3N1bSA/IChhcmcuY2hlY2tzdW0ubGVuZ3RoID8gYXJnLmNoZWNrc3VtIDogQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoYXJnLmNoZWNrc3VtKSkgOiB1bmRlZmluZWRcbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbUJ1ZmZlcnMoYnVmZmVycyk7XG59O1xuXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLl9idWlsZEZyb21TZXJpYWxpemVkID0gZnVuY3Rpb24oYXJnKSB7XG4gIHZhciBkZWNvZGVkID0gQmFzZTU4Q2hlY2suZGVjb2RlKGFyZyk7XG4gIHZhciBidWZmZXJzID0ge1xuICAgIHZlcnNpb246IGRlY29kZWQuc2xpY2UoSERQcml2YXRlS2V5LlZlcnNpb25TdGFydCwgSERQcml2YXRlS2V5LlZlcnNpb25FbmQpLFxuICAgIGRlcHRoOiBkZWNvZGVkLnNsaWNlKEhEUHJpdmF0ZUtleS5EZXB0aFN0YXJ0LCBIRFByaXZhdGVLZXkuRGVwdGhFbmQpLFxuICAgIHBhcmVudEZpbmdlclByaW50OiBkZWNvZGVkLnNsaWNlKEhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludFN0YXJ0LFxuICAgICAgSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50RW5kKSxcbiAgICBjaGlsZEluZGV4OiBkZWNvZGVkLnNsaWNlKEhEUHJpdmF0ZUtleS5DaGlsZEluZGV4U3RhcnQsIEhEUHJpdmF0ZUtleS5DaGlsZEluZGV4RW5kKSxcbiAgICBjaGFpbkNvZGU6IGRlY29kZWQuc2xpY2UoSERQcml2YXRlS2V5LkNoYWluQ29kZVN0YXJ0LCBIRFByaXZhdGVLZXkuQ2hhaW5Db2RlRW5kKSxcbiAgICBwcml2YXRlS2V5OiBkZWNvZGVkLnNsaWNlKEhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5U3RhcnQsIEhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5RW5kKSxcbiAgICBjaGVja3N1bTogZGVjb2RlZC5zbGljZShIRFByaXZhdGVLZXkuQ2hlY2tzdW1TdGFydCwgSERQcml2YXRlS2V5LkNoZWNrc3VtRW5kKSxcbiAgICB4cHJpdmtleTogYXJnXG4gIH07XG4gIHJldHVybiB0aGlzLl9idWlsZEZyb21CdWZmZXJzKGJ1ZmZlcnMpO1xufTtcblxuSERQcml2YXRlS2V5LnByb3RvdHlwZS5fZ2VuZXJhdGVSYW5kb21seSA9IGZ1bmN0aW9uKG5ldHdvcmspIHtcbiAgcmV0dXJuIEhEUHJpdmF0ZUtleS5mcm9tU2VlZChSYW5kb20uZ2V0UmFuZG9tQnVmZmVyKDY0KSwgbmV0d29yayk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcHJpdmF0ZSBrZXkgZnJvbSBhIHNlZWQsIGFzIGRlc2NyaWJlZCBpbiBCSVAzMlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gaGV4YVxuICogQHBhcmFtIHsqfSBuZXR3b3JrXG4gKiBAcmV0dXJuIEhEUHJpdmF0ZUtleVxuICovXG5IRFByaXZhdGVLZXkuZnJvbVNlZWQgPSBmdW5jdGlvbihoZXhhLCBuZXR3b3JrKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG4gIGlmIChKU1V0aWwuaXNIZXhhU3RyaW5nKGhleGEpKSB7XG4gICAgaGV4YSA9IEJ1ZmZlci5mcm9tKGhleGEsICdoZXgnKTtcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihoZXhhKSkge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkRW50cm9weUFyZ3VtZW50KGhleGEpO1xuICB9XG4gIGlmIChoZXhhLmxlbmd0aCA8IE1JTklNVU1fRU5UUk9QWV9CSVRTICogQklUU19UT19CWVRFUykge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkRW50cm9weUFyZ3VtZW50Lk5vdEVub3VnaEVudHJvcHkoaGV4YSk7XG4gIH1cbiAgaWYgKGhleGEubGVuZ3RoID4gTUFYSU1VTV9FTlRST1BZX0JJVFMgKiBCSVRTX1RPX0JZVEVTKSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRFbnRyb3B5QXJndW1lbnQuVG9vTXVjaEVudHJvcHkoaGV4YSk7XG4gIH1cbiAgY29uc3QgaGFzaCA9IEhhc2guc2hhNTEyaG1hYyhoZXhhLCBCdWZmZXIuZnJvbSgnQml0Y29pbiBzZWVkJykpO1xuXG4gIHJldHVybiBuZXcgSERQcml2YXRlS2V5KHtcbiAgICBuZXR3b3JrOiBOZXR3b3JrLmdldChuZXR3b3JrKSB8fCBOZXR3b3JrLmRlZmF1bHROZXR3b3JrLFxuICAgIGRlcHRoOiAwLFxuICAgIHBhcmVudEZpbmdlclByaW50OiAwLFxuICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgcHJpdmF0ZUtleTogaGFzaC5zbGljZSgwLCAzMiksXG4gICAgY2hhaW5Db2RlOiBoYXNoLnNsaWNlKDMyLCA2NClcbiAgfSk7XG59O1xuXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLl9jYWxjSERQdWJsaWNLZXkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9oZFB1YmxpY0tleSkge1xuICAgIHZhciBIRFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vaGRwdWJsaWNrZXknKTtcbiAgICB0aGlzLl9oZFB1YmxpY0tleSA9IG5ldyBIRFB1YmxpY0tleSh0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWNlaXZlcyBhIG9iamVjdCB3aXRoIGJ1ZmZlcnMgaW4gYWxsIHRoZSBwcm9wZXJ0aWVzIGFuZCBwb3B1bGF0ZXMgdGhlXG4gKiBpbnRlcm5hbCBzdHJ1Y3R1cmVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy52ZXJzaW9uXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5kZXB0aFxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcucGFyZW50RmluZ2VyUHJpbnRcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmNoaWxkSW5kZXhcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmNoYWluQ29kZVxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcucHJpdmF0ZUtleVxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcuY2hlY2tzdW1cbiAqIEBwYXJhbSB7c3RyaW5nPX0gYXJnLnhwcml2a2V5IC0gaWYgc2V0LCBkb24ndCByZWNhbGN1bGF0ZSB0aGUgYmFzZTU4XG4gKiAgICAgIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtIRFByaXZhdGVLZXl9IHRoaXNcbiAqL1xuSERQcml2YXRlS2V5LnByb3RvdHlwZS5fYnVpbGRGcm9tQnVmZmVycyA9IGZ1bmN0aW9uKGFyZykge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogOCAqL1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cblxuICBIRFByaXZhdGVLZXkuX3ZhbGlkYXRlQnVmZmVyQXJndW1lbnRzKGFyZyk7XG5cbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XG4gICAgX2J1ZmZlcnM6IGFyZ1xuICB9KTtcblxuICB2YXIgc2VxdWVuY2UgPSBbXG4gICAgYXJnLnZlcnNpb24sIGFyZy5kZXB0aCwgYXJnLnBhcmVudEZpbmdlclByaW50LCBhcmcuY2hpbGRJbmRleCwgYXJnLmNoYWluQ29kZSxcbiAgICBCdWZmZXJVdGlsLmVtcHR5QnVmZmVyKDEpLCBhcmcucHJpdmF0ZUtleVxuICBdO1xuICB2YXIgY29uY2F0ID0gYnVmZmVyLkJ1ZmZlci5jb25jYXQoc2VxdWVuY2UpO1xuICBpZiAoIWFyZy5jaGVja3N1bSB8fCAhYXJnLmNoZWNrc3VtLmxlbmd0aCkge1xuICAgIGFyZy5jaGVja3N1bSA9IEJhc2U1OENoZWNrLmNoZWNrc3VtKGNvbmNhdCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFyZy5jaGVja3N1bS50b1N0cmluZygpICE9PSBCYXNlNThDaGVjay5jaGVja3N1bShjb25jYXQpLnRvU3RyaW5nKCkpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEI1OENoZWNrc3VtKGNvbmNhdCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ldHdvcmsgPSBOZXR3b3JrLmdldChCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKGFyZy52ZXJzaW9uKSk7XG4gIHZhciB4cHJpdmtleTtcbiAgeHByaXZrZXkgPSBCYXNlNThDaGVjay5lbmNvZGUoYnVmZmVyLkJ1ZmZlci5jb25jYXQoc2VxdWVuY2UpKTtcbiAgYXJnLnhwcml2a2V5ID0gQnVmZmVyLmZyb20oeHByaXZrZXkpO1xuXG4gIHZhciBwcml2YXRlS2V5ID0gbmV3IFByaXZhdGVLZXkoQk4uZnJvbUJ1ZmZlcihhcmcucHJpdmF0ZUtleSksIG5ldHdvcmspO1xuICB2YXIgcHVibGljS2V5ID0gcHJpdmF0ZUtleS50b1B1YmxpY0tleSgpO1xuICB2YXIgc2l6ZSA9IEhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludFNpemU7XG4gIHZhciBmaW5nZXJQcmludCA9IEhhc2guc2hhMjU2cmlwZW1kMTYwKHB1YmxpY0tleS50b0J1ZmZlcigpKS5zbGljZSgwLCBzaXplKTtcblxuICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKHRoaXMsIHtcbiAgICB4cHJpdmtleTogeHByaXZrZXksXG4gICAgbmV0d29yazogbmV0d29yayxcbiAgICBkZXB0aDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbVNpbmdsZUJ5dGVCdWZmZXIoYXJnLmRlcHRoKSxcbiAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxuICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgIGZpbmdlclByaW50OiBmaW5nZXJQcmludFxuICB9KTtcblxuICB0aGlzLl9oZFB1YmxpY0tleSA9IG51bGw7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoZFB1YmxpY0tleScsIHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NhbGNIRFB1YmxpY0tleSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX2hkUHVibGljS2V5O1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAneHB1YmtleScsIHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NhbGNIRFB1YmxpY0tleSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX2hkUHVibGljS2V5LnhwdWJrZXk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5IRFByaXZhdGVLZXkuX3ZhbGlkYXRlQnVmZmVyQXJndW1lbnRzID0gZnVuY3Rpb24oYXJnKSB7XG4gIHZhciBjaGVja0J1ZmZlciA9IGZ1bmN0aW9uKG5hbWUsIHNpemUpIHtcbiAgICB2YXIgYnVmZiA9IGFyZ1tuYW1lXTtcbiAgICBhc3NlcnQoQnVmZmVyVXRpbC5pc0J1ZmZlcihidWZmKSwgbmFtZSArICcgYXJndW1lbnQgaXMgbm90IGEgYnVmZmVyJyk7XG4gICAgYXNzZXJ0KFxuICAgICAgYnVmZi5sZW5ndGggPT09IHNpemUsXG4gICAgICBuYW1lICsgJyBoYXMgbm90IHRoZSBleHBlY3RlZCBzaXplOiBmb3VuZCAnICsgYnVmZi5sZW5ndGggKyAnLCBleHBlY3RlZCAnICsgc2l6ZVxuICAgICk7XG4gIH07XG4gIGNoZWNrQnVmZmVyKCd2ZXJzaW9uJywgSERQcml2YXRlS2V5LlZlcnNpb25TaXplKTtcbiAgY2hlY2tCdWZmZXIoJ2RlcHRoJywgSERQcml2YXRlS2V5LkRlcHRoU2l6ZSk7XG4gIGNoZWNrQnVmZmVyKCdwYXJlbnRGaW5nZXJQcmludCcsIEhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludFNpemUpO1xuICBjaGVja0J1ZmZlcignY2hpbGRJbmRleCcsIEhEUHJpdmF0ZUtleS5DaGlsZEluZGV4U2l6ZSk7XG4gIGNoZWNrQnVmZmVyKCdjaGFpbkNvZGUnLCBIRFByaXZhdGVLZXkuQ2hhaW5Db2RlU2l6ZSk7XG4gIGNoZWNrQnVmZmVyKCdwcml2YXRlS2V5JywgSERQcml2YXRlS2V5LlByaXZhdGVLZXlTaXplKTtcbiAgaWYgKGFyZy5jaGVja3N1bSAmJiBhcmcuY2hlY2tzdW0ubGVuZ3RoKSB7XG4gICAgY2hlY2tCdWZmZXIoJ2NoZWNrc3VtJywgSERQcml2YXRlS2V5LkNoZWNrU3VtU2l6ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcHJpdmF0ZSBrZXkgKGEgc3RyaW5nIHN0YXJ0aW5nXG4gKiB3aXRoIFwieHBydi4uLlwiXG4gKlxuICogQHJldHVybiBzdHJpbmdcbiAqL1xuSERQcml2YXRlS2V5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54cHJpdmtleTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29uc29sZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV4dGVuZGVkIHByaXZhdGUga2V5LlxuICogQHJldHVybiBzdHJpbmdcbiAqL1xuSERQcml2YXRlS2V5LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPEhEUHJpdmF0ZUtleTogJyArIHRoaXMueHByaXZrZXkgKyAnPic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCBhIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcHJpdmF0ZSBrZXkuXG4gKlxuICogRmllbGRzIGluY2x1ZGU6PHVsPlxuICogPGxpPiBuZXR3b3JrOiBlaXRoZXIgJ2xpdmVuZXQnIG9yICd0ZXN0bmV0J1xuICogPGxpPiBkZXB0aDogYSBudW1iZXIgcmFuZ2luZyBmcm9tIDAgdG8gMjU1XG4gKiA8bGk+IGZpbmdlclByaW50OiBhIG51bWJlciByYW5naW5nIGZyb20gMCB0byAyXjMyLTEsIHRha2VuIGZyb20gdGhlIGhhc2ggb2YgdGhlXG4gKiA8bGk+ICAgICBhc3NvY2lhdGVkIHB1YmxpYyBrZXlcbiAqIDxsaT4gcGFyZW50RmluZ2VyUHJpbnQ6IGEgbnVtYmVyIHJhbmdpbmcgZnJvbSAwIHRvIDJeMzItMSwgdGFrZW4gZnJvbSB0aGUgaGFzaFxuICogPGxpPiAgICAgb2YgdGhpcyBwYXJlbnQncyBhc3NvY2lhdGVkIHB1YmxpYyBrZXkgb3IgemVyby5cbiAqIDxsaT4gY2hpbGRJbmRleDogdGhlIGluZGV4IGZyb20gd2hpY2ggdGhpcyBjaGlsZCB3YXMgZGVyaXZlZCAob3IgemVybylcbiAqIDxsaT4gY2hhaW5Db2RlOiBhbiBoZXhhIHN0cmluZyByZXByZXNlbnRpbmcgYSBudW1iZXIgdXNlZCBpbiB0aGUgZGVyaXZhdGlvblxuICogPGxpPiBwcml2YXRlS2V5OiB0aGUgcHJpdmF0ZSBrZXkgYXNzb2NpYXRlZCwgaW4gaGV4YSByZXByZXNlbnRhdGlvblxuICogPGxpPiB4cHJpdmtleTogdGhlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaW4gY2hlY2tzdW1cbiAqIDxsaT4gICAgIGJhc2U1OCBmb3JtYXRcbiAqIDxsaT4gY2hlY2tzdW06IHRoZSBiYXNlNTggY2hlY2tzdW0gb2YgeHByaXZrZXlcbiAqIDwvdWw+XG4gKiAgQHJldHVybiB7T2JqZWN0fVxuICovXG5IRFByaXZhdGVLZXkucHJvdG90eXBlLnRvT2JqZWN0ID0gSERQcml2YXRlS2V5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBuZXR3b3JrOiBOZXR3b3JrLmdldChCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuX2J1ZmZlcnMudmVyc2lvbiksICd4cHJpdmtleScpLm5hbWUsXG4gICAgZGVwdGg6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21TaW5nbGVCeXRlQnVmZmVyKHRoaXMuX2J1ZmZlcnMuZGVwdGgpLFxuICAgIGZpbmdlclByaW50OiBCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuZmluZ2VyUHJpbnQpLFxuICAgIHBhcmVudEZpbmdlclByaW50OiBCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuX2J1ZmZlcnMucGFyZW50RmluZ2VyUHJpbnQpLFxuICAgIGNoaWxkSW5kZXg6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy5jaGlsZEluZGV4KSxcbiAgICBjaGFpbkNvZGU6IEJ1ZmZlclV0aWwuYnVmZmVyVG9IZXgodGhpcy5fYnVmZmVycy5jaGFpbkNvZGUpLFxuICAgIHByaXZhdGVLZXk6IHRoaXMucHJpdmF0ZUtleS50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICBjaGVja3N1bTogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih0aGlzLl9idWZmZXJzLmNoZWNrc3VtKSxcbiAgICB4cHJpdmtleTogdGhpcy54cHJpdmtleVxuICB9O1xufTtcblxuLyoqXG4gKiBCdWlsZCBhIEhEUHJpdmF0ZUtleSBmcm9tIGEgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFyZ1xuICogQHJldHVybiB7SERQcml2YXRlS2V5fVxuICovXG5IRFByaXZhdGVLZXkuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gbmV3IEhEUHJpdmF0ZUtleShhcmcudG9TdHJpbmcoKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIEhEUHJpdmF0ZUtleVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuSERQcml2YXRlS2V5LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQnVmZmVyVXRpbC5jb3B5KHRoaXMuX2J1ZmZlcnMueHByaXZrZXkpO1xufTtcblxuSERQcml2YXRlS2V5LkRlZmF1bHREZXB0aCA9IDA7XG5IRFByaXZhdGVLZXkuRGVmYXVsdEZpbmdlcnByaW50ID0gMDtcbkhEUHJpdmF0ZUtleS5EZWZhdWx0Q2hpbGRJbmRleCA9IDA7XG5IRFByaXZhdGVLZXkuSGFyZGVuZWQgPSAweDgwMDAwMDAwO1xuSERQcml2YXRlS2V5Lk1heEluZGV4ID0gMiAqIEhEUHJpdmF0ZUtleS5IYXJkZW5lZDtcblxuSERQcml2YXRlS2V5LlJvb3RFbGVtZW50QWxpYXMgPSBbJ20nLCAnTScsICdtXFwnJywgJ01cXCcnXTtcblxuSERQcml2YXRlS2V5LlZlcnNpb25TaXplID0gNDtcbkhEUHJpdmF0ZUtleS5EZXB0aFNpemUgPSAxO1xuSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50U2l6ZSA9IDQ7XG5IRFByaXZhdGVLZXkuQ2hpbGRJbmRleFNpemUgPSA0O1xuSERQcml2YXRlS2V5LkNoYWluQ29kZVNpemUgPSAzMjtcbkhEUHJpdmF0ZUtleS5Qcml2YXRlS2V5U2l6ZSA9IDMyO1xuSERQcml2YXRlS2V5LkNoZWNrU3VtU2l6ZSA9IDQ7XG5cbkhEUHJpdmF0ZUtleS5EYXRhTGVuZ3RoID0gNzg7XG5IRFByaXZhdGVLZXkuU2VyaWFsaXplZEJ5dGVTaXplID0gODI7XG5cbkhEUHJpdmF0ZUtleS5WZXJzaW9uU3RhcnQgPSAwO1xuSERQcml2YXRlS2V5LlZlcnNpb25FbmQgPSBIRFByaXZhdGVLZXkuVmVyc2lvblN0YXJ0ICsgSERQcml2YXRlS2V5LlZlcnNpb25TaXplO1xuSERQcml2YXRlS2V5LkRlcHRoU3RhcnQgPSBIRFByaXZhdGVLZXkuVmVyc2lvbkVuZDtcbkhEUHJpdmF0ZUtleS5EZXB0aEVuZCA9IEhEUHJpdmF0ZUtleS5EZXB0aFN0YXJ0ICsgSERQcml2YXRlS2V5LkRlcHRoU2l6ZTtcbkhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludFN0YXJ0ID0gSERQcml2YXRlS2V5LkRlcHRoRW5kO1xuSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50RW5kID0gSERQcml2YXRlS2V5LlBhcmVudEZpbmdlclByaW50U3RhcnQgKyBIRFByaXZhdGVLZXkuUGFyZW50RmluZ2VyUHJpbnRTaXplO1xuSERQcml2YXRlS2V5LkNoaWxkSW5kZXhTdGFydCA9IEhEUHJpdmF0ZUtleS5QYXJlbnRGaW5nZXJQcmludEVuZDtcbkhEUHJpdmF0ZUtleS5DaGlsZEluZGV4RW5kID0gSERQcml2YXRlS2V5LkNoaWxkSW5kZXhTdGFydCArIEhEUHJpdmF0ZUtleS5DaGlsZEluZGV4U2l6ZTtcbkhEUHJpdmF0ZUtleS5DaGFpbkNvZGVTdGFydCA9IEhEUHJpdmF0ZUtleS5DaGlsZEluZGV4RW5kO1xuSERQcml2YXRlS2V5LkNoYWluQ29kZUVuZCA9IEhEUHJpdmF0ZUtleS5DaGFpbkNvZGVTdGFydCArIEhEUHJpdmF0ZUtleS5DaGFpbkNvZGVTaXplO1xuSERQcml2YXRlS2V5LlByaXZhdGVLZXlTdGFydCA9IEhEUHJpdmF0ZUtleS5DaGFpbkNvZGVFbmQgKyAxO1xuSERQcml2YXRlS2V5LlByaXZhdGVLZXlFbmQgPSBIRFByaXZhdGVLZXkuUHJpdmF0ZUtleVN0YXJ0ICsgSERQcml2YXRlS2V5LlByaXZhdGVLZXlTaXplO1xuSERQcml2YXRlS2V5LkNoZWNrc3VtU3RhcnQgPSBIRFByaXZhdGVLZXkuUHJpdmF0ZUtleUVuZDtcbkhEUHJpdmF0ZUtleS5DaGVja3N1bUVuZCA9IEhEUHJpdmF0ZUtleS5DaGVja3N1bVN0YXJ0ICsgSERQcml2YXRlS2V5LkNoZWNrU3VtU2l6ZTtcblxuYXNzZXJ0KEhEUHJpdmF0ZUtleS5DaGVja3N1bUVuZCA9PT0gSERQcml2YXRlS2V5LlNlcmlhbGl6ZWRCeXRlU2l6ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSERQcml2YXRlS2V5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/hdprivatekey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/hdpublickey.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/hdpublickey.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar Base58 = __webpack_require__(/*! ./encoding/base58 */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58.js\");\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar HDPrivateKey = __webpack_require__(/*! ./hdprivatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/hdprivatekey.js\");\nvar Network = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar Point = __webpack_require__(/*! ./crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\n\nvar bitcoreErrors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\n\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\nHDPublicKey.isValidPath = function(arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.derive = function(arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function(index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});\n  var chainCode = hash.slice(32, 64);\n\n  var publicKey;\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function(path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPublicKey.isValidSerialized = function(data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\nHDPublicKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n  return null;\n};\n\nHDPublicKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey,'hex') :\n      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,\n                                     HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\nHDPublicKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    arg.publicKey\n  ];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n\n  var publicKey = new PublicKey(arg.publicKey, {network: network});\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\nHDPublicKey.prototype.toString = function() {\n  return this.xpubkey;\n};\n\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\nHDPublicKey.prototype.inspect = function() {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\nHDPublicKey.fromBuffer = function(arg) {\n  return new HDPublicKey(arg);\n};\n\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\nHDPublicKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\n\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\n\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\n\nHDPublicKey.VersionStart           = 0;\nHDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart             = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\n\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\n\nmodule.exports = HDPublicKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL2hkcHVibGlja2V5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMsd0ZBQXNCOztBQUV0QyxTQUFTLG1CQUFPLENBQUMsc0VBQWE7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLGtGQUFtQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDbEQsV0FBVyxtQkFBTyxDQUFDLDBFQUFlO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFnQjtBQUMzQyxjQUFjLG1CQUFPLENBQUMsb0VBQVk7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBYTs7QUFFckMsb0JBQW9CLG1CQUFPLENBQUMsc0VBQVU7QUFDdEM7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFN0IsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFlOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvaGRwdWJsaWNrZXkuanM/NTM4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbnZhciBCTiA9IHJlcXVpcmUoJy4vY3J5cHRvL2JuJyk7XG52YXIgQmFzZTU4ID0gcmVxdWlyZSgnLi9lbmNvZGluZy9iYXNlNTgnKTtcbnZhciBCYXNlNThDaGVjayA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYmFzZTU4Y2hlY2snKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9jcnlwdG8vaGFzaCcpO1xudmFyIEhEUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vaGRwcml2YXRla2V5Jyk7XG52YXIgTmV0d29yayA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vY3J5cHRvL3BvaW50Jyk7XG52YXIgUHVibGljS2V5ID0gcmVxdWlyZSgnLi9wdWJsaWNrZXknKTtcblxudmFyIGJpdGNvcmVFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGVycm9ycyA9IGJpdGNvcmVFcnJvcnM7XG52YXIgaGRFcnJvcnMgPSBiaXRjb3JlRXJyb3JzLkhEUHVibGljS2V5O1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9idWZmZXInKTtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gaGllcmFyY2hpY2FsbHkgZGVyaXZlZCBwdWJsaWMga2V5LlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDMyLm1lZGlhd2lraVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfEJ1ZmZlcn0gYXJnXG4gKi9cbmZ1bmN0aW9uIEhEUHVibGljS2V5KGFyZykge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTIgKi9cbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDIwICovXG4gIGlmIChhcmcgaW5zdGFuY2VvZiBIRFB1YmxpY0tleSkge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhEUHVibGljS2V5KSkge1xuICAgIHJldHVybiBuZXcgSERQdWJsaWNLZXkoYXJnKTtcbiAgfVxuICBpZiAoYXJnKSB7XG4gICAgaWYgKF8uaXNTdHJpbmcoYXJnKSB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZykpIHtcbiAgICAgIHZhciBlcnJvciA9IEhEUHVibGljS2V5LmdldFNlcmlhbGl6ZWRFcnJvcihhcmcpO1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRGcm9tU2VyaWFsaXplZChhcmcpO1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZykgJiYgIUhEUHVibGljS2V5LmdldFNlcmlhbGl6ZWRFcnJvcihhcmcudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbVNlcmlhbGl6ZWQoYXJnLnRvU3RyaW5nKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgaGRFcnJvcnMuQXJndW1lbnRJc1ByaXZhdGVFeHRlbmRlZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSERQcml2YXRlS2V5KGFyZykuaGRQdWJsaWNLZXk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfLmlzT2JqZWN0KGFyZykpIHtcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEhEUHJpdmF0ZUtleSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZEZyb21Qcml2YXRlKGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbU9iamVjdChhcmcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgaGRFcnJvcnMuVW5yZWNvZ25pemVkQXJndW1lbnQoYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLk11c3RTdXBwbHlBcmd1bWVudCgpO1xuICB9XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBhIGdpdmVuIHBhdGggaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBhcmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkhEUHVibGljS2V5LmlzVmFsaWRQYXRoID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmIChfLmlzU3RyaW5nKGFyZykpIHtcbiAgICB2YXIgaW5kZXhlcyA9IEhEUHJpdmF0ZUtleS5fZ2V0RGVyaXZhdGlvbkluZGV4ZXMoYXJnKTtcbiAgICByZXR1cm4gaW5kZXhlcyAhPT0gbnVsbCAmJiBfLmV2ZXJ5KGluZGV4ZXMsIEhEUHVibGljS2V5LmlzVmFsaWRQYXRoKTtcbiAgfVxuXG4gIGlmIChfLmlzTnVtYmVyKGFyZykpIHtcbiAgICByZXR1cm4gYXJnID49IDAgJiYgYXJnIDwgSERQdWJsaWNLZXkuSGFyZGVuZWQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIFVzZSBkZXJpdmVDaGlsZCBpbnN0ZWFkLlxuICpcbiAqXG4gKiBHZXQgYSBkZXJpdmF0ZWQgY2hpbGQgYmFzZWQgb24gYSBzdHJpbmcgb3IgbnVtYmVyLlxuICpcbiAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgaXQncyBwYXJzZWQgYXMgdGhlIGZ1bGwgcGF0aCBvZlxuICogZGVyaXZhdGlvbi4gVmFsaWQgdmFsdWVzIGZvciB0aGlzIGFyZ3VtZW50IGluY2x1ZGUgXCJtXCIgKHdoaWNoIHJldHVybnMgdGhlXG4gKiBzYW1lIHB1YmxpYyBrZXkpLCBcIm0vMC8xLzQwLzIvMTAwMFwiLlxuICpcbiAqIE5vdGUgdGhhdCBoYXJkZW5lZCBrZXlzIGNhbid0IGJlIGRlcml2ZWQgZnJvbSBhIHB1YmxpYyBleHRlbmRlZCBrZXkuXG4gKlxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgbnVtYmVyLCB0aGUgY2hpbGQgd2l0aCB0aGF0IGluZGV4IHdpbGwgYmVcbiAqIGRlcml2ZWQuIFNlZSB0aGUgZXhhbXBsZSB1c2FnZSBmb3IgY2xhcmlmaWNhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBhcmVudCA9IG5ldyBIRFB1YmxpY0tleSgneHB1Yi4uLicpO1xuICogdmFyIGNoaWxkXzBfMV8yID0gcGFyZW50LmRlcml2ZSgwKS5kZXJpdmUoMSkuZGVyaXZlKDIpO1xuICogdmFyIGNvcHlfb2ZfY2hpbGRfMF8xXzIgPSBwYXJlbnQuZGVyaXZlKFwibS8wLzEvMlwiKTtcbiAqIGFzc2VydChjaGlsZF8wXzFfMi54cHJpdmtleSA9PT0gY29weV9vZl9jaGlsZF8wXzFfMik7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGFyZ1xuICovXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24oYXJnLCBoYXJkZW5lZCkge1xuICByZXR1cm4gdGhpcy5kZXJpdmVDaGlsZChhcmcsIGhhcmRlbmVkKTtcbn07XG5cbi8qKlxuICogV0FSTklORzogVGhpcyBtZXRob2Qgd2lsbCBub3QgYmUgb2ZmaWNpYWxseSBzdXBwb3J0ZWQgdW50aWwgdjEuMC4wLlxuICpcbiAqXG4gKiBHZXQgYSBkZXJpdmF0ZWQgY2hpbGQgYmFzZWQgb24gYSBzdHJpbmcgb3IgbnVtYmVyLlxuICpcbiAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgaXQncyBwYXJzZWQgYXMgdGhlIGZ1bGwgcGF0aCBvZlxuICogZGVyaXZhdGlvbi4gVmFsaWQgdmFsdWVzIGZvciB0aGlzIGFyZ3VtZW50IGluY2x1ZGUgXCJtXCIgKHdoaWNoIHJldHVybnMgdGhlXG4gKiBzYW1lIHB1YmxpYyBrZXkpLCBcIm0vMC8xLzQwLzIvMTAwMFwiLlxuICpcbiAqIE5vdGUgdGhhdCBoYXJkZW5lZCBrZXlzIGNhbid0IGJlIGRlcml2ZWQgZnJvbSBhIHB1YmxpYyBleHRlbmRlZCBrZXkuXG4gKlxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgbnVtYmVyLCB0aGUgY2hpbGQgd2l0aCB0aGF0IGluZGV4IHdpbGwgYmVcbiAqIGRlcml2ZWQuIFNlZSB0aGUgZXhhbXBsZSB1c2FnZSBmb3IgY2xhcmlmaWNhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBhcmVudCA9IG5ldyBIRFB1YmxpY0tleSgneHB1Yi4uLicpO1xuICogdmFyIGNoaWxkXzBfMV8yID0gcGFyZW50LmRlcml2ZUNoaWxkKDApLmRlcml2ZUNoaWxkKDEpLmRlcml2ZUNoaWxkKDIpO1xuICogdmFyIGNvcHlfb2ZfY2hpbGRfMF8xXzIgPSBwYXJlbnQuZGVyaXZlQ2hpbGQoXCJtLzAvMS8yXCIpO1xuICogYXNzZXJ0KGNoaWxkXzBfMV8yLnhwcml2a2V5ID09PSBjb3B5X29mX2NoaWxkXzBfMV8yKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXJnXG4gKi9cbkhEUHVibGljS2V5LnByb3RvdHlwZS5kZXJpdmVDaGlsZCA9IGZ1bmN0aW9uKGFyZywgaGFyZGVuZWQpIHtcbiAgaWYgKF8uaXNOdW1iZXIoYXJnKSkge1xuICAgIHJldHVybiB0aGlzLl9kZXJpdmVXaXRoTnVtYmVyKGFyZywgaGFyZGVuZWQpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYXJnKSkge1xuICAgIHJldHVybiB0aGlzLl9kZXJpdmVGcm9tU3RyaW5nKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWREZXJpdmF0aW9uQXJndW1lbnQoYXJnKTtcbiAgfVxufTtcblxuSERQdWJsaWNLZXkucHJvdG90eXBlLl9kZXJpdmVXaXRoTnVtYmVyID0gZnVuY3Rpb24oaW5kZXgsIGhhcmRlbmVkKSB7XG4gIGlmIChpbmRleCA+PSBIRFB1YmxpY0tleS5IYXJkZW5lZCB8fCBoYXJkZW5lZCkge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkSW5kZXhDYW50RGVyaXZlSGFyZGVuZWQoKTtcbiAgfVxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGhkRXJyb3JzLkludmFsaWRQYXRoKGluZGV4KTtcbiAgfVxuXG4gIHZhciBpbmRleEJ1ZmZlciA9IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGluZGV4KTtcbiAgdmFyIGRhdGEgPSBCdWZmZXJVdGlsLmNvbmNhdChbdGhpcy5wdWJsaWNLZXkudG9CdWZmZXIoKSwgaW5kZXhCdWZmZXJdKTtcbiAgdmFyIGhhc2ggPSBIYXNoLnNoYTUxMmhtYWMoZGF0YSwgdGhpcy5fYnVmZmVycy5jaGFpbkNvZGUpO1xuICB2YXIgbGVmdFBhcnQgPSBCTi5mcm9tQnVmZmVyKGhhc2guc2xpY2UoMCwgMzIpLCB7c2l6ZTogMzJ9KTtcbiAgdmFyIGNoYWluQ29kZSA9IGhhc2guc2xpY2UoMzIsIDY0KTtcblxuICB2YXIgcHVibGljS2V5O1xuICB0cnkge1xuICAgIHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tUG9pbnQoUG9pbnQuZ2V0RygpLm11bChsZWZ0UGFydCkuYWRkKHRoaXMucHVibGljS2V5LnBvaW50KSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVyaXZlV2l0aE51bWJlcihpbmRleCArIDEpO1xuICB9XG5cbiAgdmFyIGRlcml2ZWQgPSBuZXcgSERQdWJsaWNLZXkoe1xuICAgIG5ldHdvcms6IHRoaXMubmV0d29yayxcbiAgICBkZXB0aDogdGhpcy5kZXB0aCArIDEsXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IHRoaXMuZmluZ2VyUHJpbnQsXG4gICAgY2hpbGRJbmRleDogaW5kZXgsXG4gICAgY2hhaW5Db2RlOiBjaGFpbkNvZGUsXG4gICAgcHVibGljS2V5OiBwdWJsaWNLZXlcbiAgfSk7XG5cbiAgcmV0dXJuIGRlcml2ZWQ7XG59O1xuXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuX2Rlcml2ZUZyb21TdHJpbmcgPSBmdW5jdGlvbihwYXRoKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG4gIGlmIChfLmluY2x1ZGVzKHBhdGgsIFwiJ1wiKSkge1xuICAgIHRocm93IG5ldyBoZEVycm9ycy5JbnZhbGlkSW5kZXhDYW50RGVyaXZlSGFyZGVuZWQoKTtcbiAgfSBlbHNlIGlmICghSERQdWJsaWNLZXkuaXNWYWxpZFBhdGgocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgaGRFcnJvcnMuSW52YWxpZFBhdGgocGF0aCk7XG4gIH1cblxuICB2YXIgaW5kZXhlcyA9IEhEUHJpdmF0ZUtleS5fZ2V0RGVyaXZhdGlvbkluZGV4ZXMocGF0aCk7XG4gIHZhciBkZXJpdmVkID0gaW5kZXhlcy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgaW5kZXgpIHtcbiAgICByZXR1cm4gcHJldi5fZGVyaXZlV2l0aE51bWJlcihpbmRleCk7XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiBkZXJpdmVkO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGEgZ2l2ZW4gc2VyaWFsaXplZCBwdWJsaWMga2V5IGluIGJhc2U1OCB3aXRoIGNoZWNrc3VtIGZvcm1hdFxuICogaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIC0gdGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleVxuICogQHBhcmFtIHtzdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBvcHRpb25hbCwgaWYgcHJlc2VudCwgY2hlY2tzIHRoYXQgdGhlXG4gKiAgICAgbmV0d29yayBwcm92aWRlZCBtYXRjaGVzIHRoZSBuZXR3b3JrIHNlcmlhbGl6ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5IRFB1YmxpY0tleS5pc1ZhbGlkU2VyaWFsaXplZCA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmspIHtcbiAgcmV0dXJuIF8uaXNOdWxsKEhEUHVibGljS2V5LmdldFNlcmlhbGl6ZWRFcnJvcihkYXRhLCBuZXR3b3JrKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGF0J3MgdGhlIGVycm9yIHRoYXQgY2F1c2VzIHRoZSB2YWxpZGF0aW9uIG9mIGEgc2VyaWFsaXplZCBwdWJsaWMga2V5XG4gKiBpbiBiYXNlNTggd2l0aCBjaGVja3N1bSB0byBmYWlsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSAtIHRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfE5ldHdvcms9fSBuZXR3b3JrIC0gb3B0aW9uYWwsIGlmIHByZXNlbnQsIGNoZWNrcyB0aGF0IHRoZVxuICogICAgIG5ldHdvcmsgcHJvdmlkZWQgbWF0Y2hlcyB0aGUgbmV0d29yayBzZXJpYWxpemVkLlxuICogQHJldHVybiB7ZXJyb3JzfG51bGx9XG4gKi9cbkhEUHVibGljS2V5LmdldFNlcmlhbGl6ZWRFcnJvciA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmspIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xuICBpZiAoIShfLmlzU3RyaW5nKGRhdGEpIHx8IEJ1ZmZlclV0aWwuaXNCdWZmZXIoZGF0YSkpKSB7XG4gICAgcmV0dXJuIG5ldyBoZEVycm9ycy5VbnJlY29nbml6ZWRBcmd1bWVudCgnZXhwZWN0ZWQgYnVmZmVyIG9yIHN0cmluZycpO1xuICB9XG4gIGlmICghQmFzZTU4LnZhbGlkQ2hhcmFjdGVycyhkYXRhKSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWRCNThDaGFyKCcodW5rbm93biknLCBkYXRhKTtcbiAgfVxuICB0cnkge1xuICAgIGRhdGEgPSBCYXNlNThDaGVjay5kZWNvZGUoZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbmV3IGVycm9ycy5JbnZhbGlkQjU4Q2hlY2tzdW0oZGF0YSk7XG4gIH1cbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBIRFB1YmxpY0tleS5EYXRhU2l6ZSkge1xuICAgIHJldHVybiBuZXcgaGRFcnJvcnMuSW52YWxpZExlbmd0aChkYXRhKTtcbiAgfVxuICBpZiAoIV8uaXNVbmRlZmluZWQobmV0d29yaykpIHtcbiAgICB2YXIgZXJyb3IgPSBIRFB1YmxpY0tleS5fdmFsaWRhdGVOZXR3b3JrKGRhdGEsIG5ldHdvcmspO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfVxuICB2YXIgdmVyc2lvbiA9IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIoZGF0YS5zbGljZSgwLCA0KSk7XG4gIGlmICh2ZXJzaW9uID09PSBOZXR3b3JrLmxpdmVuZXQueHByaXZrZXkgfHwgdmVyc2lvbiA9PT0gTmV0d29yay50ZXN0bmV0Lnhwcml2a2V5ICkge1xuICAgIHJldHVybiBuZXcgaGRFcnJvcnMuQXJndW1lbnRJc1ByaXZhdGVFeHRlbmRlZCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuSERQdWJsaWNLZXkuX3ZhbGlkYXRlTmV0d29yayA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmtBcmcpIHtcbiAgdmFyIG5ldHdvcmsgPSBOZXR3b3JrLmdldChuZXR3b3JrQXJnKTtcbiAgaWYgKCFuZXR3b3JrKSB7XG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuSW52YWxpZE5ldHdvcmtBcmd1bWVudChuZXR3b3JrQXJnKTtcbiAgfVxuICB2YXIgdmVyc2lvbiA9IGRhdGEuc2xpY2UoSERQdWJsaWNLZXkuVmVyc2lvblN0YXJ0LCBIRFB1YmxpY0tleS5WZXJzaW9uRW5kKTtcbiAgaWYgKEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodmVyc2lvbikgIT09IG5ldHdvcmsueHB1YmtleSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLkludmFsaWROZXR3b3JrKHZlcnNpb24pO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuSERQdWJsaWNLZXkucHJvdG90eXBlLl9idWlsZEZyb21Qcml2YXRlID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgYXJncyA9IF8uY2xvbmUoYXJnLl9idWZmZXJzKTtcbiAgdmFyIHBvaW50ID0gUG9pbnQuZ2V0RygpLm11bChCTi5mcm9tQnVmZmVyKGFyZ3MucHJpdmF0ZUtleSkpO1xuICBhcmdzLnB1YmxpY0tleSA9IFBvaW50LnBvaW50VG9Db21wcmVzc2VkKHBvaW50KTtcbiAgYXJncy52ZXJzaW9uID0gQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoTmV0d29yay5nZXQoQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcihhcmdzLnZlcnNpb24pKS54cHVia2V5KTtcbiAgYXJncy5wcml2YXRlS2V5ID0gdW5kZWZpbmVkO1xuICBhcmdzLmNoZWNrc3VtID0gdW5kZWZpbmVkO1xuICBhcmdzLnhwcml2a2V5ID0gdW5kZWZpbmVkO1xuICByZXR1cm4gdGhpcy5fYnVpbGRGcm9tQnVmZmVycyhhcmdzKTtcbn07XG5cbkhEUHVibGljS2V5LnByb3RvdHlwZS5fYnVpbGRGcm9tT2JqZWN0ID0gZnVuY3Rpb24oYXJnKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMCAqL1xuICAvLyBUT0RPOiBUeXBlIHZhbGlkYXRpb25cbiAgdmFyIGJ1ZmZlcnMgPSB7XG4gICAgdmVyc2lvbjogYXJnLm5ldHdvcmsgPyBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihOZXR3b3JrLmdldChhcmcubmV0d29yaykueHB1YmtleSkgOiBhcmcudmVyc2lvbixcbiAgICBkZXB0aDogXy5pc051bWJlcihhcmcuZGVwdGgpID8gQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKGFyZy5kZXB0aCkgOiBhcmcuZGVwdGgsXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IF8uaXNOdW1iZXIoYXJnLnBhcmVudEZpbmdlclByaW50KSA/IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGFyZy5wYXJlbnRGaW5nZXJQcmludCkgOiBhcmcucGFyZW50RmluZ2VyUHJpbnQsXG4gICAgY2hpbGRJbmRleDogXy5pc051bWJlcihhcmcuY2hpbGRJbmRleCkgPyBCdWZmZXJVdGlsLmludGVnZXJBc0J1ZmZlcihhcmcuY2hpbGRJbmRleCkgOiBhcmcuY2hpbGRJbmRleCxcbiAgICBjaGFpbkNvZGU6IF8uaXNTdHJpbmcoYXJnLmNoYWluQ29kZSkgPyBCdWZmZXIuZnJvbShhcmcuY2hhaW5Db2RlLCdoZXgnKSA6IGFyZy5jaGFpbkNvZGUsXG4gICAgcHVibGljS2V5OiBfLmlzU3RyaW5nKGFyZy5wdWJsaWNLZXkpID8gQnVmZmVyLmZyb20oYXJnLnB1YmxpY0tleSwnaGV4JykgOlxuICAgICAgQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcucHVibGljS2V5KSA/IGFyZy5wdWJsaWNLZXkgOiBhcmcucHVibGljS2V5LnRvQnVmZmVyKCksXG4gICAgY2hlY2tzdW06IF8uaXNOdW1iZXIoYXJnLmNoZWNrc3VtKSA/IEJ1ZmZlclV0aWwuaW50ZWdlckFzQnVmZmVyKGFyZy5jaGVja3N1bSkgOiBhcmcuY2hlY2tzdW1cbiAgfTtcbiAgcmV0dXJuIHRoaXMuX2J1aWxkRnJvbUJ1ZmZlcnMoYnVmZmVycyk7XG59O1xuXG5IRFB1YmxpY0tleS5wcm90b3R5cGUuX2J1aWxkRnJvbVNlcmlhbGl6ZWQgPSBmdW5jdGlvbihhcmcpIHtcbiAgdmFyIGRlY29kZWQgPSBCYXNlNThDaGVjay5kZWNvZGUoYXJnKTtcbiAgdmFyIGJ1ZmZlcnMgPSB7XG4gICAgdmVyc2lvbjogZGVjb2RlZC5zbGljZShIRFB1YmxpY0tleS5WZXJzaW9uU3RhcnQsIEhEUHVibGljS2V5LlZlcnNpb25FbmQpLFxuICAgIGRlcHRoOiBkZWNvZGVkLnNsaWNlKEhEUHVibGljS2V5LkRlcHRoU3RhcnQsIEhEUHVibGljS2V5LkRlcHRoRW5kKSxcbiAgICBwYXJlbnRGaW5nZXJQcmludDogZGVjb2RlZC5zbGljZShIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50RW5kKSxcbiAgICBjaGlsZEluZGV4OiBkZWNvZGVkLnNsaWNlKEhEUHVibGljS2V5LkNoaWxkSW5kZXhTdGFydCwgSERQdWJsaWNLZXkuQ2hpbGRJbmRleEVuZCksXG4gICAgY2hhaW5Db2RlOiBkZWNvZGVkLnNsaWNlKEhEUHVibGljS2V5LkNoYWluQ29kZVN0YXJ0LCBIRFB1YmxpY0tleS5DaGFpbkNvZGVFbmQpLFxuICAgIHB1YmxpY0tleTogZGVjb2RlZC5zbGljZShIRFB1YmxpY0tleS5QdWJsaWNLZXlTdGFydCwgSERQdWJsaWNLZXkuUHVibGljS2V5RW5kKSxcbiAgICBjaGVja3N1bTogZGVjb2RlZC5zbGljZShIRFB1YmxpY0tleS5DaGVja3N1bVN0YXJ0LCBIRFB1YmxpY0tleS5DaGVja3N1bUVuZCksXG4gICAgeHB1YmtleTogYXJnXG4gIH07XG4gIHJldHVybiB0aGlzLl9idWlsZEZyb21CdWZmZXJzKGJ1ZmZlcnMpO1xufTtcblxuLyoqXG4gKiBSZWNlaXZlcyBhIG9iamVjdCB3aXRoIGJ1ZmZlcnMgaW4gYWxsIHRoZSBwcm9wZXJ0aWVzIGFuZCBwb3B1bGF0ZXMgdGhlXG4gKiBpbnRlcm5hbCBzdHJ1Y3R1cmVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy52ZXJzaW9uXG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5kZXB0aFxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcucGFyZW50RmluZ2VyUHJpbnRcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmNoaWxkSW5kZXhcbiAqIEBwYXJhbSB7YnVmZmVyLkJ1ZmZlcn0gYXJnLmNoYWluQ29kZVxuICogQHBhcmFtIHtidWZmZXIuQnVmZmVyfSBhcmcucHVibGljS2V5XG4gKiBAcGFyYW0ge2J1ZmZlci5CdWZmZXJ9IGFyZy5jaGVja3N1bVxuICogQHBhcmFtIHtzdHJpbmc9fSBhcmcueHB1YmtleSAtIGlmIHNldCwgZG9uJ3QgcmVjYWxjdWxhdGUgdGhlIGJhc2U1OFxuICogICAgICByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7SERQdWJsaWNLZXl9IHRoaXNcbiAqL1xuSERQdWJsaWNLZXkucHJvdG90eXBlLl9idWlsZEZyb21CdWZmZXJzID0gZnVuY3Rpb24oYXJnKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyMCAqL1xuXG4gIEhEUHVibGljS2V5Ll92YWxpZGF0ZUJ1ZmZlckFyZ3VtZW50cyhhcmcpO1xuXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xuICAgIF9idWZmZXJzOiBhcmdcbiAgfSk7XG5cbiAgdmFyIHNlcXVlbmNlID0gW1xuICAgIGFyZy52ZXJzaW9uLCBhcmcuZGVwdGgsIGFyZy5wYXJlbnRGaW5nZXJQcmludCwgYXJnLmNoaWxkSW5kZXgsIGFyZy5jaGFpbkNvZGUsXG4gICAgYXJnLnB1YmxpY0tleVxuICBdO1xuICB2YXIgY29uY2F0ID0gQnVmZmVyVXRpbC5jb25jYXQoc2VxdWVuY2UpO1xuICB2YXIgY2hlY2tzdW0gPSBCYXNlNThDaGVjay5jaGVja3N1bShjb25jYXQpO1xuICBpZiAoIWFyZy5jaGVja3N1bSB8fCAhYXJnLmNoZWNrc3VtLmxlbmd0aCkge1xuICAgIGFyZy5jaGVja3N1bSA9IGNoZWNrc3VtO1xuICB9IGVsc2Uge1xuICAgIGlmIChhcmcuY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpICE9PSBjaGVja3N1bS50b1N0cmluZygnaGV4JykpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEI1OENoZWNrc3VtKGNvbmNhdCwgY2hlY2tzdW0pO1xuICAgIH1cbiAgfVxuICB2YXIgbmV0d29yayA9IE5ldHdvcmsuZ2V0KEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIoYXJnLnZlcnNpb24pKTtcblxuICB2YXIgeHB1YmtleTtcbiAgeHB1YmtleSA9IEJhc2U1OENoZWNrLmVuY29kZShCdWZmZXJVdGlsLmNvbmNhdChzZXF1ZW5jZSkpO1xuICBhcmcueHB1YmtleSA9IEJ1ZmZlci5mcm9tKHhwdWJrZXkpO1xuXG4gIHZhciBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGFyZy5wdWJsaWNLZXksIHtuZXR3b3JrOiBuZXR3b3JrfSk7XG4gIHZhciBzaXplID0gSERQdWJsaWNLZXkuUGFyZW50RmluZ2VyUHJpbnRTaXplO1xuICB2YXIgZmluZ2VyUHJpbnQgPSBIYXNoLnNoYTI1NnJpcGVtZDE2MChwdWJsaWNLZXkudG9CdWZmZXIoKSkuc2xpY2UoMCwgc2l6ZSk7XG5cbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XG4gICAgeHB1YmtleTogeHB1YmtleSxcbiAgICBuZXR3b3JrOiBuZXR3b3JrLFxuICAgIGRlcHRoOiBCdWZmZXJVdGlsLmludGVnZXJGcm9tU2luZ2xlQnl0ZUJ1ZmZlcihhcmcuZGVwdGgpLFxuICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgIGZpbmdlclByaW50OiBmaW5nZXJQcmludFxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkhEUHVibGljS2V5Ll92YWxpZGF0ZUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKGFyZykge1xuICB2YXIgY2hlY2tCdWZmZXIgPSBmdW5jdGlvbihuYW1lLCBzaXplKSB7XG4gICAgdmFyIGJ1ZmYgPSBhcmdbbmFtZV07XG4gICAgYXNzZXJ0KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmZiksIG5hbWUgKyAnIGFyZ3VtZW50IGlzIG5vdCBhIGJ1ZmZlciwgaXRcXCdzICcgKyB0eXBlb2YgYnVmZik7XG4gICAgYXNzZXJ0KFxuICAgICAgYnVmZi5sZW5ndGggPT09IHNpemUsXG4gICAgICBuYW1lICsgJyBoYXMgbm90IHRoZSBleHBlY3RlZCBzaXplOiBmb3VuZCAnICsgYnVmZi5sZW5ndGggKyAnLCBleHBlY3RlZCAnICsgc2l6ZVxuICAgICk7XG4gIH07XG4gIGNoZWNrQnVmZmVyKCd2ZXJzaW9uJywgSERQdWJsaWNLZXkuVmVyc2lvblNpemUpO1xuICBjaGVja0J1ZmZlcignZGVwdGgnLCBIRFB1YmxpY0tleS5EZXB0aFNpemUpO1xuICBjaGVja0J1ZmZlcigncGFyZW50RmluZ2VyUHJpbnQnLCBIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludFNpemUpO1xuICBjaGVja0J1ZmZlcignY2hpbGRJbmRleCcsIEhEUHVibGljS2V5LkNoaWxkSW5kZXhTaXplKTtcbiAgY2hlY2tCdWZmZXIoJ2NoYWluQ29kZScsIEhEUHVibGljS2V5LkNoYWluQ29kZVNpemUpO1xuICBjaGVja0J1ZmZlcigncHVibGljS2V5JywgSERQdWJsaWNLZXkuUHVibGljS2V5U2l6ZSk7XG4gIGlmIChhcmcuY2hlY2tzdW0gJiYgYXJnLmNoZWNrc3VtLmxlbmd0aCkge1xuICAgIGNoZWNrQnVmZmVyKCdjaGVja3N1bScsIEhEUHVibGljS2V5LkNoZWNrU3VtU2l6ZSk7XG4gIH1cbn07XG5cbkhEUHVibGljS2V5LmZyb21TdHJpbmcgPSBmdW5jdGlvbihhcmcpIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcoYXJnKSwgJ05vIHZhbGlkIHN0cmluZyB3YXMgcHJvdmlkZWQnKTtcbiAgcmV0dXJuIG5ldyBIRFB1YmxpY0tleShhcmcpO1xufTtcblxuSERQdWJsaWNLZXkuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGFyZykge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc09iamVjdChhcmcpLCAnTm8gdmFsaWQgYXJndW1lbnQgd2FzIHByb3ZpZGVkJyk7XG4gIHJldHVybiBuZXcgSERQdWJsaWNLZXkoYXJnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZTU4IGNoZWNrZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAqIEByZXR1cm4ge3N0cmluZ30gYSBzdHJpbmcgc3RhcnRpbmcgd2l0aCBcInhwdWIuLi5cIiBpbiBsaXZlbmV0XG4gKi9cbkhEUHVibGljS2V5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54cHVia2V5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb25zb2xlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXh0ZW5kZWQgcHVibGljIGtleS5cbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cbkhEUHVibGljS2V5LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPEhEUHVibGljS2V5OiAnICsgdGhpcy54cHVia2V5ICsgJz4nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiB0byByZWNvbnN0cnVjdCBhIGtleS5cbiAqXG4gKiBGaWVsZHMgYXJlOiA8dWw+XG4gKiAgPGxpPiBuZXR3b3JrOiAnbGl2ZW5ldCcgb3IgJ3Rlc3RuZXQnXG4gKiAgPGxpPiBkZXB0aDogYSBudW1iZXIgZnJvbSAwIHRvIDI1NSwgdGhlIGRlcHRoIHRvIHRoZSBtYXN0ZXIgZXh0ZW5kZWQga2V5XG4gKiAgPGxpPiBmaW5nZXJQcmludDogYSBudW1iZXIgb2YgMzIgYml0cyB0YWtlbiBmcm9tIHRoZSBoYXNoIG9mIHRoZSBwdWJsaWMga2V5XG4gKiAgPGxpPiBmaW5nZXJQcmludDogYSBudW1iZXIgb2YgMzIgYml0cyB0YWtlbiBmcm9tIHRoZSBoYXNoIG9mIHRoaXMga2V5J3NcbiAqICA8bGk+ICAgICBwYXJlbnQncyBwdWJsaWMga2V5XG4gKiAgPGxpPiBjaGlsZEluZGV4OiBpbmRleCB3aXRoIHdoaWNoIHRoaXMga2V5IHdhcyBkZXJpdmVkXG4gKiAgPGxpPiBjaGFpbkNvZGU6IHN0cmluZyBpbiBoZXhhIGVuY29kaW5nIHVzZWQgZm9yIGRlcml2YXRpb25cbiAqICA8bGk+IHB1YmxpY0tleTogc3RyaW5nLCBoZXhhIGVuY29kZWQsIGluIGNvbXByZXNzZWQga2V5IGZvcm1hdFxuICogIDxsaT4gY2hlY2tzdW06IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy5jaGVja3N1bSksXG4gKiAgPGxpPiB4cHVia2V5OiB0aGUgc3RyaW5nIHdpdGggdGhlIGJhc2U1OCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV4dGVuZGVkIGtleVxuICogIDxsaT4gY2hlY2tzdW06IHRoZSBiYXNlNTggY2hlY2tzdW0gb2YgeHB1YmtleVxuICogPC91bD5cbiAqL1xuSERQdWJsaWNLZXkucHJvdG90eXBlLnRvT2JqZWN0ID0gSERQdWJsaWNLZXkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIG5ldHdvcms6IE5ldHdvcmsuZ2V0KEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy52ZXJzaW9uKSkubmFtZSxcbiAgICBkZXB0aDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbVNpbmdsZUJ5dGVCdWZmZXIodGhpcy5fYnVmZmVycy5kZXB0aCksXG4gICAgZmluZ2VyUHJpbnQ6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5maW5nZXJQcmludCksXG4gICAgcGFyZW50RmluZ2VyUHJpbnQ6IEJ1ZmZlclV0aWwuaW50ZWdlckZyb21CdWZmZXIodGhpcy5fYnVmZmVycy5wYXJlbnRGaW5nZXJQcmludCksXG4gICAgY2hpbGRJbmRleDogQnVmZmVyVXRpbC5pbnRlZ2VyRnJvbUJ1ZmZlcih0aGlzLl9idWZmZXJzLmNoaWxkSW5kZXgpLFxuICAgIGNoYWluQ29kZTogQnVmZmVyVXRpbC5idWZmZXJUb0hleCh0aGlzLl9idWZmZXJzLmNoYWluQ29kZSksXG4gICAgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleS50b1N0cmluZygpLFxuICAgIGNoZWNrc3VtOiBCdWZmZXJVdGlsLmludGVnZXJGcm9tQnVmZmVyKHRoaXMuX2J1ZmZlcnMuY2hlY2tzdW0pLFxuICAgIHhwdWJrZXk6IHRoaXMueHB1YmtleVxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBIRFB1YmxpY0tleSBmcm9tIGEgYnVmZmVyIGFyZ3VtZW50XG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFyZ1xuICogQHJldHVybiB7SERQdWJsaWNLZXl9XG4gKi9cbkhEUHVibGljS2V5LmZyb21CdWZmZXIgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIG5ldyBIRFB1YmxpY0tleShhcmcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHhwdWJrZXlcbiAqXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbkhEUHVibGljS2V5LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQnVmZmVyVXRpbC5jb3B5KHRoaXMuX2J1ZmZlcnMueHB1YmtleSk7XG59O1xuXG5IRFB1YmxpY0tleS5IYXJkZW5lZCA9IDB4ODAwMDAwMDA7XG5IRFB1YmxpY0tleS5Sb290RWxlbWVudEFsaWFzID0gWydtJywgJ00nXTtcblxuSERQdWJsaWNLZXkuVmVyc2lvblNpemUgPSA0O1xuSERQdWJsaWNLZXkuRGVwdGhTaXplID0gMTtcbkhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50U2l6ZSA9IDQ7XG5IRFB1YmxpY0tleS5DaGlsZEluZGV4U2l6ZSA9IDQ7XG5IRFB1YmxpY0tleS5DaGFpbkNvZGVTaXplID0gMzI7XG5IRFB1YmxpY0tleS5QdWJsaWNLZXlTaXplID0gMzM7XG5IRFB1YmxpY0tleS5DaGVja1N1bVNpemUgPSA0O1xuXG5IRFB1YmxpY0tleS5EYXRhU2l6ZSA9IDc4O1xuSERQdWJsaWNLZXkuU2VyaWFsaXplZEJ5dGVTaXplID0gODI7XG5cbkhEUHVibGljS2V5LlZlcnNpb25TdGFydCAgICAgICAgICAgPSAwO1xuSERQdWJsaWNLZXkuVmVyc2lvbkVuZCAgICAgICAgICAgICA9IEhEUHVibGljS2V5LlZlcnNpb25TdGFydCArIEhEUHVibGljS2V5LlZlcnNpb25TaXplO1xuSERQdWJsaWNLZXkuRGVwdGhTdGFydCAgICAgICAgICAgICA9IEhEUHVibGljS2V5LlZlcnNpb25FbmQ7XG5IRFB1YmxpY0tleS5EZXB0aEVuZCAgICAgICAgICAgICAgID0gSERQdWJsaWNLZXkuRGVwdGhTdGFydCArIEhEUHVibGljS2V5LkRlcHRoU2l6ZTtcbkhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50U3RhcnQgPSBIRFB1YmxpY0tleS5EZXB0aEVuZDtcbkhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50RW5kICAgPSBIRFB1YmxpY0tleS5QYXJlbnRGaW5nZXJQcmludFN0YXJ0ICsgSERQdWJsaWNLZXkuUGFyZW50RmluZ2VyUHJpbnRTaXplO1xuSERQdWJsaWNLZXkuQ2hpbGRJbmRleFN0YXJ0ICAgICAgICA9IEhEUHVibGljS2V5LlBhcmVudEZpbmdlclByaW50RW5kO1xuSERQdWJsaWNLZXkuQ2hpbGRJbmRleEVuZCAgICAgICAgICA9IEhEUHVibGljS2V5LkNoaWxkSW5kZXhTdGFydCArIEhEUHVibGljS2V5LkNoaWxkSW5kZXhTaXplO1xuSERQdWJsaWNLZXkuQ2hhaW5Db2RlU3RhcnQgICAgICAgICA9IEhEUHVibGljS2V5LkNoaWxkSW5kZXhFbmQ7XG5IRFB1YmxpY0tleS5DaGFpbkNvZGVFbmQgICAgICAgICAgID0gSERQdWJsaWNLZXkuQ2hhaW5Db2RlU3RhcnQgKyBIRFB1YmxpY0tleS5DaGFpbkNvZGVTaXplO1xuSERQdWJsaWNLZXkuUHVibGljS2V5U3RhcnQgICAgICAgICA9IEhEUHVibGljS2V5LkNoYWluQ29kZUVuZDtcbkhEUHVibGljS2V5LlB1YmxpY0tleUVuZCAgICAgICAgICAgPSBIRFB1YmxpY0tleS5QdWJsaWNLZXlTdGFydCArIEhEUHVibGljS2V5LlB1YmxpY0tleVNpemU7XG5IRFB1YmxpY0tleS5DaGVja3N1bVN0YXJ0ICAgICAgICAgID0gSERQdWJsaWNLZXkuUHVibGljS2V5RW5kO1xuSERQdWJsaWNLZXkuQ2hlY2tzdW1FbmQgICAgICAgICAgICA9IEhEUHVibGljS2V5LkNoZWNrc3VtU3RhcnQgKyBIRFB1YmxpY0tleS5DaGVja1N1bVNpemU7XG5cbmFzc2VydChIRFB1YmxpY0tleS5QdWJsaWNLZXlFbmQgPT09IEhEUHVibGljS2V5LkRhdGFTaXplKTtcbmFzc2VydChIRFB1YmxpY0tleS5DaGVja3N1bUVuZCA9PT0gSERQdWJsaWNLZXkuU2VyaWFsaXplZEJ5dGVTaXplKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIRFB1YmxpY0tleTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/hdpublickey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/message.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/message.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar PrivateKey = __webpack_require__(/*! ./privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar Address = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar BufferWriter = __webpack_require__(/*! ./encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar ECDSA = __webpack_require__(/*! ./crypto/ecdsa */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\");\nvar Signature = __webpack_require__(/*! ./crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar sha256sha256 = (__webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\").sha256sha256);\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nfunction Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n\n  return this;\n}\n\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\n\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = Buffer.from(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\n\nMessage.prototype._sign = function _sign(privateKey) {\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\n  const hash = this.magicHash();\n  const sig = ECDSA.sign(hash, privateKey, { randomK: true });\n  ECDSA.calci(hash, sig, privateKey.toPublicKey());\n  return sig;\n};\n\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n  return signature.toCompact().toString('base64');\n};\n\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n  return verified;\n};\n\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  const hashbuf = this.magicHash();\n  var publicKey = ECDSA.recoverPublicKey(hashbuf, signature);\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n\n  return this._verify(publicKey, signature);\n};\n\n/**\n * Will return a public key string if the provided signature and the message digest is correct\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {String}\n */\nMessage.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  const hashbuf = this.magicHash();\n  var publicKey = ECDSA.recoverPublicKey(hashbuf, signature);\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n  }\n\n  return publicKey.toString();\n};\n\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromString = function(str) {\n  return new Message(str);\n};\n\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n  return new Message(json.message);\n};\n\n/**\n * @returns {Object} A plain object with the message information\n */\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n\n/**\n * @returns {String} A JSON representation of the message information\n */\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\nMessage.prototype.toString = function() {\n  return this.message;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\nMessage.prototype.inspect = function() {\n  return '<Message: ' + this.toString() + '>';\n};\n\nmodule.exports = Message;\n\nvar Script = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFRO0FBQ3hCLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBVztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDcEQsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDNUMsbUJBQW1CLDhHQUFxQztBQUN4RCxhQUFhLG1CQUFPLENBQUMsa0VBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHNFQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL21lc3NhZ2UuanM/YTMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vcHJpdmF0ZWtleScpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vcHVibGlja2V5Jyk7XG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XG52YXIgRUNEU0EgPSByZXF1aXJlKCcuL2NyeXB0by9lY2RzYScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vY3J5cHRvL3NpZ25hdHVyZScpO1xudmFyIHNoYTI1NnNoYTI1NiA9IHJlcXVpcmUoJy4vY3J5cHRvL2hhc2gnKS5zaGEyNTZzaGEyNTY7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbmZ1bmN0aW9uIE1lc3NhZ2UobWVzc2FnZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWVzc2FnZSkpIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcobWVzc2FnZSksICdGaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuTWVzc2FnZS5NQUdJQ19CWVRFUyA9IEJ1ZmZlci5mcm9tKCdCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcbicpO1xuXG5NZXNzYWdlLnByb3RvdHlwZS5tYWdpY0hhc2ggPSBmdW5jdGlvbiBtYWdpY0hhc2goKSB7XG4gIHZhciBwcmVmaXgxID0gQnVmZmVyV3JpdGVyLnZhcmludEJ1Zk51bShNZXNzYWdlLk1BR0lDX0JZVEVTLmxlbmd0aCk7XG4gIHZhciBtZXNzYWdlQnVmZmVyID0gQnVmZmVyLmZyb20odGhpcy5tZXNzYWdlKTtcbiAgdmFyIHByZWZpeDIgPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKG1lc3NhZ2VCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3ByZWZpeDEsIE1lc3NhZ2UuTUFHSUNfQllURVMsIHByZWZpeDIsIG1lc3NhZ2VCdWZmZXJdKTtcbiAgdmFyIGhhc2ggPSBzaGEyNTZzaGEyNTYoYnVmKTtcbiAgcmV0dXJuIGhhc2g7XG59O1xuXG5NZXNzYWdlLnByb3RvdHlwZS5fc2lnbiA9IGZ1bmN0aW9uIF9zaWduKHByaXZhdGVLZXkpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHByaXZhdGVLZXkgaW5zdGFuY2VvZiBQcml2YXRlS2V5LCAnRmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIFByaXZhdGVLZXknKTtcbiAgY29uc3QgaGFzaCA9IHRoaXMubWFnaWNIYXNoKCk7XG4gIGNvbnN0IHNpZyA9IEVDRFNBLnNpZ24oaGFzaCwgcHJpdmF0ZUtleSwgeyByYW5kb21LOiB0cnVlIH0pO1xuICBFQ0RTQS5jYWxjaShoYXNoLCBzaWcsIHByaXZhdGVLZXkudG9QdWJsaWNLZXkoKSk7XG4gIHJldHVybiBzaWc7XG59O1xuXG4vKipcbiAqIFdpbGwgc2lnbiBhIG1lc3NhZ2Ugd2l0aCBhIGdpdmVuIGJpdGNvaW4gcHJpdmF0ZSBrZXkuXG4gKlxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlS2V5IC0gQW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleVxuICogQHJldHVybnMge1N0cmluZ30gQSBiYXNlNjQgZW5jb2RlZCBjb21wYWN0IHNpZ25hdHVyZVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihwcml2YXRlS2V5KSB7XG4gIHZhciBzaWduYXR1cmUgPSB0aGlzLl9zaWduKHByaXZhdGVLZXkpO1xuICByZXR1cm4gc2lnbmF0dXJlLnRvQ29tcGFjdCgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn07XG5cbk1lc3NhZ2UucHJvdG90eXBlLl92ZXJpZnkgPSBmdW5jdGlvbiBfdmVyaWZ5KHB1YmxpY0tleSwgc2lnbmF0dXJlKSB7XG4gICQuY2hlY2tBcmd1bWVudChwdWJsaWNLZXkgaW5zdGFuY2VvZiBQdWJsaWNLZXksICdGaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgUHVibGljS2V5Jyk7XG4gICQuY2hlY2tBcmd1bWVudChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUsICdTZWNvbmQgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIFNpZ25hdHVyZScpO1xuICB2YXIgaGFzaCA9IHRoaXMubWFnaWNIYXNoKCk7XG4gIHZhciB2ZXJpZmllZCA9IEVDRFNBLnZlcmlmeShoYXNoLCBzaWduYXR1cmUsIHB1YmxpY0tleSk7XG4gIGlmICghdmVyaWZpZWQpIHtcbiAgICB0aGlzLmVycm9yID0gJ1RoZSBzaWduYXR1cmUgd2FzIGludmFsaWQnO1xuICB9XG4gIHJldHVybiB2ZXJpZmllZDtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYSBib29sZWFuIG9mIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQgZm9yIGEgZ2l2ZW4gYml0Y29pbiBhZGRyZXNzLlxuICogSWYgaXQgaXNuJ3QgdGhlIHNwZWNpZmljIHJlYXNvbiBpcyBhY2Nlc3NpYmxlIHZpYSB0aGUgXCJlcnJvclwiIG1lbWJlci5cbiAqXG4gKiBAcGFyYW0ge0FkZHJlc3N8U3RyaW5nfSBiaXRjb2luQWRkcmVzcyAtIEEgYml0Y29pbiBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmF0dXJlU3RyaW5nIC0gQSBiYXNlNjQgZW5jb2RlZCBjb21wYWN0IHNpZ25hdHVyZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShiaXRjb2luQWRkcmVzcywgc2lnbmF0dXJlU3RyaW5nKSB7XG4gICQuY2hlY2tBcmd1bWVudChiaXRjb2luQWRkcmVzcyk7XG4gICQuY2hlY2tBcmd1bWVudChzaWduYXR1cmVTdHJpbmcgJiYgXy5pc1N0cmluZyhzaWduYXR1cmVTdHJpbmcpKTtcblxuICBpZiAoXy5pc1N0cmluZyhiaXRjb2luQWRkcmVzcykpIHtcbiAgICBiaXRjb2luQWRkcmVzcyA9IEFkZHJlc3MuZnJvbVN0cmluZyhiaXRjb2luQWRkcmVzcyk7XG4gIH1cbiAgdmFyIHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChCdWZmZXIuZnJvbShzaWduYXR1cmVTdHJpbmcsICdiYXNlNjQnKSk7XG5cbiAgLy8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxuICBjb25zdCBoYXNoYnVmID0gdGhpcy5tYWdpY0hhc2goKTtcbiAgdmFyIHB1YmxpY0tleSA9IEVDRFNBLnJlY292ZXJQdWJsaWNLZXkoaGFzaGJ1Ziwgc2lnbmF0dXJlKTtcblxuICB2YXIgc2lnbmF0dXJlQWRkcmVzcyA9IEFkZHJlc3MuZnJvbVB1YmxpY0tleShwdWJsaWNLZXksIGJpdGNvaW5BZGRyZXNzLm5ldHdvcmspO1xuXG4gIC8vIGNoZWNrIHRoYXQgdGhlIHJlY292ZXJlZCBhZGRyZXNzIGFuZCBzcGVjaWZpZWQgYWRkcmVzcyBtYXRjaFxuICBpZiAoYml0Y29pbkFkZHJlc3MudG9TdHJpbmcoKSAhPT0gc2lnbmF0dXJlQWRkcmVzcy50b1N0cmluZygpKSB7XG4gICAgdGhpcy5lcnJvciA9ICdUaGUgc2lnbmF0dXJlIGRpZCBub3QgbWF0Y2ggdGhlIG1lc3NhZ2UgZGlnZXN0JztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fdmVyaWZ5KHB1YmxpY0tleSwgc2lnbmF0dXJlKTtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYSBwdWJsaWMga2V5IHN0cmluZyBpZiB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlIGFuZCB0aGUgbWVzc2FnZSBkaWdlc3QgaXMgY29ycmVjdFxuICogSWYgaXQgaXNuJ3QgdGhlIHNwZWNpZmljIHJlYXNvbiBpcyBhY2Nlc3NpYmxlIHZpYSB0aGUgXCJlcnJvclwiIG1lbWJlci5cbiAqXG4gKiBAcGFyYW0ge0FkZHJlc3N8U3RyaW5nfSBiaXRjb2luQWRkcmVzcyAtIEEgYml0Y29pbiBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmF0dXJlU3RyaW5nIC0gQSBiYXNlNjQgZW5jb2RlZCBjb21wYWN0IHNpZ25hdHVyZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUucmVjb3ZlclB1YmxpY0tleSA9IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkoYml0Y29pbkFkZHJlc3MsIHNpZ25hdHVyZVN0cmluZykge1xuICAkLmNoZWNrQXJndW1lbnQoYml0Y29pbkFkZHJlc3MpO1xuICAkLmNoZWNrQXJndW1lbnQoc2lnbmF0dXJlU3RyaW5nICYmIF8uaXNTdHJpbmcoc2lnbmF0dXJlU3RyaW5nKSk7XG5cbiAgaWYgKF8uaXNTdHJpbmcoYml0Y29pbkFkZHJlc3MpKSB7XG4gICAgYml0Y29pbkFkZHJlc3MgPSBBZGRyZXNzLmZyb21TdHJpbmcoYml0Y29pbkFkZHJlc3MpO1xuICB9XG4gIHZhciBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3QoQnVmZmVyLmZyb20oc2lnbmF0dXJlU3RyaW5nLCAnYmFzZTY0JykpO1xuXG4gIC8vIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAgY29uc3QgaGFzaGJ1ZiA9IHRoaXMubWFnaWNIYXNoKCk7XG4gIHZhciBwdWJsaWNLZXkgPSBFQ0RTQS5yZWNvdmVyUHVibGljS2V5KGhhc2hidWYsIHNpZ25hdHVyZSk7XG5cbiAgdmFyIHNpZ25hdHVyZUFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkocHVibGljS2V5LCBiaXRjb2luQWRkcmVzcy5uZXR3b3JrKTtcblxuICAvLyBjaGVjayB0aGF0IHRoZSByZWNvdmVyZWQgYWRkcmVzcyBhbmQgc3BlY2lmaWVkIGFkZHJlc3MgbWF0Y2hcbiAgaWYgKGJpdGNvaW5BZGRyZXNzLnRvU3RyaW5nKCkgIT09IHNpZ25hdHVyZUFkZHJlc3MudG9TdHJpbmcoKSkge1xuICAgIHRoaXMuZXJyb3IgPSAnVGhlIHNpZ25hdHVyZSBkaWQgbm90IG1hdGNoIHRoZSBtZXNzYWdlIGRpZ2VzdCc7XG4gIH1cblxuICByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKCk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgbWVzc2FnZSBmcm9tIGEgbWVzc2FnZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gQSBzdHJpbmcgb2YgdGhlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtNZXNzYWdlfSBBIG5ldyBpbnN0YW5jZSBvZiBhIE1lc3NhZ2VcbiAqL1xuTWVzc2FnZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBuZXcgTWVzc2FnZShzdHIpO1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIG1lc3NhZ2UgZnJvbSBKU09OXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGpzb24gLSBBbiBKU09OIHN0cmluZyBvciBPYmplY3Qgd2l0aCBrZXlzOiBtZXNzYWdlXG4gKiBAcmV0dXJucyB7TWVzc2FnZX0gQSBuZXcgaW5zdGFuY2Ugb2YgYSBNZXNzYWdlXG4gKi9cbk1lc3NhZ2UuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihqc29uKSB7XG4gIGlmIChKU1V0aWwuaXNWYWxpZEpTT04oanNvbikpIHtcbiAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcbiAgfVxuICByZXR1cm4gbmV3IE1lc3NhZ2UoanNvbi5tZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge09iamVjdH0gQSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgbWVzc2FnZSBpbmZvcm1hdGlvblxuICovXG5NZXNzYWdlLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICB9O1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIG1lc3NhZ2UgaW5mb3JtYXRpb25cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b09iamVjdCgpKTtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXNzYWdlXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gTWVzc2FnZVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5tZXNzYWdlO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIHN0cmluZyBmb3JtYXR0ZWQgZm9yIHRoZSBjb25zb2xlXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gTWVzc2FnZVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPE1lc3NhZ2U6ICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnPic7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2U7XG5cbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/networks.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/networks.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar networks = [];\nvar networkMaps = {};\n\n/**\n * A network is merely a map containing values that correspond to version\n * numbers for each bitcoin network. Currently only supporting \"livenet\"\n * (a.k.a. \"mainnet\") and \"testnet\".\n * @constructor\n */\nfunction Network() {}\n\nNetwork.prototype.toString = function toString() {\n  return this.name;\n};\n\n/**\n * @function\n * @member Networks#get\n * Retrieves the network associated with a magic number or string.\n * @param {string|number|Network} arg\n * @param {string|Array} keys - if set, only check if the magic number associated with this name matches\n * @return Network\n */\nfunction get(arg, keys) {\n  if (~networks.indexOf(arg)) {\n    return arg;\n  }\n  if (keys) {\n    if (!Array.isArray(keys)) {\n      keys = [keys];\n    }\n    for (const index in networks) {\n      if (keys.some(key => networks[index][key] === arg)) {\n        return networks[index];\n      }\n    }\n    return undefined;\n  }\n  if (networkMaps[arg] && networkMaps[arg].length >= 1) {\n    return networkMaps[arg][0];\n  } else {\n    return networkMaps[arg];\n  }\n}\n\n/**\n * @function\n * @member Networks#is\n * Returns true if the string is the network name or alias\n * @param {string} str - A string to check\n * @return boolean\n */\nfunction is(str) {\n  return this.name == str || this.alias == str;\n}\n\n/**\n * @function\n * @member Networks#add\n * Will add a custom Network\n * @param {Object} data\n * @param {string} data.name - The name of the network\n * @param {string} data.alias - The aliased name of the network\n * @param {Number} data.pubkeyhash - The publickey hash prefix\n * @param {Number} data.privatekey - The privatekey prefix\n * @param {Number} data.scripthash - The scripthash prefix\n * @param {string} data.bech32prefix - The native segwit prefix\n * @param {Number} data.xpubkey - The extended public key magic\n * @param {Number} data.xprivkey - The extended private key magic\n * @param {Array}  data.variants - An array of variants\n * @param {string} data.variants.name - The name of the variant\n * @param {Number} data.variants.networkMagic - The network magic number\n * @param {Number} data.variants.port - The network port\n * @param {Array}  data.variants.dnsSeeds - An array of dns seeds\n * @return Network\n */\nfunction addNetwork(data) {\n  var network = new Network();\n\n  JSUtil.defineImmutable(network, {\n    name: data.name,\n    alias: data.alias,\n    is: data.is,\n    pubkeyhash: data.pubkeyhash,\n    privatekey: data.privatekey,\n    scripthash: data.scripthash,\n    bech32prefix: data.bech32prefix,\n    xpubkey: data.xpubkey,\n    xprivkey: data.xprivkey\n  });\n\n  if (data.networkMagic) {\n    JSUtil.defineImmutable(network, {\n      networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)\n    });\n  }\n\n  if (data.port) {\n    JSUtil.defineImmutable(network, {\n      port: data.port\n    });\n  }\n\n  if (data.dnsSeeds) {\n    JSUtil.defineImmutable(network, {\n      dnsSeeds: data.dnsSeeds\n    });\n  }\n\n  for (const value of Object.values(network)) {\n    if (value != null && typeof value !== 'object') {\n      if (!networkMaps[value]) {\n        networkMaps[value] = [];\n      }\n      networkMaps[value].push(network);\n    }\n  };\n\n  networks.push(network);\n\n  for (const variant of data.variants || []) {\n    addNetwork({\n      ...data,\n      variants: undefined,\n      ...variant,\n    });\n  }\n\n  return network;\n}\n\n/**\n * @function\n * @member Networks#remove\n * Will remove a custom network\n * @param {Network} network\n */\nfunction removeNetwork(network) {\n  if (typeof network !== 'object') {\n    network = get(network);\n  }\n  for (var i = 0; i < networks.length; i++) {\n    if (networks[i] === network) {\n      networks.splice(i, 1);\n    }\n  }\n  for (var key in networkMaps) {\n    if (networkMaps[key].length) {\n      const index = networkMaps[key].indexOf(network);\n      if (index >= 0) {\n        networkMaps[key].splice(index, 1);\n      }\n      if (networkMaps[key].length === 0) {\n        delete networkMaps[key];\n      }\n    } else if (networkMaps[key] === network) {\n      delete networkMaps[key];\n    }\n  }\n}\n\naddNetwork({\n  name: 'livenet',\n  alias: 'mainnet',\n  is,\n  pubkeyhash: 0x00,\n  privatekey: 0x80,\n  scripthash: 0x05,\n  bech32prefix: 'bc',\n  xpubkey: 0x0488b21e,\n  xprivkey: 0x0488ade4,\n  networkMagic: 0xf9beb4d9,\n  port: 8333,\n  dnsSeeds: [\n    'seed.bitcoin.sipa.be',\n    'dnsseed.bluematt.me',\n    'dnsseed.bitcoin.dashjr.org',\n    'seed.bitcoinstats.com',\n    'seed.bitnodes.io',\n    'bitseed.xf2.org'\n  ]\n});\n\n/**\n * @instance\n * @member Networks#livenet\n */\nvar livenet = get('livenet');\n\naddNetwork({\n  name: 'testnet',\n  alias: 'testnet',\n  is,\n  pubkeyhash: 0x6f,\n  privatekey: 0xef,\n  scripthash: 0xc4,\n  bech32prefix: 'tb',\n  xpubkey: 0x043587cf,\n  xprivkey: 0x04358394,\n  variants: [{\n    name: 'testnet3',\n    networkMagic: 0x0b110907,\n    port: 18333,\n    dnsSeeds: [\n      'testnet-seed.bitcoin.petertodd.org',\n      'testnet-seed.bluematt.me',\n      'testnet-seed.alexykot.me',\n      'testnet-seed.bitcoin.schildbach.de'\n    ]\n  }, {\n    name: 'signet',\n    networkMagic: 0x0a03cf40,\n    port: 38333,\n    dnsSeeds: [\n      '178.128.221.177',\n      '103.16.128.63',\n      '153.126.143.201',\n      '192.241.163.142'\n    ]\n  }, {\n    name: 'testnet4',\n    networkMagic: 0x1c163f28,\n    port: 48333,\n    dnsSeeds: [\n      '18.189.156.102',\n      '18.201.207.55',\n      '51.158.248.8',\n      '57.128.176.163',\n      '82.67.102.15',\n      '88.99.248.50',\n      '95.217.73.162',\n      '103.99.171.212',\n      '103.165.192.210',\n    ]\n  }]\n});\n\n/**\n * @instance\n * @member Networks#testnet\n */\nvar testnet = get('testnet');\nvar testnet3 = get('testnet3');\nvar signet = get('signet');\n\naddNetwork({\n  name: 'regtest',\n  alias: 'dev',\n  is,\n  pubkeyhash: 0x6f,\n  privatekey: 0xef,\n  scripthash: 0xc4,\n  bech32prefix: 'bcrt',\n  xpubkey: 0x043587cf,\n  xprivkey: 0x04358394,\n  networkMagic: 0xfabfb5da,\n  port: 18444,\n  dnsSeeds: []\n});\n\n/**\n * @instance\n * @member Networks#regtest\n */\nvar regtest = get('regtest');\n\n/**\n * @function\n * @deprecated\n * @member Networks#enableRegtest\n * Will enable regtest features for testnet\n */\nfunction enableRegtest() {\n  testnet.regtestEnabled = true;\n}\n\n/**\n * @function\n * @deprecated\n * @member Networks#disableRegtest\n * Will disable regtest features for testnet\n */\nfunction disableRegtest() {\n  testnet.regtestEnabled = false;\n}\n\n/**\n * @namespace Networks\n */\nmodule.exports = {\n  add: addNetwork,\n  remove: removeNetwork,\n  defaultNetwork: livenet,\n  livenet: livenet,\n  mainnet: livenet,\n  testnet: testnet,\n  testnet3: testnet3,\n  signet: signet,\n  regtest: regtest,\n  get: get,\n  enableRegtest: enableRegtest,\n  disableRegtest: disableRegtest\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL25ldHdvcmtzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWU7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL25ldHdvcmtzLmpzPzM3YmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL3V0aWwvYnVmZmVyJyk7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XG52YXIgbmV0d29ya3MgPSBbXTtcbnZhciBuZXR3b3JrTWFwcyA9IHt9O1xuXG4vKipcbiAqIEEgbmV0d29yayBpcyBtZXJlbHkgYSBtYXAgY29udGFpbmluZyB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHZlcnNpb25cbiAqIG51bWJlcnMgZm9yIGVhY2ggYml0Y29pbiBuZXR3b3JrLiBDdXJyZW50bHkgb25seSBzdXBwb3J0aW5nIFwibGl2ZW5ldFwiXG4gKiAoYS5rLmEuIFwibWFpbm5ldFwiKSBhbmQgXCJ0ZXN0bmV0XCIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTmV0d29yaygpIHt9XG5cbk5ldHdvcmsucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm5hbWU7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlciBOZXR3b3JrcyNnZXRcbiAqIFJldHJpZXZlcyB0aGUgbmV0d29yayBhc3NvY2lhdGVkIHdpdGggYSBtYWdpYyBudW1iZXIgb3Igc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfE5ldHdvcmt9IGFyZ1xuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGtleXMgLSBpZiBzZXQsIG9ubHkgY2hlY2sgaWYgdGhlIG1hZ2ljIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBuYW1lIG1hdGNoZXNcbiAqIEByZXR1cm4gTmV0d29ya1xuICovXG5mdW5jdGlvbiBnZXQoYXJnLCBrZXlzKSB7XG4gIGlmICh+bmV0d29ya3MuaW5kZXhPZihhcmcpKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxuICBpZiAoa2V5cykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAga2V5cyA9IFtrZXlzXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpbmRleCBpbiBuZXR3b3Jrcykge1xuICAgICAgaWYgKGtleXMuc29tZShrZXkgPT4gbmV0d29ya3NbaW5kZXhdW2tleV0gPT09IGFyZykpIHtcbiAgICAgICAgcmV0dXJuIG5ldHdvcmtzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAobmV0d29ya01hcHNbYXJnXSAmJiBuZXR3b3JrTWFwc1thcmddLmxlbmd0aCA+PSAxKSB7XG4gICAgcmV0dXJuIG5ldHdvcmtNYXBzW2FyZ11bMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldHdvcmtNYXBzW2FyZ107XG4gIH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXIgTmV0d29ya3MjaXNcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIHRoZSBuZXR3b3JrIG5hbWUgb3IgYWxpYXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBBIHN0cmluZyB0byBjaGVja1xuICogQHJldHVybiBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzKHN0cikge1xuICByZXR1cm4gdGhpcy5uYW1lID09IHN0ciB8fCB0aGlzLmFsaWFzID09IHN0cjtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXIgTmV0d29ya3MjYWRkXG4gKiBXaWxsIGFkZCBhIGN1c3RvbSBOZXR3b3JrXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBuZXR3b3JrXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YS5hbGlhcyAtIFRoZSBhbGlhc2VkIG5hbWUgb2YgdGhlIG5ldHdvcmtcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnB1YmtleWhhc2ggLSBUaGUgcHVibGlja2V5IGhhc2ggcHJlZml4XG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YS5wcml2YXRla2V5IC0gVGhlIHByaXZhdGVrZXkgcHJlZml4XG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JpcHRoYXNoIC0gVGhlIHNjcmlwdGhhc2ggcHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YS5iZWNoMzJwcmVmaXggLSBUaGUgbmF0aXZlIHNlZ3dpdCBwcmVmaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnhwdWJrZXkgLSBUaGUgZXh0ZW5kZWQgcHVibGljIGtleSBtYWdpY1xuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEueHByaXZrZXkgLSBUaGUgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgbWFnaWNcbiAqIEBwYXJhbSB7QXJyYXl9ICBkYXRhLnZhcmlhbnRzIC0gQW4gYXJyYXkgb2YgdmFyaWFudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhLnZhcmlhbnRzLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFudFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudmFyaWFudHMubmV0d29ya01hZ2ljIC0gVGhlIG5ldHdvcmsgbWFnaWMgbnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YS52YXJpYW50cy5wb3J0IC0gVGhlIG5ldHdvcmsgcG9ydFxuICogQHBhcmFtIHtBcnJheX0gIGRhdGEudmFyaWFudHMuZG5zU2VlZHMgLSBBbiBhcnJheSBvZiBkbnMgc2VlZHNcbiAqIEByZXR1cm4gTmV0d29ya1xuICovXG5mdW5jdGlvbiBhZGROZXR3b3JrKGRhdGEpIHtcbiAgdmFyIG5ldHdvcmsgPSBuZXcgTmV0d29yaygpO1xuXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUobmV0d29yaywge1xuICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICBhbGlhczogZGF0YS5hbGlhcyxcbiAgICBpczogZGF0YS5pcyxcbiAgICBwdWJrZXloYXNoOiBkYXRhLnB1YmtleWhhc2gsXG4gICAgcHJpdmF0ZWtleTogZGF0YS5wcml2YXRla2V5LFxuICAgIHNjcmlwdGhhc2g6IGRhdGEuc2NyaXB0aGFzaCxcbiAgICBiZWNoMzJwcmVmaXg6IGRhdGEuYmVjaDMycHJlZml4LFxuICAgIHhwdWJrZXk6IGRhdGEueHB1YmtleSxcbiAgICB4cHJpdmtleTogZGF0YS54cHJpdmtleVxuICB9KTtcblxuICBpZiAoZGF0YS5uZXR3b3JrTWFnaWMpIHtcbiAgICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKG5ldHdvcmssIHtcbiAgICAgIG5ldHdvcmtNYWdpYzogQnVmZmVyVXRpbC5pbnRlZ2VyQXNCdWZmZXIoZGF0YS5uZXR3b3JrTWFnaWMpXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGF0YS5wb3J0KSB7XG4gICAgSlNVdGlsLmRlZmluZUltbXV0YWJsZShuZXR3b3JrLCB7XG4gICAgICBwb3J0OiBkYXRhLnBvcnRcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkYXRhLmRuc1NlZWRzKSB7XG4gICAgSlNVdGlsLmRlZmluZUltbXV0YWJsZShuZXR3b3JrLCB7XG4gICAgICBkbnNTZWVkczogZGF0YS5kbnNTZWVkc1xuICAgIH0pO1xuICB9XG5cbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBPYmplY3QudmFsdWVzKG5ldHdvcmspKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKCFuZXR3b3JrTWFwc1t2YWx1ZV0pIHtcbiAgICAgICAgbmV0d29ya01hcHNbdmFsdWVdID0gW107XG4gICAgICB9XG4gICAgICBuZXR3b3JrTWFwc1t2YWx1ZV0ucHVzaChuZXR3b3JrKTtcbiAgICB9XG4gIH07XG5cbiAgbmV0d29ya3MucHVzaChuZXR3b3JrKTtcblxuICBmb3IgKGNvbnN0IHZhcmlhbnQgb2YgZGF0YS52YXJpYW50cyB8fCBbXSkge1xuICAgIGFkZE5ldHdvcmsoe1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHZhcmlhbnRzOiB1bmRlZmluZWQsXG4gICAgICAuLi52YXJpYW50LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG5ldHdvcms7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyIE5ldHdvcmtzI3JlbW92ZVxuICogV2lsbCByZW1vdmUgYSBjdXN0b20gbmV0d29ya1xuICogQHBhcmFtIHtOZXR3b3JrfSBuZXR3b3JrXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZU5ldHdvcmsobmV0d29yaykge1xuICBpZiAodHlwZW9mIG5ldHdvcmsgIT09ICdvYmplY3QnKSB7XG4gICAgbmV0d29yayA9IGdldChuZXR3b3JrKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5ldHdvcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5ldHdvcmtzW2ldID09PSBuZXR3b3JrKSB7XG4gICAgICBuZXR3b3Jrcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGtleSBpbiBuZXR3b3JrTWFwcykge1xuICAgIGlmIChuZXR3b3JrTWFwc1trZXldLmxlbmd0aCkge1xuICAgICAgY29uc3QgaW5kZXggPSBuZXR3b3JrTWFwc1trZXldLmluZGV4T2YobmV0d29yayk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBuZXR3b3JrTWFwc1trZXldLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAobmV0d29ya01hcHNba2V5XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIG5ldHdvcmtNYXBzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXR3b3JrTWFwc1trZXldID09PSBuZXR3b3JrKSB7XG4gICAgICBkZWxldGUgbmV0d29ya01hcHNba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuYWRkTmV0d29yayh7XG4gIG5hbWU6ICdsaXZlbmV0JyxcbiAgYWxpYXM6ICdtYWlubmV0JyxcbiAgaXMsXG4gIHB1YmtleWhhc2g6IDB4MDAsXG4gIHByaXZhdGVrZXk6IDB4ODAsXG4gIHNjcmlwdGhhc2g6IDB4MDUsXG4gIGJlY2gzMnByZWZpeDogJ2JjJyxcbiAgeHB1YmtleTogMHgwNDg4YjIxZSxcbiAgeHByaXZrZXk6IDB4MDQ4OGFkZTQsXG4gIG5ldHdvcmtNYWdpYzogMHhmOWJlYjRkOSxcbiAgcG9ydDogODMzMyxcbiAgZG5zU2VlZHM6IFtcbiAgICAnc2VlZC5iaXRjb2luLnNpcGEuYmUnLFxuICAgICdkbnNzZWVkLmJsdWVtYXR0Lm1lJyxcbiAgICAnZG5zc2VlZC5iaXRjb2luLmRhc2hqci5vcmcnLFxuICAgICdzZWVkLmJpdGNvaW5zdGF0cy5jb20nLFxuICAgICdzZWVkLmJpdG5vZGVzLmlvJyxcbiAgICAnYml0c2VlZC54ZjIub3JnJ1xuICBdXG59KTtcblxuLyoqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgTmV0d29ya3MjbGl2ZW5ldFxuICovXG52YXIgbGl2ZW5ldCA9IGdldCgnbGl2ZW5ldCcpO1xuXG5hZGROZXR3b3JrKHtcbiAgbmFtZTogJ3Rlc3RuZXQnLFxuICBhbGlhczogJ3Rlc3RuZXQnLFxuICBpcyxcbiAgcHVia2V5aGFzaDogMHg2ZixcbiAgcHJpdmF0ZWtleTogMHhlZixcbiAgc2NyaXB0aGFzaDogMHhjNCxcbiAgYmVjaDMycHJlZml4OiAndGInLFxuICB4cHVia2V5OiAweDA0MzU4N2NmLFxuICB4cHJpdmtleTogMHgwNDM1ODM5NCxcbiAgdmFyaWFudHM6IFt7XG4gICAgbmFtZTogJ3Rlc3RuZXQzJyxcbiAgICBuZXR3b3JrTWFnaWM6IDB4MGIxMTA5MDcsXG4gICAgcG9ydDogMTgzMzMsXG4gICAgZG5zU2VlZHM6IFtcbiAgICAgICd0ZXN0bmV0LXNlZWQuYml0Y29pbi5wZXRlcnRvZGQub3JnJyxcbiAgICAgICd0ZXN0bmV0LXNlZWQuYmx1ZW1hdHQubWUnLFxuICAgICAgJ3Rlc3RuZXQtc2VlZC5hbGV4eWtvdC5tZScsXG4gICAgICAndGVzdG5ldC1zZWVkLmJpdGNvaW4uc2NoaWxkYmFjaC5kZSdcbiAgICBdXG4gIH0sIHtcbiAgICBuYW1lOiAnc2lnbmV0JyxcbiAgICBuZXR3b3JrTWFnaWM6IDB4MGEwM2NmNDAsXG4gICAgcG9ydDogMzgzMzMsXG4gICAgZG5zU2VlZHM6IFtcbiAgICAgICcxNzguMTI4LjIyMS4xNzcnLFxuICAgICAgJzEwMy4xNi4xMjguNjMnLFxuICAgICAgJzE1My4xMjYuMTQzLjIwMScsXG4gICAgICAnMTkyLjI0MS4xNjMuMTQyJ1xuICAgIF1cbiAgfSwge1xuICAgIG5hbWU6ICd0ZXN0bmV0NCcsXG4gICAgbmV0d29ya01hZ2ljOiAweDFjMTYzZjI4LFxuICAgIHBvcnQ6IDQ4MzMzLFxuICAgIGRuc1NlZWRzOiBbXG4gICAgICAnMTguMTg5LjE1Ni4xMDInLFxuICAgICAgJzE4LjIwMS4yMDcuNTUnLFxuICAgICAgJzUxLjE1OC4yNDguOCcsXG4gICAgICAnNTcuMTI4LjE3Ni4xNjMnLFxuICAgICAgJzgyLjY3LjEwMi4xNScsXG4gICAgICAnODguOTkuMjQ4LjUwJyxcbiAgICAgICc5NS4yMTcuNzMuMTYyJyxcbiAgICAgICcxMDMuOTkuMTcxLjIxMicsXG4gICAgICAnMTAzLjE2NS4xOTIuMjEwJyxcbiAgICBdXG4gIH1dXG59KTtcblxuLyoqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgTmV0d29ya3MjdGVzdG5ldFxuICovXG52YXIgdGVzdG5ldCA9IGdldCgndGVzdG5ldCcpO1xudmFyIHRlc3RuZXQzID0gZ2V0KCd0ZXN0bmV0MycpO1xudmFyIHNpZ25ldCA9IGdldCgnc2lnbmV0Jyk7XG5cbmFkZE5ldHdvcmsoe1xuICBuYW1lOiAncmVndGVzdCcsXG4gIGFsaWFzOiAnZGV2JyxcbiAgaXMsXG4gIHB1YmtleWhhc2g6IDB4NmYsXG4gIHByaXZhdGVrZXk6IDB4ZWYsXG4gIHNjcmlwdGhhc2g6IDB4YzQsXG4gIGJlY2gzMnByZWZpeDogJ2JjcnQnLFxuICB4cHVia2V5OiAweDA0MzU4N2NmLFxuICB4cHJpdmtleTogMHgwNDM1ODM5NCxcbiAgbmV0d29ya01hZ2ljOiAweGZhYmZiNWRhLFxuICBwb3J0OiAxODQ0NCxcbiAgZG5zU2VlZHM6IFtdXG59KTtcblxuLyoqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXIgTmV0d29ya3MjcmVndGVzdFxuICovXG52YXIgcmVndGVzdCA9IGdldCgncmVndGVzdCcpO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlcHJlY2F0ZWRcbiAqIEBtZW1iZXIgTmV0d29ya3MjZW5hYmxlUmVndGVzdFxuICogV2lsbCBlbmFibGUgcmVndGVzdCBmZWF0dXJlcyBmb3IgdGVzdG5ldFxuICovXG5mdW5jdGlvbiBlbmFibGVSZWd0ZXN0KCkge1xuICB0ZXN0bmV0LnJlZ3Rlc3RFbmFibGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXByZWNhdGVkXG4gKiBAbWVtYmVyIE5ldHdvcmtzI2Rpc2FibGVSZWd0ZXN0XG4gKiBXaWxsIGRpc2FibGUgcmVndGVzdCBmZWF0dXJlcyBmb3IgdGVzdG5ldFxuICovXG5mdW5jdGlvbiBkaXNhYmxlUmVndGVzdCgpIHtcbiAgdGVzdG5ldC5yZWd0ZXN0RW5hYmxlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgTmV0d29ya3NcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZDogYWRkTmV0d29yayxcbiAgcmVtb3ZlOiByZW1vdmVOZXR3b3JrLFxuICBkZWZhdWx0TmV0d29yazogbGl2ZW5ldCxcbiAgbGl2ZW5ldDogbGl2ZW5ldCxcbiAgbWFpbm5ldDogbGl2ZW5ldCxcbiAgdGVzdG5ldDogdGVzdG5ldCxcbiAgdGVzdG5ldDM6IHRlc3RuZXQzLFxuICBzaWduZXQ6IHNpZ25ldCxcbiAgcmVndGVzdDogcmVndGVzdCxcbiAgZ2V0OiBnZXQsXG4gIGVuYWJsZVJlZ3Rlc3Q6IGVuYWJsZVJlZ3Rlc3QsXG4gIGRpc2FibGVSZWd0ZXN0OiBkaXNhYmxlUmVndGVzdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/networks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/opcode.js":
/*!************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/opcode.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ./util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nfunction Opcode(num) {\n  if (!(this instanceof Opcode)) {\n    return new Opcode(num);\n  }\n\n  var value;\n\n  if (_.isNumber(num)) {\n    value = num;\n  } else if (_.isString(num)) {\n    value = Opcode.map[num];\n  } else {\n    throw new TypeError('Unrecognized num type: \"' + typeof(num) + '\" for Opcode');\n  }\n\n  JSUtil.defineImmutable(this, {\n    num: value\n  });\n\n  return this;\n}\n\nOpcode.fromBuffer = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return new Opcode(Number('0x' + buf.toString('hex')));\n};\n\nOpcode.fromNumber = function(num) {\n  $.checkArgument(_.isNumber(num));\n  return new Opcode(num);\n};\n\nOpcode.fromString = function(str) {\n  $.checkArgument(_.isString(str));\n  var value = Opcode.map[str];\n  if (typeof value === 'undefined') {\n    throw new TypeError('Invalid opcodestr');\n  }\n  return new Opcode(value);\n};\n\nOpcode.prototype.toHex = function() {\n  return this.num.toString(16);\n};\n\nOpcode.prototype.toBuffer = function() {\n  return Buffer.from(this.toHex(), 'hex');\n};\n\nOpcode.prototype.toNumber = function() {\n  return this.num;\n};\n\nOpcode.prototype.toString = function() {\n  var str = Opcode.reverseMap[this.num];\n  if (typeof str === 'undefined') {\n    throw new Error('Opcode does not have a string representation');\n  }\n  return str;\n};\n\nOpcode.smallInt = function(n) {\n  $.checkArgument(_.isNumber(n), 'Invalid Argument: n should be number');\n  $.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');\n  if (n === 0) {\n    return Opcode('OP_0');\n  }\n  return new Opcode(Opcode.map.OP_1 + n - 1);\n};\n\n/**\n * Converts OP_0 - OP_16 to an int\n * @param {Number} opcode Opcode\n * @returns {Number}\n */\nOpcode.decodeOpN = function(opcode) {\n  if (opcode === Opcode.OP_0) {\n    return 0;\n  }\n  $.checkArgument(opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16, new Error('Invalid opcode: ' + JSON.stringify(opcode)));\n  return opcode - (Opcode.OP_1 - 1);\n};\n\n/**\n * Returns true if given opcode is classified as a \"success\".\n * This was taken from commit https://github.com/bitcoin/bitcoin/commit/72422ce396b8eba7b1a72c171c2f07dae691d1b5\n * @param {Number|String} opcode \n * @returns {Boolean}\n */\nOpcode.isOpSuccess = function(opcode) {\n  if (typeof opcode === 'string' && !parseInt(opcode)) {\n    opcode = Opcode[opcode];\n  }\n  return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\n        (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\n        (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\n        (opcode >= 187 && opcode <= 254);\n};\n\n\nOpcode.map = {\n  // push value\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n\n  // control\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n\n  // stack ops\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n\n  // splice ops\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n\n  // bit logic\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n\n  // numeric\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n\n  OP_WITHIN: 165,\n\n  // crypto\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_CHECKSEQUENCEVERIFY: 178,\n\n  // expansion\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_NOP3: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n\n  // Opcode added by BIP 342 (Tapscript)\n  OP_CHECKSIGADD: 186, // 0xba\n\n  // template matching params\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255\n};\n\nOpcode.reverseMap = [];\n\nfor (var k in Opcode.map) {\n  Opcode.reverseMap[Opcode.map[k]] = k;\n}\n\n// Easier access to opcodes\n_.extend(Opcode, Opcode.map);\n\n/**\n * @returns true if opcode is one of OP_0, OP_1, ..., OP_16\n */\nOpcode.isSmallIntOp = function(opcode) {\n  if (opcode instanceof Opcode) {\n    opcode = opcode.toNumber();\n  }\n  return ((opcode === Opcode.map.OP_0) ||\n    ((opcode >= Opcode.map.OP_1) && (opcode <= Opcode.map.OP_16)));\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Script opcode\n */\nOpcode.prototype.inspect = function() {\n  return '<Opcode: ' + this.toString() + ', hex: '+this.toHex()+', decimal: '+this.num+'>';\n};\n\nmodule.exports = Opcode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL29wY29kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBZTtBQUN4QyxhQUFhLG1CQUFPLENBQUMsa0VBQVc7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9vcGNvZGUuanM/Y2FhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9idWZmZXInKTtcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuL3V0aWwvanMnKTtcblxuZnVuY3Rpb24gT3Bjb2RlKG51bSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT3Bjb2RlKSkge1xuICAgIHJldHVybiBuZXcgT3Bjb2RlKG51bSk7XG4gIH1cblxuICB2YXIgdmFsdWU7XG5cbiAgaWYgKF8uaXNOdW1iZXIobnVtKSkge1xuICAgIHZhbHVlID0gbnVtO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcobnVtKSkge1xuICAgIHZhbHVlID0gT3Bjb2RlLm1hcFtudW1dO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVjb2duaXplZCBudW0gdHlwZTogXCInICsgdHlwZW9mKG51bSkgKyAnXCIgZm9yIE9wY29kZScpO1xuICB9XG5cbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XG4gICAgbnVtOiB2YWx1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuT3Bjb2RlLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcbiAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoYnVmKSk7XG4gIHJldHVybiBuZXcgT3Bjb2RlKE51bWJlcignMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKSkpO1xufTtcblxuT3Bjb2RlLmZyb21OdW1iZXIgPSBmdW5jdGlvbihudW0pIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNOdW1iZXIobnVtKSk7XG4gIHJldHVybiBuZXcgT3Bjb2RlKG51bSk7XG59O1xuXG5PcGNvZGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc1N0cmluZyhzdHIpKTtcbiAgdmFyIHZhbHVlID0gT3Bjb2RlLm1hcFtzdHJdO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3Bjb2Rlc3RyJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPcGNvZGUodmFsdWUpO1xufTtcblxuT3Bjb2RlLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5udW0udG9TdHJpbmcoMTYpO1xufTtcblxuT3Bjb2RlLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy50b0hleCgpLCAnaGV4Jyk7XG59O1xuXG5PcGNvZGUucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm51bTtcbn07XG5cbk9wY29kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9IE9wY29kZS5yZXZlcnNlTWFwW3RoaXMubnVtXTtcbiAgaWYgKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcGNvZGUgZG9lcyBub3QgaGF2ZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbicpO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5PcGNvZGUuc21hbGxJbnQgPSBmdW5jdGlvbihuKSB7XG4gICQuY2hlY2tBcmd1bWVudChfLmlzTnVtYmVyKG4pLCAnSW52YWxpZCBBcmd1bWVudDogbiBzaG91bGQgYmUgbnVtYmVyJyk7XG4gICQuY2hlY2tBcmd1bWVudChuID49IDAgJiYgbiA8PSAxNiwgJ0ludmFsaWQgQXJndW1lbnQ6IG4gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDE2Jyk7XG4gIGlmIChuID09PSAwKSB7XG4gICAgcmV0dXJuIE9wY29kZSgnT1BfMCcpO1xuICB9XG4gIHJldHVybiBuZXcgT3Bjb2RlKE9wY29kZS5tYXAuT1BfMSArIG4gLSAxKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgT1BfMCAtIE9QXzE2IHRvIGFuIGludFxuICogQHBhcmFtIHtOdW1iZXJ9IG9wY29kZSBPcGNvZGVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbk9wY29kZS5kZWNvZGVPcE4gPSBmdW5jdGlvbihvcGNvZGUpIHtcbiAgaWYgKG9wY29kZSA9PT0gT3Bjb2RlLk9QXzApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAkLmNoZWNrQXJndW1lbnQob3Bjb2RlID49IE9wY29kZS5PUF8xICYmIG9wY29kZSA8PSBPcGNvZGUuT1BfMTYsIG5ldyBFcnJvcignSW52YWxpZCBvcGNvZGU6ICcgKyBKU09OLnN0cmluZ2lmeShvcGNvZGUpKSk7XG4gIHJldHVybiBvcGNvZGUgLSAoT3Bjb2RlLk9QXzEgLSAxKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIG9wY29kZSBpcyBjbGFzc2lmaWVkIGFzIGEgXCJzdWNjZXNzXCIuXG4gKiBUaGlzIHdhcyB0YWtlbiBmcm9tIGNvbW1pdCBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2NvbW1pdC83MjQyMmNlMzk2YjhlYmE3YjFhNzJjMTcxYzJmMDdkYWU2OTFkMWI1XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9wY29kZSBcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5PcGNvZGUuaXNPcFN1Y2Nlc3MgPSBmdW5jdGlvbihvcGNvZGUpIHtcbiAgaWYgKHR5cGVvZiBvcGNvZGUgPT09ICdzdHJpbmcnICYmICFwYXJzZUludChvcGNvZGUpKSB7XG4gICAgb3Bjb2RlID0gT3Bjb2RlW29wY29kZV07XG4gIH1cbiAgcmV0dXJuIG9wY29kZSA9PSA4MCB8fCBvcGNvZGUgPT0gOTggfHwgKG9wY29kZSA+PSAxMjYgJiYgb3Bjb2RlIDw9IDEyOSkgfHxcbiAgICAgICAgKG9wY29kZSA+PSAxMzEgJiYgb3Bjb2RlIDw9IDEzNCkgfHwgKG9wY29kZSA+PSAxMzcgJiYgb3Bjb2RlIDw9IDEzOCkgfHxcbiAgICAgICAgKG9wY29kZSA+PSAxNDEgJiYgb3Bjb2RlIDw9IDE0MikgfHwgKG9wY29kZSA+PSAxNDkgJiYgb3Bjb2RlIDw9IDE1MykgfHxcbiAgICAgICAgKG9wY29kZSA+PSAxODcgJiYgb3Bjb2RlIDw9IDI1NCk7XG59O1xuXG5cbk9wY29kZS5tYXAgPSB7XG4gIC8vIHB1c2ggdmFsdWVcbiAgT1BfRkFMU0U6IDAsXG4gIE9QXzA6IDAsXG4gIE9QX1BVU0hEQVRBMTogNzYsXG4gIE9QX1BVU0hEQVRBMjogNzcsXG4gIE9QX1BVU0hEQVRBNDogNzgsXG4gIE9QXzFORUdBVEU6IDc5LFxuICBPUF9SRVNFUlZFRDogODAsXG4gIE9QX1RSVUU6IDgxLFxuICBPUF8xOiA4MSxcbiAgT1BfMjogODIsXG4gIE9QXzM6IDgzLFxuICBPUF80OiA4NCxcbiAgT1BfNTogODUsXG4gIE9QXzY6IDg2LFxuICBPUF83OiA4NyxcbiAgT1BfODogODgsXG4gIE9QXzk6IDg5LFxuICBPUF8xMDogOTAsXG4gIE9QXzExOiA5MSxcbiAgT1BfMTI6IDkyLFxuICBPUF8xMzogOTMsXG4gIE9QXzE0OiA5NCxcbiAgT1BfMTU6IDk1LFxuICBPUF8xNjogOTYsXG5cbiAgLy8gY29udHJvbFxuICBPUF9OT1A6IDk3LFxuICBPUF9WRVI6IDk4LFxuICBPUF9JRjogOTksXG4gIE9QX05PVElGOiAxMDAsXG4gIE9QX1ZFUklGOiAxMDEsXG4gIE9QX1ZFUk5PVElGOiAxMDIsXG4gIE9QX0VMU0U6IDEwMyxcbiAgT1BfRU5ESUY6IDEwNCxcbiAgT1BfVkVSSUZZOiAxMDUsXG4gIE9QX1JFVFVSTjogMTA2LFxuXG4gIC8vIHN0YWNrIG9wc1xuICBPUF9UT0FMVFNUQUNLOiAxMDcsXG4gIE9QX0ZST01BTFRTVEFDSzogMTA4LFxuICBPUF8yRFJPUDogMTA5LFxuICBPUF8yRFVQOiAxMTAsXG4gIE9QXzNEVVA6IDExMSxcbiAgT1BfMk9WRVI6IDExMixcbiAgT1BfMlJPVDogMTEzLFxuICBPUF8yU1dBUDogMTE0LFxuICBPUF9JRkRVUDogMTE1LFxuICBPUF9ERVBUSDogMTE2LFxuICBPUF9EUk9QOiAxMTcsXG4gIE9QX0RVUDogMTE4LFxuICBPUF9OSVA6IDExOSxcbiAgT1BfT1ZFUjogMTIwLFxuICBPUF9QSUNLOiAxMjEsXG4gIE9QX1JPTEw6IDEyMixcbiAgT1BfUk9UOiAxMjMsXG4gIE9QX1NXQVA6IDEyNCxcbiAgT1BfVFVDSzogMTI1LFxuXG4gIC8vIHNwbGljZSBvcHNcbiAgT1BfQ0FUOiAxMjYsXG4gIE9QX1NVQlNUUjogMTI3LFxuICBPUF9MRUZUOiAxMjgsXG4gIE9QX1JJR0hUOiAxMjksXG4gIE9QX1NJWkU6IDEzMCxcblxuICAvLyBiaXQgbG9naWNcbiAgT1BfSU5WRVJUOiAxMzEsXG4gIE9QX0FORDogMTMyLFxuICBPUF9PUjogMTMzLFxuICBPUF9YT1I6IDEzNCxcbiAgT1BfRVFVQUw6IDEzNSxcbiAgT1BfRVFVQUxWRVJJRlk6IDEzNixcbiAgT1BfUkVTRVJWRUQxOiAxMzcsXG4gIE9QX1JFU0VSVkVEMjogMTM4LFxuXG4gIC8vIG51bWVyaWNcbiAgT1BfMUFERDogMTM5LFxuICBPUF8xU1VCOiAxNDAsXG4gIE9QXzJNVUw6IDE0MSxcbiAgT1BfMkRJVjogMTQyLFxuICBPUF9ORUdBVEU6IDE0MyxcbiAgT1BfQUJTOiAxNDQsXG4gIE9QX05PVDogMTQ1LFxuICBPUF8wTk9URVFVQUw6IDE0NixcblxuICBPUF9BREQ6IDE0NyxcbiAgT1BfU1VCOiAxNDgsXG4gIE9QX01VTDogMTQ5LFxuICBPUF9ESVY6IDE1MCxcbiAgT1BfTU9EOiAxNTEsXG4gIE9QX0xTSElGVDogMTUyLFxuICBPUF9SU0hJRlQ6IDE1MyxcblxuICBPUF9CT09MQU5EOiAxNTQsXG4gIE9QX0JPT0xPUjogMTU1LFxuICBPUF9OVU1FUVVBTDogMTU2LFxuICBPUF9OVU1FUVVBTFZFUklGWTogMTU3LFxuICBPUF9OVU1OT1RFUVVBTDogMTU4LFxuICBPUF9MRVNTVEhBTjogMTU5LFxuICBPUF9HUkVBVEVSVEhBTjogMTYwLFxuICBPUF9MRVNTVEhBTk9SRVFVQUw6IDE2MSxcbiAgT1BfR1JFQVRFUlRIQU5PUkVRVUFMOiAxNjIsXG4gIE9QX01JTjogMTYzLFxuICBPUF9NQVg6IDE2NCxcblxuICBPUF9XSVRISU46IDE2NSxcblxuICAvLyBjcnlwdG9cbiAgT1BfUklQRU1EMTYwOiAxNjYsXG4gIE9QX1NIQTE6IDE2NyxcbiAgT1BfU0hBMjU2OiAxNjgsXG4gIE9QX0hBU0gxNjA6IDE2OSxcbiAgT1BfSEFTSDI1NjogMTcwLFxuICBPUF9DT0RFU0VQQVJBVE9SOiAxNzEsXG4gIE9QX0NIRUNLU0lHOiAxNzIsXG4gIE9QX0NIRUNLU0lHVkVSSUZZOiAxNzMsXG4gIE9QX0NIRUNLTVVMVElTSUc6IDE3NCxcbiAgT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWTogMTc1LFxuXG4gIE9QX0NIRUNLTE9DS1RJTUVWRVJJRlk6IDE3NyxcbiAgT1BfQ0hFQ0tTRVFVRU5DRVZFUklGWTogMTc4LFxuXG4gIC8vIGV4cGFuc2lvblxuICBPUF9OT1AxOiAxNzYsXG4gIE9QX05PUDI6IDE3NyxcbiAgT1BfTk9QMzogMTc4LFxuICBPUF9OT1A0OiAxNzksXG4gIE9QX05PUDU6IDE4MCxcbiAgT1BfTk9QNjogMTgxLFxuICBPUF9OT1A3OiAxODIsXG4gIE9QX05PUDg6IDE4MyxcbiAgT1BfTk9QOTogMTg0LFxuICBPUF9OT1AxMDogMTg1LFxuXG4gIC8vIE9wY29kZSBhZGRlZCBieSBCSVAgMzQyIChUYXBzY3JpcHQpXG4gIE9QX0NIRUNLU0lHQUREOiAxODYsIC8vIDB4YmFcblxuICAvLyB0ZW1wbGF0ZSBtYXRjaGluZyBwYXJhbXNcbiAgT1BfUFVCS0VZSEFTSDogMjUzLFxuICBPUF9QVUJLRVk6IDI1NCxcbiAgT1BfSU5WQUxJRE9QQ09ERTogMjU1XG59O1xuXG5PcGNvZGUucmV2ZXJzZU1hcCA9IFtdO1xuXG5mb3IgKHZhciBrIGluIE9wY29kZS5tYXApIHtcbiAgT3Bjb2RlLnJldmVyc2VNYXBbT3Bjb2RlLm1hcFtrXV0gPSBrO1xufVxuXG4vLyBFYXNpZXIgYWNjZXNzIHRvIG9wY29kZXNcbl8uZXh0ZW5kKE9wY29kZSwgT3Bjb2RlLm1hcCk7XG5cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiBvcGNvZGUgaXMgb25lIG9mIE9QXzAsIE9QXzEsIC4uLiwgT1BfMTZcbiAqL1xuT3Bjb2RlLmlzU21hbGxJbnRPcCA9IGZ1bmN0aW9uKG9wY29kZSkge1xuICBpZiAob3Bjb2RlIGluc3RhbmNlb2YgT3Bjb2RlKSB7XG4gICAgb3Bjb2RlID0gb3Bjb2RlLnRvTnVtYmVyKCk7XG4gIH1cbiAgcmV0dXJuICgob3Bjb2RlID09PSBPcGNvZGUubWFwLk9QXzApIHx8XG4gICAgKChvcGNvZGUgPj0gT3Bjb2RlLm1hcC5PUF8xKSAmJiAob3Bjb2RlIDw9IE9wY29kZS5tYXAuT1BfMTYpKSk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTY3JpcHQgb3Bjb2RlXG4gKi9cbk9wY29kZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxPcGNvZGU6ICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnLCBoZXg6ICcrdGhpcy50b0hleCgpKycsIGRlY2ltYWw6ICcrdGhpcy5udW0rJz4nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcGNvZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/opcode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/privatekey.js":
/*!****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/privatekey.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar Address = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Base58Check = __webpack_require__(/*! ./encoding/base58check */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/base58check.js\");\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar Networks = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar Point = __webpack_require__(/*! ./crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nvar PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar Random = __webpack_require__(/*! ./crypto/random */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/random.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst TaggedHash = __webpack_require__(/*! ./crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\nfunction PrivateKey(data, network) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 8 */\n\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network);\n\n  // validation\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0){\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n  if (typeof(info.network) === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n\n  return this;\n\n};\n\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\nPrivateKey.prototype._classifyArguments = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  };\n\n  // detect type of data\n  if (_.isUndefined(data) || _.isNull(data)){\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network){\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof(data) === 'string'){\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(data, 'hex');\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n  return info;\n};\n\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\nPrivateKey._getRandomBN = function(){\n  var condition;\n  var bn;\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n  return bn;\n};\n\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformBuffer = function(buf, network) {\n\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n\n  return info;\n};\n\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\nPrivateKey._transformBNBuffer = function(buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformWIF = function(str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\nPrivateKey.fromBuffer = function(arg, network) {\n  return new PrivateKey(arg, network);\n};\n\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformObject = function(json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn: bn,\n    network: network,\n    compressed: json.compressed\n  };\n};\n\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromString = PrivateKey.fromWIF = function(str) {\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\nPrivateKey.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromRandom = function(network) {\n  var bn = PrivateKey._getRandomBN();\n  return new PrivateKey(bn, network);\n};\n\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\nPrivateKey.getValidationError = function(data, network) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\nPrivateKey.isValid = function(data, network){\n  if (!data) {\n    return false;\n  }\n  return !PrivateKey.getValidationError(data, network);\n};\n\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\nPrivateKey.prototype.toString = function() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\nPrivateKey.prototype.toWIF = function() {\n  var network = this.network;\n  var compressed = this.compressed;\n\n  var buf;\n  if (compressed) {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32}),\n                         Buffer.from([0x01])]);\n  } else {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32})]);\n  }\n\n  return Base58Check.encode(buf);\n};\n\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\nPrivateKey.prototype.toBigNumber = function(){\n  return this.bn;\n};\n\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBuffer = function(){\n  return this.bn.toBuffer({size: 32});\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Will return the private key as a BN buffer without leading zero padding\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBufferNoPadding = function() {\n  return this.bn.toBuffer();\n};\n\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\nPrivateKey.prototype.toPublicKey = function(){\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n  return this._pubkey;\n};\n\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\nPrivateKey.prototype.toAddress = function(network, type) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network, type);\n};\n\n/**\n * @returns {Object} A plain object representation\n */\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Create a tweaked version of this private key\n * @param {Buffer} merkleRoot (optional)\n * @returns {{ tweakedPrivKey: Buffer }}\n */\nPrivateKey.prototype.createTapTweak = function(merkleRoot) {\n  const order = Point.getN();\n  const P = Point.getG().mul(this.bn);\n  const secKey = P.y.isEven() ? this.bn : order.sub(this.bn);\n  const taggedWriter = new TaggedHash('TapTweak');\n  taggedWriter.write(P.x.toBuffer({ size: 32 }));\n\n  if (merkleRoot) {\n    $.checkArgument(Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32, 'merkleRoot must be 32 byte buffer');\n    taggedWriter.write(merkleRoot);\n  }\n  const tweakHash = taggedWriter.finalize();\n\n  $.checkState(BN.fromBuffer(tweakHash).lt(order), 'TapTweak hash failed secp256k1 order check');\n  return {\n    tweakedPrivKey: secKey.add(new BN(tweakHash)).mod(order).toBuffer({ size: 32 })\n  };\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\nPrivateKey.prototype.inspect = function() {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\n};\n\nmodule.exports = PrivateKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3ByaXZhdGVrZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFRO0FBQ3hCLGNBQWMsbUJBQU8sQ0FBQyxrRUFBVztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDbEQsU0FBUyxtQkFBTyxDQUFDLHNFQUFhO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxrRUFBVztBQUNoQyxlQUFlLG1CQUFPLENBQUMsb0VBQVk7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBYTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsOEVBQWlCO0FBQ3RDLFFBQVEsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQXFCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUIsYUFBYSxlQUFlO0FBQ3hELGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxpQkFBaUIsYUFBYSxlQUFlO0FBQ3hELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQixhQUFhLGVBQWU7QUFDeEQsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUIsYUFBYSxlQUFlO0FBQ3hELGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RSxVQUFVO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvcHJpdmF0ZWtleS5qcz82ZGU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XG52YXIgQmFzZTU4Q2hlY2sgPSByZXF1aXJlKCcuL2VuY29kaW5nL2Jhc2U1OGNoZWNrJyk7XG52YXIgQk4gPSByZXF1aXJlKCcuL2NyeXB0by9ibicpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9qcycpO1xudmFyIE5ldHdvcmtzID0gcmVxdWlyZSgnLi9uZXR3b3JrcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9jcnlwdG8vcG9pbnQnKTtcbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuL3B1YmxpY2tleScpO1xudmFyIFJhbmRvbSA9IHJlcXVpcmUoJy4vY3J5cHRvL3JhbmRvbScpO1xudmFyICQgPSByZXF1aXJlKCcuL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4vY3J5cHRvL3RhZ2dlZGhhc2gnKTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIFByaXZhdGVLZXkgZnJvbSBhIEJOLCBCdWZmZXIgYW5kIFdJRi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gZ2VuZXJhdGUgYSBuZXcgcmFuZG9tIGtleVxuICogdmFyIGtleSA9IFByaXZhdGVLZXkoKTtcbiAqXG4gKiAvLyBnZXQgdGhlIGFzc29jaWF0ZWQgYWRkcmVzc1xuICogdmFyIGFkZHJlc3MgPSBrZXkudG9BZGRyZXNzKCk7XG4gKlxuICogLy8gZW5jb2RlIGludG8gd2FsbGV0IGV4cG9ydCBmb3JtYXRcbiAqIHZhciBleHBvcnRlZCA9IGtleS50b1dJRigpO1xuICpcbiAqIC8vIGluc3RhbnRpYXRlIGZyb20gdGhlIGV4cG9ydGVkIChhbmQgc2F2ZWQpIHByaXZhdGUga2V5XG4gKiB2YXIgaW1wb3J0ZWQgPSBQcml2YXRlS2V5LmZyb21XSUYoZXhwb3J0ZWQpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICogQHBhcmFtIHtOZXR3b3JrfHN0cmluZz19IG5ldHdvcmsgLSBhIHtAbGluayBOZXR3b3JrfSBvYmplY3QsIG9yIGEgc3RyaW5nIHdpdGggdGhlIG5ldHdvcmsgbmFtZVxuICogQHJldHVybnMge1ByaXZhdGVLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIGFuIFByaXZhdGVLZXlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQcml2YXRlS2V5KGRhdGEsIG5ldHdvcmspIHtcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDIwICovXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByaXZhdGVLZXkpKSB7XG4gICAgcmV0dXJuIG5ldyBQcml2YXRlS2V5KGRhdGEsIG5ldHdvcmspO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGluZm8gPSB0aGlzLl9jbGFzc2lmeUFyZ3VtZW50cyhkYXRhLCBuZXR3b3JrKTtcblxuICAvLyB2YWxpZGF0aW9uXG4gIGlmICghaW5mby5ibiB8fCBpbmZvLmJuLmNtcChuZXcgQk4oMCkpID09PSAwKXtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOdW1iZXIgY2FuIG5vdCBiZSBlcXVhbCB0byB6ZXJvLCB1bmRlZmluZWQsIG51bGwgb3IgZmFsc2UnKTtcbiAgfVxuICBpZiAoIWluZm8uYm4ubHQoUG9pbnQuZ2V0TigpKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ051bWJlciBtdXN0IGJlIGxlc3MgdGhhbiBOJyk7XG4gIH1cbiAgaWYgKHR5cGVvZihpbmZvLm5ldHdvcmspID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3Qgc3BlY2lmeSB0aGUgbmV0d29yayAoXCJsaXZlbmV0XCIgb3IgXCJ0ZXN0bmV0XCIpJyk7XG4gIH1cblxuICBKU1V0aWwuZGVmaW5lSW1tdXRhYmxlKHRoaXMsIHtcbiAgICBibjogaW5mby5ibixcbiAgICBjb21wcmVzc2VkOiBpbmZvLmNvbXByZXNzZWQsXG4gICAgbmV0d29yazogaW5mby5uZXR3b3JrXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHVibGljS2V5Jywge1xuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IHRoaXMudG9QdWJsaWNLZXkuYmluZCh0aGlzKVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgdG8gaW5zdGFudGlhdGUgUHJpdmF0ZUtleSBpbnRlcm5hbCBgaW5mb2Agb2JqZWN0IGZyb21cbiAqIGRpZmZlcmVudCBraW5kcyBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7TmV0d29ya3xzdHJpbmc9fSBuZXR3b3JrIC0gYSB7QGxpbmsgTmV0d29ya30gb2JqZWN0LCBvciBhIHN0cmluZyB3aXRoIHRoZSBuZXR3b3JrIG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuUHJpdmF0ZUtleS5wcm90b3R5cGUuX2NsYXNzaWZ5QXJndW1lbnRzID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaykge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cbiAgdmFyIGluZm8gPSB7XG4gICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICBuZXR3b3JrOiBuZXR3b3JrID8gTmV0d29ya3MuZ2V0KG5ldHdvcmspIDogTmV0d29ya3MuZGVmYXVsdE5ldHdvcmtcbiAgfTtcblxuICAvLyBkZXRlY3QgdHlwZSBvZiBkYXRhXG4gIGlmIChfLmlzVW5kZWZpbmVkKGRhdGEpIHx8IF8uaXNOdWxsKGRhdGEpKXtcbiAgICBpbmZvLmJuID0gUHJpdmF0ZUtleS5fZ2V0UmFuZG9tQk4oKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQk4pIHtcbiAgICBpbmZvLmJuID0gZGF0YTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgaW5mbyA9IFByaXZhdGVLZXkuX3RyYW5zZm9ybUJ1ZmZlcihkYXRhLCBuZXR3b3JrKTtcbiAgfSBlbHNlIGlmIChkYXRhLmJuICYmIGRhdGEubmV0d29yayl7XG4gICAgaW5mbyA9IFByaXZhdGVLZXkuX3RyYW5zZm9ybU9iamVjdChkYXRhKTtcbiAgfSBlbHNlIGlmICghbmV0d29yayAmJiBOZXR3b3Jrcy5nZXQoZGF0YSkpIHtcbiAgICBpbmZvLmJuID0gUHJpdmF0ZUtleS5fZ2V0UmFuZG9tQk4oKTtcbiAgICBpbmZvLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQoZGF0YSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKGRhdGEpID09PSAnc3RyaW5nJyl7XG4gICAgaWYgKEpTVXRpbC5pc0hleGEoZGF0YSkpIHtcbiAgICAgIGluZm8uYm4gPSBuZXcgQk4oZGF0YSwgJ2hleCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0gUHJpdmF0ZUtleS5fdHJhbnNmb3JtV0lGKGRhdGEsIG5ldHdvcmspO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBpcyBhbiB1bnJlY29nbml6ZWQgZGF0YSB0eXBlLicpO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBnZXQgYSByYW5kb20gQmlnIE51bWJlciAoQk4pXG4gKlxuICogQHJldHVybnMge0JOfSBBIG5ldyByYW5kb21seSBnZW5lcmF0ZWQgQk5cbiAqIEBwcml2YXRlXG4gKi9cblByaXZhdGVLZXkuX2dldFJhbmRvbUJOID0gZnVuY3Rpb24oKXtcbiAgdmFyIGNvbmRpdGlvbjtcbiAgdmFyIGJuO1xuICBkbyB7XG4gICAgdmFyIHByaXZidWYgPSBSYW5kb20uZ2V0UmFuZG9tQnVmZmVyKDMyKTtcbiAgICBibiA9IEJOLmZyb21CdWZmZXIocHJpdmJ1Zik7XG4gICAgY29uZGl0aW9uID0gYm4ubHQoUG9pbnQuZ2V0TigpKTtcbiAgfSB3aGlsZSAoIWNvbmRpdGlvbik7XG4gIHJldHVybiBibjtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGEgV0lGIEJ1ZmZlciBpbnRvIGEgcHJpdmF0ZSBrZXlcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gQW4gV0lGIHN0cmluZ1xuICogQHBhcmFtIHtOZXR3b3JrfHN0cmluZz19IG5ldHdvcmsgLSBhIHtAbGluayBOZXR3b3JrfSBvYmplY3QsIG9yIGEgc3RyaW5nIHdpdGggdGhlIG5ldHdvcmsgbmFtZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5czogYm4sIG5ldHdvcmsgYW5kIGNvbXByZXNzZWRcbiAqIEBwcml2YXRlXG4gKi9cblByaXZhdGVLZXkuX3RyYW5zZm9ybUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZiwgbmV0d29yaykge1xuXG4gIHZhciBpbmZvID0ge307XG5cbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDMyKSB7XG4gICAgcmV0dXJuIFByaXZhdGVLZXkuX3RyYW5zZm9ybUJOQnVmZmVyKGJ1ZiwgbmV0d29yayk7XG4gIH1cblxuICBpbmZvLm5ldHdvcmsgPSBOZXR3b3Jrcy5nZXQoYnVmWzBdLCAncHJpdmF0ZWtleScpO1xuXG4gIGlmICghaW5mby5uZXR3b3JrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5ldHdvcmsnKTtcbiAgfVxuXG4gIGlmIChuZXR3b3JrICYmIGluZm8ubmV0d29yayAhPT0gTmV0d29ya3MuZ2V0KG5ldHdvcmspKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBrZXkgbmV0d29yayBtaXNtYXRjaCcpO1xuICB9XG5cbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDEgKyAzMiArIDEgJiYgYnVmWzEgKyAzMiArIDEgLSAxXSA9PT0gMSkge1xuICAgIGluZm8uY29tcHJlc3NlZCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoYnVmLmxlbmd0aCA9PT0gMSArIDMyKSB7XG4gICAgaW5mby5jb21wcmVzc2VkID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggb2YgYnVmZmVyIG11c3QgYmUgMzMgKHVuY29tcHJlc3NlZCkgb3IgMzQgKGNvbXByZXNzZWQpJyk7XG4gIH1cblxuICBpbmZvLmJuID0gQk4uZnJvbUJ1ZmZlcihidWYuc2xpY2UoMSwgMzIgKyAxKSk7XG5cbiAgcmV0dXJuIGluZm87XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIEJOIGJ1ZmZlciBpbnRvIGEgcHJpdmF0ZSBrZXlcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcGFyYW0ge05ldHdvcmt8c3RyaW5nPX0gbmV0d29yayAtIGEge0BsaW5rIE5ldHdvcmt9IG9iamVjdCwgb3IgYSBzdHJpbmcgd2l0aCB0aGUgbmV0d29yayBuYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBhbiBPYmplY3Qgd2l0aCBrZXlzOiBibiwgbmV0d29yaywgYW5kIGNvbXByZXNzZWRcbiAqIEBwcml2YXRlXG4gKi9cblByaXZhdGVLZXkuX3RyYW5zZm9ybUJOQnVmZmVyID0gZnVuY3Rpb24oYnVmLCBuZXR3b3JrKSB7XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8ubmV0d29yayA9IE5ldHdvcmtzLmdldChuZXR3b3JrKSB8fCBOZXR3b3Jrcy5kZWZhdWx0TmV0d29yaztcbiAgaW5mby5ibiA9IEJOLmZyb21CdWZmZXIoYnVmKTtcbiAgaW5mby5jb21wcmVzc2VkID0gZmFsc2U7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBXSUYgc3RyaW5nIGludG8gYSBwcml2YXRlIGtleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBidWYgLSBBbiBXSUYgc3RyaW5nXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBrZXlzOiBibiwgbmV0d29yayBhbmQgY29tcHJlc3NlZFxuICogQHByaXZhdGVcbiAqL1xuUHJpdmF0ZUtleS5fdHJhbnNmb3JtV0lGID0gZnVuY3Rpb24oc3RyLCBuZXR3b3JrKSB7XG4gIHJldHVybiBQcml2YXRlS2V5Ll90cmFuc2Zvcm1CdWZmZXIoQmFzZTU4Q2hlY2suZGVjb2RlKHN0ciksIG5ldHdvcmspO1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIFByaXZhdGVLZXkgZnJvbSBhIEJ1ZmZlciB3aXRoIHRoZSBERVIgb3IgV0lGIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFyZ1xuICogQHBhcmFtIHtOZXR3b3JrfSBuZXR3b3JrXG4gKiBAcmV0dXJuIHtQcml2YXRlS2V5fVxuICovXG5Qcml2YXRlS2V5LmZyb21CdWZmZXIgPSBmdW5jdGlvbihhcmcsIG5ldHdvcmspIHtcbiAgcmV0dXJuIG5ldyBQcml2YXRlS2V5KGFyZywgbmV0d29yayk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIEpTT04gc3RyaW5nIG9uIHBsYWluIG9iamVjdCBpbnRvIGEgcHJpdmF0ZSBrZXlcbiAqIHJldHVybiB0aGlzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc29uIC0gQSBKU09OIHN0cmluZyBvciBwbGFpbiBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IGJuLCBuZXR3b3JrIGFuZCBjb21wcmVzc2VkXG4gKiBAcHJpdmF0ZVxuICovXG5Qcml2YXRlS2V5Ll90cmFuc2Zvcm1PYmplY3QgPSBmdW5jdGlvbihqc29uKSB7XG4gIHZhciBibiA9IG5ldyBCTihqc29uLmJuLCAnaGV4Jyk7XG4gIHZhciBuZXR3b3JrID0gTmV0d29ya3MuZ2V0KGpzb24ubmV0d29yayk7XG4gIHJldHVybiB7XG4gICAgYm46IGJuLFxuICAgIG5ldHdvcms6IG5ldHdvcmssXG4gICAgY29tcHJlc3NlZDoganNvbi5jb21wcmVzc2VkXG4gIH07XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHJpdmF0ZUtleSBmcm9tIGEgV0lGIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgV0lGIGVuY29kZWQgcHJpdmF0ZSBrZXkgc3RyaW5nXG4gKiBAcmV0dXJucyB7UHJpdmF0ZUtleX0gQSBuZXcgdmFsaWQgaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleVxuICovXG5Qcml2YXRlS2V5LmZyb21TdHJpbmcgPSBQcml2YXRlS2V5LmZyb21XSUYgPSBmdW5jdGlvbihzdHIpIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNTdHJpbmcoc3RyKSwgJ0ZpcnN0IGFyZ3VtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgc3RyaW5nLicpO1xuICByZXR1cm4gbmV3IFByaXZhdGVLZXkoc3RyKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYSBQcml2YXRlS2V5IGZyb20gYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb3V0cHV0IGZyb20gcHJpdmF0ZUtleS50b09iamVjdCgpXG4gKi9cblByaXZhdGVLZXkuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc09iamVjdChvYmopLCAnRmlyc3QgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LicpO1xuICByZXR1cm4gbmV3IFByaXZhdGVLZXkob2JqKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYSBQcml2YXRlS2V5IGZyb20gcmFuZG9tIGJ5dGVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBuZXR3b3JrIC0gRWl0aGVyIFwibGl2ZW5ldFwiIG9yIFwidGVzdG5ldFwiXG4gKiBAcmV0dXJucyB7UHJpdmF0ZUtleX0gQSBuZXcgdmFsaWQgaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleVxuICovXG5Qcml2YXRlS2V5LmZyb21SYW5kb20gPSBmdW5jdGlvbihuZXR3b3JrKSB7XG4gIHZhciBibiA9IFByaXZhdGVLZXkuX2dldFJhbmRvbUJOKCk7XG4gIHJldHVybiBuZXcgUHJpdmF0ZUtleShibiwgbmV0d29yayk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZXJlIHdvdWxkIGJlIGFueSBlcnJvcnMgd2hlbiBpbml0aWFsaXppbmcgYSBQcml2YXRlS2V5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICogQHBhcmFtIHtzdHJpbmc9fSBuZXR3b3JrIC0gRWl0aGVyIFwibGl2ZW5ldFwiIG9yIFwidGVzdG5ldFwiXG4gKiBAcmV0dXJucyB7bnVsbHxFcnJvcn0gQW4gZXJyb3IgaWYgZXhpc3RzXG4gKi9cblByaXZhdGVLZXkuZ2V0VmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oZGF0YSwgbmV0d29yaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgLyoganNoaW50IG5vbmV3OiBmYWxzZSAqL1xuICAgIG5ldyBQcml2YXRlS2V5KGRhdGEsIG5ldHdvcmspO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIHZhbGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICogQHBhcmFtIHtzdHJpbmc9fSBuZXR3b3JrIC0gRWl0aGVyIFwibGl2ZW5ldFwiIG9yIFwidGVzdG5ldFwiXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHByaXZhdGUga2V5IGlzIHdvdWxkIGJlIHZhbGlkXG4gKi9cblByaXZhdGVLZXkuaXNWYWxpZCA9IGZ1bmN0aW9uKGRhdGEsIG5ldHdvcmspe1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICFQcml2YXRlS2V5LmdldFZhbGlkYXRpb25FcnJvcihkYXRhLCBuZXR3b3JrKTtcbn07XG5cbi8qKlxuICogV2lsbCBvdXRwdXQgdGhlIFByaXZhdGVLZXkgZW5jb2RlZCBhcyBoZXggc3RyaW5nXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUHJpdmF0ZUtleS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG59O1xuXG4vKipcbiAqIFdpbGwgb3V0cHV0IHRoZSBQcml2YXRlS2V5IHRvIGEgV0lGIHN0cmluZ1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgV0lQIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleVxuICovXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b1dJRiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbmV0d29yayA9IHRoaXMubmV0d29yaztcbiAgdmFyIGNvbXByZXNzZWQgPSB0aGlzLmNvbXByZXNzZWQ7XG5cbiAgdmFyIGJ1ZjtcbiAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbbmV0d29yay5wcml2YXRla2V5XSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ibi50b0J1ZmZlcih7c2l6ZTogMzJ9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShbMHgwMV0pXSk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oW25ldHdvcmsucHJpdmF0ZWtleV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm4udG9CdWZmZXIoe3NpemU6IDMyfSldKTtcbiAgfVxuXG4gIHJldHVybiBCYXNlNThDaGVjay5lbmNvZGUoYnVmKTtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gdGhlIHByaXZhdGUga2V5IGFzIGEgQk4gaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJucyB7Qk59IEEgQk4gaW5zdGFuY2Ugb2YgdGhlIHByaXZhdGUga2V5XG4gKi9cblByaXZhdGVLZXkucHJvdG90eXBlLnRvQmlnTnVtYmVyID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuYm47XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIHRoZSBwcml2YXRlIGtleSBhcyBhIEJOIGJ1ZmZlclxuICpcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEEgYnVmZmVyIG9mIHRoZSBwcml2YXRlIGtleVxuICovXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLmJuLnRvQnVmZmVyKHtzaXplOiAzMn0pO1xufTtcblxuLyoqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCB3aWxsIG5vdCBiZSBvZmZpY2lhbGx5IHN1cHBvcnRlZCB1bnRpbCB2MS4wLjAuXG4gKlxuICpcbiAqIFdpbGwgcmV0dXJuIHRoZSBwcml2YXRlIGtleSBhcyBhIEJOIGJ1ZmZlciB3aXRob3V0IGxlYWRpbmcgemVybyBwYWRkaW5nXG4gKlxuICogQHJldHVybnMge0J1ZmZlcn0gQSBidWZmZXIgb2YgdGhlIHByaXZhdGUga2V5XG4gKi9cblByaXZhdGVLZXkucHJvdG90eXBlLnRvQnVmZmVyTm9QYWRkaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJuLnRvQnVmZmVyKCk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHB1YmxpYyBrZXlcbiAqXG4gKiBAcmV0dXJucyB7UHVibGljS2V5fSBBIHB1YmxpYyBrZXkgZ2VuZXJhdGVkIGZyb20gdGhlIHByaXZhdGUga2V5XG4gKi9cblByaXZhdGVLZXkucHJvdG90eXBlLnRvUHVibGljS2V5ID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9wdWJrZXkpIHtcbiAgICB0aGlzLl9wdWJrZXkgPSBQdWJsaWNLZXkuZnJvbVByaXZhdGVLZXkodGhpcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3B1YmtleTtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYW4gYWRkcmVzcyBmb3IgdGhlIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge05ldHdvcms9fSBuZXR3b3JrIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHNwZWNpZnlpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gRWl0aGVyICdwdWJrZXloYXNoJywgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3NjcmlwdGhhc2gnXG4gKiB0aGUgZGVzaXJlZCBuZXR3b3JrIGZvciB0aGUgYWRkcmVzc1xuICpcbiAqIEByZXR1cm5zIHtBZGRyZXNzfSBBbiBhZGRyZXNzIGdlbmVyYXRlZCBmcm9tIHRoZSBwcml2YXRlIGtleVxuICovXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b0FkZHJlc3MgPSBmdW5jdGlvbihuZXR3b3JrLCB0eXBlKSB7XG4gIHZhciBwdWJrZXkgPSB0aGlzLnRvUHVibGljS2V5KCk7XG4gIHJldHVybiBBZGRyZXNzLmZyb21QdWJsaWNLZXkocHVia2V5LCBuZXR3b3JrIHx8IHRoaXMubmV0d29yaywgdHlwZSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gKi9cblByaXZhdGVLZXkucHJvdG90eXBlLnRvT2JqZWN0ID0gUHJpdmF0ZUtleS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgYm46IHRoaXMuYm4udG9TdHJpbmcoJ2hleCcpLFxuICAgIGNvbXByZXNzZWQ6IHRoaXMuY29tcHJlc3NlZCxcbiAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmsudG9TdHJpbmcoKVxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0d2Vha2VkIHZlcnNpb24gb2YgdGhpcyBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IG1lcmtsZVJvb3QgKG9wdGlvbmFsKVxuICogQHJldHVybnMge3sgdHdlYWtlZFByaXZLZXk6IEJ1ZmZlciB9fVxuICovXG5Qcml2YXRlS2V5LnByb3RvdHlwZS5jcmVhdGVUYXBUd2VhayA9IGZ1bmN0aW9uKG1lcmtsZVJvb3QpIHtcbiAgY29uc3Qgb3JkZXIgPSBQb2ludC5nZXROKCk7XG4gIGNvbnN0IFAgPSBQb2ludC5nZXRHKCkubXVsKHRoaXMuYm4pO1xuICBjb25zdCBzZWNLZXkgPSBQLnkuaXNFdmVuKCkgPyB0aGlzLmJuIDogb3JkZXIuc3ViKHRoaXMuYm4pO1xuICBjb25zdCB0YWdnZWRXcml0ZXIgPSBuZXcgVGFnZ2VkSGFzaCgnVGFwVHdlYWsnKTtcbiAgdGFnZ2VkV3JpdGVyLndyaXRlKFAueC50b0J1ZmZlcih7IHNpemU6IDMyIH0pKTtcblxuICBpZiAobWVya2xlUm9vdCkge1xuICAgICQuY2hlY2tBcmd1bWVudChCdWZmZXIuaXNCdWZmZXIobWVya2xlUm9vdCkgJiYgbWVya2xlUm9vdC5sZW5ndGggPT09IDMyLCAnbWVya2xlUm9vdCBtdXN0IGJlIDMyIGJ5dGUgYnVmZmVyJyk7XG4gICAgdGFnZ2VkV3JpdGVyLndyaXRlKG1lcmtsZVJvb3QpO1xuICB9XG4gIGNvbnN0IHR3ZWFrSGFzaCA9IHRhZ2dlZFdyaXRlci5maW5hbGl6ZSgpO1xuXG4gICQuY2hlY2tTdGF0ZShCTi5mcm9tQnVmZmVyKHR3ZWFrSGFzaCkubHQob3JkZXIpLCAnVGFwVHdlYWsgaGFzaCBmYWlsZWQgc2VjcDI1NmsxIG9yZGVyIGNoZWNrJyk7XG4gIHJldHVybiB7XG4gICAgdHdlYWtlZFByaXZLZXk6IHNlY0tleS5hZGQobmV3IEJOKHR3ZWFrSGFzaCkpLm1vZChvcmRlcikudG9CdWZmZXIoeyBzaXplOiAzMiB9KVxuICB9O1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIHN0cmluZyBmb3JtYXR0ZWQgZm9yIHRoZSBjb25zb2xlXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gUHJpdmF0ZSBrZXlcbiAqL1xuUHJpdmF0ZUtleS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdW5jb21wcmVzc2VkID0gIXRoaXMuY29tcHJlc3NlZCA/ICcsIHVuY29tcHJlc3NlZCcgOiAnJztcbiAgcmV0dXJuICc8UHJpdmF0ZUtleTogJyArIHRoaXMudG9TdHJpbmcoKSArICcsIG5ldHdvcms6ICcgKyB0aGlzLm5ldHdvcmsgKyB1bmNvbXByZXNzZWQgKyAnPic7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByaXZhdGVLZXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/publickey.js":
/*!***************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/publickey.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! ./crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar Point = __webpack_require__(/*! ./crypto/point */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/point.js\");\nvar Hash = __webpack_require__(/*! ./crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar JSUtil = __webpack_require__(/*! ./util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar Network = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst TaggedHash = __webpack_require__(/*! ./crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\nfunction PublicKey(data, extra) {\n\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra);\n\n  // validation\n  info.point.validate();\n\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n\n  return this;\n};\n\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\nPublicKey.prototype._classifyArgs = function(data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  };\n\n  // detect type of data\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof(data) === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n  return info;\n};\n\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isPrivateKey = function(param) {\n  var PrivateKey = __webpack_require__(/*! ./privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\n  return param instanceof PrivateKey;\n};\n\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isBuffer = function(param) {\n  return (param instanceof Buffer) || (param instanceof Uint8Array);\n};\n\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformDER = function(buf, strict) {\n  /* jshint maxstatements: 30 */\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n\n  strict = _.isUndefined(strict) ? true : strict;\n\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n  return info;\n};\n\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformX = function(odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformObject = function(json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = PublicKey._transformPrivateKey(privkey);\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf A DER buffer (33+ bytes) or a 32 byte X-only coordinate (taproot only)\n * @param {Boolean} strict (optional; Only applies to DER format) If set to false, will loosen some conditions\n * @returns {PublicKey}\n */\nPublicKey.fromBuffer = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key or 32 byte X coordinate (taproot)');\n  if (buf.length === 32) {\n    return PublicKey.fromX(false, buf);\n  }\n  return PublicKey.fromDER(buf, strict);\n}\n\n/**\n * Instantiate a PublicKey from a DER buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromDER = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = PublicKey._transformDER(buf, strict);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPoint = function(point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromString = function(str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n  var info = PublicKey._transformDER(buf);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromX = function(odd, x) {\n  var info = PublicKey._transformX(odd, x);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * PublicKey instance from a Taproot (32-byte) public key\n * @param {String|Buffer} hexBuf \n * @returns {PublicKey}\n */\nPublicKey.fromTaproot = function(hexBuf) {\n  if (typeof hexBuf === 'string' && JSUtil.isHexaString(hexBuf)) {\n    hexBuf = Buffer.from(hexBuf, 'hex');\n  }\n  $.checkArgument(Buffer.isBuffer(hexBuf), 'hexBuf must be a hex string or buffer');\n  $.checkArgument(hexBuf.length === 32, 'Taproot public keys must be 32 bytes');\n  return new PublicKey.fromX(false, hexBuf);\n}\n\n/**\n * Verifies if the input is a valid Taproot public key\n * @param {String|Buffer} hexBuf \n * @returns {Boolean}\n */\nPublicKey.isValidTaproot = function(hexBuf) {\n  try {\n    return !!PublicKey.fromTaproot(hexBuf);\n  } catch (e) {\n    return false;\n  }\n};\n\n\n/**\n * Get the TapTweak tagged hash of this pub key and the merkleRoot\n * @param {Buffer} merkleRoot (optional)\n * @returns {Buffer}\n */\nPublicKey.prototype.computeTapTweakHash = function(merkleRoot) {\n  const taggedWriter = new TaggedHash('TapTweak');\n  taggedWriter.write(this.point.x.toBuffer({ size: 32 }));\n\n  //  If !merkleRoot, then we have no scripts. The actual tweak does not matter, but \n  //  follow BIP341 here to allow for reproducible tweaking.\n\n  if (merkleRoot) {\n    $.checkArgument(Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32, 'merkleRoot must be 32 byte buffer');\n    taggedWriter.write(merkleRoot);\n  }\n  const tweakHash = taggedWriter.finalize();\n  \n  const order = Point.getN();\n  $.checkState(BN.fromBuffer(tweakHash).lt(order), 'TapTweak hash failed secp256k1 order check');\n  return tweakHash;\n};\n\n\n/**\n * Verify a tweaked public key against this key\n * @param {PublicKey|Buffer} p Tweaked pub key\n * @param {Buffer} merkleRoot (optional)\n * @param {Buffer} control \n * @returns {Boolean}\n */\nPublicKey.prototype.checkTapTweak = function(p, merkleRoot, control) {\n  if (Buffer.isBuffer(p)) {\n    p = PublicKey.fromTaproot(p);\n  }\n  const tweak = p.computeTapTweakHash(merkleRoot);\n\n  const P = p.point.liftX();\n  const Q = P.add(this.point.curve.g.mul(BN.fromBuffer(tweak)));\n  \n  return this.point.x.eq(Q.x) && Q.y.mod(new BN(2)).eq(new BN(control[0] & 1));\n};\n\n\n/**\n * Create a tweaked version of this pub key\n * @param {Buffer} merkleRoot (optional)\n * @returns {{ parity: Number, tweakedPubKey: Buffer }}\n */\nPublicKey.prototype.createTapTweak = function(merkleRoot) {\n  $.checkArgument(merkleRoot == null || (Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32), 'merkleRoot must be a 32 byte buffer');\n\n  let t = this.computeTapTweakHash(merkleRoot);\n  t = new BN(t);\n  const Q = this.point.liftX().add(Point.getG().mul(t));\n  const parity = Q.y.isEven() ? 0 : 1;\n  return {\n    parity,\n    tweakedPubKey: Q.x.toBuffer()\n  };\n};\n\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\nPublicKey.getValidationError = function(data) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\nPublicKey.isValid = function(data) {\n  return !PublicKey.getValidationError(data);\n};\n\n/**\n * @returns {Object} A plain object of the PublicKey\n */\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {\n  var x = this.point.getX();\n  var y = this.point.getY();\n\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n\n  var prefix;\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n    if (odd) {\n      prefix = Buffer.from([0x03]);\n    } else {\n      prefix = Buffer.from([0x02]);\n    }\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} An address generated from the public key\n */\nPublicKey.prototype.toAddress = function(network, type) {\n  var Address = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\n  return Address.fromPublicKey(this, network || this.network, type);\n};\n\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\nPublicKey.prototype.toString = function() {\n  return this.toDER().toString('hex');\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\nPublicKey.prototype.inspect = function() {\n  return '<PublicKey: ' + this.toString() +\n    (this.compressed ? '' : ', uncompressed') + '>';\n};\n\n\nmodule.exports = PublicKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3B1YmxpY2tleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsc0VBQWE7QUFDOUIsWUFBWSxtQkFBTyxDQUFDLDRFQUFnQjtBQUNwQyxXQUFXLG1CQUFPLENBQUMsMEVBQWU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBWTtBQUNsQyxRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBcUI7O0FBRWhEO0FBQ0EsbUNBQW1DLGlCQUFpQixHQUFHLFlBQVk7QUFDbkU7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTLGtCQUFrQjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFXO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9wdWJsaWNrZXkuanM/Yzk4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJy4vY3J5cHRvL2JuJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL2NyeXB0by9wb2ludCcpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuL2NyeXB0by9oYXNoJyk7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi91dGlsL2pzJyk7XG52YXIgTmV0d29yayA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5jb25zdCBUYWdnZWRIYXNoID0gcmVxdWlyZSgnLi9jcnlwdG8vdGFnZ2VkaGFzaCcpO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHVibGljS2V5IGZyb20gYSB7QGxpbmsgUHJpdmF0ZUtleX0sIHtAbGluayBQb2ludH0sIGBzdHJpbmdgLCBvciBgQnVmZmVyYC5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGludGVybmFsIHByb3BlcnRpZXMsIGBuZXR3b3JrYCBhbmQgYGNvbXByZXNzZWRgLCB0aGF0IGRlYWwgd2l0aCBpbXBvcnRpbmdcbiAqIGEgUHVibGljS2V5IGZyb20gYSBQcml2YXRlS2V5IGluIFdJRiBmb3JtYXQuIE1vcmUgZGV0YWlscyBkZXNjcmliZWQgb24ge0BsaW5rIFByaXZhdGVLZXl9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIGluc3RhbnRpYXRlIGZyb20gYSBwcml2YXRlIGtleVxuICogdmFyIGtleSA9IFB1YmxpY0tleShwcml2YXRlS2V5LCB0cnVlKTtcbiAqXG4gKiAvLyBleHBvcnQgdG8gYXMgYSBERVIgaGV4IGVuY29kZWQgc3RyaW5nXG4gKiB2YXIgZXhwb3J0ZWQgPSBrZXkudG9TdHJpbmcoKTtcbiAqXG4gKiAvLyBpbXBvcnQgdGhlIHB1YmxpYyBrZXlcbiAqIHZhciBpbXBvcnRlZCA9IFB1YmxpY0tleS5mcm9tU3RyaW5nKGV4cG9ydGVkKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGVuY29kZWQgZGF0YSBpbiB2YXJpb3VzIGZvcm1hdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSAtIGFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtOZXR3b3JrPX0gZXh0cmEubmV0d29yayAtIFdoaWNoIG5ldHdvcmsgc2hvdWxkIHRoZSBhZGRyZXNzIGZvciB0aGlzIHB1YmxpYyBrZXkgYmUgZm9yXG4gKiBAcGFyYW0ge1N0cmluZz19IGV4dHJhLmNvbXByZXNzZWQgLSBJZiB0aGUgcHVibGljIGtleSBpcyBjb21wcmVzc2VkXG4gKiBAcmV0dXJucyB7UHVibGljS2V5fSBBIG5ldyB2YWxpZCBpbnN0YW5jZSBvZiBhbiBQdWJsaWNLZXlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQdWJsaWNLZXkoZGF0YSwgZXh0cmEpIHtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHVibGljS2V5KSkge1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KGRhdGEsIGV4dHJhKTtcbiAgfVxuXG4gICQuY2hlY2tBcmd1bWVudChkYXRhLCAnRmlyc3QgYXJndW1lbnQgaXMgcmVxdWlyZWQsIHBsZWFzZSBpbmNsdWRlIHB1YmxpYyBrZXkgZGF0YS4nKTtcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFB1YmxpY0tleSkge1xuICAgIC8vIFJldHVybiBjb3B5LCBidXQgYXMgaXQncyBhbiBpbW11dGFibGUgb2JqZWN0LCByZXR1cm4gc2FtZSBhcmd1bWVudFxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGV4dHJhID0gZXh0cmEgfHwge307XG5cbiAgdmFyIGluZm8gPSB0aGlzLl9jbGFzc2lmeUFyZ3MoZGF0YSwgZXh0cmEpO1xuXG4gIC8vIHZhbGlkYXRpb25cbiAgaW5mby5wb2ludC52YWxpZGF0ZSgpO1xuXG4gIEpTVXRpbC5kZWZpbmVJbW11dGFibGUodGhpcywge1xuICAgIHBvaW50OiBpbmZvLnBvaW50LFxuICAgIGNvbXByZXNzZWQ6IGluZm8uY29tcHJlc3NlZCxcbiAgICBuZXR3b3JrOiBpbmZvLm5ldHdvcmsgfHwgTmV0d29yay5kZWZhdWx0TmV0d29ya1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLl9jbGFzc2lmeUFyZ3MgPSBmdW5jdGlvbihkYXRhLCBleHRyYSkge1xuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cbiAgdmFyIGluZm8gPSB7XG4gICAgY29tcHJlc3NlZDogXy5pc1VuZGVmaW5lZChleHRyYS5jb21wcmVzc2VkKSB8fCBleHRyYS5jb21wcmVzc2VkXG4gIH07XG5cbiAgLy8gZGV0ZWN0IHR5cGUgb2YgZGF0YVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgaW5mby5wb2ludCA9IGRhdGE7XG4gIH0gZWxzZSBpZiAoZGF0YS54ICYmIGRhdGEueSkge1xuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybU9iamVjdChkYXRhKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YoZGF0YSkgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtREVSKEJ1ZmZlci5mcm9tKGRhdGEsICdoZXgnKSk7XG4gIH0gZWxzZSBpZiAoUHVibGljS2V5Ll9pc0J1ZmZlcihkYXRhKSkge1xuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybURFUihkYXRhKTtcbiAgfSBlbHNlIGlmIChQdWJsaWNLZXkuX2lzUHJpdmF0ZUtleShkYXRhKSkge1xuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybVByaXZhdGVLZXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgaXMgYW4gdW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0LicpO1xuICB9XG4gIGlmICghaW5mby5uZXR3b3JrKSB7XG4gICAgaW5mby5uZXR3b3JrID0gXy5pc1VuZGVmaW5lZChleHRyYS5uZXR3b3JrKSA/IHVuZGVmaW5lZCA6IE5ldHdvcmsuZ2V0KGV4dHJhLm5ldHdvcmspO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBkZXRlY3QgaWYgYW4gb2JqZWN0IGlzIGEge0BsaW5rIFByaXZhdGVLZXl9XG4gKlxuICogQHBhcmFtIHsqfSBwYXJhbSAtIG9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cblB1YmxpY0tleS5faXNQcml2YXRlS2V5ID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgdmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuL3ByaXZhdGVrZXknKTtcbiAgcmV0dXJuIHBhcmFtIGluc3RhbmNlb2YgUHJpdmF0ZUtleTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZGV0ZWN0IGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gcGFyYW0gLSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5QdWJsaWNLZXkuX2lzQnVmZmVyID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgcmV0dXJuIChwYXJhbSBpbnN0YW5jZW9mIEJ1ZmZlcikgfHwgKHBhcmFtIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIHByaXZhdGUga2V5IGludG8gYSBwdWJsaWMga2V5IHBvaW50XG4gKlxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2a2V5IC0gQW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5czogcG9pbnQgYW5kIGNvbXByZXNzZWRcbiAqIEBwcml2YXRlXG4gKi9cblB1YmxpY0tleS5fdHJhbnNmb3JtUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHByaXZrZXkpIHtcbiAgJC5jaGVja0FyZ3VtZW50KFB1YmxpY0tleS5faXNQcml2YXRlS2V5KHByaXZrZXkpLCAnTXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQcml2YXRlS2V5Jyk7XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8ucG9pbnQgPSBQb2ludC5nZXRHKCkubXVsKHByaXZrZXkuYm4pO1xuICBpbmZvLmNvbXByZXNzZWQgPSBwcml2a2V5LmNvbXByZXNzZWQ7XG4gIGluZm8ubmV0d29yayA9IHByaXZrZXkubmV0d29yaztcbiAgcmV0dXJuIGluZm87XG59O1xuXG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBERVIgaW50byBhIHB1YmxpYyBrZXkgcG9pbnRcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gQW4gaGV4IGVuY29kZWQgYnVmZmVyXG4gKiBAcGFyYW0ge2Jvb2w9fSBzdHJpY3QgLSBpZiBzZXQgdG8gZmFsc2UsIHdpbGwgbG9vc2VuIHNvbWUgY29uZGl0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGgga2V5czogcG9pbnQgYW5kIGNvbXByZXNzZWRcbiAqIEBwcml2YXRlXG4gKi9cblB1YmxpY0tleS5fdHJhbnNmb3JtREVSID0gZnVuY3Rpb24oYnVmLCBzdHJpY3QpIHtcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDMwICovXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxMiAqL1xuICAkLmNoZWNrQXJndW1lbnQoUHVibGljS2V5Ll9pc0J1ZmZlcihidWYpLCAnTXVzdCBiZSBhIGhleCBidWZmZXIgb2YgREVSIGVuY29kZWQgcHVibGljIGtleScpO1xuICB2YXIgaW5mbyA9IHt9O1xuXG4gIHN0cmljdCA9IF8uaXNVbmRlZmluZWQoc3RyaWN0KSA/IHRydWUgOiBzdHJpY3Q7XG5cbiAgdmFyIHg7XG4gIHZhciB5O1xuICB2YXIgeGJ1ZjtcbiAgdmFyIHlidWY7XG5cbiAgaWYgKGJ1ZlswXSA9PT0gMHgwNCB8fCAoIXN0cmljdCAmJiAoYnVmWzBdID09PSAweDA2IHx8IGJ1ZlswXSA9PT0gMHgwNykpKSB7XG4gICAgeGJ1ZiA9IGJ1Zi5zbGljZSgxLCAzMyk7XG4gICAgeWJ1ZiA9IGJ1Zi5zbGljZSgzMywgNjUpO1xuICAgIGlmICh4YnVmLmxlbmd0aCAhPT0gMzIgfHwgeWJ1Zi5sZW5ndGggIT09IDMyIHx8IGJ1Zi5sZW5ndGggIT09IDY1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMZW5ndGggb2YgeCBhbmQgeSBtdXN0IGJlIDMyIGJ5dGVzJyk7XG4gICAgfVxuICAgIHggPSBuZXcgQk4oeGJ1Zik7XG4gICAgeSA9IG5ldyBCTih5YnVmKTtcbiAgICBpbmZvLnBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgIGluZm8uY29tcHJlc3NlZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHgwMykge1xuICAgIHhidWYgPSBidWYuc2xpY2UoMSk7XG4gICAgeCA9IG5ldyBCTih4YnVmKTtcbiAgICBpbmZvID0gUHVibGljS2V5Ll90cmFuc2Zvcm1YKHRydWUsIHgpO1xuICAgIGluZm8uY29tcHJlc3NlZCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoYnVmWzBdID09PSAweDAyKSB7XG4gICAgeGJ1ZiA9IGJ1Zi5zbGljZSgxKTtcbiAgICB4ID0gbmV3IEJOKHhidWYpO1xuICAgIGluZm8gPSBQdWJsaWNLZXkuX3RyYW5zZm9ybVgoZmFsc2UsIHgpO1xuICAgIGluZm8uY29tcHJlc3NlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBERVIgZm9ybWF0IHB1YmxpYyBrZXknKTtcbiAgfVxuICByZXR1cm4gaW5mbztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIFggaW50byBhIHB1YmxpYyBrZXkgcG9pbnRcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9kZCAtIElmIHRoZSBwb2ludCBpcyBhYm92ZSBvciBiZWxvdyB0aGUgeCBheGlzXG4gKiBAcGFyYW0ge1BvaW50fSB4IC0gVGhlIHggcG9pbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IHBvaW50IGFuZCBjb21wcmVzc2VkXG4gKiBAcHJpdmF0ZVxuICovXG5QdWJsaWNLZXkuX3RyYW5zZm9ybVggPSBmdW5jdGlvbihvZGQsIHgpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHR5cGVvZiBvZGQgPT09ICdib29sZWFuJywgJ011c3Qgc3BlY2lmeSB3aGV0aGVyIHkgaXMgb2RkIG9yIG5vdCAodHJ1ZSBvciBmYWxzZSknKTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5wb2ludCA9IFBvaW50LmZyb21YKG9kZCwgeCk7XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBKU09OIGludG8gYSBwdWJsaWMga2V5IHBvaW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIC0gYSBKU09OIHN0cmluZyBvciBwbGFpbiBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXM6IHBvaW50IGFuZCBjb21wcmVzc2VkXG4gKiBAcHJpdmF0ZVxuICovXG5QdWJsaWNLZXkuX3RyYW5zZm9ybU9iamVjdCA9IGZ1bmN0aW9uKGpzb24pIHtcbiAgdmFyIHggPSBuZXcgQk4oanNvbi54LCAnaGV4Jyk7XG4gIHZhciB5ID0gbmV3IEJOKGpzb24ueSwgJ2hleCcpO1xuICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gIHJldHVybiBuZXcgUHVibGljS2V5KHBvaW50LCB7XG4gICAgY29tcHJlc3NlZDoganNvbi5jb21wcmVzc2VkXG4gIH0pO1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIFB1YmxpY0tleSBmcm9tIGEgUHJpdmF0ZUtleVxuICpcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmtleSAtIEFuIGluc3RhbmNlIG9mIFByaXZhdGVLZXlcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFB1YmxpY0tleVxuICovXG5QdWJsaWNLZXkuZnJvbVByaXZhdGVLZXkgPSBmdW5jdGlvbihwcml2a2V5KSB7XG4gICQuY2hlY2tBcmd1bWVudChQdWJsaWNLZXkuX2lzUHJpdmF0ZUtleShwcml2a2V5KSwgJ011c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUHJpdmF0ZUtleScpO1xuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtUHJpdmF0ZUtleShwcml2a2V5KTtcbiAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoaW5mby5wb2ludCwge1xuICAgIGNvbXByZXNzZWQ6IGluZm8uY29tcHJlc3NlZCxcbiAgICBuZXR3b3JrOiBpbmZvLm5ldHdvcmtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHVibGljS2V5IGZyb20gYSBCdWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgQSBERVIgYnVmZmVyICgzMysgYnl0ZXMpIG9yIGEgMzIgYnl0ZSBYLW9ubHkgY29vcmRpbmF0ZSAodGFwcm9vdCBvbmx5KVxuICogQHBhcmFtIHtCb29sZWFufSBzdHJpY3QgKG9wdGlvbmFsOyBPbmx5IGFwcGxpZXMgdG8gREVSIGZvcm1hdCkgSWYgc2V0IHRvIGZhbHNlLCB3aWxsIGxvb3NlbiBzb21lIGNvbmRpdGlvbnNcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9XG4gKi9cblB1YmxpY0tleS5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmLCBzdHJpY3QpIHtcbiAgJC5jaGVja0FyZ3VtZW50KFB1YmxpY0tleS5faXNCdWZmZXIoYnVmKSwgJ011c3QgYmUgYSBoZXggYnVmZmVyIG9mIERFUiBlbmNvZGVkIHB1YmxpYyBrZXkgb3IgMzIgYnl0ZSBYIGNvb3JkaW5hdGUgKHRhcHJvb3QpJyk7XG4gIGlmIChidWYubGVuZ3RoID09PSAzMikge1xuICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVgoZmFsc2UsIGJ1Zik7XG4gIH1cbiAgcmV0dXJuIFB1YmxpY0tleS5mcm9tREVSKGJ1Ziwgc3RyaWN0KTtcbn1cblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhIFB1YmxpY0tleSBmcm9tIGEgREVSIGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIEEgREVSIGhleCBidWZmZXJcbiAqIEBwYXJhbSB7Ym9vbD19IHN0cmljdCAtIGlmIHNldCB0byBmYWxzZSwgd2lsbCBsb29zZW4gc29tZSBjb25kaXRpb25zXG4gKiBAcmV0dXJucyB7UHVibGljS2V5fSBBIG5ldyB2YWxpZCBpbnN0YW5jZSBvZiBQdWJsaWNLZXlcbiAqL1xuUHVibGljS2V5LmZyb21ERVIgPSBmdW5jdGlvbihidWYsIHN0cmljdCkge1xuICAkLmNoZWNrQXJndW1lbnQoUHVibGljS2V5Ll9pc0J1ZmZlcihidWYpLCAnTXVzdCBiZSBhIGhleCBidWZmZXIgb2YgREVSIGVuY29kZWQgcHVibGljIGtleScpO1xuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtREVSKGJ1Ziwgc3RyaWN0KTtcbiAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoaW5mby5wb2ludCwge1xuICAgIGNvbXByZXNzZWQ6IGluZm8uY29tcHJlc3NlZFxuICB9KTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYSBQdWJsaWNLZXkgZnJvbSBhIFBvaW50XG4gKlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIFBvaW50IGluc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBjb21wcmVzc2VkIC0gd2hldGhlciB0byBzdG9yZSB0aGlzIHB1YmxpYyBrZXkgYXMgY29tcHJlc3NlZCBmb3JtYXRcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFB1YmxpY0tleVxuICovXG5QdWJsaWNLZXkuZnJvbVBvaW50ID0gZnVuY3Rpb24ocG9pbnQsIGNvbXByZXNzZWQpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHBvaW50IGluc3RhbmNlb2YgUG9pbnQsICdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFBvaW50LicpO1xuICByZXR1cm4gbmV3IFB1YmxpY0tleShwb2ludCwge1xuICAgIGNvbXByZXNzZWQ6IGNvbXByZXNzZWRcbiAgfSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHVibGljS2V5IGZyb20gYSBERVIgaGV4IGVuY29kZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIEEgREVSIGhleCBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nPX0gZW5jb2RpbmcgLSBUaGUgdHlwZSBvZiBzdHJpbmcgZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IEEgbmV3IHZhbGlkIGluc3RhbmNlIG9mIFB1YmxpY0tleVxuICovXG5QdWJsaWNLZXkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0ciwgZW5jb2RpbmcgfHwgJ2hleCcpO1xuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtREVSKGJ1Zik7XG4gIHJldHVybiBuZXcgUHVibGljS2V5KGluZm8ucG9pbnQsIHtcbiAgICBjb21wcmVzc2VkOiBpbmZvLmNvbXByZXNzZWRcbiAgfSk7XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgUHVibGljS2V5IGZyb20gYW4gWCBQb2ludFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb2RkIC0gSWYgdGhlIHBvaW50IGlzIGFib3ZlIG9yIGJlbG93IHRoZSB4IGF4aXNcbiAqIEBwYXJhbSB7UG9pbnR9IHggLSBUaGUgeCBwb2ludFxuICogQHJldHVybnMge1B1YmxpY0tleX0gQSBuZXcgdmFsaWQgaW5zdGFuY2Ugb2YgUHVibGljS2V5XG4gKi9cblB1YmxpY0tleS5mcm9tWCA9IGZ1bmN0aW9uKG9kZCwgeCkge1xuICB2YXIgaW5mbyA9IFB1YmxpY0tleS5fdHJhbnNmb3JtWChvZGQsIHgpO1xuICByZXR1cm4gbmV3IFB1YmxpY0tleShpbmZvLnBvaW50LCB7XG4gICAgY29tcHJlc3NlZDogaW5mby5jb21wcmVzc2VkXG4gIH0pO1xufTtcblxuLyoqXG4gKiBQdWJsaWNLZXkgaW5zdGFuY2UgZnJvbSBhIFRhcHJvb3QgKDMyLWJ5dGUpIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gaGV4QnVmIFxuICogQHJldHVybnMge1B1YmxpY0tleX1cbiAqL1xuUHVibGljS2V5LmZyb21UYXByb290ID0gZnVuY3Rpb24oaGV4QnVmKSB7XG4gIGlmICh0eXBlb2YgaGV4QnVmID09PSAnc3RyaW5nJyAmJiBKU1V0aWwuaXNIZXhhU3RyaW5nKGhleEJ1ZikpIHtcbiAgICBoZXhCdWYgPSBCdWZmZXIuZnJvbShoZXhCdWYsICdoZXgnKTtcbiAgfVxuICAkLmNoZWNrQXJndW1lbnQoQnVmZmVyLmlzQnVmZmVyKGhleEJ1ZiksICdoZXhCdWYgbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYnVmZmVyJyk7XG4gICQuY2hlY2tBcmd1bWVudChoZXhCdWYubGVuZ3RoID09PSAzMiwgJ1RhcHJvb3QgcHVibGljIGtleXMgbXVzdCBiZSAzMiBieXRlcycpO1xuICByZXR1cm4gbmV3IFB1YmxpY0tleS5mcm9tWChmYWxzZSwgaGV4QnVmKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyBpZiB0aGUgaW5wdXQgaXMgYSB2YWxpZCBUYXByb290IHB1YmxpYyBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gaGV4QnVmIFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblB1YmxpY0tleS5pc1ZhbGlkVGFwcm9vdCA9IGZ1bmN0aW9uKGhleEJ1Zikge1xuICB0cnkge1xuICAgIHJldHVybiAhIVB1YmxpY0tleS5mcm9tVGFwcm9vdChoZXhCdWYpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBUYXBUd2VhayB0YWdnZWQgaGFzaCBvZiB0aGlzIHB1YiBrZXkgYW5kIHRoZSBtZXJrbGVSb290XG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVya2xlUm9vdCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLmNvbXB1dGVUYXBUd2Vha0hhc2ggPSBmdW5jdGlvbihtZXJrbGVSb290KSB7XG4gIGNvbnN0IHRhZ2dlZFdyaXRlciA9IG5ldyBUYWdnZWRIYXNoKCdUYXBUd2VhaycpO1xuICB0YWdnZWRXcml0ZXIud3JpdGUodGhpcy5wb2ludC54LnRvQnVmZmVyKHsgc2l6ZTogMzIgfSkpO1xuXG4gIC8vICBJZiAhbWVya2xlUm9vdCwgdGhlbiB3ZSBoYXZlIG5vIHNjcmlwdHMuIFRoZSBhY3R1YWwgdHdlYWsgZG9lcyBub3QgbWF0dGVyLCBidXQgXG4gIC8vICBmb2xsb3cgQklQMzQxIGhlcmUgdG8gYWxsb3cgZm9yIHJlcHJvZHVjaWJsZSB0d2Vha2luZy5cblxuICBpZiAobWVya2xlUm9vdCkge1xuICAgICQuY2hlY2tBcmd1bWVudChCdWZmZXIuaXNCdWZmZXIobWVya2xlUm9vdCkgJiYgbWVya2xlUm9vdC5sZW5ndGggPT09IDMyLCAnbWVya2xlUm9vdCBtdXN0IGJlIDMyIGJ5dGUgYnVmZmVyJyk7XG4gICAgdGFnZ2VkV3JpdGVyLndyaXRlKG1lcmtsZVJvb3QpO1xuICB9XG4gIGNvbnN0IHR3ZWFrSGFzaCA9IHRhZ2dlZFdyaXRlci5maW5hbGl6ZSgpO1xuICBcbiAgY29uc3Qgb3JkZXIgPSBQb2ludC5nZXROKCk7XG4gICQuY2hlY2tTdGF0ZShCTi5mcm9tQnVmZmVyKHR3ZWFrSGFzaCkubHQob3JkZXIpLCAnVGFwVHdlYWsgaGFzaCBmYWlsZWQgc2VjcDI1NmsxIG9yZGVyIGNoZWNrJyk7XG4gIHJldHVybiB0d2Vha0hhc2g7XG59O1xuXG5cbi8qKlxuICogVmVyaWZ5IGEgdHdlYWtlZCBwdWJsaWMga2V5IGFnYWluc3QgdGhpcyBrZXlcbiAqIEBwYXJhbSB7UHVibGljS2V5fEJ1ZmZlcn0gcCBUd2Vha2VkIHB1YiBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXJrbGVSb290IChvcHRpb25hbClcbiAqIEBwYXJhbSB7QnVmZmVyfSBjb250cm9sIFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblB1YmxpY0tleS5wcm90b3R5cGUuY2hlY2tUYXBUd2VhayA9IGZ1bmN0aW9uKHAsIG1lcmtsZVJvb3QsIGNvbnRyb2wpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwKSkge1xuICAgIHAgPSBQdWJsaWNLZXkuZnJvbVRhcHJvb3QocCk7XG4gIH1cbiAgY29uc3QgdHdlYWsgPSBwLmNvbXB1dGVUYXBUd2Vha0hhc2gobWVya2xlUm9vdCk7XG5cbiAgY29uc3QgUCA9IHAucG9pbnQubGlmdFgoKTtcbiAgY29uc3QgUSA9IFAuYWRkKHRoaXMucG9pbnQuY3VydmUuZy5tdWwoQk4uZnJvbUJ1ZmZlcih0d2VhaykpKTtcbiAgXG4gIHJldHVybiB0aGlzLnBvaW50LnguZXEoUS54KSAmJiBRLnkubW9kKG5ldyBCTigyKSkuZXEobmV3IEJOKGNvbnRyb2xbMF0gJiAxKSk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgdHdlYWtlZCB2ZXJzaW9uIG9mIHRoaXMgcHViIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IG1lcmtsZVJvb3QgKG9wdGlvbmFsKVxuICogQHJldHVybnMge3sgcGFyaXR5OiBOdW1iZXIsIHR3ZWFrZWRQdWJLZXk6IEJ1ZmZlciB9fVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLmNyZWF0ZVRhcFR3ZWFrID0gZnVuY3Rpb24obWVya2xlUm9vdCkge1xuICAkLmNoZWNrQXJndW1lbnQobWVya2xlUm9vdCA9PSBudWxsIHx8IChCdWZmZXIuaXNCdWZmZXIobWVya2xlUm9vdCkgJiYgbWVya2xlUm9vdC5sZW5ndGggPT09IDMyKSwgJ21lcmtsZVJvb3QgbXVzdCBiZSBhIDMyIGJ5dGUgYnVmZmVyJyk7XG5cbiAgbGV0IHQgPSB0aGlzLmNvbXB1dGVUYXBUd2Vha0hhc2gobWVya2xlUm9vdCk7XG4gIHQgPSBuZXcgQk4odCk7XG4gIGNvbnN0IFEgPSB0aGlzLnBvaW50LmxpZnRYKCkuYWRkKFBvaW50LmdldEcoKS5tdWwodCkpO1xuICBjb25zdCBwYXJpdHkgPSBRLnkuaXNFdmVuKCkgPyAwIDogMTtcbiAgcmV0dXJuIHtcbiAgICBwYXJpdHksXG4gICAgdHdlYWtlZFB1YktleTogUS54LnRvQnVmZmVyKClcbiAgfTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlcmUgd291bGQgYmUgYW55IGVycm9ycyB3aGVuIGluaXRpYWxpemluZyBhIFB1YmxpY0tleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGVuY29kZWQgZGF0YSBpbiB2YXJpb3VzIGZvcm1hdHNcbiAqIEByZXR1cm5zIHtudWxsfEVycm9yfSBBbiBlcnJvciBpZiBleGlzdHNcbiAqL1xuUHVibGljS2V5LmdldFZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIC8qIGpzaGludCBub25ldzogZmFsc2UgKi9cbiAgICBuZXcgUHVibGljS2V5KGRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIHZhbGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZW5jb2RlZCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBwdWJsaWMga2V5IHdvdWxkIGJlIHZhbGlkXG4gKi9cblB1YmxpY0tleS5pc1ZhbGlkID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gIVB1YmxpY0tleS5nZXRWYWxpZGF0aW9uRXJyb3IoZGF0YSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcGxhaW4gb2JqZWN0IG9mIHRoZSBQdWJsaWNLZXlcbiAqL1xuUHVibGljS2V5LnByb3RvdHlwZS50b09iamVjdCA9IFB1YmxpY0tleS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgeDogdGhpcy5wb2ludC5nZXRYKCkudG9TdHJpbmcoJ2hleCcsIDIpLFxuICAgIHk6IHRoaXMucG9pbnQuZ2V0WSgpLnRvU3RyaW5nKCdoZXgnLCAyKSxcbiAgICBjb21wcmVzc2VkOiB0aGlzLmNvbXByZXNzZWRcbiAgfTtcbn07XG5cbi8qKlxuICogV2lsbCBvdXRwdXQgdGhlIFB1YmxpY0tleSB0byBhIERFUiBCdWZmZXJcbiAqXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBBIERFUiBoZXggZW5jb2RlZCBidWZmZXJcbiAqL1xuUHVibGljS2V5LnByb3RvdHlwZS50b0J1ZmZlciA9IFB1YmxpY0tleS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLnBvaW50LmdldFgoKTtcbiAgdmFyIHkgPSB0aGlzLnBvaW50LmdldFkoKTtcblxuICB2YXIgeGJ1ZiA9IHgudG9CdWZmZXIoe1xuICAgIHNpemU6IDMyXG4gIH0pO1xuICB2YXIgeWJ1ZiA9IHkudG9CdWZmZXIoe1xuICAgIHNpemU6IDMyXG4gIH0pO1xuXG4gIHZhciBwcmVmaXg7XG4gIGlmICghdGhpcy5jb21wcmVzc2VkKSB7XG4gICAgcHJlZml4ID0gQnVmZmVyLmZyb20oWzB4MDRdKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbcHJlZml4LCB4YnVmLCB5YnVmXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9kZCA9IHlidWZbeWJ1Zi5sZW5ndGggLSAxXSAlIDI7XG4gICAgaWYgKG9kZCkge1xuICAgICAgcHJlZml4ID0gQnVmZmVyLmZyb20oWzB4MDNdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gQnVmZmVyLmZyb20oWzB4MDJdKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgeGJ1Zl0pO1xuICB9XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc2hhMjU2ICsgcmlwZW1kMTYwIGhhc2ggb2YgdGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2Jsb2IvbWFzdGVyL3NyYy9wdWJrZXkuaCNMMTQxXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLl9nZXRJRCA9IGZ1bmN0aW9uIF9nZXRJRCgpIHtcbiAgcmV0dXJuIEhhc2guc2hhMjU2cmlwZW1kMTYwKHRoaXMudG9CdWZmZXIoKSk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGFuIGFkZHJlc3MgZm9yIHRoZSBwdWJsaWMga2V5XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TmV0d29yaz19IG5ldHdvcmsgLSBXaGljaCBuZXR3b3JrIHNob3VsZCB0aGUgYWRkcmVzcyBiZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gRWl0aGVyICdwdWJrZXloYXNoJywgJ3dpdG5lc3NwdWJrZXloYXNoJywgb3IgJ3NjcmlwdGhhc2gnXG4gKiBAcmV0dXJucyB7QWRkcmVzc30gQW4gYWRkcmVzcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcHVibGljIGtleVxuICovXG5QdWJsaWNLZXkucHJvdG90eXBlLnRvQWRkcmVzcyA9IGZ1bmN0aW9uKG5ldHdvcmssIHR5cGUpIHtcbiAgdmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKTtcbiAgcmV0dXJuIEFkZHJlc3MuZnJvbVB1YmxpY0tleSh0aGlzLCBuZXR3b3JrIHx8IHRoaXMubmV0d29yaywgdHlwZSk7XG59O1xuXG4vKipcbiAqIFdpbGwgb3V0cHV0IHRoZSBQdWJsaWNLZXkgdG8gYSBERVIgZW5jb2RlZCBoZXggc3RyaW5nXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gQSBERVIgaGV4IGVuY29kZWQgc3RyaW5nXG4gKi9cblB1YmxpY0tleS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9ERVIoKS50b1N0cmluZygnaGV4Jyk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBQdWJsaWMga2V5XG4gKi9cblB1YmxpY0tleS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxQdWJsaWNLZXk6ICcgKyB0aGlzLnRvU3RyaW5nKCkgK1xuICAgICh0aGlzLmNvbXByZXNzZWQgPyAnJyA6ICcsIHVuY29tcHJlc3NlZCcpICsgJz4nO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFB1YmxpY0tleTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/publickey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/script/index.js":
/*!******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/script/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/script.js\");\n\nmodule.exports.Interpreter = __webpack_require__(/*! ./interpreter */ \"(ssr)/./node_modules/bitcore-lib/lib/script/interpreter.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3NjcmlwdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2R0FBb0M7O0FBRXBDLG1JQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi9zY3JpcHQvaW5kZXguanM/ZGVmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5cbm1vZHVsZS5leHBvcnRzLkludGVycHJldGVyID0gcmVxdWlyZSgnLi9pbnRlcnByZXRlcicpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/script/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/script/interpreter.js":
/*!************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/script/interpreter.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nconst Script = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/script.js\");\nconst Opcode = __webpack_require__(/*! ../opcode */ \"(ssr)/./node_modules/bitcore-lib/lib/opcode.js\");\nconst BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nconst Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nconst Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nconst PublicKey = __webpack_require__(/*! ../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst SighashWitness = __webpack_require__(/*! ../transaction/sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\nconst SighashSchnorr = __webpack_require__(/*! ../transaction/sighashschnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js\");\nconst BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n\n\nInterpreter.prototype.verifyWitnessProgram = function(version, program, witness, satoshis, flags, isP2SH) {\n\n  var scriptPubKey = new Script();\n  var stack = [];\n\n  if (version === 0) {\n    if (program.length === Interpreter.WITNESS_V0_SCRIPTHASH_SIZE) {\n      if (witness.length === 0) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\n        return false;\n      }\n\n      var scriptPubKeyBuffer = witness[witness.length - 1];\n      scriptPubKey = new Script(scriptPubKeyBuffer);\n      var hash = Hash.sha256(scriptPubKeyBuffer);\n      if (hash.toString('hex') !== program.toString('hex')) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      stack = witness.slice(0, -1);\n      return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.WITNESS_V0, satoshis, flags);\n    } else if (program.length === Interpreter.WITNESS_V0_KEYHASH_SIZE) {\n      if (witness.length !== 2) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      scriptPubKey.add(Opcode.OP_DUP);\n      scriptPubKey.add(Opcode.OP_HASH160);\n      scriptPubKey.add(program);\n      scriptPubKey.add(Opcode.OP_EQUALVERIFY);\n      scriptPubKey.add(Opcode.OP_CHECKSIG);\n\n      stack = witness;\n      return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.WITNESS_V0, satoshis, flags);\n    } else {\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH';\n      return false;\n    }\n  } else if (version === 1 && program.length == Interpreter.WITNESS_V1_TAPROOT_SIZE && !isP2SH) {\n    const execdata = { annexPresent: false };\n    // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n    if (!(flags & Interpreter.SCRIPT_VERIFY_TAPROOT)) {\n      return true;\n    }\n    stack = Array.from(witness);\n    if (stack.length == 0) {\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\n      return false;\n    }\n    if (stack.length >= 2 && stack[stack.length - 1].length && stack[stack.length - 1][0] === Script.ANNEX_TAG) {\n      // Drop annex (this is non-standard; see IsWitnessStandard)\n      const annex = stack.pop();\n      const annexWriter = new BufferWriter();\n      annexWriter.writeVarintNum(annex.length);\n      annexWriter.write(annex);\n      execdata.annexHash = Hash.sha256(annexWriter.toBuffer());\n      execdata.annexPresent = true;\n    }\n    execdata.annexInit = true;\n    if (stack.length === 1) {\n      // Key path spending (stack size is 1 after removing optional annex)\n      return this.checkSchnorrSignature(stack[0], program, Signature.Version.TAPROOT, execdata);\n    } else {\n      // Script path spending (stack size is >1 after removing optional annex)\n      const control = stack.pop();\n      const scriptPubKeyBuf = stack.pop();\n\n      if (\n        control.length < Interpreter.TAPROOT_CONTROL_BASE_SIZE  ||\n        control.length > Interpreter.TAPROOT_CONTROL_MAX_SIZE   ||\n        ((control.length - Interpreter.TAPROOT_CONTROL_BASE_SIZE) % Interpreter.TAPROOT_CONTROL_NODE_SIZE) != 0\n      ) {\n        this.errstr = 'SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE';\n        return false;\n      }\n      execdata.tapleafHash = Interpreter.computeTapleafHash(control[0] & Interpreter.TAPROOT_LEAF_MASK, scriptPubKeyBuf);\n      if (!Interpreter.verifyTaprootCommitment(control, program, execdata.tapleafHash)) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n      execdata.tapleafHashInit = true;\n      if ((control[0] & Interpreter.TAPROOT_LEAF_MASK) === Interpreter.TAPROOT_LEAF_TAPSCRIPT) {\n        // Tapscript (leaf version 0xc0)\n        let witnessSize;\n        {\n          const bw = new BufferWriter();\n          bw.writeVarintNum(witness.length);\n          for (let element of witness) {\n            bw.writeVarintNum(element.length);\n            bw.write(element);\n          }\n          witnessSize = bw.toBuffer().length;\n        }\n\n        try {\n          scriptPubKey = new Script(scriptPubKeyBuf);\n        } catch (err) {\n          // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n          this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n          return false;\n        }\n\n        execdata.validationWeightLeft = witnessSize + Script.VALIDATION_WEIGHT_OFFSET;\n        execdata.validationWeightLeftInit = true;\n        return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.TAPSCRIPT, satoshis, flags, execdata);\n      }\n      // If none of the above conditions are met then this must be an upgraded taproot version.\n      if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {\n        this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION';\n        return false;\n      }\n      // Future softfork compatibility\n      return true;\n    }\n  } else if ((flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)) {\n    this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM';\n    return false;\n  }\n  // Other version/size/p2sh combinations return true for future softfork compatibility\n  return true;\n};\n\n\nInterpreter.prototype.executeWitnessScript = function(scriptPubKey, stack, sigversion, satoshis, flags, execdata) {\n  if (sigversion === Signature.Version.TAPSCRIPT) {\n    for (let chunk of scriptPubKey.chunks) {\n      // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n      if (Opcode.isOpSuccess(chunk.opcodenum)) {\n        if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n          this.errstr = 'SCRIPT_ERR_DISCOURAGE_OP_SUCCESS';\n          return false;\n        }\n        return true;\n      }\n    }\n\n    // Tapscript enforces initial stack size limits (altstack is empty here)\n    if (stack.length > Interpreter.MAX_STACK_SIZE) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  }\n\n  // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n  if (stack.length && stack.some(elem => elem.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE)) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  this.initialize();\n\n  this.set({\n    script: scriptPubKey,\n    stack: stack,\n    sigversion: sigversion,\n    satoshis: satoshis,\n    flags: flags,\n    execdata: execdata\n  });\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length !== 1) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  return true;\n};\n\n\n\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n * @param {number} witness - array of witness data\n * @param {number} satoshis - number of satoshis created by this output\n *\n * Translated from bitcoind's VerifyScript\n */\nInterpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {\n\n  var Transaction = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\");\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n  if (_.isUndefined(witness)) {\n    witness = null;\n  }\n  if (_.isUndefined(satoshis)) {\n    satoshis = 0;\n  }\n\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    sigversion: Signature.Version.BASE,\n    satoshis: 0,\n    flags: flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  }\n\n  // evaluate scriptSig\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n\n  // evaluate scriptPubkey\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  var hadWitness = false;\n  if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n    var witnessValues = {};\n    if (scriptPubkey.isWitnessProgram(witnessValues)) {\n      hadWitness = true;\n      if (scriptSig.toBuffer().length !== 0) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED';\n        return false;\n      }\n      if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags, /* isP2SH */ false)) {\n        return false;\n      }\n    }\n  }\n\n  // Additional validation for spend-to-script-hash transactions:\n  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    }\n\n    // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags\n    });\n\n    // evaluate redeemScript\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n    if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n      var p2shWitnessValues = {};\n      if (redeemScript.isWitnessProgram(p2shWitnessValues)) {\n        hadWitness = true;\n        var redeemScriptPush = new Script();\n        redeemScriptPush.add(redeemScript.toBuffer());\n        if (scriptSig.toHex() !== redeemScriptPush.toHex()) {\n          this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED_P2SH';\n          return false;\n        }\n\n        if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags, /* isP2SH */ true)) {\n          return false;\n        }\n        // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n        // for witness programs.\n        stack = [stack[0]];\n      }\n    }\n  }\n\n  // The CLEANSTACK check is only performed after potential P2SH evaluation,\n  // as the non-P2SH evaluation of a P2SH script will obviously not result in\n  // a clean stack (the P2SH inputs remain). The same holds for witness\n  // evaluation.\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {\n      // Disallow CLEANSTACK without P2SH, as otherwise a switch\n      // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a\n      // softfork (and P2SH should be one).\n      if (\n        (this.flags & Interpreter.SCRIPT_VERIFY_P2SH)    == 0 ||\n        (this.flags & Interpreter.SCRIPT_VERIFY_WITNESS) == 0\n      ) {\n        throw 'flags & SCRIPT_VERIFY_P2SH';\n      }\n\n      if (stackCopy.length != 1) {\n        this.errstr = 'SCRIPT_ERR_CLEANSTACK';\n        return false;\n      }\n  }\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n    if (!hadWitness && witness.length > 0) {\n      this.errstr = 'SCRIPT_ERR_WITNESS_UNEXPECTED';\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function(obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.satoshis = 0;\n  this.sigversion = Signature.Version.BASE;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n  this.execdata = {};\n};\n\nInterpreter.prototype.set = function(obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin === 'undefined' ? this.nin : parseInt(obj.nin);\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altstack || this.altstack;\n  this.pc = typeof obj.pc === 'undefined' ? this.pc : obj.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash === 'undefined' ? this.pbegincodehash : obj.pbegincodehash;\n  this.sigversion = typeof obj.sigversion === 'undefined' ? this.sigversion : obj.sigversion;\n  this.satoshis = typeof obj.satoshis === 'undefined' ? this.satoshis : obj.satoshis;\n  this.nOpCount = typeof obj.nOpCount === 'undefined' ? this.nOpCount : obj.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags === 'undefined' ? this.flags : obj.flags;\n  this.execdata = typeof obj.execdata === 'undefined' ? this.execdata : (obj.execdata || {});\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\n\nInterpreter.MAX_SCRIPT_SIZE = 10000;\nInterpreter.MAX_STACK_SIZE = 1000;\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\n\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);\n\n// flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\nInterpreter.SCRIPT_VERIFY_NONE = 0;\n\n// Evaluate P2SH subscripts (softfork safe, BIP16).\nInterpreter.SCRIPT_VERIFY_P2SH = (1 << 0);\n\n// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\nInterpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);\n\n// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\nInterpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);\n\n// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\nInterpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);\n\n// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);\n\n// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);\n\n// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);\n\n// Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);\n\n\n// Require that only a single stack element remains after evaluation. This\n// changes the success criterion from \"At least one stack element must\n// remain, and when interpreted as a boolean, it must be true\" to \"Exactly\n// one stack element must remain, and when interpreted as a boolean, it must\n// be true\".\n// (softfork safe, BIP62 rule 6)\n// Note: CLEANSTACK should never be used without P2SH or WITNESS.\nInterpreter.SCRIPT_VERIFY_CLEANSTACK = (1 << 8),\n\n// Verify CHECKLOCKTIMEVERIFY\n//\n// See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);\n\n// support CHECKSEQUENCEVERIFY opcode\n//\n// See BIP112 for details\nInterpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1 << 10);\n\n// Support segregated witness\n//\nInterpreter.SCRIPT_VERIFY_WITNESS = (1 << 11);\n\n// Making v1-v16 witness program non-standard\n//\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1 << 12);\n\n\n//\n// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly\n// 0x01 or empty vector\n//\nInterpreter.SCRIPT_VERIFY_MINIMALIF = (1 << 13);\n\n\n// Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n//\nInterpreter.SCRIPT_VERIFY_NULLFAIL = (1 << 14);\n\n// Public keys in scripts must be compressed\n//\nInterpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1 << 15);\n\n// Do we accept signature using SIGHASH_FORKID\n//\nInterpreter.SCRIPT_ENABLE_SIGHASH_FORKID = (1 << 16);\n\n// Do we accept activate replay protection using a different fork id.\n//\nInterpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = (1 << 17);\n\n// Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n//\nInterpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE = (1 << 16);\n\n// Verify taproot script\n//\nInterpreter.SCRIPT_VERIFY_TAPROOT = (1 << 17);\n\n// Making unknown Taproot leaf versions non-standard\n//\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1 << 18);\n\n// Making unknown OP_SUCCESS non-standard\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1 << 19);\n\n// Making unknown public key versions (in BIP 342 scripts) non-standard\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1 << 20);\n\n\n\n/* Below flags apply in the context of BIP 68*/\n/**\n * If this flag set, CTxIn::nSequence is NOT interpreted as a relative\n * lock-time.\n */\nInterpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time and this flag is set,\n * the relative lock-time has units of 512 seconds, otherwise it specifies\n * blocks with a granularity of 1.\n */\nInterpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to\n * extract that lock-time from the sequence field.\n */\nInterpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\n/** Signature hash sizes */\nInterpreter.WITNESS_V0_SCRIPTHASH_SIZE = 32;\nInterpreter.WITNESS_V0_KEYHASH_SIZE = 20;\nInterpreter.WITNESS_V1_TAPROOT_SIZE = 32;\n\nInterpreter.TAPROOT_LEAF_MASK = 0xfe;\nInterpreter.TAPROOT_LEAF_TAPSCRIPT = 0xc0;\nInterpreter.TAPROOT_CONTROL_BASE_SIZE = 33;\nInterpreter.TAPROOT_CONTROL_NODE_SIZE = 32;\nInterpreter.TAPROOT_CONTROL_MAX_NODE_COUNT = 128;\nInterpreter.TAPROOT_CONTROL_MAX_SIZE = Interpreter.TAPROOT_CONTROL_BASE_SIZE + Interpreter.TAPROOT_CONTROL_NODE_SIZE * Interpreter.TAPROOT_CONTROL_MAX_NODE_COUNT;\n\n// Conceptually, this doesn't really belong with the Interpreter, but I haven't found a better place for it.\nInterpreter.PROTOCOL_VERSION = 70016;\n\nInterpreter.castToBool = function(buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\nInterpreter.prototype.checkSignatureEncoding = function(buf) {\n  var sig;\n\n    // Empty signature. Not strictly DER encoded, but allowed to provide a\n    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n    if (buf.length == 0) {\n        return true;\n    }\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\nInterpreter.prototype.checkPubkeyEncoding = function(buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n\n  // Only compressed keys are accepted in segwit\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == Signature.Version.WITNESS_V0 && !PublicKey.fromBuffer(buf).compressed) {\n    this.errstr = 'SCRIPT_ERR_WITNESS_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n\n\n/**\n * Verifies ECDSA signature\n * @param {Signature} sig\n * @param {PublicKey} pubkey\n * @param {Number} nin\n * @param {Script} subscript\n * @param {Number} satoshis\n * @returns {Boolean}\n */\nInterpreter.prototype.checkEcdsaSignature = function(sig, pubkey, nin, subscript, satoshis) {\n  var subscriptBuffer = subscript.toBuffer();\n  var scriptCodeWriter = new BufferWriter();\n  scriptCodeWriter.writeVarintNum(subscriptBuffer.length);\n  scriptCodeWriter.write(subscriptBuffer);\n\n  $.checkState(JSUtil.isNaturalNumber(satoshis));\n  var satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();\n\n  var verified = SighashWitness.verify(\n    this,\n    sig,\n    pubkey,\n    nin,\n    scriptCodeWriter.toBuffer(),\n    satoshisBuffer\n  );\n  return verified;\n};\n\n\n/**\n * Verifies Schnorr signature\n * @param {Signature|Buffer} sig\n * @param {PublicKey|Buffer} pubkey\n * @param {Number} sigversion\n * @param {Object} execdata\n * @returns {Boolean}\n */\nInterpreter.prototype.checkSchnorrSignature = function(sig, pubkey, sigversion, execdata) {\n  $.checkArgument(sig && Buffer.isBuffer(sig), 'Missing sig');\n  $.checkArgument(pubkey && Buffer.isBuffer(pubkey), 'Missing pubkey');\n  $.checkArgument(sigversion, 'Missing sigversion');\n  $.checkArgument(execdata, 'Missing execdata');\n\n  $.checkArgument(pubkey.length === 32, 'Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.');\n  // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not\n  // abort script execution). This is implemented in EvalChecksigTapscript, which won't invoke\n  // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with\n  // size different from 64 or 65.\n  if (!(sig.length === 64 || sig.length === 65)) {\n    this.errstr = 'SCRIPT_ERR_SCHNORR_SIG_SIZE';\n    return false;\n  }\n\n  if (sig.length === 65 && sig[sig.length - 1] === Signature.SIGHASH_DEFAULT) {\n    this.errstr = 'SCRIPT_ERR_SCHNORR_SIG_HASHTYPE';\n    return false;\n  }\n  sig = Signature.fromSchnorr(sig);\n  const verified = SighashSchnorr.verify(\n    this.tx,\n    sig,\n    pubkey,\n    sigversion,\n    this.nin,\n    execdata\n  );\n  return verified;\n};\n\n\n/**\n * Based on bitcoind's EvalChecksigPreTapscript function\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\n */\nInterpreter.prototype._evalChecksigPreTapscript = function(bufSig, bufPubkey) {\n  $.checkArgument(\n    this.sigversion === Signature.Version.BASE || this.sigversion === Signature.Version.WITNESS_V0,\n    'sigversion must be base or witness_v0'\n  );\n\n  // Success signifies if the signature is valid.\n  // Result signifies the result of this funciton, which also takes flags into account.\n  const retVal = { success: false, result: false };\n\n  const subscript = new Script().set({\n    chunks: this.script.chunks.slice(this.pbegincodehash)\n  });\n\n  // Drop the signature in pre-segwit scripts but not segwit scripts\n  if (this.sigversion === Signature.Version.BASE) {\n    // Drop the signature, since there's no way for a signature to sign itself\n    const tmpScript = new Script().add(bufSig);\n    let found = subscript.chunks.length;\n    subscript.findAndDelete(tmpScript);\n\n    found = found == subscript.chunks.length + 1; // found if a chunk was removed\n    if (found && (this.flags & Interpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE)) {\n      this.errstr = 'SCRIPT_ERR_SIG_FINDANDDELETE';\n      return retVal;\n    }\n  }\n\n  if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n    return retVal;\n  }\n\n  try {\n    const sig = Signature.fromTxFormat(bufSig);\n    const pubkey = PublicKey.fromBuffer(bufPubkey, false);\n    retVal.success = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);\n  } catch (e) {\n    //invalid sig or pubkey\n    retVal.success = false;\n  }\n\n  if (!retVal.success && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) && bufSig.length) {\n    this.errstr = 'SCRIPT_ERR_SIG_NULLFAIL';\n    return retVal;\n  }\n\n  // If it reaches here, then true\n  retVal.result = true;\n  return retVal;\n};\n\n\n/**\n * Based on bitcoind's EvalChecksigTapscript function\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\n */\nInterpreter.prototype._evalChecksigTapscript = function(bufSig, bufPubkey) {\n  $.checkArgument(this.sigversion == Signature.Version.TAPSCRIPT, 'this.sigversion must by TAPSCRIPT');\n\n  /*\n    *  The following validation sequence is consensus critical. Please note how --\n    *    upgradable public key versions precede other rules;\n    *    the script execution fails when using empty signature with invalid public key;\n    *    the script execution fails when using non-empty invalid signature.\n    */\n\n  // Success signifies if the signature is valid.\n  // Result signifies the result of this funciton, which also takes flags into account.\n  const retVal = {\n    success: bufSig.length > 0,\n    result: false\n  }\n  if (retVal.success) {\n    // Implement the sigops/witnesssize ratio test.\n    // Passing with an upgradable public key version is also counted.\n    $.checkState(this.execdata.validationWeightLeftInit, 'validationWeightLeftInit is false');\n    this.execdata.validationWeightLeft -= Script.VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n    if (this.execdata.validationWeightLeft < 0) {\n      this.errstr = 'SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT';\n      return retVal;\n    }\n  }\n  if (bufPubkey.length === 0) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return retVal;\n  } else if (bufPubkey.length == 32) {\n    if (retVal.success && !this.tx.checkSchnorrSignature(bufSig, bufPubkey, this.nin, this.sigversion, this.execdata)) {\n      this.errstr = 'SCRIPT_ERR_SCHNORR_SIG';\n      return retVal;\n    }\n  } else {\n    /*\n      *  New public key version softforks should be defined before this `else` block.\n      *  Generally, the new code should not do anything but failing the script execution. To avoid\n      *  consensus bugs, it should not modify any existing values (including `success`).\n      */\n    if ((this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n      this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE';\n      return retVal;\n    }\n  }\n\n  // If it reaches here, then true\n  retVal.result = true;\n  return retVal;\n}\n\n/**\n * Based on bitcoind's EvalChecksig function\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\n * @returns {{ success: Boolean, verified: Boolean }}\n */\nInterpreter.prototype._evalCheckSig = function(bufSig, bufPubkey) {\n  switch(this.sigversion) {\n    case Signature.Version.BASE:\n    case Signature.Version.WITNESS_V0:\n      // const verified = this._evalChecksigPreTapscript(bufSig, bufPubkey);\n      // return { success: verified, verified }; // This is to keep the same return format as _evalCheckSigTapscript\n      return this._evalChecksigPreTapscript(bufSig, bufPubkey);\n    case Signature.Version.TAPSCRIPT:\n      return this._evalChecksigTapscript(bufSig, bufPubkey);\n    case Signature.Version.TAPROOT:\n      // Key path spending in Taproot has no script, so this is unreachable.\n      throw new Error('Called evalCheckSig with a TAPROOT sigversion. Check your implementation');\n  }\n};\n\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.evaluate = function() {\n  // sigversion cannot be TAPROOT here, as it admits no script execution.\n  $.checkArgument(this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0 || this.sigversion == Signature.Version.TAPSCRIPT, 'invalid sigversion');\n\n  if (\n    (this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0) &&\n    this.script.toBuffer().length > Interpreter.MAX_SCRIPT_SIZE\n  ) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n      if (!fSuccess) {\n        return false;\n      }\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\nInterpreter.prototype.checkLockTime = function(nLockTime) {\n\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(\n    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||\n    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))\n  )) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  }\n\n  // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n}\n\n\n/**\n * Checks a sequence parameter with the transaction's sequence.\n * @param {BN} nSequence the sequence read from the script\n * @return {boolean} true if the transaction's sequence is less than or equal to\n *                   the transaction's sequence\n */\nInterpreter.prototype.checkSequence = function(nSequence) {\n\n  // Relative lock times are supported by comparing the passed in operand to\n  // the sequence number of the input.\n  var txToSequence = this.tx.inputs[this.nin].sequenceNumber;\n\n  // Fail if the transaction's version number is not set high enough to\n  // trigger BIP 68 rules.\n  if (this.tx.version < 2) {\n    return false;\n  }\n\n  // Sequence numbers with their most significant bit set are not consensus\n  // constrained. Testing that the transaction's sequence number do not have\n  // this bit set prevents using this property to get around a\n  // CHECKSEQUENCEVERIFY check.\n  if (txToSequence & Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return false;\n  }\n\n  // Mask off any bits that do not have consensus-enforced meaning before\n  // doing the integer comparisons\n  var nLockTimeMask =\n      Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;\n  var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);\n  var nSequenceMasked = nSequence.and(new BN(nLockTimeMask));\n\n  // There are two kinds of nSequence: lock-by-blockheight and\n  // lock-by-blocktime, distinguished by whether nSequenceMasked <\n  // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n  //\n  // We want to compare apples to apples, so fail the script unless the type\n  // of nSequenceMasked being tested is the same as the nSequenceMasked in the\n  // transaction.\n  var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);\n\n  if (!((txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)  &&\n          nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)) ||\n        (txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&\n          nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)))) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the comparison is a\n  // simple numeric one.\n  return nSequenceMasked.lte(txToSequenceMasked)\n}\n\n\nInterpreter.computeTapleafHash = function(leafVersion, scriptBuf) {\n  const tagWriter = TaggedHash.TAPLEAF;\n  tagWriter.writeUInt8(leafVersion);\n  tagWriter.writeVarintNum(scriptBuf.length);\n  tagWriter.write(scriptBuf);\n  return tagWriter.finalize();\n};\n\n\nInterpreter.computeTaprootMerkleRoot = function(control, tapleafHash) {\n  const pathLen = (control.length - Interpreter.TAPROOT_CONTROL_BASE_SIZE) / Interpreter.TAPROOT_CONTROL_NODE_SIZE;\n  let k = tapleafHash;\n  for (let i = 0; i < pathLen; ++i) {\n    const tagWriter = TaggedHash.TAPBRANCH;\n    const start = Interpreter.TAPROOT_CONTROL_BASE_SIZE + Interpreter.TAPROOT_CONTROL_NODE_SIZE * i;\n    const node = control.slice(start, start + Interpreter.TAPROOT_CONTROL_NODE_SIZE);\n    if (Buffer.compare(k, node) === -1) {\n      tagWriter.write(k);\n      tagWriter.write(node);\n    } else {\n      tagWriter.write(node);\n      tagWriter.write(k);\n    }\n    k = tagWriter.finalize();\n  }\n  return k;\n};\n\n\nInterpreter.verifyTaprootCommitment = function(control, program, tapleafHash) {\n  $.checkArgument(control.length >= Interpreter.TAPROOT_CONTROL_BASE_SIZE, 'control too short');\n  $.checkArgument(program.length >= 32, 'program is too short');\n\n  try {\n    //! The internal pubkey (x-only, so no Y coordinate parity).\n    const p = PublicKey.fromX(false, control.slice(1, Interpreter.TAPROOT_CONTROL_BASE_SIZE));\n    //! The output pubkey (taken from the scriptPubKey).\n    const q = PublicKey.fromX(false, program);\n    // Compute the Merkle root from the leaf and the provided path.\n    const merkleRoot = Interpreter.computeTaprootMerkleRoot(control, tapleafHash);\n    // Verify that the output pubkey matches the tweaked internal pubkey, after correcting for parity.\n    return q.checkTapTweak(p, merkleRoot, control);\n  } catch (err) {\n    return false;\n  }\n};\n\n\n/**\n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.step = function() {\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;\n\n  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n  var fExec = (this.vfExec.indexOf(false) === -1);\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess;\n  this.execdata = this.execdata || {};\n  if (!this.execdata.codeseparatorPosInit) {\n    this.execdata.codeseparatorPos = new BN(0xFFFFFFFF);\n    this.execdata.codeseparatorPosInit = true;\n  }\n\n  // Read instruction\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  if (this.sigversion === Signature.Version.BASE || this.sigversion === Signature.Version.WITNESS_V0) {\n    // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n    if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {\n      this.errstr = 'SCRIPT_ERR_OP_COUNT';\n      return false;\n    }\n  }\n\n\n  if (opcodenum === Opcode.OP_CAT ||\n    opcodenum === Opcode.OP_SUBSTR ||\n    opcodenum === Opcode.OP_LEFT ||\n    opcodenum === Opcode.OP_RIGHT ||\n    opcodenum === Opcode.OP_INVERT ||\n    opcodenum === Opcode.OP_AND ||\n    opcodenum === Opcode.OP_OR ||\n    opcodenum === Opcode.OP_XOR ||\n    opcodenum === Opcode.OP_2MUL ||\n    opcodenum === Opcode.OP_2DIV ||\n    opcodenum === Opcode.OP_MUL ||\n    opcodenum === Opcode.OP_DIV ||\n    opcodenum === Opcode.OP_MOD ||\n    opcodenum === Opcode.OP_LSHIFT ||\n    opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  // With SCRIPT_VERIFY_CONST_SCRIPTCODE, OP_CODESEPARATOR in non-segwit script is rejected even in an unexecuted branch\n  if (opcodenum == Opcode.OP_CODESEPARATOR && this.sigversion === Signature.Version.BASE && (this.flags & Interpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE)) {\n    this.errstr = 'SCRIPT_ERR_OP_CODESEPARATOR';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf);\n          // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n\n\n        //\n        // Control\n        //\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n      case Opcode.OP_NOP3:\n      case Opcode.OP_CHECKSEQUENCEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n          // not enabled; treat as a NOP3\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n\n        // nSequence, like nLockTime, is a 32-bit unsigned\n        // integer field. See the comment in CHECKLOCKTIMEVERIFY\n        // regarding 5-byte numeric operands.\n\n        var nSequence = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKSEQUENCEVERIFY.\n        if (nSequence.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // To provide for future soft-fork extensibility, if the\n        // operand has the disabled lock-time flag set,\n        // CHECKSEQUENCEVERIFY behaves as a NOP.\n        if ((nSequence &\n          Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {\n          break;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkSequence(nSequence)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n\n            buf = this.stack[this.stack.length - 1];\n\n            // Tapscript requires minimal IF/NOTIF inputs as a consensus rule.\n            if (this.sigversion === Signature.Version.TAPSCRIPT) {\n              // The input argument to the OP_IF and OP_NOTIF opcodes must be either\n              // exactly 0 (the empty vector) or exactly 1 (the one-byte vector with value 1).\n              if (buf.length > 1 || (buf.length === 1 && buf[0] !== 1)) {\n                this.errstr = 'SCRIPT_ERR_TAPSCRIPT_MINIMALIF';\n                return false;\n              }\n            }\n            // Under witness v0 rules it is only a policy rule, enabled through SCRIPT_VERIFY_MINIMALIF.\n            if (this.sigversion === Signature.Version.WITNESS_V0 && (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF)) {\n              buf = this.stack[this.stack.length - 1];\n              if (buf.length > 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n              if (buf.length == 1 && buf[0]!=1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n            }\n            fValue = Interpreter.castToBool(buf);\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n            this.stack.pop();\n          }\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n\n\n        //\n        // Stack ops\n        //\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 4];\n          buf2 = this.stack[this.stack.length - 3];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 2]);\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - n - 1];\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 2];\n          x2 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        }\n        break;\n\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn = new BN(this.stack[this.stack.length - 1].length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n\n        //\n        // Bitwise logic\n        //\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n\n        //\n        // Numeric\n        //\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n              break;\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n            case Opcode.OP_BOOLAND:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n            case Opcode.OP_BOOLOR:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n            case Opcode.OP_MIN:\n              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);\n              break;\n            case Opcode.OP_MAX:\n              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);\n              break;\n              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n\n\n        //\n        // Crypto\n        //\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n          var bufHash;\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n          this.execdata.codeseparatorPos = this.pc - 1;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1];\n\n          const { success: fSuccess, result } = this._evalCheckSig(bufSig, bufPubkey);\n          if (!result) {\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n\n          // stack.push_back(fSuccess ? vchTrue : vchFalse);\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      case Opcode.OP_CHECKSIGADD:\n        {\n          // OP_CHECKSIGADD is only available in Tapscript\n          if (this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0) {\n            this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n            return false;\n          }\n\n          // (sig num pubkey -- num)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          let sig = this.stack[this.stack.length - 3];\n          let num = this.stack[this.stack.length - 2];\n          let pubkey = this.stack[this.stack.length - 1];\n\n          num = BN.fromScriptNumBuffer(num, fRequireMinimal);\n\n          const { success, result } = this._evalCheckSig(sig, pubkey);\n          if (!result) {\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(num.addn(success ? 1 : 0).toScriptNumBuffer());\n        }\n        break;\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n          var i = 1;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n          this.nOpCount += nKeysCount;\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          }\n          // int ikey = ++i;\n          var ikey = ++i;\n          i += nKeysCount;\n\n          // ikey2 is the position of last non-signature item in\n          // the stack. Top stack item = 1. With\n          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if\n          // operation fails.\n          var ikey2 = nKeysCount + 2;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          }\n          // int isig = ++i;\n          var isig = ++i;\n          i += nSigsCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          // Subset of script starting at the most recent codeseparator\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signatures, since there's no way for a signature to sign itself\n          for (var k = 0; k < nSigsCount; k++) {\n            bufSig = this.stack[this.stack.length - isig - k];\n            subscript.findAndDelete(new Script().add(bufSig));\n          }\n\n          fSuccess = true;\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig];\n            // valtype& vchPubKey = stacktop(-ikey);\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk;\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis, this.execdata);\n            } catch (e) {\n              //invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig++;\n              nSigsCount--;\n            }\n            ikey++;\n            nKeysCount--;\n\n            // If there are more signatures left than keys left,\n            // then too many signatures have failed\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          }\n\n\n          // Clean up stack of actual arguments\n          while (i-- > 1) {\n            if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&\n              !ikey2 && this.stack[this.stack.length - 1].length) {\n\n              this.errstr = 'SCRIPT_ERR_NULLFAIL';\n              return false;\n            }\n\n            if (ikey2 > 0) {\n              ikey2--;\n            }\n\n            this.stack.pop();\n          }\n\n          // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n          this.stack.pop();\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  // Size limits\n  if (this.stack.length + this.altstack.length > Interpreter.MAX_STACK_SIZE) {\n    this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n    return false;\n  }\n\n  return true;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3NjcmlwdC9pbnRlcnByZXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMscURBQVE7O0FBRTFCLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsaUVBQVc7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMscUZBQXFCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFjO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDekMsdUJBQXVCLG1CQUFPLENBQUMseUdBQStCO0FBQzlELHVCQUF1QixtQkFBTyxDQUFDLHlHQUErQjtBQUM5RCxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDdkQsbUJBQW1CLG1CQUFPLENBQUMsdUZBQXNCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvc2NyaXB0L2ludGVycHJldGVyLmpzPzQ5YzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmNvbnN0IFNjcmlwdCA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCBPcGNvZGUgPSByZXF1aXJlKCcuLi9vcGNvZGUnKTtcbmNvbnN0IEJOID0gcmVxdWlyZSgnLi4vY3J5cHRvL2JuJyk7XG5jb25zdCBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcbmNvbnN0IFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL2NyeXB0by9zaWduYXR1cmUnKTtcbmNvbnN0IFB1YmxpY0tleSA9IHJlcXVpcmUoJy4uL3B1YmxpY2tleScpO1xuY29uc3QgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuY29uc3QgU2lnaGFzaFdpdG5lc3MgPSByZXF1aXJlKCcuLi90cmFuc2FjdGlvbi9zaWdoYXNod2l0bmVzcycpO1xuY29uc3QgU2lnaGFzaFNjaG5vcnIgPSByZXF1aXJlKCcuLi90cmFuc2FjdGlvbi9zaWdoYXNoc2Nobm9ycicpO1xuY29uc3QgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XG5jb25zdCBUYWdnZWRIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL3RhZ2dlZGhhc2gnKTtcblxuLyoqXG4gKiBCaXRjb2luIHRyYW5zYWN0aW9ucyBjb250YWluIHNjcmlwdHMuIEVhY2ggaW5wdXQgaGFzIGEgc2NyaXB0IGNhbGxlZCB0aGVcbiAqIHNjcmlwdFNpZywgYW5kIGVhY2ggb3V0cHV0IGhhcyBhIHNjcmlwdCBjYWxsZWQgdGhlIHNjcmlwdFB1YmtleS4gVG8gdmFsaWRhdGVcbiAqIGFuIGlucHV0LCB0aGUgaW5wdXQncyBzY3JpcHQgaXMgY29uY2F0ZW5hdGVkIHdpdGggdGhlIHJlZmVyZW5jZWQgb3V0cHV0IHNjcmlwdCxcbiAqIGFuZCB0aGUgcmVzdWx0IGlzIGV4ZWN1dGVkLiBJZiBhdCB0aGUgZW5kIG9mIGV4ZWN1dGlvbiB0aGUgc3RhY2sgY29udGFpbnMgYVxuICogXCJ0cnVlXCIgdmFsdWUsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIHZhbGlkLlxuICpcbiAqIFRoZSBwcmltYXJ5IHdheSB0byB1c2UgdGhpcyBjbGFzcyBpcyB2aWEgdGhlIHZlcmlmeSBmdW5jdGlvbi5cbiAqIGUuZy4sIEludGVycHJldGVyKCkudmVyaWZ5KCAuLi4gKTtcbiAqL1xudmFyIEludGVycHJldGVyID0gZnVuY3Rpb24gSW50ZXJwcmV0ZXIob2JqKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnRlcnByZXRlcikpIHtcbiAgICByZXR1cm4gbmV3IEludGVycHJldGVyKG9iaik7XG4gIH1cbiAgaWYgKG9iaikge1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuc2V0KG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbn07XG5cblxuSW50ZXJwcmV0ZXIucHJvdG90eXBlLnZlcmlmeVdpdG5lc3NQcm9ncmFtID0gZnVuY3Rpb24odmVyc2lvbiwgcHJvZ3JhbSwgd2l0bmVzcywgc2F0b3NoaXMsIGZsYWdzLCBpc1AyU0gpIHtcblxuICB2YXIgc2NyaXB0UHViS2V5ID0gbmV3IFNjcmlwdCgpO1xuICB2YXIgc3RhY2sgPSBbXTtcblxuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIGlmIChwcm9ncmFtLmxlbmd0aCA9PT0gSW50ZXJwcmV0ZXIuV0lUTkVTU19WMF9TQ1JJUFRIQVNIX1NJWkUpIHtcbiAgICAgIGlmICh3aXRuZXNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1dJVE5FU1NfUFJPR1JBTV9XSVRORVNTX0VNUFRZJztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2NyaXB0UHViS2V5QnVmZmVyID0gd2l0bmVzc1t3aXRuZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgc2NyaXB0UHViS2V5ID0gbmV3IFNjcmlwdChzY3JpcHRQdWJLZXlCdWZmZXIpO1xuICAgICAgdmFyIGhhc2ggPSBIYXNoLnNoYTI1NihzY3JpcHRQdWJLZXlCdWZmZXIpO1xuICAgICAgaWYgKGhhc2gudG9TdHJpbmcoJ2hleCcpICE9PSBwcm9ncmFtLnRvU3RyaW5nKCdoZXgnKSkge1xuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1dJVE5FU1NfUFJPR1JBTV9NSVNNQVRDSCc7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RhY2sgPSB3aXRuZXNzLnNsaWNlKDAsIC0xKTtcbiAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVXaXRuZXNzU2NyaXB0KHNjcmlwdFB1YktleSwgc3RhY2ssIFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjAsIHNhdG9zaGlzLCBmbGFncyk7XG4gICAgfSBlbHNlIGlmIChwcm9ncmFtLmxlbmd0aCA9PT0gSW50ZXJwcmV0ZXIuV0lUTkVTU19WMF9LRVlIQVNIX1NJWkUpIHtcbiAgICAgIGlmICh3aXRuZXNzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1dJVE5FU1NfUFJPR1JBTV9NSVNNQVRDSCc7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc2NyaXB0UHViS2V5LmFkZChPcGNvZGUuT1BfRFVQKTtcbiAgICAgIHNjcmlwdFB1YktleS5hZGQoT3Bjb2RlLk9QX0hBU0gxNjApO1xuICAgICAgc2NyaXB0UHViS2V5LmFkZChwcm9ncmFtKTtcbiAgICAgIHNjcmlwdFB1YktleS5hZGQoT3Bjb2RlLk9QX0VRVUFMVkVSSUZZKTtcbiAgICAgIHNjcmlwdFB1YktleS5hZGQoT3Bjb2RlLk9QX0NIRUNLU0lHKTtcblxuICAgICAgc3RhY2sgPSB3aXRuZXNzO1xuICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVdpdG5lc3NTY3JpcHQoc2NyaXB0UHViS2V5LCBzdGFjaywgU2lnbmF0dXJlLlZlcnNpb24uV0lUTkVTU19WMCwgc2F0b3NoaXMsIGZsYWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX1BST0dSQU1fV1JPTkdfTEVOR1RIJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMSAmJiBwcm9ncmFtLmxlbmd0aCA9PSBJbnRlcnByZXRlci5XSVRORVNTX1YxX1RBUFJPT1RfU0laRSAmJiAhaXNQMlNIKSB7XG4gICAgY29uc3QgZXhlY2RhdGEgPSB7IGFubmV4UHJlc2VudDogZmFsc2UgfTtcbiAgICAvLyBCSVAzNDEgVGFwcm9vdDogMzItYnl0ZSBub24tUDJTSCB3aXRuZXNzIHYxIHByb2dyYW0gKHdoaWNoIGVuY29kZXMgYSBQMkMtdHdlYWtlZCBwdWJrZXkpXG4gICAgaWYgKCEoZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1RBUFJPT1QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RhY2sgPSBBcnJheS5mcm9tKHdpdG5lc3MpO1xuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX1BST0dSQU1fV0lUTkVTU19FTVBUWSc7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPj0gMiAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5sZW5ndGggJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1bMF0gPT09IFNjcmlwdC5BTk5FWF9UQUcpIHtcbiAgICAgIC8vIERyb3AgYW5uZXggKHRoaXMgaXMgbm9uLXN0YW5kYXJkOyBzZWUgSXNXaXRuZXNzU3RhbmRhcmQpXG4gICAgICBjb25zdCBhbm5leCA9IHN0YWNrLnBvcCgpO1xuICAgICAgY29uc3QgYW5uZXhXcml0ZXIgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICBhbm5leFdyaXRlci53cml0ZVZhcmludE51bShhbm5leC5sZW5ndGgpO1xuICAgICAgYW5uZXhXcml0ZXIud3JpdGUoYW5uZXgpO1xuICAgICAgZXhlY2RhdGEuYW5uZXhIYXNoID0gSGFzaC5zaGEyNTYoYW5uZXhXcml0ZXIudG9CdWZmZXIoKSk7XG4gICAgICBleGVjZGF0YS5hbm5leFByZXNlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBleGVjZGF0YS5hbm5leEluaXQgPSB0cnVlO1xuICAgIGlmIChzdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIEtleSBwYXRoIHNwZW5kaW5nIChzdGFjayBzaXplIGlzIDEgYWZ0ZXIgcmVtb3Zpbmcgb3B0aW9uYWwgYW5uZXgpXG4gICAgICByZXR1cm4gdGhpcy5jaGVja1NjaG5vcnJTaWduYXR1cmUoc3RhY2tbMF0sIHByb2dyYW0sIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFJPT1QsIGV4ZWNkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2NyaXB0IHBhdGggc3BlbmRpbmcgKHN0YWNrIHNpemUgaXMgPjEgYWZ0ZXIgcmVtb3Zpbmcgb3B0aW9uYWwgYW5uZXgpXG4gICAgICBjb25zdCBjb250cm9sID0gc3RhY2sucG9wKCk7XG4gICAgICBjb25zdCBzY3JpcHRQdWJLZXlCdWYgPSBzdGFjay5wb3AoKTtcblxuICAgICAgaWYgKFxuICAgICAgICBjb250cm9sLmxlbmd0aCA8IEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9CQVNFX1NJWkUgIHx8XG4gICAgICAgIGNvbnRyb2wubGVuZ3RoID4gSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX01BWF9TSVpFICAgfHxcbiAgICAgICAgKChjb250cm9sLmxlbmd0aCAtIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9CQVNFX1NJWkUpICUgSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX05PREVfU0laRSkgIT0gMFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVEFQUk9PVF9XUk9OR19DT05UUk9MX1NJWkUnO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBleGVjZGF0YS50YXBsZWFmSGFzaCA9IEludGVycHJldGVyLmNvbXB1dGVUYXBsZWFmSGFzaChjb250cm9sWzBdICYgSW50ZXJwcmV0ZXIuVEFQUk9PVF9MRUFGX01BU0ssIHNjcmlwdFB1YktleUJ1Zik7XG4gICAgICBpZiAoIUludGVycHJldGVyLnZlcmlmeVRhcHJvb3RDb21taXRtZW50KGNvbnRyb2wsIHByb2dyYW0sIGV4ZWNkYXRhLnRhcGxlYWZIYXNoKSkge1xuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1dJVE5FU1NfUFJPR1JBTV9NSVNNQVRDSCc7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGV4ZWNkYXRhLnRhcGxlYWZIYXNoSW5pdCA9IHRydWU7XG4gICAgICBpZiAoKGNvbnRyb2xbMF0gJiBJbnRlcnByZXRlci5UQVBST09UX0xFQUZfTUFTSykgPT09IEludGVycHJldGVyLlRBUFJPT1RfTEVBRl9UQVBTQ1JJUFQpIHtcbiAgICAgICAgLy8gVGFwc2NyaXB0IChsZWFmIHZlcnNpb24gMHhjMClcbiAgICAgICAgbGV0IHdpdG5lc3NTaXplO1xuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgYncgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgYncud3JpdGVWYXJpbnROdW0od2l0bmVzcy5sZW5ndGgpO1xuICAgICAgICAgIGZvciAobGV0IGVsZW1lbnQgb2Ygd2l0bmVzcykge1xuICAgICAgICAgICAgYncud3JpdGVWYXJpbnROdW0oZWxlbWVudC5sZW5ndGgpO1xuICAgICAgICAgICAgYncud3JpdGUoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdpdG5lc3NTaXplID0gYncudG9CdWZmZXIoKS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNjcmlwdFB1YktleSA9IG5ldyBTY3JpcHQoc2NyaXB0UHViS2V5QnVmKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gTm90ZSBob3cgdGhpcyBjb25kaXRpb24gd291bGQgbm90IGJlIHJlYWNoZWQgaWYgYW4gdW5rbm93biBPUF9TVUNDRVNTeCB3YXMgZm91bmRcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0JBRF9PUENPREUnO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4ZWNkYXRhLnZhbGlkYXRpb25XZWlnaHRMZWZ0ID0gd2l0bmVzc1NpemUgKyBTY3JpcHQuVkFMSURBVElPTl9XRUlHSFRfT0ZGU0VUO1xuICAgICAgICBleGVjZGF0YS52YWxpZGF0aW9uV2VpZ2h0TGVmdEluaXQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlV2l0bmVzc1NjcmlwdChzY3JpcHRQdWJLZXksIHN0YWNrLCBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQsIHNhdG9zaGlzLCBmbGFncywgZXhlY2RhdGEpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbm9uZSBvZiB0aGUgYWJvdmUgY29uZGl0aW9ucyBhcmUgbWV0IHRoZW4gdGhpcyBtdXN0IGJlIGFuIHVwZ3JhZGVkIHRhcHJvb3QgdmVyc2lvbi5cbiAgICAgIGlmIChmbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX1RBUFJPT1RfVkVSU0lPTikge1xuICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9UQVBST09UX1ZFUlNJT04nO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBGdXR1cmUgc29mdGZvcmsgY29tcGF0aWJpbGl0eVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKChmbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX1dJVE5FU1NfUFJPR1JBTSkpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9XSVRORVNTX1BST0dSQU0nO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPdGhlciB2ZXJzaW9uL3NpemUvcDJzaCBjb21iaW5hdGlvbnMgcmV0dXJuIHRydWUgZm9yIGZ1dHVyZSBzb2Z0Zm9yayBjb21wYXRpYmlsaXR5XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5JbnRlcnByZXRlci5wcm90b3R5cGUuZXhlY3V0ZVdpdG5lc3NTY3JpcHQgPSBmdW5jdGlvbihzY3JpcHRQdWJLZXksIHN0YWNrLCBzaWd2ZXJzaW9uLCBzYXRvc2hpcywgZmxhZ3MsIGV4ZWNkYXRhKSB7XG4gIGlmIChzaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQpIHtcbiAgICBmb3IgKGxldCBjaHVuayBvZiBzY3JpcHRQdWJLZXkuY2h1bmtzKSB7XG4gICAgICAvLyBOZXcgb3Bjb2RlcyB3aWxsIGJlIGxpc3RlZCBoZXJlLiBNYXkgdXNlIGEgZGlmZmVyZW50IHNpZ3ZlcnNpb24gdG8gbW9kaWZ5IGV4aXN0aW5nIG9wY29kZXMuXG4gICAgICBpZiAoT3Bjb2RlLmlzT3BTdWNjZXNzKGNodW5rLm9wY29kZW51bSkpIHtcbiAgICAgICAgaWYgKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX09QX1NVQ0NFU1MpIHtcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0RJU0NPVVJBR0VfT1BfU1VDQ0VTUyc7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRhcHNjcmlwdCBlbmZvcmNlcyBpbml0aWFsIHN0YWNrIHNpemUgbGltaXRzIChhbHRzdGFjayBpcyBlbXB0eSBoZXJlKVxuICAgIGlmIChzdGFjay5sZW5ndGggPiBJbnRlcnByZXRlci5NQVhfU1RBQ0tfU0laRSkge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TVEFDS19TSVpFJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBEaXNhbGxvdyBzdGFjayBpdGVtIHNpemUgPiBNQVhfU0NSSVBUX0VMRU1FTlRfU0laRSBpbiB3aXRuZXNzIHN0YWNrXG4gIGlmIChzdGFjay5sZW5ndGggJiYgc3RhY2suc29tZShlbGVtID0+IGVsZW0ubGVuZ3RoID4gSW50ZXJwcmV0ZXIuTUFYX1NDUklQVF9FTEVNRU5UX1NJWkUpKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9QVVNIX1NJWkUnO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuaW5pdGlhbGl6ZSgpO1xuXG4gIHRoaXMuc2V0KHtcbiAgICBzY3JpcHQ6IHNjcmlwdFB1YktleSxcbiAgICBzdGFjazogc3RhY2ssXG4gICAgc2lndmVyc2lvbjogc2lndmVyc2lvbixcbiAgICBzYXRvc2hpczogc2F0b3NoaXMsXG4gICAgZmxhZ3M6IGZsYWdzLFxuICAgIGV4ZWNkYXRhOiBleGVjZGF0YVxuICB9KTtcblxuICBpZiAoIXRoaXMuZXZhbHVhdGUoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPT0gMSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRVZBTF9GQUxTRSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGJ1ZiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgaWYgKCFJbnRlcnByZXRlci5jYXN0VG9Cb29sKGJ1ZikpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0VWQUxfRkFMU0VfSU5fU1RBQ0snO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8qKlxuICogVmVyaWZpZXMgYSBTY3JpcHQgYnkgZXhlY3V0aW5nIGl0IGFuZCByZXR1cm5zIHRydWUgaWYgaXQgaXMgdmFsaWQuXG4gKiBUaGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHByb3ZpZGVkIHdpdGggdGhlIHNjcmlwdFNpZyBhbmQgdGhlIHNjcmlwdFB1YmtleVxuICogc2VwYXJhdGVseS5cbiAqIEBwYXJhbSB7U2NyaXB0fSBzY3JpcHRTaWcgLSB0aGUgc2NyaXB0J3MgZmlyc3QgcGFydCAoY29ycmVzcG9uZGluZyB0byB0aGUgdHggaW5wdXQpXG4gKiBAcGFyYW0ge1NjcmlwdH0gc2NyaXB0UHVia2V5IC0gdGhlIHNjcmlwdCdzIGxhc3QgcGFydCAoY29ycmVzcG9uZGluZyB0byB0aGUgdHggb3V0cHV0KVxuICogQHBhcmFtIHtUcmFuc2FjdGlvbj19IHR4IC0gdGhlIFRyYW5zYWN0aW9uIGNvbnRhaW5pbmcgdGhlIHNjcmlwdFNpZyBpbiBvbmUgaW5wdXQgKHVzZWRcbiAqICAgIHRvIGNoZWNrIHNpZ25hdHVyZSB2YWxpZGl0eSBmb3Igc29tZSBvcGNvZGVzIGxpa2UgT1BfQ0hFQ0tTSUcpXG4gKiBAcGFyYW0ge251bWJlcn0gbmluIC0gaW5kZXggb2YgdGhlIHRyYW5zYWN0aW9uIGlucHV0IGNvbnRhaW5pbmcgdGhlIHNjcmlwdFNpZyB2ZXJpZmllZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyAtIGV2YWx1YXRpb24gZmxhZ3MuIFNlZSBJbnRlcnByZXRlci5TQ1JJUFRfKiBjb25zdGFudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXRuZXNzIC0gYXJyYXkgb2Ygd2l0bmVzcyBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gc2F0b3NoaXMgLSBudW1iZXIgb2Ygc2F0b3NoaXMgY3JlYXRlZCBieSB0aGlzIG91dHB1dFxuICpcbiAqIFRyYW5zbGF0ZWQgZnJvbSBiaXRjb2luZCdzIFZlcmlmeVNjcmlwdFxuICovXG5JbnRlcnByZXRlci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24oc2NyaXB0U2lnLCBzY3JpcHRQdWJrZXksIHR4LCBuaW4sIGZsYWdzLCB3aXRuZXNzLCBzYXRvc2hpcykge1xuXG4gIHZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uJyk7XG4gIGlmIChfLmlzVW5kZWZpbmVkKHR4KSkge1xuICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gIH1cbiAgaWYgKF8uaXNVbmRlZmluZWQobmluKSkge1xuICAgIG5pbiA9IDA7XG4gIH1cbiAgaWYgKF8uaXNVbmRlZmluZWQoZmxhZ3MpKSB7XG4gICAgZmxhZ3MgPSAwO1xuICB9XG4gIGlmIChfLmlzVW5kZWZpbmVkKHdpdG5lc3MpKSB7XG4gICAgd2l0bmVzcyA9IG51bGw7XG4gIH1cbiAgaWYgKF8uaXNVbmRlZmluZWQoc2F0b3NoaXMpKSB7XG4gICAgc2F0b3NoaXMgPSAwO1xuICB9XG5cbiAgdGhpcy5zZXQoe1xuICAgIHNjcmlwdDogc2NyaXB0U2lnLFxuICAgIHR4OiB0eCxcbiAgICBuaW46IG5pbixcbiAgICBzaWd2ZXJzaW9uOiBTaWduYXR1cmUuVmVyc2lvbi5CQVNFLFxuICAgIHNhdG9zaGlzOiAwLFxuICAgIGZsYWdzOiBmbGFnc1xuICB9KTtcbiAgdmFyIHN0YWNrQ29weTtcblxuICBpZiAoKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9TSUdQVVNIT05MWSkgIT09IDAgJiYgIXNjcmlwdFNpZy5pc1B1c2hPbmx5KCkpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NJR19QVVNIT05MWSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZXZhbHVhdGUgc2NyaXB0U2lnXG4gIGlmICghdGhpcy5ldmFsdWF0ZSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9QMlNIKSB7XG4gICAgc3RhY2tDb3B5ID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICB9XG5cbiAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaztcbiAgdGhpcy5pbml0aWFsaXplKCk7XG4gIHRoaXMuc2V0KHtcbiAgICBzY3JpcHQ6IHNjcmlwdFB1YmtleSxcbiAgICBzdGFjazogc3RhY2ssXG4gICAgdHg6IHR4LFxuICAgIG5pbjogbmluLFxuICAgIGZsYWdzOiBmbGFnc1xuICB9KTtcblxuICAvLyBldmFsdWF0ZSBzY3JpcHRQdWJrZXlcbiAgaWYgKCF0aGlzLmV2YWx1YXRlKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0VWQUxfRkFMU0VfTk9fUkVTVUxUJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYnVmID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICBpZiAoIUludGVycHJldGVyLmNhc3RUb0Jvb2woYnVmKSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRVZBTF9GQUxTRV9JTl9TVEFDSyc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhhZFdpdG5lc3MgPSBmYWxzZTtcbiAgaWYgKChmbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfV0lUTkVTUykpIHtcbiAgICB2YXIgd2l0bmVzc1ZhbHVlcyA9IHt9O1xuICAgIGlmIChzY3JpcHRQdWJrZXkuaXNXaXRuZXNzUHJvZ3JhbSh3aXRuZXNzVmFsdWVzKSkge1xuICAgICAgaGFkV2l0bmVzcyA9IHRydWU7XG4gICAgICBpZiAoc2NyaXB0U2lnLnRvQnVmZmVyKCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19NQUxMRUFURUQnO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMudmVyaWZ5V2l0bmVzc1Byb2dyYW0od2l0bmVzc1ZhbHVlcy52ZXJzaW9uLCB3aXRuZXNzVmFsdWVzLnByb2dyYW0sIHdpdG5lc3MsIHNhdG9zaGlzLCB0aGlzLmZsYWdzLCAvKiBpc1AyU0ggKi8gZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBZGRpdGlvbmFsIHZhbGlkYXRpb24gZm9yIHNwZW5kLXRvLXNjcmlwdC1oYXNoIHRyYW5zYWN0aW9uczpcbiAgaWYgKChmbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfUDJTSCkgJiYgc2NyaXB0UHVia2V5LmlzU2NyaXB0SGFzaE91dCgpKSB7XG4gICAgLy8gc2NyaXB0U2lnIG11c3QgYmUgbGl0ZXJhbHMtb25seSBvciB2YWxpZGF0aW9uIGZhaWxzXG4gICAgaWYgKCFzY3JpcHRTaWcuaXNQdXNoT25seSgpKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NJR19QVVNIT05MWSc7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gc3RhY2tDb3B5IGNhbm5vdCBiZSBlbXB0eSBoZXJlLCBiZWNhdXNlIGlmIGl0IHdhcyB0aGVcbiAgICAvLyBQMlNIICBIQVNIIDw+IEVRVUFMICBzY3JpcHRQdWJLZXkgd291bGQgYmUgZXZhbHVhdGVkIHdpdGhcbiAgICAvLyBhbiBlbXB0eSBzdGFjayBhbmQgdGhlIEV2YWxTY3JpcHQgYWJvdmUgd291bGQgcmV0dXJuIGZhbHNlLlxuICAgIGlmIChzdGFja0NvcHkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVybmFsIGVycm9yIC0gc3RhY2sgY29weSBlbXB0eScpO1xuICAgIH1cblxuICAgIHZhciByZWRlZW1TY3JpcHRTZXJpYWxpemVkID0gc3RhY2tDb3B5W3N0YWNrQ29weS5sZW5ndGggLSAxXTtcbiAgICB2YXIgcmVkZWVtU2NyaXB0ID0gU2NyaXB0LmZyb21CdWZmZXIocmVkZWVtU2NyaXB0U2VyaWFsaXplZCk7XG4gICAgc3RhY2tDb3B5LnBvcCgpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgc2NyaXB0OiByZWRlZW1TY3JpcHQsXG4gICAgICBzdGFjazogc3RhY2tDb3B5LFxuICAgICAgdHg6IHR4LFxuICAgICAgbmluOiBuaW4sXG4gICAgICBmbGFnczogZmxhZ3NcbiAgICB9KTtcblxuICAgIC8vIGV2YWx1YXRlIHJlZGVlbVNjcmlwdFxuICAgIGlmICghdGhpcy5ldmFsdWF0ZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrQ29weS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRVZBTF9GQUxTRV9OT19QMlNIX1NUQUNLJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIUludGVycHJldGVyLmNhc3RUb0Jvb2woc3RhY2tDb3B5W3N0YWNrQ29weS5sZW5ndGggLSAxXSkpIHtcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRVZBTF9GQUxTRV9JTl9QMlNIX1NUQUNLJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChmbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfV0lUTkVTUykpIHtcbiAgICAgIHZhciBwMnNoV2l0bmVzc1ZhbHVlcyA9IHt9O1xuICAgICAgaWYgKHJlZGVlbVNjcmlwdC5pc1dpdG5lc3NQcm9ncmFtKHAyc2hXaXRuZXNzVmFsdWVzKSkge1xuICAgICAgICBoYWRXaXRuZXNzID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJlZGVlbVNjcmlwdFB1c2ggPSBuZXcgU2NyaXB0KCk7XG4gICAgICAgIHJlZGVlbVNjcmlwdFB1c2guYWRkKHJlZGVlbVNjcmlwdC50b0J1ZmZlcigpKTtcbiAgICAgICAgaWYgKHNjcmlwdFNpZy50b0hleCgpICE9PSByZWRlZW1TY3JpcHRQdXNoLnRvSGV4KCkpIHtcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1dJVE5FU1NfTUFMTEVBVEVEX1AyU0gnO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy52ZXJpZnlXaXRuZXNzUHJvZ3JhbShwMnNoV2l0bmVzc1ZhbHVlcy52ZXJzaW9uLCBwMnNoV2l0bmVzc1ZhbHVlcy5wcm9ncmFtLCB3aXRuZXNzLCBzYXRvc2hpcywgdGhpcy5mbGFncywgLyogaXNQMlNIICovIHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ5cGFzcyB0aGUgY2xlYW5zdGFjayBjaGVjayBhdCB0aGUgZW5kLiBUaGUgYWN0dWFsIHN0YWNrIGlzIG9idmlvdXNseSBub3QgY2xlYW5cbiAgICAgICAgLy8gZm9yIHdpdG5lc3MgcHJvZ3JhbXMuXG4gICAgICAgIHN0YWNrID0gW3N0YWNrWzBdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUaGUgQ0xFQU5TVEFDSyBjaGVjayBpcyBvbmx5IHBlcmZvcm1lZCBhZnRlciBwb3RlbnRpYWwgUDJTSCBldmFsdWF0aW9uLFxuICAvLyBhcyB0aGUgbm9uLVAyU0ggZXZhbHVhdGlvbiBvZiBhIFAyU0ggc2NyaXB0IHdpbGwgb2J2aW91c2x5IG5vdCByZXN1bHQgaW5cbiAgLy8gYSBjbGVhbiBzdGFjayAodGhlIFAyU0ggaW5wdXRzIHJlbWFpbikuIFRoZSBzYW1lIGhvbGRzIGZvciB3aXRuZXNzXG4gIC8vIGV2YWx1YXRpb24uXG4gIGlmICgodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ0xFQU5TVEFDSykgIT0gMCkge1xuICAgICAgLy8gRGlzYWxsb3cgQ0xFQU5TVEFDSyB3aXRob3V0IFAyU0gsIGFzIG90aGVyd2lzZSBhIHN3aXRjaFxuICAgICAgLy8gQ0xFQU5TVEFDSy0+UDJTSCtDTEVBTlNUQUNLIHdvdWxkIGJlIHBvc3NpYmxlLCB3aGljaCBpcyBub3QgYVxuICAgICAgLy8gc29mdGZvcmsgKGFuZCBQMlNIIHNob3VsZCBiZSBvbmUpLlxuICAgICAgaWYgKFxuICAgICAgICAodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfUDJTSCkgICAgPT0gMCB8fFxuICAgICAgICAodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfV0lUTkVTUykgPT0gMFxuICAgICAgKSB7XG4gICAgICAgIHRocm93ICdmbGFncyAmIFNDUklQVF9WRVJJRllfUDJTSCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFja0NvcHkubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9DTEVBTlNUQUNLJztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKCh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9XSVRORVNTKSkge1xuICAgIGlmICghaGFkV2l0bmVzcyAmJiB3aXRuZXNzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfV0lUTkVTU19VTkVYUEVDVEVEJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJwcmV0ZXI7XG5cbkludGVycHJldGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gIHRoaXMuc3RhY2sgPSBbXTtcbiAgdGhpcy5hbHRzdGFjayA9IFtdO1xuICB0aGlzLnBjID0gMDtcbiAgdGhpcy5zYXRvc2hpcyA9IDA7XG4gIHRoaXMuc2lndmVyc2lvbiA9IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0U7XG4gIHRoaXMucGJlZ2luY29kZWhhc2ggPSAwO1xuICB0aGlzLm5PcENvdW50ID0gMDtcbiAgdGhpcy52ZkV4ZWMgPSBbXTtcbiAgdGhpcy5lcnJzdHIgPSAnJztcbiAgdGhpcy5mbGFncyA9IDA7XG4gIHRoaXMuZXhlY2RhdGEgPSB7fTtcbn07XG5cbkludGVycHJldGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5zY3JpcHQgPSBvYmouc2NyaXB0IHx8IHRoaXMuc2NyaXB0O1xuICB0aGlzLnR4ID0gb2JqLnR4IHx8IHRoaXMudHg7XG4gIHRoaXMubmluID0gdHlwZW9mIG9iai5uaW4gPT09ICd1bmRlZmluZWQnID8gdGhpcy5uaW4gOiBwYXJzZUludChvYmoubmluKTtcbiAgdGhpcy5zdGFjayA9IG9iai5zdGFjayB8fCB0aGlzLnN0YWNrO1xuICB0aGlzLmFsdHN0YWNrID0gb2JqLmFsdHN0YWNrIHx8IHRoaXMuYWx0c3RhY2s7XG4gIHRoaXMucGMgPSB0eXBlb2Ygb2JqLnBjID09PSAndW5kZWZpbmVkJyA/IHRoaXMucGMgOiBvYmoucGM7XG4gIHRoaXMucGJlZ2luY29kZWhhc2ggPSB0eXBlb2Ygb2JqLnBiZWdpbmNvZGVoYXNoID09PSAndW5kZWZpbmVkJyA/IHRoaXMucGJlZ2luY29kZWhhc2ggOiBvYmoucGJlZ2luY29kZWhhc2g7XG4gIHRoaXMuc2lndmVyc2lvbiA9IHR5cGVvZiBvYmouc2lndmVyc2lvbiA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNpZ3ZlcnNpb24gOiBvYmouc2lndmVyc2lvbjtcbiAgdGhpcy5zYXRvc2hpcyA9IHR5cGVvZiBvYmouc2F0b3NoaXMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zYXRvc2hpcyA6IG9iai5zYXRvc2hpcztcbiAgdGhpcy5uT3BDb3VudCA9IHR5cGVvZiBvYmoubk9wQ291bnQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5uT3BDb3VudCA6IG9iai5uT3BDb3VudDtcbiAgdGhpcy52ZkV4ZWMgPSBvYmoudmZFeGVjIHx8IHRoaXMudmZFeGVjO1xuICB0aGlzLmVycnN0ciA9IG9iai5lcnJzdHIgfHwgdGhpcy5lcnJzdHI7XG4gIHRoaXMuZmxhZ3MgPSB0eXBlb2Ygb2JqLmZsYWdzID09PSAndW5kZWZpbmVkJyA/IHRoaXMuZmxhZ3MgOiBvYmouZmxhZ3M7XG4gIHRoaXMuZXhlY2RhdGEgPSB0eXBlb2Ygb2JqLmV4ZWNkYXRhID09PSAndW5kZWZpbmVkJyA/IHRoaXMuZXhlY2RhdGEgOiAob2JqLmV4ZWNkYXRhIHx8IHt9KTtcbn07XG5cbkludGVycHJldGVyLnRydWUgPSBCdWZmZXIuZnJvbShbMV0pO1xuSW50ZXJwcmV0ZXIuZmFsc2UgPSBCdWZmZXIuZnJvbShbXSk7XG5cbkludGVycHJldGVyLk1BWF9TQ1JJUFRfU0laRSA9IDEwMDAwO1xuSW50ZXJwcmV0ZXIuTUFYX1NUQUNLX1NJWkUgPSAxMDAwO1xuSW50ZXJwcmV0ZXIuTUFYX1NDUklQVF9FTEVNRU5UX1NJWkUgPSA1MjA7XG5cbkludGVycHJldGVyLkxPQ0tUSU1FX1RIUkVTSE9MRCA9IDUwMDAwMDAwMDtcbkludGVycHJldGVyLkxPQ0tUSU1FX1RIUkVTSE9MRF9CTiA9IG5ldyBCTihJbnRlcnByZXRlci5MT0NLVElNRV9USFJFU0hPTEQpO1xuXG4vLyBmbGFncyB0YWtlbiBmcm9tIGJpdGNvaW5kXG4vLyBiaXRjb2luZCBjb21taXQ6IGI1ZDFiMTA5Mjk5OGJjOTUzMTM4NTZkNTM1YzYzMmVhNWE4ZjkxMDRcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfTk9ORSA9IDA7XG5cbi8vIEV2YWx1YXRlIFAyU0ggc3Vic2NyaXB0cyAoc29mdGZvcmsgc2FmZSwgQklQMTYpLlxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9QMlNIID0gKDEgPDwgMCk7XG5cbi8vIFBhc3NpbmcgYSBub24tc3RyaWN0LURFUiBzaWduYXR1cmUgb3Igb25lIHdpdGggdW5kZWZpbmVkIGhhc2h0eXBlIHRvIGEgY2hlY2tzaWcgb3BlcmF0aW9uIGNhdXNlcyBzY3JpcHQgZmFpbHVyZS5cbi8vIFBhc3NpbmcgYSBwdWJrZXkgdGhhdCBpcyBub3QgKDB4MDQgKyA2NCBieXRlcykgb3IgKDB4MDIgb3IgMHgwMyArIDMyIGJ5dGVzKSB0byBjaGVja3NpZyBjYXVzZXMgdGhhdCBwdWJrZXkgdG8gYmVcbi8vIHNraXBwZWQgKG5vdCBzb2Z0Zm9yayBzYWZlOiB0aGlzIGZsYWcgY2FuIHdpZGVuIHRoZSB2YWxpZGl0eSBvZiBPUF9DSEVDS1NJRyBPUF9OT1QpLlxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9TVFJJQ1RFTkMgPSAoMSA8PCAxKTtcblxuLy8gUGFzc2luZyBhIG5vbi1zdHJpY3QtREVSIHNpZ25hdHVyZSB0byBhIGNoZWNrc2lnIG9wZXJhdGlvbiBjYXVzZXMgc2NyaXB0IGZhaWx1cmUgKHNvZnRmb3JrIHNhZmUsIEJJUDYyIHJ1bGUgMSlcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfREVSU0lHID0gKDEgPDwgMik7XG5cbi8vIFBhc3NpbmcgYSBub24tc3RyaWN0LURFUiBzaWduYXR1cmUgb3Igb25lIHdpdGggUyA+IG9yZGVyLzIgdG8gYSBjaGVja3NpZyBvcGVyYXRpb24gY2F1c2VzIHNjcmlwdCBmYWlsdXJlXG4vLyAoc29mdGZvcmsgc2FmZSwgQklQNjIgcnVsZSA1KS5cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfTE9XX1MgPSAoMSA8PCAzKTtcblxuLy8gdmVyaWZ5IGR1bW15IHN0YWNrIGl0ZW0gY29uc3VtZWQgYnkgQ0hFQ0tNVUxUSVNJRyBpcyBvZiB6ZXJvLWxlbmd0aCAoc29mdGZvcmsgc2FmZSwgQklQNjIgcnVsZSA3KS5cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfTlVMTERVTU1ZID0gKDEgPDwgNCk7XG5cbi8vIFVzaW5nIGEgbm9uLXB1c2ggb3BlcmF0b3IgaW4gdGhlIHNjcmlwdFNpZyBjYXVzZXMgc2NyaXB0IGZhaWx1cmUgKHNvZnRmb3JrIHNhZmUsIEJJUDYyIHJ1bGUgMikuXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1NJR1BVU0hPTkxZID0gKDEgPDwgNSk7XG5cbi8vIFJlcXVpcmUgbWluaW1hbCBlbmNvZGluZ3MgZm9yIGFsbCBwdXNoIG9wZXJhdGlvbnMgKE9QXzAuLi4gT1BfMTYsIE9QXzFORUdBVEUgd2hlcmUgcG9zc2libGUsIGRpcmVjdFxuLy8gcHVzaGVzIHVwIHRvIDc1IGJ5dGVzLCBPUF9QVVNIREFUQSB1cCB0byAyNTUgYnl0ZXMsIE9QX1BVU0hEQVRBMiBmb3IgYW55dGhpbmcgbGFyZ2VyKS4gRXZhbHVhdGluZ1xuLy8gYW55IG90aGVyIHB1c2ggY2F1c2VzIHRoZSBzY3JpcHQgdG8gZmFpbCAoQklQNjIgcnVsZSAzKS5cbi8vIEluIGFkZGl0aW9uLCB3aGVuZXZlciBhIHN0YWNrIGVsZW1lbnQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBudW1iZXIsIGl0IG11c3QgYmUgb2YgbWluaW1hbCBsZW5ndGggKEJJUDYyIHJ1bGUgNCkuXG4vLyAoc29mdGZvcmsgc2FmZSlcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfTUlOSU1BTERBVEEgPSAoMSA8PCA2KTtcblxuLy8gRGlzY291cmFnZSB1c2Ugb2YgTk9QcyByZXNlcnZlZCBmb3IgdXBncmFkZXMgKE5PUDEtMTApXG4vL1xuLy8gUHJvdmlkZWQgc28gdGhhdCBub2RlcyBjYW4gYXZvaWQgYWNjZXB0aW5nIG9yIG1pbmluZyB0cmFuc2FjdGlvbnNcbi8vIGNvbnRhaW5pbmcgZXhlY3V0ZWQgTk9QJ3Mgd2hvc2UgbWVhbmluZyBtYXkgY2hhbmdlIGFmdGVyIGEgc29mdC1mb3JrLFxuLy8gdGh1cyByZW5kZXJpbmcgdGhlIHNjcmlwdCBpbnZhbGlkOyB3aXRoIHRoaXMgZmxhZyBzZXQgZXhlY3V0aW5nXG4vLyBkaXNjb3VyYWdlZCBOT1BzIGZhaWxzIHRoZSBzY3JpcHQuIFRoaXMgdmVyaWZpY2F0aW9uIGZsYWcgd2lsbCBuZXZlciBiZVxuLy8gYSBtYW5kYXRvcnkgZmxhZyBhcHBsaWVkIHRvIHNjcmlwdHMgaW4gYSBibG9jay4gTk9QcyB0aGF0IGFyZSBub3Rcbi8vIGV4ZWN1dGVkLCBlLmcuICB3aXRoaW4gYW4gdW5leGVjdXRlZCBJRiBFTkRJRiBibG9jaywgYXJlICpub3QqIHJlamVjdGVkLlxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfTk9QUyA9ICgxIDw8IDcpO1xuXG5cbi8vIFJlcXVpcmUgdGhhdCBvbmx5IGEgc2luZ2xlIHN0YWNrIGVsZW1lbnQgcmVtYWlucyBhZnRlciBldmFsdWF0aW9uLiBUaGlzXG4vLyBjaGFuZ2VzIHRoZSBzdWNjZXNzIGNyaXRlcmlvbiBmcm9tIFwiQXQgbGVhc3Qgb25lIHN0YWNrIGVsZW1lbnQgbXVzdFxuLy8gcmVtYWluLCBhbmQgd2hlbiBpbnRlcnByZXRlZCBhcyBhIGJvb2xlYW4sIGl0IG11c3QgYmUgdHJ1ZVwiIHRvIFwiRXhhY3RseVxuLy8gb25lIHN0YWNrIGVsZW1lbnQgbXVzdCByZW1haW4sIGFuZCB3aGVuIGludGVycHJldGVkIGFzIGEgYm9vbGVhbiwgaXQgbXVzdFxuLy8gYmUgdHJ1ZVwiLlxuLy8gKHNvZnRmb3JrIHNhZmUsIEJJUDYyIHJ1bGUgNilcbi8vIE5vdGU6IENMRUFOU1RBQ0sgc2hvdWxkIG5ldmVyIGJlIHVzZWQgd2l0aG91dCBQMlNIIG9yIFdJVE5FU1MuXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NMRUFOU1RBQ0sgPSAoMSA8PCA4KSxcblxuLy8gVmVyaWZ5IENIRUNLTE9DS1RJTUVWRVJJRllcbi8vXG4vLyBTZWUgQklQNjUgZm9yIGRldGFpbHMuXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NIRUNLTE9DS1RJTUVWRVJJRlkgPSAoMSA8PCA5KTtcblxuLy8gc3VwcG9ydCBDSEVDS1NFUVVFTkNFVkVSSUZZIG9wY29kZVxuLy9cbi8vIFNlZSBCSVAxMTIgZm9yIGRldGFpbHNcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ0hFQ0tTRVFVRU5DRVZFUklGWSA9ICgxIDw8IDEwKTtcblxuLy8gU3VwcG9ydCBzZWdyZWdhdGVkIHdpdG5lc3Ncbi8vXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1dJVE5FU1MgPSAoMSA8PCAxMSk7XG5cbi8vIE1ha2luZyB2MS12MTYgd2l0bmVzcyBwcm9ncmFtIG5vbi1zdGFuZGFyZFxuLy9cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX1dJVE5FU1NfUFJPR1JBTSA9ICgxIDw8IDEyKTtcblxuXG4vL1xuLy8gU2Vnd2l0IHNjcmlwdCBvbmx5OiBSZXF1aXJlIHRoZSBhcmd1bWVudCBvZiBPUF9JRi9OT1RJRiB0byBiZSBleGFjdGx5XG4vLyAweDAxIG9yIGVtcHR5IHZlY3RvclxuLy9cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfTUlOSU1BTElGID0gKDEgPDwgMTMpO1xuXG5cbi8vIFNpZ25hdHVyZShzKSBtdXN0IGJlIGVtcHR5IHZlY3RvciBpZiBhbiBDSEVDSyhNVUxUSSlTSUcgb3BlcmF0aW9uIGZhaWxlZFxuLy9cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfTlVMTEZBSUwgPSAoMSA8PCAxNCk7XG5cbi8vIFB1YmxpYyBrZXlzIGluIHNjcmlwdHMgbXVzdCBiZSBjb21wcmVzc2VkXG4vL1xuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9XSVRORVNTX1BVQktFWVRZUEUgPSAoMSA8PCAxNSk7XG5cbi8vIERvIHdlIGFjY2VwdCBzaWduYXR1cmUgdXNpbmcgU0lHSEFTSF9GT1JLSURcbi8vXG5JbnRlcnByZXRlci5TQ1JJUFRfRU5BQkxFX1NJR0hBU0hfRk9SS0lEID0gKDEgPDwgMTYpO1xuXG4vLyBEbyB3ZSBhY2NlcHQgYWN0aXZhdGUgcmVwbGF5IHByb3RlY3Rpb24gdXNpbmcgYSBkaWZmZXJlbnQgZm9yayBpZC5cbi8vXG5JbnRlcnByZXRlci5TQ1JJUFRfRU5BQkxFX1JFUExBWV9QUk9URUNUSU9OID0gKDEgPDwgMTcpO1xuXG4vLyBNYWtpbmcgT1BfQ09ERVNFUEFSQVRPUiBhbmQgRmluZEFuZERlbGV0ZSBmYWlsIGFueSBub24tc2Vnd2l0IHNjcmlwdHNcbi8vXG5JbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NPTlNUX1NDUklQVENPREUgPSAoMSA8PCAxNik7XG5cbi8vIFZlcmlmeSB0YXByb290IHNjcmlwdFxuLy9cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfVEFQUk9PVCA9ICgxIDw8IDE3KTtcblxuLy8gTWFraW5nIHVua25vd24gVGFwcm9vdCBsZWFmIHZlcnNpb25zIG5vbi1zdGFuZGFyZFxuLy9cbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX1RBUFJPT1RfVkVSU0lPTiA9ICgxIDw8IDE4KTtcblxuLy8gTWFraW5nIHVua25vd24gT1BfU1VDQ0VTUyBub24tc3RhbmRhcmRcbkludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9PUF9TVUNDRVNTID0gKDEgPDwgMTkpO1xuXG4vLyBNYWtpbmcgdW5rbm93biBwdWJsaWMga2V5IHZlcnNpb25zIChpbiBCSVAgMzQyIHNjcmlwdHMpIG5vbi1zdGFuZGFyZFxuSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfUFVCS0VZVFlQRSA9ICgxIDw8IDIwKTtcblxuXG5cbi8qIEJlbG93IGZsYWdzIGFwcGx5IGluIHRoZSBjb250ZXh0IG9mIEJJUCA2OCovXG4vKipcbiAqIElmIHRoaXMgZmxhZyBzZXQsIENUeEluOjpuU2VxdWVuY2UgaXMgTk9UIGludGVycHJldGVkIGFzIGEgcmVsYXRpdmVcbiAqIGxvY2stdGltZS5cbiAqL1xuSW50ZXJwcmV0ZXIuU0VRVUVOQ0VfTE9DS1RJTUVfRElTQUJMRV9GTEFHID0gKDEgPDwgMzEpO1xuXG4vKipcbiAqIElmIENUeEluOjpuU2VxdWVuY2UgZW5jb2RlcyBhIHJlbGF0aXZlIGxvY2stdGltZSBhbmQgdGhpcyBmbGFnIGlzIHNldCxcbiAqIHRoZSByZWxhdGl2ZSBsb2NrLXRpbWUgaGFzIHVuaXRzIG9mIDUxMiBzZWNvbmRzLCBvdGhlcndpc2UgaXQgc3BlY2lmaWVzXG4gKiBibG9ja3Mgd2l0aCBhIGdyYW51bGFyaXR5IG9mIDEuXG4gKi9cbkludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBRyA9ICgxIDw8IDIyKTtcblxuLyoqXG4gKiBJZiBDVHhJbjo6blNlcXVlbmNlIGVuY29kZXMgYSByZWxhdGl2ZSBsb2NrLXRpbWUsIHRoaXMgbWFzayBpcyBhcHBsaWVkIHRvXG4gKiBleHRyYWN0IHRoYXQgbG9jay10aW1lIGZyb20gdGhlIHNlcXVlbmNlIGZpZWxkLlxuICovXG5JbnRlcnByZXRlci5TRVFVRU5DRV9MT0NLVElNRV9NQVNLID0gMHgwMDAwZmZmZjtcblxuLyoqIFNpZ25hdHVyZSBoYXNoIHNpemVzICovXG5JbnRlcnByZXRlci5XSVRORVNTX1YwX1NDUklQVEhBU0hfU0laRSA9IDMyO1xuSW50ZXJwcmV0ZXIuV0lUTkVTU19WMF9LRVlIQVNIX1NJWkUgPSAyMDtcbkludGVycHJldGVyLldJVE5FU1NfVjFfVEFQUk9PVF9TSVpFID0gMzI7XG5cbkludGVycHJldGVyLlRBUFJPT1RfTEVBRl9NQVNLID0gMHhmZTtcbkludGVycHJldGVyLlRBUFJPT1RfTEVBRl9UQVBTQ1JJUFQgPSAweGMwO1xuSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX0JBU0VfU0laRSA9IDMzO1xuSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX05PREVfU0laRSA9IDMyO1xuSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX01BWF9OT0RFX0NPVU5UID0gMTI4O1xuSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX01BWF9TSVpFID0gSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX0JBU0VfU0laRSArIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9OT0RFX1NJWkUgKiBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfTUFYX05PREVfQ09VTlQ7XG5cbi8vIENvbmNlcHR1YWxseSwgdGhpcyBkb2Vzbid0IHJlYWxseSBiZWxvbmcgd2l0aCB0aGUgSW50ZXJwcmV0ZXIsIGJ1dCBJIGhhdmVuJ3QgZm91bmQgYSBiZXR0ZXIgcGxhY2UgZm9yIGl0LlxuSW50ZXJwcmV0ZXIuUFJPVE9DT0xfVkVSU0lPTiA9IDcwMDE2O1xuXG5JbnRlcnByZXRlci5jYXN0VG9Cb29sID0gZnVuY3Rpb24oYnVmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSAhPT0gMCkge1xuICAgICAgLy8gY2FuIGJlIG5lZ2F0aXZlIHplcm9cbiAgICAgIGlmIChpID09PSBidWYubGVuZ3RoIC0gMSAmJiBidWZbaV0gPT09IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlZCBmcm9tIGJpdGNvaW5kJ3MgQ2hlY2tTaWduYXR1cmVFbmNvZGluZ1xuICovXG5JbnRlcnByZXRlci5wcm90b3R5cGUuY2hlY2tTaWduYXR1cmVFbmNvZGluZyA9IGZ1bmN0aW9uKGJ1Zikge1xuICB2YXIgc2lnO1xuXG4gICAgLy8gRW1wdHkgc2lnbmF0dXJlLiBOb3Qgc3RyaWN0bHkgREVSIGVuY29kZWQsIGJ1dCBhbGxvd2VkIHRvIHByb3ZpZGUgYVxuICAgIC8vIGNvbXBhY3Qgd2F5IHRvIHByb3ZpZGUgYW4gaW52YWxpZCBzaWduYXR1cmUgZm9yIHVzZSB3aXRoIENIRUNLKE1VTFRJKVNJR1xuICAgIGlmIChidWYubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIGlmICgodGhpcy5mbGFncyAmIChJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RFUlNJRyB8IEludGVycHJldGVyLlNDUklQVF9WRVJJRllfTE9XX1MgfCBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1NUUklDVEVOQykpICE9PSAwICYmICFTaWduYXR1cmUuaXNUeERFUihidWYpKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TSUdfREVSX0lOVkFMSURfRk9STUFUJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0xPV19TKSAhPT0gMCkge1xuICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoYnVmKTtcbiAgICBpZiAoIXNpZy5oYXNMb3dTKCkpIHtcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX0RFUl9ISUdIX1MnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfU1RSSUNURU5DKSAhPT0gMCkge1xuICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoYnVmKTtcbiAgICBpZiAoIXNpZy5oYXNEZWZpbmVkSGFzaHR5cGUoKSkge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TSUdfSEFTSFRZUEUnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVkIGZyb20gYml0Y29pbmQncyBDaGVja1B1YktleUVuY29kaW5nXG4gKi9cbkludGVycHJldGVyLnByb3RvdHlwZS5jaGVja1B1YmtleUVuY29kaW5nID0gZnVuY3Rpb24oYnVmKSB7XG4gIGlmICgodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfU1RSSUNURU5DKSAhPT0gMCAmJiAhUHVibGljS2V5LmlzVmFsaWQoYnVmKSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfUFVCS0VZVFlQRSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gT25seSBjb21wcmVzc2VkIGtleXMgYXJlIGFjY2VwdGVkIGluIHNlZ3dpdFxuICBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX1dJVE5FU1NfUFVCS0VZVFlQRSkgIT0gMCAmJiB0aGlzLnNpZ3ZlcnNpb24gPT0gU2lnbmF0dXJlLlZlcnNpb24uV0lUTkVTU19WMCAmJiAhUHVibGljS2V5LmZyb21CdWZmZXIoYnVmKS5jb21wcmVzc2VkKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9XSVRORVNTX1BVQktFWVRZUEUnO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIFZlcmlmaWVzIEVDRFNBIHNpZ25hdHVyZVxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ1xuICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmtleVxuICogQHBhcmFtIHtOdW1iZXJ9IG5pblxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdFxuICogQHBhcmFtIHtOdW1iZXJ9IHNhdG9zaGlzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNoZWNrRWNkc2FTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcsIHB1YmtleSwgbmluLCBzdWJzY3JpcHQsIHNhdG9zaGlzKSB7XG4gIHZhciBzdWJzY3JpcHRCdWZmZXIgPSBzdWJzY3JpcHQudG9CdWZmZXIoKTtcbiAgdmFyIHNjcmlwdENvZGVXcml0ZXIgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gIHNjcmlwdENvZGVXcml0ZXIud3JpdGVWYXJpbnROdW0oc3Vic2NyaXB0QnVmZmVyLmxlbmd0aCk7XG4gIHNjcmlwdENvZGVXcml0ZXIud3JpdGUoc3Vic2NyaXB0QnVmZmVyKTtcblxuICAkLmNoZWNrU3RhdGUoSlNVdGlsLmlzTmF0dXJhbE51bWJlcihzYXRvc2hpcykpO1xuICB2YXIgc2F0b3NoaXNCdWZmZXIgPSBuZXcgQnVmZmVyV3JpdGVyKCkud3JpdGVVSW50NjRMRUJOKG5ldyBCTihzYXRvc2hpcykpLnRvQnVmZmVyKCk7XG5cbiAgdmFyIHZlcmlmaWVkID0gU2lnaGFzaFdpdG5lc3MudmVyaWZ5KFxuICAgIHRoaXMsXG4gICAgc2lnLFxuICAgIHB1YmtleSxcbiAgICBuaW4sXG4gICAgc2NyaXB0Q29kZVdyaXRlci50b0J1ZmZlcigpLFxuICAgIHNhdG9zaGlzQnVmZmVyXG4gICk7XG4gIHJldHVybiB2ZXJpZmllZDtcbn07XG5cblxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZVxuICogQHBhcmFtIHtTaWduYXR1cmV8QnVmZmVyfSBzaWdcbiAqIEBwYXJhbSB7UHVibGljS2V5fEJ1ZmZlcn0gcHVia2V5XG4gKiBAcGFyYW0ge051bWJlcn0gc2lndmVyc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGV4ZWNkYXRhXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNoZWNrU2Nobm9yclNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZywgcHVia2V5LCBzaWd2ZXJzaW9uLCBleGVjZGF0YSkge1xuICAkLmNoZWNrQXJndW1lbnQoc2lnICYmIEJ1ZmZlci5pc0J1ZmZlcihzaWcpLCAnTWlzc2luZyBzaWcnKTtcbiAgJC5jaGVja0FyZ3VtZW50KHB1YmtleSAmJiBCdWZmZXIuaXNCdWZmZXIocHVia2V5KSwgJ01pc3NpbmcgcHVia2V5Jyk7XG4gICQuY2hlY2tBcmd1bWVudChzaWd2ZXJzaW9uLCAnTWlzc2luZyBzaWd2ZXJzaW9uJyk7XG4gICQuY2hlY2tBcmd1bWVudChleGVjZGF0YSwgJ01pc3NpbmcgZXhlY2RhdGEnKTtcblxuICAkLmNoZWNrQXJndW1lbnQocHVia2V5Lmxlbmd0aCA9PT0gMzIsICdTY2hub3JyIHNpZ25hdHVyZXMgaGF2ZSAzMi1ieXRlIHB1YmxpYyBrZXlzLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbmZvcmNpbmcgdGhpcy4nKTtcbiAgLy8gTm90ZSB0aGF0IGluIFRhcHNjcmlwdCBldmFsdWF0aW9uLCBlbXB0eSBzaWduYXR1cmVzIGFyZSB0cmVhdGVkIHNwZWNpYWxseSAoaW52YWxpZCBzaWduYXR1cmUgdGhhdCBkb2VzIG5vdFxuICAvLyBhYm9ydCBzY3JpcHQgZXhlY3V0aW9uKS4gVGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBFdmFsQ2hlY2tzaWdUYXBzY3JpcHQsIHdoaWNoIHdvbid0IGludm9rZVxuICAvLyBDaGVja1NjaG5vcnJTaWduYXR1cmUgaW4gdGhhdCBjYXNlLiBJbiBvdGhlciBjb250ZXh0cywgdGhleSBhcmUgaW52YWxpZCBsaWtlIGV2ZXJ5IG90aGVyIHNpZ25hdHVyZSB3aXRoXG4gIC8vIHNpemUgZGlmZmVyZW50IGZyb20gNjQgb3IgNjUuXG4gIGlmICghKHNpZy5sZW5ndGggPT09IDY0IHx8IHNpZy5sZW5ndGggPT09IDY1KSkge1xuICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0NITk9SUl9TSUdfU0laRSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHNpZy5sZW5ndGggPT09IDY1ICYmIHNpZ1tzaWcubGVuZ3RoIC0gMV0gPT09IFNpZ25hdHVyZS5TSUdIQVNIX0RFRkFVTFQpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NDSE5PUlJfU0lHX0hBU0hUWVBFJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2lnID0gU2lnbmF0dXJlLmZyb21TY2hub3JyKHNpZyk7XG4gIGNvbnN0IHZlcmlmaWVkID0gU2lnaGFzaFNjaG5vcnIudmVyaWZ5KFxuICAgIHRoaXMudHgsXG4gICAgc2lnLFxuICAgIHB1YmtleSxcbiAgICBzaWd2ZXJzaW9uLFxuICAgIHRoaXMubmluLFxuICAgIGV4ZWNkYXRhXG4gICk7XG4gIHJldHVybiB2ZXJpZmllZDtcbn07XG5cblxuLyoqXG4gKiBCYXNlZCBvbiBiaXRjb2luZCdzIEV2YWxDaGVja3NpZ1ByZVRhcHNjcmlwdCBmdW5jdGlvblxuICogYml0Y29pbmQgY29tbWl0OiBhMDk4ODE0MGI3MTQ4NWFkMTJjM2MzYTRhOTU3M2Y3YzIxYjFlZmY4XG4gKi9cbkludGVycHJldGVyLnByb3RvdHlwZS5fZXZhbENoZWNrc2lnUHJlVGFwc2NyaXB0ID0gZnVuY3Rpb24oYnVmU2lnLCBidWZQdWJrZXkpIHtcbiAgJC5jaGVja0FyZ3VtZW50KFxuICAgIHRoaXMuc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uQkFTRSB8fCB0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjAsXG4gICAgJ3NpZ3ZlcnNpb24gbXVzdCBiZSBiYXNlIG9yIHdpdG5lc3NfdjAnXG4gICk7XG5cbiAgLy8gU3VjY2VzcyBzaWduaWZpZXMgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAgLy8gUmVzdWx0IHNpZ25pZmllcyB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY2l0b24sIHdoaWNoIGFsc28gdGFrZXMgZmxhZ3MgaW50byBhY2NvdW50LlxuICBjb25zdCByZXRWYWwgPSB7IHN1Y2Nlc3M6IGZhbHNlLCByZXN1bHQ6IGZhbHNlIH07XG5cbiAgY29uc3Qgc3Vic2NyaXB0ID0gbmV3IFNjcmlwdCgpLnNldCh7XG4gICAgY2h1bmtzOiB0aGlzLnNjcmlwdC5jaHVua3Muc2xpY2UodGhpcy5wYmVnaW5jb2RlaGFzaClcbiAgfSk7XG5cbiAgLy8gRHJvcCB0aGUgc2lnbmF0dXJlIGluIHByZS1zZWd3aXQgc2NyaXB0cyBidXQgbm90IHNlZ3dpdCBzY3JpcHRzXG4gIGlmICh0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UpIHtcbiAgICAvLyBEcm9wIHRoZSBzaWduYXR1cmUsIHNpbmNlIHRoZXJlJ3Mgbm8gd2F5IGZvciBhIHNpZ25hdHVyZSB0byBzaWduIGl0c2VsZlxuICAgIGNvbnN0IHRtcFNjcmlwdCA9IG5ldyBTY3JpcHQoKS5hZGQoYnVmU2lnKTtcbiAgICBsZXQgZm91bmQgPSBzdWJzY3JpcHQuY2h1bmtzLmxlbmd0aDtcbiAgICBzdWJzY3JpcHQuZmluZEFuZERlbGV0ZSh0bXBTY3JpcHQpO1xuXG4gICAgZm91bmQgPSBmb3VuZCA9PSBzdWJzY3JpcHQuY2h1bmtzLmxlbmd0aCArIDE7IC8vIGZvdW5kIGlmIGEgY2h1bmsgd2FzIHJlbW92ZWRcbiAgICBpZiAoZm91bmQgJiYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NPTlNUX1NDUklQVENPREUpKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NJR19GSU5EQU5EREVMRVRFJztcbiAgICAgIHJldHVybiByZXRWYWw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLmNoZWNrU2lnbmF0dXJlRW5jb2RpbmcoYnVmU2lnKSB8fCAhdGhpcy5jaGVja1B1YmtleUVuY29kaW5nKGJ1ZlB1YmtleSkpIHtcbiAgICByZXR1cm4gcmV0VmFsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzaWcgPSBTaWduYXR1cmUuZnJvbVR4Rm9ybWF0KGJ1ZlNpZyk7XG4gICAgY29uc3QgcHVia2V5ID0gUHVibGljS2V5LmZyb21CdWZmZXIoYnVmUHVia2V5LCBmYWxzZSk7XG4gICAgcmV0VmFsLnN1Y2Nlc3MgPSB0aGlzLnR4LnZlcmlmeVNpZ25hdHVyZShzaWcsIHB1YmtleSwgdGhpcy5uaW4sIHN1YnNjcmlwdCwgdGhpcy5zaWd2ZXJzaW9uLCB0aGlzLnNhdG9zaGlzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vaW52YWxpZCBzaWcgb3IgcHVia2V5XG4gICAgcmV0VmFsLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghcmV0VmFsLnN1Y2Nlc3MgJiYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX05VTExGQUlMKSAmJiBidWZTaWcubGVuZ3RoKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TSUdfTlVMTEZBSUwnO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH1cblxuICAvLyBJZiBpdCByZWFjaGVzIGhlcmUsIHRoZW4gdHJ1ZVxuICByZXRWYWwucmVzdWx0ID0gdHJ1ZTtcbiAgcmV0dXJuIHJldFZhbDtcbn07XG5cblxuLyoqXG4gKiBCYXNlZCBvbiBiaXRjb2luZCdzIEV2YWxDaGVja3NpZ1RhcHNjcmlwdCBmdW5jdGlvblxuICogYml0Y29pbmQgY29tbWl0OiBhMDk4ODE0MGI3MTQ4NWFkMTJjM2MzYTRhOTU3M2Y3YzIxYjFlZmY4XG4gKi9cbkludGVycHJldGVyLnByb3RvdHlwZS5fZXZhbENoZWNrc2lnVGFwc2NyaXB0ID0gZnVuY3Rpb24oYnVmU2lnLCBidWZQdWJrZXkpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHRoaXMuc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQsICd0aGlzLnNpZ3ZlcnNpb24gbXVzdCBieSBUQVBTQ1JJUFQnKTtcblxuICAvKlxuICAgICogIFRoZSBmb2xsb3dpbmcgdmFsaWRhdGlvbiBzZXF1ZW5jZSBpcyBjb25zZW5zdXMgY3JpdGljYWwuIFBsZWFzZSBub3RlIGhvdyAtLVxuICAgICogICAgdXBncmFkYWJsZSBwdWJsaWMga2V5IHZlcnNpb25zIHByZWNlZGUgb3RoZXIgcnVsZXM7XG4gICAgKiAgICB0aGUgc2NyaXB0IGV4ZWN1dGlvbiBmYWlscyB3aGVuIHVzaW5nIGVtcHR5IHNpZ25hdHVyZSB3aXRoIGludmFsaWQgcHVibGljIGtleTtcbiAgICAqICAgIHRoZSBzY3JpcHQgZXhlY3V0aW9uIGZhaWxzIHdoZW4gdXNpbmcgbm9uLWVtcHR5IGludmFsaWQgc2lnbmF0dXJlLlxuICAgICovXG5cbiAgLy8gU3VjY2VzcyBzaWduaWZpZXMgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAgLy8gUmVzdWx0IHNpZ25pZmllcyB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY2l0b24sIHdoaWNoIGFsc28gdGFrZXMgZmxhZ3MgaW50byBhY2NvdW50LlxuICBjb25zdCByZXRWYWwgPSB7XG4gICAgc3VjY2VzczogYnVmU2lnLmxlbmd0aCA+IDAsXG4gICAgcmVzdWx0OiBmYWxzZVxuICB9XG4gIGlmIChyZXRWYWwuc3VjY2Vzcykge1xuICAgIC8vIEltcGxlbWVudCB0aGUgc2lnb3BzL3dpdG5lc3NzaXplIHJhdGlvIHRlc3QuXG4gICAgLy8gUGFzc2luZyB3aXRoIGFuIHVwZ3JhZGFibGUgcHVibGljIGtleSB2ZXJzaW9uIGlzIGFsc28gY291bnRlZC5cbiAgICAkLmNoZWNrU3RhdGUodGhpcy5leGVjZGF0YS52YWxpZGF0aW9uV2VpZ2h0TGVmdEluaXQsICd2YWxpZGF0aW9uV2VpZ2h0TGVmdEluaXQgaXMgZmFsc2UnKTtcbiAgICB0aGlzLmV4ZWNkYXRhLnZhbGlkYXRpb25XZWlnaHRMZWZ0IC09IFNjcmlwdC5WQUxJREFUSU9OX1dFSUdIVF9QRVJfU0lHT1BfUEFTU0VEO1xuICAgIGlmICh0aGlzLmV4ZWNkYXRhLnZhbGlkYXRpb25XZWlnaHRMZWZ0IDwgMCkge1xuICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9UQVBTQ1JJUFRfVkFMSURBVElPTl9XRUlHSFQnO1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG4gIH1cbiAgaWYgKGJ1ZlB1YmtleS5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1BVQktFWVRZUEUnO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH0gZWxzZSBpZiAoYnVmUHVia2V5Lmxlbmd0aCA9PSAzMikge1xuICAgIGlmIChyZXRWYWwuc3VjY2VzcyAmJiAhdGhpcy50eC5jaGVja1NjaG5vcnJTaWduYXR1cmUoYnVmU2lnLCBidWZQdWJrZXksIHRoaXMubmluLCB0aGlzLnNpZ3ZlcnNpb24sIHRoaXMuZXhlY2RhdGEpKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NDSE5PUlJfU0lHJztcbiAgICAgIHJldHVybiByZXRWYWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8qXG4gICAgICAqICBOZXcgcHVibGljIGtleSB2ZXJzaW9uIHNvZnRmb3JrcyBzaG91bGQgYmUgZGVmaW5lZCBiZWZvcmUgdGhpcyBgZWxzZWAgYmxvY2suXG4gICAgICAqICBHZW5lcmFsbHksIHRoZSBuZXcgY29kZSBzaG91bGQgbm90IGRvIGFueXRoaW5nIGJ1dCBmYWlsaW5nIHRoZSBzY3JpcHQgZXhlY3V0aW9uLiBUbyBhdm9pZFxuICAgICAgKiAgY29uc2Vuc3VzIGJ1Z3MsIGl0IHNob3VsZCBub3QgbW9kaWZ5IGFueSBleGlzdGluZyB2YWx1ZXMgKGluY2x1ZGluZyBgc3VjY2Vzc2ApLlxuICAgICAgKi9cbiAgICBpZiAoKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9QVUJLRVlUWVBFKSAhPSAwKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9QVUJLRVlUWVBFJztcbiAgICAgIHJldHVybiByZXRWYWw7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgaXQgcmVhY2hlcyBoZXJlLCB0aGVuIHRydWVcbiAgcmV0VmFsLnJlc3VsdCA9IHRydWU7XG4gIHJldHVybiByZXRWYWw7XG59XG5cbi8qKlxuICogQmFzZWQgb24gYml0Y29pbmQncyBFdmFsQ2hlY2tzaWcgZnVuY3Rpb25cbiAqIGJpdGNvaW5kIGNvbW1pdDogYTA5ODgxNDBiNzE0ODVhZDEyYzNjM2E0YTk1NzNmN2MyMWIxZWZmOFxuICogQHJldHVybnMge3sgc3VjY2VzczogQm9vbGVhbiwgdmVyaWZpZWQ6IEJvb2xlYW4gfX1cbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLl9ldmFsQ2hlY2tTaWcgPSBmdW5jdGlvbihidWZTaWcsIGJ1ZlB1YmtleSkge1xuICBzd2l0Y2godGhpcy5zaWd2ZXJzaW9uKSB7XG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5CQVNFOlxuICAgIGNhc2UgU2lnbmF0dXJlLlZlcnNpb24uV0lUTkVTU19WMDpcbiAgICAgIC8vIGNvbnN0IHZlcmlmaWVkID0gdGhpcy5fZXZhbENoZWNrc2lnUHJlVGFwc2NyaXB0KGJ1ZlNpZywgYnVmUHVia2V5KTtcbiAgICAgIC8vIHJldHVybiB7IHN1Y2Nlc3M6IHZlcmlmaWVkLCB2ZXJpZmllZCB9OyAvLyBUaGlzIGlzIHRvIGtlZXAgdGhlIHNhbWUgcmV0dXJuIGZvcm1hdCBhcyBfZXZhbENoZWNrU2lnVGFwc2NyaXB0XG4gICAgICByZXR1cm4gdGhpcy5fZXZhbENoZWNrc2lnUHJlVGFwc2NyaXB0KGJ1ZlNpZywgYnVmUHVia2V5KTtcbiAgICBjYXNlIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVDpcbiAgICAgIHJldHVybiB0aGlzLl9ldmFsQ2hlY2tzaWdUYXBzY3JpcHQoYnVmU2lnLCBidWZQdWJrZXkpO1xuICAgIGNhc2UgU2lnbmF0dXJlLlZlcnNpb24uVEFQUk9PVDpcbiAgICAgIC8vIEtleSBwYXRoIHNwZW5kaW5nIGluIFRhcHJvb3QgaGFzIG5vIHNjcmlwdCwgc28gdGhpcyBpcyB1bnJlYWNoYWJsZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGVkIGV2YWxDaGVja1NpZyB3aXRoIGEgVEFQUk9PVCBzaWd2ZXJzaW9uLiBDaGVjayB5b3VyIGltcGxlbWVudGF0aW9uJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZWQgb24gYml0Y29pbmQncyBFdmFsU2NyaXB0IGZ1bmN0aW9uLCB3aXRoIHRoZSBpbm5lciBsb29wIG1vdmVkIHRvXG4gKiBJbnRlcnByZXRlci5wcm90b3R5cGUuc3RlcCgpXG4gKiBiaXRjb2luZCBjb21taXQ6IGI1ZDFiMTA5Mjk5OGJjOTUzMTM4NTZkNTM1YzYzMmVhNWE4ZjkxMDRcbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNpZ3ZlcnNpb24gY2Fubm90IGJlIFRBUFJPT1QgaGVyZSwgYXMgaXQgYWRtaXRzIG5vIHNjcmlwdCBleGVjdXRpb24uXG4gICQuY2hlY2tBcmd1bWVudCh0aGlzLnNpZ3ZlcnNpb24gPT0gU2lnbmF0dXJlLlZlcnNpb24uQkFTRSB8fCB0aGlzLnNpZ3ZlcnNpb24gPT0gU2lnbmF0dXJlLlZlcnNpb24uV0lUTkVTU19WMCB8fCB0aGlzLnNpZ3ZlcnNpb24gPT0gU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBULCAnaW52YWxpZCBzaWd2ZXJzaW9uJyk7XG5cbiAgaWYgKFxuICAgICh0aGlzLnNpZ3ZlcnNpb24gPT0gU2lnbmF0dXJlLlZlcnNpb24uQkFTRSB8fCB0aGlzLnNpZ3ZlcnNpb24gPT0gU2lnbmF0dXJlLlZlcnNpb24uV0lUTkVTU19WMCkgJiZcbiAgICB0aGlzLnNjcmlwdC50b0J1ZmZlcigpLmxlbmd0aCA+IEludGVycHJldGVyLk1BWF9TQ1JJUFRfU0laRVxuICApIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NDUklQVF9TSVpFJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHdoaWxlICh0aGlzLnBjIDwgdGhpcy5zY3JpcHQuY2h1bmtzLmxlbmd0aCkge1xuICAgICAgdmFyIGZTdWNjZXNzID0gdGhpcy5zdGVwKCk7XG4gICAgICBpZiAoIWZTdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1VOS05PV05fRVJST1I6ICcgKyBlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLnZmRXhlYy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9VTkJBTEFOQ0VEX0NPTkRJVElPTkFMJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGEgbG9ja3RpbWUgcGFyYW1ldGVyIHdpdGggdGhlIHRyYW5zYWN0aW9uJ3MgbG9ja3RpbWUuXG4gKiBUaGVyZSBhcmUgdHdvIHRpbWVzIG9mIG5Mb2NrVGltZTogbG9jay1ieS1ibG9ja2hlaWdodCBhbmQgbG9jay1ieS1ibG9ja3RpbWUsXG4gKiBkaXN0aW5ndWlzaGVkIGJ5IHdoZXRoZXIgbkxvY2tUaW1lIDwgTE9DS1RJTUVfVEhSRVNIT0xEID0gNTAwMDAwMDAwXG4gKlxuICogU2VlIHRoZSBjb3JyZXNwb25kaW5nIGNvZGUgb24gYml0Y29pbiBjb3JlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9ibG9iL2ZmZDc1YWRjZTAxYTc4YjM0NjFiM2ZmMDViY2MyYjUzMGE5Y2U5OTQvc3JjL3NjcmlwdC9pbnRlcnByZXRlci5jcHAjTDExMjlcbiAqXG4gKiBAcGFyYW0ge0JOfSBuTG9ja1RpbWUgdGhlIGxvY2t0aW1lIHJlYWQgZnJvbSB0aGUgc2NyaXB0XG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbidzIGxvY2t0aW1lIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICogICAgICAgICAgICAgICAgICAgdGhlIHRyYW5zYWN0aW9uJ3MgbG9ja3RpbWVcbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNoZWNrTG9ja1RpbWUgPSBmdW5jdGlvbihuTG9ja1RpbWUpIHtcblxuICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgYXBwbGVzIHRvIGFwcGxlcywgc28gZmFpbCB0aGUgc2NyaXB0XG4gIC8vIHVubGVzcyB0aGUgdHlwZSBvZiBuTG9ja1RpbWUgYmVpbmcgdGVzdGVkIGlzIHRoZSBzYW1lIGFzXG4gIC8vIHRoZSBuTG9ja1RpbWUgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICBpZiAoIShcbiAgICAodGhpcy50eC5uTG9ja1RpbWUgPCAgSW50ZXJwcmV0ZXIuTE9DS1RJTUVfVEhSRVNIT0xEICYmIG5Mb2NrVGltZS5sdChJbnRlcnByZXRlci5MT0NLVElNRV9USFJFU0hPTERfQk4pKSB8fFxuICAgICh0aGlzLnR4Lm5Mb2NrVGltZSA+PSBJbnRlcnByZXRlci5MT0NLVElNRV9USFJFU0hPTEQgJiYgbkxvY2tUaW1lLmd0ZShJbnRlcnByZXRlci5MT0NLVElNRV9USFJFU0hPTERfQk4pKVxuICApKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTm93IHRoYXQgd2Uga25vdyB3ZSdyZSBjb21wYXJpbmcgYXBwbGVzLXRvLWFwcGxlcywgdGhlXG4gIC8vIGNvbXBhcmlzb24gaXMgYSBzaW1wbGUgbnVtZXJpYyBvbmUuXG4gIGlmIChuTG9ja1RpbWUuZ3QobmV3IEJOKHRoaXMudHgubkxvY2tUaW1lKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGaW5hbGx5IHRoZSBuTG9ja1RpbWUgZmVhdHVyZSBjYW4gYmUgZGlzYWJsZWQgYW5kIHRodXNcbiAgLy8gQ0hFQ0tMT0NLVElNRVZFUklGWSBieXBhc3NlZCBpZiBldmVyeSB0eGluIGhhcyBiZWVuXG4gIC8vIGZpbmFsaXplZCBieSBzZXR0aW5nIG5TZXF1ZW5jZSB0byBtYXhpbnQuIFRoZVxuICAvLyB0cmFuc2FjdGlvbiB3b3VsZCBiZSBhbGxvd2VkIGludG8gdGhlIGJsb2NrY2hhaW4sIG1ha2luZ1xuICAvLyB0aGUgb3Bjb2RlIGluZWZmZWN0aXZlLlxuICAvL1xuICAvLyBUZXN0aW5nIGlmIHRoaXMgdmluIGlzIG5vdCBmaW5hbCBpcyBzdWZmaWNpZW50IHRvXG4gIC8vIHByZXZlbnQgdGhpcyBjb25kaXRpb24uIEFsdGVybmF0aXZlbHkgd2UgY291bGQgdGVzdCBhbGxcbiAgLy8gaW5wdXRzLCBidXQgdGVzdGluZyBqdXN0IHRoaXMgaW5wdXQgbWluaW1pemVzIHRoZSBkYXRhXG4gIC8vIHJlcXVpcmVkIHRvIHByb3ZlIGNvcnJlY3QgQ0hFQ0tMT0NLVElNRVZFUklGWSBleGVjdXRpb24uXG4gIGlmICghdGhpcy50eC5pbnB1dHNbdGhpcy5uaW5dLmlzRmluYWwoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogQ2hlY2tzIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHdpdGggdGhlIHRyYW5zYWN0aW9uJ3Mgc2VxdWVuY2UuXG4gKiBAcGFyYW0ge0JOfSBuU2VxdWVuY2UgdGhlIHNlcXVlbmNlIHJlYWQgZnJvbSB0aGUgc2NyaXB0XG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbidzIHNlcXVlbmNlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICogICAgICAgICAgICAgICAgICAgdGhlIHRyYW5zYWN0aW9uJ3Mgc2VxdWVuY2VcbiAqL1xuSW50ZXJwcmV0ZXIucHJvdG90eXBlLmNoZWNrU2VxdWVuY2UgPSBmdW5jdGlvbihuU2VxdWVuY2UpIHtcblxuICAvLyBSZWxhdGl2ZSBsb2NrIHRpbWVzIGFyZSBzdXBwb3J0ZWQgYnkgY29tcGFyaW5nIHRoZSBwYXNzZWQgaW4gb3BlcmFuZCB0b1xuICAvLyB0aGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBpbnB1dC5cbiAgdmFyIHR4VG9TZXF1ZW5jZSA9IHRoaXMudHguaW5wdXRzW3RoaXMubmluXS5zZXF1ZW5jZU51bWJlcjtcblxuICAvLyBGYWlsIGlmIHRoZSB0cmFuc2FjdGlvbidzIHZlcnNpb24gbnVtYmVyIGlzIG5vdCBzZXQgaGlnaCBlbm91Z2ggdG9cbiAgLy8gdHJpZ2dlciBCSVAgNjggcnVsZXMuXG4gIGlmICh0aGlzLnR4LnZlcnNpb24gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gU2VxdWVuY2UgbnVtYmVycyB3aXRoIHRoZWlyIG1vc3Qgc2lnbmlmaWNhbnQgYml0IHNldCBhcmUgbm90IGNvbnNlbnN1c1xuICAvLyBjb25zdHJhaW5lZC4gVGVzdGluZyB0aGF0IHRoZSB0cmFuc2FjdGlvbidzIHNlcXVlbmNlIG51bWJlciBkbyBub3QgaGF2ZVxuICAvLyB0aGlzIGJpdCBzZXQgcHJldmVudHMgdXNpbmcgdGhpcyBwcm9wZXJ0eSB0byBnZXQgYXJvdW5kIGFcbiAgLy8gQ0hFQ0tTRVFVRU5DRVZFUklGWSBjaGVjay5cbiAgaWYgKHR4VG9TZXF1ZW5jZSAmIEludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX0RJU0FCTEVfRkxBRykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE1hc2sgb2ZmIGFueSBiaXRzIHRoYXQgZG8gbm90IGhhdmUgY29uc2Vuc3VzLWVuZm9yY2VkIG1lYW5pbmcgYmVmb3JlXG4gIC8vIGRvaW5nIHRoZSBpbnRlZ2VyIGNvbXBhcmlzb25zXG4gIHZhciBuTG9ja1RpbWVNYXNrID1cbiAgICAgIEludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBRyB8IEludGVycHJldGVyLlNFUVVFTkNFX0xPQ0tUSU1FX01BU0s7XG4gIHZhciB0eFRvU2VxdWVuY2VNYXNrZWQgPSBuZXcgQk4odHhUb1NlcXVlbmNlICYgbkxvY2tUaW1lTWFzayk7XG4gIHZhciBuU2VxdWVuY2VNYXNrZWQgPSBuU2VxdWVuY2UuYW5kKG5ldyBCTihuTG9ja1RpbWVNYXNrKSk7XG5cbiAgLy8gVGhlcmUgYXJlIHR3byBraW5kcyBvZiBuU2VxdWVuY2U6IGxvY2stYnktYmxvY2toZWlnaHQgYW5kXG4gIC8vIGxvY2stYnktYmxvY2t0aW1lLCBkaXN0aW5ndWlzaGVkIGJ5IHdoZXRoZXIgblNlcXVlbmNlTWFza2VkIDxcbiAgLy8gQ1R4SW46OlNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBRy5cbiAgLy9cbiAgLy8gV2Ugd2FudCB0byBjb21wYXJlIGFwcGxlcyB0byBhcHBsZXMsIHNvIGZhaWwgdGhlIHNjcmlwdCB1bmxlc3MgdGhlIHR5cGVcbiAgLy8gb2YgblNlcXVlbmNlTWFza2VkIGJlaW5nIHRlc3RlZCBpcyB0aGUgc2FtZSBhcyB0aGUgblNlcXVlbmNlTWFza2VkIGluIHRoZVxuICAvLyB0cmFuc2FjdGlvbi5cbiAgdmFyIFNFUVVFTkNFX0xPQ0tUSU1FX1RZUEVfRkxBR19CTiA9IG5ldyBCTihJbnRlcnByZXRlci5TRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcpO1xuXG4gIGlmICghKCh0eFRvU2VxdWVuY2VNYXNrZWQubHQoU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOKSAgJiZcbiAgICAgICAgICBuU2VxdWVuY2VNYXNrZWQubHQoU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOKSkgfHxcbiAgICAgICAgKHR4VG9TZXF1ZW5jZU1hc2tlZC5ndGUoU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOKSAmJlxuICAgICAgICAgIG5TZXF1ZW5jZU1hc2tlZC5ndGUoU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHX0JOKSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTm93IHRoYXQgd2Uga25vdyB3ZSdyZSBjb21wYXJpbmcgYXBwbGVzLXRvLWFwcGxlcywgdGhlIGNvbXBhcmlzb24gaXMgYVxuICAvLyBzaW1wbGUgbnVtZXJpYyBvbmUuXG4gIHJldHVybiBuU2VxdWVuY2VNYXNrZWQubHRlKHR4VG9TZXF1ZW5jZU1hc2tlZClcbn1cblxuXG5JbnRlcnByZXRlci5jb21wdXRlVGFwbGVhZkhhc2ggPSBmdW5jdGlvbihsZWFmVmVyc2lvbiwgc2NyaXB0QnVmKSB7XG4gIGNvbnN0IHRhZ1dyaXRlciA9IFRhZ2dlZEhhc2guVEFQTEVBRjtcbiAgdGFnV3JpdGVyLndyaXRlVUludDgobGVhZlZlcnNpb24pO1xuICB0YWdXcml0ZXIud3JpdGVWYXJpbnROdW0oc2NyaXB0QnVmLmxlbmd0aCk7XG4gIHRhZ1dyaXRlci53cml0ZShzY3JpcHRCdWYpO1xuICByZXR1cm4gdGFnV3JpdGVyLmZpbmFsaXplKCk7XG59O1xuXG5cbkludGVycHJldGVyLmNvbXB1dGVUYXByb290TWVya2xlUm9vdCA9IGZ1bmN0aW9uKGNvbnRyb2wsIHRhcGxlYWZIYXNoKSB7XG4gIGNvbnN0IHBhdGhMZW4gPSAoY29udHJvbC5sZW5ndGggLSBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfQkFTRV9TSVpFKSAvIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9OT0RFX1NJWkU7XG4gIGxldCBrID0gdGFwbGVhZkhhc2g7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aExlbjsgKytpKSB7XG4gICAgY29uc3QgdGFnV3JpdGVyID0gVGFnZ2VkSGFzaC5UQVBCUkFOQ0g7XG4gICAgY29uc3Qgc3RhcnQgPSBJbnRlcnByZXRlci5UQVBST09UX0NPTlRST0xfQkFTRV9TSVpFICsgSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX05PREVfU0laRSAqIGk7XG4gICAgY29uc3Qgbm9kZSA9IGNvbnRyb2wuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX05PREVfU0laRSk7XG4gICAgaWYgKEJ1ZmZlci5jb21wYXJlKGssIG5vZGUpID09PSAtMSkge1xuICAgICAgdGFnV3JpdGVyLndyaXRlKGspO1xuICAgICAgdGFnV3JpdGVyLndyaXRlKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdXcml0ZXIud3JpdGUobm9kZSk7XG4gICAgICB0YWdXcml0ZXIud3JpdGUoayk7XG4gICAgfVxuICAgIGsgPSB0YWdXcml0ZXIuZmluYWxpemUoKTtcbiAgfVxuICByZXR1cm4gaztcbn07XG5cblxuSW50ZXJwcmV0ZXIudmVyaWZ5VGFwcm9vdENvbW1pdG1lbnQgPSBmdW5jdGlvbihjb250cm9sLCBwcm9ncmFtLCB0YXBsZWFmSGFzaCkge1xuICAkLmNoZWNrQXJndW1lbnQoY29udHJvbC5sZW5ndGggPj0gSW50ZXJwcmV0ZXIuVEFQUk9PVF9DT05UUk9MX0JBU0VfU0laRSwgJ2NvbnRyb2wgdG9vIHNob3J0Jyk7XG4gICQuY2hlY2tBcmd1bWVudChwcm9ncmFtLmxlbmd0aCA+PSAzMiwgJ3Byb2dyYW0gaXMgdG9vIHNob3J0Jyk7XG5cbiAgdHJ5IHtcbiAgICAvLyEgVGhlIGludGVybmFsIHB1YmtleSAoeC1vbmx5LCBzbyBubyBZIGNvb3JkaW5hdGUgcGFyaXR5KS5cbiAgICBjb25zdCBwID0gUHVibGljS2V5LmZyb21YKGZhbHNlLCBjb250cm9sLnNsaWNlKDEsIEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9CQVNFX1NJWkUpKTtcbiAgICAvLyEgVGhlIG91dHB1dCBwdWJrZXkgKHRha2VuIGZyb20gdGhlIHNjcmlwdFB1YktleSkuXG4gICAgY29uc3QgcSA9IFB1YmxpY0tleS5mcm9tWChmYWxzZSwgcHJvZ3JhbSk7XG4gICAgLy8gQ29tcHV0ZSB0aGUgTWVya2xlIHJvb3QgZnJvbSB0aGUgbGVhZiBhbmQgdGhlIHByb3ZpZGVkIHBhdGguXG4gICAgY29uc3QgbWVya2xlUm9vdCA9IEludGVycHJldGVyLmNvbXB1dGVUYXByb290TWVya2xlUm9vdChjb250cm9sLCB0YXBsZWFmSGFzaCk7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIG91dHB1dCBwdWJrZXkgbWF0Y2hlcyB0aGUgdHdlYWtlZCBpbnRlcm5hbCBwdWJrZXksIGFmdGVyIGNvcnJlY3RpbmcgZm9yIHBhcml0eS5cbiAgICByZXR1cm4gcS5jaGVja1RhcFR3ZWFrKHAsIG1lcmtsZVJvb3QsIGNvbnRyb2wpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBCYXNlZCBvbiB0aGUgaW5uZXIgbG9vcCBvZiBiaXRjb2luZCdzIEV2YWxTY3JpcHQgZnVuY3Rpb25cbiAqIGJpdGNvaW5kIGNvbW1pdDogYjVkMWIxMDkyOTk4YmM5NTMxMzg1NmQ1MzVjNjMyZWE1YThmOTEwNFxuICovXG5JbnRlcnByZXRlci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZlJlcXVpcmVNaW5pbWFsID0gKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX01JTklNQUxEQVRBKSAhPT0gMDtcblxuICAvL2Jvb2wgZkV4ZWMgPSAhY291bnQodmZFeGVjLmJlZ2luKCksIHZmRXhlYy5lbmQoKSwgZmFsc2UpO1xuICB2YXIgZkV4ZWMgPSAodGhpcy52ZkV4ZWMuaW5kZXhPZihmYWxzZSkgPT09IC0xKTtcbiAgdmFyIGJ1ZiwgYnVmMSwgYnVmMiwgc3BsaWNlZCwgbiwgeDEsIHgyLCBibiwgYm4xLCBibjIsIGJ1ZlNpZywgYnVmUHVia2V5LCBzdWJzY3JpcHQ7XG4gIHZhciBzaWcsIHB1YmtleTtcbiAgdmFyIGZWYWx1ZSwgZlN1Y2Nlc3M7XG4gIHRoaXMuZXhlY2RhdGEgPSB0aGlzLmV4ZWNkYXRhIHx8IHt9O1xuICBpZiAoIXRoaXMuZXhlY2RhdGEuY29kZXNlcGFyYXRvclBvc0luaXQpIHtcbiAgICB0aGlzLmV4ZWNkYXRhLmNvZGVzZXBhcmF0b3JQb3MgPSBuZXcgQk4oMHhGRkZGRkZGRik7XG4gICAgdGhpcy5leGVjZGF0YS5jb2Rlc2VwYXJhdG9yUG9zSW5pdCA9IHRydWU7XG4gIH1cblxuICAvLyBSZWFkIGluc3RydWN0aW9uXG4gIHZhciBjaHVuayA9IHRoaXMuc2NyaXB0LmNodW5rc1t0aGlzLnBjXTtcbiAgdGhpcy5wYysrO1xuICB2YXIgb3Bjb2RlbnVtID0gY2h1bmsub3Bjb2RlbnVtO1xuICBpZiAoXy5pc1VuZGVmaW5lZChvcGNvZGVudW0pKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9VTkRFRklORURfT1BDT0RFJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNodW5rLmJ1ZiAmJiBjaHVuay5idWYubGVuZ3RoID4gSW50ZXJwcmV0ZXIuTUFYX1NDUklQVF9FTEVNRU5UX1NJWkUpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1BVU0hfU0laRSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uQkFTRSB8fCB0aGlzLnNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjApIHtcbiAgICAvLyBOb3RlIGhvdyBPcGNvZGUuT1BfUkVTRVJWRUQgZG9lcyBub3QgY291bnQgdG93YXJkcyB0aGUgb3Bjb2RlIGxpbWl0LlxuICAgIGlmIChvcGNvZGVudW0gPiBPcGNvZGUuT1BfMTYgJiYgKysodGhpcy5uT3BDb3VudCkgPiAyMDEpIHtcbiAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfT1BfQ09VTlQnO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG5cbiAgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0NBVCB8fFxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1NVQlNUUiB8fFxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0xFRlQgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9SSUdIVCB8fFxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0lOVkVSVCB8fFxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0FORCB8fFxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX09SIHx8XG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfWE9SIHx8XG4gICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfMk1VTCB8fFxuICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QXzJESVYgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9NVUwgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9ESVYgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9NT0QgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9MU0hJRlQgfHxcbiAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9SU0hJRlQpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0RJU0FCTEVEX09QQ09ERSc7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2l0aCBTQ1JJUFRfVkVSSUZZX0NPTlNUX1NDUklQVENPREUsIE9QX0NPREVTRVBBUkFUT1IgaW4gbm9uLXNlZ3dpdCBzY3JpcHQgaXMgcmVqZWN0ZWQgZXZlbiBpbiBhbiB1bmV4ZWN1dGVkIGJyYW5jaFxuICBpZiAob3Bjb2RlbnVtID09IE9wY29kZS5PUF9DT0RFU0VQQVJBVE9SICYmIHRoaXMuc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uQkFTRSAmJiAodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfQ09OU1RfU0NSSVBUQ09ERSkpIHtcbiAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX09QX0NPREVTRVBBUkFUT1InO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChmRXhlYyAmJiAwIDw9IG9wY29kZW51bSAmJiBvcGNvZGVudW0gPD0gT3Bjb2RlLk9QX1BVU0hEQVRBNCkge1xuICAgIGlmIChmUmVxdWlyZU1pbmltYWwgJiYgIXRoaXMuc2NyaXB0LmNoZWNrTWluaW1hbFB1c2godGhpcy5wYyAtIDEpKSB7XG4gICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX01JTklNQUxEQVRBJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjaHVuay5idWYpIHtcbiAgICAgIHRoaXMuc3RhY2sucHVzaChJbnRlcnByZXRlci5mYWxzZSk7XG4gICAgfSBlbHNlIGlmIChjaHVuay5sZW4gIT09IGNodW5rLmJ1Zi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIG9mIHB1c2ggdmFsdWUgbm90IGVxdWFsIHRvIGxlbmd0aCBvZiBkYXRhJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhY2sucHVzaChjaHVuay5idWYpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmRXhlYyB8fCAoT3Bjb2RlLk9QX0lGIDw9IG9wY29kZW51bSAmJiBvcGNvZGVudW0gPD0gT3Bjb2RlLk9QX0VORElGKSkge1xuICAgIHN3aXRjaCAob3Bjb2RlbnVtKSB7XG4gICAgICAvLyBQdXNoIHZhbHVlXG4gICAgICBjYXNlIE9wY29kZS5PUF8xTkVHQVRFOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfMTpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzI6XG4gICAgICBjYXNlIE9wY29kZS5PUF8zOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfNDpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzU6XG4gICAgICBjYXNlIE9wY29kZS5PUF82OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfNzpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzg6XG4gICAgICBjYXNlIE9wY29kZS5PUF85OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfMTA6XG4gICAgICBjYXNlIE9wY29kZS5PUF8xMTpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzEyOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfMTM6XG4gICAgICBjYXNlIE9wY29kZS5PUF8xNDpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzE1OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfMTY6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoIC0tIHZhbHVlKVxuICAgICAgICAgIC8vIFNjcmlwdE51bSBibigoaW50KW9wY29kZSAtIChpbnQpKE9wY29kZS5PUF8xIC0gMSkpO1xuICAgICAgICAgIG4gPSBvcGNvZGVudW0gLSAoT3Bjb2RlLk9QXzEgLSAxKTtcbiAgICAgICAgICBidWYgPSBuZXcgQk4obikudG9TY3JpcHROdW1CdWZmZXIoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmKTtcbiAgICAgICAgICAvLyBUaGUgcmVzdWx0IG9mIHRoZXNlIG9wY29kZXMgc2hvdWxkIGFsd2F5cyBiZSB0aGUgbWluaW1hbCB3YXkgdG8gcHVzaCB0aGUgZGF0YVxuICAgICAgICAgIC8vIHRoZXkgcHVzaCwgc28gbm8gbmVlZCBmb3IgYSBDaGVja01pbmltYWxQdXNoIGhlcmUuXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBDb250cm9sXG4gICAgICAgIC8vXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A6XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1AyOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tMT0NLVElNRVZFUklGWTpcblxuICAgICAgICBpZiAoISh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9DSEVDS0xPQ0tUSU1FVkVSSUZZKSkge1xuICAgICAgICAgIC8vIG5vdCBlbmFibGVkOyB0cmVhdCBhcyBhIE5PUDJcbiAgICAgICAgICBpZiAodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfRElTQ09VUkFHRV9VUEdSQURBQkxFX05PUFMpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRElTQ09VUkFHRV9VUEdSQURBQkxFX05PUFMnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlIHRoYXQgZWxzZXdoZXJlIG51bWVyaWMgb3Bjb2RlcyBhcmUgbGltaXRlZCB0b1xuICAgICAgICAvLyBvcGVyYW5kcyBpbiB0aGUgcmFuZ2UgLTIqKjMxKzEgdG8gMioqMzEtMSwgaG93ZXZlciBpdCBpc1xuICAgICAgICAvLyBsZWdhbCBmb3Igb3Bjb2RlcyB0byBwcm9kdWNlIHJlc3VsdHMgZXhjZWVkaW5nIHRoYXRcbiAgICAgICAgLy8gcmFuZ2UuIFRoaXMgbGltaXRhdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBDU2NyaXB0TnVtJ3NcbiAgICAgICAgLy8gZGVmYXVsdCA0LWJ5dGUgbGltaXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlIGtlcHQgdG8gdGhhdCBsaW1pdCB3ZSdkIGhhdmUgYSB5ZWFyIDIwMzggcHJvYmxlbSxcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhlIG5Mb2NrVGltZSBmaWVsZCBpbiB0cmFuc2FjdGlvbnNcbiAgICAgICAgLy8gdGhlbXNlbHZlcyBpcyB1aW50MzIgd2hpY2ggb25seSBiZWNvbWVzIG1lYW5pbmdsZXNzXG4gICAgICAgIC8vIGFmdGVyIHRoZSB5ZWFyIDIxMDYuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRodXMgYXMgYSBzcGVjaWFsIGNhc2Ugd2UgdGVsbCBDU2NyaXB0TnVtIHRvIGFjY2VwdCB1cFxuICAgICAgICAvLyB0byA1LWJ5dGUgYmlnbnVtcywgd2hpY2ggYXJlIGdvb2QgdW50aWwgMioqMzktMSwgd2VsbFxuICAgICAgICAvLyBiZXlvbmQgdGhlIDIqKjMyLTEgbGltaXQgb2YgdGhlIG5Mb2NrVGltZSBmaWVsZCBpdHNlbGYuXG4gICAgICAgIHZhciBuTG9ja1RpbWUgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSwgZlJlcXVpcmVNaW5pbWFsLCA1KTtcblxuICAgICAgICAvLyBJbiB0aGUgcmFyZSBldmVudCB0aGF0IHRoZSBhcmd1bWVudCBtYXkgYmUgPCAwIGR1ZSB0b1xuICAgICAgICAvLyBzb21lIGFyaXRobWV0aWMgYmVpbmcgZG9uZSBmaXJzdCwgeW91IGNhbiBhbHdheXMgdXNlXG4gICAgICAgIC8vIDAgTUFYIENIRUNLTE9DS1RJTUVWRVJJRlkuXG4gICAgICAgIGlmIChuTG9ja1RpbWUubHQobmV3IEJOKDApKSkge1xuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfTkVHQVRJVkVfTE9DS1RJTUUnO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjdHVhbGx5IGNvbXBhcmUgdGhlIHNwZWNpZmllZCBsb2NrIHRpbWUgd2l0aCB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5jaGVja0xvY2tUaW1lKG5Mb2NrVGltZSkpIHtcbiAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1VOU0FUSVNGSUVEX0xPQ0tUSU1FJztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05PUDM6XG4gICAgICBjYXNlIE9wY29kZS5PUF9DSEVDS1NFUVVFTkNFVkVSSUZZOlxuXG4gICAgICAgIGlmICghKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0NIRUNLU0VRVUVOQ0VWRVJJRlkpKSB7XG4gICAgICAgICAgLy8gbm90IGVuYWJsZWQ7IHRyZWF0IGFzIGEgTk9QM1xuICAgICAgICAgIGlmICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9ESVNDT1VSQUdFX1VQR1JBREFCTEVfTk9QUykge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9ESVNDT1VSQUdFX1VQR1JBREFCTEVfTk9QUyc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gblNlcXVlbmNlLCBsaWtlIG5Mb2NrVGltZSwgaXMgYSAzMi1iaXQgdW5zaWduZWRcbiAgICAgICAgLy8gaW50ZWdlciBmaWVsZC4gU2VlIHRoZSBjb21tZW50IGluIENIRUNLTE9DS1RJTUVWRVJJRllcbiAgICAgICAgLy8gcmVnYXJkaW5nIDUtYnl0ZSBudW1lcmljIG9wZXJhbmRzLlxuXG4gICAgICAgIHZhciBuU2VxdWVuY2UgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSwgZlJlcXVpcmVNaW5pbWFsLCA1KTtcblxuXG4gICAgICAgIC8vIEluIHRoZSByYXJlIGV2ZW50IHRoYXQgdGhlIGFyZ3VtZW50IG1heSBiZSA8IDAgZHVlIHRvXG4gICAgICAgIC8vIHNvbWUgYXJpdGhtZXRpYyBiZWluZyBkb25lIGZpcnN0LCB5b3UgY2FuIGFsd2F5cyB1c2VcbiAgICAgICAgLy8gMCBNQVggQ0hFQ0tTRVFVRU5DRVZFUklGWS5cbiAgICAgICAgaWYgKG5TZXF1ZW5jZS5sdChuZXcgQk4oMCkpKSB7XG4gICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9ORUdBVElWRV9MT0NLVElNRSc7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gcHJvdmlkZSBmb3IgZnV0dXJlIHNvZnQtZm9yayBleHRlbnNpYmlsaXR5LCBpZiB0aGVcbiAgICAgICAgLy8gb3BlcmFuZCBoYXMgdGhlIGRpc2FibGVkIGxvY2stdGltZSBmbGFnIHNldCxcbiAgICAgICAgLy8gQ0hFQ0tTRVFVRU5DRVZFUklGWSBiZWhhdmVzIGFzIGEgTk9QLlxuICAgICAgICBpZiAoKG5TZXF1ZW5jZSAmXG4gICAgICAgICAgSW50ZXJwcmV0ZXIuU0VRVUVOQ0VfTE9DS1RJTUVfRElTQUJMRV9GTEFHKSAhPSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3R1YWxseSBjb21wYXJlIHRoZSBzcGVjaWZpZWQgbG9jayB0aW1lIHdpdGggdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTZXF1ZW5jZShuU2VxdWVuY2UpKSB7XG4gICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9VTlNBVElTRklFRF9MT0NLVElNRSc7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG5cblxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9QMTpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05PUDQ6XG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A1OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9QNjpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05PUDc6XG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1A4OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9QOTpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05PUDEwOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiBJbnRlcnByZXRlci5TQ1JJUFRfVkVSSUZZX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9OT1BTKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0RJU0NPVVJBR0VfVVBHUkFEQUJMRV9OT1BTJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0lGOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTk9USUY6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyA8ZXhwcmVzc2lvbj4gaWYgW3N0YXRlbWVudHNdIFtlbHNlIFtzdGF0ZW1lbnRzXV0gZW5kaWZcbiAgICAgICAgICAvLyBib29sIGZWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGZWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChmRXhlYykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1VOQkFMQU5DRURfQ09ORElUSU9OQUwnO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgLy8gVGFwc2NyaXB0IHJlcXVpcmVzIG1pbmltYWwgSUYvTk9USUYgaW5wdXRzIGFzIGEgY29uc2Vuc3VzIHJ1bGUuXG4gICAgICAgICAgICBpZiAodGhpcy5zaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IGFyZ3VtZW50IHRvIHRoZSBPUF9JRiBhbmQgT1BfTk9USUYgb3Bjb2RlcyBtdXN0IGJlIGVpdGhlclxuICAgICAgICAgICAgICAvLyBleGFjdGx5IDAgKHRoZSBlbXB0eSB2ZWN0b3IpIG9yIGV4YWN0bHkgMSAodGhlIG9uZS1ieXRlIHZlY3RvciB3aXRoIHZhbHVlIDEpLlxuICAgICAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA+IDEgfHwgKGJ1Zi5sZW5ndGggPT09IDEgJiYgYnVmWzBdICE9PSAxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVEFQU0NSSVBUX01JTklNQUxJRic7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmRlciB3aXRuZXNzIHYwIHJ1bGVzIGl0IGlzIG9ubHkgYSBwb2xpY3kgcnVsZSwgZW5hYmxlZCB0aHJvdWdoIFNDUklQVF9WRVJJRllfTUlOSU1BTElGLlxuICAgICAgICAgICAgaWYgKHRoaXMuc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uV0lUTkVTU19WMCAmJiAodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfTUlOSU1BTElGKSkge1xuICAgICAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGlmIChidWYubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfTUlOSU1BTElGJztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT0gMSAmJiBidWZbMF0hPTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX01JTklNQUxJRic7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmVmFsdWUgPSBJbnRlcnByZXRlci5jYXN0VG9Cb29sKGJ1Zik7XG4gICAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfTk9USUYpIHtcbiAgICAgICAgICAgICAgZlZhbHVlID0gIWZWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudmZFeGVjLnB1c2goZlZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfRUxTRTpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLnZmRXhlYy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVU5CQUxBTkNFRF9DT05ESVRJT05BTCc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudmZFeGVjW3RoaXMudmZFeGVjLmxlbmd0aCAtIDFdID0gIXRoaXMudmZFeGVjW3RoaXMudmZFeGVjLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9FTkRJRjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLnZmRXhlYy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfVU5CQUxBTkNFRF9DT05ESVRJT05BTCc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudmZFeGVjLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9WRVJJRlk6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAodHJ1ZSAtLSApIG9yXG4gICAgICAgICAgLy8gKGZhbHNlIC0tIGZhbHNlKSBhbmQgcmV0dXJuXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICBmVmFsdWUgPSBJbnRlcnByZXRlci5jYXN0VG9Cb29sKGJ1Zik7XG4gICAgICAgICAgaWYgKGZWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9WRVJJRlknO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfUkVUVVJOOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9PUF9SRVRVUk4nO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFN0YWNrIG9wc1xuICAgICAgICAvL1xuICAgICAgY2FzZSBPcGNvZGUuT1BfVE9BTFRTVEFDSzpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFsdHN0YWNrLnB1c2godGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0ZST01BTFRTVEFDSzpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLmFsdHN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9BTFRTVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5hbHRzdGFjay5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzJEUk9QOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHgxIHgyIC0tIClcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF8yRFVQOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHgxIHgyIC0tIHgxIHgyIHgxIHgyKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWYxID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIGJ1ZjIgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1ZjEpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfM0RVUDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4MSB4MiB4MyAtLSB4MSB4MiB4MyB4MSB4MiB4MylcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmMSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAzXTtcbiAgICAgICAgICBidWYyID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIHZhciBidWYzID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYxKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmMik7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1ZjMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF8yT1ZFUjpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4MSB4MiB4MyB4NCAtLSB4MSB4MiB4MyB4NCB4MSB4MilcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmMSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSA0XTtcbiAgICAgICAgICBidWYyID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDNdO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYxKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmMik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzJST1Q6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgeDMgeDQgeDUgeDYgLS0geDMgeDQgeDUgeDYgeDEgeDIpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZWQgPSB0aGlzLnN0YWNrLnNwbGljZSh0aGlzLnN0YWNrLmxlbmd0aCAtIDYsIDIpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChzcGxpY2VkWzBdKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goc3BsaWNlZFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzJTV0FQOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHgxIHgyIHgzIHg0IC0tIHgzIHg0IHgxIHgyKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGxpY2VkID0gdGhpcy5zdGFjay5zcGxpY2UodGhpcy5zdGFjay5sZW5ndGggLSA0LCAyKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goc3BsaWNlZFswXSk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHNwbGljZWRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9JRkRVUDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4IC0gMCB8IHggeClcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGZWYWx1ZSA9IEludGVycHJldGVyLmNhc3RUb0Jvb2woYnVmKTtcbiAgICAgICAgICBpZiAoZlZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnVmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0RFUFRIOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gLS0gc3RhY2tzaXplXG4gICAgICAgICAgYnVmID0gbmV3IEJOKHRoaXMuc3RhY2subGVuZ3RoKS50b1NjcmlwdE51bUJ1ZmZlcigpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidWYpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9EUk9QOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKHggLS0gKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9EVVA6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeCAtLSB4IHgpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9OSVA6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgLS0geDIpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhY2suc3BsaWNlKHRoaXMuc3RhY2subGVuZ3RoIC0gMiwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX09WRVI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgLS0geDEgeDIgeDEpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9QSUNLOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfUk9MTDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4biAuLi4geDIgeDEgeDAgbiAtIHhuIC4uLiB4MiB4MSB4MCB4bilcbiAgICAgICAgICAvLyAoeG4gLi4uIHgyIHgxIHgwIG4gLSAuLi4geDIgeDEgeDAgeG4pXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICBibiA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIoYnVmLCBmUmVxdWlyZU1pbmltYWwpO1xuICAgICAgICAgIG4gPSBibi50b051bWJlcigpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gbiAtIDFdO1xuICAgICAgICAgIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9ST0xMKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSh0aGlzLnN0YWNrLmxlbmd0aCAtIG4gLSAxLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1JPVDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4MSB4MiB4MyAtLSB4MiB4MyB4MSlcbiAgICAgICAgICAvLyAgeDIgeDEgeDMgIGFmdGVyIGZpcnN0IHN3YXBcbiAgICAgICAgICAvLyAgeDIgeDMgeDEgIGFmdGVyIHNlY29uZCBzd2FwXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHgxID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDNdO1xuICAgICAgICAgIHgyID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIHZhciB4MyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gM10gPSB4MjtcbiAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl0gPSB4MztcbiAgICAgICAgICB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPSB4MTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfU1dBUDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4MSB4MiAtLSB4MiB4MSlcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeDEgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XG4gICAgICAgICAgeDIgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdID0geDI7XG4gICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0geDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX1RVQ0s6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgLS0geDIgeDEgeDIpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhY2suc3BsaWNlKHRoaXMuc3RhY2subGVuZ3RoIC0gMiwgMCwgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuXG4gICAgICBjYXNlIE9wY29kZS5PUF9TSVpFOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKGluIC0tIGluIHNpemUpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJuID0gbmV3IEJOKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXS5sZW5ndGgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChibi50b1NjcmlwdE51bUJ1ZmZlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJpdHdpc2UgbG9naWNcbiAgICAgICAgLy9cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0VRVUFMOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfRVFVQUxWRVJJRlk6XG4gICAgICAgIC8vY2FzZSBPcGNvZGUuT1BfTk9URVFVQUw6IC8vIHVzZSBPcGNvZGUuT1BfTlVNTk9URVFVQUxcbiAgICAgICAge1xuICAgICAgICAgIC8vICh4MSB4MiAtIGJvb2wpXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZjEgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XG4gICAgICAgICAgYnVmMiA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgZkVxdWFsID0gYnVmMS50b1N0cmluZygnaGV4JykgPT09IGJ1ZjIudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZkVxdWFsID8gSW50ZXJwcmV0ZXIudHJ1ZSA6IEludGVycHJldGVyLmZhbHNlKTtcbiAgICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfRVFVQUxWRVJJRlkpIHtcbiAgICAgICAgICAgIGlmIChmRXF1YWwpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfRVFVQUxWRVJJRlknO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTnVtZXJpY1xuICAgICAgICAvL1xuICAgICAgY2FzZSBPcGNvZGUuT1BfMUFERDpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QXzFTVUI6XG4gICAgICBjYXNlIE9wY29kZS5PUF9ORUdBVEU6XG4gICAgICBjYXNlIE9wY29kZS5PUF9BQlM6XG4gICAgICBjYXNlIE9wY29kZS5PUF9OT1Q6XG4gICAgICBjYXNlIE9wY29kZS5PUF8wTk9URVFVQUw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoaW4gLS0gb3V0KVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWYgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgYm4gPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKGJ1ZiwgZlJlcXVpcmVNaW5pbWFsKTtcbiAgICAgICAgICBzd2l0Y2ggKG9wY29kZW51bSkge1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfMUFERDpcbiAgICAgICAgICAgICAgYm4gPSBibi5hZGQoQk4uT25lKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF8xU1VCOlxuICAgICAgICAgICAgICBibiA9IGJuLnN1YihCTi5PbmUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX05FR0FURTpcbiAgICAgICAgICAgICAgYm4gPSBibi5uZWcoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9BQlM6XG4gICAgICAgICAgICAgIGlmIChibi5jbXAoQk4uWmVybykgPCAwKSB7XG4gICAgICAgICAgICAgICAgYm4gPSBibi5uZWcoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX05PVDpcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKGJuLmNtcChCTi5aZXJvKSA9PT0gMCkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF8wTk9URVFVQUw6XG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibi5jbXAoQk4uWmVybykgIT09IDApICsgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvL2RlZmF1bHQ6ICAgICAgYXNzZXJ0KCEnaW52YWxpZCBvcGNvZGUnKTsgYnJlYWs7IC8vIFRPRE86IGRvZXMgdGhpcyBldmVyIG9jY3VyP1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChibi50b1NjcmlwdE51bUJ1ZmZlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBPcGNvZGUuT1BfQUREOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfU1VCOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfQk9PTEFORDpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0JPT0xPUjpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX05VTUVRVUFMOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfTlVNRVFVQUxWRVJJRlk6XG4gICAgICBjYXNlIE9wY29kZS5PUF9OVU1OT1RFUVVBTDpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0xFU1NUSEFOOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfR1JFQVRFUlRIQU46XG4gICAgICBjYXNlIE9wY29kZS5PUF9MRVNTVEhBTk9SRVFVQUw6XG4gICAgICBjYXNlIE9wY29kZS5PUF9HUkVBVEVSVEhBTk9SRVFVQUw6XG4gICAgICBjYXNlIE9wY29kZS5PUF9NSU46XG4gICAgICBjYXNlIE9wY29kZS5PUF9NQVg6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeDEgeDIgLS0gb3V0KVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBibjEgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXSwgZlJlcXVpcmVNaW5pbWFsKTtcbiAgICAgICAgICBibjIgPSBCTi5mcm9tU2NyaXB0TnVtQnVmZmVyKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSwgZlJlcXVpcmVNaW5pbWFsKTtcbiAgICAgICAgICBibiA9IG5ldyBCTigwKTtcblxuICAgICAgICAgIHN3aXRjaCAob3Bjb2RlbnVtKSB7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9BREQ6XG4gICAgICAgICAgICAgIGJuID0gYm4xLmFkZChibjIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfU1VCOlxuICAgICAgICAgICAgICBibiA9IGJuMS5zdWIoYm4yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgLy8gY2FzZSBPcGNvZGUuT1BfQk9PTEFORDogICAgICAgYm4gPSAoYm4xICE9IGJuWmVybyAmJiBibjIgIT0gYm5aZXJvKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9CT09MQU5EOlxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoKGJuMS5jbXAoQk4uWmVybykgIT09IDApICYmIChibjIuY21wKEJOLlplcm8pICE9PSAwKSkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0JPT0xPUjogICAgICAgIGJuID0gKGJuMSAhPSBiblplcm8gfHwgYm4yICE9IGJuWmVybyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfQk9PTE9SOlxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoKGJuMS5jbXAoQk4uWmVybykgIT09IDApIHx8IChibjIuY21wKEJOLlplcm8pICE9PSAwKSkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX05VTUVRVUFMOiAgICAgIGJuID0gKGJuMSA9PSBibjIpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX05VTUVRVUFMOlxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoYm4xLmNtcChibjIpID09PSAwKSArIDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgLy8gY2FzZSBPcGNvZGUuT1BfTlVNRVFVQUxWRVJJRlk6ICAgIGJuID0gKGJuMSA9PSBibjIpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX05VTUVRVUFMVkVSSUZZOlxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoYm4xLmNtcChibjIpID09PSAwKSArIDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgLy8gY2FzZSBPcGNvZGUuT1BfTlVNTk9URVFVQUw6ICAgICBibiA9IChibjEgIT0gYm4yKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9OVU1OT1RFUVVBTDpcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKGJuMS5jbXAoYm4yKSAhPT0gMCkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0xFU1NUSEFOOiAgICAgIGJuID0gKGJuMSA8IGJuMik7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfTEVTU1RIQU46XG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibjEuY21wKGJuMikgPCAwKSArIDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgLy8gY2FzZSBPcGNvZGUuT1BfR1JFQVRFUlRIQU46ICAgICBibiA9IChibjEgPiBibjIpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX0dSRUFURVJUSEFOOlxuICAgICAgICAgICAgICBibiA9IG5ldyBCTigoYm4xLmNtcChibjIpID4gMCkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0xFU1NUSEFOT1JFUVVBTDogICBibiA9IChibjEgPD0gYm4yKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9wY29kZS5PUF9MRVNTVEhBTk9SRVFVQUw6XG4gICAgICAgICAgICAgIGJuID0gbmV3IEJOKChibjEuY21wKGJuMikgPD0gMCkgKyAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGNhc2UgT3Bjb2RlLk9QX0dSRUFURVJUSEFOT1JFUVVBTDogIGJuID0gKGJuMSA+PSBibjIpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX0dSRUFURVJUSEFOT1JFUVVBTDpcbiAgICAgICAgICAgICAgYm4gPSBuZXcgQk4oKGJuMS5jbXAoYm4yKSA+PSAwKSArIDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT3Bjb2RlLk9QX01JTjpcbiAgICAgICAgICAgICAgYm4gPSAoYm4xLmNtcChibjIpIDwgMCA/IGJuMSA6IGJuMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPcGNvZGUuT1BfTUFYOlxuICAgICAgICAgICAgICBibiA9IChibjEuY21wKGJuMikgPiAwID8gYm4xIDogYm4yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGRlZmF1bHQ6ICAgICAgICAgICBhc3NlcnQoISdpbnZhbGlkIG9wY29kZScpOyBicmVhazsgLy9UT0RPOiBkb2VzIHRoaXMgZXZlciBvY2N1cj9cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChibi50b1NjcmlwdE51bUJ1ZmZlcigpKTtcblxuICAgICAgICAgIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9OVU1FUVVBTFZFUklGWSkge1xuICAgICAgICAgICAgLy8gaWYgKENhc3RUb0Jvb2woc3RhY2t0b3AoLTEpKSlcbiAgICAgICAgICAgIGlmIChJbnRlcnByZXRlci5jYXN0VG9Cb29sKHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfTlVNRVFVQUxWRVJJRlknO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9XSVRISU46XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoeCBtaW4gbWF4IC0tIG91dClcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm4xID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gM10sIGZSZXF1aXJlTWluaW1hbCk7XG4gICAgICAgICAgYm4yID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl0sIGZSZXF1aXJlTWluaW1hbCk7XG4gICAgICAgICAgdmFyIGJuMyA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdLCBmUmVxdWlyZU1pbmltYWwpO1xuICAgICAgICAgIC8vYm9vbCBmVmFsdWUgPSAoYm4yIDw9IGJuMSAmJiBibjEgPCBibjMpO1xuICAgICAgICAgIGZWYWx1ZSA9IChibjIuY21wKGJuMSkgPD0gMCkgJiYgKGJuMS5jbXAoYm4zKSA8IDApO1xuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmVmFsdWUgPyBJbnRlcnByZXRlci50cnVlIDogSW50ZXJwcmV0ZXIuZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQ3J5cHRvXG4gICAgICAgIC8vXG4gICAgICBjYXNlIE9wY29kZS5PUF9SSVBFTUQxNjA6XG4gICAgICBjYXNlIE9wY29kZS5PUF9TSEExOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfU0hBMjU2OlxuICAgICAgY2FzZSBPcGNvZGUuT1BfSEFTSDE2MDpcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0hBU0gyNTY6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoaW4gLS0gaGFzaClcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIC8vdmFsdHlwZSB2Y2hIYXNoKChvcGNvZGUgPT0gT3Bjb2RlLk9QX1JJUEVNRDE2MCB8fFxuICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBvcGNvZGUgPT0gT3Bjb2RlLk9QX1NIQTEgfHwgb3Bjb2RlID09IE9wY29kZS5PUF9IQVNIMTYwKSA/IDIwIDogMzIpO1xuICAgICAgICAgIHZhciBidWZIYXNoO1xuICAgICAgICAgIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9SSVBFTUQxNjApIHtcbiAgICAgICAgICAgIGJ1Zkhhc2ggPSBIYXNoLnJpcGVtZDE2MChidWYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfU0hBMSkge1xuICAgICAgICAgICAgYnVmSGFzaCA9IEhhc2guc2hhMShidWYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfU0hBMjU2KSB7XG4gICAgICAgICAgICBidWZIYXNoID0gSGFzaC5zaGEyNTYoYnVmKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0hBU0gxNjApIHtcbiAgICAgICAgICAgIGJ1Zkhhc2ggPSBIYXNoLnNoYTI1NnJpcGVtZDE2MChidWYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfSEFTSDI1Nikge1xuICAgICAgICAgICAgYnVmSGFzaCA9IEhhc2guc2hhMjU2c2hhMjU2KGJ1Zik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ1Zkhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIE9wY29kZS5PUF9DT0RFU0VQQVJBVE9SOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gSGFzaCBzdGFydHMgYWZ0ZXIgdGhlIGNvZGUgc2VwYXJhdG9yXG4gICAgICAgICAgdGhpcy5wYmVnaW5jb2RlaGFzaCA9IHRoaXMucGM7XG4gICAgICAgICAgdGhpcy5leGVjZGF0YS5jb2Rlc2VwYXJhdG9yUG9zID0gdGhpcy5wYyAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0NIRUNLU0lHOlxuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tTSUdWRVJJRlk6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAoc2lnIHB1YmtleSAtLSBib29sKVxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJ1ZlNpZyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgICBidWZQdWJrZXkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBjb25zdCB7IHN1Y2Nlc3M6IGZTdWNjZXNzLCByZXN1bHQgfSA9IHRoaXMuX2V2YWxDaGVja1NpZyhidWZTaWcsIGJ1ZlB1YmtleSk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICAvLyBzdGFjay5wdXNoX2JhY2soZlN1Y2Nlc3MgPyB2Y2hUcnVlIDogdmNoRmFsc2UpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmU3VjY2VzcyA/IEludGVycHJldGVyLnRydWUgOiBJbnRlcnByZXRlci5mYWxzZSk7XG4gICAgICAgICAgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0NIRUNLU0lHVkVSSUZZKSB7XG4gICAgICAgICAgICBpZiAoZlN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfQ0hFQ0tTSUdWRVJJRlknO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPcGNvZGUuT1BfQ0hFQ0tTSUdBREQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBPUF9DSEVDS1NJR0FERCBpcyBvbmx5IGF2YWlsYWJsZSBpbiBUYXBzY3JpcHRcbiAgICAgICAgICBpZiAodGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLkJBU0UgfHwgdGhpcy5zaWd2ZXJzaW9uID09IFNpZ25hdHVyZS5WZXJzaW9uLldJVE5FU1NfVjApIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfQkFEX09QQ09ERSc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gKHNpZyBudW0gcHVia2V5IC0tIG51bSlcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgc2lnID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDNdO1xuICAgICAgICAgIGxldCBudW0gPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XG4gICAgICAgICAgbGV0IHB1YmtleSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIG51bSA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIobnVtLCBmUmVxdWlyZU1pbmltYWwpO1xuXG4gICAgICAgICAgY29uc3QgeyBzdWNjZXNzLCByZXN1bHQgfSA9IHRoaXMuX2V2YWxDaGVja1NpZyhzaWcsIHB1YmtleSk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2gobnVtLmFkZG4oc3VjY2VzcyA/IDEgOiAwKS50b1NjcmlwdE51bUJ1ZmZlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgT3Bjb2RlLk9QX0NIRUNLTVVMVElTSUc6XG4gICAgICBjYXNlIE9wY29kZS5PUF9DSEVDS01VTFRJU0lHVkVSSUZZOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gKFtzaWcgLi4uXSBudW1fb2Zfc2lnbmF0dXJlcyBbcHVia2V5IC4uLl0gbnVtX29mX3B1YmtleXMgLS0gYm9vbClcblxuICAgICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCBpKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX0lOVkFMSURfU1RBQ0tfT1BFUkFUSU9OJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbktleXNDb3VudCA9IEJOLmZyb21TY3JpcHROdW1CdWZmZXIodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIGldLCBmUmVxdWlyZU1pbmltYWwpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgaWYgKG5LZXlzQ291bnQgPCAwIHx8IG5LZXlzQ291bnQgPiAyMCkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9QVUJLRVlfQ09VTlQnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5PcENvdW50ICs9IG5LZXlzQ291bnQ7XG4gICAgICAgICAgaWYgKHRoaXMubk9wQ291bnQgPiAyMDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfT1BfQ09VTlQnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbnQgaWtleSA9ICsraTtcbiAgICAgICAgICB2YXIgaWtleSA9ICsraTtcbiAgICAgICAgICBpICs9IG5LZXlzQ291bnQ7XG5cbiAgICAgICAgICAvLyBpa2V5MiBpcyB0aGUgcG9zaXRpb24gb2YgbGFzdCBub24tc2lnbmF0dXJlIGl0ZW0gaW5cbiAgICAgICAgICAvLyB0aGUgc3RhY2suIFRvcCBzdGFjayBpdGVtID0gMS4gV2l0aFxuICAgICAgICAgIC8vIFNDUklQVF9WRVJJRllfTlVMTEZBSUwsIHRoaXMgaXMgdXNlZCBmb3IgY2xlYW51cCBpZlxuICAgICAgICAgIC8vIG9wZXJhdGlvbiBmYWlscy5cbiAgICAgICAgICB2YXIgaWtleTIgPSBuS2V5c0NvdW50ICsgMjtcblxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IGkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuU2lnc0NvdW50ID0gQk4uZnJvbVNjcmlwdE51bUJ1ZmZlcih0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gaV0sIGZSZXF1aXJlTWluaW1hbCkudG9OdW1iZXIoKTtcbiAgICAgICAgICBpZiAoblNpZ3NDb3VudCA8IDAgfHwgblNpZ3NDb3VudCA+IG5LZXlzQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfU0lHX0NPVU5UJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaW50IGlzaWcgPSArK2k7XG4gICAgICAgICAgdmFyIGlzaWcgPSArK2k7XG4gICAgICAgICAgaSArPSBuU2lnc0NvdW50O1xuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IGkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfSU5WQUxJRF9TVEFDS19PUEVSQVRJT04nO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN1YnNldCBvZiBzY3JpcHQgc3RhcnRpbmcgYXQgdGhlIG1vc3QgcmVjZW50IGNvZGVzZXBhcmF0b3JcbiAgICAgICAgICBzdWJzY3JpcHQgPSBuZXcgU2NyaXB0KCkuc2V0KHtcbiAgICAgICAgICAgIGNodW5rczogdGhpcy5zY3JpcHQuY2h1bmtzLnNsaWNlKHRoaXMucGJlZ2luY29kZWhhc2gpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBEcm9wIHRoZSBzaWduYXR1cmVzLCBzaW5jZSB0aGVyZSdzIG5vIHdheSBmb3IgYSBzaWduYXR1cmUgdG8gc2lnbiBpdHNlbGZcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5TaWdzQ291bnQ7IGsrKykge1xuICAgICAgICAgICAgYnVmU2lnID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIGlzaWcgLSBrXTtcbiAgICAgICAgICAgIHN1YnNjcmlwdC5maW5kQW5kRGVsZXRlKG5ldyBTY3JpcHQoKS5hZGQoYnVmU2lnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZlN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgIHdoaWxlIChmU3VjY2VzcyAmJiBuU2lnc0NvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gdmFsdHlwZSYgdmNoU2lnICA9IHN0YWNrdG9wKC1pc2lnKTtcbiAgICAgICAgICAgIGJ1ZlNpZyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSBpc2lnXTtcbiAgICAgICAgICAgIC8vIHZhbHR5cGUmIHZjaFB1YktleSA9IHN0YWNrdG9wKC1pa2V5KTtcbiAgICAgICAgICAgIGJ1ZlB1YmtleSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSBpa2V5XTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU2lnbmF0dXJlRW5jb2RpbmcoYnVmU2lnKSB8fCAhdGhpcy5jaGVja1B1YmtleUVuY29kaW5nKGJ1ZlB1YmtleSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZk9rO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc2lnID0gU2lnbmF0dXJlLmZyb21UeEZvcm1hdChidWZTaWcpO1xuICAgICAgICAgICAgICBwdWJrZXkgPSBQdWJsaWNLZXkuZnJvbUJ1ZmZlcihidWZQdWJrZXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgZk9rID0gdGhpcy50eC52ZXJpZnlTaWduYXR1cmUoc2lnLCBwdWJrZXksIHRoaXMubmluLCBzdWJzY3JpcHQsIHRoaXMuc2lndmVyc2lvbiwgdGhpcy5zYXRvc2hpcywgdGhpcy5leGVjZGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vaW52YWxpZCBzaWcgb3IgcHVia2V5XG4gICAgICAgICAgICAgIGZPayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZk9rKSB7XG4gICAgICAgICAgICAgIGlzaWcrKztcbiAgICAgICAgICAgICAgblNpZ3NDb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWtleSsrO1xuICAgICAgICAgICAgbktleXNDb3VudC0tO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSBzaWduYXR1cmVzIGxlZnQgdGhhbiBrZXlzIGxlZnQsXG4gICAgICAgICAgICAvLyB0aGVuIHRvbyBtYW55IHNpZ25hdHVyZXMgaGF2ZSBmYWlsZWRcbiAgICAgICAgICAgIGlmIChuU2lnc0NvdW50ID4gbktleXNDb3VudCkge1xuICAgICAgICAgICAgICBmU3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgc3RhY2sgb2YgYWN0dWFsIGFyZ3VtZW50c1xuICAgICAgICAgIHdoaWxlIChpLS0gPiAxKSB7XG4gICAgICAgICAgICBpZiAoIWZTdWNjZXNzICYmICh0aGlzLmZsYWdzICYgSW50ZXJwcmV0ZXIuU0NSSVBUX1ZFUklGWV9OVUxMRkFJTCkgJiZcbiAgICAgICAgICAgICAgIWlrZXkyICYmIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXS5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX05VTExGQUlMJztcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWtleTIgPiAwKSB7XG4gICAgICAgICAgICAgIGlrZXkyLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQSBidWcgY2F1c2VzIENIRUNLTVVMVElTSUcgdG8gY29uc3VtZSBvbmUgZXh0cmEgYXJndW1lbnRcbiAgICAgICAgICAvLyB3aG9zZSBjb250ZW50cyB3ZXJlIG5vdCBjaGVja2VkIGluIGFueSB3YXkuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoaXMgaXMgYSBwb3RlbnRpYWwgc291cmNlIG9mIG11dGFiaWxpdHksXG4gICAgICAgICAgLy8gc28gb3B0aW9uYWxseSB2ZXJpZnkgaXQgaXMgZXhhY3RseSBlcXVhbCB0byB6ZXJvIHByaW9yXG4gICAgICAgICAgLy8gdG8gcmVtb3ZpbmcgaXQgZnJvbSB0aGUgc3RhY2suXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9JTlZBTElEX1NUQUNLX09QRVJBVElPTic7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgodGhpcy5mbGFncyAmIEludGVycHJldGVyLlNDUklQVF9WRVJJRllfTlVMTERVTU1ZKSAmJiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVycnN0ciA9ICdTQ1JJUFRfRVJSX1NJR19OVUxMRFVNTVknO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZTdWNjZXNzID8gSW50ZXJwcmV0ZXIudHJ1ZSA6IEludGVycHJldGVyLmZhbHNlKTtcblxuICAgICAgICAgIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9DSEVDS01VTFRJU0lHVkVSSUZZKSB7XG4gICAgICAgICAgICBpZiAoZlN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfQ0hFQ0tNVUxUSVNJR1ZFUklGWSc7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZXJyc3RyID0gJ1NDUklQVF9FUlJfQkFEX09QQ09ERSc7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBTaXplIGxpbWl0c1xuICBpZiAodGhpcy5zdGFjay5sZW5ndGggKyB0aGlzLmFsdHN0YWNrLmxlbmd0aCA+IEludGVycHJldGVyLk1BWF9TVEFDS19TSVpFKSB7XG4gICAgdGhpcy5lcnJzdHIgPSAnU0NSSVBUX0VSUl9TVEFDS19TSVpFJztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/script/interpreter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/script/script.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/script/script.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Address = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Opcode = __webpack_require__(/*! ../opcode */ \"(ssr)/./node_modules/bitcore-lib/lib/opcode.js\");\nvar PublicKey = __webpack_require__(/*! ../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Networks = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/bitcore-lib/lib/networks.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\n/**\n * A bitcoin transaction script. Each transaction's inputs and outputs\n * has a script that is evaluated to validate it's spending.\n *\n * See https://en.bitcoin.it/wiki/Script\n *\n * @constructor\n * @param {Object|string|Buffer=} from optional data to populate script\n */\nvar Script = function Script(from) {\n  if (!(this instanceof Script)) {\n    return new Script(from);\n  }\n  this.chunks = [];\n\n  if (BufferUtil.isBuffer(from)) {\n    return Script.fromBuffer(from);\n  } else if (from instanceof Address) {\n    return Script.fromAddress(from);\n  } else if (from instanceof Script) {\n    return Script.fromBuffer(from.toBuffer());\n  } else if (typeof from === 'string') {\n    return Script.fromString(from);\n  } else if (_.isObject(from) && Array.isArray(from.chunks)) {\n    this.set(from);\n  }\n};\n\n\nScript.prototype.set = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  $.checkArgument(Array.isArray(obj.chunks));\n  this.chunks = obj.chunks;\n  return this;\n};\n\nScript.fromBuffer = function(buffer) {\n  var script = new Script();\n  script.chunks = [];\n\n  var br = new BufferReader(buffer);\n  while (!br.finished()) {\n    try {\n      var opcodenum = br.readUInt8();\n\n      var len, buf;\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        len = opcodenum;\n        script.chunks.push({\n          buf: br.read(len),\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        len = br.readUInt8();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        len = br.readUInt16LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        len = br.readUInt32LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (Opcode.isOpSuccess(opcodenum)) {\n        // OP_SUCCESSx processing overrides everything, including stack element size limits\n        buf = br.readAll();\n        len = buf.length;\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else {\n        script.chunks.push({\n          opcodenum: opcodenum\n        });\n      }\n    } catch (e) {\n      if (e instanceof RangeError) {\n        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));\n      }\n      throw e;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype.toBuffer = function() {\n  var bw = new BufferWriter();\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    var opcodenum = chunk.opcodenum;\n    bw.writeUInt8(chunk.opcodenum);\n    if (chunk.buf) {\n      if (opcodenum < Opcode.OP_PUSHDATA1) {\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        bw.writeUInt8(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        bw.writeUInt16LE(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        bw.writeUInt32LE(chunk.len);\n        bw.write(chunk.buf);\n      } else {\n        // Could reach here if opcodenum is OP_SUCCESSx (see comment in .fromBuffer)\n        bw.write(chunk.buf);\n      }\n    }\n  }\n\n  return bw.concat();\n};\n\nScript.fromASM = function(str) {\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (opcodenum == null) {\n      var buf = Buffer.from(tokens[i], 'hex');\n      script.chunks.push({\n        buf: buf,\n        len: buf.length,\n        opcodenum: buf.length\n      });\n      i = i + 1;\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2], 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.fromHex = function(str) {\n  return new Script(Buffer.from(str, 'hex'));\n};\n\nScript.fromString = function(str) {\n  if (JSUtil.isHexa(str) || str.length === 0) {\n    return new Script(Buffer.from(str, 'hex'));\n  }\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (opcodenum == null) {\n      opcodenum = parseInt(token);\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        script.chunks.push({\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\n          len: opcodenum,\n          opcodenum: opcodenum\n        });\n        i = i + 2;\n      } else {\n        throw new Error('Invalid script: ' + JSON.stringify(str));\n      }\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\n        throw new Error('Pushdata data must start with 0x');\n      }\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.prototype._chunkToString = function(chunk, type) {\n  var opcodenum = chunk.opcodenum;\n  var asm = (type === 'asm');\n  var str = '';\n  if (!chunk.buf) {\n    // no data chunk\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\n      if (asm) {\n        // A few cases where the opcode name differs from reverseMap\n        // aside from 1 to 16 data pushes.\n        if (opcodenum === 0) {\n          // OP_0 -> 0\n          str = str + ' 0';\n        } else if(opcodenum === 79) {\n          // OP_1NEGATE -> 1\n          str = str + ' -1';\n        } else {\n          str = str + ' ' + Opcode(opcodenum).toString();\n        }\n      } else {\n        str = str + ' ' + Opcode(opcodenum).toString();\n      }\n    } else {\n      var numstr = opcodenum.toString(16);\n      if (numstr.length % 2 !== 0) {\n        numstr = '0' + numstr;\n      }\n      if (asm) {\n        str = str + ' ' + numstr;\n      } else {\n        str = str + ' ' + '0x' + numstr;\n      }\n    }\n  } else {\n    // data chunk\n    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      str = str + ' ' + Opcode(opcodenum).toString();\n    }\n    if (chunk.len > 0) {\n      if (asm) {\n        str = str + ' ' + chunk.buf.toString('hex');\n      } else {\n        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');\n      }\n    }\n  }\n  return str;\n};\n\nScript.prototype.toASM = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk, 'asm');\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toString = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk);\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toHex = function() {\n  return this.toBuffer().toString('hex');\n};\n\nScript.prototype.inspect = function() {\n  return '<Script: ' + this.toString() + '>';\n};\n\n// script classification methods\n\n/**\n * @returns {boolean} if this is a pay to pubkey hash output script\n */\nScript.prototype.isPublicKeyHashOut = function() {\n  return !!(this.chunks.length === 5 &&\n    this.chunks[0].opcodenum === Opcode.OP_DUP &&\n    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&\n    this.chunks[2].buf &&\n    this.chunks[2].buf.length === 20 &&\n    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&\n    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\n};\n\n/**\n * @returns {boolean} if this is a pay to public key hash input script\n */\nScript.prototype.isPublicKeyHashIn = function() {\n  if (this.chunks.length === 2) {\n    var signatureBuf = this.chunks[0].buf;\n    var pubkeyBuf = this.chunks[1].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30 &&\n        pubkeyBuf &&\n        pubkeyBuf.length\n       ) {\n      var version = pubkeyBuf[0];\n      if ((version === 0x04 ||\n           version === 0x06 ||\n           version === 0x07) && pubkeyBuf.length === 65) {\n        return true;\n      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nScript.prototype.getPublicKey = function() {\n  $.checkState(this.isPublicKeyOut(), 'Can\\'t retrieve PublicKey from a non-PK output');\n  return this.chunks[0].buf;\n};\n\nScript.prototype.getPublicKeyHash = function() {\n  if (this.isPublicKeyHashOut()) {\n    return this.chunks[2].buf;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    return this.chunks[1].buf;\n  } else if (this.isTaproot()) {\n    return this.chunks[1].buf;\n  } else {\n    throw new Error('Can\\'t retrieve PublicKeyHash from a non-PKH output');\n  }\n};\n\n/**\n * @returns {boolean} if this is a public key output script\n */\nScript.prototype.isPublicKeyOut = function() {\n  if (this.chunks.length === 2 &&\n      this.chunks[0].buf &&\n      this.chunks[0].buf.length &&\n      this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\n    var pubkeyBuf = this.chunks[0].buf;\n    var version = pubkeyBuf[0];\n    var isVersion = false;\n    if ((version === 0x04 ||\n         version === 0x06 ||\n         version === 0x07) && pubkeyBuf.length === 65) {\n      isVersion = true;\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n      isVersion = true;\n    }\n    if (isVersion) {\n      return PublicKey.isValid(pubkeyBuf);\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a pay to public key input script\n */\nScript.prototype.isPublicKeyIn = function() {\n  if (this.chunks.length === 1) {\n    var signatureBuf = this.chunks[0].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh output script\n */\nScript.prototype.isScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 23 &&\n    buf[0] === Opcode.OP_HASH160 &&\n    buf[1] === 0x14 &&\n    buf[buf.length - 1] === Opcode.OP_EQUAL);\n};\n\n/**\n * @returns {boolean} if this is a p2wsh output script\n */\nScript.prototype.isWitnessScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 34 && buf[0] === Opcode.OP_0 && buf[1] === 32);\n};\n\n/**\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessPublicKeyHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 22 && buf[0] === Opcode.OP_0 && buf[1] === 20);\n};\n\n/**\n * @returns {boolean} if this is a p2tr output script\n */\nScript.prototype.isTaproot = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 34 && buf[0] === Opcode.OP_1 && buf[1] === 32);\n}\n\n/**\n * @param {Object=} values - The return values\n * @param {Number} values.version - Set with the witness version\n * @param {Buffer} values.program - Set with the witness program\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessProgram = function(values) {\n  if (!values) {\n    values = {};\n  }\n  var buf = this.toBuffer();\n  if (buf.length < 4 || buf.length > 42) {\n    return false;\n  }\n  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {\n    return false;\n  }\n\n  if (buf.length === buf[1] + 2) {\n    values.version = Opcode.decodeOpN(buf[0]);\n    values.program = buf.slice(2, buf.length);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh input script\n * Note that these are frequently indistinguishable from pubkeyhashin\n */\nScript.prototype.isScriptHashIn = function() {\n  if (this.chunks.length <= 1) {\n    return false;\n  }\n  var redeemChunk = this.chunks[this.chunks.length - 1];\n  var redeemBuf = redeemChunk.buf;\n  if (!redeemBuf) {\n    return false;\n  }\n\n  var redeemScript;\n  try {\n    redeemScript = Script.fromBuffer(redeemBuf);\n  } catch (e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      return false;\n    }\n    throw e;\n  }\n  var type = redeemScript.classify();\n  return type !== Script.types.UNKNOWN;\n};\n\n/**\n * @returns {boolean} if this is a mutlsig output script\n */\nScript.prototype.isMultisigOut = function() {\n  return (this.chunks.length > 3 &&\n    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&\n    this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {\n      return obj.buf && BufferUtil.isBuffer(obj.buf);\n    }) &&\n    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&\n    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG);\n};\n\n\n/**\n * @returns {boolean} if this is a multisig input script\n */\nScript.prototype.isMultisigIn = function() {\n  return this.chunks.length >= 2 &&\n    this.chunks[0].opcodenum === 0 &&\n    this.chunks.slice(1, this.chunks.length).every(function(obj) {\n      return obj.buf &&\n        BufferUtil.isBuffer(obj.buf) &&\n        Signature.isTxDER(obj.buf);\n    });\n};\n\n/**\n * @returns {boolean} true if this is a valid standard OP_RETURN output\n */\nScript.prototype.isDataOut = function() {\n  return this.chunks.length >= 1 &&\n    this.chunks[0].opcodenum === Opcode.OP_RETURN &&\n    (this.chunks.length === 1 ||\n      (this.chunks.length === 2 &&\n        this.chunks[1].buf &&\n        this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE &&\n        this.chunks[1].length === this.chunks.len));\n};\n\n/**\n * Retrieve the associated data for this script.\n * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.\n * In the case of a standard OP_RETURN, return the data\n * @returns {Buffer}\n */\nScript.prototype.getData = function() {\n  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut() || this.isTaproot()) {\n    if (this.chunks[1] == null) {\n      return Buffer.alloc(0);\n    } else {\n      return Buffer.from(this.chunks[1].buf);\n    }\n  }\n  if (this.isPublicKeyHashOut()) {\n    return Buffer.from(this.chunks[2].buf);\n  }\n  throw new Error('Unrecognized script type to get data from');\n};\n\n/**\n * @returns {boolean} if the script is only composed of data pushing\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\n */\nScript.prototype.isPushOnly = function() {\n  return this.chunks.every(function(chunk) {\n    return chunk.opcodenum <= Opcode.OP_16;\n  });\n};\n\n\nScript.types = {};\nScript.types.UNKNOWN = 'Unknown';\nScript.types.PUBKEY_OUT = 'Pay to public key';\nScript.types.PUBKEY_IN = 'Spend from public key';\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\nScript.types.MULTISIG_OUT = 'Pay to multisig';\nScript.types.MULTISIG_IN = 'Spend from multisig';\nScript.types.DATA_OUT = 'Data push';\n\nScript.OP_RETURN_STANDARD_SIZE = 80;\n\n// Tag for input annex. If there are at least two witness elements for a transaction input,\n// and the first byte of the last element is 0x50, this last element is called annex, and\n// has meanings independent of the script\nScript.ANNEX_TAG = 0x50;\n\n// Validation weight per passing signature (Tapscript only, see BIP 342).\nScript.VALIDATION_WEIGHT_PER_SIGOP_PASSED = 50;\n\n// How much weight budget is added to the witness size (Tapscript only, see BIP 342).\nScript.VALIDATION_WEIGHT_OFFSET = 50;\n\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classify = function() {\n  if (this._isInput) {\n    return this.classifyInput();\n  } else if (this._isOutput) {\n    return this.classifyOutput();\n  } else {\n    var outputType = this.classifyOutput();\n    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();\n  }\n};\n\nScript.outputIdentifiers = {};\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyOutput = function() {\n  for (var type in Script.outputIdentifiers) {\n    if (Script.outputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\nScript.inputIdentifiers = {};\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyInput = function() {\n  for (var type in Script.inputIdentifiers) {\n    if (Script.inputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\n\n/**\n * @returns {boolean} if script is one of the known types\n */\nScript.prototype.isStandard = function() {\n  // TODO: Add BIP62 compliance\n  return this.classify() !== Script.types.UNKNOWN;\n};\n\n\n// Script construction methods\n\n/**\n * Adds a script element at the start of the script.\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n */\nScript.prototype.prepend = function(obj) {\n  this._addByType(obj, true);\n  return this;\n};\n\n/**\n * Compares a script with another script\n */\nScript.prototype.equals = function(script) {\n  $.checkState(script instanceof Script, 'Must provide another script');\n  if (this.chunks.length !== script.chunks.length) {\n    return false;\n  }\n  var i;\n  for (i = 0; i < this.chunks.length; i++) {\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\n      return false;\n    }\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\n      return false;\n    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Adds a script element to the end of the script.\n *\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n *\n */\nScript.prototype.add = function(obj) {\n  this._addByType(obj, false);\n  return this;\n};\n\nScript.prototype._addByType = function(obj, prepend) {\n  if (typeof obj === 'string') {\n    this._addOpcode(obj, prepend);\n  } else if (typeof obj === 'number') {\n    this._addOpcode(obj, prepend);\n  } else if (obj instanceof Opcode) {\n    this._addOpcode(obj, prepend);\n  } else if (BufferUtil.isBuffer(obj)) {\n    this._addBuffer(obj, prepend);\n  } else if (obj instanceof Script) {\n    this.chunks = this.chunks.concat(obj.chunks);\n  } else if (typeof obj === 'object') {\n    this._insertAtPosition(obj, prepend);\n  } else {\n    throw new Error('Invalid script chunk');\n  }\n};\n\nScript.prototype._insertAtPosition = function(op, prepend) {\n  if (prepend) {\n    this.chunks.unshift(op);\n  } else {\n    this.chunks.push(op);\n  }\n};\n\nScript.prototype._addOpcode = function(opcode, prepend) {\n  var op;\n  if (typeof opcode === 'number') {\n    op = opcode;\n  } else if (opcode instanceof Opcode) {\n    op = opcode.toNumber();\n  } else {\n    op = Opcode(opcode).toNumber();\n  }\n  this._insertAtPosition({\n    opcodenum: op\n  }, prepend);\n  return this;\n};\n\nScript.prototype._addBuffer = function(buf, prepend) {\n  var opcodenum;\n  var len = buf.length;\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\n    opcodenum = len;\n  } else if (len < Math.pow(2, 8)) {\n    opcodenum = Opcode.OP_PUSHDATA1;\n  } else if (len < Math.pow(2, 16)) {\n    opcodenum = Opcode.OP_PUSHDATA2;\n  } else if (len < Math.pow(2, 32)) {\n    opcodenum = Opcode.OP_PUSHDATA4;\n  } else {\n    throw new Error('You can\\'t push that much data');\n  }\n  this._insertAtPosition({\n    buf: buf,\n    len: len,\n    opcodenum: opcodenum\n  }, prepend);\n  return this;\n};\n\nScript.prototype.hasCodeseparators = function() {\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {\n      return true;\n    }\n  }\n  return false;\n};\n\nScript.prototype.removeCodeseparators = function() {\n  var chunks = [];\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {\n      chunks.push(this.chunks[i]);\n    }\n  }\n  this.chunks = chunks;\n  return this;\n};\n\n// high level script builder methods\n\n/**\n * @returns {Script} a new Multisig output script for given public keys,\n * requiring m of those public keys to spend\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\n * @param {number} threshold - amount of required signatures to spend the output\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true, don't sort the given\n *                      public keys before creating the script\n */\nScript.buildMultisigOut = function(publicKeys, threshold, opts) {\n  $.checkArgument(threshold <= publicKeys.length,\n    'Number of required signatures must be less than or equal to the number of public keys');\n  opts = opts || {};\n  var script = new Script();\n  script.add(Opcode.smallInt(threshold));\n  publicKeys = publicKeys.map(PublicKey);\n  var sorted = publicKeys;\n  if (!opts.noSorting) {\n    sorted = _.sortBy(publicKeys, function(publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n  for (var i = 0; i < sorted.length; i++) {\n    var publicKey = sorted[i];\n    script.add(publicKey.toBuffer());\n  }\n  script.add(Opcode.smallInt(publicKeys.length));\n  script.add(Opcode.OP_CHECKMULTISIG);\n  return script;\n};\n\nScript.buildWitnessMultisigOutFromScript = function(script) {\n  if (script instanceof Script) {\n    var s = new Script();\n    s.add(Opcode.OP_0);\n    s.add(Hash.sha256(script.toBuffer()));\n    return s;\n  } else {\n    throw new TypeError('First argument is expected to be a p2sh script');\n  }\n};\n\n/**\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(Array.isArray(pubkeys));\n  $.checkArgument(!isNaN(threshold));\n  $.checkArgument(Array.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  for (const signature of signatures) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  }\n  return s;\n};\n\n/**\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(Array.isArray(pubkeys));\n  $.checkArgument(!isNaN(threshold));\n  $.checkArgument(Array.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  for (const signature of signatures) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  }\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to public key hash output for the given\n * address or public key\n * @param {(Address|PublicKey)} to - destination address or public key\n */\nScript.buildPublicKeyHashOut = function(to) {\n  $.checkArgument(to != null);\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\n  if (to instanceof PublicKey) {\n    to = to.toAddress();\n  } else if (typeof to === 'string') {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_DUP)\n    .add(Opcode.OP_HASH160)\n    .add(to.hashBuffer)\n    .add(Opcode.OP_EQUALVERIFY)\n    .add(Opcode.OP_CHECKSIG);\n  s._network = to.network;\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to witness v0 output for the given\n * address\n * @param {(Address|PublicKey)} to - destination address\n */\nScript.buildWitnessV0Out = function(to) {\n  $.checkArgument(to != null);\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\n  if (to instanceof PublicKey) {\n    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);\n  } else if (typeof to === 'string') {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_0)\n    .add(to.hashBuffer);\n  s._network = to.network;\n  return s;\n};\n\n\n/**\n * Build Taproot script output\n * @param {PublicKey|Address} to recipient's pubKey or address\n * @param {Array|Object} scriptTree single leaf object OR array of leaves. leaf: { script: String, leafVersion: Integer }\n * @returns {Script}\n */\nScript.buildWitnessV1Out = function(to, scriptTree) {\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\n  $.checkArgument(!scriptTree || Array.isArray(scriptTree) || !!scriptTree.script);\n\n  if (typeof to === 'string') {\n    try {\n      to = PublicKey.fromTaproot(to);\n    } catch {\n      to = Address.fromString(to);\n    }\n  }\n  \n  function buildTree(tree) {\n    if (Array.isArray(tree)) {\n      const [left, leftH] = buildTree(tree[0]);\n      const [right, rightH] = buildTree(tree[1]);\n      const ret = [[[left[0], left[1]], rightH], [[right[0], right[1]], leftH]];\n      const hWriter = TaggedHash.TAPBRANCH;\n      if (leftH.compare(rightH) === 1) {\n        hWriter.write(rightH);\n        hWriter.write(leftH);\n      } else {\n        hWriter.write(leftH);\n        hWriter.write(rightH);\n      }\n      return [ret, hWriter.finalize()];\n    } else {\n      const { leafVersion, script } = tree;\n      const scriptBuf = new Script(script).toBuffer();\n      const leafWriter = TaggedHash.TAPLEAF;\n      leafWriter.writeUInt8(leafVersion);\n      leafWriter.writeUInt8(scriptBuf.length);\n      leafWriter.write(scriptBuf);\n      const h = leafWriter.finalize();\n      return [[Buffer.from([leafVersion]), scriptBuf], h];\n    }\n  }\n\n  let taggedHash = null;\n  if (scriptTree) { \n    const [_, h] = buildTree(scriptTree);\n    taggedHash = h;\n  }\n  \n  let tweakedPubKey;\n  if (to instanceof PublicKey) {\n    tweakedPubKey = to.createTapTweak(taggedHash).tweakedPubKey;\n  } else { // Address\n    tweakedPubKey = to.hashBuffer;\n  }\n  const s = new Script();\n  s.add(Opcode.OP_1);\n  s.add(tweakedPubKey);\n  return s;\n};\n\n\n/**\n * @returns {Script} a new pay to public key output for the given\n *  public key\n */\nScript.buildPublicKeyOut = function(pubkey) {\n  $.checkArgument(pubkey instanceof PublicKey);\n  var s = new Script();\n  s.add(pubkey.toBuffer())\n    .add(Opcode.OP_CHECKSIG);\n  return s;\n};\n\n/**\n * @returns {Script} a new OP_RETURN script with data\n * @param {(string|Buffer)} data - the data to embed in the output\n * @param {(string)} encoding - the type of encoding of the string\n */\nScript.buildDataOut = function(data, encoding) {\n  $.checkArgument(data == null || typeof data === 'string' || BufferUtil.isBuffer(data));\n  if (typeof data === 'string') {\n    data = Buffer.from(data, encoding);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_RETURN);\n  if (data != null) {\n    s.add(data);\n  }\n  return s;\n};\n\n/**\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\n *    It can also be a p2sh address\n * @returns {Script} new pay to script hash script for given script\n */\nScript.buildScriptHashOut = function(script) {\n  $.checkArgument(script instanceof Script ||\n    (script instanceof Address && script.isPayToScriptHash()));\n  var s = new Script();\n  s.add(Opcode.OP_HASH160)\n    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))\n    .add(Opcode.OP_EQUAL);\n\n  s._network = script._network || script.network;\n  return s;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key output script.\n *\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyIn = function(signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(sigtype == null || !isNaN(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script();\n  script.add(BufferUtil.concat([\n    signature,\n    BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n  ]));\n  return script;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key hash\n * output script.\n *\n * @param {Buffer|string|PublicKey} publicKey\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(sigtype == null || !isNaN(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script()\n    .add(BufferUtil.concat([\n      signature,\n      BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n    ]))\n    .add(new PublicKey(publicKey).toBuffer());\n  return script;\n};\n\n/**\n * @returns {Script} an empty script\n */\nScript.empty = function() {\n  return new Script();\n};\n\n/**\n * @returns {Script} a new pay to script hash script that pays to this script\n */\nScript.prototype.toScriptHashOut = function() {\n  return Script.buildScriptHashOut(this);\n};\n\n/**\n * @return {Script} an output script built from the address\n */\nScript.fromAddress = function(address) {\n  address = Address(address);\n  if (address.isPayToScriptHash()) {\n    return Script.buildScriptHashOut(address);\n  } else if (address.isPayToPublicKeyHash()) {\n    return Script.buildPublicKeyHashOut(address);\n  } else if (address.isPayToWitnessPublicKeyHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToWitnessScriptHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToTaproot()) {\n    return Script.buildWitnessV1Out(address);\n  }\n  throw new errors.Script.UnrecognizedAddress(address);\n};\n\n/**\n * Will return the associated address information object\n * @return {Address|boolean}\n */\nScript.prototype.getAddressInfo = function(opts) {\n  if (this._isInput) {\n    return this._getInputAddressInfo();\n  } else if (this._isOutput) {\n    return this._getOutputAddressInfo();\n  } else {\n    var info = this._getOutputAddressInfo();\n    if (!info) {\n      return this._getInputAddressInfo();\n    }\n    return info;\n  }\n};\n\n/**\n * Will return the associated output scriptPubKey address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getOutputAddressInfo = function() {\n  var info = {};\n  if (this.isScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToScriptHash;\n  } else if (this.isPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isWitnessScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessScriptHash;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessPublicKeyHash;\n  } else if (this.isTaproot()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToTaproot;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * Will return the associated input scriptSig address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getInputAddressInfo = function() {\n  var info = {};\n  if (this.isPublicKeyHashIn()) {\n    // hash the publickey found in the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isScriptHashIn()) {\n    // hash the redeemscript found at the end of the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\n    info.type = Address.PayToScriptHash;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * @param {Network=} network\n * @return {Address|boolean} the associated address for this script if possible, or false\n */\nScript.prototype.toAddress = function(network) {\n  var info = this.getAddressInfo();\n  if (!info) {\n    return false;\n  }\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\n  return new Address(info);\n};\n\n/**\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\n * typically used with push data chunks.  Note that this will find and delete\n * not just the same data, but the same data with the same push data op as\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\n * pushdata op, then when you try to remove the data it is pushing, it will not\n * be removed, because they do not use the same pushdata op.\n */\nScript.prototype.findAndDelete = function(script) {\n  var buf = script.toBuffer();\n  var hex = buf.toString('hex');\n  for (var i = 0; i < this.chunks.length; i++) {\n    var script2 = Script({\n      chunks: [this.chunks[i]]\n    });\n    var buf2 = script2.toBuffer();\n    var hex2 = buf2.toString('hex');\n    if (hex === hex2) {\n      this.chunks.splice(i, 1);\n    }\n  }\n  return this;\n};\n\n/**\n * Comes from bitcoind's script interpreter CheckMinimalPush function\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\n */\nScript.prototype.checkMinimalPush = function(i) {\n  var chunk = this.chunks[i];\n  var buf = chunk.buf;\n  var opcodenum = chunk.opcodenum;\n  if (!buf) {\n    return true;\n  }\n  if (buf.length === 0) {\n    // Could have used OP_0.\n    return opcodenum === Opcode.OP_0;\n  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\n    // Could have used OP_1 .. OP_16.\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\n  } else if (buf.length === 1 && buf[0] === 0x81) {\n    // Could have used OP_1NEGATE\n    return opcodenum === Opcode.OP_1NEGATE;\n  } else if (buf.length <= 75) {\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n    return opcodenum === buf.length;\n  } else if (buf.length <= 255) {\n    // Could have used OP_PUSHDATA.\n    return opcodenum === Opcode.OP_PUSHDATA1;\n  } else if (buf.length <= 65535) {\n    // Could have used OP_PUSHDATA2.\n    return opcodenum === Opcode.OP_PUSHDATA2;\n  }\n  return true;\n};\n\n\n/**\n * Comes from bitcoind's script GetSigOpCount(boolean) function\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\n * @returns {number} number of signature operations required by this script\n */\nScript.prototype.getSignatureOperationsCount = function(accurate) {\n  accurate = (accurate == null ? true : accurate);\n  var n = 0;\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\n  for (const chunk of this.chunks) {\n    var opcode = chunk.opcodenum;\n    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {\n      n++;\n    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\n        n += Opcode.decodeOpN(lastOpcode);\n      } else {\n        n += 20;\n      }\n    }\n    lastOpcode = opcode;\n  }\n  return n;\n};\n\nmodule.exports = Script;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3NjcmlwdC9zY3JpcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLG1FQUFZO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDckQsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxhQUFhLG1CQUFPLENBQUMsaUVBQVc7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQWM7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQXFCO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyxxRUFBYTtBQUNwQyxRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxtRUFBWTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBc0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsY0FBYywwREFBMEQ7QUFDbkYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUyxjQUFjLEdBQUc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3NjcmlwdC9zY3JpcHQuanM/NjNmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi4vYWRkcmVzcycpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIE9wY29kZSA9IHJlcXVpcmUoJy4uL29wY29kZScpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4uL3B1YmxpY2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL2NyeXB0by9zaWduYXR1cmUnKTtcbnZhciBOZXR3b3JrcyA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XG5jb25zdCBUYWdnZWRIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL3RhZ2dlZGhhc2gnKTtcblxuLyoqXG4gKiBBIGJpdGNvaW4gdHJhbnNhY3Rpb24gc2NyaXB0LiBFYWNoIHRyYW5zYWN0aW9uJ3MgaW5wdXRzIGFuZCBvdXRwdXRzXG4gKiBoYXMgYSBzY3JpcHQgdGhhdCBpcyBldmFsdWF0ZWQgdG8gdmFsaWRhdGUgaXQncyBzcGVuZGluZy5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvU2NyaXB0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd8QnVmZmVyPX0gZnJvbSBvcHRpb25hbCBkYXRhIHRvIHBvcHVsYXRlIHNjcmlwdFxuICovXG52YXIgU2NyaXB0ID0gZnVuY3Rpb24gU2NyaXB0KGZyb20pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjcmlwdCkpIHtcbiAgICByZXR1cm4gbmV3IFNjcmlwdChmcm9tKTtcbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuXG4gIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKGZyb20pKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5mcm9tQnVmZmVyKGZyb20pO1xuICB9IGVsc2UgaWYgKGZyb20gaW5zdGFuY2VvZiBBZGRyZXNzKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5mcm9tQWRkcmVzcyhmcm9tKTtcbiAgfSBlbHNlIGlmIChmcm9tIGluc3RhbmNlb2YgU2NyaXB0KSB7XG4gICAgcmV0dXJuIFNjcmlwdC5mcm9tQnVmZmVyKGZyb20udG9CdWZmZXIoKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZyb20gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5mcm9tU3RyaW5nKGZyb20pO1xuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZnJvbSkgJiYgQXJyYXkuaXNBcnJheShmcm9tLmNodW5rcykpIHtcbiAgICB0aGlzLnNldChmcm9tKTtcbiAgfVxufTtcblxuXG5TY3JpcHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc09iamVjdChvYmopKTtcbiAgJC5jaGVja0FyZ3VtZW50KEFycmF5LmlzQXJyYXkob2JqLmNodW5rcykpO1xuICB0aGlzLmNodW5rcyA9IG9iai5jaHVua3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuU2NyaXB0LmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHNjcmlwdCA9IG5ldyBTY3JpcHQoKTtcbiAgc2NyaXB0LmNodW5rcyA9IFtdO1xuXG4gIHZhciBiciA9IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKTtcbiAgd2hpbGUgKCFici5maW5pc2hlZCgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcGNvZGVudW0gPSBici5yZWFkVUludDgoKTtcblxuICAgICAgdmFyIGxlbiwgYnVmO1xuICAgICAgaWYgKG9wY29kZW51bSA+IDAgJiYgb3Bjb2RlbnVtIDwgT3Bjb2RlLk9QX1BVU0hEQVRBMSkge1xuICAgICAgICBsZW4gPSBvcGNvZGVudW07XG4gICAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgICAgYnVmOiBici5yZWFkKGxlbiksXG4gICAgICAgICAgbGVuOiBsZW4sXG4gICAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMSkge1xuICAgICAgICBsZW4gPSBici5yZWFkVUludDgoKTtcbiAgICAgICAgYnVmID0gYnIucmVhZChsZW4pO1xuICAgICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xuICAgICAgICAgIGJ1ZjogYnVmLFxuICAgICAgICAgIGxlbjogbGVuLFxuICAgICAgICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTIpIHtcbiAgICAgICAgbGVuID0gYnIucmVhZFVJbnQxNkxFKCk7XG4gICAgICAgIGJ1ZiA9IGJyLnJlYWQobGVuKTtcbiAgICAgICAgc2NyaXB0LmNodW5rcy5wdXNoKHtcbiAgICAgICAgICBidWY6IGJ1ZixcbiAgICAgICAgICBsZW46IGxlbixcbiAgICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEE0KSB7XG4gICAgICAgIGxlbiA9IGJyLnJlYWRVSW50MzJMRSgpO1xuICAgICAgICBidWYgPSBici5yZWFkKGxlbik7XG4gICAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgICAgYnVmOiBidWYsXG4gICAgICAgICAgbGVuOiBsZW4sXG4gICAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9wY29kZS5pc09wU3VjY2VzcyhvcGNvZGVudW0pKSB7XG4gICAgICAgIC8vIE9QX1NVQ0NFU1N4IHByb2Nlc3Npbmcgb3ZlcnJpZGVzIGV2ZXJ5dGhpbmcsIGluY2x1ZGluZyBzdGFjayBlbGVtZW50IHNpemUgbGltaXRzXG4gICAgICAgIGJ1ZiA9IGJyLnJlYWRBbGwoKTtcbiAgICAgICAgbGVuID0gYnVmLmxlbmd0aDtcbiAgICAgICAgc2NyaXB0LmNodW5rcy5wdXNoKHtcbiAgICAgICAgICBidWY6IGJ1ZixcbiAgICAgICAgICBsZW46IGxlbixcbiAgICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuU2NyaXB0LkludmFsaWRCdWZmZXIoYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidyA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gdGhpcy5jaHVua3NbaV07XG4gICAgdmFyIG9wY29kZW51bSA9IGNodW5rLm9wY29kZW51bTtcbiAgICBidy53cml0ZVVJbnQ4KGNodW5rLm9wY29kZW51bSk7XG4gICAgaWYgKGNodW5rLmJ1Zikge1xuICAgICAgaWYgKG9wY29kZW51bSA8IE9wY29kZS5PUF9QVVNIREFUQTEpIHtcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEExKSB7XG4gICAgICAgIGJ3LndyaXRlVUludDgoY2h1bmsubGVuKTtcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyKSB7XG4gICAgICAgIGJ3LndyaXRlVUludDE2TEUoY2h1bmsubGVuKTtcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH0gZWxzZSBpZiAob3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEE0KSB7XG4gICAgICAgIGJ3LndyaXRlVUludDMyTEUoY2h1bmsubGVuKTtcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvdWxkIHJlYWNoIGhlcmUgaWYgb3Bjb2RlbnVtIGlzIE9QX1NVQ0NFU1N4IChzZWUgY29tbWVudCBpbiAuZnJvbUJ1ZmZlcilcbiAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYncuY29uY2F0KCk7XG59O1xuXG5TY3JpcHQuZnJvbUFTTSA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgc2NyaXB0ID0gbmV3IFNjcmlwdCgpO1xuICBzY3JpcHQuY2h1bmtzID0gW107XG5cbiAgdmFyIHRva2VucyA9IHN0ci5zcGxpdCgnICcpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICB2YXIgb3Bjb2RlID0gT3Bjb2RlKHRva2VuKTtcbiAgICB2YXIgb3Bjb2RlbnVtID0gb3Bjb2RlLnRvTnVtYmVyKCk7XG5cbiAgICBpZiAob3Bjb2RlbnVtID09IG51bGwpIHtcbiAgICAgIHZhciBidWYgPSBCdWZmZXIuZnJvbSh0b2tlbnNbaV0sICdoZXgnKTtcbiAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgIGJ1ZjogYnVmLFxuICAgICAgICBsZW46IGJ1Zi5sZW5ndGgsXG4gICAgICAgIG9wY29kZW51bTogYnVmLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBpID0gaSArIDE7XG4gICAgfSBlbHNlIGlmIChvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTEgfHxcbiAgICAgIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMiB8fFxuICAgICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEE0KSB7XG4gICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xuICAgICAgICBidWY6IEJ1ZmZlci5mcm9tKHRva2Vuc1tpICsgMl0sICdoZXgnKSxcbiAgICAgICAgbGVuOiBwYXJzZUludCh0b2tlbnNbaSArIDFdKSxcbiAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgIH0pO1xuICAgICAgaSA9IGkgKyAzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JpcHQuY2h1bmtzLnB1c2goe1xuICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxuICAgICAgfSk7XG4gICAgICBpID0gaSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG5TY3JpcHQuZnJvbUhleCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gbmV3IFNjcmlwdChCdWZmZXIuZnJvbShzdHIsICdoZXgnKSk7XG59O1xuXG5TY3JpcHQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoSlNVdGlsLmlzSGV4YShzdHIpIHx8IHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IFNjcmlwdChCdWZmZXIuZnJvbShzdHIsICdoZXgnKSk7XG4gIH1cbiAgdmFyIHNjcmlwdCA9IG5ldyBTY3JpcHQoKTtcbiAgc2NyaXB0LmNodW5rcyA9IFtdO1xuXG4gIHZhciB0b2tlbnMgPSBzdHIuc3BsaXQoJyAnKTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgdmFyIG9wY29kZSA9IE9wY29kZSh0b2tlbik7XG4gICAgdmFyIG9wY29kZW51bSA9IG9wY29kZS50b051bWJlcigpO1xuXG4gICAgaWYgKG9wY29kZW51bSA9PSBudWxsKSB7XG4gICAgICBvcGNvZGVudW0gPSBwYXJzZUludCh0b2tlbik7XG4gICAgICBpZiAob3Bjb2RlbnVtID4gMCAmJiBvcGNvZGVudW0gPCBPcGNvZGUuT1BfUFVTSERBVEExKSB7XG4gICAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgICAgYnVmOiBCdWZmZXIuZnJvbSh0b2tlbnNbaSArIDFdLnNsaWNlKDIpLCAnaGV4JyksXG4gICAgICAgICAgbGVuOiBvcGNvZGVudW0sXG4gICAgICAgICAgb3Bjb2RlbnVtOiBvcGNvZGVudW1cbiAgICAgICAgfSk7XG4gICAgICAgIGkgPSBpICsgMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzY3JpcHQ6ICcgKyBKU09OLnN0cmluZ2lmeShzdHIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMSB8fFxuICAgICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyIHx8XG4gICAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTQpIHtcbiAgICAgIGlmICh0b2tlbnNbaSArIDJdLnNsaWNlKDAsIDIpICE9PSAnMHgnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHVzaGRhdGEgZGF0YSBtdXN0IHN0YXJ0IHdpdGggMHgnKTtcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgIGJ1ZjogQnVmZmVyLmZyb20odG9rZW5zW2kgKyAyXS5zbGljZSgyKSwgJ2hleCcpLFxuICAgICAgICBsZW46IHBhcnNlSW50KHRva2Vuc1tpICsgMV0pLFxuICAgICAgICBvcGNvZGVudW06IG9wY29kZW51bVxuICAgICAgfSk7XG4gICAgICBpID0gaSArIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcmlwdC5jaHVua3MucHVzaCh7XG4gICAgICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXG4gICAgICB9KTtcbiAgICAgIGkgPSBpICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjcmlwdDtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUuX2NodW5rVG9TdHJpbmcgPSBmdW5jdGlvbihjaHVuaywgdHlwZSkge1xuICB2YXIgb3Bjb2RlbnVtID0gY2h1bmsub3Bjb2RlbnVtO1xuICB2YXIgYXNtID0gKHR5cGUgPT09ICdhc20nKTtcbiAgdmFyIHN0ciA9ICcnO1xuICBpZiAoIWNodW5rLmJ1Zikge1xuICAgIC8vIG5vIGRhdGEgY2h1bmtcbiAgICBpZiAodHlwZW9mIE9wY29kZS5yZXZlcnNlTWFwW29wY29kZW51bV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoYXNtKSB7XG4gICAgICAgIC8vIEEgZmV3IGNhc2VzIHdoZXJlIHRoZSBvcGNvZGUgbmFtZSBkaWZmZXJzIGZyb20gcmV2ZXJzZU1hcFxuICAgICAgICAvLyBhc2lkZSBmcm9tIDEgdG8gMTYgZGF0YSBwdXNoZXMuXG4gICAgICAgIGlmIChvcGNvZGVudW0gPT09IDApIHtcbiAgICAgICAgICAvLyBPUF8wIC0+IDBcbiAgICAgICAgICBzdHIgPSBzdHIgKyAnIDAnO1xuICAgICAgICB9IGVsc2UgaWYob3Bjb2RlbnVtID09PSA3OSkge1xuICAgICAgICAgIC8vIE9QXzFORUdBVEUgLT4gMVxuICAgICAgICAgIHN0ciA9IHN0ciArICcgLTEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0ciArICcgJyArIE9wY29kZShvcGNvZGVudW0pLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IHN0ciArICcgJyArIE9wY29kZShvcGNvZGVudW0pLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBudW1zdHIgPSBvcGNvZGVudW0udG9TdHJpbmcoMTYpO1xuICAgICAgaWYgKG51bXN0ci5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIG51bXN0ciA9ICcwJyArIG51bXN0cjtcbiAgICAgIH1cbiAgICAgIGlmIChhc20pIHtcbiAgICAgICAgc3RyID0gc3RyICsgJyAnICsgbnVtc3RyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gc3RyICsgJyAnICsgJzB4JyArIG51bXN0cjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGF0YSBjaHVua1xuICAgIGlmICghYXNtICYmIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMSB8fFxuICAgICAgb3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfUFVTSERBVEEyIHx8XG4gICAgICBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTQpIHtcbiAgICAgIHN0ciA9IHN0ciArICcgJyArIE9wY29kZShvcGNvZGVudW0pLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChjaHVuay5sZW4gPiAwKSB7XG4gICAgICBpZiAoYXNtKSB7XG4gICAgICAgIHN0ciA9IHN0ciArICcgJyArIGNodW5rLmJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBzdHIgKyAnICcgKyBjaHVuay5sZW4gKyAnICcgKyAnMHgnICsgY2h1bmsuYnVmLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUudG9BU00gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gdGhpcy5jaHVua3NbaV07XG4gICAgc3RyICs9IHRoaXMuX2NodW5rVG9TdHJpbmcoY2h1bmssICdhc20nKTtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyKDEpO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RyID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSB0aGlzLmNodW5rc1tpXTtcbiAgICBzdHIgKz0gdGhpcy5fY2h1bmtUb1N0cmluZyhjaHVuayk7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cigxKTtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8U2NyaXB0OiAnICsgdGhpcy50b1N0cmluZygpICsgJz4nO1xufTtcblxuLy8gc2NyaXB0IGNsYXNzaWZpY2F0aW9uIG1ldGhvZHNcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHBheSB0byBwdWJrZXkgaGFzaCBvdXRwdXQgc2NyaXB0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUuaXNQdWJsaWNLZXlIYXNoT3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhISh0aGlzLmNodW5rcy5sZW5ndGggPT09IDUgJiZcbiAgICB0aGlzLmNodW5rc1swXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9EVVAgJiZcbiAgICB0aGlzLmNodW5rc1sxXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9IQVNIMTYwICYmXG4gICAgdGhpcy5jaHVua3NbMl0uYnVmICYmXG4gICAgdGhpcy5jaHVua3NbMl0uYnVmLmxlbmd0aCA9PT0gMjAgJiZcbiAgICB0aGlzLmNodW5rc1szXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9FUVVBTFZFUklGWSAmJlxuICAgIHRoaXMuY2h1bmtzWzRdLm9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0NIRUNLU0lHKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwYXkgdG8gcHVibGljIGtleSBoYXNoIGlucHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzUHVibGljS2V5SGFzaEluID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2lnbmF0dXJlQnVmID0gdGhpcy5jaHVua3NbMF0uYnVmO1xuICAgIHZhciBwdWJrZXlCdWYgPSB0aGlzLmNodW5rc1sxXS5idWY7XG4gICAgaWYgKHNpZ25hdHVyZUJ1ZiAmJlxuICAgICAgICBzaWduYXR1cmVCdWYubGVuZ3RoICYmXG4gICAgICAgIHNpZ25hdHVyZUJ1ZlswXSA9PT0gMHgzMCAmJlxuICAgICAgICBwdWJrZXlCdWYgJiZcbiAgICAgICAgcHVia2V5QnVmLmxlbmd0aFxuICAgICAgICkge1xuICAgICAgdmFyIHZlcnNpb24gPSBwdWJrZXlCdWZbMF07XG4gICAgICBpZiAoKHZlcnNpb24gPT09IDB4MDQgfHxcbiAgICAgICAgICAgdmVyc2lvbiA9PT0gMHgwNiB8fFxuICAgICAgICAgICB2ZXJzaW9uID09PSAweDA3KSAmJiBwdWJrZXlCdWYubGVuZ3RoID09PSA2NSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoKHZlcnNpb24gPT09IDB4MDMgfHwgdmVyc2lvbiA9PT0gMHgwMikgJiYgcHVia2V5QnVmLmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24oKSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLmlzUHVibGljS2V5T3V0KCksICdDYW5cXCd0IHJldHJpZXZlIFB1YmxpY0tleSBmcm9tIGEgbm9uLVBLIG91dHB1dCcpO1xuICByZXR1cm4gdGhpcy5jaHVua3NbMF0uYnVmO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXlIYXNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzUHVibGljS2V5SGFzaE91dCgpKSB7XG4gICAgcmV0dXJuIHRoaXMuY2h1bmtzWzJdLmJ1ZjtcbiAgfSBlbHNlIGlmICh0aGlzLmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSkge1xuICAgIHJldHVybiB0aGlzLmNodW5rc1sxXS5idWY7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1RhcHJvb3QoKSkge1xuICAgIHJldHVybiB0aGlzLmNodW5rc1sxXS5idWY7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHJldHJpZXZlIFB1YmxpY0tleUhhc2ggZnJvbSBhIG5vbi1QS0ggb3V0cHV0Jyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwdWJsaWMga2V5IG91dHB1dCBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5pc1B1YmxpY0tleU91dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09PSAyICYmXG4gICAgICB0aGlzLmNodW5rc1swXS5idWYgJiZcbiAgICAgIHRoaXMuY2h1bmtzWzBdLmJ1Zi5sZW5ndGggJiZcbiAgICAgIHRoaXMuY2h1bmtzWzFdLm9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX0NIRUNLU0lHKSB7XG4gICAgdmFyIHB1YmtleUJ1ZiA9IHRoaXMuY2h1bmtzWzBdLmJ1ZjtcbiAgICB2YXIgdmVyc2lvbiA9IHB1YmtleUJ1ZlswXTtcbiAgICB2YXIgaXNWZXJzaW9uID0gZmFsc2U7XG4gICAgaWYgKCh2ZXJzaW9uID09PSAweDA0IHx8XG4gICAgICAgICB2ZXJzaW9uID09PSAweDA2IHx8XG4gICAgICAgICB2ZXJzaW9uID09PSAweDA3KSAmJiBwdWJrZXlCdWYubGVuZ3RoID09PSA2NSkge1xuICAgICAgaXNWZXJzaW9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCh2ZXJzaW9uID09PSAweDAzIHx8IHZlcnNpb24gPT09IDB4MDIpICYmIHB1YmtleUJ1Zi5sZW5ndGggPT09IDMzKSB7XG4gICAgICBpc1ZlcnNpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNWZXJzaW9uKSB7XG4gICAgICByZXR1cm4gUHVibGljS2V5LmlzVmFsaWQocHVia2V5QnVmKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHBheSB0byBwdWJsaWMga2V5IGlucHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzUHVibGljS2V5SW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzaWduYXR1cmVCdWYgPSB0aGlzLmNodW5rc1swXS5idWY7XG4gICAgaWYgKHNpZ25hdHVyZUJ1ZiAmJlxuICAgICAgICBzaWduYXR1cmVCdWYubGVuZ3RoICYmXG4gICAgICAgIHNpZ25hdHVyZUJ1ZlswXSA9PT0gMHgzMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMnNoIG91dHB1dCBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5pc1NjcmlwdEhhc2hPdXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgcmV0dXJuIChidWYubGVuZ3RoID09PSAyMyAmJlxuICAgIGJ1ZlswXSA9PT0gT3Bjb2RlLk9QX0hBU0gxNjAgJiZcbiAgICBidWZbMV0gPT09IDB4MTQgJiZcbiAgICBidWZbYnVmLmxlbmd0aCAtIDFdID09PSBPcGNvZGUuT1BfRVFVQUwpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHAyd3NoIG91dHB1dCBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5pc1dpdG5lc3NTY3JpcHRIYXNoT3V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gIHJldHVybiAoYnVmLmxlbmd0aCA9PT0gMzQgJiYgYnVmWzBdID09PSBPcGNvZGUuT1BfMCAmJiBidWZbMV0gPT09IDMyKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMndwa2ggb3V0cHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgcmV0dXJuIChidWYubGVuZ3RoID09PSAyMiAmJiBidWZbMF0gPT09IE9wY29kZS5PUF8wICYmIGJ1ZlsxXSA9PT0gMjApO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIHAydHIgb3V0cHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzVGFwcm9vdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICByZXR1cm4gKGJ1Zi5sZW5ndGggPT09IDM0ICYmIGJ1ZlswXSA9PT0gT3Bjb2RlLk9QXzEgJiYgYnVmWzFdID09PSAzMik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q9fSB2YWx1ZXMgLSBUaGUgcmV0dXJuIHZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlcy52ZXJzaW9uIC0gU2V0IHdpdGggdGhlIHdpdG5lc3MgdmVyc2lvblxuICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlcy5wcm9ncmFtIC0gU2V0IHdpdGggdGhlIHdpdG5lc3MgcHJvZ3JhbVxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMndwa2ggb3V0cHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzV2l0bmVzc1Byb2dyYW0gPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgaWYgKCF2YWx1ZXMpIHtcbiAgICB2YWx1ZXMgPSB7fTtcbiAgfVxuICB2YXIgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICBpZiAoYnVmLmxlbmd0aCA8IDQgfHwgYnVmLmxlbmd0aCA+IDQyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChidWZbMF0gIT09IE9wY29kZS5PUF8wICYmICEoYnVmWzBdID49IE9wY29kZS5PUF8xICYmIGJ1ZlswXSA8PSBPcGNvZGUuT1BfMTYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1ZlsxXSArIDIpIHtcbiAgICB2YWx1ZXMudmVyc2lvbiA9IE9wY29kZS5kZWNvZGVPcE4oYnVmWzBdKTtcbiAgICB2YWx1ZXMucHJvZ3JhbSA9IGJ1Zi5zbGljZSgyLCBidWYubGVuZ3RoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBwMnNoIGlucHV0IHNjcmlwdFxuICogTm90ZSB0aGF0IHRoZXNlIGFyZSBmcmVxdWVudGx5IGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gcHVia2V5aGFzaGluXG4gKi9cblNjcmlwdC5wcm90b3R5cGUuaXNTY3JpcHRIYXNoSW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciByZWRlZW1DaHVuayA9IHRoaXMuY2h1bmtzW3RoaXMuY2h1bmtzLmxlbmd0aCAtIDFdO1xuICB2YXIgcmVkZWVtQnVmID0gcmVkZWVtQ2h1bmsuYnVmO1xuICBpZiAoIXJlZGVlbUJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciByZWRlZW1TY3JpcHQ7XG4gIHRyeSB7XG4gICAgcmVkZWVtU2NyaXB0ID0gU2NyaXB0LmZyb21CdWZmZXIocmVkZWVtQnVmKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgZXJyb3JzLlNjcmlwdC5JbnZhbGlkQnVmZmVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbiAgdmFyIHR5cGUgPSByZWRlZW1TY3JpcHQuY2xhc3NpZnkoKTtcbiAgcmV0dXJuIHR5cGUgIT09IFNjcmlwdC50eXBlcy5VTktOT1dOO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhpcyBpcyBhIG11dGxzaWcgb3V0cHV0IHNjcmlwdFxuICovXG5TY3JpcHQucHJvdG90eXBlLmlzTXVsdGlzaWdPdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLmNodW5rcy5sZW5ndGggPiAzICYmXG4gICAgT3Bjb2RlLmlzU21hbGxJbnRPcCh0aGlzLmNodW5rc1swXS5vcGNvZGVudW0pICYmXG4gICAgdGhpcy5jaHVua3Muc2xpY2UoMSwgdGhpcy5jaHVua3MubGVuZ3RoIC0gMikuZXZlcnkoZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmJ1ZiAmJiBCdWZmZXJVdGlsLmlzQnVmZmVyKG9iai5idWYpO1xuICAgIH0pICYmXG4gICAgT3Bjb2RlLmlzU21hbGxJbnRPcCh0aGlzLmNodW5rc1t0aGlzLmNodW5rcy5sZW5ndGggLSAyXS5vcGNvZGVudW0pICYmXG4gICAgdGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMV0ub3Bjb2RlbnVtID09PSBPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJRyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoaXMgaXMgYSBtdWx0aXNpZyBpbnB1dCBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5pc011bHRpc2lnSW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2h1bmtzLmxlbmd0aCA+PSAyICYmXG4gICAgdGhpcy5jaHVua3NbMF0ub3Bjb2RlbnVtID09PSAwICYmXG4gICAgdGhpcy5jaHVua3Muc2xpY2UoMSwgdGhpcy5jaHVua3MubGVuZ3RoKS5ldmVyeShmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmouYnVmICYmXG4gICAgICAgIEJ1ZmZlclV0aWwuaXNCdWZmZXIob2JqLmJ1ZikgJiZcbiAgICAgICAgU2lnbmF0dXJlLmlzVHhERVIob2JqLmJ1Zik7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBzdGFuZGFyZCBPUF9SRVRVUk4gb3V0cHV0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUuaXNEYXRhT3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNodW5rcy5sZW5ndGggPj0gMSAmJlxuICAgIHRoaXMuY2h1bmtzWzBdLm9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1JFVFVSTiAmJlxuICAgICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDEgfHxcbiAgICAgICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgdGhpcy5jaHVua3NbMV0uYnVmICYmXG4gICAgICAgIHRoaXMuY2h1bmtzWzFdLmJ1Zi5sZW5ndGggPD0gU2NyaXB0Lk9QX1JFVFVSTl9TVEFOREFSRF9TSVpFICYmXG4gICAgICAgIHRoaXMuY2h1bmtzWzFdLmxlbmd0aCA9PT0gdGhpcy5jaHVua3MubGVuKSk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhc3NvY2lhdGVkIGRhdGEgZm9yIHRoaXMgc2NyaXB0LlxuICogSW4gdGhlIGNhc2Ugb2YgYSBwYXkgdG8gcHVibGljIGtleSBoYXNoLCBQMlNILCBQMldTSCwgb3IgUDJXUEtILCByZXR1cm4gdGhlIGhhc2guXG4gKiBJbiB0aGUgY2FzZSBvZiBhIHN0YW5kYXJkIE9QX1JFVFVSTiwgcmV0dXJuIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5TY3JpcHQucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNEYXRhT3V0KCkgfHwgdGhpcy5pc1NjcmlwdEhhc2hPdXQoKSB8fCB0aGlzLmlzV2l0bmVzc1NjcmlwdEhhc2hPdXQoKSB8fCB0aGlzLmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSB8fCB0aGlzLmlzVGFwcm9vdCgpKSB7XG4gICAgaWYgKHRoaXMuY2h1bmtzWzFdID09IG51bGwpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmNodW5rc1sxXS5idWYpO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5pc1B1YmxpY0tleUhhc2hPdXQoKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmNodW5rc1syXS5idWYpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIHNjcmlwdCB0eXBlIHRvIGdldCBkYXRhIGZyb20nKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoZSBzY3JpcHQgaXMgb25seSBjb21wb3NlZCBvZiBkYXRhIHB1c2hpbmdcbiAqIG9wY29kZXMgb3Igc21hbGwgaW50IG9wY29kZXMgKE9QXzAsIE9QXzEsIC4uLiwgT1BfMTYpXG4gKi9cblNjcmlwdC5wcm90b3R5cGUuaXNQdXNoT25seSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jaHVua3MuZXZlcnkoZnVuY3Rpb24oY2h1bmspIHtcbiAgICByZXR1cm4gY2h1bmsub3Bjb2RlbnVtIDw9IE9wY29kZS5PUF8xNjtcbiAgfSk7XG59O1xuXG5cblNjcmlwdC50eXBlcyA9IHt9O1xuU2NyaXB0LnR5cGVzLlVOS05PV04gPSAnVW5rbm93bic7XG5TY3JpcHQudHlwZXMuUFVCS0VZX09VVCA9ICdQYXkgdG8gcHVibGljIGtleSc7XG5TY3JpcHQudHlwZXMuUFVCS0VZX0lOID0gJ1NwZW5kIGZyb20gcHVibGljIGtleSc7XG5TY3JpcHQudHlwZXMuUFVCS0VZSEFTSF9PVVQgPSAnUGF5IHRvIHB1YmxpYyBrZXkgaGFzaCc7XG5TY3JpcHQudHlwZXMuUFVCS0VZSEFTSF9JTiA9ICdTcGVuZCBmcm9tIHB1YmxpYyBrZXkgaGFzaCc7XG5TY3JpcHQudHlwZXMuU0NSSVBUSEFTSF9PVVQgPSAnUGF5IHRvIHNjcmlwdCBoYXNoJztcblNjcmlwdC50eXBlcy5TQ1JJUFRIQVNIX0lOID0gJ1NwZW5kIGZyb20gc2NyaXB0IGhhc2gnO1xuU2NyaXB0LnR5cGVzLk1VTFRJU0lHX09VVCA9ICdQYXkgdG8gbXVsdGlzaWcnO1xuU2NyaXB0LnR5cGVzLk1VTFRJU0lHX0lOID0gJ1NwZW5kIGZyb20gbXVsdGlzaWcnO1xuU2NyaXB0LnR5cGVzLkRBVEFfT1VUID0gJ0RhdGEgcHVzaCc7XG5cblNjcmlwdC5PUF9SRVRVUk5fU1RBTkRBUkRfU0laRSA9IDgwO1xuXG4vLyBUYWcgZm9yIGlucHV0IGFubmV4LiBJZiB0aGVyZSBhcmUgYXQgbGVhc3QgdHdvIHdpdG5lc3MgZWxlbWVudHMgZm9yIGEgdHJhbnNhY3Rpb24gaW5wdXQsXG4vLyBhbmQgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIGxhc3QgZWxlbWVudCBpcyAweDUwLCB0aGlzIGxhc3QgZWxlbWVudCBpcyBjYWxsZWQgYW5uZXgsIGFuZFxuLy8gaGFzIG1lYW5pbmdzIGluZGVwZW5kZW50IG9mIHRoZSBzY3JpcHRcblNjcmlwdC5BTk5FWF9UQUcgPSAweDUwO1xuXG4vLyBWYWxpZGF0aW9uIHdlaWdodCBwZXIgcGFzc2luZyBzaWduYXR1cmUgKFRhcHNjcmlwdCBvbmx5LCBzZWUgQklQIDM0MikuXG5TY3JpcHQuVkFMSURBVElPTl9XRUlHSFRfUEVSX1NJR09QX1BBU1NFRCA9IDUwO1xuXG4vLyBIb3cgbXVjaCB3ZWlnaHQgYnVkZ2V0IGlzIGFkZGVkIHRvIHRoZSB3aXRuZXNzIHNpemUgKFRhcHNjcmlwdCBvbmx5LCBzZWUgQklQIDM0MikuXG5TY3JpcHQuVkFMSURBVElPTl9XRUlHSFRfT0ZGU0VUID0gNTA7XG5cblxuLyoqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgU2NyaXB0IHR5cGUgaWYgaXQgaXMgYSBrbm93biBmb3JtLFxuICogb3IgU2NyaXB0LlVOS05PV04gaWYgaXQgaXNuJ3RcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5jbGFzc2lmeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5faXNJbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzaWZ5SW5wdXQoKTtcbiAgfSBlbHNlIGlmICh0aGlzLl9pc091dHB1dCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzaWZ5T3V0cHV0KCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG91dHB1dFR5cGUgPSB0aGlzLmNsYXNzaWZ5T3V0cHV0KCk7XG4gICAgcmV0dXJuIG91dHB1dFR5cGUgIT0gU2NyaXB0LnR5cGVzLlVOS05PV04gPyBvdXRwdXRUeXBlIDogdGhpcy5jbGFzc2lmeUlucHV0KCk7XG4gIH1cbn07XG5cblNjcmlwdC5vdXRwdXRJZGVudGlmaWVycyA9IHt9O1xuU2NyaXB0Lm91dHB1dElkZW50aWZpZXJzLlBVQktFWV9PVVQgPSBTY3JpcHQucHJvdG90eXBlLmlzUHVibGljS2V5T3V0O1xuU2NyaXB0Lm91dHB1dElkZW50aWZpZXJzLlBVQktFWUhBU0hfT1VUID0gU2NyaXB0LnByb3RvdHlwZS5pc1B1YmxpY0tleUhhc2hPdXQ7XG5TY3JpcHQub3V0cHV0SWRlbnRpZmllcnMuTVVMVElTSUdfT1VUID0gU2NyaXB0LnByb3RvdHlwZS5pc011bHRpc2lnT3V0O1xuU2NyaXB0Lm91dHB1dElkZW50aWZpZXJzLlNDUklQVEhBU0hfT1VUID0gU2NyaXB0LnByb3RvdHlwZS5pc1NjcmlwdEhhc2hPdXQ7XG5TY3JpcHQub3V0cHV0SWRlbnRpZmllcnMuREFUQV9PVVQgPSBTY3JpcHQucHJvdG90eXBlLmlzRGF0YU91dDtcblxuLyoqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgU2NyaXB0IHR5cGUgaWYgaXQgaXMgYSBrbm93biBmb3JtLFxuICogb3IgU2NyaXB0LlVOS05PV04gaWYgaXQgaXNuJ3RcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5jbGFzc2lmeU91dHB1dCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0eXBlIGluIFNjcmlwdC5vdXRwdXRJZGVudGlmaWVycykge1xuICAgIGlmIChTY3JpcHQub3V0cHV0SWRlbnRpZmllcnNbdHlwZV0uYmluZCh0aGlzKSgpKSB7XG4gICAgICByZXR1cm4gU2NyaXB0LnR5cGVzW3R5cGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gU2NyaXB0LnR5cGVzLlVOS05PV047XG59O1xuXG5TY3JpcHQuaW5wdXRJZGVudGlmaWVycyA9IHt9O1xuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMuUFVCS0VZX0lOID0gU2NyaXB0LnByb3RvdHlwZS5pc1B1YmxpY0tleUluO1xuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMuUFVCS0VZSEFTSF9JTiA9IFNjcmlwdC5wcm90b3R5cGUuaXNQdWJsaWNLZXlIYXNoSW47XG5TY3JpcHQuaW5wdXRJZGVudGlmaWVycy5NVUxUSVNJR19JTiA9IFNjcmlwdC5wcm90b3R5cGUuaXNNdWx0aXNpZ0luO1xuU2NyaXB0LmlucHV0SWRlbnRpZmllcnMuU0NSSVBUSEFTSF9JTiA9IFNjcmlwdC5wcm90b3R5cGUuaXNTY3JpcHRIYXNoSW47XG5cbi8qKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIFNjcmlwdCB0eXBlIGlmIGl0IGlzIGEga25vd24gZm9ybSxcbiAqIG9yIFNjcmlwdC5VTktOT1dOIGlmIGl0IGlzbid0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUuY2xhc3NpZnlJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0eXBlIGluIFNjcmlwdC5pbnB1dElkZW50aWZpZXJzKSB7XG4gICAgaWYgKFNjcmlwdC5pbnB1dElkZW50aWZpZXJzW3R5cGVdLmJpbmQodGhpcykoKSkge1xuICAgICAgcmV0dXJuIFNjcmlwdC50eXBlc1t0eXBlXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFNjcmlwdC50eXBlcy5VTktOT1dOO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiBzY3JpcHQgaXMgb25lIG9mIHRoZSBrbm93biB0eXBlc1xuICovXG5TY3JpcHQucHJvdG90eXBlLmlzU3RhbmRhcmQgPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETzogQWRkIEJJUDYyIGNvbXBsaWFuY2VcbiAgcmV0dXJuIHRoaXMuY2xhc3NpZnkoKSAhPT0gU2NyaXB0LnR5cGVzLlVOS05PV047XG59O1xuXG5cbi8vIFNjcmlwdCBjb25zdHJ1Y3Rpb24gbWV0aG9kc1xuXG4vKipcbiAqIEFkZHMgYSBzY3JpcHQgZWxlbWVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIHNjcmlwdC5cbiAqIEBwYXJhbSB7Kn0gb2JqIGEgc3RyaW5nLCBudW1iZXIsIE9wY29kZSwgQnVmZmVyLCBvciBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7U2NyaXB0fSB0aGlzIHNjcmlwdCBpbnN0YW5jZVxuICovXG5TY3JpcHQucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5fYWRkQnlUeXBlKG9iaiwgdHJ1ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyBhIHNjcmlwdCB3aXRoIGFub3RoZXIgc2NyaXB0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oc2NyaXB0KSB7XG4gICQuY2hlY2tTdGF0ZShzY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQsICdNdXN0IHByb3ZpZGUgYW5vdGhlciBzY3JpcHQnKTtcbiAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCAhPT0gc2NyaXB0LmNodW5rcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKHRoaXMuY2h1bmtzW2ldLmJ1ZikgJiYgIUJ1ZmZlclV0aWwuaXNCdWZmZXIoc2NyaXB0LmNodW5rc1tpXS5idWYpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKHRoaXMuY2h1bmtzW2ldLmJ1ZikgJiYgIUJ1ZmZlclV0aWwuZXF1YWxzKHRoaXMuY2h1bmtzW2ldLmJ1Ziwgc2NyaXB0LmNodW5rc1tpXS5idWYpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNodW5rc1tpXS5vcGNvZGVudW0gIT09IHNjcmlwdC5jaHVua3NbaV0ub3Bjb2RlbnVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgc2NyaXB0IGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgc2NyaXB0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIGEgc3RyaW5nLCBudW1iZXIsIE9wY29kZSwgQnVmZmVyLCBvciBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7U2NyaXB0fSB0aGlzIHNjcmlwdCBpbnN0YW5jZVxuICpcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdGhpcy5fYWRkQnlUeXBlKG9iaiwgZmFsc2UpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUuX2FkZEJ5VHlwZSA9IGZ1bmN0aW9uKG9iaiwgcHJlcGVuZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9hZGRPcGNvZGUob2JqLCBwcmVwZW5kKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2FkZE9wY29kZShvYmosIHByZXBlbmQpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIE9wY29kZSkge1xuICAgIHRoaXMuX2FkZE9wY29kZShvYmosIHByZXBlbmQpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlclV0aWwuaXNCdWZmZXIob2JqKSkge1xuICAgIHRoaXMuX2FkZEJ1ZmZlcihvYmosIHByZXBlbmQpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFNjcmlwdCkge1xuICAgIHRoaXMuY2h1bmtzID0gdGhpcy5jaHVua3MuY29uY2F0KG9iai5jaHVua3MpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy5faW5zZXJ0QXRQb3NpdGlvbihvYmosIHByZXBlbmQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzY3JpcHQgY2h1bmsnKTtcbiAgfVxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5faW5zZXJ0QXRQb3NpdGlvbiA9IGZ1bmN0aW9uKG9wLCBwcmVwZW5kKSB7XG4gIGlmIChwcmVwZW5kKSB7XG4gICAgdGhpcy5jaHVua3MudW5zaGlmdChvcCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaHVua3MucHVzaChvcCk7XG4gIH1cbn07XG5cblNjcmlwdC5wcm90b3R5cGUuX2FkZE9wY29kZSA9IGZ1bmN0aW9uKG9wY29kZSwgcHJlcGVuZCkge1xuICB2YXIgb3A7XG4gIGlmICh0eXBlb2Ygb3Bjb2RlID09PSAnbnVtYmVyJykge1xuICAgIG9wID0gb3Bjb2RlO1xuICB9IGVsc2UgaWYgKG9wY29kZSBpbnN0YW5jZW9mIE9wY29kZSkge1xuICAgIG9wID0gb3Bjb2RlLnRvTnVtYmVyKCk7XG4gIH0gZWxzZSB7XG4gICAgb3AgPSBPcGNvZGUob3Bjb2RlKS50b051bWJlcigpO1xuICB9XG4gIHRoaXMuX2luc2VydEF0UG9zaXRpb24oe1xuICAgIG9wY29kZW51bTogb3BcbiAgfSwgcHJlcGVuZCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5fYWRkQnVmZmVyID0gZnVuY3Rpb24oYnVmLCBwcmVwZW5kKSB7XG4gIHZhciBvcGNvZGVudW07XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuICBpZiAobGVuID49IDAgJiYgbGVuIDwgT3Bjb2RlLk9QX1BVU0hEQVRBMSkge1xuICAgIG9wY29kZW51bSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPCBNYXRoLnBvdygyLCA4KSkge1xuICAgIG9wY29kZW51bSA9IE9wY29kZS5PUF9QVVNIREFUQTE7XG4gIH0gZWxzZSBpZiAobGVuIDwgTWF0aC5wb3coMiwgMTYpKSB7XG4gICAgb3Bjb2RlbnVtID0gT3Bjb2RlLk9QX1BVU0hEQVRBMjtcbiAgfSBlbHNlIGlmIChsZW4gPCBNYXRoLnBvdygyLCAzMikpIHtcbiAgICBvcGNvZGVudW0gPSBPcGNvZGUuT1BfUFVTSERBVEE0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhblxcJ3QgcHVzaCB0aGF0IG11Y2ggZGF0YScpO1xuICB9XG4gIHRoaXMuX2luc2VydEF0UG9zaXRpb24oe1xuICAgIGJ1ZjogYnVmLFxuICAgIGxlbjogbGVuLFxuICAgIG9wY29kZW51bTogb3Bjb2RlbnVtXG4gIH0sIHByZXBlbmQpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUuaGFzQ29kZXNlcGFyYXRvcnMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmNodW5rc1tpXS5vcGNvZGVudW0gPT09IE9wY29kZS5PUF9DT0RFU0VQQVJBVE9SKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5yZW1vdmVDb2Rlc2VwYXJhdG9ycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2h1bmtzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5jaHVua3NbaV0ub3Bjb2RlbnVtICE9PSBPcGNvZGUuT1BfQ09ERVNFUEFSQVRPUikge1xuICAgICAgY2h1bmtzLnB1c2godGhpcy5jaHVua3NbaV0pO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IGNodW5rcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBoaWdoIGxldmVsIHNjcmlwdCBidWlsZGVyIG1ldGhvZHNcblxuLyoqXG4gKiBAcmV0dXJucyB7U2NyaXB0fSBhIG5ldyBNdWx0aXNpZyBvdXRwdXQgc2NyaXB0IGZvciBnaXZlbiBwdWJsaWMga2V5cyxcbiAqIHJlcXVpcmluZyBtIG9mIHRob3NlIHB1YmxpYyBrZXlzIHRvIHNwZW5kXG4gKiBAcGFyYW0ge1B1YmxpY0tleVtdfSBwdWJsaWNLZXlzIC0gbGlzdCBvZiBhbGwgcHVibGljIGtleXMgY29udHJvbGxpbmcgdGhlIG91dHB1dFxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCAtIGFtb3VudCBvZiByZXF1aXJlZCBzaWduYXR1cmVzIHRvIHNwZW5kIHRoZSBvdXRwdXRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0cyAtIFNldmVyYWwgb3B0aW9uczpcbiAqICAgICAgICAtIG5vU29ydGluZzogZGVmYXVsdHMgdG8gZmFsc2UsIGlmIHRydWUsIGRvbid0IHNvcnQgdGhlIGdpdmVuXG4gKiAgICAgICAgICAgICAgICAgICAgICBwdWJsaWMga2V5cyBiZWZvcmUgY3JlYXRpbmcgdGhlIHNjcmlwdFxuICovXG5TY3JpcHQuYnVpbGRNdWx0aXNpZ091dCA9IGZ1bmN0aW9uKHB1YmxpY0tleXMsIHRocmVzaG9sZCwgb3B0cykge1xuICAkLmNoZWNrQXJndW1lbnQodGhyZXNob2xkIDw9IHB1YmxpY0tleXMubGVuZ3RoLFxuICAgICdOdW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcyBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHB1YmxpYyBrZXlzJyk7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgc2NyaXB0ID0gbmV3IFNjcmlwdCgpO1xuICBzY3JpcHQuYWRkKE9wY29kZS5zbWFsbEludCh0aHJlc2hvbGQpKTtcbiAgcHVibGljS2V5cyA9IHB1YmxpY0tleXMubWFwKFB1YmxpY0tleSk7XG4gIHZhciBzb3J0ZWQgPSBwdWJsaWNLZXlzO1xuICBpZiAoIW9wdHMubm9Tb3J0aW5nKSB7XG4gICAgc29ydGVkID0gXy5zb3J0QnkocHVibGljS2V5cywgZnVuY3Rpb24ocHVibGljS2V5KSB7XG4gICAgICByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9KTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdWJsaWNLZXkgPSBzb3J0ZWRbaV07XG4gICAgc2NyaXB0LmFkZChwdWJsaWNLZXkudG9CdWZmZXIoKSk7XG4gIH1cbiAgc2NyaXB0LmFkZChPcGNvZGUuc21hbGxJbnQocHVibGljS2V5cy5sZW5ndGgpKTtcbiAgc2NyaXB0LmFkZChPcGNvZGUuT1BfQ0hFQ0tNVUxUSVNJRyk7XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG5TY3JpcHQuYnVpbGRXaXRuZXNzTXVsdGlzaWdPdXRGcm9tU2NyaXB0ID0gZnVuY3Rpb24oc2NyaXB0KSB7XG4gIGlmIChzY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQpIHtcbiAgICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcbiAgICBzLmFkZChPcGNvZGUuT1BfMCk7XG4gICAgcy5hZGQoSGFzaC5zaGEyNTYoc2NyaXB0LnRvQnVmZmVyKCkpKTtcbiAgICByZXR1cm4gcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIHAyc2ggc2NyaXB0Jyk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBuZXcgTXVsdGlzaWcgaW5wdXQgc2NyaXB0IGZvciB0aGUgZ2l2ZW4gcHVibGljIGtleXMsIHJlcXVpcmluZyBtIG9mIHRob3NlIHB1YmxpYyBrZXlzIHRvIHNwZW5kXG4gKlxuICogQHBhcmFtIHtQdWJsaWNLZXlbXX0gcHVia2V5cyBsaXN0IG9mIGFsbCBwdWJsaWMga2V5cyBjb250cm9sbGluZyB0aGUgb3V0cHV0XG4gKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIGFtb3VudCBvZiByZXF1aXJlZCBzaWduYXR1cmVzIHRvIHNwZW5kIHRoZSBvdXRwdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHNpZ25hdHVyZXMgYW5kIGFycmF5IG9mIHNpZ25hdHVyZSBidWZmZXJzIHRvIGFwcGVuZCB0byB0aGUgc2NyaXB0XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdHMubm9Tb3J0aW5nIGRvbid0IHNvcnQgdGhlIGdpdmVuIHB1YmxpYyBrZXlzIGJlZm9yZSBjcmVhdGluZyB0aGUgc2NyaXB0IChmYWxzZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIHtTY3JpcHQ9fSBvcHRzLmNhY2hlZE11bHRpc2lnIGRvbid0IHJlY2FsY3VsYXRlIHRoZSByZWRlZW1TY3JpcHRcbiAqXG4gKiBAcmV0dXJucyB7U2NyaXB0fVxuICovXG5TY3JpcHQuYnVpbGRNdWx0aXNpZ0luID0gZnVuY3Rpb24ocHVia2V5cywgdGhyZXNob2xkLCBzaWduYXR1cmVzLCBvcHRzKSB7XG4gICQuY2hlY2tBcmd1bWVudChBcnJheS5pc0FycmF5KHB1YmtleXMpKTtcbiAgJC5jaGVja0FyZ3VtZW50KCFpc05hTih0aHJlc2hvbGQpKTtcbiAgJC5jaGVja0FyZ3VtZW50KEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlcykpO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHMgPSBuZXcgU2NyaXB0KCk7XG4gIHMuYWRkKE9wY29kZS5PUF8wKTtcbiAgZm9yIChjb25zdCBzaWduYXR1cmUgb2Ygc2lnbmF0dXJlcykge1xuICAgICQuY2hlY2tBcmd1bWVudChCdWZmZXJVdGlsLmlzQnVmZmVyKHNpZ25hdHVyZSksICdTaWduYXR1cmVzIG11c3QgYmUgYW4gYXJyYXkgb2YgQnVmZmVycycpO1xuICAgIC8vIFRPRE86IGFsbG93IHNpZ25hdHVyZXMgdG8gYmUgYW4gYXJyYXkgb2YgU2lnbmF0dXJlIG9iamVjdHNcbiAgICBzLmFkZChzaWduYXR1cmUpO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBBIG5ldyBQMlNIIE11bHRpc2lnIGlucHV0IHNjcmlwdCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXlzLCByZXF1aXJpbmcgbSBvZiB0aG9zZSBwdWJsaWMga2V5cyB0byBzcGVuZFxuICpcbiAqIEBwYXJhbSB7UHVibGljS2V5W119IHB1YmtleXMgbGlzdCBvZiBhbGwgcHVibGljIGtleXMgY29udHJvbGxpbmcgdGhlIG91dHB1dFxuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBhbW91bnQgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcyB0byBzcGVuZCB0aGUgb3V0cHV0XG4gKiBAcGFyYW0ge0FycmF5fSBzaWduYXR1cmVzIGFuZCBhcnJheSBvZiBzaWduYXR1cmUgYnVmZmVycyB0byBhcHBlbmQgdG8gdGhlIHNjcmlwdFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRzLm5vU29ydGluZyBkb24ndCBzb3J0IHRoZSBnaXZlbiBwdWJsaWMga2V5cyBiZWZvcmUgY3JlYXRpbmcgdGhlIHNjcmlwdCAoZmFsc2UgYnkgZGVmYXVsdClcbiAqIEBwYXJhbSB7U2NyaXB0PX0gb3B0cy5jYWNoZWRNdWx0aXNpZyBkb24ndCByZWNhbGN1bGF0ZSB0aGUgcmVkZWVtU2NyaXB0XG4gKlxuICogQHJldHVybnMge1NjcmlwdH1cbiAqL1xuU2NyaXB0LmJ1aWxkUDJTSE11bHRpc2lnSW4gPSBmdW5jdGlvbihwdWJrZXlzLCB0aHJlc2hvbGQsIHNpZ25hdHVyZXMsIG9wdHMpIHtcbiAgJC5jaGVja0FyZ3VtZW50KEFycmF5LmlzQXJyYXkocHVia2V5cykpO1xuICAkLmNoZWNrQXJndW1lbnQoIWlzTmFOKHRocmVzaG9sZCkpO1xuICAkLmNoZWNrQXJndW1lbnQoQXJyYXkuaXNBcnJheShzaWduYXR1cmVzKSk7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcbiAgcy5hZGQoT3Bjb2RlLk9QXzApO1xuICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiBzaWduYXR1cmVzKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50KEJ1ZmZlclV0aWwuaXNCdWZmZXIoc2lnbmF0dXJlKSwgJ1NpZ25hdHVyZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgLy8gVE9ETzogYWxsb3cgc2lnbmF0dXJlcyB0byBiZSBhbiBhcnJheSBvZiBTaWduYXR1cmUgb2JqZWN0c1xuICAgIHMuYWRkKHNpZ25hdHVyZSk7XG4gIH1cbiAgcy5hZGQoKG9wdHMuY2FjaGVkTXVsdGlzaWcgfHwgU2NyaXB0LmJ1aWxkTXVsdGlzaWdPdXQocHVia2V5cywgdGhyZXNob2xkLCBvcHRzKSkudG9CdWZmZXIoKSk7XG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7U2NyaXB0fSBhIG5ldyBwYXkgdG8gcHVibGljIGtleSBoYXNoIG91dHB1dCBmb3IgdGhlIGdpdmVuXG4gKiBhZGRyZXNzIG9yIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSB7KEFkZHJlc3N8UHVibGljS2V5KX0gdG8gLSBkZXN0aW5hdGlvbiBhZGRyZXNzIG9yIHB1YmxpYyBrZXlcbiAqL1xuU2NyaXB0LmJ1aWxkUHVibGljS2V5SGFzaE91dCA9IGZ1bmN0aW9uKHRvKSB7XG4gICQuY2hlY2tBcmd1bWVudCh0byAhPSBudWxsKTtcbiAgJC5jaGVja0FyZ3VtZW50KHRvIGluc3RhbmNlb2YgUHVibGljS2V5IHx8IHRvIGluc3RhbmNlb2YgQWRkcmVzcyB8fCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnKTtcbiAgaWYgKHRvIGluc3RhbmNlb2YgUHVibGljS2V5KSB7XG4gICAgdG8gPSB0by50b0FkZHJlc3MoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XG4gICAgdG8gPSBuZXcgQWRkcmVzcyh0byk7XG4gIH1cbiAgdmFyIHMgPSBuZXcgU2NyaXB0KCk7XG4gIHMuYWRkKE9wY29kZS5PUF9EVVApXG4gICAgLmFkZChPcGNvZGUuT1BfSEFTSDE2MClcbiAgICAuYWRkKHRvLmhhc2hCdWZmZXIpXG4gICAgLmFkZChPcGNvZGUuT1BfRVFVQUxWRVJJRlkpXG4gICAgLmFkZChPcGNvZGUuT1BfQ0hFQ0tTSUcpO1xuICBzLl9uZXR3b3JrID0gdG8ubmV0d29yaztcbiAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTY3JpcHR9IGEgbmV3IHBheSB0byB3aXRuZXNzIHYwIG91dHB1dCBmb3IgdGhlIGdpdmVuXG4gKiBhZGRyZXNzXG4gKiBAcGFyYW0geyhBZGRyZXNzfFB1YmxpY0tleSl9IHRvIC0gZGVzdGluYXRpb24gYWRkcmVzc1xuICovXG5TY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQgPSBmdW5jdGlvbih0bykge1xuICAkLmNoZWNrQXJndW1lbnQodG8gIT0gbnVsbCk7XG4gICQuY2hlY2tBcmd1bWVudCh0byBpbnN0YW5jZW9mIFB1YmxpY0tleSB8fCB0byBpbnN0YW5jZW9mIEFkZHJlc3MgfHwgdHlwZW9mIHRvID09PSAnc3RyaW5nJyk7XG4gIGlmICh0byBpbnN0YW5jZW9mIFB1YmxpY0tleSkge1xuICAgIHRvID0gdG8udG9BZGRyZXNzKG51bGwsIEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRvID09PSAnc3RyaW5nJykge1xuICAgIHRvID0gbmV3IEFkZHJlc3ModG8pO1xuICB9XG4gIHZhciBzID0gbmV3IFNjcmlwdCgpO1xuICBzLmFkZChPcGNvZGUuT1BfMClcbiAgICAuYWRkKHRvLmhhc2hCdWZmZXIpO1xuICBzLl9uZXR3b3JrID0gdG8ubmV0d29yaztcbiAgcmV0dXJuIHM7XG59O1xuXG5cbi8qKlxuICogQnVpbGQgVGFwcm9vdCBzY3JpcHQgb3V0cHV0XG4gKiBAcGFyYW0ge1B1YmxpY0tleXxBZGRyZXNzfSB0byByZWNpcGllbnQncyBwdWJLZXkgb3IgYWRkcmVzc1xuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHNjcmlwdFRyZWUgc2luZ2xlIGxlYWYgb2JqZWN0IE9SIGFycmF5IG9mIGxlYXZlcy4gbGVhZjogeyBzY3JpcHQ6IFN0cmluZywgbGVhZlZlcnNpb246IEludGVnZXIgfVxuICogQHJldHVybnMge1NjcmlwdH1cbiAqL1xuU2NyaXB0LmJ1aWxkV2l0bmVzc1YxT3V0ID0gZnVuY3Rpb24odG8sIHNjcmlwdFRyZWUpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHRvIGluc3RhbmNlb2YgUHVibGljS2V5IHx8IHRvIGluc3RhbmNlb2YgQWRkcmVzcyB8fCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnKTtcbiAgJC5jaGVja0FyZ3VtZW50KCFzY3JpcHRUcmVlIHx8IEFycmF5LmlzQXJyYXkoc2NyaXB0VHJlZSkgfHwgISFzY3JpcHRUcmVlLnNjcmlwdCk7XG5cbiAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdG8gPSBQdWJsaWNLZXkuZnJvbVRhcHJvb3QodG8pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdG8gPSBBZGRyZXNzLmZyb21TdHJpbmcodG8pO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gYnVpbGRUcmVlKHRyZWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgICAgY29uc3QgW2xlZnQsIGxlZnRIXSA9IGJ1aWxkVHJlZSh0cmVlWzBdKTtcbiAgICAgIGNvbnN0IFtyaWdodCwgcmlnaHRIXSA9IGJ1aWxkVHJlZSh0cmVlWzFdKTtcbiAgICAgIGNvbnN0IHJldCA9IFtbW2xlZnRbMF0sIGxlZnRbMV1dLCByaWdodEhdLCBbW3JpZ2h0WzBdLCByaWdodFsxXV0sIGxlZnRIXV07XG4gICAgICBjb25zdCBoV3JpdGVyID0gVGFnZ2VkSGFzaC5UQVBCUkFOQ0g7XG4gICAgICBpZiAobGVmdEguY29tcGFyZShyaWdodEgpID09PSAxKSB7XG4gICAgICAgIGhXcml0ZXIud3JpdGUocmlnaHRIKTtcbiAgICAgICAgaFdyaXRlci53cml0ZShsZWZ0SCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoV3JpdGVyLndyaXRlKGxlZnRIKTtcbiAgICAgICAgaFdyaXRlci53cml0ZShyaWdodEgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtyZXQsIGhXcml0ZXIuZmluYWxpemUoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgbGVhZlZlcnNpb24sIHNjcmlwdCB9ID0gdHJlZTtcbiAgICAgIGNvbnN0IHNjcmlwdEJ1ZiA9IG5ldyBTY3JpcHQoc2NyaXB0KS50b0J1ZmZlcigpO1xuICAgICAgY29uc3QgbGVhZldyaXRlciA9IFRhZ2dlZEhhc2guVEFQTEVBRjtcbiAgICAgIGxlYWZXcml0ZXIud3JpdGVVSW50OChsZWFmVmVyc2lvbik7XG4gICAgICBsZWFmV3JpdGVyLndyaXRlVUludDgoc2NyaXB0QnVmLmxlbmd0aCk7XG4gICAgICBsZWFmV3JpdGVyLndyaXRlKHNjcmlwdEJ1Zik7XG4gICAgICBjb25zdCBoID0gbGVhZldyaXRlci5maW5hbGl6ZSgpO1xuICAgICAgcmV0dXJuIFtbQnVmZmVyLmZyb20oW2xlYWZWZXJzaW9uXSksIHNjcmlwdEJ1Zl0sIGhdO1xuICAgIH1cbiAgfVxuXG4gIGxldCB0YWdnZWRIYXNoID0gbnVsbDtcbiAgaWYgKHNjcmlwdFRyZWUpIHsgXG4gICAgY29uc3QgW18sIGhdID0gYnVpbGRUcmVlKHNjcmlwdFRyZWUpO1xuICAgIHRhZ2dlZEhhc2ggPSBoO1xuICB9XG4gIFxuICBsZXQgdHdlYWtlZFB1YktleTtcbiAgaWYgKHRvIGluc3RhbmNlb2YgUHVibGljS2V5KSB7XG4gICAgdHdlYWtlZFB1YktleSA9IHRvLmNyZWF0ZVRhcFR3ZWFrKHRhZ2dlZEhhc2gpLnR3ZWFrZWRQdWJLZXk7XG4gIH0gZWxzZSB7IC8vIEFkZHJlc3NcbiAgICB0d2Vha2VkUHViS2V5ID0gdG8uaGFzaEJ1ZmZlcjtcbiAgfVxuICBjb25zdCBzID0gbmV3IFNjcmlwdCgpO1xuICBzLmFkZChPcGNvZGUuT1BfMSk7XG4gIHMuYWRkKHR3ZWFrZWRQdWJLZXkpO1xuICByZXR1cm4gcztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJucyB7U2NyaXB0fSBhIG5ldyBwYXkgdG8gcHVibGljIGtleSBvdXRwdXQgZm9yIHRoZSBnaXZlblxuICogIHB1YmxpYyBrZXlcbiAqL1xuU2NyaXB0LmJ1aWxkUHVibGljS2V5T3V0ID0gZnVuY3Rpb24ocHVia2V5KSB7XG4gICQuY2hlY2tBcmd1bWVudChwdWJrZXkgaW5zdGFuY2VvZiBQdWJsaWNLZXkpO1xuICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcbiAgcy5hZGQocHVia2V5LnRvQnVmZmVyKCkpXG4gICAgLmFkZChPcGNvZGUuT1BfQ0hFQ0tTSUcpO1xuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogQHJldHVybnMge1NjcmlwdH0gYSBuZXcgT1BfUkVUVVJOIHNjcmlwdCB3aXRoIGRhdGFcbiAqIEBwYXJhbSB7KHN0cmluZ3xCdWZmZXIpfSBkYXRhIC0gdGhlIGRhdGEgdG8gZW1iZWQgaW4gdGhlIG91dHB1dFxuICogQHBhcmFtIHsoc3RyaW5nKX0gZW5jb2RpbmcgLSB0aGUgdHlwZSBvZiBlbmNvZGluZyBvZiB0aGUgc3RyaW5nXG4gKi9cblNjcmlwdC5idWlsZERhdGFPdXQgPSBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAkLmNoZWNrQXJndW1lbnQoZGF0YSA9PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKGRhdGEpKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZyk7XG4gIH1cbiAgdmFyIHMgPSBuZXcgU2NyaXB0KCk7XG4gIHMuYWRkKE9wY29kZS5PUF9SRVRVUk4pO1xuICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgcy5hZGQoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U2NyaXB0fEFkZHJlc3N9IHNjcmlwdCAtIHRoZSByZWRlZW1TY3JpcHQgZm9yIHRoZSBuZXcgcDJzaCBvdXRwdXQuXG4gKiAgICBJdCBjYW4gYWxzbyBiZSBhIHAyc2ggYWRkcmVzc1xuICogQHJldHVybnMge1NjcmlwdH0gbmV3IHBheSB0byBzY3JpcHQgaGFzaCBzY3JpcHQgZm9yIGdpdmVuIHNjcmlwdFxuICovXG5TY3JpcHQuYnVpbGRTY3JpcHRIYXNoT3V0ID0gZnVuY3Rpb24oc2NyaXB0KSB7XG4gICQuY2hlY2tBcmd1bWVudChzY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQgfHxcbiAgICAoc2NyaXB0IGluc3RhbmNlb2YgQWRkcmVzcyAmJiBzY3JpcHQuaXNQYXlUb1NjcmlwdEhhc2goKSkpO1xuICB2YXIgcyA9IG5ldyBTY3JpcHQoKTtcbiAgcy5hZGQoT3Bjb2RlLk9QX0hBU0gxNjApXG4gICAgLmFkZChzY3JpcHQgaW5zdGFuY2VvZiBBZGRyZXNzID8gc2NyaXB0Lmhhc2hCdWZmZXIgOiBIYXNoLnNoYTI1NnJpcGVtZDE2MChzY3JpcHQudG9CdWZmZXIoKSkpXG4gICAgLmFkZChPcGNvZGUuT1BfRVFVQUwpO1xuXG4gIHMuX25ldHdvcmsgPSBzY3JpcHQuX25ldHdvcmsgfHwgc2NyaXB0Lm5ldHdvcms7XG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBzY3JpcHRTaWcgKGEgc2NyaXB0IGZvciBhbiBpbnB1dCkgdGhhdCBzaWducyBhIHB1YmxpYyBrZXkgb3V0cHV0IHNjcmlwdC5cbiAqXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZ25hdHVyZSAtIGEgU2lnbmF0dXJlIG9iamVjdCwgb3IgdGhlIHNpZ25hdHVyZSBpbiBERVIgY2Fub25pY2FsIGVuY29kaW5nXG4gKiBAcGFyYW0ge251bWJlcj19IHNpZ3R5cGUgLSB0aGUgdHlwZSBvZiB0aGUgc2lnbmF0dXJlIChkZWZhdWx0cyB0byBTSUdIQVNIX0FMTClcbiAqL1xuU2NyaXB0LmJ1aWxkUHVibGljS2V5SW4gPSBmdW5jdGlvbihzaWduYXR1cmUsIHNpZ3R5cGUpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNpZ25hdHVyZSB8fCBCdWZmZXJVdGlsLmlzQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAkLmNoZWNrQXJndW1lbnQoc2lndHlwZSA9PSBudWxsIHx8ICFpc05hTihzaWd0eXBlKSk7XG4gIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICBzaWduYXR1cmUgPSBzaWduYXR1cmUudG9CdWZmZXIoKTtcbiAgfVxuICB2YXIgc2NyaXB0ID0gbmV3IFNjcmlwdCgpO1xuICBzY3JpcHQuYWRkKEJ1ZmZlclV0aWwuY29uY2F0KFtcbiAgICBzaWduYXR1cmUsXG4gICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ3R5cGUgfHwgU2lnbmF0dXJlLlNJR0hBU0hfQUxMKVxuICBdKSk7XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNjcmlwdFNpZyAoYSBzY3JpcHQgZm9yIGFuIGlucHV0KSB0aGF0IHNpZ25zIGEgcHVibGljIGtleSBoYXNoXG4gKiBvdXRwdXQgc2NyaXB0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ3xQdWJsaWNLZXl9IHB1YmxpY0tleVxuICogQHBhcmFtIHtTaWduYXR1cmV8QnVmZmVyfSBzaWduYXR1cmUgLSBhIFNpZ25hdHVyZSBvYmplY3QsIG9yIHRoZSBzaWduYXR1cmUgaW4gREVSIGNhbm9uaWNhbCBlbmNvZGluZ1xuICogQHBhcmFtIHtudW1iZXI9fSBzaWd0eXBlIC0gdGhlIHR5cGUgb2YgdGhlIHNpZ25hdHVyZSAoZGVmYXVsdHMgdG8gU0lHSEFTSF9BTEwpXG4gKi9cblNjcmlwdC5idWlsZFB1YmxpY0tleUhhc2hJbiA9IGZ1bmN0aW9uKHB1YmxpY0tleSwgc2lnbmF0dXJlLCBzaWd0eXBlKSB7XG4gICQuY2hlY2tBcmd1bWVudChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUgfHwgQnVmZmVyVXRpbC5pc0J1ZmZlcihzaWduYXR1cmUpKTtcbiAgJC5jaGVja0FyZ3VtZW50KHNpZ3R5cGUgPT0gbnVsbCB8fCAhaXNOYU4oc2lndHlwZSkpO1xuICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnRvQnVmZmVyKCk7XG4gIH1cbiAgdmFyIHNjcmlwdCA9IG5ldyBTY3JpcHQoKVxuICAgIC5hZGQoQnVmZmVyVXRpbC5jb25jYXQoW1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ3R5cGUgfHwgU2lnbmF0dXJlLlNJR0hBU0hfQUxMKVxuICAgIF0pKVxuICAgIC5hZGQobmV3IFB1YmxpY0tleShwdWJsaWNLZXkpLnRvQnVmZmVyKCkpO1xuICByZXR1cm4gc2NyaXB0O1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7U2NyaXB0fSBhbiBlbXB0eSBzY3JpcHRcbiAqL1xuU2NyaXB0LmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2NyaXB0KCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTY3JpcHR9IGEgbmV3IHBheSB0byBzY3JpcHQgaGFzaCBzY3JpcHQgdGhhdCBwYXlzIHRvIHRoaXMgc2NyaXB0XG4gKi9cblNjcmlwdC5wcm90b3R5cGUudG9TY3JpcHRIYXNoT3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBTY3JpcHQuYnVpbGRTY3JpcHRIYXNoT3V0KHRoaXMpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtTY3JpcHR9IGFuIG91dHB1dCBzY3JpcHQgYnVpbHQgZnJvbSB0aGUgYWRkcmVzc1xuICovXG5TY3JpcHQuZnJvbUFkZHJlc3MgPSBmdW5jdGlvbihhZGRyZXNzKSB7XG4gIGFkZHJlc3MgPSBBZGRyZXNzKGFkZHJlc3MpO1xuICBpZiAoYWRkcmVzcy5pc1BheVRvU2NyaXB0SGFzaCgpKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5idWlsZFNjcmlwdEhhc2hPdXQoYWRkcmVzcyk7XG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5pc1BheVRvUHVibGljS2V5SGFzaCgpKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5idWlsZFB1YmxpY0tleUhhc2hPdXQoYWRkcmVzcyk7XG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5pc1BheVRvV2l0bmVzc1B1YmxpY0tleUhhc2goKSkge1xuICAgIHJldHVybiBTY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQoYWRkcmVzcyk7XG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5pc1BheVRvV2l0bmVzc1NjcmlwdEhhc2goKSkge1xuICAgIHJldHVybiBTY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQoYWRkcmVzcyk7XG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5pc1BheVRvVGFwcm9vdCgpKSB7XG4gICAgcmV0dXJuIFNjcmlwdC5idWlsZFdpdG5lc3NWMU91dChhZGRyZXNzKTtcbiAgfVxuICB0aHJvdyBuZXcgZXJyb3JzLlNjcmlwdC5VbnJlY29nbml6ZWRBZGRyZXNzKGFkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0aGUgYXNzb2NpYXRlZCBhZGRyZXNzIGluZm9ybWF0aW9uIG9iamVjdFxuICogQHJldHVybiB7QWRkcmVzc3xib29sZWFufVxuICovXG5TY3JpcHQucHJvdG90eXBlLmdldEFkZHJlc3NJbmZvID0gZnVuY3Rpb24ob3B0cykge1xuICBpZiAodGhpcy5faXNJbnB1dCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRJbnB1dEFkZHJlc3NJbmZvKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5faXNPdXRwdXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0T3V0cHV0QWRkcmVzc0luZm8oKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuX2dldE91dHB1dEFkZHJlc3NJbmZvKCk7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0SW5wdXRBZGRyZXNzSW5mbygpO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0aGUgYXNzb2NpYXRlZCBvdXRwdXQgc2NyaXB0UHViS2V5IGFkZHJlc3MgaW5mb3JtYXRpb24gb2JqZWN0XG4gKiBAcmV0dXJuIHtBZGRyZXNzfGJvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5TY3JpcHQucHJvdG90eXBlLl9nZXRPdXRwdXRBZGRyZXNzSW5mbyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5mbyA9IHt9O1xuICBpZiAodGhpcy5pc1NjcmlwdEhhc2hPdXQoKSkge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIGluZm8udHlwZSA9IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoO1xuICB9IGVsc2UgaWYgKHRoaXMuaXNQdWJsaWNLZXlIYXNoT3V0KCkpIHtcbiAgICBpbmZvLmhhc2hCdWZmZXIgPSB0aGlzLmdldERhdGEoKTtcbiAgICBpbmZvLnR5cGUgPSBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaDtcbiAgfSBlbHNlIGlmICh0aGlzLmlzV2l0bmVzc1NjcmlwdEhhc2hPdXQoKSkge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIGluZm8udHlwZSA9IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaDtcbiAgfSBlbHNlIGlmICh0aGlzLmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSkge1xuICAgIGluZm8uaGFzaEJ1ZmZlciA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIGluZm8udHlwZSA9IEFkZHJlc3MuUGF5VG9XaXRuZXNzUHVibGljS2V5SGFzaDtcbiAgfSBlbHNlIGlmICh0aGlzLmlzVGFwcm9vdCgpKSB7XG4gICAgaW5mby5oYXNoQnVmZmVyID0gdGhpcy5nZXREYXRhKCk7XG4gICAgaW5mby50eXBlID0gQWRkcmVzcy5QYXlUb1RhcHJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpbmZvO1xufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBzY3JpcHRTaWcgYWRkcmVzcyBpbmZvcm1hdGlvbiBvYmplY3RcbiAqIEByZXR1cm4ge0FkZHJlc3N8Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cblNjcmlwdC5wcm90b3R5cGUuX2dldElucHV0QWRkcmVzc0luZm8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaWYgKHRoaXMuaXNQdWJsaWNLZXlIYXNoSW4oKSkge1xuICAgIC8vIGhhc2ggdGhlIHB1YmxpY2tleSBmb3VuZCBpbiB0aGUgc2NyaXB0U2lnXG4gICAgaW5mby5oYXNoQnVmZmVyID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAodGhpcy5jaHVua3NbMV0uYnVmKTtcbiAgICBpbmZvLnR5cGUgPSBBZGRyZXNzLlBheVRvUHVibGljS2V5SGFzaDtcbiAgfSBlbHNlIGlmICh0aGlzLmlzU2NyaXB0SGFzaEluKCkpIHtcbiAgICAvLyBoYXNoIHRoZSByZWRlZW1zY3JpcHQgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgc2NyaXB0U2lnXG4gICAgaW5mby5oYXNoQnVmZmVyID0gSGFzaC5zaGEyNTZyaXBlbWQxNjAodGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMV0uYnVmKTtcbiAgICBpbmZvLnR5cGUgPSBBZGRyZXNzLlBheVRvU2NyaXB0SGFzaDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TmV0d29yaz19IG5ldHdvcmtcbiAqIEByZXR1cm4ge0FkZHJlc3N8Ym9vbGVhbn0gdGhlIGFzc29jaWF0ZWQgYWRkcmVzcyBmb3IgdGhpcyBzY3JpcHQgaWYgcG9zc2libGUsIG9yIGZhbHNlXG4gKi9cblNjcmlwdC5wcm90b3R5cGUudG9BZGRyZXNzID0gZnVuY3Rpb24obmV0d29yaykge1xuICB2YXIgaW5mbyA9IHRoaXMuZ2V0QWRkcmVzc0luZm8oKTtcbiAgaWYgKCFpbmZvKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGluZm8ubmV0d29yayA9IE5ldHdvcmtzLmdldChuZXR3b3JrKSB8fCB0aGlzLl9uZXR3b3JrIHx8IE5ldHdvcmtzLmRlZmF1bHROZXR3b3JrO1xuICByZXR1cm4gbmV3IEFkZHJlc3MoaW5mbyk7XG59O1xuXG4vKipcbiAqIEFuYWxvZ291cyB0byBiaXRjb2luZCdzIEZpbmRBbmREZWxldGUuIEZpbmQgYW5kIGRlbGV0ZSBlcXVpdmFsZW50IGNodW5rcyxcbiAqIHR5cGljYWxseSB1c2VkIHdpdGggcHVzaCBkYXRhIGNodW5rcy4gIE5vdGUgdGhhdCB0aGlzIHdpbGwgZmluZCBhbmQgZGVsZXRlXG4gKiBub3QganVzdCB0aGUgc2FtZSBkYXRhLCBidXQgdGhlIHNhbWUgZGF0YSB3aXRoIHRoZSBzYW1lIHB1c2ggZGF0YSBvcCBhc1xuICogcHJvZHVjZWQgYnkgZGVmYXVsdC4gaS5lLiwgaWYgYSBwdXNoZGF0YSBpbiBhIHR4IGRvZXMgbm90IHVzZSB0aGUgbWluaW1hbFxuICogcHVzaGRhdGEgb3AsIHRoZW4gd2hlbiB5b3UgdHJ5IHRvIHJlbW92ZSB0aGUgZGF0YSBpdCBpcyBwdXNoaW5nLCBpdCB3aWxsIG5vdFxuICogYmUgcmVtb3ZlZCwgYmVjYXVzZSB0aGV5IGRvIG5vdCB1c2UgdGhlIHNhbWUgcHVzaGRhdGEgb3AuXG4gKi9cblNjcmlwdC5wcm90b3R5cGUuZmluZEFuZERlbGV0ZSA9IGZ1bmN0aW9uKHNjcmlwdCkge1xuICB2YXIgYnVmID0gc2NyaXB0LnRvQnVmZmVyKCk7XG4gIHZhciBoZXggPSBidWYudG9TdHJpbmcoJ2hleCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNjcmlwdDIgPSBTY3JpcHQoe1xuICAgICAgY2h1bmtzOiBbdGhpcy5jaHVua3NbaV1dXG4gICAgfSk7XG4gICAgdmFyIGJ1ZjIgPSBzY3JpcHQyLnRvQnVmZmVyKCk7XG4gICAgdmFyIGhleDIgPSBidWYyLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAoaGV4ID09PSBoZXgyKSB7XG4gICAgICB0aGlzLmNodW5rcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21lcyBmcm9tIGJpdGNvaW5kJ3Mgc2NyaXB0IGludGVycHJldGVyIENoZWNrTWluaW1hbFB1c2ggZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiB0aGUgY2h1bmsge2l9IGlzIHRoZSBzbWFsbGVzdCB3YXkgdG8gcHVzaCB0aGF0IHBhcnRpY3VsYXIgZGF0YS5cbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5jaGVja01pbmltYWxQdXNoID0gZnVuY3Rpb24oaSkge1xuICB2YXIgY2h1bmsgPSB0aGlzLmNodW5rc1tpXTtcbiAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZjtcbiAgdmFyIG9wY29kZW51bSA9IGNodW5rLm9wY29kZW51bTtcbiAgaWYgKCFidWYpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIENvdWxkIGhhdmUgdXNlZCBPUF8wLlxuICAgIHJldHVybiBvcGNvZGVudW0gPT09IE9wY29kZS5PUF8wO1xuICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPT09IDEgJiYgYnVmWzBdID49IDEgJiYgYnVmWzBdIDw9IDE2KSB7XG4gICAgLy8gQ291bGQgaGF2ZSB1c2VkIE9QXzEgLi4gT1BfMTYuXG4gICAgcmV0dXJuIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QXzEgKyAoYnVmWzBdIC0gMSk7XG4gIH0gZWxzZSBpZiAoYnVmLmxlbmd0aCA9PT0gMSAmJiBidWZbMF0gPT09IDB4ODEpIHtcbiAgICAvLyBDb3VsZCBoYXZlIHVzZWQgT1BfMU5FR0FURVxuICAgIHJldHVybiBvcGNvZGVudW0gPT09IE9wY29kZS5PUF8xTkVHQVRFO1xuICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPD0gNzUpIHtcbiAgICAvLyBDb3VsZCBoYXZlIHVzZWQgYSBkaXJlY3QgcHVzaCAob3Bjb2RlIGluZGljYXRpbmcgbnVtYmVyIG9mIGJ5dGVzIHB1c2hlZCArIHRob3NlIGJ5dGVzKS5cbiAgICByZXR1cm4gb3Bjb2RlbnVtID09PSBidWYubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPD0gMjU1KSB7XG4gICAgLy8gQ291bGQgaGF2ZSB1c2VkIE9QX1BVU0hEQVRBLlxuICAgIHJldHVybiBvcGNvZGVudW0gPT09IE9wY29kZS5PUF9QVVNIREFUQTE7XG4gIH0gZWxzZSBpZiAoYnVmLmxlbmd0aCA8PSA2NTUzNSkge1xuICAgIC8vIENvdWxkIGhhdmUgdXNlZCBPUF9QVVNIREFUQTIuXG4gICAgcmV0dXJuIG9wY29kZW51bSA9PT0gT3Bjb2RlLk9QX1BVU0hEQVRBMjtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBDb21lcyBmcm9tIGJpdGNvaW5kJ3Mgc2NyaXB0IEdldFNpZ09wQ291bnQoYm9vbGVhbikgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlIGN1cnJlbnQgKHRydWUpIG9yIHByZS12ZXJzaW9uLTAuNiAoZmFsc2UpIGxvZ2ljXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBudW1iZXIgb2Ygc2lnbmF0dXJlIG9wZXJhdGlvbnMgcmVxdWlyZWQgYnkgdGhpcyBzY3JpcHRcbiAqL1xuU2NyaXB0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVPcGVyYXRpb25zQ291bnQgPSBmdW5jdGlvbihhY2N1cmF0ZSkge1xuICBhY2N1cmF0ZSA9IChhY2N1cmF0ZSA9PSBudWxsID8gdHJ1ZSA6IGFjY3VyYXRlKTtcbiAgdmFyIG4gPSAwO1xuICB2YXIgbGFzdE9wY29kZSA9IE9wY29kZS5PUF9JTlZBTElET1BDT0RFO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIHRoaXMuY2h1bmtzKSB7XG4gICAgdmFyIG9wY29kZSA9IGNodW5rLm9wY29kZW51bTtcbiAgICBpZiAob3Bjb2RlID09IE9wY29kZS5PUF9DSEVDS1NJRyB8fCBvcGNvZGUgPT0gT3Bjb2RlLk9QX0NIRUNLU0lHVkVSSUZZKSB7XG4gICAgICBuKys7XG4gICAgfSBlbHNlIGlmIChvcGNvZGUgPT0gT3Bjb2RlLk9QX0NIRUNLTVVMVElTSUcgfHwgb3Bjb2RlID09IE9wY29kZS5PUF9DSEVDS01VTFRJU0lHVkVSSUZZKSB7XG4gICAgICBpZiAoYWNjdXJhdGUgJiYgbGFzdE9wY29kZSA+PSBPcGNvZGUuT1BfMSAmJiBsYXN0T3Bjb2RlIDw9IE9wY29kZS5PUF8xNikge1xuICAgICAgICBuICs9IE9wY29kZS5kZWNvZGVPcE4obGFzdE9wY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuICs9IDIwO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0T3Bjb2RlID0gb3Bjb2RlO1xuICB9XG4gIHJldHVybiBuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JpcHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/script/script.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js\");\n\nmodule.exports.Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js\");\nmodule.exports.Output = __webpack_require__(/*! ./output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nmodule.exports.UnspentOutput = __webpack_require__(/*! ./unspentoutput */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/unspentoutput.js\");\nmodule.exports.Signature = __webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\nmodule.exports.Sighash = __webpack_require__(/*! ./sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nmodule.exports.SighashWitness = __webpack_require__(/*! ./sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDRIQUF5Qzs7QUFFekMsNEhBQXlDO0FBQ3pDLHlIQUEyQztBQUMzQyw4SUFBeUQ7QUFDekQsa0lBQWlEO0FBQ2pELDRIQUE2QztBQUM3QyxpSkFBMkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5kZXguanM/OGRmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMuSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSByZXF1aXJlKCcuL291dHB1dCcpO1xubW9kdWxlLmV4cG9ydHMuVW5zcGVudE91dHB1dCA9IHJlcXVpcmUoJy4vdW5zcGVudG91dHB1dCcpO1xubW9kdWxlLmV4cG9ydHMuU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbm1vZHVsZS5leHBvcnRzLlNpZ2hhc2ggPSByZXF1aXJlKCcuL3NpZ2hhc2gnKTtcbm1vZHVsZS5leHBvcnRzLlNpZ2hhc2hXaXRuZXNzID0gcmVxdWlyZSgnLi9zaWdoYXNod2l0bmVzcycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\n\nmodule.exports.PublicKey = __webpack_require__(/*! ./publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickey.js\");\nmodule.exports.PublicKeyHash = __webpack_require__(/*! ./publickeyhash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js\");\nmodule.exports.MultiSig = __webpack_require__(/*! ./multisig */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisig.js\");\nmodule.exports.MultiSigScriptHash = __webpack_require__(/*! ./multisigscripthash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js\");\nmodule.exports.Taproot = __webpack_require__(/*! ./taproot */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/taproot.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHNIQUFtQzs7QUFFbkMsd0lBQWlEO0FBQ2pELG9KQUF5RDtBQUN6RCxxSUFBK0M7QUFDL0MsbUtBQW1FO0FBQ25FLGtJQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi90cmFuc2FjdGlvbi9pbnB1dC9pbmRleC5qcz81NTAzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5QdWJsaWNLZXkgPSByZXF1aXJlKCcuL3B1YmxpY2tleScpO1xubW9kdWxlLmV4cG9ydHMuUHVibGljS2V5SGFzaCA9IHJlcXVpcmUoJy4vcHVibGlja2V5aGFzaCcpO1xubW9kdWxlLmV4cG9ydHMuTXVsdGlTaWcgPSByZXF1aXJlKCcuL211bHRpc2lnJyk7XG5tb2R1bGUuZXhwb3J0cy5NdWx0aVNpZ1NjcmlwdEhhc2ggPSByZXF1aXJlKCcuL211bHRpc2lnc2NyaXB0aGFzaCcpO1xubW9kdWxlLmV4cG9ydHMuVGFwcm9vdCA9IHJlcXVpcmUoJy4vdGFwcm9vdCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/input.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst errors = __webpack_require__(/*! ../../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar BufferWriter = __webpack_require__(/*! ../../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\n\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nconst SEQUENCE_LOCKTIME_DISABLE_FLAG =  Math.pow(2,31); // (1 << 31);\nconst SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2,22); // (1 << 22);\nconst SEQUENCE_LOCKTIME_MASK = 0xffff;\nconst SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds\nconst SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2,16)-1; // 16 bits \n\n\nfunction Input(params) {\n  if (!(this instanceof Input)) {\n    return new Input(params);\n  }\n  if (params) {\n    return this._fromObject(params);\n  }\n}\n\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\nInput.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;\n\nObject.defineProperty(Input.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    if (this.isNull()) {\n      return null;\n    }\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n    return this._script;\n  }\n});\n\nInput.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  var input = new Input();\n  return input._fromObject(obj);\n};\n\nInput.prototype._fromObject = function(params) {\n  var prevTxId;\n  if (typeof params.prevTxId === 'string' && JSUtil.isHexa(params.prevTxId)) {\n    prevTxId = Buffer.from(params.prevTxId, 'hex');\n  } else {\n    prevTxId = params.prevTxId;\n  }\n  this.witnesses = [];\n  this.output = params.output ?\n    (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;\n  this.prevTxId = prevTxId || params.txidbuf;\n  this.outputIndex = params.outputIndex == null ? params.txoutnum : params.outputIndex;\n  this.sequenceNumber = params.sequenceNumber == null ?\n    (params.seqnum == null ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber;\n  // null script is allowed in setScript()\n  if (params.script === undefined && params.scriptBuffer === undefined) {\n    throw new errors.Transaction.Input.MissingScript();\n  }\n  this.setScript(params.scriptBuffer || params.script);\n  return this;\n};\n\nInput.prototype.toObject = Input.prototype.toJSON = function toObject() {\n  var obj = {\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    sequenceNumber: this.sequenceNumber,\n    script: this._scriptBuffer.toString('hex'),\n  };\n  // add human readable form if input contains valid script\n  if (this.script) {\n    obj.scriptString = this.script.toString();\n  }\n  if (this.output) {\n    obj.output = this.output.toObject();\n  }\n  return obj;\n};\n\nInput.fromBufferReader = function(br) {\n  var input = new Input();\n  input.prevTxId = br.readReverse(32);\n  input.outputIndex = br.readUInt32LE();\n  input._scriptBuffer = br.readVarLengthBuffer();\n  input.sequenceNumber = br.readUInt32LE();\n  // TODO: return different classes according to which input it is\n  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n  return input;\n};\n\nInput.prototype.toBufferWriter = function(writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n  writer.writeReverse(this.prevTxId);\n  writer.writeUInt32LE(this.outputIndex);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  writer.writeUInt32LE(this.sequenceNumber);\n  return writer;\n};\n\nInput.prototype.setScript = function(script) {\n  this._script = null;\n  if (script instanceof Script) {\n    this._script = script;\n    this._script._isInput = true;\n    this._scriptBuffer = script.toBuffer();\n  } else if (JSUtil.isHexa(script)) {\n    // hex string script\n    this._scriptBuffer = Buffer.from(script, 'hex');\n  } else if (_.isString(script)) {\n    // human readable string script\n    this._script = new Script(script);\n    this._script._isInput = true;\n    this._scriptBuffer = this._script.toBuffer();\n  } else if (BufferUtil.isBuffer(script)) {\n    // buffer script\n    this._scriptBuffer = Buffer.from(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n  return this;\n};\n\n/**\n * Retrieve signatures for the provided PrivateKey.\n *\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key to use when signing\n * @param {number} inputIndex - the index of this input in the provided transaction\n * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n *     public key associated with the private key provided\n * @abstract\n */\nInput.prototype.getSignatures = function() {\n  throw new errors.AbstractMethodInvoked(\n    'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' +\n    ' for input: ' + JSON.stringify(this)\n  );\n};\n\nInput.prototype.getSatoshisBuffer = function() {\n  $.checkState(this.output instanceof Output);\n  $.checkState(this.output._satoshisBN);\n  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();\n};\n\n\nInput.prototype.isFullySigned = function() {\n  throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n};\n\nInput.prototype.isFinal = function() {\n  return this.sequenceNumber !== Input.MAXINT;\n};\n\nInput.prototype.addSignature = function() {\n  throw new errors.AbstractMethodInvoked('Input#addSignature');\n};\n\nInput.prototype.clearSignatures = function() {\n  throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n};\n\nInput.prototype.hasWitnesses = function() {\n  if (this.witnesses && this.witnesses.length > 0) {\n    return true;\n  }\n  return false;\n};\n\nInput.prototype.getWitnesses = function() {\n  return this.witnesses;\n};\n\nInput.prototype.setWitnesses = function(witnesses) {\n  this.witnesses = witnesses;\n};\n\nInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script\n  );\n};\n\n/**\n * @returns true if this is a coinbase input (represents no input)\n */\nInput.prototype.isNull = function() {\n  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&\n    this.outputIndex === 0xffffffff;\n};\n\nInput.prototype._estimateSize = function() {\n  return this.toBufferWriter().toBuffer().length;\n};\n\nInput.prototype._getBaseSize = function() {\n  return 32 + 4 + 4; // outpoint (32 + 4) + sequence (4)\n};\n\n\n/**\n * Sets sequence number so that transaction is not valid until the desired seconds\n *  since the transaction is mined\n *\n * @param {Number} time in seconds\n * @return {Transaction} this\n */\nInput.prototype.lockForSeconds = function(seconds) {\n  $.checkArgument(_.isNumber(seconds));\n  if (seconds < 0 ||  seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {\n    throw new errors.Transaction.Input.LockTimeRange();\n  }\n  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));\n\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 \n  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG ;\n  return this;\n};\n\n/**\n * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined\n *\n * @param {Number} height\n * @return {Transaction} this\n */\nInput.prototype.lockUntilBlockHeight = function(heightDiff) {\n  $.checkArgument(_.isNumber(heightDiff));\n  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {\n    throw new errors.Transaction.Input.BlockHeightOutOfRange();\n  }\n  // SEQUENCE_LOCKTIME_TYPE_FLAG = 0\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0\n  this.sequenceNumber = heightDiff ;\n  return this;\n};\n\n\n/**\n *  Returns a semantic version of the input's sequence nLockTime.\n *  @return {Number|Date}\n *  If sequence lock is disabled  it returns null,\n *  if is set to block height lock, returns a block height (number)\n *  else it returns a Date object.\n */\nInput.prototype.getLockTime = function() {\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return null;\n  }\n\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {\n    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);\n    return seconds;\n  } else {\n    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;\n    return blockHeight;\n  }\n};\n\n\n\n\nmodule.exports = Input;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L2lucHV0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMsNEZBQTBCO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQywwRUFBYztBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyxrR0FBNkI7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsc0VBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDBFQUFjO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQywrRUFBWTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsNkVBQVc7O0FBRWhDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsb0RBQW9EO0FBQ3BEO0FBQ0EsMkNBQTJDO0FBQzNDLG1EQUFtRDs7O0FBR25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L2lucHV0LmpzPzRmYTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uLy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2J1ZmZlcicpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvanMnKTtcbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbnZhciBTaWdoYXNoID0gcmVxdWlyZSgnLi4vc2lnaGFzaCcpO1xudmFyIE91dHB1dCA9IHJlcXVpcmUoJy4uL291dHB1dCcpO1xuXG52YXIgTUFYSU5UID0gMHhmZmZmZmZmZjsgLy8gTWF0aC5wb3coMiwgMzIpIC0gMTtcbnZhciBERUZBVUxUX1NFUU5VTUJFUiA9IE1BWElOVDtcbnZhciBERUZBVUxUX0xPQ0tUSU1FX1NFUU5VTUJFUiA9IE1BWElOVCAtIDE7XG52YXIgREVGQVVMVF9SQkZfU0VRTlVNQkVSID0gTUFYSU5UIC0gMjtcbmNvbnN0IFNFUVVFTkNFX0xPQ0tUSU1FX0RJU0FCTEVfRkxBRyA9ICBNYXRoLnBvdygyLDMxKTsgLy8gKDEgPDwgMzEpO1xuY29uc3QgU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHID0gTWF0aC5wb3coMiwyMik7IC8vICgxIDw8IDIyKTtcbmNvbnN0IFNFUVVFTkNFX0xPQ0tUSU1FX01BU0sgPSAweGZmZmY7XG5jb25zdCBTRVFVRU5DRV9MT0NLVElNRV9HUkFOVUxBUklUWSA9IDUxMjsgLy8gNTEyIHNlY29uZHNcbmNvbnN0IFNFUVVFTkNFX0JMT0NLRElGRl9MSU1JVCA9IE1hdGgucG93KDIsMTYpLTE7IC8vIDE2IGJpdHMgXG5cblxuZnVuY3Rpb24gSW5wdXQocGFyYW1zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnB1dCkpIHtcbiAgICByZXR1cm4gbmV3IElucHV0KHBhcmFtcyk7XG4gIH1cbiAgaWYgKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLl9mcm9tT2JqZWN0KHBhcmFtcyk7XG4gIH1cbn1cblxuSW5wdXQuTUFYSU5UID0gTUFYSU5UO1xuSW5wdXQuREVGQVVMVF9TRVFOVU1CRVIgPSBERUZBVUxUX1NFUU5VTUJFUjtcbklucHV0LkRFRkFVTFRfTE9DS1RJTUVfU0VRTlVNQkVSID0gREVGQVVMVF9MT0NLVElNRV9TRVFOVU1CRVI7XG5JbnB1dC5ERUZBVUxUX1JCRl9TRVFOVU1CRVIgPSBERUZBVUxUX1JCRl9TRVFOVU1CRVI7XG5JbnB1dC5TRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcgPSBTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dC5wcm90b3R5cGUsICdzY3JpcHQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NjcmlwdCkge1xuICAgICAgdGhpcy5fc2NyaXB0ID0gbmV3IFNjcmlwdCh0aGlzLl9zY3JpcHRCdWZmZXIpO1xuICAgICAgdGhpcy5fc2NyaXB0Ll9pc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NjcmlwdDtcbiAgfVxufSk7XG5cbklucHV0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3Qob2JqKSk7XG4gIHZhciBpbnB1dCA9IG5ldyBJbnB1dCgpO1xuICByZXR1cm4gaW5wdXQuX2Zyb21PYmplY3Qob2JqKTtcbn07XG5cbklucHV0LnByb3RvdHlwZS5fZnJvbU9iamVjdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcHJldlR4SWQ7XG4gIGlmICh0eXBlb2YgcGFyYW1zLnByZXZUeElkID09PSAnc3RyaW5nJyAmJiBKU1V0aWwuaXNIZXhhKHBhcmFtcy5wcmV2VHhJZCkpIHtcbiAgICBwcmV2VHhJZCA9IEJ1ZmZlci5mcm9tKHBhcmFtcy5wcmV2VHhJZCwgJ2hleCcpO1xuICB9IGVsc2Uge1xuICAgIHByZXZUeElkID0gcGFyYW1zLnByZXZUeElkO1xuICB9XG4gIHRoaXMud2l0bmVzc2VzID0gW107XG4gIHRoaXMub3V0cHV0ID0gcGFyYW1zLm91dHB1dCA/XG4gICAgKHBhcmFtcy5vdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQgPyBwYXJhbXMub3V0cHV0IDogbmV3IE91dHB1dChwYXJhbXMub3V0cHV0KSkgOiB1bmRlZmluZWQ7XG4gIHRoaXMucHJldlR4SWQgPSBwcmV2VHhJZCB8fCBwYXJhbXMudHhpZGJ1ZjtcbiAgdGhpcy5vdXRwdXRJbmRleCA9IHBhcmFtcy5vdXRwdXRJbmRleCA9PSBudWxsID8gcGFyYW1zLnR4b3V0bnVtIDogcGFyYW1zLm91dHB1dEluZGV4O1xuICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gcGFyYW1zLnNlcXVlbmNlTnVtYmVyID09IG51bGwgP1xuICAgIChwYXJhbXMuc2VxbnVtID09IG51bGwgPyBERUZBVUxUX1NFUU5VTUJFUiA6IHBhcmFtcy5zZXFudW0pIDogcGFyYW1zLnNlcXVlbmNlTnVtYmVyO1xuICAvLyBudWxsIHNjcmlwdCBpcyBhbGxvd2VkIGluIHNldFNjcmlwdCgpXG4gIGlmIChwYXJhbXMuc2NyaXB0ID09PSB1bmRlZmluZWQgJiYgcGFyYW1zLnNjcmlwdEJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5JbnB1dC5NaXNzaW5nU2NyaXB0KCk7XG4gIH1cbiAgdGhpcy5zZXRTY3JpcHQocGFyYW1zLnNjcmlwdEJ1ZmZlciB8fCBwYXJhbXMuc2NyaXB0KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUudG9PYmplY3QgPSBJbnB1dC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHZhciBvYmogPSB7XG4gICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQudG9TdHJpbmcoJ2hleCcpLFxuICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxuICAgIHNlcXVlbmNlTnVtYmVyOiB0aGlzLnNlcXVlbmNlTnVtYmVyLFxuICAgIHNjcmlwdDogdGhpcy5fc2NyaXB0QnVmZmVyLnRvU3RyaW5nKCdoZXgnKSxcbiAgfTtcbiAgLy8gYWRkIGh1bWFuIHJlYWRhYmxlIGZvcm0gaWYgaW5wdXQgY29udGFpbnMgdmFsaWQgc2NyaXB0XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIG9iai5zY3JpcHRTdHJpbmcgPSB0aGlzLnNjcmlwdC50b1N0cmluZygpO1xuICB9XG4gIGlmICh0aGlzLm91dHB1dCkge1xuICAgIG9iai5vdXRwdXQgPSB0aGlzLm91dHB1dC50b09iamVjdCgpO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG5JbnB1dC5mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24oYnIpIHtcbiAgdmFyIGlucHV0ID0gbmV3IElucHV0KCk7XG4gIGlucHV0LnByZXZUeElkID0gYnIucmVhZFJldmVyc2UoMzIpO1xuICBpbnB1dC5vdXRwdXRJbmRleCA9IGJyLnJlYWRVSW50MzJMRSgpO1xuICBpbnB1dC5fc2NyaXB0QnVmZmVyID0gYnIucmVhZFZhckxlbmd0aEJ1ZmZlcigpO1xuICBpbnB1dC5zZXF1ZW5jZU51bWJlciA9IGJyLnJlYWRVSW50MzJMRSgpO1xuICAvLyBUT0RPOiByZXR1cm4gZGlmZmVyZW50IGNsYXNzZXMgYWNjb3JkaW5nIHRvIHdoaWNoIGlucHV0IGl0IGlzXG4gIC8vIGUuZzogQ29pbmJhc2VJbnB1dCwgUHVibGljS2V5SGFzaElucHV0LCBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dCwgZXRjLlxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUudG9CdWZmZXJXcml0ZXIgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgaWYgKCF3cml0ZXIpIHtcbiAgICB3cml0ZXIgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gIH1cbiAgd3JpdGVyLndyaXRlUmV2ZXJzZSh0aGlzLnByZXZUeElkKTtcbiAgd3JpdGVyLndyaXRlVUludDMyTEUodGhpcy5vdXRwdXRJbmRleCk7XG4gIHZhciBzY3JpcHQgPSB0aGlzLl9zY3JpcHRCdWZmZXI7XG4gIHdyaXRlci53cml0ZVZhcmludE51bShzY3JpcHQubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKHNjcmlwdCk7XG4gIHdyaXRlci53cml0ZVVJbnQzMkxFKHRoaXMuc2VxdWVuY2VOdW1iZXIpO1xuICByZXR1cm4gd3JpdGVyO1xufTtcblxuSW5wdXQucHJvdG90eXBlLnNldFNjcmlwdCA9IGZ1bmN0aW9uKHNjcmlwdCkge1xuICB0aGlzLl9zY3JpcHQgPSBudWxsO1xuICBpZiAoc2NyaXB0IGluc3RhbmNlb2YgU2NyaXB0KSB7XG4gICAgdGhpcy5fc2NyaXB0ID0gc2NyaXB0O1xuICAgIHRoaXMuX3NjcmlwdC5faXNJbnB1dCA9IHRydWU7XG4gICAgdGhpcy5fc2NyaXB0QnVmZmVyID0gc2NyaXB0LnRvQnVmZmVyKCk7XG4gIH0gZWxzZSBpZiAoSlNVdGlsLmlzSGV4YShzY3JpcHQpKSB7XG4gICAgLy8gaGV4IHN0cmluZyBzY3JpcHRcbiAgICB0aGlzLl9zY3JpcHRCdWZmZXIgPSBCdWZmZXIuZnJvbShzY3JpcHQsICdoZXgnKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHNjcmlwdCkpIHtcbiAgICAvLyBodW1hbiByZWFkYWJsZSBzdHJpbmcgc2NyaXB0XG4gICAgdGhpcy5fc2NyaXB0ID0gbmV3IFNjcmlwdChzY3JpcHQpO1xuICAgIHRoaXMuX3NjcmlwdC5faXNJbnB1dCA9IHRydWU7XG4gICAgdGhpcy5fc2NyaXB0QnVmZmVyID0gdGhpcy5fc2NyaXB0LnRvQnVmZmVyKCk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyVXRpbC5pc0J1ZmZlcihzY3JpcHQpKSB7XG4gICAgLy8gYnVmZmVyIHNjcmlwdFxuICAgIHRoaXMuX3NjcmlwdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNjcmlwdCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCB0eXBlOiBzY3JpcHQnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0cmlldmUgc2lnbmF0dXJlcyBmb3IgdGhlIHByb3ZpZGVkIFByaXZhdGVLZXkuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVLZXkgLSB0aGUgcHJpdmF0ZSBrZXkgdG8gdXNlIHdoZW4gc2lnbmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0SW5kZXggLSB0aGUgaW5kZXggb2YgdGhpcyBpbnB1dCBpbiB0aGUgcHJvdmlkZWQgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWdUeXBlIC0gZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYWRkcmVzc0hhc2ggLSBpZiBwcm92aWRlZCwgZG9uJ3QgY2FsY3VsYXRlIHRoZSBoYXNoIG9mIHRoZVxuICogICAgIHB1YmxpYyBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcml2YXRlIGtleSBwcm92aWRlZFxuICogQGFic3RyYWN0XG4gKi9cbklucHV0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBlcnJvcnMuQWJzdHJhY3RNZXRob2RJbnZva2VkKFxuICAgICdUcnlpbmcgdG8gc2lnbiB1bnN1cHBvcnRlZCBvdXRwdXQgdHlwZSAob25seSBQMlBLSCBhbmQgUDJTSCBtdWx0aXNpZyBpbnB1dHMgYXJlIHN1cHBvcnRlZCknICtcbiAgICAnIGZvciBpbnB1dDogJyArIEpTT04uc3RyaW5naWZ5KHRoaXMpXG4gICk7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuZ2V0U2F0b3NoaXNCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgT3V0cHV0KTtcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0Ll9zYXRvc2hpc0JOKTtcbiAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKS53cml0ZVVJbnQ2NExFQk4odGhpcy5vdXRwdXQuX3NhdG9zaGlzQk4pLnRvQnVmZmVyKCk7XG59O1xuXG5cbklucHV0LnByb3RvdHlwZS5pc0Z1bGx5U2lnbmVkID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBlcnJvcnMuQWJzdHJhY3RNZXRob2RJbnZva2VkKCdJbnB1dCNpc0Z1bGx5U2lnbmVkJyk7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuaXNGaW5hbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zZXF1ZW5jZU51bWJlciAhPT0gSW5wdXQuTUFYSU5UO1xufTtcblxuSW5wdXQucHJvdG90eXBlLmFkZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgZXJyb3JzLkFic3RyYWN0TWV0aG9kSW52b2tlZCgnSW5wdXQjYWRkU2lnbmF0dXJlJyk7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBlcnJvcnMuQWJzdHJhY3RNZXRob2RJbnZva2VkKCdJbnB1dCNjbGVhclNpZ25hdHVyZXMnKTtcbn07XG5cbklucHV0LnByb3RvdHlwZS5oYXNXaXRuZXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMud2l0bmVzc2VzICYmIHRoaXMud2l0bmVzc2VzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuZ2V0V2l0bmVzc2VzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndpdG5lc3Nlcztcbn07XG5cbklucHV0LnByb3RvdHlwZS5zZXRXaXRuZXNzZXMgPSBmdW5jdGlvbih3aXRuZXNzZXMpIHtcbiAgdGhpcy53aXRuZXNzZXMgPSB3aXRuZXNzZXM7XG59O1xuXG5JbnB1dC5wcm90b3R5cGUuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcbiAgLy8gRklYTUU6IFJlZmFjdG9yIHNpZ25hdHVyZSBzbyB0aGlzIGlzIG5vdCBuZWNlc3NhcnlcbiAgc2lnbmF0dXJlLnNpZ25hdHVyZS5uaGFzaHR5cGUgPSBzaWduYXR1cmUuc2lndHlwZTtcbiAgcmV0dXJuIFNpZ2hhc2gudmVyaWZ5KFxuICAgIHRyYW5zYWN0aW9uLFxuICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgc2lnbmF0dXJlLnB1YmxpY0tleSxcbiAgICBzaWduYXR1cmUuaW5wdXRJbmRleCxcbiAgICB0aGlzLm91dHB1dC5zY3JpcHRcbiAgKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgY29pbmJhc2UgaW5wdXQgKHJlcHJlc2VudHMgbm8gaW5wdXQpXG4gKi9cbklucHV0LnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucHJldlR4SWQudG9TdHJpbmcoJ2hleCcpID09PSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgJiZcbiAgICB0aGlzLm91dHB1dEluZGV4ID09PSAweGZmZmZmZmZmO1xufTtcblxuSW5wdXQucHJvdG90eXBlLl9lc3RpbWF0ZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXJXcml0ZXIoKS50b0J1ZmZlcigpLmxlbmd0aDtcbn07XG5cbklucHV0LnByb3RvdHlwZS5fZ2V0QmFzZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDMyICsgNCArIDQ7IC8vIG91dHBvaW50ICgzMiArIDQpICsgc2VxdWVuY2UgKDQpXG59O1xuXG5cbi8qKlxuICogU2V0cyBzZXF1ZW5jZSBudW1iZXIgc28gdGhhdCB0cmFuc2FjdGlvbiBpcyBub3QgdmFsaWQgdW50aWwgdGhlIGRlc2lyZWQgc2Vjb25kc1xuICogIHNpbmNlIHRoZSB0cmFuc2FjdGlvbiBpcyBtaW5lZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGluIHNlY29uZHNcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzXG4gKi9cbklucHV0LnByb3RvdHlwZS5sb2NrRm9yU2Vjb25kcyA9IGZ1bmN0aW9uKHNlY29uZHMpIHtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNOdW1iZXIoc2Vjb25kcykpO1xuICBpZiAoc2Vjb25kcyA8IDAgfHwgIHNlY29uZHMgPj0gU0VRVUVOQ0VfTE9DS1RJTUVfR1JBTlVMQVJJVFkgKiBTRVFVRU5DRV9MT0NLVElNRV9NQVNLKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5JbnB1dC5Mb2NrVGltZVJhbmdlKCk7XG4gIH1cbiAgc2Vjb25kcyA9IHBhcnNlSW50KE1hdGguZmxvb3Ioc2Vjb25kcyAvIFNFUVVFTkNFX0xPQ0tUSU1FX0dSQU5VTEFSSVRZKSk7XG5cbiAgLy8gU0VRVUVOQ0VfTE9DS1RJTUVfRElTQUJMRV9GTEFHID0gMSBcbiAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IHNlY29uZHMgfCBTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcgO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBzZXF1ZW5jZSBudW1iZXIgc28gdGhhdCB0cmFuc2FjdGlvbiBpcyBub3QgdmFsaWQgdW50aWwgdGhlIGRlc2lyZWQgYmxvY2sgaGVpZ2h0IGRpZmZlcm5lY2Ugc2luY2UgdGhlIHR4IGlzIG1pbmVkXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcbiAqL1xuSW5wdXQucHJvdG90eXBlLmxvY2tVbnRpbEJsb2NrSGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0RGlmZikge1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc051bWJlcihoZWlnaHREaWZmKSk7XG4gIGlmIChoZWlnaHREaWZmIDwgMCB8fCBoZWlnaHREaWZmID49IFNFUVVFTkNFX0JMT0NLRElGRl9MSU1JVCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW5wdXQuQmxvY2tIZWlnaHRPdXRPZlJhbmdlKCk7XG4gIH1cbiAgLy8gU0VRVUVOQ0VfTE9DS1RJTUVfVFlQRV9GTEFHID0gMFxuICAvLyBTRVFVRU5DRV9MT0NLVElNRV9ESVNBQkxFX0ZMQUcgPSAwXG4gIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSBoZWlnaHREaWZmIDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogIFJldHVybnMgYSBzZW1hbnRpYyB2ZXJzaW9uIG9mIHRoZSBpbnB1dCdzIHNlcXVlbmNlIG5Mb2NrVGltZS5cbiAqICBAcmV0dXJuIHtOdW1iZXJ8RGF0ZX1cbiAqICBJZiBzZXF1ZW5jZSBsb2NrIGlzIGRpc2FibGVkICBpdCByZXR1cm5zIG51bGwsXG4gKiAgaWYgaXMgc2V0IHRvIGJsb2NrIGhlaWdodCBsb2NrLCByZXR1cm5zIGEgYmxvY2sgaGVpZ2h0IChudW1iZXIpXG4gKiAgZWxzZSBpdCByZXR1cm5zIGEgRGF0ZSBvYmplY3QuXG4gKi9cbklucHV0LnByb3RvdHlwZS5nZXRMb2NrVGltZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zZXF1ZW5jZU51bWJlciAmIFNFUVVFTkNFX0xPQ0tUSU1FX0RJU0FCTEVfRkxBRykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuc2VxdWVuY2VOdW1iZXIgJiBTRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcpIHtcbiAgICB2YXIgc2Vjb25kcyA9IFNFUVVFTkNFX0xPQ0tUSU1FX0dSQU5VTEFSSVRZICogKHRoaXMuc2VxdWVuY2VOdW1iZXIgJiBTRVFVRU5DRV9MT0NLVElNRV9NQVNLKTtcbiAgICByZXR1cm4gc2Vjb25kcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmxvY2tIZWlnaHQgPSB0aGlzLnNlcXVlbmNlTnVtYmVyICYgU0VRVUVOQ0VfTE9DS1RJTUVfTUFTSztcbiAgICByZXR1cm4gYmxvY2tIZWlnaHQ7XG4gIH1cbn07XG5cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gSW5wdXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisig.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/multisig.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\nvar Transaction = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js\");\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar PublicKey = __webpack_require__(/*! ../../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\n\n/**\n * @constructor\n */\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),\n    'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n  _.each(this.publicKeys, function(publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function(signatures) {\n  return _.map(signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function() {\n  return _.map(this.signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\n/**\n * Get signatures for this input\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer} merkleRoot - unused for this input type\n * @return {Array<TransactionSignature>}\n */\nMultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  const results = [];\n  for (const publicKey of this.publicKeys || []) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\n        sigtype: sigtype\n      }));\n    }\n  }\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()], \"Signature Undefined\"),\n    'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), \"Invalid Signature\");\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function() {\n  this.setScript(Script.buildMultisigIn(\n    this.publicKeys,\n    this.threshold,\n    this._createSignatures()\n  ));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function() {\n  return _.map(\n    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),\n    // Future signature types may need refactor of toDER\n    function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    }\n  );\n};\n\nMultiSigInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function() {\n  return _.reduce(this.signatures, function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function() {\n  var self = this;\n  return _.filter(this.publicKeys, function(publicKey) {\n    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script\n  );\n};\n\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @returns {TransactionSignature[]}\n */\nMultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(\n          transaction,\n          signature.signature,\n          signature.publicKey,\n          signature.inputIndex,\n          input.output.script\n      );\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function() {\n  return this._getBaseSize() + MultiSigInput.OPCODES_SIZE +\n    this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L211bHRpc2lnLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixlQUFlLG1CQUFPLENBQUMsb0ZBQVU7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsdUZBQWdCO0FBQzFDLFlBQVksbUJBQU8sQ0FBQyxnRkFBUztBQUM3QixhQUFhLG1CQUFPLENBQUMsNkVBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLDRGQUEwQjs7QUFFMUMsYUFBYSxtQkFBTyxDQUFDLDBFQUFjO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHdGQUF3QjtBQUNoRCxjQUFjLG1CQUFPLENBQUMsK0VBQVk7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjtBQUM1QywyQkFBMkIsbUJBQU8sQ0FBQyxtRkFBYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhEQUE4RCxtQ0FBbUM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDhCQUE4QjtBQUM5RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsbUNBQW1DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsZ0NBQWdDO0FBQ2hDLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvbXVsdGlzaWcuanM/YWRjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi4vdHJhbnNhY3Rpb24nKTtcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuLi9vdXRwdXQnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG5cbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9zY3JpcHQnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi8uLi9jcnlwdG8vc2lnbmF0dXJlJyk7XG52YXIgU2lnaGFzaCA9IHJlcXVpcmUoJy4uL3NpZ2hhc2gnKTtcbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuLi8uLi9wdWJsaWNrZXknKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9idWZmZXInKTtcbnZhciBUcmFuc2FjdGlvblNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL3NpZ25hdHVyZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNdWx0aVNpZ0lucHV0KGlucHV0LCBwdWJrZXlzLCB0aHJlc2hvbGQsIHNpZ25hdHVyZXMsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcHVia2V5cyA9IHB1YmtleXMgfHwgaW5wdXQucHVibGljS2V5cztcbiAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IGlucHV0LnRocmVzaG9sZDtcbiAgc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXMgfHwgaW5wdXQuc2lnbmF0dXJlcztcbiAgaWYgKG9wdHMubm9Tb3J0aW5nKSB7XG4gICAgdGhpcy5wdWJsaWNLZXlzID0gcHVia2V5c1xuICB9IGVsc2UgIHtcbiAgICB0aGlzLnB1YmxpY0tleXMgPSBfLnNvcnRCeShwdWJrZXlzLCBmdW5jdGlvbihwdWJsaWNLZXkpIHsgcmV0dXJuIHB1YmxpY0tleS50b1N0cmluZygnaGV4Jyk7IH0pO1xuICB9XG4gICQuY2hlY2tTdGF0ZShTY3JpcHQuYnVpbGRNdWx0aXNpZ091dCh0aGlzLnB1YmxpY0tleXMsIHRocmVzaG9sZCkuZXF1YWxzKHRoaXMub3V0cHV0LnNjcmlwdCksXG4gICAgJ1Byb3ZpZGVkIHB1YmxpYyBrZXlzIGRvblxcJ3QgbWF0Y2ggdG8gdGhlIHByb3ZpZGVkIG91dHB1dCBzY3JpcHQnKTtcbiAgdGhpcy5wdWJsaWNLZXlJbmRleCA9IHt9O1xuICBfLmVhY2godGhpcy5wdWJsaWNLZXlzLCBmdW5jdGlvbihwdWJsaWNLZXksIGluZGV4KSB7XG4gICAgc2VsZi5wdWJsaWNLZXlJbmRleFtwdWJsaWNLZXkudG9TdHJpbmcoKV0gPSBpbmRleDtcbiAgfSk7XG4gIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAvLyBFbXB0eSBhcnJheSBvZiBzaWduYXR1cmVzXG4gIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXMgPyB0aGlzLl9kZXNlcmlhbGl6ZVNpZ25hdHVyZXMoc2lnbmF0dXJlcykgOiBuZXcgQXJyYXkodGhpcy5wdWJsaWNLZXlzLmxlbmd0aCk7XG59XG5pbmhlcml0cyhNdWx0aVNpZ0lucHV0LCBJbnB1dCk7XG5cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvYmogPSBJbnB1dC5wcm90b3R5cGUudG9PYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgb2JqLnRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkO1xuICBvYmoucHVibGljS2V5cyA9IF8ubWFwKHRoaXMucHVibGljS2V5cywgZnVuY3Rpb24ocHVibGljS2V5KSB7IHJldHVybiBwdWJsaWNLZXkudG9TdHJpbmcoKTsgfSk7XG4gIG9iai5zaWduYXR1cmVzID0gdGhpcy5fc2VyaWFsaXplU2lnbmF0dXJlcygpO1xuICByZXR1cm4gb2JqO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuX2Rlc2VyaWFsaXplU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKHNpZ25hdHVyZXMpIHtcbiAgcmV0dXJuIF8ubWFwKHNpZ25hdHVyZXMsIGZ1bmN0aW9uKHNpZ25hdHVyZSkge1xuICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIH0pO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuX3NlcmlhbGl6ZVNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8ubWFwKHRoaXMuc2lnbmF0dXJlcywgZnVuY3Rpb24oc2lnbmF0dXJlKSB7XG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzaWduYXR1cmUudG9PYmplY3QoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBzaWduYXR1cmVzIGZvciB0aGlzIGlucHV0XG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAtIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBzaWduZWRcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSB3aXRoIHdoaWNoIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGlucHV0IGluIHRoZSB0cmFuc2FjdGlvbiBpbnB1dCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWd0eXBlIC0gdGhlIHR5cGUgb2Ygc2lnbmF0dXJlLCBkZWZhdWx0cyB0byBTaWduYXR1cmUuU0lHSEFTSF9BTExcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoRGF0YSAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCBERVBSRUNBVEVEIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVya2xlUm9vdCAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLmdldFNpZ25hdHVyZXMgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgaW5kZXgsIHNpZ3R5cGUsIGhhc2hEYXRhLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLm91dHB1dCBpbnN0YW5jZW9mIE91dHB1dCk7XG4gIHNpZ3R5cGUgPSBzaWd0eXBlIHx8IFNpZ25hdHVyZS5TSUdIQVNIX0FMTDtcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcblxuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAoY29uc3QgcHVibGljS2V5IG9mIHRoaXMucHVibGljS2V5cyB8fCBbXSkge1xuICAgIGlmIChwdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHJpdmF0ZUtleS5wdWJsaWNLZXkudG9TdHJpbmcoKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKG5ldyBUcmFuc2FjdGlvblNpZ25hdHVyZSh7XG4gICAgICAgIHB1YmxpY0tleTogcHJpdmF0ZUtleS5wdWJsaWNLZXksXG4gICAgICAgIHByZXZUeElkOiB0aGlzLnByZXZUeElkLFxuICAgICAgICBvdXRwdXRJbmRleDogdGhpcy5vdXRwdXRJbmRleCxcbiAgICAgICAgaW5wdXRJbmRleDogaW5kZXgsXG4gICAgICAgIHNpZ25hdHVyZTogU2lnaGFzaC5zaWduKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBzaWd0eXBlLCBpbmRleCwgdGhpcy5vdXRwdXQuc2NyaXB0KSxcbiAgICAgICAgc2lndHlwZTogc2lndHlwZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuYWRkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICAkLmNoZWNrU3RhdGUoIXRoaXMuaXNGdWxseVNpZ25lZCgpLCAnQWxsIG5lZWRlZCBzaWduYXR1cmVzIGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkJyk7XG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZCh0aGlzLnB1YmxpY0tleUluZGV4W3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKV0sIFwiU2lnbmF0dXJlIFVuZGVmaW5lZFwiKSxcbiAgICAnU2lnbmF0dXJlIGhhcyBubyBtYXRjaGluZyBwdWJsaWMga2V5Jyk7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLmlzVmFsaWRTaWduYXR1cmUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCksIFwiSW52YWxpZCBTaWduYXR1cmVcIik7XG4gIHRoaXMuc2lnbmF0dXJlc1t0aGlzLnB1YmxpY0tleUluZGV4W3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKV1dID0gc2lnbmF0dXJlO1xuICB0aGlzLl91cGRhdGVTY3JpcHQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5fdXBkYXRlU2NyaXB0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2V0U2NyaXB0KFNjcmlwdC5idWlsZE11bHRpc2lnSW4oXG4gICAgdGhpcy5wdWJsaWNLZXlzLFxuICAgIHRoaXMudGhyZXNob2xkLFxuICAgIHRoaXMuX2NyZWF0ZVNpZ25hdHVyZXMoKVxuICApKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5fY3JlYXRlU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXy5tYXAoXG4gICAgXy5maWx0ZXIodGhpcy5zaWduYXR1cmVzLCBmdW5jdGlvbihzaWduYXR1cmUpIHsgcmV0dXJuICFfLmlzVW5kZWZpbmVkKHNpZ25hdHVyZSk7IH0pLFxuICAgIC8vIEZ1dHVyZSBzaWduYXR1cmUgdHlwZXMgbWF5IG5lZWQgcmVmYWN0b3Igb2YgdG9ERVJcbiAgICBmdW5jdGlvbihzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiBCdWZmZXJVdGlsLmNvbmNhdChbXG4gICAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9ERVIoKSxcbiAgICAgICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ25hdHVyZS5zaWd0eXBlKVxuICAgICAgXSk7XG4gICAgfVxuICApO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2lnbmF0dXJlcyA9IG5ldyBBcnJheSh0aGlzLnB1YmxpY0tleXMubGVuZ3RoKTtcbiAgdGhpcy5fdXBkYXRlU2NyaXB0KCk7XG59O1xuXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5pc0Z1bGx5U2lnbmVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvdW50U2lnbmF0dXJlcygpID09PSB0aGlzLnRocmVzaG9sZDtcbn07XG5cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLmNvdW50TWlzc2luZ1NpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGhyZXNob2xkIC0gdGhpcy5jb3VudFNpZ25hdHVyZXMoKTtcbn07XG5cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLmNvdW50U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXy5yZWR1Y2UodGhpcy5zaWduYXR1cmVzLCBmdW5jdGlvbihzdW0sIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBzdW0gKyAoISFzaWduYXR1cmUpO1xuICB9LCAwKTtcbn07XG5cbk11bHRpU2lnSW5wdXQucHJvdG90eXBlLnB1YmxpY0tleXNXaXRob3V0U2lnbmF0dXJlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIF8uZmlsdGVyKHRoaXMucHVibGljS2V5cywgZnVuY3Rpb24ocHVibGljS2V5KSB7XG4gICAgcmV0dXJuICEoc2VsZi5zaWduYXR1cmVzW3NlbGYucHVibGljS2V5SW5kZXhbcHVibGljS2V5LnRvU3RyaW5nKCldXSk7XG4gIH0pO1xufTtcblxuTXVsdGlTaWdJbnB1dC5wcm90b3R5cGUuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcbiAgc2lnbmluZ01ldGhvZCA9IHNpZ25pbmdNZXRob2QgfHwgJ2VjZHNhJzsgLy8gdW51c2VkLiBLZWVwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGxpYnNcbiAgLy8gRklYTUU6IFJlZmFjdG9yIHNpZ25hdHVyZSBzbyB0aGlzIGlzIG5vdCBuZWNlc3NhcnlcbiAgc2lnbmF0dXJlLnNpZ25hdHVyZS5uaGFzaHR5cGUgPSBzaWduYXR1cmUuc2lndHlwZTtcbiAgcmV0dXJuIFNpZ2hhc2gudmVyaWZ5KFxuICAgIHRyYW5zYWN0aW9uLFxuICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgc2lnbmF0dXJlLnB1YmxpY0tleSxcbiAgICBzaWduYXR1cmUuaW5wdXRJbmRleCxcbiAgICB0aGlzLm91dHB1dC5zY3JpcHRcbiAgKTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IHNpZ25hdHVyZXNcbiAqIEBwYXJhbSB7UHVibGljS2V5W119IHB1YmxpY0tleXNcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGlucHV0SW5kZXhcbiAqIEBwYXJhbSB7SW5wdXR9IGlucHV0XG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCBERVBSRUNBVEVEIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInIChmdXR1cmUgc2lnbmluZyBtZXRob2QpXG4gKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TaWduYXR1cmVbXX1cbiAqL1xuTXVsdGlTaWdJbnB1dC5ub3JtYWxpemVTaWduYXR1cmVzID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIGlucHV0LCBpbnB1dEluZGV4LCBzaWduYXR1cmVzLCBwdWJsaWNLZXlzLCBzaWduaW5nTWV0aG9kKSB7XG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXG5cbiAgcmV0dXJuIHB1YmxpY0tleXMubWFwKGZ1bmN0aW9uIChwdWJLZXkpIHtcbiAgICB2YXIgc2lnbmF0dXJlTWF0Y2ggPSBudWxsO1xuICAgIHNpZ25hdHVyZXMgPSBzaWduYXR1cmVzLmZpbHRlcihmdW5jdGlvbiAoc2lnbmF0dXJlQnVmZmVyKSB7XG4gICAgICBpZiAoc2lnbmF0dXJlTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaWduYXR1cmUgPSBuZXcgVHJhbnNhY3Rpb25TaWduYXR1cmUoe1xuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tVHhGb3JtYXQoc2lnbmF0dXJlQnVmZmVyKSxcbiAgICAgICAgcHVibGljS2V5OiBwdWJLZXksXG4gICAgICAgIHByZXZUeElkOiBpbnB1dC5wcmV2VHhJZCxcbiAgICAgICAgb3V0cHV0SW5kZXg6IGlucHV0Lm91dHB1dEluZGV4LFxuICAgICAgICBpbnB1dEluZGV4OiBpbnB1dEluZGV4LFxuICAgICAgICBzaWd0eXBlOiBTaWduYXR1cmUuU0lHSEFTSF9BTExcbiAgICAgIH0pO1xuXG4gICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLm5oYXNodHlwZSA9IHNpZ25hdHVyZS5zaWd0eXBlO1xuICAgICAgdmFyIGlzTWF0Y2ggPSBTaWdoYXNoLnZlcmlmeShcbiAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxuICAgICAgICAgIHNpZ25hdHVyZS5wdWJsaWNLZXksXG4gICAgICAgICAgc2lnbmF0dXJlLmlucHV0SW5kZXgsXG4gICAgICAgICAgaW5wdXQub3V0cHV0LnNjcmlwdFxuICAgICAgKTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgc2lnbmF0dXJlTWF0Y2ggPSBzaWduYXR1cmU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2lnbmF0dXJlTWF0Y2ggPyBzaWduYXR1cmVNYXRjaCA6IG51bGw7XG4gIH0pO1xufTtcblxuTXVsdGlTaWdJbnB1dC5PUENPREVTX1NJWkUgPSAxOyAvLyAwXG5NdWx0aVNpZ0lucHV0LlNJR05BVFVSRV9TSVpFID0gNzM7IC8vIHNpemUgKDEpICsgREVSICg8PTcyKVxuXG5NdWx0aVNpZ0lucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nZXRCYXNlU2l6ZSgpICsgTXVsdGlTaWdJbnB1dC5PUENPREVTX1NJWkUgK1xuICAgIHRoaXMudGhyZXNob2xkICogTXVsdGlTaWdJbnB1dC5TSUdOQVRVUkVfU0laRTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGlTaWdJbnB1dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js":
/*!******************************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* jshint maxparams:5 */\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar Address = __webpack_require__(/*! ../../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar SighashWitness = __webpack_require__(/*! ../sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\nvar BufferWriter = __webpack_require__(/*! ../../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\n\n/**\n * @constructor\n */\nfunction MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {\n  /* jshint maxstatements:20 */\n  opts = opts || {};\n  Input.apply(this, arguments);\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys;\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);\n  var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);\n  if (nested.equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToWitnessScriptHash;\n  } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {\n    this.nestedWitness = true;\n    this.type = Address.PayToScriptHash;\n  } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToScriptHash;\n  } else {\n    throw new Error('Provided public keys don\\'t hash to the provided output');\n  }\n\n  if (this.nestedWitness) {\n    var scriptSig = new Script();\n    scriptSig.add(nested.toBuffer());\n    this.setScript(scriptSig);\n  }\n\n  this.publicKeyIndex = {};\n  for (let index = 0; index < this.publicKeys.length; index++) {\n    const publicKey = this.publicKeys[index];\n    this.publicKeyIndex[publicKey.toString()] = index;\n  }\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigScriptHashInput, Input);\n\nMultiSigScriptHashInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = this.publicKeys.map(function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {\n  return signatures.map(function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigScriptHashInput.prototype._serializeSignatures = function() {\n  return this.signatures.map(function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\nMultiSigScriptHashInput.prototype.getScriptCode = function() {\n  var writer = new BufferWriter();\n  if (!this.redeemScript.hasCodeseparators()) {\n    var redeemScriptBuffer = this.redeemScript.toBuffer();\n    writer.writeVarintNum(redeemScriptBuffer.length);\n    writer.write(redeemScriptBuffer);\n  } else {\n    throw new Error('@TODO');\n  }\n  return writer.toBuffer();\n};\n\nMultiSigScriptHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\n  var hash;\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    hash = SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n  } else  {\n    hash = Sighash.sighash(transaction, sigtype, index, this.redeemScript);\n  }\n  return hash;\n};\n\n/**\n * Get signatures for this input\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer} merkleRoot - unused for this input type\n * @return {Array<TransactionSignature>}\n */\nMultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  const results = [];\n  for (const publicKey of this.publicKeys) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      var signature;\n      if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n        var scriptCode = this.getScriptCode();\n        var satoshisBuffer = this.getSatoshisBuffer();\n        signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer);\n      } else  {\n        signature = Sighash.sign(transaction, privateKey, sigtype, index, this.redeemScript);\n      }\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: signature,\n        sigtype: sigtype\n      }));\n    }\n  }\n  return results;\n};\n\nMultiSigScriptHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] != null,\n                  'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Invalid Signature!');\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._updateScript = function() {\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    var stack = [\n      Buffer.alloc(0),\n    ];\n    var signatures = this._createSignatures();\n    for (var i = 0; i < signatures.length; i++) {\n      stack.push(signatures[i]);\n    }\n    stack.push(this.redeemScript.toBuffer());\n    this.setWitnesses(stack);\n  } else {\n    var scriptSig = Script.buildP2SHMultisigIn(\n      this.publicKeys,\n      this.threshold,\n      this._createSignatures(),\n      { cachedMultisig: this.redeemScript }\n    );\n    this.setScript(scriptSig);\n  }\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._createSignatures = function() {\n  return this.signatures\n    .filter(function(signature) { return signature != null; })\n    .map(function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    });\n};\n\nMultiSigScriptHashInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigScriptHashInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigScriptHashInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigScriptHashInput.prototype.countSignatures = function() {\n  return this.signatures.reduce(function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {\n  return this.publicKeys.filter((publicKey) => {\n    return !(this.signatures[this.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    signature.signature.nhashtype = signature.sigtype;\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      scriptCode,\n      satoshisBuffer\n    );\n  } else {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      this.redeemScript\n    );\n  }\n};\n\nMultiSigScriptHashInput.MAX_OPCODES_SIZE = 8; // serialized size (<=3) + 0 .. OP_PUSHDATAx N .. M OP_CHECKMULTISIG\nMultiSigScriptHashInput.MAX_SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\nMultiSigScriptHashInput.MAX_PUBKEY_SIZE = 34; // size (1) + DER (<=33)\nMultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34; // OP_0 (1) + scriptHash (1 + 32)\n\nMultiSigScriptHashInput.prototype._estimateSize = function() {\n  let result = this._getBaseSize();\n  const WITNESS_DISCOUNT = 4;\n  const witnessSize = MultiSigScriptHashInput.MAX_OPCODES_SIZE +\n    this.threshold * MultiSigScriptHashInput.MAX_SIGNATURE_SIZE +\n    this.publicKeys.length * MultiSigScriptHashInput.MAX_PUBKEY_SIZE;\n  if (this.type === Address.PayToWitnessScriptHash) {\n    result += witnessSize / WITNESS_DISCOUNT;\n  } else if (this.nestedWitness) {\n    result += witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    result += witnessSize;\n  }\n  return result;\n};\n\nmodule.exports = MultiSigScriptHashInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L211bHRpc2lnc2NyaXB0aGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsZUFBZSxtQkFBTyxDQUFDLG9GQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxnRkFBUztBQUM3QixhQUFhLG1CQUFPLENBQUMsNkVBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLDRGQUEwQjs7QUFFMUMsY0FBYyxtQkFBTyxDQUFDLHNFQUFlO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQywwRUFBYztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBd0I7QUFDaEQsY0FBYyxtQkFBTyxDQUFDLCtFQUFZO0FBQ2xDLHFCQUFxQixtQkFBTyxDQUFDLDZGQUFtQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxrR0FBNkI7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsOEVBQW1CO0FBQzVDLDJCQUEyQixtQkFBTyxDQUFDLG1GQUFjOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOERBQThELG1DQUFtQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsOEJBQThCO0FBQzNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDLGlEQUFpRDtBQUNqRCw4Q0FBOEM7QUFDOUMsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L211bHRpc2lnc2NyaXB0aGFzaC5qcz9jMmNiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoganNoaW50IG1heHBhcmFtczo1ICovXG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xudmFyIE91dHB1dCA9IHJlcXVpcmUoJy4uL291dHB1dCcpO1xudmFyICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcblxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi8uLi9hZGRyZXNzJyk7XG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xudmFyIFNpZ2hhc2ggPSByZXF1aXJlKCcuLi9zaWdoYXNoJyk7XG52YXIgU2lnaGFzaFdpdG5lc3MgPSByZXF1aXJlKCcuLi9zaWdoYXNod2l0bmVzcycpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uLy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2J1ZmZlcicpO1xudmFyIFRyYW5zYWN0aW9uU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE11bHRpU2lnU2NyaXB0SGFzaElucHV0KGlucHV0LCBwdWJrZXlzLCB0aHJlc2hvbGQsIHNpZ25hdHVyZXMsIG9wdHMpIHtcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6MjAgKi9cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHB1YmtleXMgPSBwdWJrZXlzIHx8IGlucHV0LnB1YmxpY0tleXM7XG4gIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCBpbnB1dC50aHJlc2hvbGQ7XG4gIHNpZ25hdHVyZXMgPSBzaWduYXR1cmVzIHx8IGlucHV0LnNpZ25hdHVyZXM7XG4gIGlmIChvcHRzLm5vU29ydGluZykge1xuICAgIHRoaXMucHVibGljS2V5cyA9IHB1YmtleXM7XG4gIH0gZWxzZSAge1xuICAgIHRoaXMucHVibGljS2V5cyA9IF8uc29ydEJ5KHB1YmtleXMsIGZ1bmN0aW9uKHB1YmxpY0tleSkgeyByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKTsgfSk7XG4gIH1cbiAgdGhpcy5yZWRlZW1TY3JpcHQgPSBTY3JpcHQuYnVpbGRNdWx0aXNpZ091dCh0aGlzLnB1YmxpY0tleXMsIHRocmVzaG9sZCwgb3B0cyk7XG4gIHZhciBuZXN0ZWQgPSBTY3JpcHQuYnVpbGRXaXRuZXNzTXVsdGlzaWdPdXRGcm9tU2NyaXB0KHRoaXMucmVkZWVtU2NyaXB0KTtcbiAgaWYgKG5lc3RlZC5lcXVhbHModGhpcy5vdXRwdXQuc2NyaXB0KSkge1xuICAgIHRoaXMubmVzdGVkV2l0bmVzcyA9IGZhbHNlO1xuICAgIHRoaXMudHlwZSA9IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaDtcbiAgfSBlbHNlIGlmIChTY3JpcHQuYnVpbGRTY3JpcHRIYXNoT3V0KG5lc3RlZCkuZXF1YWxzKHRoaXMub3V0cHV0LnNjcmlwdCkpIHtcbiAgICB0aGlzLm5lc3RlZFdpdG5lc3MgPSB0cnVlO1xuICAgIHRoaXMudHlwZSA9IEFkZHJlc3MuUGF5VG9TY3JpcHRIYXNoO1xuICB9IGVsc2UgaWYgKFNjcmlwdC5idWlsZFNjcmlwdEhhc2hPdXQodGhpcy5yZWRlZW1TY3JpcHQpLmVxdWFscyh0aGlzLm91dHB1dC5zY3JpcHQpKSB7XG4gICAgdGhpcy5uZXN0ZWRXaXRuZXNzID0gZmFsc2U7XG4gICAgdGhpcy50eXBlID0gQWRkcmVzcy5QYXlUb1NjcmlwdEhhc2g7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBwdWJsaWMga2V5cyBkb25cXCd0IGhhc2ggdG8gdGhlIHByb3ZpZGVkIG91dHB1dCcpO1xuICB9XG5cbiAgaWYgKHRoaXMubmVzdGVkV2l0bmVzcykge1xuICAgIHZhciBzY3JpcHRTaWcgPSBuZXcgU2NyaXB0KCk7XG4gICAgc2NyaXB0U2lnLmFkZChuZXN0ZWQudG9CdWZmZXIoKSk7XG4gICAgdGhpcy5zZXRTY3JpcHQoc2NyaXB0U2lnKTtcbiAgfVxuXG4gIHRoaXMucHVibGljS2V5SW5kZXggPSB7fTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucHVibGljS2V5cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleXNbaW5kZXhdO1xuICAgIHRoaXMucHVibGljS2V5SW5kZXhbcHVibGljS2V5LnRvU3RyaW5nKCldID0gaW5kZXg7XG4gIH1cbiAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIC8vIEVtcHR5IGFycmF5IG9mIHNpZ25hdHVyZXNcbiAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmF0dXJlcyA/IHRoaXMuX2Rlc2VyaWFsaXplU2lnbmF0dXJlcyhzaWduYXR1cmVzKSA6IG5ldyBBcnJheSh0aGlzLnB1YmxpY0tleXMubGVuZ3RoKTtcbn1cbmluaGVyaXRzKE11bHRpU2lnU2NyaXB0SGFzaElucHV0LCBJbnB1dCk7XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb2JqID0gSW5wdXQucHJvdG90eXBlLnRvT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIG9iai50aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZDtcbiAgb2JqLnB1YmxpY0tleXMgPSB0aGlzLnB1YmxpY0tleXMubWFwKGZ1bmN0aW9uKHB1YmxpY0tleSkgeyByZXR1cm4gcHVibGljS2V5LnRvU3RyaW5nKCk7IH0pO1xuICBvYmouc2lnbmF0dXJlcyA9IHRoaXMuX3NlcmlhbGl6ZVNpZ25hdHVyZXMoKTtcbiAgcmV0dXJuIG9iajtcbn07XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5fZGVzZXJpYWxpemVTaWduYXR1cmVzID0gZnVuY3Rpb24oc2lnbmF0dXJlcykge1xuICByZXR1cm4gc2lnbmF0dXJlcy5tYXAoZnVuY3Rpb24oc2lnbmF0dXJlKSB7XG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgfSk7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuX3NlcmlhbGl6ZVNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlcy5tYXAoZnVuY3Rpb24oc2lnbmF0dXJlKSB7XG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzaWduYXR1cmUudG9PYmplY3QoKTtcbiAgfSk7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuZ2V0U2NyaXB0Q29kZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICBpZiAoIXRoaXMucmVkZWVtU2NyaXB0Lmhhc0NvZGVzZXBhcmF0b3JzKCkpIHtcbiAgICB2YXIgcmVkZWVtU2NyaXB0QnVmZmVyID0gdGhpcy5yZWRlZW1TY3JpcHQudG9CdWZmZXIoKTtcbiAgICB3cml0ZXIud3JpdGVWYXJpbnROdW0ocmVkZWVtU2NyaXB0QnVmZmVyLmxlbmd0aCk7XG4gICAgd3JpdGVyLndyaXRlKHJlZGVlbVNjcmlwdEJ1ZmZlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdAVE9ETycpO1xuICB9XG4gIHJldHVybiB3cml0ZXIudG9CdWZmZXIoKTtcbn07XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5nZXRTaWdoYXNoID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIGluZGV4LCBzaWd0eXBlKSB7XG4gIHZhciBoYXNoO1xuICBpZiAodGhpcy5uZXN0ZWRXaXRuZXNzIHx8IHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XG4gICAgdmFyIHNjcmlwdENvZGUgPSB0aGlzLmdldFNjcmlwdENvZGUoKTtcbiAgICB2YXIgc2F0b3NoaXNCdWZmZXIgPSB0aGlzLmdldFNhdG9zaGlzQnVmZmVyKCk7XG4gICAgaGFzaCA9IFNpZ2hhc2hXaXRuZXNzLnNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ3R5cGUsIGluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XG4gIH0gZWxzZSAge1xuICAgIGhhc2ggPSBTaWdoYXNoLnNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ3R5cGUsIGluZGV4LCB0aGlzLnJlZGVlbVNjcmlwdCk7XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59O1xuXG4vKipcbiAqIEdldCBzaWduYXR1cmVzIGZvciB0aGlzIGlucHV0XG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAtIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBzaWduZWRcbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIHRoZSBwcml2YXRlIGtleSB3aXRoIHdoaWNoIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGlucHV0IGluIHRoZSB0cmFuc2FjdGlvbiBpbnB1dCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWd0eXBlIC0gdGhlIHR5cGUgb2Ygc2lnbmF0dXJlLCBkZWZhdWx0cyB0byBTaWduYXR1cmUuU0lHSEFTSF9BTExcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoRGF0YSAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCBERVBSRUNBVEVEIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVya2xlUm9vdCAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVzID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIGluZGV4LCBzaWd0eXBlLCBoYXNoRGF0YSwgc2lnbmluZ01ldGhvZCwgbWVya2xlUm9vdCkge1xuICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQpO1xuICBzaWd0eXBlID0gc2lndHlwZSB8fCBTaWduYXR1cmUuU0lHSEFTSF9BTEw7XG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXG5cbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHB1YmxpY0tleSBvZiB0aGlzLnB1YmxpY0tleXMpIHtcbiAgICBpZiAocHVibGljS2V5LnRvU3RyaW5nKCkgPT09IHByaXZhdGVLZXkucHVibGljS2V5LnRvU3RyaW5nKCkpIHtcbiAgICAgIHZhciBzaWduYXR1cmU7XG4gICAgICBpZiAodGhpcy5uZXN0ZWRXaXRuZXNzIHx8IHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XG4gICAgICAgIHZhciBzY3JpcHRDb2RlID0gdGhpcy5nZXRTY3JpcHRDb2RlKCk7XG4gICAgICAgIHZhciBzYXRvc2hpc0J1ZmZlciA9IHRoaXMuZ2V0U2F0b3NoaXNCdWZmZXIoKTtcbiAgICAgICAgc2lnbmF0dXJlID0gU2lnaGFzaFdpdG5lc3Muc2lnbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgc2lndHlwZSwgaW5kZXgsIHNjcmlwdENvZGUsIHNhdG9zaGlzQnVmZmVyKTtcbiAgICAgIH0gZWxzZSAge1xuICAgICAgICBzaWduYXR1cmUgPSBTaWdoYXNoLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCB0aGlzLnJlZGVlbVNjcmlwdCk7XG4gICAgICB9XG4gICAgICByZXN1bHRzLnB1c2gobmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcbiAgICAgICAgcHVibGljS2V5OiBwcml2YXRlS2V5LnB1YmxpY0tleSxcbiAgICAgICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQsXG4gICAgICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxuICAgICAgICBpbnB1dEluZGV4OiBpbmRleCxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIHNpZ3R5cGU6IHNpZ3R5cGVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuYWRkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICAkLmNoZWNrU3RhdGUoIXRoaXMuaXNGdWxseVNpZ25lZCgpLCAnQWxsIG5lZWRlZCBzaWduYXR1cmVzIGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkJyk7XG4gICQuY2hlY2tBcmd1bWVudCh0aGlzLnB1YmxpY0tleUluZGV4W3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKV0gIT0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICdTaWduYXR1cmUgaGFzIG5vIG1hdGNoaW5nIHB1YmxpYyBrZXknKTtcbiAgJC5jaGVja1N0YXRlKHRoaXMuaXNWYWxpZFNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSwgJ0ludmFsaWQgU2lnbmF0dXJlIScpO1xuICB0aGlzLnNpZ25hdHVyZXNbdGhpcy5wdWJsaWNLZXlJbmRleFtzaWduYXR1cmUucHVibGljS2V5LnRvU3RyaW5nKCldXSA9IHNpZ25hdHVyZTtcbiAgdGhpcy5fdXBkYXRlU2NyaXB0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLl91cGRhdGVTY3JpcHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMubmVzdGVkV2l0bmVzcyB8fCB0aGlzLnR5cGUgPT09IEFkZHJlc3MuUGF5VG9XaXRuZXNzU2NyaXB0SGFzaCkge1xuICAgIHZhciBzdGFjayA9IFtcbiAgICAgIEJ1ZmZlci5hbGxvYygwKSxcbiAgICBdO1xuICAgIHZhciBzaWduYXR1cmVzID0gdGhpcy5fY3JlYXRlU2lnbmF0dXJlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhY2sucHVzaChzaWduYXR1cmVzW2ldKTtcbiAgICB9XG4gICAgc3RhY2sucHVzaCh0aGlzLnJlZGVlbVNjcmlwdC50b0J1ZmZlcigpKTtcbiAgICB0aGlzLnNldFdpdG5lc3NlcyhzdGFjayk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjcmlwdFNpZyA9IFNjcmlwdC5idWlsZFAyU0hNdWx0aXNpZ0luKFxuICAgICAgdGhpcy5wdWJsaWNLZXlzLFxuICAgICAgdGhpcy50aHJlc2hvbGQsXG4gICAgICB0aGlzLl9jcmVhdGVTaWduYXR1cmVzKCksXG4gICAgICB7IGNhY2hlZE11bHRpc2lnOiB0aGlzLnJlZGVlbVNjcmlwdCB9XG4gICAgKTtcbiAgICB0aGlzLnNldFNjcmlwdChzY3JpcHRTaWcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLl9jcmVhdGVTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNpZ25hdHVyZXNcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKHNpZ25hdHVyZSkgeyByZXR1cm4gc2lnbmF0dXJlICE9IG51bGw7IH0pXG4gICAgLm1hcChmdW5jdGlvbihzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiBCdWZmZXJVdGlsLmNvbmNhdChbXG4gICAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9ERVIoKSxcbiAgICAgICAgQnVmZmVyVXRpbC5pbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKHNpZ25hdHVyZS5zaWd0eXBlKVxuICAgICAgXSk7XG4gICAgfSk7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2lnbmF0dXJlcyA9IG5ldyBBcnJheSh0aGlzLnB1YmxpY0tleXMubGVuZ3RoKTtcbiAgdGhpcy5fdXBkYXRlU2NyaXB0KCk7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb3VudFNpZ25hdHVyZXMoKSA9PT0gdGhpcy50aHJlc2hvbGQ7XG59O1xuXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5wcm90b3R5cGUuY291bnRNaXNzaW5nU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50aHJlc2hvbGQgLSB0aGlzLmNvdW50U2lnbmF0dXJlcygpO1xufTtcblxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLmNvdW50U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zaWduYXR1cmVzLnJlZHVjZShmdW5jdGlvbihzdW0sIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBzdW0gKyAoISFzaWduYXR1cmUpO1xuICB9LCAwKTtcbn07XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5wdWJsaWNLZXlzV2l0aG91dFNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wdWJsaWNLZXlzLmZpbHRlcigocHVibGljS2V5KSA9PiB7XG4gICAgcmV0dXJuICEodGhpcy5zaWduYXR1cmVzW3RoaXMucHVibGljS2V5SW5kZXhbcHVibGljS2V5LnRvU3RyaW5nKCldXSk7XG4gIH0pO1xufTtcblxuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQucHJvdG90eXBlLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSB7XG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXG4gIGlmICh0aGlzLm5lc3RlZFdpdG5lc3MgfHwgdGhpcy50eXBlID09PSBBZGRyZXNzLlBheVRvV2l0bmVzc1NjcmlwdEhhc2gpIHtcbiAgICBzaWduYXR1cmUuc2lnbmF0dXJlLm5oYXNodHlwZSA9IHNpZ25hdHVyZS5zaWd0eXBlO1xuICAgIHZhciBzY3JpcHRDb2RlID0gdGhpcy5nZXRTY3JpcHRDb2RlKCk7XG4gICAgdmFyIHNhdG9zaGlzQnVmZmVyID0gdGhpcy5nZXRTYXRvc2hpc0J1ZmZlcigpO1xuICAgIHJldHVybiBTaWdoYXNoV2l0bmVzcy52ZXJpZnkoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgICBzaWduYXR1cmUucHVibGljS2V5LFxuICAgICAgc2lnbmF0dXJlLmlucHV0SW5kZXgsXG4gICAgICBzY3JpcHRDb2RlLFxuICAgICAgc2F0b3NoaXNCdWZmZXJcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIEZJWE1FOiBSZWZhY3RvciBzaWduYXR1cmUgc28gdGhpcyBpcyBub3QgbmVjZXNzYXJ5XG4gICAgc2lnbmF0dXJlLnNpZ25hdHVyZS5uaGFzaHR5cGUgPSBzaWduYXR1cmUuc2lndHlwZTtcbiAgICByZXR1cm4gU2lnaGFzaC52ZXJpZnkoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgICBzaWduYXR1cmUucHVibGljS2V5LFxuICAgICAgc2lnbmF0dXJlLmlucHV0SW5kZXgsXG4gICAgICB0aGlzLnJlZGVlbVNjcmlwdFxuICAgICk7XG4gIH1cbn07XG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0Lk1BWF9PUENPREVTX1NJWkUgPSA4OyAvLyBzZXJpYWxpemVkIHNpemUgKDw9MykgKyAwIC4uIE9QX1BVU0hEQVRBeCBOIC4uIE0gT1BfQ0hFQ0tNVUxUSVNJR1xuTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQuTUFYX1NJR05BVFVSRV9TSVpFID0gNzQ7IC8vIHNpemUgKDEpICsgREVSICg8PTcyKSArIHNpZ2hhc2ggKDEpXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5NQVhfUFVCS0VZX1NJWkUgPSAzNDsgLy8gc2l6ZSAoMSkgKyBERVIgKDw9MzMpXG5NdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5SRURFRU1fU0NSSVBUX1NJWkUgPSAzNDsgLy8gT1BfMCAoMSkgKyBzY3JpcHRIYXNoICgxICsgMzIpXG5cbk11bHRpU2lnU2NyaXB0SGFzaElucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIGxldCByZXN1bHQgPSB0aGlzLl9nZXRCYXNlU2l6ZSgpO1xuICBjb25zdCBXSVRORVNTX0RJU0NPVU5UID0gNDtcbiAgY29uc3Qgd2l0bmVzc1NpemUgPSBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dC5NQVhfT1BDT0RFU19TSVpFICtcbiAgICB0aGlzLnRocmVzaG9sZCAqIE11bHRpU2lnU2NyaXB0SGFzaElucHV0Lk1BWF9TSUdOQVRVUkVfU0laRSArXG4gICAgdGhpcy5wdWJsaWNLZXlzLmxlbmd0aCAqIE11bHRpU2lnU2NyaXB0SGFzaElucHV0Lk1BWF9QVUJLRVlfU0laRTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gQWRkcmVzcy5QYXlUb1dpdG5lc3NTY3JpcHRIYXNoKSB7XG4gICAgcmVzdWx0ICs9IHdpdG5lc3NTaXplIC8gV0lUTkVTU19ESVNDT1VOVDtcbiAgfSBlbHNlIGlmICh0aGlzLm5lc3RlZFdpdG5lc3MpIHtcbiAgICByZXN1bHQgKz0gd2l0bmVzc1NpemUgLyBXSVRORVNTX0RJU0NPVU5UICsgTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQuUkVERUVNX1NDUklQVF9TSVpFO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSB3aXRuZXNzU2l6ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aVNpZ1NjcmlwdEhhc2hJbnB1dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickey.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/publickey.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\n\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\n\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\n\n/**\n * Represents a special kind of input of PayToPublicKey kind.\n * @constructor\n */\nfunction PublicKeyInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyInput, Input);\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type \n * @param {String} signingMethod DEPRECATED - method used to sign input - 'ecdsa' or 'schnorr'\n * @return {Array} of objects that can be\n */\nPublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  var publicKey = privateKey.toPublicKey();\n  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\n    return [new TransactionSignature({\n      publicKey: publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyInput} this, for chaining\n */\nPublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyIn(\n    signature.signature.toDER(),\n    signature.sigtype\n  ));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyIn();\n};\n\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\n\nPublicKeyInput.prototype._estimateSize = function() {\n  return this._getBaseSize() + PublicKeyInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3B1YmxpY2tleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0ZBQVU7O0FBRWpDLFFBQVEsbUJBQU8sQ0FBQyw0RkFBMEI7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQW1COztBQUU1QyxZQUFZLG1CQUFPLENBQUMsZ0ZBQVM7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDZFQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQywrRUFBWTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsMEVBQWM7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQXdCO0FBQ2hELDJCQUEyQixtQkFBTyxDQUFDLG1GQUFjOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi90cmFuc2FjdGlvbi9pbnB1dC9wdWJsaWNrZXkuanM/NjczOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciAkID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnVmZmVyJyk7XG5cbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuLi9vdXRwdXQnKTtcbnZhciBTaWdoYXNoID0gcmVxdWlyZSgnLi4vc2lnaGFzaCcpO1xudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL3NjcmlwdCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uLy4uL2NyeXB0by9zaWduYXR1cmUnKTtcbnZhciBUcmFuc2FjdGlvblNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL3NpZ25hdHVyZScpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzcGVjaWFsIGtpbmQgb2YgaW5wdXQgb2YgUGF5VG9QdWJsaWNLZXkga2luZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQdWJsaWNLZXlJbnB1dCgpIHtcbiAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmluaGVyaXRzKFB1YmxpY0tleUlucHV0LCBJbnB1dCk7XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVLZXkgLSB0aGUgcHJpdmF0ZSBrZXkgd2l0aCB3aGljaCB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBpbnB1dCBpbiB0aGUgdHJhbnNhY3Rpb24gaW5wdXQgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHNpZ25hdHVyZSwgZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaERhdGEgLSB1bnVzZWQgZm9yIHRoaXMgaW5wdXQgdHlwZSBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIERFUFJFQ0FURUQgLSBtZXRob2QgdXNlZCB0byBzaWduIGlucHV0IC0gJ2VjZHNhJyBvciAnc2Nobm9ycidcbiAqIEByZXR1cm4ge0FycmF5fSBvZiBvYmplY3RzIHRoYXQgY2FuIGJlXG4gKi9cblB1YmxpY0tleUlucHV0LnByb3RvdHlwZS5nZXRTaWduYXR1cmVzID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIGluZGV4LCBzaWd0eXBlLCBoYXNoRGF0YSwgc2lnbmluZ01ldGhvZCkge1xuICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQpO1xuICBzaWd0eXBlID0gc2lndHlwZSB8fCBTaWduYXR1cmUuU0lHSEFTSF9BTEw7XG4gIHNpZ25pbmdNZXRob2QgPSBzaWduaW5nTWV0aG9kIHx8ICdlY2RzYSc7IC8vIHVudXNlZC4gS2VlcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBsaWJzXG4gIHZhciBwdWJsaWNLZXkgPSBwcml2YXRlS2V5LnRvUHVibGljS2V5KCk7XG4gIGlmIChwdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gdGhpcy5vdXRwdXQuc2NyaXB0LmdldFB1YmxpY0tleSgpLnRvU3RyaW5nKCdoZXgnKSkge1xuICAgIHJldHVybiBbbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcbiAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQsXG4gICAgICBvdXRwdXRJbmRleDogdGhpcy5vdXRwdXRJbmRleCxcbiAgICAgIGlucHV0SW5kZXg6IGluZGV4LFxuICAgICAgc2lnbmF0dXJlOiBTaWdoYXNoLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCB0aGlzLm91dHB1dC5zY3JpcHQpLFxuICAgICAgc2lndHlwZTogc2lndHlwZVxuICAgIH0pXTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHNpZ25hdHVyZS5wdWJsaWNLZXlcbiAqIEBwYXJhbSB7U2lnbmF0dXJlfSBzaWduYXR1cmUuc2lnbmF0dXJlXG4gKiBAcGFyYW0ge251bWJlcj19IHNpZ25hdHVyZS5zaWd0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmluZ01ldGhvZCAtIG1ldGhvZCB1c2VkIHRvIHNpZ24gLSAnZWNkc2EnIG9yICdzY2hub3JyJyAoZnV0dXJlIHNpZ25pbmcgbWV0aG9kKVxuICogQHJldHVybiB7UHVibGljS2V5SW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5QdWJsaWNLZXlJbnB1dC5wcm90b3R5cGUuYWRkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICAkLmNoZWNrU3RhdGUodGhpcy5pc1ZhbGlkU2lnbmF0dXJlKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpLCAnU2lnbmF0dXJlIGlzIGludmFsaWQnKTtcbiAgdGhpcy5zZXRTY3JpcHQoU2NyaXB0LmJ1aWxkUHVibGljS2V5SW4oXG4gICAgc2lnbmF0dXJlLnNpZ25hdHVyZS50b0RFUigpLFxuICAgIHNpZ25hdHVyZS5zaWd0eXBlXG4gICkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIGlucHV0J3Mgc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtQdWJsaWNLZXlIYXNoSW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5QdWJsaWNLZXlJbnB1dC5wcm90b3R5cGUuY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2V0U2NyaXB0KFNjcmlwdC5lbXB0eSgpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXJ5IHdoZXRoZXIgdGhlIGlucHV0IGlzIHNpZ25lZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUHVibGljS2V5SW5wdXQucHJvdG90eXBlLmlzRnVsbHlTaWduZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2NyaXB0LmlzUHVibGljS2V5SW4oKTtcbn07XG5cblB1YmxpY0tleUlucHV0LlNDUklQVF9NQVhfU0laRSA9IDczOyAvLyBzaWdzaXplICgxICsgNzIpXG5cblB1YmxpY0tleUlucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nZXRCYXNlU2l6ZSgpICsgUHVibGljS2V5SW5wdXQuU0NSSVBUX01BWF9TSVpFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQdWJsaWNLZXlJbnB1dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\n\nvar $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\n\nvar Address = __webpack_require__(/*! ../../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Hash = __webpack_require__(/*! ../../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/input.js\");\nvar Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar Sighash = __webpack_require__(/*! ../sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar SighashWitness = __webpack_require__(/*! ../sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\nvar BufferWriter = __webpack_require__(/*! ../../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar BufferUtil = __webpack_require__(/*! ../../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar Script = __webpack_require__(/*! ../../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyHashInput, Input);\n\nPublicKeyHashInput.prototype.getRedeemScript = function(publicKey) {\n  if (!this.redeemScript) {\n    var redeemScript = Script.buildWitnessV0Out(publicKey);\n    if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {\n      var scriptSig = new Script();\n      scriptSig.add(redeemScript.toBuffer());\n      this.setScript(scriptSig);\n      this.redeemScript = redeemScript;\n    }\n  }\n  return this.redeemScript;\n};\n\nPublicKeyHashInput.prototype.getScriptCode = function(publicKey) {\n  var writer = new BufferWriter();\n  var script;\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(publicKey);\n  } else {\n    script = this.output.script;\n  }\n  var scriptBuffer = Script.buildPublicKeyHashOut(script.toAddress()).toBuffer();\n  writer.writeVarintNum(scriptBuffer.length);\n  writer.write(scriptBuffer);\n  return writer.toBuffer();\n};\n\nPublicKeyHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\n  var scriptCode = this.getScriptCode(privateKey);\n  var satoshisBuffer = this.getSatoshisBuffer();\n  return SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n};\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer} merkleRoot - unused for this input type\n * @return {Array<TransactionSignature>}\n */\nPublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  var script;\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(privateKey.publicKey);\n  } else {\n    script = this.output.script;\n  }\n\n  if (script && BufferUtil.equals(hashData, script.getPublicKeyHash())) {\n    var signature;\n    if (script.isWitnessPublicKeyHashOut()) {\n      var satoshisBuffer = this.getSatoshisBuffer();\n      var scriptCode = this.getScriptCode(privateKey.publicKey);\n      signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer);\n    } else {\n      signature = Sighash.sign(transaction, privateKey, sigtype, index, this.output.script);\n    }\n\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: signature,\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Transaction} transaction\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    this.setWitnesses([\n      BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]),\n      signature.publicKey.toBuffer()\n    ]);\n  } else {\n    this.setScript(Script.buildPublicKeyHashIn(\n      signature.publicKey,\n      signature.signature.toDER(),\n      signature.sigtype\n    ));\n  }\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  this.setWitnesses([]);\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyHashInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyHashIn() || this.hasWitnesses();\n};\n\nPublicKeyHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      scriptCode,\n      satoshisBuffer\n    );\n  } else {\n    return Sighash.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      this.output.script\n    );\n  }\n};\n\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\nPublicKeyHashInput.REDEEM_SCRIPT_SIZE = 1 + 22; // len (1) OP_0 (1) pubkeyhash (1 + 20)\n\nPublicKeyHashInput.prototype._estimateSize = function() {\n  let result = this._getBaseSize();\n  result += 1; // script size\n  const WITNESS_DISCOUNT = 4;\n  const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;\n  if (this.output.script.isWitnessPublicKeyHashOut()) {\n    result += witnessSize;\n  } else if (this.output.script.isScriptHashOut()) {\n    result += witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    result += PublicKeyHashInput.SCRIPT_MAX_SIZE;\n  }\n  return result;\n};\n\nmodule.exports = PublicKeyHashInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3B1YmxpY2tleWhhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9GQUFVOztBQUVqQyxRQUFRLG1CQUFPLENBQUMsNEZBQTBCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjs7QUFFNUMsY0FBYyxtQkFBTyxDQUFDLHNFQUFlO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLGdGQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyw2RUFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsK0VBQVk7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLGtHQUE2QjtBQUN4RCxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLDBFQUFjO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHdGQUF3QjtBQUNoRCwyQkFBMkIsbUJBQU8sQ0FBQyxtRkFBYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDhDQUE4QztBQUM5QyxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvcHVibGlja2V5aGFzaC5qcz8wNTVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9idWZmZXInKTtcblxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi8uLi9hZGRyZXNzJyk7XG52YXIgSGFzaCA9IHJlcXVpcmUoJy4uLy4uL2NyeXB0by9oYXNoJyk7XG52YXIgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XG52YXIgT3V0cHV0ID0gcmVxdWlyZSgnLi4vb3V0cHV0Jyk7XG52YXIgU2lnaGFzaCA9IHJlcXVpcmUoJy4uL3NpZ2hhc2gnKTtcbnZhciBTaWdoYXNoV2l0bmVzcyA9IHJlcXVpcmUoJy4uL3NpZ2hhc2h3aXRuZXNzJyk7XG52YXIgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnVmZmVyJyk7XG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vc2NyaXB0Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xudmFyIFRyYW5zYWN0aW9uU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNwZWNpYWwga2luZCBvZiBpbnB1dCBvZiBQYXlUb1B1YmxpY0tleUhhc2gga2luZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQdWJsaWNLZXlIYXNoSW5wdXQoKSB7XG4gIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5pbmhlcml0cyhQdWJsaWNLZXlIYXNoSW5wdXQsIElucHV0KTtcblxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5nZXRSZWRlZW1TY3JpcHQgPSBmdW5jdGlvbihwdWJsaWNLZXkpIHtcbiAgaWYgKCF0aGlzLnJlZGVlbVNjcmlwdCkge1xuICAgIHZhciByZWRlZW1TY3JpcHQgPSBTY3JpcHQuYnVpbGRXaXRuZXNzVjBPdXQocHVibGljS2V5KTtcbiAgICBpZiAoU2NyaXB0LmJ1aWxkU2NyaXB0SGFzaE91dChyZWRlZW1TY3JpcHQpLmVxdWFscyh0aGlzLm91dHB1dC5zY3JpcHQpKSB7XG4gICAgICB2YXIgc2NyaXB0U2lnID0gbmV3IFNjcmlwdCgpO1xuICAgICAgc2NyaXB0U2lnLmFkZChyZWRlZW1TY3JpcHQudG9CdWZmZXIoKSk7XG4gICAgICB0aGlzLnNldFNjcmlwdChzY3JpcHRTaWcpO1xuICAgICAgdGhpcy5yZWRlZW1TY3JpcHQgPSByZWRlZW1TY3JpcHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnJlZGVlbVNjcmlwdDtcbn07XG5cblB1YmxpY0tleUhhc2hJbnB1dC5wcm90b3R5cGUuZ2V0U2NyaXB0Q29kZSA9IGZ1bmN0aW9uKHB1YmxpY0tleSkge1xuICB2YXIgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICB2YXIgc2NyaXB0O1xuICBpZiAodGhpcy5vdXRwdXQuc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpKSB7XG4gICAgc2NyaXB0ID0gdGhpcy5nZXRSZWRlZW1TY3JpcHQocHVibGljS2V5KTtcbiAgfSBlbHNlIHtcbiAgICBzY3JpcHQgPSB0aGlzLm91dHB1dC5zY3JpcHQ7XG4gIH1cbiAgdmFyIHNjcmlwdEJ1ZmZlciA9IFNjcmlwdC5idWlsZFB1YmxpY0tleUhhc2hPdXQoc2NyaXB0LnRvQWRkcmVzcygpKS50b0J1ZmZlcigpO1xuICB3cml0ZXIud3JpdGVWYXJpbnROdW0oc2NyaXB0QnVmZmVyLmxlbmd0aCk7XG4gIHdyaXRlci53cml0ZShzY3JpcHRCdWZmZXIpO1xuICByZXR1cm4gd3JpdGVyLnRvQnVmZmVyKCk7XG59O1xuXG5QdWJsaWNLZXlIYXNoSW5wdXQucHJvdG90eXBlLmdldFNpZ2hhc2ggPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgaW5kZXgsIHNpZ3R5cGUpIHtcbiAgdmFyIHNjcmlwdENvZGUgPSB0aGlzLmdldFNjcmlwdENvZGUocHJpdmF0ZUtleSk7XG4gIHZhciBzYXRvc2hpc0J1ZmZlciA9IHRoaXMuZ2V0U2F0b3NoaXNCdWZmZXIoKTtcbiAgcmV0dXJuIFNpZ2hhc2hXaXRuZXNzLnNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ3R5cGUsIGluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIC0gdGhlIHRyYW5zYWN0aW9uIHRvIGJlIHNpZ25lZFxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlS2V5IC0gdGhlIHByaXZhdGUga2V5IHdpdGggd2hpY2ggdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgaW5wdXQgaW4gdGhlIHRyYW5zYWN0aW9uIGlucHV0IHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ3R5cGUgLSB0aGUgdHlwZSBvZiBzaWduYXR1cmUsIGRlZmF1bHRzIHRvIFNpZ25hdHVyZS5TSUdIQVNIX0FMTFxuICogQHBhcmFtIHtCdWZmZXJ9IGhhc2hEYXRhIC0gdGhlIHByZWNhbGN1bGF0ZWQgaGFzaCBvZiB0aGUgcHVibGljIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHByaXZhdGVLZXkgcHJvdmlkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVya2xlUm9vdCAtIHVudXNlZCBmb3IgdGhpcyBpbnB1dCB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cblB1YmxpY0tleUhhc2hJbnB1dC5wcm90b3R5cGUuZ2V0U2lnbmF0dXJlcyA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBpbmRleCwgc2lndHlwZSwgaGFzaERhdGEsIHNpZ25pbmdNZXRob2QsIG1lcmtsZVJvb3QpIHtcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgT3V0cHV0KTtcbiAgaGFzaERhdGEgPSBoYXNoRGF0YSB8fCBIYXNoLnNoYTI1NnJpcGVtZDE2MChwcml2YXRlS2V5LnB1YmxpY0tleS50b0J1ZmZlcigpKTtcbiAgc2lndHlwZSA9IHNpZ3R5cGUgfHwgU2lnbmF0dXJlLlNJR0hBU0hfQUxMO1xuICBzaWduaW5nTWV0aG9kID0gc2lnbmluZ01ldGhvZCB8fCAnZWNkc2EnOyAvLyB1bnVzZWQuIEtlZXBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgbGlic1xuXG4gIHZhciBzY3JpcHQ7XG4gIGlmICh0aGlzLm91dHB1dC5zY3JpcHQuaXNTY3JpcHRIYXNoT3V0KCkpIHtcbiAgICBzY3JpcHQgPSB0aGlzLmdldFJlZGVlbVNjcmlwdChwcml2YXRlS2V5LnB1YmxpY0tleSk7XG4gIH0gZWxzZSB7XG4gICAgc2NyaXB0ID0gdGhpcy5vdXRwdXQuc2NyaXB0O1xuICB9XG5cbiAgaWYgKHNjcmlwdCAmJiBCdWZmZXJVdGlsLmVxdWFscyhoYXNoRGF0YSwgc2NyaXB0LmdldFB1YmxpY0tleUhhc2goKSkpIHtcbiAgICB2YXIgc2lnbmF0dXJlO1xuICAgIGlmIChzY3JpcHQuaXNXaXRuZXNzUHVibGljS2V5SGFzaE91dCgpKSB7XG4gICAgICB2YXIgc2F0b3NoaXNCdWZmZXIgPSB0aGlzLmdldFNhdG9zaGlzQnVmZmVyKCk7XG4gICAgICB2YXIgc2NyaXB0Q29kZSA9IHRoaXMuZ2V0U2NyaXB0Q29kZShwcml2YXRlS2V5LnB1YmxpY0tleSk7XG4gICAgICBzaWduYXR1cmUgPSBTaWdoYXNoV2l0bmVzcy5zaWduKHRyYW5zYWN0aW9uLCBwcml2YXRlS2V5LCBzaWd0eXBlLCBpbmRleCwgc2NyaXB0Q29kZSwgc2F0b3NoaXNCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWduYXR1cmUgPSBTaWdoYXNoLnNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ3R5cGUsIGluZGV4LCB0aGlzLm91dHB1dC5zY3JpcHQpO1xuICAgIH1cblxuICAgIHJldHVybiBbbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKHtcbiAgICAgIHB1YmxpY0tleTogcHJpdmF0ZUtleS5wdWJsaWNLZXksXG4gICAgICBwcmV2VHhJZDogdGhpcy5wcmV2VHhJZCxcbiAgICAgIG91dHB1dEluZGV4OiB0aGlzLm91dHB1dEluZGV4LFxuICAgICAgaW5wdXRJbmRleDogaW5kZXgsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgIHNpZ3R5cGU6IHNpZ3R5cGVcbiAgICB9KV07XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcbi8qIGpzaGludCBtYXhwYXJhbXM6IDMgKi9cblxuLyoqXG4gKiBBZGQgdGhlIHByb3ZpZGVkIHNpZ25hdHVyZVxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gc2lnbmF0dXJlLnB1YmxpY0tleVxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZS5zaWduYXR1cmVcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2lnbmF0dXJlLnNpZ3R5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduaW5nTWV0aG9kIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInIChmdXR1cmUgc2lnbmluZyBtZXRob2QpXG4gKiBAcmV0dXJuIHtQdWJsaWNLZXlIYXNoSW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5QdWJsaWNLZXlIYXNoSW5wdXQucHJvdG90eXBlLmFkZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpIHtcbiAgJC5jaGVja1N0YXRlKHRoaXMuaXNWYWxpZFNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSwgJ1NpZ25hdHVyZSBpcyBpbnZhbGlkJyk7XG5cbiAgaWYgKHRoaXMub3V0cHV0LnNjcmlwdC5pc1dpdG5lc3NQdWJsaWNLZXlIYXNoT3V0KCkgfHwgdGhpcy5vdXRwdXQuc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpKSB7XG4gICAgdGhpcy5zZXRXaXRuZXNzZXMoW1xuICAgICAgQnVmZmVyVXRpbC5jb25jYXQoW1xuICAgICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLnRvREVSKCksXG4gICAgICAgIEJ1ZmZlclV0aWwuaW50ZWdlckFzU2luZ2xlQnl0ZUJ1ZmZlcihzaWduYXR1cmUuc2lndHlwZSlcbiAgICAgIF0pLFxuICAgICAgc2lnbmF0dXJlLnB1YmxpY0tleS50b0J1ZmZlcigpXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZXRTY3JpcHQoU2NyaXB0LmJ1aWxkUHVibGljS2V5SGFzaEluKFxuICAgICAgc2lnbmF0dXJlLnB1YmxpY0tleSxcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9ERVIoKSxcbiAgICAgIHNpZ25hdHVyZS5zaWd0eXBlXG4gICAgKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBpbnB1dCdzIHNpZ25hdHVyZVxuICogQHJldHVybiB7UHVibGljS2V5SGFzaElucHV0fSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5jbGVhclNpZ25hdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXRTY3JpcHQoU2NyaXB0LmVtcHR5KCkpO1xuICB0aGlzLnNldFdpdG5lc3NlcyhbXSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBRdWVyeSB3aGV0aGVyIHRoZSBpbnB1dCBpcyBzaWduZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblB1YmxpY0tleUhhc2hJbnB1dC5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zY3JpcHQuaXNQdWJsaWNLZXlIYXNoSW4oKSB8fCB0aGlzLmhhc1dpdG5lc3NlcygpO1xufTtcblxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICBzaWduaW5nTWV0aG9kID0gc2lnbmluZ01ldGhvZCB8fCAnZWNkc2EnOyAvLyB1bnVzZWQuIEtlZXBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgbGlic1xuICAvLyBGSVhNRTogUmVmYWN0b3Igc2lnbmF0dXJlIHNvIHRoaXMgaXMgbm90IG5lY2Vzc2FyeVxuICBzaWduYXR1cmUuc2lnbmF0dXJlLm5oYXNodHlwZSA9IHNpZ25hdHVyZS5zaWd0eXBlO1xuICBpZiAodGhpcy5vdXRwdXQuc2NyaXB0LmlzV2l0bmVzc1B1YmxpY0tleUhhc2hPdXQoKSB8fCB0aGlzLm91dHB1dC5zY3JpcHQuaXNTY3JpcHRIYXNoT3V0KCkpIHtcbiAgICB2YXIgc2NyaXB0Q29kZSA9IHRoaXMuZ2V0U2NyaXB0Q29kZSgpO1xuICAgIHZhciBzYXRvc2hpc0J1ZmZlciA9IHRoaXMuZ2V0U2F0b3NoaXNCdWZmZXIoKTtcbiAgICByZXR1cm4gU2lnaGFzaFdpdG5lc3MudmVyaWZ5KFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxuICAgICAgc2lnbmF0dXJlLnB1YmxpY0tleSxcbiAgICAgIHNpZ25hdHVyZS5pbnB1dEluZGV4LFxuICAgICAgc2NyaXB0Q29kZSxcbiAgICAgIHNhdG9zaGlzQnVmZmVyXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gU2lnaGFzaC52ZXJpZnkoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgICBzaWduYXR1cmUucHVibGljS2V5LFxuICAgICAgc2lnbmF0dXJlLmlucHV0SW5kZXgsXG4gICAgICB0aGlzLm91dHB1dC5zY3JpcHRcbiAgICApO1xuICB9XG59O1xuXG5cblB1YmxpY0tleUhhc2hJbnB1dC5TQ1JJUFRfTUFYX1NJWkUgPSA3MyArIDM0OyAvLyBzaWdzaXplICgxICsgNzIpICsgcHVia2V5ICgxICsgMzMpXG5QdWJsaWNLZXlIYXNoSW5wdXQuUkVERUVNX1NDUklQVF9TSVpFID0gMSArIDIyOyAvLyBsZW4gKDEpIE9QXzAgKDEpIHB1YmtleWhhc2ggKDEgKyAyMClcblxuUHVibGljS2V5SGFzaElucHV0LnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIGxldCByZXN1bHQgPSB0aGlzLl9nZXRCYXNlU2l6ZSgpO1xuICByZXN1bHQgKz0gMTsgLy8gc2NyaXB0IHNpemVcbiAgY29uc3QgV0lUTkVTU19ESVNDT1VOVCA9IDQ7XG4gIGNvbnN0IHdpdG5lc3NTaXplID0gUHVibGljS2V5SGFzaElucHV0LlNDUklQVF9NQVhfU0laRSAvIFdJVE5FU1NfRElTQ09VTlQ7XG4gIGlmICh0aGlzLm91dHB1dC5zY3JpcHQuaXNXaXRuZXNzUHVibGljS2V5SGFzaE91dCgpKSB7XG4gICAgcmVzdWx0ICs9IHdpdG5lc3NTaXplO1xuICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0LnNjcmlwdC5pc1NjcmlwdEhhc2hPdXQoKSkge1xuICAgIHJlc3VsdCArPSB3aXRuZXNzU2l6ZSArIFB1YmxpY0tleUhhc2hJbnB1dC5SRURFRU1fU0NSSVBUX1NJWkU7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IFB1YmxpY0tleUhhc2hJbnB1dC5TQ1JJUFRfTUFYX1NJWkU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHVibGljS2V5SGFzaElucHV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/input/taproot.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/input/taproot.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\nconst $ = __webpack_require__(/*! ../../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst PubKeyHashInput = __webpack_require__(/*! ./publickeyhash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js\");\nconst SighashSchnorr = __webpack_require__(/*! ../sighashschnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js\");\nconst Signature = __webpack_require__(/*! ../../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nconst TransactionSignature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\");\nconst Output = __webpack_require__(/*! ../output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nconst PrivateKey = __webpack_require__(/*! ../../privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\n\nfunction TaprootInput() {\n  PubKeyHashInput.apply(this, arguments);\n}\ninherits(TaprootInput, PubKeyHashInput);\n\n/**\n * Get signatures for this input\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type\n * @param {String} signingMethod - always schnorr for taproot\n * @param {Buffer} merkleRoot - the merkle root of the taproot tree\n * @return {Array<TransactionSignature>}\n */\nTaprootInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_DEFAULT;\n  \n  const inputIndex = transaction.inputs.indexOf(this);\n  const tweakedPk = privateKey.createTapTweak(merkleRoot).tweakedPrivKey;\n  const signature = SighashSchnorr.sign(\n    transaction,\n    tweakedPk,\n    sigtype,\n    inputIndex,\n    Signature.Version.TAPROOT,\n    null\n  );\n  if (!signature) {\n    return [];\n  }\n  const txSig = new TransactionSignature({\n    publicKey: privateKey.publicKey,\n    prevTxId: this.prevTxId,\n    outputIndex: this.outputIndex,\n    inputIndex,\n    signature: Signature.fromSchnorr(signature),\n    sigtype: sigtype\n  });\n  return this.isValidSignature(transaction, txSig) ? [txSig] : [];\n};\n\n\nTaprootInput.prototype.isValidSignature = function(transaction, signature) {\n  $.checkState(transaction.inputs.indexOf(this) >= 0, 'Signature has no matching input');\n  $.checkState(this.output instanceof Output, 'output is not instance of Output');\n  \n  if (!this.output.script.isTaproot()) {\n    return false;\n  }\n\n  return SighashSchnorr.verify(\n    transaction,\n    signature.signature,\n    this.output.script.chunks[1].buf,\n    Signature.Version.TAPROOT,\n    transaction.inputs.indexOf(this),\n    null\n  );\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nTaprootInput.prototype.isFullySigned = function() {\n  return this.output.script.isTaproot() && this.hasWitnesses();\n};\n\n/**\n * Add the provided signature\n *\n * @param {Transaction} transaction\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number} signature.sigtype\n * @return {TaprootInput} this, for chaining\n */\nTaprootInput.prototype.addSignature = function(transaction, signature) {\n  if (this.isValidSignature(transaction, signature)) {\n    this.setWitnesses([\n      signature.signature.toBuffer(),\n    ]);\n  }\n  // else... do nothing?\n  // When tx.sign(keys) is called, the given keys are used to try to sign all\n  // inputs. Invalid sigs may be created, in which case we should not add them here.\n  // The flow is kind of weird since this fn name is saying to add the signature.\n  // Maybe the validation check should be upstream to keep the code lexically obedient?\n\n  return this;\n};\n\n\n// TODO verify that this is the correct MAX size.\nTaprootInput.SCRIPT_MAX_SIZE = 66; // numwitnesses (1) + sigsize (1 + 64)\n\nTaprootInput.prototype._estimateSize = function() {\n  let result = this._getBaseSize();\n  result += 1; // script size\n  const WITNESS_DISCOUNT = 4;\n  const witnessSize = TaprootInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;\n  result += witnessSize;\n  return result;\n};\n\n\nmodule.exports = TaprootInput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL2lucHV0L3RhcHJvb3QuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQVU7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLDRGQUEwQjtBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBaUI7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ2xELGtCQUFrQixtQkFBTyxDQUFDLHdGQUF3QjtBQUNsRCw2QkFBNkIsbUJBQU8sQ0FBQyxtRkFBYztBQUNuRCxlQUFlLG1CQUFPLENBQUMsNkVBQVc7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQWtCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vaW5wdXQvdGFwcm9vdC5qcz82M2M3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbmNvbnN0ICQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbmNvbnN0IFB1YktleUhhc2hJbnB1dCA9IHJlcXVpcmUoJy4vcHVibGlja2V5aGFzaCcpO1xuY29uc3QgU2lnaGFzaFNjaG5vcnIgPSByZXF1aXJlKCcuLi9zaWdoYXNoc2Nobm9ycicpO1xuY29uc3QgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xuY29uc3QgVHJhbnNhY3Rpb25TaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcbmNvbnN0IE91dHB1dCA9IHJlcXVpcmUoJy4uL291dHB1dCcpO1xuY29uc3QgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uLy4uL3ByaXZhdGVrZXknKTtcblxuZnVuY3Rpb24gVGFwcm9vdElucHV0KCkge1xuICBQdWJLZXlIYXNoSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmluaGVyaXRzKFRhcHJvb3RJbnB1dCwgUHViS2V5SGFzaElucHV0KTtcblxuLyoqXG4gKiBHZXQgc2lnbmF0dXJlcyBmb3IgdGhpcyBpbnB1dFxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgc2lnbmVkXG4gKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVLZXkgLSB0aGUgcHJpdmF0ZSBrZXkgd2l0aCB3aGljaCB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBpbnB1dCBpbiB0aGUgdHJhbnNhY3Rpb24gaW5wdXQgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gc2lndHlwZSAtIHRoZSB0eXBlIG9mIHNpZ25hdHVyZSwgZGVmYXVsdHMgdG8gU2lnbmF0dXJlLlNJR0hBU0hfQUxMXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGFzaERhdGEgLSB1bnVzZWQgZm9yIHRoaXMgaW5wdXQgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25pbmdNZXRob2QgLSBhbHdheXMgc2Nobm9yciBmb3IgdGFwcm9vdFxuICogQHBhcmFtIHtCdWZmZXJ9IG1lcmtsZVJvb3QgLSB0aGUgbWVya2xlIHJvb3Qgb2YgdGhlIHRhcHJvb3QgdHJlZVxuICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5UYXByb290SW5wdXQucHJvdG90eXBlLmdldFNpZ25hdHVyZXMgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgaW5kZXgsIHNpZ3R5cGUsIGhhc2hEYXRhLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLm91dHB1dCBpbnN0YW5jZW9mIE91dHB1dCk7XG4gIHNpZ3R5cGUgPSBzaWd0eXBlIHx8IFNpZ25hdHVyZS5TSUdIQVNIX0RFRkFVTFQ7XG4gIFxuICBjb25zdCBpbnB1dEluZGV4ID0gdHJhbnNhY3Rpb24uaW5wdXRzLmluZGV4T2YodGhpcyk7XG4gIGNvbnN0IHR3ZWFrZWRQayA9IHByaXZhdGVLZXkuY3JlYXRlVGFwVHdlYWsobWVya2xlUm9vdCkudHdlYWtlZFByaXZLZXk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ2hhc2hTY2hub3JyLnNpZ24oXG4gICAgdHJhbnNhY3Rpb24sXG4gICAgdHdlYWtlZFBrLFxuICAgIHNpZ3R5cGUsXG4gICAgaW5wdXRJbmRleCxcbiAgICBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09ULFxuICAgIG51bGxcbiAgKTtcbiAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgdHhTaWcgPSBuZXcgVHJhbnNhY3Rpb25TaWduYXR1cmUoe1xuICAgIHB1YmxpY0tleTogcHJpdmF0ZUtleS5wdWJsaWNLZXksXG4gICAgcHJldlR4SWQ6IHRoaXMucHJldlR4SWQsXG4gICAgb3V0cHV0SW5kZXg6IHRoaXMub3V0cHV0SW5kZXgsXG4gICAgaW5wdXRJbmRleCxcbiAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tU2Nobm9ycihzaWduYXR1cmUpLFxuICAgIHNpZ3R5cGU6IHNpZ3R5cGVcbiAgfSk7XG4gIHJldHVybiB0aGlzLmlzVmFsaWRTaWduYXR1cmUodHJhbnNhY3Rpb24sIHR4U2lnKSA/IFt0eFNpZ10gOiBbXTtcbn07XG5cblxuVGFwcm9vdElucHV0LnByb3RvdHlwZS5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAkLmNoZWNrU3RhdGUodHJhbnNhY3Rpb24uaW5wdXRzLmluZGV4T2YodGhpcykgPj0gMCwgJ1NpZ25hdHVyZSBoYXMgbm8gbWF0Y2hpbmcgaW5wdXQnKTtcbiAgJC5jaGVja1N0YXRlKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgT3V0cHV0LCAnb3V0cHV0IGlzIG5vdCBpbnN0YW5jZSBvZiBPdXRwdXQnKTtcbiAgXG4gIGlmICghdGhpcy5vdXRwdXQuc2NyaXB0LmlzVGFwcm9vdCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFNpZ2hhc2hTY2hub3JyLnZlcmlmeShcbiAgICB0cmFuc2FjdGlvbixcbiAgICBzaWduYXR1cmUuc2lnbmF0dXJlLFxuICAgIHRoaXMub3V0cHV0LnNjcmlwdC5jaHVua3NbMV0uYnVmLFxuICAgIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFJPT1QsXG4gICAgdHJhbnNhY3Rpb24uaW5wdXRzLmluZGV4T2YodGhpcyksXG4gICAgbnVsbFxuICApO1xufTtcblxuLyoqXG4gKiBRdWVyeSB3aGV0aGVyIHRoZSBpbnB1dCBpcyBzaWduZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblRhcHJvb3RJbnB1dC5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vdXRwdXQuc2NyaXB0LmlzVGFwcm9vdCgpICYmIHRoaXMuaGFzV2l0bmVzc2VzKCk7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBzaWduYXR1cmUucHVibGljS2V5XG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlLnNpZ25hdHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ25hdHVyZS5zaWd0eXBlXG4gKiBAcmV0dXJuIHtUYXByb290SW5wdXR9IHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5UYXByb290SW5wdXQucHJvdG90eXBlLmFkZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgaWYgKHRoaXMuaXNWYWxpZFNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSkge1xuICAgIHRoaXMuc2V0V2l0bmVzc2VzKFtcbiAgICAgIHNpZ25hdHVyZS5zaWduYXR1cmUudG9CdWZmZXIoKSxcbiAgICBdKTtcbiAgfVxuICAvLyBlbHNlLi4uIGRvIG5vdGhpbmc/XG4gIC8vIFdoZW4gdHguc2lnbihrZXlzKSBpcyBjYWxsZWQsIHRoZSBnaXZlbiBrZXlzIGFyZSB1c2VkIHRvIHRyeSB0byBzaWduIGFsbFxuICAvLyBpbnB1dHMuIEludmFsaWQgc2lncyBtYXkgYmUgY3JlYXRlZCwgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgbm90IGFkZCB0aGVtIGhlcmUuXG4gIC8vIFRoZSBmbG93IGlzIGtpbmQgb2Ygd2VpcmQgc2luY2UgdGhpcyBmbiBuYW1lIGlzIHNheWluZyB0byBhZGQgdGhlIHNpZ25hdHVyZS5cbiAgLy8gTWF5YmUgdGhlIHZhbGlkYXRpb24gY2hlY2sgc2hvdWxkIGJlIHVwc3RyZWFtIHRvIGtlZXAgdGhlIGNvZGUgbGV4aWNhbGx5IG9iZWRpZW50P1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBUT0RPIHZlcmlmeSB0aGF0IHRoaXMgaXMgdGhlIGNvcnJlY3QgTUFYIHNpemUuXG5UYXByb290SW5wdXQuU0NSSVBUX01BWF9TSVpFID0gNjY7IC8vIG51bXdpdG5lc3NlcyAoMSkgKyBzaWdzaXplICgxICsgNjQpXG5cblRhcHJvb3RJbnB1dC5wcm90b3R5cGUuX2VzdGltYXRlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcmVzdWx0ID0gdGhpcy5fZ2V0QmFzZVNpemUoKTtcbiAgcmVzdWx0ICs9IDE7IC8vIHNjcmlwdCBzaXplXG4gIGNvbnN0IFdJVE5FU1NfRElTQ09VTlQgPSA0O1xuICBjb25zdCB3aXRuZXNzU2l6ZSA9IFRhcHJvb3RJbnB1dC5TQ1JJUFRfTUFYX1NJWkUgLyBXSVRORVNTX0RJU0NPVU5UO1xuICByZXN1bHQgKz0gd2l0bmVzc1NpemU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGFwcm9vdElucHV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/input/taproot.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js":
/*!************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/output.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar bufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nconst Interpreter = __webpack_require__(/*! ../script/interpreter */ \"(ssr)/./node_modules/bitcore-lib/lib/script/interpreter.js\");\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\n\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\nfunction Output(args) {\n  if (!(this instanceof Output)) {\n    return new Output(args);\n  }\n  if (_.isObject(args)) {\n    this.satoshis = args.satoshis;\n    if (bufferUtil.isBuffer(args.script)) {\n      this.setScriptFromBuffer(args.script);\n    } else {\n      var script;\n      if (_.isString(args.script) && JSUtil.isHexa(args.script)) {\n        script = Buffer.from(args.script, 'hex');\n      } else {\n        script = args.script;\n      }\n      this.setScript(script);\n    }\n\n    if (args.type === 'taproot') {\n      this.branch = [];\n      Object.defineProperty(this, 'isValid', {\n        configurable: false,\n        enumerable: false,\n        get: function() {\n          this._isValid || this._branch.length === 0;\n        },\n        set: function(isValid) {\n          this._isValid = isValid;\n        }\n      });\n      Object.defineProperty(this, 'isComplete', {\n        configurable: false,\n        enumerable: false,\n        get: function() {\n          return this.isValid && (this._branch.length === 0 || (this._branch.length === 1 && !!this._branch[0]));\n        }\n      });\n    }\n  } else {\n    throw new TypeError('Unrecognized argument for Output');\n  }\n}\n\nObject.defineProperty(Output.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    if (this._script) {\n      return this._script;\n    } else {\n      this.setScriptFromBuffer(this._scriptBuffer);\n      return this._script;\n    }\n\n  }\n});\n\nObject.defineProperty(Output.prototype, 'satoshis', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    return this._satoshis;\n  },\n  set: function(num) {\n    if (num instanceof BN) {\n      this._satoshisBN = num;\n      this._satoshis = num.toNumber();\n    } else if (_.isString(num)) {\n      this._satoshis = parseInt(num);\n      this._satoshisBN = BN.fromNumber(this._satoshis);\n    } else {\n      $.checkArgument(\n        JSUtil.isNaturalNumber(num),\n        'Output satoshis is not a natural number'\n      );\n      this._satoshisBN = BN.fromNumber(num);\n      this._satoshis = num;\n    }\n    $.checkState(\n      JSUtil.isNaturalNumber(this._satoshis),\n      'Output satoshis is not a natural number'\n    );\n  }\n});\n\nOutput.prototype.invalidSatoshis = function() {\n  if (this._satoshis > MAX_SAFE_INTEGER) {\n    return 'transaction txout satoshis greater than max safe integer';\n  }\n  if (this._satoshis !== this._satoshisBN.toNumber()) {\n    return 'transaction txout satoshis has corrupted value';\n  }\n  if (this._satoshis < 0) {\n    return 'transaction txout negative';\n  }\n  return false;\n};\n\nOutput.prototype.toObject = Output.prototype.toJSON = function toObject() {\n  var obj = {\n    satoshis: this.satoshis\n  };\n  obj.script = this._scriptBuffer.toString('hex');\n  return obj;\n};\n\nOutput.fromObject = function(data) {\n  return new Output(data);\n};\n\nOutput.prototype.setScriptFromBuffer = function(buffer) {\n  this._scriptBuffer = buffer;\n  try {\n    this._script = Script.fromBuffer(this._scriptBuffer);\n    this._script._isOutput = true;\n  } catch(e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      this._script = null;\n    } else {\n      throw e;\n    }\n  }\n};\n\nOutput.prototype.setScript = function(script) {\n  if (script instanceof Script) {\n    this._scriptBuffer = script.toBuffer();\n    this._script = script;\n    this._script._isOutput = true;\n  } else if (_.isString(script)) {\n    this._script = Script.fromString(script);\n    this._scriptBuffer = this._script.toBuffer();\n    this._script._isOutput = true;\n  } else if (bufferUtil.isBuffer(script)) {\n    this.setScriptFromBuffer(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n  return this;\n};\n\nOutput.prototype.inspect = function() {\n  var scriptStr;\n  if (this.script) {\n    scriptStr = this.script.inspect();\n  } else {\n    scriptStr = this._scriptBuffer.toString('hex');\n  }\n  return '<Output (' + this.satoshis + ' sats) ' + scriptStr + '>';\n};\n\nOutput.fromBufferReader = function(br) {\n  var obj = {};\n  obj.satoshis = br.readUInt64LEBN();\n  var size = br.readVarintNum();\n  if (size !== 0) {\n    obj.script = br.read(size);\n  } else {\n    obj.script = Buffer.from([]);\n  }\n  return new Output(obj);\n};\n\nOutput.prototype.toBufferWriter = function(writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n  writer.writeUInt64LEBN(this._satoshisBN);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  return writer;\n};\n\nOutput.prototype.calculateSize = function() {\n  let result = 8; // satoshis\n  result += BufferWriter.varintBufNum(this._scriptBuffer.length).length;\n  result += this._scriptBuffer.length;\n  return result;\n};\n\n/**\n * Taproot only\n * Add a new script at a certain depth in the tree. Add() operations must be called\n *  in depth-first traversal order of binary tree. If track is true, it will be included in\n *  the GetSpendData() output.\n * @param {Number} depth Tree depth at which to insert the node (depth is 0-based)\n * @param {Script} script \n * @param {Number} leafVersion \n * @param {Boolean} track If true, the leaf will be included in GetSpendData() output\n */\nOutput.prototype.add = function(depth, script, leafVersion, track = true) {\n  $.checkArgument((leafVersion & ~Interpreter.TAPROOT_LEAF_MASK) === 0, 'invalid leafVersion');\n  if (!this.isValid) {\n    return;\n  }\n\n  const node = {\n    hash: TaggedHash.TAPLEAF.writeUInt8(leafVersion).write(script.toBuffer()).finalize(),\n    leaves: []\n  };\n  if (track) {\n    const leafInfo = {\n      script,\n      leafVersion,\n      merkleBranch: []\n    };\n    node.leaves.push(leafInfo);\n  }\n  this._insertNode(node, depth);\n  return this;\n};\n\n\nOutput.prototype._insertNode = function(node, depth) {\n  $.checkArgument(depth >= 0 && depth <= Interpreter.TAPROOT_CONTROL_MAX_NODE_COUNT, 'invalid depth');\n  /* We cannot insert a leaf at a lower depth while a deeper branch is unfinished. Doing\n   * so would mean the Add() invocations do not correspond to a DFS traversal of a\n   * binary tree. */\n  if (depth + 1 < this._branch.length) {\n    this.isValid = false;\n    return;\n  }\n  /* As long as an entry in the branch exists at the specified depth, combine it and propagate up.\n   * The 'node' variable is overwritten here with the newly combined node. */\n  while (this.isValid && this._branch.length > depth && this._branch[depth]) {\n    node = this._combineNodes(node, this._branch[depth]);\n    this._branch = this._branch.slice(0, this._branch.length - 2);\n    if (depth == 0) {\n      this.isValid = false; /* Can't propagate further up than the root */\n    }\n    depth--;\n  }\n  if (this.isValid) {\n    /* Make sure the branch is big enough to place the new node. */\n    if (this._branch.length <= depth) {\n      this._branch = this._branch.slice(0, depth + 1);\n    }\n    $.checkState(!this._nodes[depth]);\n    m_branch[depth] = node;\n  }\n};\n\nOutput.prototype._combineNodes = function(a, b) {\n  const ret = {\n    hash: null,\n    leaves: []\n  };\n  /* Iterate over all tracked leaves in a, add b's hash to their Merkle branch, and move them to ret. */\n  for (let leaf of a.leaves) {\n    leaf.merkleBranch.push(b.hash);\n    ret.leaves.push(leaf);\n  }\n  /* Iterate over all tracked leaves in b, add a's hash to their Merkle branch, and move them to ret. */\n  for (let leaf of b.leaves) {\n    leaf.merkleBranch.push(a.hash);\n    ret.leaves.push(leaf);\n  }\n  /* Lexicographically sort a and b's hash, and compute parent hash. */\n  if (a.hash.compare(b.hash) === -1) {\n    ret.hash = TaggedHash.TAPBRANCH.write(a.hash).write(b.hash).finalize();\n  } else {\n    ret.hash = TaggedHash.TAPBRANCH.write(b.hash).write(a.hash).finalize();\n  }\n  return ret;\n};\n\n\n/**\n * Finalize the construction. Can only be called when IsComplete() is true.\n *  internal_key.IsFullyValid() must be true.\n * @param {PublicKey} pubKey \n */\nOutput.prototype.finalize = function(pubKey) {\n  $.checkState(this.isComplete === true, 'finalize can only be called when isComplete is true');\n  const ret = pubKey.createTapTweak(this._branch.length === 0 ? null : this._branch[0].hash);\n\n};\n\nmodule.exports = Output;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL291dHB1dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsU0FBUyxtQkFBTyxDQUFDLHVFQUFjO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsbUVBQVk7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3JELGFBQWEsbUJBQU8sQ0FBQyx1RUFBVztBQUNoQyxRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyx1RUFBVztBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsdUZBQXNCOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL291dHB1dC5qcz80NjY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBCTiA9IHJlcXVpcmUoJy4uL2NyeXB0by9ibicpO1xudmFyIGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpO1xudmFyIEpTVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvanMnKTtcbnZhciBCdWZmZXJXcml0ZXIgPSByZXF1aXJlKCcuLi9lbmNvZGluZy9idWZmZXJ3cml0ZXInKTtcbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBJbnRlcnByZXRlciA9IHJlcXVpcmUoJy4uL3NjcmlwdC9pbnRlcnByZXRlcicpO1xuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by90YWdnZWRoYXNoJyk7XG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZjtcblxuZnVuY3Rpb24gT3V0cHV0KGFyZ3MpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE91dHB1dCkpIHtcbiAgICByZXR1cm4gbmV3IE91dHB1dChhcmdzKTtcbiAgfVxuICBpZiAoXy5pc09iamVjdChhcmdzKSkge1xuICAgIHRoaXMuc2F0b3NoaXMgPSBhcmdzLnNhdG9zaGlzO1xuICAgIGlmIChidWZmZXJVdGlsLmlzQnVmZmVyKGFyZ3Muc2NyaXB0KSkge1xuICAgICAgdGhpcy5zZXRTY3JpcHRGcm9tQnVmZmVyKGFyZ3Muc2NyaXB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNjcmlwdDtcbiAgICAgIGlmIChfLmlzU3RyaW5nKGFyZ3Muc2NyaXB0KSAmJiBKU1V0aWwuaXNIZXhhKGFyZ3Muc2NyaXB0KSkge1xuICAgICAgICBzY3JpcHQgPSBCdWZmZXIuZnJvbShhcmdzLnNjcmlwdCwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NyaXB0ID0gYXJncy5zY3JpcHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFNjcmlwdChzY3JpcHQpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLnR5cGUgPT09ICd0YXByb290Jykge1xuICAgICAgdGhpcy5icmFuY2ggPSBbXTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNWYWxpZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5faXNWYWxpZCB8fCB0aGlzLl9icmFuY2gubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGlzVmFsaWQpIHtcbiAgICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzQ29tcGxldGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgJiYgKHRoaXMuX2JyYW5jaC5sZW5ndGggPT09IDAgfHwgKHRoaXMuX2JyYW5jaC5sZW5ndGggPT09IDEgJiYgISF0aGlzLl9icmFuY2hbMF0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVjb2duaXplZCBhcmd1bWVudCBmb3IgT3V0cHV0Jyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE91dHB1dC5wcm90b3R5cGUsICdzY3JpcHQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3NjcmlwdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTY3JpcHRGcm9tQnVmZmVyKHRoaXMuX3NjcmlwdEJ1ZmZlcik7XG4gICAgICByZXR1cm4gdGhpcy5fc2NyaXB0O1xuICAgIH1cblxuICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE91dHB1dC5wcm90b3R5cGUsICdzYXRvc2hpcycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2F0b3NoaXM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24obnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICB0aGlzLl9zYXRvc2hpc0JOID0gbnVtO1xuICAgICAgdGhpcy5fc2F0b3NoaXMgPSBudW0udG9OdW1iZXIoKTtcbiAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcobnVtKSkge1xuICAgICAgdGhpcy5fc2F0b3NoaXMgPSBwYXJzZUludChudW0pO1xuICAgICAgdGhpcy5fc2F0b3NoaXNCTiA9IEJOLmZyb21OdW1iZXIodGhpcy5fc2F0b3NoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkLmNoZWNrQXJndW1lbnQoXG4gICAgICAgIEpTVXRpbC5pc05hdHVyYWxOdW1iZXIobnVtKSxcbiAgICAgICAgJ091dHB1dCBzYXRvc2hpcyBpcyBub3QgYSBuYXR1cmFsIG51bWJlcidcbiAgICAgICk7XG4gICAgICB0aGlzLl9zYXRvc2hpc0JOID0gQk4uZnJvbU51bWJlcihudW0pO1xuICAgICAgdGhpcy5fc2F0b3NoaXMgPSBudW07XG4gICAgfVxuICAgICQuY2hlY2tTdGF0ZShcbiAgICAgIEpTVXRpbC5pc05hdHVyYWxOdW1iZXIodGhpcy5fc2F0b3NoaXMpLFxuICAgICAgJ091dHB1dCBzYXRvc2hpcyBpcyBub3QgYSBuYXR1cmFsIG51bWJlcidcbiAgICApO1xuICB9XG59KTtcblxuT3V0cHV0LnByb3RvdHlwZS5pbnZhbGlkU2F0b3NoaXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3NhdG9zaGlzID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHJldHVybiAndHJhbnNhY3Rpb24gdHhvdXQgc2F0b3NoaXMgZ3JlYXRlciB0aGFuIG1heCBzYWZlIGludGVnZXInO1xuICB9XG4gIGlmICh0aGlzLl9zYXRvc2hpcyAhPT0gdGhpcy5fc2F0b3NoaXNCTi50b051bWJlcigpKSB7XG4gICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCBzYXRvc2hpcyBoYXMgY29ycnVwdGVkIHZhbHVlJztcbiAgfVxuICBpZiAodGhpcy5fc2F0b3NoaXMgPCAwKSB7XG4gICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCBuZWdhdGl2ZSc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS50b09iamVjdCA9IE91dHB1dC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHZhciBvYmogPSB7XG4gICAgc2F0b3NoaXM6IHRoaXMuc2F0b3NoaXNcbiAgfTtcbiAgb2JqLnNjcmlwdCA9IHRoaXMuX3NjcmlwdEJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG4gIHJldHVybiBvYmo7XG59O1xuXG5PdXRwdXQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBPdXRwdXQoZGF0YSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldFNjcmlwdEZyb21CdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdGhpcy5fc2NyaXB0QnVmZmVyID0gYnVmZmVyO1xuICB0cnkge1xuICAgIHRoaXMuX3NjcmlwdCA9IFNjcmlwdC5mcm9tQnVmZmVyKHRoaXMuX3NjcmlwdEJ1ZmZlcik7XG4gICAgdGhpcy5fc2NyaXB0Ll9pc091dHB1dCA9IHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgZXJyb3JzLlNjcmlwdC5JbnZhbGlkQnVmZmVyKSB7XG4gICAgICB0aGlzLl9zY3JpcHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRTY3JpcHQgPSBmdW5jdGlvbihzY3JpcHQpIHtcbiAgaWYgKHNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCkge1xuICAgIHRoaXMuX3NjcmlwdEJ1ZmZlciA9IHNjcmlwdC50b0J1ZmZlcigpO1xuICAgIHRoaXMuX3NjcmlwdCA9IHNjcmlwdDtcbiAgICB0aGlzLl9zY3JpcHQuX2lzT3V0cHV0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHNjcmlwdCkpIHtcbiAgICB0aGlzLl9zY3JpcHQgPSBTY3JpcHQuZnJvbVN0cmluZyhzY3JpcHQpO1xuICAgIHRoaXMuX3NjcmlwdEJ1ZmZlciA9IHRoaXMuX3NjcmlwdC50b0J1ZmZlcigpO1xuICAgIHRoaXMuX3NjcmlwdC5faXNPdXRwdXQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGJ1ZmZlclV0aWwuaXNCdWZmZXIoc2NyaXB0KSkge1xuICAgIHRoaXMuc2V0U2NyaXB0RnJvbUJ1ZmZlcihzY3JpcHQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgdHlwZTogc2NyaXB0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNjcmlwdFN0cjtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgc2NyaXB0U3RyID0gdGhpcy5zY3JpcHQuaW5zcGVjdCgpO1xuICB9IGVsc2Uge1xuICAgIHNjcmlwdFN0ciA9IHRoaXMuX3NjcmlwdEJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG4gIH1cbiAgcmV0dXJuICc8T3V0cHV0ICgnICsgdGhpcy5zYXRvc2hpcyArICcgc2F0cykgJyArIHNjcmlwdFN0ciArICc+Jztcbn07XG5cbk91dHB1dC5mcm9tQnVmZmVyUmVhZGVyID0gZnVuY3Rpb24oYnIpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICBvYmouc2F0b3NoaXMgPSBici5yZWFkVUludDY0TEVCTigpO1xuICB2YXIgc2l6ZSA9IGJyLnJlYWRWYXJpbnROdW0oKTtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICBvYmouc2NyaXB0ID0gYnIucmVhZChzaXplKTtcbiAgfSBlbHNlIHtcbiAgICBvYmouc2NyaXB0ID0gQnVmZmVyLmZyb20oW10pO1xuICB9XG4gIHJldHVybiBuZXcgT3V0cHV0KG9iaik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnRvQnVmZmVyV3JpdGVyID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIGlmICghd3JpdGVyKSB7XG4gICAgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICB9XG4gIHdyaXRlci53cml0ZVVJbnQ2NExFQk4odGhpcy5fc2F0b3NoaXNCTik7XG4gIHZhciBzY3JpcHQgPSB0aGlzLl9zY3JpcHRCdWZmZXI7XG4gIHdyaXRlci53cml0ZVZhcmludE51bShzY3JpcHQubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKHNjcmlwdCk7XG4gIHJldHVybiB3cml0ZXI7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmNhbGN1bGF0ZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHJlc3VsdCA9IDg7IC8vIHNhdG9zaGlzXG4gIHJlc3VsdCArPSBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKHRoaXMuX3NjcmlwdEJ1ZmZlci5sZW5ndGgpLmxlbmd0aDtcbiAgcmVzdWx0ICs9IHRoaXMuX3NjcmlwdEJ1ZmZlci5sZW5ndGg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRhcHJvb3Qgb25seVxuICogQWRkIGEgbmV3IHNjcmlwdCBhdCBhIGNlcnRhaW4gZGVwdGggaW4gdGhlIHRyZWUuIEFkZCgpIG9wZXJhdGlvbnMgbXVzdCBiZSBjYWxsZWRcbiAqICBpbiBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb3JkZXIgb2YgYmluYXJ5IHRyZWUuIElmIHRyYWNrIGlzIHRydWUsIGl0IHdpbGwgYmUgaW5jbHVkZWQgaW5cbiAqICB0aGUgR2V0U3BlbmREYXRhKCkgb3V0cHV0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIFRyZWUgZGVwdGggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBub2RlIChkZXB0aCBpcyAwLWJhc2VkKVxuICogQHBhcmFtIHtTY3JpcHR9IHNjcmlwdCBcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWFmVmVyc2lvbiBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJhY2sgSWYgdHJ1ZSwgdGhlIGxlYWYgd2lsbCBiZSBpbmNsdWRlZCBpbiBHZXRTcGVuZERhdGEoKSBvdXRwdXRcbiAqL1xuT3V0cHV0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihkZXB0aCwgc2NyaXB0LCBsZWFmVmVyc2lvbiwgdHJhY2sgPSB0cnVlKSB7XG4gICQuY2hlY2tBcmd1bWVudCgobGVhZlZlcnNpb24gJiB+SW50ZXJwcmV0ZXIuVEFQUk9PVF9MRUFGX01BU0spID09PSAwLCAnaW52YWxpZCBsZWFmVmVyc2lvbicpO1xuICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgaGFzaDogVGFnZ2VkSGFzaC5UQVBMRUFGLndyaXRlVUludDgobGVhZlZlcnNpb24pLndyaXRlKHNjcmlwdC50b0J1ZmZlcigpKS5maW5hbGl6ZSgpLFxuICAgIGxlYXZlczogW11cbiAgfTtcbiAgaWYgKHRyYWNrKSB7XG4gICAgY29uc3QgbGVhZkluZm8gPSB7XG4gICAgICBzY3JpcHQsXG4gICAgICBsZWFmVmVyc2lvbixcbiAgICAgIG1lcmtsZUJyYW5jaDogW11cbiAgICB9O1xuICAgIG5vZGUubGVhdmVzLnB1c2gobGVhZkluZm8pO1xuICB9XG4gIHRoaXMuX2luc2VydE5vZGUobm9kZSwgZGVwdGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuT3V0cHV0LnByb3RvdHlwZS5faW5zZXJ0Tm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGRlcHRoKSB7XG4gICQuY2hlY2tBcmd1bWVudChkZXB0aCA+PSAwICYmIGRlcHRoIDw9IEludGVycHJldGVyLlRBUFJPT1RfQ09OVFJPTF9NQVhfTk9ERV9DT1VOVCwgJ2ludmFsaWQgZGVwdGgnKTtcbiAgLyogV2UgY2Fubm90IGluc2VydCBhIGxlYWYgYXQgYSBsb3dlciBkZXB0aCB3aGlsZSBhIGRlZXBlciBicmFuY2ggaXMgdW5maW5pc2hlZC4gRG9pbmdcbiAgICogc28gd291bGQgbWVhbiB0aGUgQWRkKCkgaW52b2NhdGlvbnMgZG8gbm90IGNvcnJlc3BvbmQgdG8gYSBERlMgdHJhdmVyc2FsIG9mIGFcbiAgICogYmluYXJ5IHRyZWUuICovXG4gIGlmIChkZXB0aCArIDEgPCB0aGlzLl9icmFuY2gubGVuZ3RoKSB7XG4gICAgdGhpcy5pc1ZhbGlkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qIEFzIGxvbmcgYXMgYW4gZW50cnkgaW4gdGhlIGJyYW5jaCBleGlzdHMgYXQgdGhlIHNwZWNpZmllZCBkZXB0aCwgY29tYmluZSBpdCBhbmQgcHJvcGFnYXRlIHVwLlxuICAgKiBUaGUgJ25vZGUnIHZhcmlhYmxlIGlzIG92ZXJ3cml0dGVuIGhlcmUgd2l0aCB0aGUgbmV3bHkgY29tYmluZWQgbm9kZS4gKi9cbiAgd2hpbGUgKHRoaXMuaXNWYWxpZCAmJiB0aGlzLl9icmFuY2gubGVuZ3RoID4gZGVwdGggJiYgdGhpcy5fYnJhbmNoW2RlcHRoXSkge1xuICAgIG5vZGUgPSB0aGlzLl9jb21iaW5lTm9kZXMobm9kZSwgdGhpcy5fYnJhbmNoW2RlcHRoXSk7XG4gICAgdGhpcy5fYnJhbmNoID0gdGhpcy5fYnJhbmNoLnNsaWNlKDAsIHRoaXMuX2JyYW5jaC5sZW5ndGggLSAyKTtcbiAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgdGhpcy5pc1ZhbGlkID0gZmFsc2U7IC8qIENhbid0IHByb3BhZ2F0ZSBmdXJ0aGVyIHVwIHRoYW4gdGhlIHJvb3QgKi9cbiAgICB9XG4gICAgZGVwdGgtLTtcbiAgfVxuICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgLyogTWFrZSBzdXJlIHRoZSBicmFuY2ggaXMgYmlnIGVub3VnaCB0byBwbGFjZSB0aGUgbmV3IG5vZGUuICovXG4gICAgaWYgKHRoaXMuX2JyYW5jaC5sZW5ndGggPD0gZGVwdGgpIHtcbiAgICAgIHRoaXMuX2JyYW5jaCA9IHRoaXMuX2JyYW5jaC5zbGljZSgwLCBkZXB0aCArIDEpO1xuICAgIH1cbiAgICAkLmNoZWNrU3RhdGUoIXRoaXMuX25vZGVzW2RlcHRoXSk7XG4gICAgbV9icmFuY2hbZGVwdGhdID0gbm9kZTtcbiAgfVxufTtcblxuT3V0cHV0LnByb3RvdHlwZS5fY29tYmluZU5vZGVzID0gZnVuY3Rpb24oYSwgYikge1xuICBjb25zdCByZXQgPSB7XG4gICAgaGFzaDogbnVsbCxcbiAgICBsZWF2ZXM6IFtdXG4gIH07XG4gIC8qIEl0ZXJhdGUgb3ZlciBhbGwgdHJhY2tlZCBsZWF2ZXMgaW4gYSwgYWRkIGIncyBoYXNoIHRvIHRoZWlyIE1lcmtsZSBicmFuY2gsIGFuZCBtb3ZlIHRoZW0gdG8gcmV0LiAqL1xuICBmb3IgKGxldCBsZWFmIG9mIGEubGVhdmVzKSB7XG4gICAgbGVhZi5tZXJrbGVCcmFuY2gucHVzaChiLmhhc2gpO1xuICAgIHJldC5sZWF2ZXMucHVzaChsZWFmKTtcbiAgfVxuICAvKiBJdGVyYXRlIG92ZXIgYWxsIHRyYWNrZWQgbGVhdmVzIGluIGIsIGFkZCBhJ3MgaGFzaCB0byB0aGVpciBNZXJrbGUgYnJhbmNoLCBhbmQgbW92ZSB0aGVtIHRvIHJldC4gKi9cbiAgZm9yIChsZXQgbGVhZiBvZiBiLmxlYXZlcykge1xuICAgIGxlYWYubWVya2xlQnJhbmNoLnB1c2goYS5oYXNoKTtcbiAgICByZXQubGVhdmVzLnB1c2gobGVhZik7XG4gIH1cbiAgLyogTGV4aWNvZ3JhcGhpY2FsbHkgc29ydCBhIGFuZCBiJ3MgaGFzaCwgYW5kIGNvbXB1dGUgcGFyZW50IGhhc2guICovXG4gIGlmIChhLmhhc2guY29tcGFyZShiLmhhc2gpID09PSAtMSkge1xuICAgIHJldC5oYXNoID0gVGFnZ2VkSGFzaC5UQVBCUkFOQ0gud3JpdGUoYS5oYXNoKS53cml0ZShiLmhhc2gpLmZpbmFsaXplKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0Lmhhc2ggPSBUYWdnZWRIYXNoLlRBUEJSQU5DSC53cml0ZShiLmhhc2gpLndyaXRlKGEuaGFzaCkuZmluYWxpemUoKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG4vKipcbiAqIEZpbmFsaXplIHRoZSBjb25zdHJ1Y3Rpb24uIENhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIElzQ29tcGxldGUoKSBpcyB0cnVlLlxuICogIGludGVybmFsX2tleS5Jc0Z1bGx5VmFsaWQoKSBtdXN0IGJlIHRydWUuXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcHViS2V5IFxuICovXG5PdXRwdXQucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24ocHViS2V5KSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLmlzQ29tcGxldGUgPT09IHRydWUsICdmaW5hbGl6ZSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiBpc0NvbXBsZXRlIGlzIHRydWUnKTtcbiAgY29uc3QgcmV0ID0gcHViS2V5LmNyZWF0ZVRhcFR3ZWFrKHRoaXMuX2JyYW5jaC5sZW5ndGggPT09IDAgPyBudWxsIDogdGhpcy5fYnJhbmNoWzBdLmhhc2gpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE91dHB1dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js":
/*!*************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/sighash.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Output = __webpack_require__(/*! ./output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar ECDSA = __webpack_require__(/*! ../crypto/ecdsa */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\n  var Transaction = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js\");\n  var Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js\");\n\n  // Convert a string to a number\n  inputNumber = parseInt(inputNumber);\n\n  var i;\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n  subscript.removeCodeseparators();\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter()\n    .write(txcopy.toBuffer())\n    .writeInt32LE(sighashType)\n    .toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript) {\n  let hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\n  const sig = ECDSA.sign(hashbuf, privateKey, { endian: 'little' });\n  sig.nhashtype = sighashType;\n  return sig;\n};\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript) {\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\n  return ECDSA.verify(hashbuf, signature, publicKey, { endian: 'little' });\n};\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMscUZBQXFCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQyx1RUFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsNEVBQVU7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxTQUFTLG1CQUFPLENBQUMsdUVBQWM7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxZQUFZLG1CQUFPLENBQUMsNkVBQWlCO0FBQ3JDLFFBQVEsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDdkMsUUFBUSxtQkFBTyxDQUFDLHFEQUFROztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFlO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyxnRkFBUzs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQkFBa0I7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vc2lnaGFzaC5qcz8zODU5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL2NyeXB0by9zaWduYXR1cmUnKTtcbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuL291dHB1dCcpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEJOID0gcmVxdWlyZSgnLi4vY3J5cHRvL2JuJyk7XG52YXIgSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by9oYXNoJyk7XG52YXIgRUNEU0EgPSByZXF1aXJlKCcuLi9jcnlwdG8vZWNkc2EnKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vdXRpbC9wcmVjb25kaXRpb25zJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgU0lHSEFTSF9TSU5HTEVfQlVHID0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnO1xudmFyIEJJVFNfNjRfT04gPSAnZmZmZmZmZmZmZmZmZmZmZic7XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBvZiBsZW5ndGggMzIgYnl0ZXMgd2l0aCB0aGUgaGFzaCB0aGF0IG5lZWRzIHRvIGJlIHNpZ25lZFxuICogZm9yIE9QX0NIRUNLU0lHLlxuICpcbiAqIEBuYW1lIFNpZ25pbmcuc2lnaGFzaFxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gdGhlIHRyYW5zYWN0aW9uIHRvIHNpZ25cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWdoYXNoVHlwZSB0aGUgdHlwZSBvZiB0aGUgaGFzaFxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0TnVtYmVyIHRoZSBpbnB1dCBpbmRleCBmb3IgdGhlIHNpZ25hdHVyZVxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdCB0aGUgc2NyaXB0IHRoYXQgd2lsbCBiZSBzaWduZWRcbiAqL1xudmFyIHNpZ2hhc2ggPSBmdW5jdGlvbiBzaWdoYXNoKHRyYW5zYWN0aW9uLCBzaWdoYXNoVHlwZSwgaW5wdXROdW1iZXIsIHN1YnNjcmlwdCkge1xuICB2YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uJyk7XG4gIHZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcblxuICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgbnVtYmVyXG4gIGlucHV0TnVtYmVyID0gcGFyc2VJbnQoaW5wdXROdW1iZXIpO1xuXG4gIHZhciBpO1xuICAvLyBDb3B5IHRyYW5zYWN0aW9uXG4gIHZhciB0eGNvcHkgPSBUcmFuc2FjdGlvbi5zaGFsbG93Q29weSh0cmFuc2FjdGlvbik7XG5cbiAgLy8gQ29weSBzY3JpcHRcbiAgc3Vic2NyaXB0ID0gbmV3IFNjcmlwdChzdWJzY3JpcHQpO1xuICBzdWJzY3JpcHQucmVtb3ZlQ29kZXNlcGFyYXRvcnMoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdHhjb3B5LmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIC8vIEJsYW5rIHNpZ25hdHVyZXMgZm9yIG90aGVyIGlucHV0c1xuICAgIHR4Y29weS5pbnB1dHNbaV0gPSBuZXcgSW5wdXQodHhjb3B5LmlucHV0c1tpXSkuc2V0U2NyaXB0KFNjcmlwdC5lbXB0eSgpKTtcbiAgfVxuXG4gIHR4Y29weS5pbnB1dHNbaW5wdXROdW1iZXJdID0gbmV3IElucHV0KHR4Y29weS5pbnB1dHNbaW5wdXROdW1iZXJdKS5zZXRTY3JpcHQoc3Vic2NyaXB0KTtcblxuICBpZiAoKHNpZ2hhc2hUeXBlICYgMzEpID09PSBTaWduYXR1cmUuU0lHSEFTSF9OT05FIHx8XG4gICAgKHNpZ2hhc2hUeXBlICYgMzEpID09PSBTaWduYXR1cmUuU0lHSEFTSF9TSU5HTEUpIHtcblxuICAgIC8vIGNsZWFyIGFsbCBzZXF1ZW5jZU51bWJlcnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHhjb3B5LmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgIT09IGlucHV0TnVtYmVyKSB7XG4gICAgICAgIHR4Y29weS5pbnB1dHNbaV0uc2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc2lnaGFzaFR5cGUgJiAzMSkgPT09IFNpZ25hdHVyZS5TSUdIQVNIX05PTkUpIHtcbiAgICB0eGNvcHkub3V0cHV0cyA9IFtdO1xuXG4gIH0gZWxzZSBpZiAoKHNpZ2hhc2hUeXBlICYgMzEpID09PSBTaWduYXR1cmUuU0lHSEFTSF9TSU5HTEUpIHtcbiAgICAvLyBUaGUgU0lHSEFTSF9TSU5HTEUgYnVnLlxuICAgIC8vIGh0dHBzOi8vYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz0yNjA1OTUuMFxuICAgIGlmIChpbnB1dE51bWJlciA+PSB0eGNvcHkub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShTSUdIQVNIX1NJTkdMRV9CVUcsICdoZXgnKTtcbiAgICB9XG5cbiAgICB0eGNvcHkub3V0cHV0cy5sZW5ndGggPSBpbnB1dE51bWJlciArIDE7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXROdW1iZXI7IGkrKykge1xuICAgICAgdHhjb3B5Lm91dHB1dHNbaV0gPSBuZXcgT3V0cHV0KHtcbiAgICAgICAgc2F0b3NoaXM6IEJOLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oQklUU182NF9PTiwgJ2hleCcpKSxcbiAgICAgICAgc2NyaXB0OiBTY3JpcHQuZW1wdHkoKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNpZ2hhc2hUeXBlICYgU2lnbmF0dXJlLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSB7XG4gICAgdHhjb3B5LmlucHV0cyA9IFt0eGNvcHkuaW5wdXRzW2lucHV0TnVtYmVyXV07XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcldyaXRlcigpXG4gICAgLndyaXRlKHR4Y29weS50b0J1ZmZlcigpKVxuICAgIC53cml0ZUludDMyTEUoc2lnaGFzaFR5cGUpXG4gICAgLnRvQnVmZmVyKCk7XG4gIHZhciByZXQgPSBIYXNoLnNoYTI1NnNoYTI1NihidWYpO1xuICByZXQgPSBuZXcgQnVmZmVyUmVhZGVyKHJldCkucmVhZFJldmVyc2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc2lnbmF0dXJlXG4gKlxuICogQG5hbWUgU2lnbmluZy5zaWduXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge251bWJlcn0gc2lnaGFzaFxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0SW5kZXhcbiAqIEBwYXJhbSB7U2NyaXB0fSBzdWJzY3JpcHRcbiAqIEByZXR1cm4ge1NpZ25hdHVyZX1cbiAqL1xuZnVuY3Rpb24gc2lnbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgc2lnaGFzaFR5cGUsIGlucHV0SW5kZXgsIHN1YnNjcmlwdCkge1xuICBsZXQgaGFzaGJ1ZiA9IHNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dEluZGV4LCBzdWJzY3JpcHQpO1xuICBjb25zdCBzaWcgPSBFQ0RTQS5zaWduKGhhc2hidWYsIHByaXZhdGVLZXksIHsgZW5kaWFuOiAnbGl0dGxlJyB9KTtcbiAgc2lnLm5oYXNodHlwZSA9IHNpZ2hhc2hUeXBlO1xuICByZXR1cm4gc2lnO1xufTtcblxuLyoqXG4gKiBWZXJpZnkgYSBzaWduYXR1cmVcbiAqXG4gKiBAbmFtZSBTaWduaW5nLnZlcmlmeVxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U2lnbmF0dXJlfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dEluZGV4XG4gKiBAcGFyYW0ge1NjcmlwdH0gc3Vic2NyaXB0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2ZXJpZnkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgcHVibGljS2V5LCBpbnB1dEluZGV4LCBzdWJzY3JpcHQpIHtcbiAgJC5jaGVja0FyZ3VtZW50KCFfLmlzVW5kZWZpbmVkKHRyYW5zYWN0aW9uKSwgXCJUcmFuc2FjdGlvbiBVbmRlZmluZWRcIik7XG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZChzaWduYXR1cmUpICYmICFfLmlzVW5kZWZpbmVkKHNpZ25hdHVyZS5uaGFzaHR5cGUpLCBcIlNpZ25hdHVyZSBVbmRlZmluZWRcIik7XG5cbiAgbGV0IGhhc2hidWYgPSBzaWdoYXNoKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUubmhhc2h0eXBlLCBpbnB1dEluZGV4LCBzdWJzY3JpcHQpO1xuICByZXR1cm4gRUNEU0EudmVyaWZ5KGhhc2hidWYsIHNpZ25hdHVyZSwgcHVibGljS2V5LCB7IGVuZGlhbjogJ2xpdHRsZScgfSk7XG59O1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgU2lnbmluZ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2lnaGFzaDogc2lnaGFzaCxcbiAgc2lnbjogc2lnbixcbiAgdmVyaWZ5OiB2ZXJpZnlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* jshint maxparams:5 */\n\nconst Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nconst BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nconst Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nconst Schnorr = __webpack_require__(/*! ../crypto/schnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/schnorr.js\");\nconst $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nconst TaggedHash = __webpack_require__(/*! ../crypto/taggedhash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/taggedhash.js\");\nconst PrivateKey = __webpack_require__(/*! ../privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness v1 programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {Number} sighashType the type of the hash\n * @param {Number} inputNumber the input index for the signature\n * @param {Number} sigversion Taproot or Tapscript version number\n * @param {Object} execdata Object with directives and data for creating the signature hash\n */\nfunction _signatureHash(transaction, sighashType, inputNumber, sigversion, execdata) {\n  let extFlag, keyVersion;\n\n  switch (sigversion) {\n    case Signature.Version.TAPROOT:\n      extFlag = 0;\n      // keyVersion is not used and left uninitialized.\n      break;\n    case Signature.Version.TAPSCRIPT:\n      extFlag = 1;\n      // keyVersion must be 0 for now, representing the current version of\n      // 32-byte public keys in the tapscript signature opcode execution.\n      // An upgradable public key version (with a size not 32-byte) may\n      // request a different keyVersion with a new sigversion.\n      keyVersion = 0;\n      break;\n    default:\n      return false;\n  }\n  $.checkArgument(inputNumber < transaction.inputs.length, 'inputNumber is greater than number of inputs');\n\n  const ss = TaggedHash.TAPSIGHASH;\n\n  // Epoch\n  ss.writeUInt8(0);\n\n  // Hash type\n  const outputType = (sighashType == Signature.SIGHASH_DEFAULT) ? Signature.SIGHASH_ALL : (sighashType & Signature.SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n  const inputType = sighashType & Signature.SIGHASH_INPUT_MASK;\n  if (!(sighashType <= 0x03 || (sighashType >= 0x81 && sighashType <= 0x83))) { // Check valid sighashtype (Signature.SIGHASH_*)\n    return false;\n  }\n  ss.writeUInt8(sighashType);\n\n  // Transaction level data\n  ss.writeInt32LE(transaction.version);\n  ss.writeUInt32LE(transaction.nLockTime);\n  if (inputType !== Signature.SIGHASH_ANYONECANPAY) {\n    const prevoutsBW = new BufferWriter();\n    const spentAmountsBW = new BufferWriter();\n    const spentScriptsBW = new BufferWriter();\n    const sequencesBW = new BufferWriter();\n\n    for(let vin of transaction.inputs) {\n      prevoutsBW.writeReverse(vin.prevTxId);\n      prevoutsBW.writeInt32LE(vin.outputIndex);\n\n      spentAmountsBW.writeUInt64LEBN(vin.output._satoshisBN);\n\n      const scriptBuf = vin.output.script.toBuffer();\n      spentScriptsBW.writeUInt8(scriptBuf.length);\n      spentScriptsBW.write(scriptBuf);\n\n      sequencesBW.writeUInt32LE(vin.sequenceNumber);\n    }\n\n    // ss << cache.m_prevouts_single_hash;\n    const prevoutsSingleHash = Hash.sha256(prevoutsBW.toBuffer());\n    ss.write(prevoutsSingleHash);\n\n    // ss << cache.m_spent_amounts_single_hash;\n    const spentAmountsSingleHash = Hash.sha256(spentAmountsBW.toBuffer());\n    ss.write(spentAmountsSingleHash);\n\n    // ss << cache.m_spent_scripts_single_hash;\n    const spentScriptsSingleHash = Hash.sha256(spentScriptsBW.toBuffer());\n    ss.write(spentScriptsSingleHash);\n\n    // ss << cache.m_sequences_single_hash;\n    const sequencesSingleHash = Hash.sha256(sequencesBW.toBuffer());\n    ss.write(sequencesSingleHash);\n  }\n  if (outputType === Signature.SIGHASH_ALL) {\n    const outputsBW = new BufferWriter();\n    for (let vout of transaction.outputs) {\n      outputsBW.write(vout.toBufferWriter().toBuffer());\n    }\n    // ss << cache.m_outputs_single_hash;\n    const outputsSingleHash = Hash.sha256(outputsBW.toBuffer());\n    ss.write(outputsSingleHash);\n  }\n\n  // Data about the input/prevout being spent\n  $.checkArgument(execdata.annexInit, 'missing or invalid annexInit');\n  const spendType = (extFlag << 1) + (execdata.annexPresent ? 1 : 0); // The low bit indicates whether an annex is present.\n  ss.writeUInt8(spendType);\n  if (inputType === Signature.SIGHASH_ANYONECANPAY) {\n    // ss << tx_to.vin[in_pos].prevout;\n    const buf = new BufferWriter();\n    buf.writeReverse(transaction.inputs[inputNumber].prevTxId);\n    buf.writeInt32LE(transaction.inputs[inputNumber].outputIndex);\n    ss.write(buf.toBuffer());\n    // ss << cache.m_spent_outputs[inputNumber];\n    ss.write(transaction.inputs[inputNumber].output.toBufferWriter().toBuffer());\n    ss.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n  } else {\n    ss.writeUInt32LE(inputNumber);\n  }\n  if (execdata.annexPresent) {\n    ss.write(execdata.annexHash);\n  }\n\n  // Data about the output (if only one).\n  if (outputType === Signature.SIGHASH_SINGLE) {\n    if (inputNumber >= transaction.outputs.length) {\n      return false;\n    }\n    const bw = new BufferWriter();\n    bw.writeUInt64LEBN(transaction.outputs[inputNumber]._satoshisBN);\n    const buf = transaction.outputs[inputNumber].script.toBuffer();\n    bw.writeVarintNum(buf.length);\n    bw.write(buf);\n    ss.write(Hash.sha256(bw.toBuffer()));\n  }\n\n  // Additional data for BIP 342 signatures\n  if (sigversion == Signature.Version.TAPSCRIPT) {\n    $.checkArgument(execdata.tapleafHashInit, 'missing or invalid tapleafHashInit');\n    ss.write(execdata.tapleafHash);\n    ss.writeUInt8(keyVersion);\n    $.checkArgument(execdata.codeseparatorPosInit, 'missing or invalid codeseparatorPosInit');\n    ss.writeUInt32LE(execdata.codeseparatorPos);\n  }\n\n  // Return the SHA256 hash\n  return ss.finalize();\n};\n\n\nfunction _getExecData(sigversion, leafHash) {\n  const execdata = { annexInit: true, annexPresent: false };\n  if (sigversion === Signature.Version.TAPSCRIPT) {\n    execdata.codeseparatorPosInit = true;\n    execdata.codeseparatorPos = 0xFFFFFFFF; // Only support non-OP_CODESEPARATOR BIP342 signing for now.\n    if (!leafHash) return false; // BIP342 signing needs leaf hash.\n    execdata.tapleafHashInit = true;\n    execdata.tapleafHash = leafHash;\n  }\n  return execdata;\n}\n\n\n/**\n * Create a Schnorr signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {Buffer|BN|PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {number} sigversion\n * @param {Buffer} leafHash\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, sigversion, leafHash) {\n  $.checkArgument(sigversion === Signature.Version.TAPROOT || sigversion === Signature.Version.TAPSCRIPT, 'Invalid sigversion');\n  \n  const execdata = _getExecData(sigversion, leafHash);\n  const hashbuf = _signatureHash(transaction, sighashType, inputIndex, sigversion, execdata);\n  if (!hashbuf) {\n    return false;\n  }\n  const sig = Schnorr.sign(privateKey, hashbuf);\n  if (sighashType !== Signature.SIGHASH_DEFAULT) {\n    return Buffer.concat([sig, Buffer.from([sighashType])]); // 65 bytes\n  }\n  return sig; // 64 bytes\n};\n\n\n/**\n * Verify a Schnorr signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {Number} inputIndex\n * @param {object|Buffer|null} execdata If given, can be full execdata object or just the leafHash buffer\n * @return {Boolean}\n */\nfunction verify(transaction, signature, publicKey, sigversion, inputIndex, execdata) {\n  $.checkArgument(transaction != null, 'Transaction Undefined');\n\n  if (!execdata || Buffer.isBuffer(execdata)) {\n    const leafHash = execdata;\n    execdata = _getExecData(sigversion, leafHash);\n  }\n\n  $.checkArgument(execdata.annexInit, 'invalid execdata');\n\n  const hashbuf = _signatureHash(transaction, signature.nhashtype, inputIndex, sigversion, execdata);\n  if (!hashbuf) {\n    return false;\n  }\n  const verified = Schnorr.verify(publicKey, hashbuf, signature);\n  return verified;\n};\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sign: sign,\n  verify: verify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2hzY2hub3JyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFxQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBbUI7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLHlGQUF1QjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMseUVBQWU7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlJQUF5STtBQUN6STtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsY0FBYztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLG9CQUFvQjtBQUMvQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2hzY2hub3JyLmpzP2E1MDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBqc2hpbnQgbWF4cGFyYW1zOjUgKi9cblxuY29uc3QgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xuY29uc3QgQnVmZmVyV3JpdGVyID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcvYnVmZmVyd3JpdGVyJyk7XG5jb25zdCBIYXNoID0gcmVxdWlyZSgnLi4vY3J5cHRvL2hhc2gnKTtcbmNvbnN0IFNjaG5vcnIgPSByZXF1aXJlKCcuLi9jcnlwdG8vc2Nobm9ycicpO1xuY29uc3QgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xuY29uc3QgVGFnZ2VkSGFzaCA9IHJlcXVpcmUoJy4uL2NyeXB0by90YWdnZWRoYXNoJyk7XG5jb25zdCBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZWtleScpO1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgb2YgbGVuZ3RoIDMyIGJ5dGVzIHdpdGggdGhlIGhhc2ggdGhhdCBuZWVkcyB0byBiZSBzaWduZWRcbiAqIGZvciB3aXRuZXNzIHYxIHByb2dyYW1zIGFzIGRlZmluZWQgYnk6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuICpcbiAqIEBuYW1lIFNpZ25pbmcuc2lnaGFzaFxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gdGhlIHRyYW5zYWN0aW9uIHRvIHNpZ25cbiAqIEBwYXJhbSB7TnVtYmVyfSBzaWdoYXNoVHlwZSB0aGUgdHlwZSBvZiB0aGUgaGFzaFxuICogQHBhcmFtIHtOdW1iZXJ9IGlucHV0TnVtYmVyIHRoZSBpbnB1dCBpbmRleCBmb3IgdGhlIHNpZ25hdHVyZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNpZ3ZlcnNpb24gVGFwcm9vdCBvciBUYXBzY3JpcHQgdmVyc2lvbiBudW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBleGVjZGF0YSBPYmplY3Qgd2l0aCBkaXJlY3RpdmVzIGFuZCBkYXRhIGZvciBjcmVhdGluZyB0aGUgc2lnbmF0dXJlIGhhc2hcbiAqL1xuZnVuY3Rpb24gX3NpZ25hdHVyZUhhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dE51bWJlciwgc2lndmVyc2lvbiwgZXhlY2RhdGEpIHtcbiAgbGV0IGV4dEZsYWcsIGtleVZlcnNpb247XG5cbiAgc3dpdGNoIChzaWd2ZXJzaW9uKSB7XG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09UOlxuICAgICAgZXh0RmxhZyA9IDA7XG4gICAgICAvLyBrZXlWZXJzaW9uIGlzIG5vdCB1c2VkIGFuZCBsZWZ0IHVuaW5pdGlhbGl6ZWQuXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVDpcbiAgICAgIGV4dEZsYWcgPSAxO1xuICAgICAgLy8ga2V5VmVyc2lvbiBtdXN0IGJlIDAgZm9yIG5vdywgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHZlcnNpb24gb2ZcbiAgICAgIC8vIDMyLWJ5dGUgcHVibGljIGtleXMgaW4gdGhlIHRhcHNjcmlwdCBzaWduYXR1cmUgb3Bjb2RlIGV4ZWN1dGlvbi5cbiAgICAgIC8vIEFuIHVwZ3JhZGFibGUgcHVibGljIGtleSB2ZXJzaW9uICh3aXRoIGEgc2l6ZSBub3QgMzItYnl0ZSkgbWF5XG4gICAgICAvLyByZXF1ZXN0IGEgZGlmZmVyZW50IGtleVZlcnNpb24gd2l0aCBhIG5ldyBzaWd2ZXJzaW9uLlxuICAgICAga2V5VmVyc2lvbiA9IDA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gICQuY2hlY2tBcmd1bWVudChpbnB1dE51bWJlciA8IHRyYW5zYWN0aW9uLmlucHV0cy5sZW5ndGgsICdpbnB1dE51bWJlciBpcyBncmVhdGVyIHRoYW4gbnVtYmVyIG9mIGlucHV0cycpO1xuXG4gIGNvbnN0IHNzID0gVGFnZ2VkSGFzaC5UQVBTSUdIQVNIO1xuXG4gIC8vIEVwb2NoXG4gIHNzLndyaXRlVUludDgoMCk7XG5cbiAgLy8gSGFzaCB0eXBlXG4gIGNvbnN0IG91dHB1dFR5cGUgPSAoc2lnaGFzaFR5cGUgPT0gU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVCkgPyBTaWduYXR1cmUuU0lHSEFTSF9BTEwgOiAoc2lnaGFzaFR5cGUgJiBTaWduYXR1cmUuU0lHSEFTSF9PVVRQVVRfTUFTSyk7IC8vIERlZmF1bHQgKG5vIHNpZ2hhc2ggYnl0ZSkgaXMgZXF1aXZhbGVudCB0byBTSUdIQVNIX0FMTFxuICBjb25zdCBpbnB1dFR5cGUgPSBzaWdoYXNoVHlwZSAmIFNpZ25hdHVyZS5TSUdIQVNIX0lOUFVUX01BU0s7XG4gIGlmICghKHNpZ2hhc2hUeXBlIDw9IDB4MDMgfHwgKHNpZ2hhc2hUeXBlID49IDB4ODEgJiYgc2lnaGFzaFR5cGUgPD0gMHg4MykpKSB7IC8vIENoZWNrIHZhbGlkIHNpZ2hhc2h0eXBlIChTaWduYXR1cmUuU0lHSEFTSF8qKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzcy53cml0ZVVJbnQ4KHNpZ2hhc2hUeXBlKTtcblxuICAvLyBUcmFuc2FjdGlvbiBsZXZlbCBkYXRhXG4gIHNzLndyaXRlSW50MzJMRSh0cmFuc2FjdGlvbi52ZXJzaW9uKTtcbiAgc3Mud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5uTG9ja1RpbWUpO1xuICBpZiAoaW5wdXRUeXBlICE9PSBTaWduYXR1cmUuU0lHSEFTSF9BTllPTkVDQU5QQVkpIHtcbiAgICBjb25zdCBwcmV2b3V0c0JXID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgIGNvbnN0IHNwZW50QW1vdW50c0JXID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgIGNvbnN0IHNwZW50U2NyaXB0c0JXID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgIGNvbnN0IHNlcXVlbmNlc0JXID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuXG4gICAgZm9yKGxldCB2aW4gb2YgdHJhbnNhY3Rpb24uaW5wdXRzKSB7XG4gICAgICBwcmV2b3V0c0JXLndyaXRlUmV2ZXJzZSh2aW4ucHJldlR4SWQpO1xuICAgICAgcHJldm91dHNCVy53cml0ZUludDMyTEUodmluLm91dHB1dEluZGV4KTtcblxuICAgICAgc3BlbnRBbW91bnRzQlcud3JpdGVVSW50NjRMRUJOKHZpbi5vdXRwdXQuX3NhdG9zaGlzQk4pO1xuXG4gICAgICBjb25zdCBzY3JpcHRCdWYgPSB2aW4ub3V0cHV0LnNjcmlwdC50b0J1ZmZlcigpO1xuICAgICAgc3BlbnRTY3JpcHRzQlcud3JpdGVVSW50OChzY3JpcHRCdWYubGVuZ3RoKTtcbiAgICAgIHNwZW50U2NyaXB0c0JXLndyaXRlKHNjcmlwdEJ1Zik7XG5cbiAgICAgIHNlcXVlbmNlc0JXLndyaXRlVUludDMyTEUodmluLnNlcXVlbmNlTnVtYmVyKTtcbiAgICB9XG5cbiAgICAvLyBzcyA8PCBjYWNoZS5tX3ByZXZvdXRzX3NpbmdsZV9oYXNoO1xuICAgIGNvbnN0IHByZXZvdXRzU2luZ2xlSGFzaCA9IEhhc2guc2hhMjU2KHByZXZvdXRzQlcudG9CdWZmZXIoKSk7XG4gICAgc3Mud3JpdGUocHJldm91dHNTaW5nbGVIYXNoKTtcblxuICAgIC8vIHNzIDw8IGNhY2hlLm1fc3BlbnRfYW1vdW50c19zaW5nbGVfaGFzaDtcbiAgICBjb25zdCBzcGVudEFtb3VudHNTaW5nbGVIYXNoID0gSGFzaC5zaGEyNTYoc3BlbnRBbW91bnRzQlcudG9CdWZmZXIoKSk7XG4gICAgc3Mud3JpdGUoc3BlbnRBbW91bnRzU2luZ2xlSGFzaCk7XG5cbiAgICAvLyBzcyA8PCBjYWNoZS5tX3NwZW50X3NjcmlwdHNfc2luZ2xlX2hhc2g7XG4gICAgY29uc3Qgc3BlbnRTY3JpcHRzU2luZ2xlSGFzaCA9IEhhc2guc2hhMjU2KHNwZW50U2NyaXB0c0JXLnRvQnVmZmVyKCkpO1xuICAgIHNzLndyaXRlKHNwZW50U2NyaXB0c1NpbmdsZUhhc2gpO1xuXG4gICAgLy8gc3MgPDwgY2FjaGUubV9zZXF1ZW5jZXNfc2luZ2xlX2hhc2g7XG4gICAgY29uc3Qgc2VxdWVuY2VzU2luZ2xlSGFzaCA9IEhhc2guc2hhMjU2KHNlcXVlbmNlc0JXLnRvQnVmZmVyKCkpO1xuICAgIHNzLndyaXRlKHNlcXVlbmNlc1NpbmdsZUhhc2gpO1xuICB9XG4gIGlmIChvdXRwdXRUeXBlID09PSBTaWduYXR1cmUuU0lHSEFTSF9BTEwpIHtcbiAgICBjb25zdCBvdXRwdXRzQlcgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgZm9yIChsZXQgdm91dCBvZiB0cmFuc2FjdGlvbi5vdXRwdXRzKSB7XG4gICAgICBvdXRwdXRzQlcud3JpdGUodm91dC50b0J1ZmZlcldyaXRlcigpLnRvQnVmZmVyKCkpO1xuICAgIH1cbiAgICAvLyBzcyA8PCBjYWNoZS5tX291dHB1dHNfc2luZ2xlX2hhc2g7XG4gICAgY29uc3Qgb3V0cHV0c1NpbmdsZUhhc2ggPSBIYXNoLnNoYTI1NihvdXRwdXRzQlcudG9CdWZmZXIoKSk7XG4gICAgc3Mud3JpdGUob3V0cHV0c1NpbmdsZUhhc2gpO1xuICB9XG5cbiAgLy8gRGF0YSBhYm91dCB0aGUgaW5wdXQvcHJldm91dCBiZWluZyBzcGVudFxuICAkLmNoZWNrQXJndW1lbnQoZXhlY2RhdGEuYW5uZXhJbml0LCAnbWlzc2luZyBvciBpbnZhbGlkIGFubmV4SW5pdCcpO1xuICBjb25zdCBzcGVuZFR5cGUgPSAoZXh0RmxhZyA8PCAxKSArIChleGVjZGF0YS5hbm5leFByZXNlbnQgPyAxIDogMCk7IC8vIFRoZSBsb3cgYml0IGluZGljYXRlcyB3aGV0aGVyIGFuIGFubmV4IGlzIHByZXNlbnQuXG4gIHNzLndyaXRlVUludDgoc3BlbmRUeXBlKTtcbiAgaWYgKGlucHV0VHlwZSA9PT0gU2lnbmF0dXJlLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSB7XG4gICAgLy8gc3MgPDwgdHhfdG8udmluW2luX3Bvc10ucHJldm91dDtcbiAgICBjb25zdCBidWYgPSBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgYnVmLndyaXRlUmV2ZXJzZSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLnByZXZUeElkKTtcbiAgICBidWYud3JpdGVJbnQzMkxFKHRyYW5zYWN0aW9uLmlucHV0c1tpbnB1dE51bWJlcl0ub3V0cHV0SW5kZXgpO1xuICAgIHNzLndyaXRlKGJ1Zi50b0J1ZmZlcigpKTtcbiAgICAvLyBzcyA8PCBjYWNoZS5tX3NwZW50X291dHB1dHNbaW5wdXROdW1iZXJdO1xuICAgIHNzLndyaXRlKHRyYW5zYWN0aW9uLmlucHV0c1tpbnB1dE51bWJlcl0ub3V0cHV0LnRvQnVmZmVyV3JpdGVyKCkudG9CdWZmZXIoKSk7XG4gICAgc3Mud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLnNlcXVlbmNlTnVtYmVyKTtcbiAgfSBlbHNlIHtcbiAgICBzcy53cml0ZVVJbnQzMkxFKGlucHV0TnVtYmVyKTtcbiAgfVxuICBpZiAoZXhlY2RhdGEuYW5uZXhQcmVzZW50KSB7XG4gICAgc3Mud3JpdGUoZXhlY2RhdGEuYW5uZXhIYXNoKTtcbiAgfVxuXG4gIC8vIERhdGEgYWJvdXQgdGhlIG91dHB1dCAoaWYgb25seSBvbmUpLlxuICBpZiAob3V0cHV0VHlwZSA9PT0gU2lnbmF0dXJlLlNJR0hBU0hfU0lOR0xFKSB7XG4gICAgaWYgKGlucHV0TnVtYmVyID49IHRyYW5zYWN0aW9uLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJ3ID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgIGJ3LndyaXRlVUludDY0TEVCTih0cmFuc2FjdGlvbi5vdXRwdXRzW2lucHV0TnVtYmVyXS5fc2F0b3NoaXNCTik7XG4gICAgY29uc3QgYnVmID0gdHJhbnNhY3Rpb24ub3V0cHV0c1tpbnB1dE51bWJlcl0uc2NyaXB0LnRvQnVmZmVyKCk7XG4gICAgYncud3JpdGVWYXJpbnROdW0oYnVmLmxlbmd0aCk7XG4gICAgYncud3JpdGUoYnVmKTtcbiAgICBzcy53cml0ZShIYXNoLnNoYTI1Nihidy50b0J1ZmZlcigpKSk7XG4gIH1cblxuICAvLyBBZGRpdGlvbmFsIGRhdGEgZm9yIEJJUCAzNDIgc2lnbmF0dXJlc1xuICBpZiAoc2lndmVyc2lvbiA9PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQpIHtcbiAgICAkLmNoZWNrQXJndW1lbnQoZXhlY2RhdGEudGFwbGVhZkhhc2hJbml0LCAnbWlzc2luZyBvciBpbnZhbGlkIHRhcGxlYWZIYXNoSW5pdCcpO1xuICAgIHNzLndyaXRlKGV4ZWNkYXRhLnRhcGxlYWZIYXNoKTtcbiAgICBzcy53cml0ZVVJbnQ4KGtleVZlcnNpb24pO1xuICAgICQuY2hlY2tBcmd1bWVudChleGVjZGF0YS5jb2Rlc2VwYXJhdG9yUG9zSW5pdCwgJ21pc3Npbmcgb3IgaW52YWxpZCBjb2Rlc2VwYXJhdG9yUG9zSW5pdCcpO1xuICAgIHNzLndyaXRlVUludDMyTEUoZXhlY2RhdGEuY29kZXNlcGFyYXRvclBvcyk7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIFNIQTI1NiBoYXNoXG4gIHJldHVybiBzcy5maW5hbGl6ZSgpO1xufTtcblxuXG5mdW5jdGlvbiBfZ2V0RXhlY0RhdGEoc2lndmVyc2lvbiwgbGVhZkhhc2gpIHtcbiAgY29uc3QgZXhlY2RhdGEgPSB7IGFubmV4SW5pdDogdHJ1ZSwgYW5uZXhQcmVzZW50OiBmYWxzZSB9O1xuICBpZiAoc2lndmVyc2lvbiA9PT0gU2lnbmF0dXJlLlZlcnNpb24uVEFQU0NSSVBUKSB7XG4gICAgZXhlY2RhdGEuY29kZXNlcGFyYXRvclBvc0luaXQgPSB0cnVlO1xuICAgIGV4ZWNkYXRhLmNvZGVzZXBhcmF0b3JQb3MgPSAweEZGRkZGRkZGOyAvLyBPbmx5IHN1cHBvcnQgbm9uLU9QX0NPREVTRVBBUkFUT1IgQklQMzQyIHNpZ25pbmcgZm9yIG5vdy5cbiAgICBpZiAoIWxlYWZIYXNoKSByZXR1cm4gZmFsc2U7IC8vIEJJUDM0MiBzaWduaW5nIG5lZWRzIGxlYWYgaGFzaC5cbiAgICBleGVjZGF0YS50YXBsZWFmSGFzaEluaXQgPSB0cnVlO1xuICAgIGV4ZWNkYXRhLnRhcGxlYWZIYXNoID0gbGVhZkhhc2g7XG4gIH1cbiAgcmV0dXJuIGV4ZWNkYXRhO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgU2Nobm9yciBzaWduYXR1cmVcbiAqXG4gKiBAbmFtZSBTaWduaW5nLnNpZ25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcnxCTnxQcml2YXRlS2V5fSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge251bWJlcn0gc2lnaGFzaFxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0SW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWd2ZXJzaW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbGVhZkhhc2hcbiAqIEByZXR1cm4ge1NpZ25hdHVyZX1cbiAqL1xuZnVuY3Rpb24gc2lnbih0cmFuc2FjdGlvbiwgcHJpdmF0ZUtleSwgc2lnaGFzaFR5cGUsIGlucHV0SW5kZXgsIHNpZ3ZlcnNpb24sIGxlYWZIYXNoKSB7XG4gICQuY2hlY2tBcmd1bWVudChzaWd2ZXJzaW9uID09PSBTaWduYXR1cmUuVmVyc2lvbi5UQVBST09UIHx8IHNpZ3ZlcnNpb24gPT09IFNpZ25hdHVyZS5WZXJzaW9uLlRBUFNDUklQVCwgJ0ludmFsaWQgc2lndmVyc2lvbicpO1xuICBcbiAgY29uc3QgZXhlY2RhdGEgPSBfZ2V0RXhlY0RhdGEoc2lndmVyc2lvbiwgbGVhZkhhc2gpO1xuICBjb25zdCBoYXNoYnVmID0gX3NpZ25hdHVyZUhhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dEluZGV4LCBzaWd2ZXJzaW9uLCBleGVjZGF0YSk7XG4gIGlmICghaGFzaGJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzaWcgPSBTY2hub3JyLnNpZ24ocHJpdmF0ZUtleSwgaGFzaGJ1Zik7XG4gIGlmIChzaWdoYXNoVHlwZSAhPT0gU2lnbmF0dXJlLlNJR0hBU0hfREVGQVVMVCkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtzaWcsIEJ1ZmZlci5mcm9tKFtzaWdoYXNoVHlwZV0pXSk7IC8vIDY1IGJ5dGVzXG4gIH1cbiAgcmV0dXJuIHNpZzsgLy8gNjQgYnl0ZXNcbn07XG5cblxuLyoqXG4gKiBWZXJpZnkgYSBTY2hub3JyIHNpZ25hdHVyZVxuICpcbiAqIEBuYW1lIFNpZ25pbmcudmVyaWZ5XG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmxpY0tleVxuICogQHBhcmFtIHtOdW1iZXJ9IGlucHV0SW5kZXhcbiAqIEBwYXJhbSB7b2JqZWN0fEJ1ZmZlcnxudWxsfSBleGVjZGF0YSBJZiBnaXZlbiwgY2FuIGJlIGZ1bGwgZXhlY2RhdGEgb2JqZWN0IG9yIGp1c3QgdGhlIGxlYWZIYXNoIGJ1ZmZlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHB1YmxpY0tleSwgc2lndmVyc2lvbiwgaW5wdXRJbmRleCwgZXhlY2RhdGEpIHtcbiAgJC5jaGVja0FyZ3VtZW50KHRyYW5zYWN0aW9uICE9IG51bGwsICdUcmFuc2FjdGlvbiBVbmRlZmluZWQnKTtcblxuICBpZiAoIWV4ZWNkYXRhIHx8IEJ1ZmZlci5pc0J1ZmZlcihleGVjZGF0YSkpIHtcbiAgICBjb25zdCBsZWFmSGFzaCA9IGV4ZWNkYXRhO1xuICAgIGV4ZWNkYXRhID0gX2dldEV4ZWNEYXRhKHNpZ3ZlcnNpb24sIGxlYWZIYXNoKTtcbiAgfVxuXG4gICQuY2hlY2tBcmd1bWVudChleGVjZGF0YS5hbm5leEluaXQsICdpbnZhbGlkIGV4ZWNkYXRhJyk7XG5cbiAgY29uc3QgaGFzaGJ1ZiA9IF9zaWduYXR1cmVIYXNoKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUubmhhc2h0eXBlLCBpbnB1dEluZGV4LCBzaWd2ZXJzaW9uLCBleGVjZGF0YSk7XG4gIGlmICghaGFzaGJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB2ZXJpZmllZCA9IFNjaG5vcnIudmVyaWZ5KHB1YmxpY0tleSwgaGFzaGJ1Ziwgc2lnbmF0dXJlKTtcbiAgcmV0dXJuIHZlcmlmaWVkO1xufTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIFNpZ25pbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpZ246IHNpZ24sXG4gIHZlcmlmeTogdmVyaWZ5XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/sighashwitness.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* jshint maxparams:5 */\n\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar ECDSA = __webpack_require__(/*! ../crypto/ecdsa */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/ecdsa.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Buffer} scriptCode\n * @param {Buffer} satoshisBuffer\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n\n  var hashPrevouts = Buffer.alloc(32);\n  var hashSequence = Buffer.alloc(32);\n  var hashOutputs = Buffer.alloc(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.alloc(4);\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\n      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n\n    var sequenceBuffers = [];\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.alloc(4);\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n\n  var outputWriter = new BufferWriter();\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  }\n\n  // Version\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n\n  writer.write(scriptCode);\n\n  writer.write(satoshisBuffer);\n\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // Sighash type\n  writer.writeInt32LE(sighashType);\n\n  return Hash.sha256sha256(writer.toBuffer());\n\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer) {\n  let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n  return ECDSA.sign(hashbuf, privateKey).set({ nhashtype: sighashType });\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer) {\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n  return ECDSA.verify(hashbuf, signature, publicKey);\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ2hhc2h3aXRuZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFxQjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxXQUFXLG1CQUFPLENBQUMsMkVBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyw2RUFBaUI7QUFDckMsUUFBUSxtQkFBTyxDQUFDLHlGQUF1QjtBQUN2QyxRQUFRLG1CQUFPLENBQUMscURBQVE7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vc2lnaGFzaHdpdG5lc3MuanM/NjkzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIGpzaGludCBtYXhwYXJhbXM6NSAqL1xuXG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vY3J5cHRvL3NpZ25hdHVyZScpO1xudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIEVDRFNBID0gcmVxdWlyZSgnLi4vY3J5cHRvL2VjZHNhJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIG9mIGxlbmd0aCAzMiBieXRlcyB3aXRoIHRoZSBoYXNoIHRoYXQgbmVlZHMgdG8gYmUgc2lnbmVkXG4gKiBmb3Igd2l0bmVzcyBwcm9ncmFtcyBhcyBkZWZpbmVkIGJ5OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0My5tZWRpYXdpa2lcbiAqXG4gKiBAbmFtZSBTaWduaW5nLnNpZ2hhc2hcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIHRoZSB0cmFuc2FjdGlvbiB0byBzaWduXG4gKiBAcGFyYW0ge251bWJlcn0gc2lnaGFzaFR5cGUgdGhlIHR5cGUgb2YgdGhlIGhhc2hcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dE51bWJlciB0aGUgaW5wdXQgaW5kZXggZm9yIHRoZSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBzY3JpcHRDb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2F0b3NoaXNCdWZmZXJcbiAqL1xudmFyIHNpZ2hhc2ggPSBmdW5jdGlvbiBzaWdoYXNoKHRyYW5zYWN0aW9uLCBzaWdoYXNoVHlwZSwgaW5wdXROdW1iZXIsIHNjcmlwdENvZGUsIHNhdG9zaGlzQnVmZmVyKSB7XG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiA1MCAqL1xuXG4gIHZhciBoYXNoUHJldm91dHMgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICB2YXIgaGFzaFNlcXVlbmNlID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgdmFyIGhhc2hPdXRwdXRzID0gQnVmZmVyLmFsbG9jKDMyKTtcblxuICBpZiAoIShzaWdoYXNoVHlwZSAmIFNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSkpIHtcbiAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdHJhbnNhY3Rpb24uaW5wdXRzLmxlbmd0aDsgbisrKSB7XG4gICAgICB2YXIgaW5wdXQgPSB0cmFuc2FjdGlvbi5pbnB1dHNbbl07XG4gICAgICB2YXIgcHJldlR4SWRCdWZmZXIgPSBuZXcgQnVmZmVyUmVhZGVyKGlucHV0LnByZXZUeElkKS5yZWFkUmV2ZXJzZSgpO1xuICAgICAgYnVmZmVycy5wdXNoKHByZXZUeElkQnVmZmVyKTtcbiAgICAgIHZhciBvdXRwdXRJbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgIG91dHB1dEluZGV4QnVmZmVyLndyaXRlVUludDMyTEUoaW5wdXQub3V0cHV0SW5kZXgsIDApO1xuICAgICAgYnVmZmVycy5wdXNoKG91dHB1dEluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgaGFzaFByZXZvdXRzID0gSGFzaC5zaGEyNTZzaGEyNTYoQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XG4gIH1cblxuICBpZiAoIShzaWdoYXNoVHlwZSAmIFNpZ25hdHVyZS5TSUdIQVNIX0FOWU9ORUNBTlBBWSkgJiZcbiAgICAgIChzaWdoYXNoVHlwZSAmIDB4MWYpICE9PSBTaWduYXR1cmUuU0lHSEFTSF9TSU5HTEUgJiYgKHNpZ2hhc2hUeXBlICYgMHgxZikgIT09IFNpZ25hdHVyZS5TSUdIQVNIX05PTkUpIHtcblxuICAgIHZhciBzZXF1ZW5jZUJ1ZmZlcnMgPSBbXTtcbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IHRyYW5zYWN0aW9uLmlucHV0cy5sZW5ndGg7IG0rKykge1xuICAgICAgdmFyIHNlcXVlbmNlQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgc2VxdWVuY2VCdWZmZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbbV0uc2VxdWVuY2VOdW1iZXIsIDApO1xuICAgICAgc2VxdWVuY2VCdWZmZXJzLnB1c2goc2VxdWVuY2VCdWZmZXIpO1xuICAgIH1cbiAgICBoYXNoU2VxdWVuY2UgPSBIYXNoLnNoYTI1NnNoYTI1NihCdWZmZXIuY29uY2F0KHNlcXVlbmNlQnVmZmVycykpO1xuICB9XG5cbiAgdmFyIG91dHB1dFdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgaWYgKChzaWdoYXNoVHlwZSAmIDB4MWYpICE9PSBTaWduYXR1cmUuU0lHSEFTSF9TSU5HTEUgJiYgKHNpZ2hhc2hUeXBlICYgMHgxZikgIT09IFNpZ25hdHVyZS5TSUdIQVNIX05PTkUpIHtcbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHRyYW5zYWN0aW9uLm91dHB1dHMubGVuZ3RoOyBwKyspIHtcbiAgICAgIHRyYW5zYWN0aW9uLm91dHB1dHNbcF0udG9CdWZmZXJXcml0ZXIob3V0cHV0V3JpdGVyKTtcbiAgICB9XG4gICAgaGFzaE91dHB1dHMgPSBIYXNoLnNoYTI1NnNoYTI1NihvdXRwdXRXcml0ZXIudG9CdWZmZXIoKSk7XG4gIH0gZWxzZSBpZiAoKHNpZ2hhc2hUeXBlICYgMHgxZikgPT09IFNpZ25hdHVyZS5TSUdIQVNIX1NJTkdMRSAmJiBpbnB1dE51bWJlciA8IHRyYW5zYWN0aW9uLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgdHJhbnNhY3Rpb24ub3V0cHV0c1tpbnB1dE51bWJlcl0udG9CdWZmZXJXcml0ZXIob3V0cHV0V3JpdGVyKTtcbiAgICBoYXNoT3V0cHV0cyA9IEhhc2guc2hhMjU2c2hhMjU2KG91dHB1dFdyaXRlci50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8vIFZlcnNpb25cbiAgdmFyIHdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgd3JpdGVyLndyaXRlVUludDMyTEUodHJhbnNhY3Rpb24udmVyc2lvbik7XG5cbiAgLy8gSW5wdXQgcHJldm91dHMvblNlcXVlbmNlIChub25lL2FsbCwgZGVwZW5kaW5nIG9uIGZsYWdzKVxuICB3cml0ZXIud3JpdGUoaGFzaFByZXZvdXRzKTtcbiAgd3JpdGVyLndyaXRlKGhhc2hTZXF1ZW5jZSk7XG5cbiAgLy8gVGhlIGlucHV0IGJlaW5nIHNpZ25lZCAocmVwbGFjaW5nIHRoZSBzY3JpcHRTaWcgd2l0aCBzY3JpcHRDb2RlICsgYW1vdW50KVxuICAvLyBUaGUgcHJldm91dCBtYXkgYWxyZWFkeSBiZSBjb250YWluZWQgaW4gaGFzaFByZXZvdXQsIGFuZCB0aGUgblNlcXVlbmNlXG4gIC8vIG1heSBhbHJlYWR5IGJlIGNvbnRhaW4gaW4gaGFzaFNlcXVlbmNlLlxuICB2YXIgb3V0cG9pbnRJZCA9IG5ldyBCdWZmZXJSZWFkZXIodHJhbnNhY3Rpb24uaW5wdXRzW2lucHV0TnVtYmVyXS5wcmV2VHhJZCkucmVhZFJldmVyc2UoKTtcbiAgd3JpdGVyLndyaXRlKG91dHBvaW50SWQpO1xuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLm91dHB1dEluZGV4KTtcblxuICB3cml0ZXIud3JpdGUoc2NyaXB0Q29kZSk7XG5cbiAgd3JpdGVyLndyaXRlKHNhdG9zaGlzQnVmZmVyKTtcblxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5pbnB1dHNbaW5wdXROdW1iZXJdLnNlcXVlbmNlTnVtYmVyKTtcblxuICAvLyBPdXRwdXRzIChub25lL29uZS9hbGwsIGRlcGVuZGluZyBvbiBmbGFncylcbiAgd3JpdGVyLndyaXRlKGhhc2hPdXRwdXRzKTtcblxuICAvLyBMb2NrdGltZVxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0cmFuc2FjdGlvbi5uTG9ja1RpbWUpO1xuXG4gIC8vIFNpZ2hhc2ggdHlwZVxuICB3cml0ZXIud3JpdGVJbnQzMkxFKHNpZ2hhc2hUeXBlKTtcblxuICByZXR1cm4gSGFzaC5zaGEyNTZzaGEyNTYod3JpdGVyLnRvQnVmZmVyKCkpO1xuXG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHNpZ25hdHVyZVxuICpcbiAqIEBuYW1lIFNpZ25pbmcuc2lnblxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ2hhc2hcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dEluZGV4XG4gKiBAcGFyYW0ge1NjcmlwdH0gc3Vic2NyaXB0XG4gKiBAcmV0dXJuIHtTaWduYXR1cmV9XG4gKi9cbmZ1bmN0aW9uIHNpZ24odHJhbnNhY3Rpb24sIHByaXZhdGVLZXksIHNpZ2hhc2hUeXBlLCBpbnB1dEluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcikge1xuICBsZXQgaGFzaGJ1ZiA9IHNpZ2hhc2godHJhbnNhY3Rpb24sIHNpZ2hhc2hUeXBlLCBpbnB1dEluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XG4gIHJldHVybiBFQ0RTQS5zaWduKGhhc2hidWYsIHByaXZhdGVLZXkpLnNldCh7IG5oYXNodHlwZTogc2lnaGFzaFR5cGUgfSk7XG59XG5cbi8qKlxuICogVmVyaWZ5IGEgc2lnbmF0dXJlXG4gKlxuICogQG5hbWUgU2lnbmluZy52ZXJpZnlcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVibGljS2V5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5wdXRJbmRleFxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHB1YmxpY0tleSwgaW5wdXRJbmRleCwgc2NyaXB0Q29kZSwgc2F0b3NoaXNCdWZmZXIpIHtcbiAgJC5jaGVja0FyZ3VtZW50KCFfLmlzVW5kZWZpbmVkKHRyYW5zYWN0aW9uKSwgXCJUcmFuc2FjdGlvbiBVbmRlZmluZWRcIik7XG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZChzaWduYXR1cmUpICYmICFfLmlzVW5kZWZpbmVkKHNpZ25hdHVyZS5uaGFzaHR5cGUpLCBcIlNpZ25hdHVyZSBVbmRlZmluZWRcIik7XG5cbiAgbGV0IGhhc2hidWYgPSBzaWdoYXNoKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUubmhhc2h0eXBlLCBpbnB1dEluZGV4LCBzY3JpcHRDb2RlLCBzYXRvc2hpc0J1ZmZlcik7XG4gIHJldHVybiBFQ0RTQS52ZXJpZnkoaGFzaGJ1Ziwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgU2lnbmluZ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2lnaGFzaDogc2lnaGFzaCxcbiAgc2lnbjogc2lnbixcbiAgdmVyaWZ5OiB2ZXJpZnlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js":
/*!***************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/signature.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nvar PublicKey = __webpack_require__(/*! ../publickey */ \"(ssr)/./node_modules/bitcore-lib/lib/publickey.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\n\n/**\n * @desc\n * Wrapper around Signature with fields related to signing a transaction specifically\n *\n * @param {Object|string|TransactionSignature} arg\n * @constructor\n */\nfunction TransactionSignature(arg) {\n  if (!(this instanceof TransactionSignature)) {\n    return new TransactionSignature(arg);\n  }\n  if (arg instanceof TransactionSignature) {\n    return arg;\n  }\n  if (arg && typeof arg === 'object') {\n    return this._fromObject(arg);\n  }\n  throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object');\n}\ninherits(TransactionSignature, Signature);\n\nTransactionSignature.prototype._fromObject = function(arg) {\n  this._checkObjectArgs(arg);\n  this.publicKey = new PublicKey(arg.publicKey);\n  this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, 'hex');\n  this.outputIndex = arg.outputIndex;\n  this.inputIndex = arg.inputIndex;\n  this.signature = (arg.signature instanceof Signature) ? arg.signature :\n                     BufferUtil.isBuffer(arg.signature) ? Signature.fromBuffer(arg.signature) :\n                     Signature.fromString(arg.signature);\n  this.sigtype = arg.sigtype;\n  return this;\n};\n\nTransactionSignature.prototype._checkObjectArgs = function(arg) {\n  $.checkArgument(PublicKey(arg.publicKey), 'invalid publicKey');\n  $.checkArgument(arg.inputIndex != null, 'missing inputIndex');\n  $.checkArgument(arg.outputIndex != null, 'missing outputIndex');\n  $.checkState(!isNaN(arg.inputIndex), 'inputIndex must be a number');\n  $.checkState(!isNaN(arg.outputIndex), 'outputIndex must be a number');\n  $.checkArgument(arg.signature, 'missing signature');\n  $.checkArgument(arg.prevTxId, 'missing prevTxId');\n  $.checkState(arg.signature instanceof Signature ||\n               BufferUtil.isBuffer(arg.signature) ||\n               JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value');\n  $.checkState(BufferUtil.isBuffer(arg.prevTxId) ||\n               JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value');\n  $.checkArgument(arg.sigtype != null, 'missing sigtype');\n  $.checkState(!isNaN(arg.sigtype), 'sigtype must be a number');\n};\n\n/**\n * Serializes a transaction to a plain JS object\n * @return {Object}\n */\nTransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject() {\n  return {\n    publicKey: this.publicKey.toString(),\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    inputIndex: this.inputIndex,\n    signature: this.signature.toString(),\n    sigtype: this.sigtype\n  };\n};\n\n/**\n * Builds a TransactionSignature from an object\n * @param {Object} object\n * @return {TransactionSignature}\n */\nTransactionSignature.fromObject = function(object) {\n  $.checkArgument(object);\n  return new TransactionSignature(object);\n};\n\nmodule.exports = TransactionSignature;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxvRkFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLG1FQUFZOztBQUVqQyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBYztBQUN0QyxhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQXFCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vc2lnbmF0dXJlLmpzPzYzYmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9idWZmZXInKTtcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XG5cbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuLi9wdWJsaWNrZXknKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi9jcnlwdG8vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogQGRlc2NcbiAqIFdyYXBwZXIgYXJvdW5kIFNpZ25hdHVyZSB3aXRoIGZpZWxkcyByZWxhdGVkIHRvIHNpZ25pbmcgYSB0cmFuc2FjdGlvbiBzcGVjaWZpY2FsbHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd8VHJhbnNhY3Rpb25TaWduYXR1cmV9IGFyZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRyYW5zYWN0aW9uU2lnbmF0dXJlKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNhY3Rpb25TaWduYXR1cmUpKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblNpZ25hdHVyZShhcmcpO1xuICB9XG4gIGlmIChhcmcgaW5zdGFuY2VvZiBUcmFuc2FjdGlvblNpZ25hdHVyZSkge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbiAgaWYgKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0aGlzLl9mcm9tT2JqZWN0KGFyZyk7XG4gIH1cbiAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnQoJ1RyYW5zYWN0aW9uU2lnbmF0dXJlcyBtdXN0IGJlIGluc3RhbnRpYXRlZCBmcm9tIGFuIG9iamVjdCcpO1xufVxuaW5oZXJpdHMoVHJhbnNhY3Rpb25TaWduYXR1cmUsIFNpZ25hdHVyZSk7XG5cblRyYW5zYWN0aW9uU2lnbmF0dXJlLnByb3RvdHlwZS5fZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGFyZykge1xuICB0aGlzLl9jaGVja09iamVjdEFyZ3MoYXJnKTtcbiAgdGhpcy5wdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGFyZy5wdWJsaWNLZXkpO1xuICB0aGlzLnByZXZUeElkID0gQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcucHJldlR4SWQpID8gYXJnLnByZXZUeElkIDogQnVmZmVyLmZyb20oYXJnLnByZXZUeElkLCAnaGV4Jyk7XG4gIHRoaXMub3V0cHV0SW5kZXggPSBhcmcub3V0cHV0SW5kZXg7XG4gIHRoaXMuaW5wdXRJbmRleCA9IGFyZy5pbnB1dEluZGV4O1xuICB0aGlzLnNpZ25hdHVyZSA9IChhcmcuc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSA/IGFyZy5zaWduYXR1cmUgOlxuICAgICAgICAgICAgICAgICAgICAgQnVmZmVyVXRpbC5pc0J1ZmZlcihhcmcuc2lnbmF0dXJlKSA/IFNpZ25hdHVyZS5mcm9tQnVmZmVyKGFyZy5zaWduYXR1cmUpIDpcbiAgICAgICAgICAgICAgICAgICAgIFNpZ25hdHVyZS5mcm9tU3RyaW5nKGFyZy5zaWduYXR1cmUpO1xuICB0aGlzLnNpZ3R5cGUgPSBhcmcuc2lndHlwZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2FjdGlvblNpZ25hdHVyZS5wcm90b3R5cGUuX2NoZWNrT2JqZWN0QXJncyA9IGZ1bmN0aW9uKGFyZykge1xuICAkLmNoZWNrQXJndW1lbnQoUHVibGljS2V5KGFyZy5wdWJsaWNLZXkpLCAnaW52YWxpZCBwdWJsaWNLZXknKTtcbiAgJC5jaGVja0FyZ3VtZW50KGFyZy5pbnB1dEluZGV4ICE9IG51bGwsICdtaXNzaW5nIGlucHV0SW5kZXgnKTtcbiAgJC5jaGVja0FyZ3VtZW50KGFyZy5vdXRwdXRJbmRleCAhPSBudWxsLCAnbWlzc2luZyBvdXRwdXRJbmRleCcpO1xuICAkLmNoZWNrU3RhdGUoIWlzTmFOKGFyZy5pbnB1dEluZGV4KSwgJ2lucHV0SW5kZXggbXVzdCBiZSBhIG51bWJlcicpO1xuICAkLmNoZWNrU3RhdGUoIWlzTmFOKGFyZy5vdXRwdXRJbmRleCksICdvdXRwdXRJbmRleCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICQuY2hlY2tBcmd1bWVudChhcmcuc2lnbmF0dXJlLCAnbWlzc2luZyBzaWduYXR1cmUnKTtcbiAgJC5jaGVja0FyZ3VtZW50KGFyZy5wcmV2VHhJZCwgJ21pc3NpbmcgcHJldlR4SWQnKTtcbiAgJC5jaGVja1N0YXRlKGFyZy5zaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUgfHxcbiAgICAgICAgICAgICAgIEJ1ZmZlclV0aWwuaXNCdWZmZXIoYXJnLnNpZ25hdHVyZSkgfHxcbiAgICAgICAgICAgICAgIEpTVXRpbC5pc0hleGEoYXJnLnNpZ25hdHVyZSksICdzaWduYXR1cmUgbXVzdCBiZSBhIGJ1ZmZlciBvciBoZXhhIHZhbHVlJyk7XG4gICQuY2hlY2tTdGF0ZShCdWZmZXJVdGlsLmlzQnVmZmVyKGFyZy5wcmV2VHhJZCkgfHxcbiAgICAgICAgICAgICAgIEpTVXRpbC5pc0hleGEoYXJnLnByZXZUeElkKSwgJ3ByZXZUeElkIG11c3QgYmUgYSBidWZmZXIgb3IgaGV4YSB2YWx1ZScpO1xuICAkLmNoZWNrQXJndW1lbnQoYXJnLnNpZ3R5cGUgIT0gbnVsbCwgJ21pc3Npbmcgc2lndHlwZScpO1xuICAkLmNoZWNrU3RhdGUoIWlzTmFOKGFyZy5zaWd0eXBlKSwgJ3NpZ3R5cGUgbXVzdCBiZSBhIG51bWJlcicpO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemVzIGEgdHJhbnNhY3Rpb24gdG8gYSBwbGFpbiBKUyBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVHJhbnNhY3Rpb25TaWduYXR1cmUucHJvdG90eXBlLnRvT2JqZWN0ID0gVHJhbnNhY3Rpb25TaWduYXR1cmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXkudG9TdHJpbmcoKSxcbiAgICBwcmV2VHhJZDogdGhpcy5wcmV2VHhJZC50b1N0cmluZygnaGV4JyksXG4gICAgb3V0cHV0SW5kZXg6IHRoaXMub3V0cHV0SW5kZXgsXG4gICAgaW5wdXRJbmRleDogdGhpcy5pbnB1dEluZGV4LFxuICAgIHNpZ25hdHVyZTogdGhpcy5zaWduYXR1cmUudG9TdHJpbmcoKSxcbiAgICBzaWd0eXBlOiB0aGlzLnNpZ3R5cGVcbiAgfTtcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgVHJhbnNhY3Rpb25TaWduYXR1cmUgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9uU2lnbmF0dXJlfVxuICovXG5UcmFuc2FjdGlvblNpZ25hdHVyZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICQuY2hlY2tBcmd1bWVudChvYmplY3QpO1xuICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uU2lnbmF0dXJlKG9iamVjdCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uU2lnbmF0dXJlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/transaction.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar compare = Buffer.compare || __webpack_require__(/*! buffer-compare */ \"(ssr)/./node_modules/buffer-compare/index.js\");\n\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar BufferUtil = __webpack_require__(/*! ../util/buffer */ \"(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar BufferReader = __webpack_require__(/*! ../encoding/bufferreader */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferreader.js\");\nvar BufferWriter = __webpack_require__(/*! ../encoding/bufferwriter */ \"(ssr)/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js\");\nvar Hash = __webpack_require__(/*! ../crypto/hash */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/hash.js\");\nvar Signature = __webpack_require__(/*! ../crypto/signature */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/signature.js\");\nvar Sighash = __webpack_require__(/*! ./sighash */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighash.js\");\nvar SighashWitness = __webpack_require__(/*! ./sighashwitness */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js\");\nconst SighashSchnorr = __webpack_require__(/*! ./sighashschnorr */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js\");\n\nvar Address = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar UnspentOutput = __webpack_require__(/*! ./unspentoutput */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/unspentoutput.js\");\nvar Input = __webpack_require__(/*! ./input */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/input/index.js\");\nvar PublicKeyHashInput = Input.PublicKeyHash;\nvar PublicKeyInput = Input.PublicKey;\nvar MultiSigScriptHashInput = Input.MultiSigScriptHash;\nvar MultiSigInput = Input.MultiSig;\nconst TaprootInput = Input.Taproot;\nvar Output = __webpack_require__(/*! ./output */ \"(ssr)/./node_modules/bitcore-lib/lib/transaction/output.js\");\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar PrivateKey = __webpack_require__(/*! ../privatekey */ \"(ssr)/./node_modules/bitcore-lib/lib/privatekey.js\");\nvar BN = __webpack_require__(/*! ../crypto/bn */ \"(ssr)/./node_modules/bitcore-lib/lib/crypto/bn.js\");\n\n/**\n * Represents a transaction, a set of inputs and outputs to change ownership of tokens\n *\n * @param {*} [serialized]\n * @param {*} [opts]\n * @constructor\n */\nfunction Transaction(serialized, opts) {\n  if (!(this instanceof Transaction)) {\n    return new Transaction(serialized);\n  }\n  this.inputs = [];\n  this.outputs = [];\n  this._inputAmount = undefined;\n  this._outputAmount = undefined;\n\n  if (serialized) {\n    if (serialized instanceof Transaction) {\n      return Transaction.shallowCopy(serialized);\n    } else if (JSUtil.isHexa(serialized)) {\n      this.fromString(serialized);\n    } else if (BufferUtil.isBuffer(serialized)) {\n      this.fromBuffer(serialized);\n    } else if (_.isObject(serialized)) {\n      this.fromObject(serialized, opts);\n    } else {\n      throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction');\n    }\n  } else {\n    this._newTransaction();\n  }\n}\nvar CURRENT_VERSION = 2;\nvar DEFAULT_NLOCKTIME = 0;\nvar MAX_BLOCK_SIZE = 1000000;\n\n// Minimum amount for an output for it not to be considered a dust output\nTransaction.DUST_AMOUNT = 546;\n\n// Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big difference\nTransaction.FEE_SECURITY_MARGIN = 150;\n\n// max amount of satoshis in circulation\nTransaction.MAX_MONEY = 21000000 * 1e8;\n\n// nlocktime limit to be considered block height rather than a timestamp\nTransaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;\n\n// Max value for an unsigned 32 bit value\nTransaction.NLOCKTIME_MAX_VALUE = 4294967295;\n\n// Value used for fee estimation (satoshis per kilobyte)\nTransaction.FEE_PER_KB = 100000;\n\n// Safe upper bound for change address script size in bytes\nTransaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;\nTransaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;\n\n/* Constructors and Serialization */\n\n/**\n * Create a 'shallow' copy of the transaction, by serializing and deserializing\n * it dropping any additional information that inputs and outputs may have hold\n *\n * @param {Transaction} transaction\n * @return {Transaction}\n */\nTransaction.shallowCopy = function(transaction) {\n  var copy = new Transaction(transaction.toBuffer());\n  return copy;\n};\n\nvar hashProperty = {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    this._hash = new BufferReader(this._getHash()).readReverse().toString('hex');\n    return this._hash;\n  }\n};\n\nvar witnessHashProperty = {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    return new BufferReader(this._getWitnessHash()).readReverse().toString('hex');\n  }\n};\n\nObject.defineProperty(Transaction.prototype, 'witnessHash', witnessHashProperty);\nObject.defineProperty(Transaction.prototype, 'hash', hashProperty);\nObject.defineProperty(Transaction.prototype, 'id', hashProperty);\n\nvar ioProperty = {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    return this._getInputAmount();\n  }\n};\nObject.defineProperty(Transaction.prototype, 'inputAmount', ioProperty);\nioProperty.get = function() {\n  return this._getOutputAmount();\n};\nObject.defineProperty(Transaction.prototype, 'outputAmount', ioProperty);\n\nObject.defineProperty(Transaction.prototype, 'size', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    return this._calculateSize();\n  }\n});\n\nObject.defineProperty(Transaction.prototype, 'vsize', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    return this._calculateVSize();\n  }\n});\n\nObject.defineProperty(Transaction.prototype, 'weight', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    return this._calculateWeight();\n  }\n});\n\n/**\n * Retrieve the little endian hash of the transaction (used for serialization)\n * @return {Buffer}\n */\nTransaction.prototype._getHash = function() {\n  return Hash.sha256sha256(this.toBuffer(true));\n};\n\n/**\n * Retrieve the little endian hash of the transaction including witness data\n * @return {Buffer}\n */\nTransaction.prototype._getWitnessHash = function() {\n  return Hash.sha256sha256(this.toBuffer(false));\n};\n\n/**\n * Retrieve a hexa string that can be used with bitcoind's CLI interface\n * (decoderawtransaction, sendrawtransaction)\n *\n * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object,\n *   it's expected to contain a set of flags to skip certain tests:\n * * `disableAll`: disable all checks\n * * `disableSmallFees`: disable checking for fees that are too small\n * * `disableLargeFees`: disable checking for fees that are too large\n * * `disableIsFullySigned`: disable checking if all inputs are fully signed\n * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts\n * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than the sum of the input amounts\n * @return {string}\n */\nTransaction.prototype.serialize = function(unsafe) {\n  if (true === unsafe || unsafe && unsafe.disableAll) {\n    return this.uncheckedSerialize();\n  } else {\n    return this.checkedSerialize(unsafe);\n  }\n};\n\nTransaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Retrieve a hexa string that can be used with bitcoind's CLI interface\n * (decoderawtransaction, sendrawtransaction)\n *\n * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n * @return {string}\n */\nTransaction.prototype.checkedSerialize = function(opts) {\n  var serializationError = this.getSerializationError(opts);\n  if (serializationError) {\n    serializationError.message += ' - For more information please see: ' +\n      'https://github.com/bitpay/bitcore/blob/master/packages/bitcore-lib/docs/transaction.md#serialization-checks';\n    throw serializationError;\n  }\n  return this.uncheckedSerialize();\n};\n\nTransaction.prototype.invalidSatoshis = function() {\n  var invalid = false;\n  for (var i = 0; i < this.outputs.length; i++) {\n    if (this.outputs[i].invalidSatoshis()) {\n      invalid = true;\n    }\n  }\n  return invalid;\n};\n\n/**\n * Retrieve a possible error that could appear when trying to serialize and\n * broadcast this transaction.\n *\n * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n * @return {bitcore.Error}\n */\nTransaction.prototype.getSerializationError = function(opts) {\n  opts = opts || {};\n\n  if (this.invalidSatoshis()) {\n    return new errors.Transaction.InvalidSatoshis();\n  }\n\n  var unspent = this._getUnspentValue();\n  var unspentError;\n  if (unspent < 0) {\n    if (!opts.disableMoreOutputThanInput) {\n      unspentError = new errors.Transaction.InvalidOutputAmountSum();\n    }\n  } else {\n    unspentError = this._hasFeeError(opts, unspent);\n  }\n\n  return unspentError ||\n    this._hasDustOutputs(opts) ||\n    this._isMissingSignatures(opts);\n};\n\nTransaction.prototype._hasFeeError = function(opts, unspent) {\n\n  if (this._fee != null && this._fee !== unspent) {\n    return new errors.Transaction.FeeError.Different(\n      'Unspent value is ' + unspent + ' but specified fee is ' + this._fee\n    );\n  }\n\n  if (!opts.disableLargeFees) {\n    var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());\n    if (unspent > maximumFee) {\n      if (this._missingChange()) {\n        return new errors.Transaction.ChangeAddressMissing(\n          'Fee is too large and no change address was provided'\n        );\n      }\n      return new errors.Transaction.FeeError.TooLarge(\n        'expected less than ' + maximumFee + ' but got ' + unspent\n      );\n    }\n  }\n\n  if (!opts.disableSmallFees) {\n    var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);\n    if (unspent < minimumFee) {\n      return new errors.Transaction.FeeError.TooSmall(\n        'expected more than ' + minimumFee + ' but got ' + unspent\n      );\n    }\n  }\n};\n\nTransaction.prototype._missingChange = function() {\n  return !this._changeScript;\n};\n\nTransaction.prototype._hasDustOutputs = function(opts) {\n  if (opts.disableDustOutputs) {\n    return;\n  }\n  var index, output;\n  for (index in this.outputs) {\n    output = this.outputs[index];\n    if (output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut()) {\n      return new errors.Transaction.DustOutputs();\n    }\n  }\n};\n\nTransaction.prototype._isMissingSignatures = function(opts) {\n  if (opts.disableIsFullySigned) {\n    return;\n  }\n  if (!this.isFullySigned()) {\n    return new errors.Transaction.MissingSignatures();\n  }\n};\n\nTransaction.prototype.inspect = function() {\n  return '<Transaction: ' + this.uncheckedSerialize() + '>';\n};\n\nTransaction.prototype.toBuffer = function(noWitness) {\n  var writer = new BufferWriter();\n  return this.toBufferWriter(writer, noWitness).toBuffer();\n};\n\nTransaction.prototype.hasWitnesses = function() {\n  for (var i = 0; i < this.inputs.length; i++) {\n    if (this.inputs[i].hasWitnesses()) {\n      return true;\n    }\n  }\n  return false;\n};\n\nTransaction.prototype.toBufferWriter = function(writer, noWitness) {\n  writer.writeInt32LE(this.version);\n\n  const hasWitnesses = this.hasWitnesses();\n\n  if (hasWitnesses && !noWitness) {\n    writer.write(Buffer.from('0001', 'hex'));\n  }\n\n  writer.writeVarintNum(this.inputs ? this.inputs.length : 0);\n  for (const input of this.inputs || []) {\n    input.toBufferWriter(writer);\n  }\n\n  writer.writeVarintNum(this.outputs ? this.outputs.length : 0);\n  for (const output of this.outputs || []) {\n    output.toBufferWriter(writer);\n  }\n\n  if (hasWitnesses && !noWitness) {\n    for (const input of this.inputs) {\n      const witnesses = input.getWitnesses();\n      writer.writeVarintNum(witnesses.length);\n      for (let j = 0; j < witnesses.length; j++) {\n        writer.writeVarintNum(witnesses[j].length);\n        writer.write(witnesses[j]);\n      }\n    }\n  }\n\n  writer.writeUInt32LE(this.nLockTime);\n  return writer;\n};\n\nTransaction.prototype.fromBuffer = function(buffer) {\n  var reader = new BufferReader(buffer);\n  return this.fromBufferReader(reader);\n};\n\nTransaction.prototype.fromBufferReader = function(reader) {\n  $.checkArgument(!reader.finished(), 'No transaction data received');\n\n  this.version = reader.readInt32LE();\n  var sizeTxIns = reader.readVarintNum();\n\n  // check for segwit\n  var hasWitnesses = false;\n  if (sizeTxIns === 0 && reader.buf[reader.pos] !== 0) {\n    reader.pos += 1;\n    hasWitnesses = true;\n    sizeTxIns = reader.readVarintNum();\n  }\n\n  for (var i = 0; i < sizeTxIns; i++) {\n    var input = Input.fromBufferReader(reader);\n    this.inputs.push(input);\n  }\n\n  var sizeTxOuts = reader.readVarintNum();\n  for (var j = 0; j < sizeTxOuts; j++) {\n    this.outputs.push(Output.fromBufferReader(reader));\n  }\n\n  if (hasWitnesses) {\n    for (var k = 0; k < sizeTxIns; k++) {\n      var itemCount = reader.readVarintNum();\n      var witnesses = [];\n      for (var l = 0; l < itemCount; l++) {\n        var size = reader.readVarintNum();\n        var item = reader.read(size);\n        witnesses.push(item);\n      }\n      this.inputs[k].setWitnesses(witnesses);\n    }\n  }\n\n  this.nLockTime = reader.readUInt32LE();\n  return this;\n};\n\n\nTransaction.prototype.toObject = Transaction.prototype.toJSON = function toObject() {\n  var inputs = [];\n  this.inputs.forEach(function(input) {\n    inputs.push(input.toObject());\n  });\n  var outputs = [];\n  this.outputs.forEach(function(output) {\n    outputs.push(output.toObject());\n  });\n  var obj = {\n    hash: this.hash,\n    version: this.version,\n    inputs: inputs,\n    outputs: outputs,\n    nLockTime: this.nLockTime\n  };\n  if (this._changeScript) {\n    obj.changeScript = this._changeScript.toString();\n  }\n  if (this._changeIndex != null) {\n    obj.changeIndex = this._changeIndex;\n  }\n  if (this._fee != null) {\n    obj.fee = this._fee;\n  }\n  return obj;\n};\n\nTransaction.prototype.fromObject = function fromObject(arg, opts) {\n  /* jshint maxstatements: 20 */\n  $.checkArgument(_.isObject(arg) || arg instanceof Transaction);\n  var transaction;\n  if (arg instanceof Transaction) {\n    transaction = arg.toObject();\n  } else {\n    transaction = arg;\n  }\n  for (const input of transaction.inputs || []) {\n    if (!input.output || !input.output.script) {\n      this.uncheckedAddInput(new Input(input));\n      continue;\n    }\n    var script = new Script(input.output.script);\n    var txin;\n    if ((script.isScriptHashOut() || script.isWitnessScriptHashOut()) && input.publicKeys && input.threshold) {\n      txin = new Input.MultiSigScriptHash(\n        input, input.publicKeys, input.threshold, input.signatures, opts\n      );\n    } else if (script.isPublicKeyHashOut() || script.isWitnessPublicKeyHashOut() || script.isScriptHashOut()) {\n      txin = new Input.PublicKeyHash(input);\n    } else if (script.isPublicKeyOut()) {\n      txin = new Input.PublicKey(input);\n    } else {\n      throw new errors.Transaction.Input.UnsupportedScript(input.output.script);\n    }\n    this.addInput(txin);\n  }\n  for (const output of transaction.outputs || []) {\n    this.addOutput(new Output(output));\n  }\n  if (transaction.changeIndex) {\n    this._changeIndex = transaction.changeIndex;\n  }\n  if (transaction.changeScript) {\n    this._changeScript = new Script(transaction.changeScript);\n  }\n  if (transaction.fee) {\n    this._fee = transaction.fee;\n  }\n  this.nLockTime = transaction.nLockTime;\n  this.version = transaction.version;\n  this._checkConsistency(arg);\n  return this;\n};\n\nTransaction.prototype._checkConsistency = function(arg) {\n  if (this._changeIndex != null) {\n    $.checkState(this._changeScript, 'Change script is expected.');\n    $.checkState(this.outputs[this._changeIndex], 'Change index points to undefined output.');\n    $.checkState(this.outputs[this._changeIndex].script.toString() ===\n      this._changeScript.toString(), 'Change output has an unexpected script.');\n  }\n  if (arg && arg.hash) {\n    $.checkState(arg.hash === this.hash, 'Hash in object does not match transaction hash.');\n  }\n};\n\n/**\n * Sets nLockTime so that transaction is not valid until the desired date(a\n * timestamp in seconds since UNIX epoch is also accepted)\n *\n * @param {Date | Number} time\n * @return {Transaction} this\n */\nTransaction.prototype.lockUntilDate = function(time) {\n  $.checkArgument(time);\n  if (!isNaN(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n    throw new errors.Transaction.LockTimeTooEarly();\n  }\n  if (_.isDate(time)) {\n    time = time.getTime() / 1000;\n  }\n\n  for (var i = 0; i < this.inputs.length; i++) {\n    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){\n      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n    }\n  }\n\n  this.nLockTime = time;\n  return this;\n};\n\n/**\n * Sets nLockTime so that transaction is not valid until the desired block\n * height.\n *\n * @param {Number} height\n * @return {Transaction} this\n */\nTransaction.prototype.lockUntilBlockHeight = function(height) {\n  $.checkArgument(!isNaN(height));\n  if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n    throw new errors.Transaction.BlockHeightTooHigh();\n  }\n  if (height < 0) {\n    throw new errors.Transaction.NLockTimeOutOfRange();\n  }\n\n  for (var i = 0; i < this.inputs.length; i++) {\n    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){\n      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n    }\n  }\n\n\n  this.nLockTime = height;\n  return this;\n};\n\n/**\n *  Returns a semantic version of the transaction's nLockTime.\n *  @return {Number|Date}\n *  If nLockTime is 0, it returns null,\n *  if it is < 500000000, it returns a block height (number)\n *  else it returns a Date object.\n */\nTransaction.prototype.getLockTime = function() {\n  if (!this.nLockTime) {\n    return null;\n  }\n  if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n    return this.nLockTime;\n  }\n  return new Date(1000 * this.nLockTime);\n};\n\nTransaction.prototype.fromString = function(string) {\n  this.fromBuffer(buffer.Buffer.from(string, 'hex'));\n};\n\nTransaction.prototype._newTransaction = function() {\n  this.version = CURRENT_VERSION;\n  this.nLockTime = DEFAULT_NLOCKTIME;\n};\n\n/* Transaction creation interface */\n\n/**\n * @typedef {Object} Transaction~fromObject\n * @property {string} prevTxId\n * @property {number} outputIndex\n * @property {(Buffer|string|Script)} script\n * @property {number} satoshis\n */\n\n/**\n * Add an input to this transaction. This is a high level interface\n * to add an input, for more control, use @{link Transaction#addInput}.\n *\n * Can receive, as output information, the output of bitcoind's `listunspent` command,\n * and a slightly fancier format recognized by bitcore:\n *\n * ```\n * {\n *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',\n *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',\n *  outputIndex: 0,\n *  script: Script.empty(),\n *  satoshis: 1020000\n * }\n * ```\n * Where `address` can be either a string or a bitcore Address object. The\n * same is true for `script`, which can be a string or a bitcore Script.\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @example\n * ```javascript\n * var transaction = new Transaction();\n *\n * // From a pay to public key hash output from bitcoind's listunspent\n * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});\n *\n * // From a pay to public key hash output\n * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});\n *\n * // From a multisig P2SH output\n * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},\n *                  ['03000...', '02000...'], 2);\n * ```\n *\n * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} utxo\n * @param {Array=} [pubkeys]\n * @param {number=} [threshold]\n * @param {Object=} [opts] - Several options:\n *        - noSorting: defaults to false, if true and is multisig, don't\n *                      sort the given public keys before creating the script\n */\nTransaction.prototype.from = function(utxo, pubkeys, threshold, opts) {\n  if (Array.isArray(utxo)) {\n    for(const u of utxo) {\n      this.from(u, pubkeys, threshold, opts);\n    };\n    return this;\n  }\n  const exists = this.inputs.some(function(input) {\n    // TODO: Maybe prevTxId should be a string? Or defined as read only property?\n    return input.prevTxId.toString('hex') === utxo.txId && input.outputIndex === utxo.outputIndex;\n  });\n  if (exists) {\n    return this;\n  }\n  if (pubkeys && threshold) {\n    this._fromMultisigUtxo(utxo, pubkeys, threshold, opts);\n  } else {\n    this._fromNonP2SH(utxo, opts);\n  }\n  return this;\n};\n\n/**\n * associateInputs - Update inputs with utxos, allowing you to specify value, and pubkey.\n * Populating these inputs allows for them to be signed with .sign(privKeys)\n *\n * @param {Array<Object>} utxos\n * @param {Array<string | PublicKey>} pubkeys\n * @param {number} threshold\n * @param {Object} opts\n * @returns {Array<number>}\n */\nTransaction.prototype.associateInputs = function(utxos, pubkeys, threshold, opts = {}) {\n  let indexes = [];\n  for(let utxo of utxos) {\n    const index = this.inputs.findIndex(i => i.prevTxId.toString('hex') === utxo.txId && i.outputIndex === utxo.outputIndex);\n    indexes.push(index);\n    if(index >= 0) {\n      const sequenceNumber = this.inputs[index].sequenceNumber; // preserve the set sequence number\n      this.inputs[index] = this._getInputFrom(utxo, pubkeys, threshold, opts);\n      this.inputs[index].sequenceNumber = sequenceNumber;\n    }\n  }\n  return indexes;\n}\n\n\nTransaction.prototype._selectInputType = function(utxo, pubkeys, threshold) {\n  var clazz;\n  utxo = new UnspentOutput(utxo);\n  if(pubkeys && threshold) {\n    if (utxo.script.isMultisigOut()) {\n      clazz = MultiSigInput;\n    } else if (utxo.script.isScriptHashOut() || utxo.script.isWitnessScriptHashOut()) {\n      clazz = MultiSigScriptHashInput;\n    }\n  } else if (utxo.script.isPublicKeyHashOut() || utxo.script.isWitnessPublicKeyHashOut() || utxo.script.isScriptHashOut()) {\n    clazz = PublicKeyHashInput;\n  } else if (utxo.script.isTaproot()) {\n    clazz = TaprootInput;\n  } else if (utxo.script.isPublicKeyOut()) {\n    clazz = PublicKeyInput;\n  } else {\n    clazz = Input;\n  }\n  return clazz;\n}\n\n\nTransaction.prototype._getInputFrom = function(utxo, pubkeys, threshold, opts = {}) {\n  utxo = new UnspentOutput(utxo);\n  const InputClass = this._selectInputType(utxo, pubkeys, threshold);\n  const input = {\n    output: new Output({\n      script: utxo.script,\n      satoshis: utxo.satoshis\n    }),\n    prevTxId: utxo.txId,\n    outputIndex: utxo.outputIndex,\n    sequenceNumber: opts.sequenceNumber,\n    script: Script.empty()\n  };\n  let args = pubkeys && threshold ? [pubkeys, threshold, false, opts] : []\n  return new InputClass(input, ...args);\n}\n\nTransaction.prototype._fromNonP2SH = function(utxo, opts) {\n  const input = this._getInputFrom(utxo, null, null, opts);\n  this.addInput(input);\n};\n\nTransaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, opts) {\n  $.checkArgument(threshold <= pubkeys.length,\n    'Number of required signatures must be greater than the number of public keys');\n  const input = this._getInputFrom(utxo, pubkeys, threshold, opts);\n  this.addInput(input);\n};\n\n/**\n * Add an input to this transaction. The input must be an instance of the `Input` class.\n * It should have information about the Output that it's spending, but if it's not already\n * set, two additional parameters, `outputScript` and `satoshis` can be provided.\n *\n * @param {Input} input\n * @param {String|Script} outputScript\n * @param {number} satoshis\n * @return Transaction this, for chaining\n */\nTransaction.prototype.addInput = function(input, outputScript, satoshis) {\n  $.checkArgumentType(input, Input, 'input');\n  if (!input.output && (outputScript == null || satoshis == null)) {\n    throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis');\n  }\n  if (!input.output && outputScript && satoshis != null) {\n    outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);\n    $.checkArgumentType(satoshis, 'number', 'satoshis');\n    input.output = new Output({\n      script: outputScript,\n      satoshis: satoshis\n    });\n  }\n  return this.uncheckedAddInput(input);\n};\n\n/**\n * Add an input to this transaction, without checking that the input has information about\n * the output that it's spending.\n *\n * @param {Input} input\n * @return Transaction this, for chaining\n */\nTransaction.prototype.uncheckedAddInput = function(input) {\n  $.checkArgumentType(input, Input, 'input');\n  this.inputs.push(input);\n  this._inputAmount = undefined;\n  this._updateChangeOutput();\n  return this;\n};\n\n/**\n * Returns true if the transaction has enough info on all inputs to be correctly validated\n *\n * @return {boolean}\n */\nTransaction.prototype.hasAllUtxoInfo = function() {\n  return this.inputs.every(function(input) {\n    return !!input.output;\n  });\n};\n\n/**\n * Manually set the fee for this transaction. Beware that this resets all the signatures\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n * be reset).\n *\n * @param {number} amount satoshis to be sent\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.fee = function(amount) {\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\n  this._fee = amount;\n  this._updateChangeOutput();\n  return this;\n};\n\n/**\n * Manually set the fee per KB for this transaction. Beware that this resets all the signatures\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n * be reset).\n *\n * @param {number} amount satoshis per KB to be sent\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.feePerKb = function(amount) {\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\n  this._feePerKb = amount;\n  this._updateChangeOutput();\n  return this;\n};\n\n/**\n * Manually set the fee per Byte for this transaction. Beware that this resets all the signatures\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n * be reset).\n * fee per Byte will be ignored if fee per KB is set\n *\n * @param {number} amount satoshis per Byte to be sent\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.feePerByte = function (amount) {\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\n  this._feePerByte = amount;\n  this._updateChangeOutput();\n  return this;\n};\n\n/* Output management */\n\n/**\n * Set the change address for this transaction\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @param {Address} address An address for change to be sent to.\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.change = function(address) {\n  $.checkArgument(address, 'address is required');\n  this._changeScript = Script.fromAddress(address);\n  this._updateChangeOutput();\n  return this;\n};\n\n\n/**\n * @return {Output} change output, if it exists\n */\nTransaction.prototype.getChangeOutput = function() {\n  if (this._changeIndex != null) {\n    return this.outputs[this._changeIndex];\n  }\n  return null;\n};\n\n/**\n * @typedef {Object} Transaction~toObject\n * @property {(string|Address)} address\n * @property {number} satoshis\n */\n\n/**\n * Add an output to the transaction.\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @param {(string|Address|Array.<Transaction~toObject>)} address\n * @param {number} amount in satoshis\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.to = function(address, amount) {\n  if (Array.isArray(address)) {\n    for (const to of address) {\n      this.to(to.address, to.satoshis);\n    }\n    return this;\n  }\n\n  $.checkArgument(\n    JSUtil.isNaturalNumber(amount),\n    'Amount is expected to be a positive integer'\n  );\n  this.addOutput(new Output({\n    script: Script(new Address(address)),\n    satoshis: amount\n  }));\n  return this;\n};\n\n/**\n * Add an OP_RETURN output to the transaction.\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @param {Buffer|string} value the data to be stored in the OP_RETURN output.\n *    In case of a string, the UTF-8 representation will be stored\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.addData = function(value) {\n  this.addOutput(new Output({\n    script: Script.buildDataOut(value),\n    satoshis: 0\n  }));\n  return this;\n};\n\n\n/**\n * Add an output to the transaction.\n *\n * @param {Output} output the output to add.\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.addOutput = function(output) {\n  $.checkArgumentType(output, Output, 'output');\n  this._addOutput(output);\n  this._updateChangeOutput();\n  return this;\n};\n\n\n/**\n * Remove all outputs from the transaction.\n *\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.clearOutputs = function() {\n  this.outputs = [];\n  this._clearSignatures();\n  this._outputAmount = undefined;\n  this._changeIndex = undefined;\n  this._updateChangeOutput();\n  return this;\n};\n\n\nTransaction.prototype._addOutput = function(output) {\n  this.outputs.push(output);\n  this._outputAmount = undefined;\n};\n\n\n/**\n * Calculates or gets the total output amount in satoshis\n *\n * @return {Number} the transaction total output amount\n */\nTransaction.prototype._getOutputAmount = function() {\n  if (this._outputAmount == null) {\n    var self = this;\n    this._outputAmount = 0;\n    for (const output of this.outputs || []) {\n      self._outputAmount += output.satoshis;\n    }\n  }\n  return this._outputAmount;\n};\n\n\n/**\n * Calculates or gets the total input amount in satoshis\n *\n * @return {Number} the transaction total input amount\n */\nTransaction.prototype._getInputAmount = function() {\n  if (this._inputAmount == null) {\n    this._inputAmount = _.sumBy(this.inputs, function(input) {\n      if (input.output == null) {\n        throw new errors.Transaction.Input.MissingPreviousOutput();\n      }\n      return input.output.satoshis;\n    });\n  }\n  return this._inputAmount;\n};\n\nTransaction.prototype._updateChangeOutput = function(noClearSigs) {\n  if (!this._changeScript) {\n    return;\n  }\n  if (!noClearSigs) {\n    this._clearSignatures();\n  }\n  if (this._changeIndex != null) {\n    this._removeOutput(this._changeIndex);\n  }\n  var available = this._getUnspentValue();\n  var fee = this.getFee();\n  var changeAmount = available - fee;\n  if (changeAmount > Transaction.DUST_AMOUNT) {\n    this._changeIndex = this.outputs.length;\n    this._addOutput(new Output({\n      script: this._changeScript,\n      satoshis: changeAmount\n    }));\n  } else {\n    this._changeIndex = undefined;\n  }\n};\n/**\n * Calculates the fee of the transaction.\n *\n * If there's a fixed fee set, return that.\n *\n * If there is no change output set, the fee is the\n * total value of the outputs minus inputs. Note that\n * a serialized transaction only specifies the value\n * of its outputs. (The value of inputs are recorded\n * in the previous transaction outputs being spent.)\n * This method therefore raises a \"MissingPreviousOutput\"\n * error when called on a serialized transaction.\n *\n * If there's no fee set and no change address,\n * estimate the fee based on size.\n *\n * @return {Number} fee of this transaction in satoshis\n */\nTransaction.prototype.getFee = function() {\n  if (this.isCoinbase()) {\n    return 0;\n  }\n  if (this._fee != null) {\n    return this._fee;\n  }\n  // if no change output is set, fees should equal all the unspent amount\n  if (!this._changeScript) {\n    return this._getUnspentValue();\n  }\n  return this._estimateFee();\n};\n\n/**\n * Estimates fee from serialized transaction size in bytes.\n */\nTransaction.prototype._estimateFee = function () {\n  const estimatedSize = this._estimateSize();\n  const available = this._getUnspentValue();\n  const feeRate = this._feePerByte || (this._feePerKb || Transaction.FEE_PER_KB) / 1000;\n  function getFee(size) {\n    return size * feeRate;\n  }\n  const fee = Math.ceil(getFee(estimatedSize));\n  const feeWithChange = Math.ceil(getFee(estimatedSize) + getFee(this._estimateSizeOfChangeOutput()));\n  if (!this._changeScript || available <= feeWithChange) {\n    return fee;\n  }\n  return feeWithChange;\n};\n\nTransaction.prototype._estimateSizeOfChangeOutput = function () {\n  if (!this._changeScript) {\n    return 0;\n  }\n  const scriptLen = this._changeScript.toBuffer().length;\n  // 8 bytes for satoshis + script size + actual script size\n  return 8 + BufferWriter.varintBufNum(scriptLen).length + scriptLen;\n};\n\nTransaction.prototype._getUnspentValue = function() {\n  return this._getInputAmount() - this._getOutputAmount();\n};\n\nTransaction.prototype._clearSignatures = function() {\n  for (const input of this.inputs || []) {\n    input.clearSignatures();\n  }\n};\n\n/**\n * Estimate the tx size before input signatures are added.\n */\nTransaction.prototype._estimateSize = function() {\n  let result = 4; // version\n\n  if (this.hasWitnesses()) {\n    result += .5;\n  }\n\n  result += BufferWriter.varintBufNum(this.inputs.length).length;\n  for (const input of this.inputs || []) {\n    result += input._estimateSize();\n  }\n\n  result += BufferWriter.varintBufNum(this.outputs.length).length;\n  for (const output of this.outputs || []) {\n    result += output.calculateSize();\n  }\n\n  result += 4; // nLockTime\n  return Math.ceil(result);\n};\n\nTransaction.prototype._calculateSize = function() {\n  return this.toBuffer().length;\n};\n\nTransaction.prototype._calculateVSize = function(noRound) {\n  const vsize = this._calculateWeight() / 4;\n  return noRound ? vsize : Math.ceil(vsize);\n};\n\nTransaction.prototype._calculateWeight = function() {\n  return (this.toBuffer(true).length * 3) + this.toBuffer(false).length;\n};\n\nTransaction.prototype._removeOutput = function(index) {\n  var output = this.outputs[index];\n  this.outputs = _.without(this.outputs, output);\n  this._outputAmount = undefined;\n};\n\nTransaction.prototype.removeOutput = function(index) {\n  this._removeOutput(index);\n  this._updateChangeOutput();\n};\n\n/**\n * Sort a transaction's inputs and outputs according to BIP69\n *\n * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki}\n * @return {Transaction} this\n */\nTransaction.prototype.sort = function() {\n  this.sortInputs(function(inputs) {\n    var copy = Array.prototype.concat.apply([], inputs);\n    let i = 0;\n    copy.forEach((x) => { x.i = i++});\n    copy.sort(function(first, second) {\n     return compare(first.prevTxId, second.prevTxId)\n        || first.outputIndex - second.outputIndex\n        || first.i - second.i;  // to ensure stable sort\n    });\n    return copy;\n  });\n  this.sortOutputs(function(outputs) {\n    var copy = Array.prototype.concat.apply([], outputs);\n    let i = 0;\n    copy.forEach((x) => { x.i = i++});\n    copy.sort(function(first, second) {\n      return first.satoshis - second.satoshis\n        || compare(first.script.toBuffer(), second.script.toBuffer())\n        || first.i - second.i;  // to ensure stable sort\n    });\n    return copy;\n  });\n  return this;\n};\n\n/**\n * Randomize this transaction's outputs ordering. The shuffling algorithm is a\n * version of the Fisher-Yates shuffle, provided by lodash's _.shuffle().\n *\n * @return {Transaction} this\n */\nTransaction.prototype.shuffleOutputs = function() {\n  return this.sortOutputs(_.shuffle);\n};\n\n/**\n * Sort this transaction's outputs, according to a given sorting function that\n * takes an array as argument and returns a new array, with the same elements\n * but with a different order. The argument function MUST NOT modify the order\n * of the original array\n *\n * @param {Function} sortingFunction\n * @return {Transaction} this\n */\nTransaction.prototype.sortOutputs = function(sortingFunction) {\n  var outs = sortingFunction(this.outputs);\n  return this._newOutputOrder(outs);\n};\n\n/**\n * Sort this transaction's inputs, according to a given sorting function that\n * takes an array as argument and returns a new array, with the same elements\n * but with a different order.\n *\n * @param {Function} sortingFunction\n * @return {Transaction} this\n */\nTransaction.prototype.sortInputs = function(sortingFunction) {\n  this.inputs = sortingFunction(this.inputs);\n  this._clearSignatures();\n  return this;\n};\n\nTransaction.prototype._newOutputOrder = function(newOutputs) {\n  var isInvalidSorting = (this.outputs.length !== newOutputs.length ||\n                          _.difference(this.outputs, newOutputs).length !== 0);\n  if (isInvalidSorting) {\n    throw new errors.Transaction.InvalidSorting();\n  }\n\n  if (this._changeIndex != null) {\n    var changeOutput = this.outputs[this._changeIndex];\n    this._changeIndex = newOutputs.indexOf(changeOutput);\n  }\n\n  this.outputs = newOutputs;\n  return this;\n};\n\nTransaction.prototype.removeInput = function(txId, outputIndex) {\n  var index;\n  if (!outputIndex && !isNaN(txId)) {\n    index = txId;\n  } else {\n    index = this.inputs.findIndex(function(input) {\n      return input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex;\n    });\n  }\n  if (index < 0 || index >= this.inputs.length) {\n    throw new errors.Transaction.InvalidIndex(index, this.inputs.length);\n  }\n  var input = this.inputs[index];\n  this.inputs = _.without(this.inputs, input);\n  this._inputAmount = undefined;\n  this._updateChangeOutput();\n};\n\n/* Signature handling */\n\n/**\n * Sign the transaction using one or more private keys.\n *\n * It tries to sign each input, verifying that the signature will be valid\n * (matches a public key).\n *\n * @param {Array|String|PrivateKey} privateKey\n * @param {number} [sigtype]\n * @param {String} [signingMethod] - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer|String} [merkleRoot] - merkle root for taproot signing\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.sign = function(privateKey, sigtype, signingMethod, merkleRoot) {\n  $.checkState(this.hasAllUtxoInfo(), 'Not all utxo information is available to sign the transaction.');\n  if (Array.isArray(privateKey)) {\n    for (const pk of privateKey) {\n      this.sign(pk, sigtype, signingMethod, merkleRoot);\n    }\n    return this;\n  }\n  for (const signature of this.getSignatures(privateKey, sigtype, signingMethod, merkleRoot)) {\n    this.applySignature(signature, signingMethod);\n  }\n  return this;\n};\n\nTransaction.prototype.getSignatures = function(privKey, sigtype, signingMethod, merkleRoot) {\n  if (typeof merkleRoot === 'string') {\n    merkleRoot = Buffer.from(merkleRoot, 'hex');\n  }\n  privKey = new PrivateKey(privKey);\n  const results = [];\n  const hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());\n  for (let i = 0; i < this.inputs.length; i++) {\n    const input = this.inputs[i];\n    for (const signature of input.getSignatures(this, privKey, i, sigtype, hashData, signingMethod, merkleRoot)) {\n      results.push(signature);\n    }\n  }\n  return results;\n};\n\n/**\n * Add a signature to the transaction\n *\n * @param {Object} signature\n * @param {number} signature.inputIndex\n * @param {number} signature.sigtype\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {String} signingMethod - 'ecdsa' to sign transaction\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.applySignature = function(signature, signingMethod) {\n  this.inputs[signature.inputIndex].addSignature(this, signature, signingMethod);\n  return this;\n};\n\nTransaction.prototype.isFullySigned = function() {\n  for (const input of this.inputs || []) {\n    if (input.isFullySigned === Input.prototype.isFullySigned) {\n      throw new errors.Transaction.UnableToVerifySignature(\n        'Unrecognized script kind, or not enough information to execute script.' +\n        'This usually happens when creating a transaction from a serialized transaction'\n      );\n    }\n  }\n  return this.inputs.every(function(input) {\n    return input.isFullySigned();\n  });\n};\n\nTransaction.prototype.isValidSignature = function(signature, signingMethod) {\n  if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {\n    throw new errors.Transaction.UnableToVerifySignature(\n      'Unrecognized script kind, or not enough information to execute script.' +\n      'This usually happens when creating a transaction from a serialized transaction'\n    );\n  }\n  return this.inputs[signature.inputIndex].isValidSignature(this, signature, signingMethod);\n};\n\n\n/**\n * Verify ECDSA signature\n * @param {Signature} sig \n * @param {PublicKey} pubkey \n * @param {Number} nin \n * @param {Script} subscript \n * @param {Number} satoshis \n * @returns {Boolean}\n */\nTransaction.prototype.checkEcdsaSignature = function(sig, pubkey, nin, subscript, satoshis) {\n  var subscriptBuffer = subscript.toBuffer();\n  var scriptCodeWriter = new BufferWriter();\n  scriptCodeWriter.writeVarintNum(subscriptBuffer.length);\n  scriptCodeWriter.write(subscriptBuffer);\n\n  var satoshisBuffer;\n  if (satoshis) {\n    $.checkState(JSUtil.isNaturalNumber(satoshis), 'satoshis needs to be a natural number');\n    satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();\n  } else {\n    satoshisBuffer = this.inputs[nin].getSatoshisBuffer();\n  }\n  var verified = SighashWitness.verify(\n    this,\n    sig,\n    pubkey,\n    nin,\n    scriptCodeWriter.toBuffer(),\n    satoshisBuffer\n  );\n  return verified;\n};\n\n\n/**\n * Verify Schnorr signature\n * @param {Signature|Buffer} sig \n * @param {PublicKey|Buffer} pubkey \n * @param {Number} nin \n * @param {Number} sigversion \n * @param {Object} execdata \n * @returns {Boolean}\n */\nTransaction.prototype.checkSchnorrSignature = function(sig, pubkey, nin, sigversion, execdata) {\n  if ($.isType(pubkey, 'PublicKey')) {\n    pubkey = pubkey.point.x.toBuffer();\n  }\n  $.checkArgument(pubkey && pubkey.length === 32, 'Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.');\n\n  if (Buffer.isBuffer(sig)) {\n    if (sig.length !== 64 && sig.length !== 65) {\n      return false;\n    }\n    sig = Signature.fromSchnorr(sig);\n  }\n  // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not\n  // abort script execution). This is implemented in Interpreter.evalChecksigTapscript, which won't invoke\n  // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with\n  // size different from 64 or 65.\n  $.checkArgument(sig.isSchnorr, 'Signature must be schnorr');\n\n  if (!SighashSchnorr.verify(this, sig, pubkey, sigversion, nin, execdata)) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * This is here largely for legacy reasons. However, if the sig type\n * is already known (via sigversion), then it would be better to call\n * checkEcdsaSignature or checkSchnorrSignature directly.\n * @param {Signature|Buffer} sig Signature to verify\n * @param {PublicKey|Buffer} pubkey Public key used to verify sig\n * @param {Number} nin Tx input index to verify signature against\n * @param {Script} subscript ECDSA only\n * @param {Number} sigversion See Signature.Version for valid versions (default: 0 or Signature.Version.BASE)\n * @param {Number} satoshis ECDSA only\n * @param {Object} execdata Schnorr only\n * @returns {Boolean} whether the signature is valid for this transaction input\n */\nTransaction.prototype.verifySignature = function(sig, pubkey, nin, subscript, sigversion, satoshis, execdata) {\n  if (sigversion == null) {\n    sigversion = Signature.Version.BASE;\n  }\n\n  switch(sigversion) {\n    case Signature.Version.WITNESS_V0:\n      return this.checkEcdsaSignature(sig, pubkey, nin, subscript, satoshis);\n    case Signature.Version.TAPROOT:\n    case Signature.Version.TAPSCRIPT:\n      return this.checkSchnorrSignature(sig, pubkey, nin, sigversion, execdata);\n    case Signature.Version.BASE:\n    default:\n      return Sighash.verify(this, sig, pubkey, nin, subscript);\n  }\n};\n\n/**\n * Check that a transaction passes basic sanity tests. If not, return a string\n * describing the error. This function contains the same logic as\n * CheckTransaction in bitcoin core.\n */\nTransaction.prototype.verify = function() {\n  // Basic checks that don't depend on any context\n  if (this.inputs.length === 0) {\n    return 'transaction txins empty';\n  }\n\n  if (this.outputs.length === 0) {\n    return 'transaction txouts empty';\n  }\n\n  // Check for negative or overflow output values\n  var valueoutbn = new BN(0);\n  for (var i = 0; i < this.outputs.length; i++) {\n    var txout = this.outputs[i];\n\n    if (txout.invalidSatoshis()) {\n      return 'transaction txout ' + i + ' satoshis is invalid';\n    }\n    if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {\n      return 'transaction txout ' + i + ' greater than MAX_MONEY';\n    }\n    valueoutbn = valueoutbn.add(txout._satoshisBN);\n    if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {\n      return 'transaction txout ' + i + ' total output greater than MAX_MONEY';\n    }\n  }\n\n  // Size limits\n  if (this.toBuffer().length > MAX_BLOCK_SIZE) {\n    return 'transaction over the maximum block size';\n  }\n\n  // Check for duplicate inputs\n  var txinmap = {};\n  for (i = 0; i < this.inputs.length; i++) {\n    var txin = this.inputs[i];\n\n    var inputid = txin.prevTxId + ':' + txin.outputIndex;\n    if (txinmap[inputid] != null) {\n      return 'transaction input ' + i + ' duplicate input';\n    }\n    txinmap[inputid] = true;\n  }\n\n  var isCoinbase = this.isCoinbase();\n  if (isCoinbase) {\n    var buf = this.inputs[0]._scriptBuffer;\n    if (buf.length < 2 || buf.length > 100) {\n      return 'coinbase transaction script size invalid';\n    }\n  } else {\n    for (i = 0; i < this.inputs.length; i++) {\n      if (this.inputs[i].isNull()) {\n        return 'transaction input ' + i + ' has null input';\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * Analogous to bitcoind's IsCoinBase function in transaction.h\n */\nTransaction.prototype.isCoinbase = function() {\n  return (this.inputs.length === 1 && this.inputs[0].isNull());\n};\n\n/**\n * Determines if this transaction can be replaced in the mempool with another\n * transaction that provides a sufficiently higher fee (RBF).\n */\nTransaction.prototype.isRBF = function() {\n  for (var i = 0; i < this.inputs.length; i++) {\n    var input = this.inputs[i];\n    if (input.sequenceNumber < Input.MAXINT - 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Enable this transaction to be replaced in the mempool (RBF) if a transaction\n * includes a sufficiently higher fee. It will set the sequenceNumber to\n * DEFAULT_RBF_SEQNUMBER for all inputs if the sequence number does not\n * already enable RBF.\n */\nTransaction.prototype.enableRBF = function() {\n  for (var i = 0; i < this.inputs.length; i++) {\n    var input = this.inputs[i];\n    if (input.sequenceNumber >= Input.MAXINT - 1) {\n      input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;\n    }\n  }\n  return this;\n};\n\nTransaction.prototype.setVersion = function(version) {\n  $.checkArgument(\n    JSUtil.isNaturalNumber(version) && version <= CURRENT_VERSION,\n    'Wrong version number');\n  this.version = version;\n  return this;\n};\n\n\n\nmodule.exports = Transaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxxREFBUTtBQUN4QixRQUFRLG1CQUFPLENBQUMseUZBQXVCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixnQ0FBZ0MsbUJBQU8sQ0FBQyxvRUFBZ0I7O0FBRXhELGFBQWEsbUJBQU8sQ0FBQyx1RUFBVztBQUNoQyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLG1FQUFZO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUEwQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDckQsV0FBVyxtQkFBTyxDQUFDLDJFQUFnQjtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBcUI7QUFDN0MsY0FBYyxtQkFBTyxDQUFDLDhFQUFXO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLDRGQUFrQjtBQUMvQyx1QkFBdUIsbUJBQU8sQ0FBQyw0RkFBa0I7O0FBRWpELGNBQWMsbUJBQU8sQ0FBQyxtRUFBWTtBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQywwRkFBaUI7QUFDN0MsWUFBWSxtQkFBTyxDQUFDLGdGQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsNEVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHVFQUFXO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFlO0FBQ3hDLFNBQVMsbUJBQU8sQ0FBQyx1RUFBYzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSxvQ0FBb0M7QUFDdkQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSxvQ0FBb0M7QUFDdkQsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0VBQW9FO0FBQ3pGO0FBQ0E7QUFDQSxxQkFBcUIsd0VBQXdFO0FBQzdGO0FBQ0E7QUFDQSxxQkFBcUIsd0VBQXdFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQXlEO0FBQ3BFLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUErQztBQUMxRCxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanM/NDljOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJlY29uZGl0aW9ucycpO1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIGNvbXBhcmUgPSBCdWZmZXIuY29tcGFyZSB8fCByZXF1aXJlKCdidWZmZXItY29tcGFyZScpO1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG52YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJyk7XG52YXIgSlNVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9qcycpO1xudmFyIEJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcnJlYWRlcicpO1xudmFyIEJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoJy4uL2VuY29kaW5nL2J1ZmZlcndyaXRlcicpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuLi9jcnlwdG8vaGFzaCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL2NyeXB0by9zaWduYXR1cmUnKTtcbnZhciBTaWdoYXNoID0gcmVxdWlyZSgnLi9zaWdoYXNoJyk7XG52YXIgU2lnaGFzaFdpdG5lc3MgPSByZXF1aXJlKCcuL3NpZ2hhc2h3aXRuZXNzJyk7XG5jb25zdCBTaWdoYXNoU2Nobm9yciA9IHJlcXVpcmUoJy4vc2lnaGFzaHNjaG5vcnInKTtcblxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi9hZGRyZXNzJyk7XG52YXIgVW5zcGVudE91dHB1dCA9IHJlcXVpcmUoJy4vdW5zcGVudG91dHB1dCcpO1xudmFyIElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xudmFyIFB1YmxpY0tleUhhc2hJbnB1dCA9IElucHV0LlB1YmxpY0tleUhhc2g7XG52YXIgUHVibGljS2V5SW5wdXQgPSBJbnB1dC5QdWJsaWNLZXk7XG52YXIgTXVsdGlTaWdTY3JpcHRIYXNoSW5wdXQgPSBJbnB1dC5NdWx0aVNpZ1NjcmlwdEhhc2g7XG52YXIgTXVsdGlTaWdJbnB1dCA9IElucHV0Lk11bHRpU2lnO1xuY29uc3QgVGFwcm9vdElucHV0ID0gSW5wdXQuVGFwcm9vdDtcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuL291dHB1dCcpO1xudmFyIFNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKCcuLi9wcml2YXRla2V5Jyk7XG52YXIgQk4gPSByZXF1aXJlKCcuLi9jcnlwdG8vYm4nKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24sIGEgc2V0IG9mIGlucHV0cyBhbmQgb3V0cHV0cyB0byBjaGFuZ2Ugb3duZXJzaGlwIG9mIHRva2Vuc1xuICpcbiAqIEBwYXJhbSB7Kn0gW3NlcmlhbGl6ZWRdXG4gKiBAcGFyYW0geyp9IFtvcHRzXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRyYW5zYWN0aW9uKHNlcmlhbGl6ZWQsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oc2VyaWFsaXplZCk7XG4gIH1cbiAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgdGhpcy5vdXRwdXRzID0gW107XG4gIHRoaXMuX2lucHV0QW1vdW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vdXRwdXRBbW91bnQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAoc2VyaWFsaXplZCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gVHJhbnNhY3Rpb24uc2hhbGxvd0NvcHkoc2VyaWFsaXplZCk7XG4gICAgfSBlbHNlIGlmIChKU1V0aWwuaXNIZXhhKHNlcmlhbGl6ZWQpKSB7XG4gICAgICB0aGlzLmZyb21TdHJpbmcoc2VyaWFsaXplZCk7XG4gICAgfSBlbHNlIGlmIChCdWZmZXJVdGlsLmlzQnVmZmVyKHNlcmlhbGl6ZWQpKSB7XG4gICAgICB0aGlzLmZyb21CdWZmZXIoc2VyaWFsaXplZCk7XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHNlcmlhbGl6ZWQpKSB7XG4gICAgICB0aGlzLmZyb21PYmplY3Qoc2VyaWFsaXplZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50KCdNdXN0IHByb3ZpZGUgYW4gb2JqZWN0IG9yIHN0cmluZyB0byBkZXNlcmlhbGl6ZSBhIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX25ld1RyYW5zYWN0aW9uKCk7XG4gIH1cbn1cbnZhciBDVVJSRU5UX1ZFUlNJT04gPSAyO1xudmFyIERFRkFVTFRfTkxPQ0tUSU1FID0gMDtcbnZhciBNQVhfQkxPQ0tfU0laRSA9IDEwMDAwMDA7XG5cbi8vIE1pbmltdW0gYW1vdW50IGZvciBhbiBvdXRwdXQgZm9yIGl0IG5vdCB0byBiZSBjb25zaWRlcmVkIGEgZHVzdCBvdXRwdXRcblRyYW5zYWN0aW9uLkRVU1RfQU1PVU5UID0gNTQ2O1xuXG4vLyBNYXJnaW4gb2YgZXJyb3IgdG8gYWxsb3cgZmVlcyBpbiB0aGUgdmVjaW5pdHkgb2YgdGhlIGV4cGVjdGVkIHZhbHVlIGJ1dCBkb2Vzbid0IGFsbG93IGEgYmlnIGRpZmZlcmVuY2VcblRyYW5zYWN0aW9uLkZFRV9TRUNVUklUWV9NQVJHSU4gPSAxNTA7XG5cbi8vIG1heCBhbW91bnQgb2Ygc2F0b3NoaXMgaW4gY2lyY3VsYXRpb25cblRyYW5zYWN0aW9uLk1BWF9NT05FWSA9IDIxMDAwMDAwICogMWU4O1xuXG4vLyBubG9ja3RpbWUgbGltaXQgdG8gYmUgY29uc2lkZXJlZCBibG9jayBoZWlnaHQgcmF0aGVyIHRoYW4gYSB0aW1lc3RhbXBcblRyYW5zYWN0aW9uLk5MT0NLVElNRV9CTE9DS0hFSUdIVF9MSU1JVCA9IDVlODtcblxuLy8gTWF4IHZhbHVlIGZvciBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWVcblRyYW5zYWN0aW9uLk5MT0NLVElNRV9NQVhfVkFMVUUgPSA0Mjk0OTY3Mjk1O1xuXG4vLyBWYWx1ZSB1c2VkIGZvciBmZWUgZXN0aW1hdGlvbiAoc2F0b3NoaXMgcGVyIGtpbG9ieXRlKVxuVHJhbnNhY3Rpb24uRkVFX1BFUl9LQiA9IDEwMDAwMDtcblxuLy8gU2FmZSB1cHBlciBib3VuZCBmb3IgY2hhbmdlIGFkZHJlc3Mgc2NyaXB0IHNpemUgaW4gYnl0ZXNcblRyYW5zYWN0aW9uLkNIQU5HRV9PVVRQVVRfTUFYX1NJWkUgPSAyMCArIDQgKyAzNCArIDQ7XG5UcmFuc2FjdGlvbi5NQVhJTVVNX0VYVFJBX1NJWkUgPSA0ICsgOSArIDkgKyA0O1xuXG4vKiBDb25zdHJ1Y3RvcnMgYW5kIFNlcmlhbGl6YXRpb24gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSAnc2hhbGxvdycgY29weSBvZiB0aGUgdHJhbnNhY3Rpb24sIGJ5IHNlcmlhbGl6aW5nIGFuZCBkZXNlcmlhbGl6aW5nXG4gKiBpdCBkcm9wcGluZyBhbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aGF0IGlucHV0cyBhbmQgb3V0cHV0cyBtYXkgaGF2ZSBob2xkXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufVxuICovXG5UcmFuc2FjdGlvbi5zaGFsbG93Q29weSA9IGZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBjb3B5ID0gbmV3IFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLnRvQnVmZmVyKCkpO1xuICByZXR1cm4gY29weTtcbn07XG5cbnZhciBoYXNoUHJvcGVydHkgPSB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faGFzaCA9IG5ldyBCdWZmZXJSZWFkZXIodGhpcy5fZ2V0SGFzaCgpKS5yZWFkUmV2ZXJzZSgpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgfVxufTtcblxudmFyIHdpdG5lc3NIYXNoUHJvcGVydHkgPSB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJSZWFkZXIodGhpcy5fZ2V0V2l0bmVzc0hhc2goKSkucmVhZFJldmVyc2UoKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsICd3aXRuZXNzSGFzaCcsIHdpdG5lc3NIYXNoUHJvcGVydHkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ2hhc2gnLCBoYXNoUHJvcGVydHkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ2lkJywgaGFzaFByb3BlcnR5KTtcblxudmFyIGlvUHJvcGVydHkgPSB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldElucHV0QW1vdW50KCk7XG4gIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCAnaW5wdXRBbW91bnQnLCBpb1Byb3BlcnR5KTtcbmlvUHJvcGVydHkuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nZXRPdXRwdXRBbW91bnQoKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCAnb3V0cHV0QW1vdW50JywgaW9Qcm9wZXJ0eSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsICdzaXplJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlU2l6ZSgpO1xuICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgJ3ZzaXplJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlVlNpemUoKTtcbiAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsICd3ZWlnaHQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVXZWlnaHQoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpdHRsZSBlbmRpYW4gaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gKHVzZWQgZm9yIHNlcmlhbGl6YXRpb24pXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZ2V0SGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSGFzaC5zaGEyNTZzaGEyNTYodGhpcy50b0J1ZmZlcih0cnVlKSk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXR0bGUgZW5kaWFuIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGluY2x1ZGluZyB3aXRuZXNzIGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9nZXRXaXRuZXNzSGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSGFzaC5zaGEyNTZzaGEyNTYodGhpcy50b0J1ZmZlcihmYWxzZSkpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGhleGEgc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBiaXRjb2luZCdzIENMSSBpbnRlcmZhY2VcbiAqIChkZWNvZGVyYXd0cmFuc2FjdGlvbiwgc2VuZHJhd3RyYW5zYWN0aW9uKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW49fSB1bnNhZmUgaWYgdHJ1ZSwgc2tpcCBhbGwgdGVzdHMuIGlmIGl0J3MgYW4gb2JqZWN0LFxuICogICBpdCdzIGV4cGVjdGVkIHRvIGNvbnRhaW4gYSBzZXQgb2YgZmxhZ3MgdG8gc2tpcCBjZXJ0YWluIHRlc3RzOlxuICogKiBgZGlzYWJsZUFsbGA6IGRpc2FibGUgYWxsIGNoZWNrc1xuICogKiBgZGlzYWJsZVNtYWxsRmVlc2A6IGRpc2FibGUgY2hlY2tpbmcgZm9yIGZlZXMgdGhhdCBhcmUgdG9vIHNtYWxsXG4gKiAqIGBkaXNhYmxlTGFyZ2VGZWVzYDogZGlzYWJsZSBjaGVja2luZyBmb3IgZmVlcyB0aGF0IGFyZSB0b28gbGFyZ2VcbiAqICogYGRpc2FibGVJc0Z1bGx5U2lnbmVkYDogZGlzYWJsZSBjaGVja2luZyBpZiBhbGwgaW5wdXRzIGFyZSBmdWxseSBzaWduZWRcbiAqICogYGRpc2FibGVEdXN0T3V0cHV0c2A6IGRpc2FibGUgY2hlY2tpbmcgaWYgdGhlcmUgYXJlIG5vIG91dHB1dHMgdGhhdCBhcmUgZHVzdCBhbW91bnRzXG4gKiAqIGBkaXNhYmxlTW9yZU91dHB1dFRoYW5JbnB1dGA6IGRpc2FibGUgY2hlY2tpbmcgaWYgdGhlIHRyYW5zYWN0aW9uIHNwZW5kcyBtb3JlIGJpdGNvaW5zIHRoYW4gdGhlIHN1bSBvZiB0aGUgaW5wdXQgYW1vdW50c1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24odW5zYWZlKSB7XG4gIGlmICh0cnVlID09PSB1bnNhZmUgfHwgdW5zYWZlICYmIHVuc2FmZS5kaXNhYmxlQWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudW5jaGVja2VkU2VyaWFsaXplKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tlZFNlcmlhbGl6ZSh1bnNhZmUpO1xuICB9XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUudW5jaGVja2VkU2VyaWFsaXplID0gVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGhleGEgc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBiaXRjb2luZCdzIENMSSBpbnRlcmZhY2VcbiAqIChkZWNvZGVyYXd0cmFuc2FjdGlvbiwgc2VuZHJhd3RyYW5zYWN0aW9uKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIGFsbG93cyB0byBza2lwIGNlcnRhaW4gdGVzdHMuIHtAc2VlIFRyYW5zYWN0aW9uI3NlcmlhbGl6ZX1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmNoZWNrZWRTZXJpYWxpemUgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciBzZXJpYWxpemF0aW9uRXJyb3IgPSB0aGlzLmdldFNlcmlhbGl6YXRpb25FcnJvcihvcHRzKTtcbiAgaWYgKHNlcmlhbGl6YXRpb25FcnJvcikge1xuICAgIHNlcmlhbGl6YXRpb25FcnJvci5tZXNzYWdlICs9ICcgLSBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlOiAnICtcbiAgICAgICdodHRwczovL2dpdGh1Yi5jb20vYml0cGF5L2JpdGNvcmUvYmxvYi9tYXN0ZXIvcGFja2FnZXMvYml0Y29yZS1saWIvZG9jcy90cmFuc2FjdGlvbi5tZCNzZXJpYWxpemF0aW9uLWNoZWNrcyc7XG4gICAgdGhyb3cgc2VyaWFsaXphdGlvbkVycm9yO1xuICB9XG4gIHJldHVybiB0aGlzLnVuY2hlY2tlZFNlcmlhbGl6ZSgpO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmludmFsaWRTYXRvc2hpcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW52YWxpZCA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLm91dHB1dHNbaV0uaW52YWxpZFNhdG9zaGlzKCkpIHtcbiAgICAgIGludmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW52YWxpZDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYSBwb3NzaWJsZSBlcnJvciB0aGF0IGNvdWxkIGFwcGVhciB3aGVuIHRyeWluZyB0byBzZXJpYWxpemUgYW5kXG4gKiBicm9hZGNhc3QgdGhpcyB0cmFuc2FjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBhbGxvd3MgdG8gc2tpcCBjZXJ0YWluIHRlc3RzLiB7QHNlZSBUcmFuc2FjdGlvbiNzZXJpYWxpemV9XG4gKiBAcmV0dXJuIHtiaXRjb3JlLkVycm9yfVxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0U2VyaWFsaXphdGlvbkVycm9yID0gZnVuY3Rpb24ob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodGhpcy5pbnZhbGlkU2F0b3NoaXMoKSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkludmFsaWRTYXRvc2hpcygpO1xuICB9XG5cbiAgdmFyIHVuc3BlbnQgPSB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcbiAgdmFyIHVuc3BlbnRFcnJvcjtcbiAgaWYgKHVuc3BlbnQgPCAwKSB7XG4gICAgaWYgKCFvcHRzLmRpc2FibGVNb3JlT3V0cHV0VGhhbklucHV0KSB7XG4gICAgICB1bnNwZW50RXJyb3IgPSBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkludmFsaWRPdXRwdXRBbW91bnRTdW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdW5zcGVudEVycm9yID0gdGhpcy5faGFzRmVlRXJyb3Iob3B0cywgdW5zcGVudCk7XG4gIH1cblxuICByZXR1cm4gdW5zcGVudEVycm9yIHx8XG4gICAgdGhpcy5faGFzRHVzdE91dHB1dHMob3B0cykgfHxcbiAgICB0aGlzLl9pc01pc3NpbmdTaWduYXR1cmVzKG9wdHMpO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9oYXNGZWVFcnJvciA9IGZ1bmN0aW9uKG9wdHMsIHVuc3BlbnQpIHtcblxuICBpZiAodGhpcy5fZmVlICE9IG51bGwgJiYgdGhpcy5fZmVlICE9PSB1bnNwZW50KSB7XG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uRmVlRXJyb3IuRGlmZmVyZW50KFxuICAgICAgJ1Vuc3BlbnQgdmFsdWUgaXMgJyArIHVuc3BlbnQgKyAnIGJ1dCBzcGVjaWZpZWQgZmVlIGlzICcgKyB0aGlzLl9mZWVcbiAgICApO1xuICB9XG5cbiAgaWYgKCFvcHRzLmRpc2FibGVMYXJnZUZlZXMpIHtcbiAgICB2YXIgbWF4aW11bUZlZSA9IE1hdGguZmxvb3IoVHJhbnNhY3Rpb24uRkVFX1NFQ1VSSVRZX01BUkdJTiAqIHRoaXMuX2VzdGltYXRlRmVlKCkpO1xuICAgIGlmICh1bnNwZW50ID4gbWF4aW11bUZlZSkge1xuICAgICAgaWYgKHRoaXMuX21pc3NpbmdDaGFuZ2UoKSkge1xuICAgICAgICByZXR1cm4gbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5DaGFuZ2VBZGRyZXNzTWlzc2luZyhcbiAgICAgICAgICAnRmVlIGlzIHRvbyBsYXJnZSBhbmQgbm8gY2hhbmdlIGFkZHJlc3Mgd2FzIHByb3ZpZGVkJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uRmVlRXJyb3IuVG9vTGFyZ2UoXG4gICAgICAgICdleHBlY3RlZCBsZXNzIHRoYW4gJyArIG1heGltdW1GZWUgKyAnIGJ1dCBnb3QgJyArIHVuc3BlbnRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRzLmRpc2FibGVTbWFsbEZlZXMpIHtcbiAgICB2YXIgbWluaW11bUZlZSA9IE1hdGguY2VpbCh0aGlzLl9lc3RpbWF0ZUZlZSgpIC8gVHJhbnNhY3Rpb24uRkVFX1NFQ1VSSVRZX01BUkdJTik7XG4gICAgaWYgKHVuc3BlbnQgPCBtaW5pbXVtRmVlKSB7XG4gICAgICByZXR1cm4gbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5GZWVFcnJvci5Ub29TbWFsbChcbiAgICAgICAgJ2V4cGVjdGVkIG1vcmUgdGhhbiAnICsgbWluaW11bUZlZSArICcgYnV0IGdvdCAnICsgdW5zcGVudFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fbWlzc2luZ0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuX2NoYW5nZVNjcmlwdDtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5faGFzRHVzdE91dHB1dHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIGlmIChvcHRzLmRpc2FibGVEdXN0T3V0cHV0cykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXgsIG91dHB1dDtcbiAgZm9yIChpbmRleCBpbiB0aGlzLm91dHB1dHMpIHtcbiAgICBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaW5kZXhdO1xuICAgIGlmIChvdXRwdXQuc2F0b3NoaXMgPCBUcmFuc2FjdGlvbi5EVVNUX0FNT1VOVCAmJiAhb3V0cHV0LnNjcmlwdC5pc0RhdGFPdXQoKSkge1xuICAgICAgcmV0dXJuIG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uRHVzdE91dHB1dHMoKTtcbiAgICB9XG4gIH1cbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5faXNNaXNzaW5nU2lnbmF0dXJlcyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgaWYgKG9wdHMuZGlzYWJsZUlzRnVsbHlTaWduZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF0aGlzLmlzRnVsbHlTaWduZWQoKSkge1xuICAgIHJldHVybiBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLk1pc3NpbmdTaWduYXR1cmVzKCk7XG4gIH1cbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPFRyYW5zYWN0aW9uOiAnICsgdGhpcy51bmNoZWNrZWRTZXJpYWxpemUoKSArICc+Jztcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKG5vV2l0bmVzcykge1xuICB2YXIgd3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICByZXR1cm4gdGhpcy50b0J1ZmZlcldyaXRlcih3cml0ZXIsIG5vV2l0bmVzcykudG9CdWZmZXIoKTtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5oYXNXaXRuZXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmlucHV0c1tpXS5oYXNXaXRuZXNzZXMoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS50b0J1ZmZlcldyaXRlciA9IGZ1bmN0aW9uKHdyaXRlciwgbm9XaXRuZXNzKSB7XG4gIHdyaXRlci53cml0ZUludDMyTEUodGhpcy52ZXJzaW9uKTtcblxuICBjb25zdCBoYXNXaXRuZXNzZXMgPSB0aGlzLmhhc1dpdG5lc3NlcygpO1xuXG4gIGlmIChoYXNXaXRuZXNzZXMgJiYgIW5vV2l0bmVzcykge1xuICAgIHdyaXRlci53cml0ZShCdWZmZXIuZnJvbSgnMDAwMScsICdoZXgnKSk7XG4gIH1cblxuICB3cml0ZXIud3JpdGVWYXJpbnROdW0odGhpcy5pbnB1dHMgPyB0aGlzLmlucHV0cy5sZW5ndGggOiAwKTtcbiAgZm9yIChjb25zdCBpbnB1dCBvZiB0aGlzLmlucHV0cyB8fCBbXSkge1xuICAgIGlucHV0LnRvQnVmZmVyV3JpdGVyKHdyaXRlcik7XG4gIH1cblxuICB3cml0ZXIud3JpdGVWYXJpbnROdW0odGhpcy5vdXRwdXRzID8gdGhpcy5vdXRwdXRzLmxlbmd0aCA6IDApO1xuICBmb3IgKGNvbnN0IG91dHB1dCBvZiB0aGlzLm91dHB1dHMgfHwgW10pIHtcbiAgICBvdXRwdXQudG9CdWZmZXJXcml0ZXIod3JpdGVyKTtcbiAgfVxuXG4gIGlmIChoYXNXaXRuZXNzZXMgJiYgIW5vV2l0bmVzcykge1xuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dHMpIHtcbiAgICAgIGNvbnN0IHdpdG5lc3NlcyA9IGlucHV0LmdldFdpdG5lc3NlcygpO1xuICAgICAgd3JpdGVyLndyaXRlVmFyaW50TnVtKHdpdG5lc3Nlcy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aXRuZXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgd3JpdGVyLndyaXRlVmFyaW50TnVtKHdpdG5lc3Nlc1tqXS5sZW5ndGgpO1xuICAgICAgICB3cml0ZXIud3JpdGUod2l0bmVzc2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3cml0ZXIud3JpdGVVSW50MzJMRSh0aGlzLm5Mb2NrVGltZSk7XG4gIHJldHVybiB3cml0ZXI7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVhZGVyID0gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpO1xuICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyUmVhZGVyKHJlYWRlcik7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZnJvbUJ1ZmZlclJlYWRlciA9IGZ1bmN0aW9uKHJlYWRlcikge1xuICAkLmNoZWNrQXJndW1lbnQoIXJlYWRlci5maW5pc2hlZCgpLCAnTm8gdHJhbnNhY3Rpb24gZGF0YSByZWNlaXZlZCcpO1xuXG4gIHRoaXMudmVyc2lvbiA9IHJlYWRlci5yZWFkSW50MzJMRSgpO1xuICB2YXIgc2l6ZVR4SW5zID0gcmVhZGVyLnJlYWRWYXJpbnROdW0oKTtcblxuICAvLyBjaGVjayBmb3Igc2Vnd2l0XG4gIHZhciBoYXNXaXRuZXNzZXMgPSBmYWxzZTtcbiAgaWYgKHNpemVUeElucyA9PT0gMCAmJiByZWFkZXIuYnVmW3JlYWRlci5wb3NdICE9PSAwKSB7XG4gICAgcmVhZGVyLnBvcyArPSAxO1xuICAgIGhhc1dpdG5lc3NlcyA9IHRydWU7XG4gICAgc2l6ZVR4SW5zID0gcmVhZGVyLnJlYWRWYXJpbnROdW0oKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVR4SW5zOyBpKyspIHtcbiAgICB2YXIgaW5wdXQgPSBJbnB1dC5mcm9tQnVmZmVyUmVhZGVyKHJlYWRlcik7XG4gICAgdGhpcy5pbnB1dHMucHVzaChpbnB1dCk7XG4gIH1cblxuICB2YXIgc2l6ZVR4T3V0cyA9IHJlYWRlci5yZWFkVmFyaW50TnVtKCk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVR4T3V0czsgaisrKSB7XG4gICAgdGhpcy5vdXRwdXRzLnB1c2goT3V0cHV0LmZyb21CdWZmZXJSZWFkZXIocmVhZGVyKSk7XG4gIH1cblxuICBpZiAoaGFzV2l0bmVzc2VzKSB7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaXplVHhJbnM7IGsrKykge1xuICAgICAgdmFyIGl0ZW1Db3VudCA9IHJlYWRlci5yZWFkVmFyaW50TnVtKCk7XG4gICAgICB2YXIgd2l0bmVzc2VzID0gW107XG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGl0ZW1Db3VudDsgbCsrKSB7XG4gICAgICAgIHZhciBzaXplID0gcmVhZGVyLnJlYWRWYXJpbnROdW0oKTtcbiAgICAgICAgdmFyIGl0ZW0gPSByZWFkZXIucmVhZChzaXplKTtcbiAgICAgICAgd2l0bmVzc2VzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlucHV0c1trXS5zZXRXaXRuZXNzZXMod2l0bmVzc2VzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm5Mb2NrVGltZSA9IHJlYWRlci5yZWFkVUludDMyTEUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS50b09iamVjdCA9IFRyYW5zYWN0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgdmFyIGlucHV0cyA9IFtdO1xuICB0aGlzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaW5wdXRzLnB1c2goaW5wdXQudG9PYmplY3QoKSk7XG4gIH0pO1xuICB2YXIgb3V0cHV0cyA9IFtdO1xuICB0aGlzLm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbihvdXRwdXQpIHtcbiAgICBvdXRwdXRzLnB1c2gob3V0cHV0LnRvT2JqZWN0KCkpO1xuICB9KTtcbiAgdmFyIG9iaiA9IHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgIGlucHV0czogaW5wdXRzLFxuICAgIG91dHB1dHM6IG91dHB1dHMsXG4gICAgbkxvY2tUaW1lOiB0aGlzLm5Mb2NrVGltZVxuICB9O1xuICBpZiAodGhpcy5fY2hhbmdlU2NyaXB0KSB7XG4gICAgb2JqLmNoYW5nZVNjcmlwdCA9IHRoaXMuX2NoYW5nZVNjcmlwdC50b1N0cmluZygpO1xuICB9XG4gIGlmICh0aGlzLl9jaGFuZ2VJbmRleCAhPSBudWxsKSB7XG4gICAgb2JqLmNoYW5nZUluZGV4ID0gdGhpcy5fY2hhbmdlSW5kZXg7XG4gIH1cbiAgaWYgKHRoaXMuX2ZlZSAhPSBudWxsKSB7XG4gICAgb2JqLmZlZSA9IHRoaXMuX2ZlZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KGFyZywgb3B0cykge1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3QoYXJnKSB8fCBhcmcgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbik7XG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgaWYgKGFyZyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgdHJhbnNhY3Rpb24gPSBhcmcudG9PYmplY3QoKTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2FjdGlvbiA9IGFyZztcbiAgfVxuICBmb3IgKGNvbnN0IGlucHV0IG9mIHRyYW5zYWN0aW9uLmlucHV0cyB8fCBbXSkge1xuICAgIGlmICghaW5wdXQub3V0cHV0IHx8ICFpbnB1dC5vdXRwdXQuc2NyaXB0KSB7XG4gICAgICB0aGlzLnVuY2hlY2tlZEFkZElucHV0KG5ldyBJbnB1dChpbnB1dCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBzY3JpcHQgPSBuZXcgU2NyaXB0KGlucHV0Lm91dHB1dC5zY3JpcHQpO1xuICAgIHZhciB0eGluO1xuICAgIGlmICgoc2NyaXB0LmlzU2NyaXB0SGFzaE91dCgpIHx8IHNjcmlwdC5pc1dpdG5lc3NTY3JpcHRIYXNoT3V0KCkpICYmIGlucHV0LnB1YmxpY0tleXMgJiYgaW5wdXQudGhyZXNob2xkKSB7XG4gICAgICB0eGluID0gbmV3IElucHV0Lk11bHRpU2lnU2NyaXB0SGFzaChcbiAgICAgICAgaW5wdXQsIGlucHV0LnB1YmxpY0tleXMsIGlucHV0LnRocmVzaG9sZCwgaW5wdXQuc2lnbmF0dXJlcywgb3B0c1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHNjcmlwdC5pc1B1YmxpY0tleUhhc2hPdXQoKSB8fCBzY3JpcHQuaXNXaXRuZXNzUHVibGljS2V5SGFzaE91dCgpIHx8IHNjcmlwdC5pc1NjcmlwdEhhc2hPdXQoKSkge1xuICAgICAgdHhpbiA9IG5ldyBJbnB1dC5QdWJsaWNLZXlIYXNoKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHNjcmlwdC5pc1B1YmxpY0tleU91dCgpKSB7XG4gICAgICB0eGluID0gbmV3IElucHV0LlB1YmxpY0tleShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW5wdXQuVW5zdXBwb3J0ZWRTY3JpcHQoaW5wdXQub3V0cHV0LnNjcmlwdCk7XG4gICAgfVxuICAgIHRoaXMuYWRkSW5wdXQodHhpbik7XG4gIH1cbiAgZm9yIChjb25zdCBvdXRwdXQgb2YgdHJhbnNhY3Rpb24ub3V0cHV0cyB8fCBbXSkge1xuICAgIHRoaXMuYWRkT3V0cHV0KG5ldyBPdXRwdXQob3V0cHV0KSk7XG4gIH1cbiAgaWYgKHRyYW5zYWN0aW9uLmNoYW5nZUluZGV4KSB7XG4gICAgdGhpcy5fY2hhbmdlSW5kZXggPSB0cmFuc2FjdGlvbi5jaGFuZ2VJbmRleDtcbiAgfVxuICBpZiAodHJhbnNhY3Rpb24uY2hhbmdlU2NyaXB0KSB7XG4gICAgdGhpcy5fY2hhbmdlU2NyaXB0ID0gbmV3IFNjcmlwdCh0cmFuc2FjdGlvbi5jaGFuZ2VTY3JpcHQpO1xuICB9XG4gIGlmICh0cmFuc2FjdGlvbi5mZWUpIHtcbiAgICB0aGlzLl9mZWUgPSB0cmFuc2FjdGlvbi5mZWU7XG4gIH1cbiAgdGhpcy5uTG9ja1RpbWUgPSB0cmFuc2FjdGlvbi5uTG9ja1RpbWU7XG4gIHRoaXMudmVyc2lvbiA9IHRyYW5zYWN0aW9uLnZlcnNpb247XG4gIHRoaXMuX2NoZWNrQ29uc2lzdGVuY3koYXJnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2NoZWNrQ29uc2lzdGVuY3kgPSBmdW5jdGlvbihhcmcpIHtcbiAgaWYgKHRoaXMuX2NoYW5nZUluZGV4ICE9IG51bGwpIHtcbiAgICAkLmNoZWNrU3RhdGUodGhpcy5fY2hhbmdlU2NyaXB0LCAnQ2hhbmdlIHNjcmlwdCBpcyBleHBlY3RlZC4nKTtcbiAgICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXRzW3RoaXMuX2NoYW5nZUluZGV4XSwgJ0NoYW5nZSBpbmRleCBwb2ludHMgdG8gdW5kZWZpbmVkIG91dHB1dC4nKTtcbiAgICAkLmNoZWNrU3RhdGUodGhpcy5vdXRwdXRzW3RoaXMuX2NoYW5nZUluZGV4XS5zY3JpcHQudG9TdHJpbmcoKSA9PT1cbiAgICAgIHRoaXMuX2NoYW5nZVNjcmlwdC50b1N0cmluZygpLCAnQ2hhbmdlIG91dHB1dCBoYXMgYW4gdW5leHBlY3RlZCBzY3JpcHQuJyk7XG4gIH1cbiAgaWYgKGFyZyAmJiBhcmcuaGFzaCkge1xuICAgICQuY2hlY2tTdGF0ZShhcmcuaGFzaCA9PT0gdGhpcy5oYXNoLCAnSGFzaCBpbiBvYmplY3QgZG9lcyBub3QgbWF0Y2ggdHJhbnNhY3Rpb24gaGFzaC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIG5Mb2NrVGltZSBzbyB0aGF0IHRyYW5zYWN0aW9uIGlzIG5vdCB2YWxpZCB1bnRpbCB0aGUgZGVzaXJlZCBkYXRlKGFcbiAqIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIFVOSVggZXBvY2ggaXMgYWxzbyBhY2NlcHRlZClcbiAqXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXJ9IHRpbWVcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5sb2NrVW50aWxEYXRlID0gZnVuY3Rpb24odGltZSkge1xuICAkLmNoZWNrQXJndW1lbnQodGltZSk7XG4gIGlmICghaXNOYU4odGltZSkgJiYgdGltZSA8IFRyYW5zYWN0aW9uLk5MT0NLVElNRV9CTE9DS0hFSUdIVF9MSU1JVCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uTG9ja1RpbWVUb29FYXJseSgpO1xuICB9XG4gIGlmIChfLmlzRGF0ZSh0aW1lKSkge1xuICAgIHRpbWUgPSB0aW1lLmdldFRpbWUoKSAvIDEwMDA7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuaW5wdXRzW2ldLnNlcXVlbmNlTnVtYmVyID09PSBJbnB1dC5ERUZBVUxUX1NFUU5VTUJFUil7XG4gICAgICB0aGlzLmlucHV0c1tpXS5zZXF1ZW5jZU51bWJlciA9IElucHV0LkRFRkFVTFRfTE9DS1RJTUVfU0VRTlVNQkVSO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubkxvY2tUaW1lID0gdGltZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgbkxvY2tUaW1lIHNvIHRoYXQgdHJhbnNhY3Rpb24gaXMgbm90IHZhbGlkIHVudGlsIHRoZSBkZXNpcmVkIGJsb2NrXG4gKiBoZWlnaHQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmxvY2tVbnRpbEJsb2NrSGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICQuY2hlY2tBcmd1bWVudCghaXNOYU4oaGVpZ2h0KSk7XG4gIGlmIChoZWlnaHQgPj0gVHJhbnNhY3Rpb24uTkxPQ0tUSU1FX0JMT0NLSEVJR0hUX0xJTUlUKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5CbG9ja0hlaWdodFRvb0hpZ2goKTtcbiAgfVxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uTkxvY2tUaW1lT3V0T2ZSYW5nZSgpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmlucHV0c1tpXS5zZXF1ZW5jZU51bWJlciA9PT0gSW5wdXQuREVGQVVMVF9TRVFOVU1CRVIpe1xuICAgICAgdGhpcy5pbnB1dHNbaV0uc2VxdWVuY2VOdW1iZXIgPSBJbnB1dC5ERUZBVUxUX0xPQ0tUSU1FX1NFUU5VTUJFUjtcbiAgICB9XG4gIH1cblxuXG4gIHRoaXMubkxvY2tUaW1lID0gaGVpZ2h0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogIFJldHVybnMgYSBzZW1hbnRpYyB2ZXJzaW9uIG9mIHRoZSB0cmFuc2FjdGlvbidzIG5Mb2NrVGltZS5cbiAqICBAcmV0dXJuIHtOdW1iZXJ8RGF0ZX1cbiAqICBJZiBuTG9ja1RpbWUgaXMgMCwgaXQgcmV0dXJucyBudWxsLFxuICogIGlmIGl0IGlzIDwgNTAwMDAwMDAwLCBpdCByZXR1cm5zIGEgYmxvY2sgaGVpZ2h0IChudW1iZXIpXG4gKiAgZWxzZSBpdCByZXR1cm5zIGEgRGF0ZSBvYmplY3QuXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXRMb2NrVGltZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMubkxvY2tUaW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHRoaXMubkxvY2tUaW1lIDwgVHJhbnNhY3Rpb24uTkxPQ0tUSU1FX0JMT0NLSEVJR0hUX0xJTUlUKSB7XG4gICAgcmV0dXJuIHRoaXMubkxvY2tUaW1lO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZSgxMDAwICogdGhpcy5uTG9ja1RpbWUpO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlci5CdWZmZXIuZnJvbShzdHJpbmcsICdoZXgnKSk7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX25ld1RyYW5zYWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudmVyc2lvbiA9IENVUlJFTlRfVkVSU0lPTjtcbiAgdGhpcy5uTG9ja1RpbWUgPSBERUZBVUxUX05MT0NLVElNRTtcbn07XG5cbi8qIFRyYW5zYWN0aW9uIGNyZWF0aW9uIGludGVyZmFjZSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYW5zYWN0aW9ufmZyb21PYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcmV2VHhJZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG91dHB1dEluZGV4XG4gKiBAcHJvcGVydHkgeyhCdWZmZXJ8c3RyaW5nfFNjcmlwdCl9IHNjcmlwdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNhdG9zaGlzXG4gKi9cblxuLyoqXG4gKiBBZGQgYW4gaW5wdXQgdG8gdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBhIGhpZ2ggbGV2ZWwgaW50ZXJmYWNlXG4gKiB0byBhZGQgYW4gaW5wdXQsIGZvciBtb3JlIGNvbnRyb2wsIHVzZSBAe2xpbmsgVHJhbnNhY3Rpb24jYWRkSW5wdXR9LlxuICpcbiAqIENhbiByZWNlaXZlLCBhcyBvdXRwdXQgaW5mb3JtYXRpb24sIHRoZSBvdXRwdXQgb2YgYml0Y29pbmQncyBgbGlzdHVuc3BlbnRgIGNvbW1hbmQsXG4gKiBhbmQgYSBzbGlnaHRseSBmYW5jaWVyIGZvcm1hdCByZWNvZ25pemVkIGJ5IGJpdGNvcmU6XG4gKlxuICogYGBgXG4gKiB7XG4gKiAgYWRkcmVzczogJ21zellxVm5xS29ReDRqY1RkSlh4d0tBaXNzRTNKYnJyYzEnLFxuICogIHR4SWQ6ICdhNDc3YWY2YjI2NjdjMjk2NzA0NjdlNGUwNzI4YjY4NWVlMDdiMjQwMjM1NzcxODYyMzE4ZTI5ZGRiZTU4NDU4JyxcbiAqICBvdXRwdXRJbmRleDogMCxcbiAqICBzY3JpcHQ6IFNjcmlwdC5lbXB0eSgpLFxuICogIHNhdG9zaGlzOiAxMDIwMDAwXG4gKiB9XG4gKiBgYGBcbiAqIFdoZXJlIGBhZGRyZXNzYCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgYml0Y29yZSBBZGRyZXNzIG9iamVjdC4gVGhlXG4gKiBzYW1lIGlzIHRydWUgZm9yIGBzY3JpcHRgLCB3aGljaCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBiaXRjb3JlIFNjcmlwdC5cbiAqXG4gKiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXMgZm9yIGlucHV0cyAoaW4gZnVydGhlciB2ZXJzaW9ucyxcbiAqIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90IGJlIHJlc2V0KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gKlxuICogLy8gRnJvbSBhIHBheSB0byBwdWJsaWMga2V5IGhhc2ggb3V0cHV0IGZyb20gYml0Y29pbmQncyBsaXN0dW5zcGVudFxuICogdHJhbnNhY3Rpb24uZnJvbSh7J3R4aWQnOiAnMDAwMC4uLicsIHZvdXQ6IDAsIGFtb3VudDogMC4xLCBzY3JpcHRQdWJLZXk6ICdPUF9EVVAgLi4uJ30pO1xuICpcbiAqIC8vIEZyb20gYSBwYXkgdG8gcHVibGljIGtleSBoYXNoIG91dHB1dFxuICogdHJhbnNhY3Rpb24uZnJvbSh7J3R4SWQnOiAnMDAwMC4uLicsIG91dHB1dEluZGV4OiAwLCBzYXRvc2hpczogMTAwMCwgc2NyaXB0OiAnT1BfRFVQIC4uLid9KTtcbiAqXG4gKiAvLyBGcm9tIGEgbXVsdGlzaWcgUDJTSCBvdXRwdXRcbiAqIHRyYW5zYWN0aW9uLmZyb20oeyd0eElkJzogJzAwMDAuLi4nLCBpbnB1dEluZGV4OiAwLCBzYXRvc2hpczogMTAwMCwgc2NyaXB0OiAnLi4uIE9QX0hBU0gnfSxcbiAqICAgICAgICAgICAgICAgICAgWycwMzAwMC4uLicsICcwMjAwMC4uLiddLCAyKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7KEFycmF5LjxUcmFuc2FjdGlvbn5mcm9tT2JqZWN0PnxUcmFuc2FjdGlvbn5mcm9tT2JqZWN0KX0gdXR4b1xuICogQHBhcmFtIHtBcnJheT19IFtwdWJrZXlzXVxuICogQHBhcmFtIHtudW1iZXI9fSBbdGhyZXNob2xkXVxuICogQHBhcmFtIHtPYmplY3Q9fSBbb3B0c10gLSBTZXZlcmFsIG9wdGlvbnM6XG4gKiAgICAgICAgLSBub1NvcnRpbmc6IGRlZmF1bHRzIHRvIGZhbHNlLCBpZiB0cnVlIGFuZCBpcyBtdWx0aXNpZywgZG9uJ3RcbiAqICAgICAgICAgICAgICAgICAgICAgIHNvcnQgdGhlIGdpdmVuIHB1YmxpYyBrZXlzIGJlZm9yZSBjcmVhdGluZyB0aGUgc2NyaXB0XG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mcm9tID0gZnVuY3Rpb24odXR4bywgcHVia2V5cywgdGhyZXNob2xkLCBvcHRzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHV0eG8pKSB7XG4gICAgZm9yKGNvbnN0IHUgb2YgdXR4bykge1xuICAgICAgdGhpcy5mcm9tKHUsIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb25zdCBleGlzdHMgPSB0aGlzLmlucHV0cy5zb21lKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgLy8gVE9ETzogTWF5YmUgcHJldlR4SWQgc2hvdWxkIGJlIGEgc3RyaW5nPyBPciBkZWZpbmVkIGFzIHJlYWQgb25seSBwcm9wZXJ0eT9cbiAgICByZXR1cm4gaW5wdXQucHJldlR4SWQudG9TdHJpbmcoJ2hleCcpID09PSB1dHhvLnR4SWQgJiYgaW5wdXQub3V0cHV0SW5kZXggPT09IHV0eG8ub3V0cHV0SW5kZXg7XG4gIH0pO1xuICBpZiAoZXhpc3RzKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHB1YmtleXMgJiYgdGhyZXNob2xkKSB7XG4gICAgdGhpcy5fZnJvbU11bHRpc2lnVXR4byh1dHhvLCBwdWJrZXlzLCB0aHJlc2hvbGQsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2Zyb21Ob25QMlNIKHV0eG8sIG9wdHMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBhc3NvY2lhdGVJbnB1dHMgLSBVcGRhdGUgaW5wdXRzIHdpdGggdXR4b3MsIGFsbG93aW5nIHlvdSB0byBzcGVjaWZ5IHZhbHVlLCBhbmQgcHVia2V5LlxuICogUG9wdWxhdGluZyB0aGVzZSBpbnB1dHMgYWxsb3dzIGZvciB0aGVtIHRvIGJlIHNpZ25lZCB3aXRoIC5zaWduKHByaXZLZXlzKVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gdXR4b3NcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nIHwgUHVibGljS2V5Pn0gcHVia2V5c1xuICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fVxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuYXNzb2NpYXRlSW5wdXRzID0gZnVuY3Rpb24odXR4b3MsIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyA9IHt9KSB7XG4gIGxldCBpbmRleGVzID0gW107XG4gIGZvcihsZXQgdXR4byBvZiB1dHhvcykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbnB1dHMuZmluZEluZGV4KGkgPT4gaS5wcmV2VHhJZC50b1N0cmluZygnaGV4JykgPT09IHV0eG8udHhJZCAmJiBpLm91dHB1dEluZGV4ID09PSB1dHhvLm91dHB1dEluZGV4KTtcbiAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIGlmKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gdGhpcy5pbnB1dHNbaW5kZXhdLnNlcXVlbmNlTnVtYmVyOyAvLyBwcmVzZXJ2ZSB0aGUgc2V0IHNlcXVlbmNlIG51bWJlclxuICAgICAgdGhpcy5pbnB1dHNbaW5kZXhdID0gdGhpcy5fZ2V0SW5wdXRGcm9tKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyk7XG4gICAgICB0aGlzLmlucHV0c1tpbmRleF0uc2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4ZXM7XG59XG5cblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9zZWxlY3RJbnB1dFR5cGUgPSBmdW5jdGlvbih1dHhvLCBwdWJrZXlzLCB0aHJlc2hvbGQpIHtcbiAgdmFyIGNsYXp6O1xuICB1dHhvID0gbmV3IFVuc3BlbnRPdXRwdXQodXR4byk7XG4gIGlmKHB1YmtleXMgJiYgdGhyZXNob2xkKSB7XG4gICAgaWYgKHV0eG8uc2NyaXB0LmlzTXVsdGlzaWdPdXQoKSkge1xuICAgICAgY2xhenogPSBNdWx0aVNpZ0lucHV0O1xuICAgIH0gZWxzZSBpZiAodXR4by5zY3JpcHQuaXNTY3JpcHRIYXNoT3V0KCkgfHwgdXR4by5zY3JpcHQuaXNXaXRuZXNzU2NyaXB0SGFzaE91dCgpKSB7XG4gICAgICBjbGF6eiA9IE11bHRpU2lnU2NyaXB0SGFzaElucHV0O1xuICAgIH1cbiAgfSBlbHNlIGlmICh1dHhvLnNjcmlwdC5pc1B1YmxpY0tleUhhc2hPdXQoKSB8fCB1dHhvLnNjcmlwdC5pc1dpdG5lc3NQdWJsaWNLZXlIYXNoT3V0KCkgfHwgdXR4by5zY3JpcHQuaXNTY3JpcHRIYXNoT3V0KCkpIHtcbiAgICBjbGF6eiA9IFB1YmxpY0tleUhhc2hJbnB1dDtcbiAgfSBlbHNlIGlmICh1dHhvLnNjcmlwdC5pc1RhcHJvb3QoKSkge1xuICAgIGNsYXp6ID0gVGFwcm9vdElucHV0O1xuICB9IGVsc2UgaWYgKHV0eG8uc2NyaXB0LmlzUHVibGljS2V5T3V0KCkpIHtcbiAgICBjbGF6eiA9IFB1YmxpY0tleUlucHV0O1xuICB9IGVsc2Uge1xuICAgIGNsYXp6ID0gSW5wdXQ7XG4gIH1cbiAgcmV0dXJuIGNsYXp6O1xufVxuXG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZ2V0SW5wdXRGcm9tID0gZnVuY3Rpb24odXR4bywgcHVia2V5cywgdGhyZXNob2xkLCBvcHRzID0ge30pIHtcbiAgdXR4byA9IG5ldyBVbnNwZW50T3V0cHV0KHV0eG8pO1xuICBjb25zdCBJbnB1dENsYXNzID0gdGhpcy5fc2VsZWN0SW5wdXRUeXBlKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCk7XG4gIGNvbnN0IGlucHV0ID0ge1xuICAgIG91dHB1dDogbmV3IE91dHB1dCh7XG4gICAgICBzY3JpcHQ6IHV0eG8uc2NyaXB0LFxuICAgICAgc2F0b3NoaXM6IHV0eG8uc2F0b3NoaXNcbiAgICB9KSxcbiAgICBwcmV2VHhJZDogdXR4by50eElkLFxuICAgIG91dHB1dEluZGV4OiB1dHhvLm91dHB1dEluZGV4LFxuICAgIHNlcXVlbmNlTnVtYmVyOiBvcHRzLnNlcXVlbmNlTnVtYmVyLFxuICAgIHNjcmlwdDogU2NyaXB0LmVtcHR5KClcbiAgfTtcbiAgbGV0IGFyZ3MgPSBwdWJrZXlzICYmIHRocmVzaG9sZCA/IFtwdWJrZXlzLCB0aHJlc2hvbGQsIGZhbHNlLCBvcHRzXSA6IFtdXG4gIHJldHVybiBuZXcgSW5wdXRDbGFzcyhpbnB1dCwgLi4uYXJncyk7XG59XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZnJvbU5vblAyU0ggPSBmdW5jdGlvbih1dHhvLCBvcHRzKSB7XG4gIGNvbnN0IGlucHV0ID0gdGhpcy5fZ2V0SW5wdXRGcm9tKHV0eG8sIG51bGwsIG51bGwsIG9wdHMpO1xuICB0aGlzLmFkZElucHV0KGlucHV0KTtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZnJvbU11bHRpc2lnVXR4byA9IGZ1bmN0aW9uKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cykge1xuICAkLmNoZWNrQXJndW1lbnQodGhyZXNob2xkIDw9IHB1YmtleXMubGVuZ3RoLFxuICAgICdOdW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHB1YmxpYyBrZXlzJyk7XG4gIGNvbnN0IGlucHV0ID0gdGhpcy5fZ2V0SW5wdXRGcm9tKHV0eG8sIHB1YmtleXMsIHRocmVzaG9sZCwgb3B0cyk7XG4gIHRoaXMuYWRkSW5wdXQoaW5wdXQpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gaW5wdXQgdG8gdGhpcyB0cmFuc2FjdGlvbi4gVGhlIGlucHV0IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgdGhlIGBJbnB1dGAgY2xhc3MuXG4gKiBJdCBzaG91bGQgaGF2ZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgT3V0cHV0IHRoYXQgaXQncyBzcGVuZGluZywgYnV0IGlmIGl0J3Mgbm90IGFscmVhZHlcbiAqIHNldCwgdHdvIGFkZGl0aW9uYWwgcGFyYW1ldGVycywgYG91dHB1dFNjcmlwdGAgYW5kIGBzYXRvc2hpc2AgY2FuIGJlIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSB7SW5wdXR9IGlucHV0XG4gKiBAcGFyYW0ge1N0cmluZ3xTY3JpcHR9IG91dHB1dFNjcmlwdFxuICogQHBhcmFtIHtudW1iZXJ9IHNhdG9zaGlzXG4gKiBAcmV0dXJuIFRyYW5zYWN0aW9uIHRoaXMsIGZvciBjaGFpbmluZ1xuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuYWRkSW5wdXQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0U2NyaXB0LCBzYXRvc2hpcykge1xuICAkLmNoZWNrQXJndW1lbnRUeXBlKGlucHV0LCBJbnB1dCwgJ2lucHV0Jyk7XG4gIGlmICghaW5wdXQub3V0cHV0ICYmIChvdXRwdXRTY3JpcHQgPT0gbnVsbCB8fCBzYXRvc2hpcyA9PSBudWxsKSkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uTmVlZE1vcmVJbmZvKCdOZWVkIGluZm9ybWF0aW9uIGFib3V0IHRoZSBVVFhPIHNjcmlwdCBhbmQgc2F0b3NoaXMnKTtcbiAgfVxuICBpZiAoIWlucHV0Lm91dHB1dCAmJiBvdXRwdXRTY3JpcHQgJiYgc2F0b3NoaXMgIT0gbnVsbCkge1xuICAgIG91dHB1dFNjcmlwdCA9IG91dHB1dFNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdCA/IG91dHB1dFNjcmlwdCA6IG5ldyBTY3JpcHQob3V0cHV0U2NyaXB0KTtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKHNhdG9zaGlzLCAnbnVtYmVyJywgJ3NhdG9zaGlzJyk7XG4gICAgaW5wdXQub3V0cHV0ID0gbmV3IE91dHB1dCh7XG4gICAgICBzY3JpcHQ6IG91dHB1dFNjcmlwdCxcbiAgICAgIHNhdG9zaGlzOiBzYXRvc2hpc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLnVuY2hlY2tlZEFkZElucHV0KGlucHV0KTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGlucHV0IHRvIHRoaXMgdHJhbnNhY3Rpb24sIHdpdGhvdXQgY2hlY2tpbmcgdGhhdCB0aGUgaW5wdXQgaGFzIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgb3V0cHV0IHRoYXQgaXQncyBzcGVuZGluZy5cbiAqXG4gKiBAcGFyYW0ge0lucHV0fSBpbnB1dFxuICogQHJldHVybiBUcmFuc2FjdGlvbiB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnVuY2hlY2tlZEFkZElucHV0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgJC5jaGVja0FyZ3VtZW50VHlwZShpbnB1dCwgSW5wdXQsICdpbnB1dCcpO1xuICB0aGlzLmlucHV0cy5wdXNoKGlucHV0KTtcbiAgdGhpcy5faW5wdXRBbW91bnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3VwZGF0ZUNoYW5nZU91dHB1dCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgZW5vdWdoIGluZm8gb24gYWxsIGlucHV0cyB0byBiZSBjb3JyZWN0bHkgdmFsaWRhdGVkXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmhhc0FsbFV0eG9JbmZvID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlucHV0cy5ldmVyeShmdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiAhIWlucHV0Lm91dHB1dDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIE1hbnVhbGx5IHNldCB0aGUgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXNcbiAqIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90XG4gKiBiZSByZXNldCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBzYXRvc2hpcyB0byBiZSBzZW50XG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mZWUgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgJC5jaGVja0FyZ3VtZW50KCFpc05hTihhbW91bnQpLCAnYW1vdW50IG11c3QgYmUgYSBudW1iZXInKTtcbiAgdGhpcy5fZmVlID0gYW1vdW50O1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1hbnVhbGx5IHNldCB0aGUgZmVlIHBlciBLQiBmb3IgdGhpcyB0cmFuc2FjdGlvbi4gQmV3YXJlIHRoYXQgdGhpcyByZXNldHMgYWxsIHRoZSBzaWduYXR1cmVzXG4gKiBmb3IgaW5wdXRzIChpbiBmdXJ0aGVyIHZlcnNpb25zLCBTSUdIQVNIX1NJTkdMRSBvciBTSUdIQVNIX05PTkUgc2lnbmF0dXJlcyB3aWxsIG5vdFxuICogYmUgcmVzZXQpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgc2F0b3NoaXMgcGVyIEtCIHRvIGJlIHNlbnRcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZlZVBlcktiID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICQuY2hlY2tBcmd1bWVudCghaXNOYU4oYW1vdW50KSwgJ2Ftb3VudCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIHRoaXMuX2ZlZVBlcktiID0gYW1vdW50O1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1hbnVhbGx5IHNldCB0aGUgZmVlIHBlciBCeXRlIGZvciB0aGlzIHRyYW5zYWN0aW9uLiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXNcbiAqIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90XG4gKiBiZSByZXNldCkuXG4gKiBmZWUgcGVyIEJ5dGUgd2lsbCBiZSBpZ25vcmVkIGlmIGZlZSBwZXIgS0IgaXMgc2V0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBzYXRvc2hpcyBwZXIgQnl0ZSB0byBiZSBzZW50XG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mZWVQZXJCeXRlID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAkLmNoZWNrQXJndW1lbnQoIWlzTmFOKGFtb3VudCksICdhbW91bnQgbXVzdCBiZSBhIG51bWJlcicpO1xuICB0aGlzLl9mZWVQZXJCeXRlID0gYW1vdW50O1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiBPdXRwdXQgbWFuYWdlbWVudCAqL1xuXG4vKipcbiAqIFNldCB0aGUgY2hhbmdlIGFkZHJlc3MgZm9yIHRoaXMgdHJhbnNhY3Rpb25cbiAqXG4gKiBCZXdhcmUgdGhhdCB0aGlzIHJlc2V0cyBhbGwgdGhlIHNpZ25hdHVyZXMgZm9yIGlucHV0cyAoaW4gZnVydGhlciB2ZXJzaW9ucyxcbiAqIFNJR0hBU0hfU0lOR0xFIG9yIFNJR0hBU0hfTk9ORSBzaWduYXR1cmVzIHdpbGwgbm90IGJlIHJlc2V0KS5cbiAqXG4gKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHJlc3MgQW4gYWRkcmVzcyBmb3IgY2hhbmdlIHRvIGJlIHNlbnQgdG8uXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpcywgZm9yIGNoYWluaW5nXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbihhZGRyZXNzKSB7XG4gICQuY2hlY2tBcmd1bWVudChhZGRyZXNzLCAnYWRkcmVzcyBpcyByZXF1aXJlZCcpO1xuICB0aGlzLl9jaGFuZ2VTY3JpcHQgPSBTY3JpcHQuZnJvbUFkZHJlc3MoYWRkcmVzcyk7XG4gIHRoaXMuX3VwZGF0ZUNoYW5nZU91dHB1dCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtPdXRwdXR9IGNoYW5nZSBvdXRwdXQsIGlmIGl0IGV4aXN0c1xuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0Q2hhbmdlT3V0cHV0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9jaGFuZ2VJbmRleCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0c1t0aGlzLl9jaGFuZ2VJbmRleF07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYW5zYWN0aW9ufnRvT2JqZWN0XG4gKiBAcHJvcGVydHkgeyhzdHJpbmd8QWRkcmVzcyl9IGFkZHJlc3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzYXRvc2hpc1xuICovXG5cbi8qKlxuICogQWRkIGFuIG91dHB1dCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogQmV3YXJlIHRoYXQgdGhpcyByZXNldHMgYWxsIHRoZSBzaWduYXR1cmVzIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsXG4gKiBTSUdIQVNIX1NJTkdMRSBvciBTSUdIQVNIX05PTkUgc2lnbmF0dXJlcyB3aWxsIG5vdCBiZSByZXNldCkuXG4gKlxuICogQHBhcmFtIHsoc3RyaW5nfEFkZHJlc3N8QXJyYXkuPFRyYW5zYWN0aW9ufnRvT2JqZWN0Pil9IGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgaW4gc2F0b3NoaXNcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24oYWRkcmVzcywgYW1vdW50KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFkZHJlc3MpKSB7XG4gICAgZm9yIChjb25zdCB0byBvZiBhZGRyZXNzKSB7XG4gICAgICB0aGlzLnRvKHRvLmFkZHJlc3MsIHRvLnNhdG9zaGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAkLmNoZWNrQXJndW1lbnQoXG4gICAgSlNVdGlsLmlzTmF0dXJhbE51bWJlcihhbW91bnQpLFxuICAgICdBbW91bnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICApO1xuICB0aGlzLmFkZE91dHB1dChuZXcgT3V0cHV0KHtcbiAgICBzY3JpcHQ6IFNjcmlwdChuZXcgQWRkcmVzcyhhZGRyZXNzKSksXG4gICAgc2F0b3NoaXM6IGFtb3VudFxuICB9KSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gT1BfUkVUVVJOIG91dHB1dCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogQmV3YXJlIHRoYXQgdGhpcyByZXNldHMgYWxsIHRoZSBzaWduYXR1cmVzIGZvciBpbnB1dHMgKGluIGZ1cnRoZXIgdmVyc2lvbnMsXG4gKiBTSUdIQVNIX1NJTkdMRSBvciBTSUdIQVNIX05PTkUgc2lnbmF0dXJlcyB3aWxsIG5vdCBiZSByZXNldCkuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSB2YWx1ZSB0aGUgZGF0YSB0byBiZSBzdG9yZWQgaW4gdGhlIE9QX1JFVFVSTiBvdXRwdXQuXG4gKiAgICBJbiBjYXNlIG9mIGEgc3RyaW5nLCB0aGUgVVRGLTggcmVwcmVzZW50YXRpb24gd2lsbCBiZSBzdG9yZWRcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFkZERhdGEgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLmFkZE91dHB1dChuZXcgT3V0cHV0KHtcbiAgICBzY3JpcHQ6IFNjcmlwdC5idWlsZERhdGFPdXQodmFsdWUpLFxuICAgIHNhdG9zaGlzOiAwXG4gIH0pKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQWRkIGFuIG91dHB1dCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPdXRwdXR9IG91dHB1dCB0aGUgb3V0cHV0IHRvIGFkZC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFkZE91dHB1dCA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAkLmNoZWNrQXJndW1lbnRUeXBlKG91dHB1dCwgT3V0cHV0LCAnb3V0cHV0Jyk7XG4gIHRoaXMuX2FkZE91dHB1dChvdXRwdXQpO1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFsbCBvdXRwdXRzIGZyb20gdGhlIHRyYW5zYWN0aW9uLlxuICpcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmNsZWFyT3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgdGhpcy5fY2xlYXJTaWduYXR1cmVzKCk7XG4gIHRoaXMuX291dHB1dEFtb3VudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fY2hhbmdlSW5kZXggPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3VwZGF0ZUNoYW5nZU91dHB1dCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9hZGRPdXRwdXQgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgdGhpcy5vdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgdGhpcy5fb3V0cHV0QW1vdW50ID0gdW5kZWZpbmVkO1xufTtcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgb3IgZ2V0cyB0aGUgdG90YWwgb3V0cHV0IGFtb3VudCBpbiBzYXRvc2hpc1xuICpcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIHRyYW5zYWN0aW9uIHRvdGFsIG91dHB1dCBhbW91bnRcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9nZXRPdXRwdXRBbW91bnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX291dHB1dEFtb3VudCA9PSBudWxsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX291dHB1dEFtb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBvdXRwdXQgb2YgdGhpcy5vdXRwdXRzIHx8IFtdKSB7XG4gICAgICBzZWxmLl9vdXRwdXRBbW91bnQgKz0gb3V0cHV0LnNhdG9zaGlzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5fb3V0cHV0QW1vdW50O1xufTtcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgb3IgZ2V0cyB0aGUgdG90YWwgaW5wdXQgYW1vdW50IGluIHNhdG9zaGlzXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgdHJhbnNhY3Rpb24gdG90YWwgaW5wdXQgYW1vdW50XG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZ2V0SW5wdXRBbW91bnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2lucHV0QW1vdW50ID09IG51bGwpIHtcbiAgICB0aGlzLl9pbnB1dEFtb3VudCA9IF8uc3VtQnkodGhpcy5pbnB1dHMsIGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQub3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5JbnB1dC5NaXNzaW5nUHJldmlvdXNPdXRwdXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dC5vdXRwdXQuc2F0b3NoaXM7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2lucHV0QW1vdW50O1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl91cGRhdGVDaGFuZ2VPdXRwdXQgPSBmdW5jdGlvbihub0NsZWFyU2lncykge1xuICBpZiAoIXRoaXMuX2NoYW5nZVNjcmlwdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIW5vQ2xlYXJTaWdzKSB7XG4gICAgdGhpcy5fY2xlYXJTaWduYXR1cmVzKCk7XG4gIH1cbiAgaWYgKHRoaXMuX2NoYW5nZUluZGV4ICE9IG51bGwpIHtcbiAgICB0aGlzLl9yZW1vdmVPdXRwdXQodGhpcy5fY2hhbmdlSW5kZXgpO1xuICB9XG4gIHZhciBhdmFpbGFibGUgPSB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcbiAgdmFyIGZlZSA9IHRoaXMuZ2V0RmVlKCk7XG4gIHZhciBjaGFuZ2VBbW91bnQgPSBhdmFpbGFibGUgLSBmZWU7XG4gIGlmIChjaGFuZ2VBbW91bnQgPiBUcmFuc2FjdGlvbi5EVVNUX0FNT1VOVCkge1xuICAgIHRoaXMuX2NoYW5nZUluZGV4ID0gdGhpcy5vdXRwdXRzLmxlbmd0aDtcbiAgICB0aGlzLl9hZGRPdXRwdXQobmV3IE91dHB1dCh7XG4gICAgICBzY3JpcHQ6IHRoaXMuX2NoYW5nZVNjcmlwdCxcbiAgICAgIHNhdG9zaGlzOiBjaGFuZ2VBbW91bnRcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY2hhbmdlSW5kZXggPSB1bmRlZmluZWQ7XG4gIH1cbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGZlZSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogSWYgdGhlcmUncyBhIGZpeGVkIGZlZSBzZXQsIHJldHVybiB0aGF0LlxuICpcbiAqIElmIHRoZXJlIGlzIG5vIGNoYW5nZSBvdXRwdXQgc2V0LCB0aGUgZmVlIGlzIHRoZVxuICogdG90YWwgdmFsdWUgb2YgdGhlIG91dHB1dHMgbWludXMgaW5wdXRzLiBOb3RlIHRoYXRcbiAqIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvbmx5IHNwZWNpZmllcyB0aGUgdmFsdWVcbiAqIG9mIGl0cyBvdXRwdXRzLiAoVGhlIHZhbHVlIG9mIGlucHV0cyBhcmUgcmVjb3JkZWRcbiAqIGluIHRoZSBwcmV2aW91cyB0cmFuc2FjdGlvbiBvdXRwdXRzIGJlaW5nIHNwZW50LilcbiAqIFRoaXMgbWV0aG9kIHRoZXJlZm9yZSByYWlzZXMgYSBcIk1pc3NpbmdQcmV2aW91c091dHB1dFwiXG4gKiBlcnJvciB3aGVuIGNhbGxlZCBvbiBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKlxuICogSWYgdGhlcmUncyBubyBmZWUgc2V0IGFuZCBubyBjaGFuZ2UgYWRkcmVzcyxcbiAqIGVzdGltYXRlIHRoZSBmZWUgYmFzZWQgb24gc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGZlZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGluIHNhdG9zaGlzXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXRGZWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNDb2luYmFzZSgpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRoaXMuX2ZlZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZlZTtcbiAgfVxuICAvLyBpZiBubyBjaGFuZ2Ugb3V0cHV0IGlzIHNldCwgZmVlcyBzaG91bGQgZXF1YWwgYWxsIHRoZSB1bnNwZW50IGFtb3VudFxuICBpZiAoIXRoaXMuX2NoYW5nZVNjcmlwdCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXN0aW1hdGVGZWUoKTtcbn07XG5cbi8qKlxuICogRXN0aW1hdGVzIGZlZSBmcm9tIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gc2l6ZSBpbiBieXRlcy5cbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9lc3RpbWF0ZUZlZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IHRoaXMuX2VzdGltYXRlU2l6ZSgpO1xuICBjb25zdCBhdmFpbGFibGUgPSB0aGlzLl9nZXRVbnNwZW50VmFsdWUoKTtcbiAgY29uc3QgZmVlUmF0ZSA9IHRoaXMuX2ZlZVBlckJ5dGUgfHwgKHRoaXMuX2ZlZVBlcktiIHx8IFRyYW5zYWN0aW9uLkZFRV9QRVJfS0IpIC8gMTAwMDtcbiAgZnVuY3Rpb24gZ2V0RmVlKHNpemUpIHtcbiAgICByZXR1cm4gc2l6ZSAqIGZlZVJhdGU7XG4gIH1cbiAgY29uc3QgZmVlID0gTWF0aC5jZWlsKGdldEZlZShlc3RpbWF0ZWRTaXplKSk7XG4gIGNvbnN0IGZlZVdpdGhDaGFuZ2UgPSBNYXRoLmNlaWwoZ2V0RmVlKGVzdGltYXRlZFNpemUpICsgZ2V0RmVlKHRoaXMuX2VzdGltYXRlU2l6ZU9mQ2hhbmdlT3V0cHV0KCkpKTtcbiAgaWYgKCF0aGlzLl9jaGFuZ2VTY3JpcHQgfHwgYXZhaWxhYmxlIDw9IGZlZVdpdGhDaGFuZ2UpIHtcbiAgICByZXR1cm4gZmVlO1xuICB9XG4gIHJldHVybiBmZWVXaXRoQ2hhbmdlO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9lc3RpbWF0ZVNpemVPZkNoYW5nZU91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9jaGFuZ2VTY3JpcHQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBzY3JpcHRMZW4gPSB0aGlzLl9jaGFuZ2VTY3JpcHQudG9CdWZmZXIoKS5sZW5ndGg7XG4gIC8vIDggYnl0ZXMgZm9yIHNhdG9zaGlzICsgc2NyaXB0IHNpemUgKyBhY3R1YWwgc2NyaXB0IHNpemVcbiAgcmV0dXJuIDggKyBCdWZmZXJXcml0ZXIudmFyaW50QnVmTnVtKHNjcmlwdExlbikubGVuZ3RoICsgc2NyaXB0TGVuO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9nZXRVbnNwZW50VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2dldElucHV0QW1vdW50KCkgLSB0aGlzLl9nZXRPdXRwdXRBbW91bnQoKTtcbn07XG5cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fY2xlYXJTaWduYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dHMgfHwgW10pIHtcbiAgICBpbnB1dC5jbGVhclNpZ25hdHVyZXMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgdHggc2l6ZSBiZWZvcmUgaW5wdXQgc2lnbmF0dXJlcyBhcmUgYWRkZWQuXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5fZXN0aW1hdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIGxldCByZXN1bHQgPSA0OyAvLyB2ZXJzaW9uXG5cbiAgaWYgKHRoaXMuaGFzV2l0bmVzc2VzKCkpIHtcbiAgICByZXN1bHQgKz0gLjU7XG4gIH1cblxuICByZXN1bHQgKz0gQnVmZmVyV3JpdGVyLnZhcmludEJ1Zk51bSh0aGlzLmlucHV0cy5sZW5ndGgpLmxlbmd0aDtcbiAgZm9yIChjb25zdCBpbnB1dCBvZiB0aGlzLmlucHV0cyB8fCBbXSkge1xuICAgIHJlc3VsdCArPSBpbnB1dC5fZXN0aW1hdGVTaXplKCk7XG4gIH1cblxuICByZXN1bHQgKz0gQnVmZmVyV3JpdGVyLnZhcmludEJ1Zk51bSh0aGlzLm91dHB1dHMubGVuZ3RoKS5sZW5ndGg7XG4gIGZvciAoY29uc3Qgb3V0cHV0IG9mIHRoaXMub3V0cHV0cyB8fCBbXSkge1xuICAgIHJlc3VsdCArPSBvdXRwdXQuY2FsY3VsYXRlU2l6ZSgpO1xuICB9XG5cbiAgcmVzdWx0ICs9IDQ7IC8vIG5Mb2NrVGltZVxuICByZXR1cm4gTWF0aC5jZWlsKHJlc3VsdCk7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2NhbGN1bGF0ZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS5sZW5ndGg7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2NhbGN1bGF0ZVZTaXplID0gZnVuY3Rpb24obm9Sb3VuZCkge1xuICBjb25zdCB2c2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZVdlaWdodCgpIC8gNDtcbiAgcmV0dXJuIG5vUm91bmQgPyB2c2l6ZSA6IE1hdGguY2VpbCh2c2l6ZSk7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX2NhbGN1bGF0ZVdlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMudG9CdWZmZXIodHJ1ZSkubGVuZ3RoICogMykgKyB0aGlzLnRvQnVmZmVyKGZhbHNlKS5sZW5ndGg7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX3JlbW92ZU91dHB1dCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaW5kZXhdO1xuICB0aGlzLm91dHB1dHMgPSBfLndpdGhvdXQodGhpcy5vdXRwdXRzLCBvdXRwdXQpO1xuICB0aGlzLl9vdXRwdXRBbW91bnQgPSB1bmRlZmluZWQ7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUucmVtb3ZlT3V0cHV0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdGhpcy5fcmVtb3ZlT3V0cHV0KGluZGV4KTtcbiAgdGhpcy5fdXBkYXRlQ2hhbmdlT3V0cHV0KCk7XG59O1xuXG4vKipcbiAqIFNvcnQgYSB0cmFuc2FjdGlvbidzIGlucHV0cyBhbmQgb3V0cHV0cyBhY2NvcmRpbmcgdG8gQklQNjlcbiAqXG4gKiBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY5Lm1lZGlhd2lraX1cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc29ydElucHV0cyhmdW5jdGlvbihpbnB1dHMpIHtcbiAgICB2YXIgY29weSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGlucHV0cyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvcHkuZm9yRWFjaCgoeCkgPT4geyB4LmkgPSBpKyt9KTtcbiAgICBjb3B5LnNvcnQoZnVuY3Rpb24oZmlyc3QsIHNlY29uZCkge1xuICAgICByZXR1cm4gY29tcGFyZShmaXJzdC5wcmV2VHhJZCwgc2Vjb25kLnByZXZUeElkKVxuICAgICAgICB8fCBmaXJzdC5vdXRwdXRJbmRleCAtIHNlY29uZC5vdXRwdXRJbmRleFxuICAgICAgICB8fCBmaXJzdC5pIC0gc2Vjb25kLmk7ICAvLyB0byBlbnN1cmUgc3RhYmxlIHNvcnRcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbiAgfSk7XG4gIHRoaXMuc29ydE91dHB1dHMoZnVuY3Rpb24ob3V0cHV0cykge1xuICAgIHZhciBjb3B5ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgb3V0cHV0cyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvcHkuZm9yRWFjaCgoeCkgPT4geyB4LmkgPSBpKyt9KTtcbiAgICBjb3B5LnNvcnQoZnVuY3Rpb24oZmlyc3QsIHNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0LnNhdG9zaGlzIC0gc2Vjb25kLnNhdG9zaGlzXG4gICAgICAgIHx8IGNvbXBhcmUoZmlyc3Quc2NyaXB0LnRvQnVmZmVyKCksIHNlY29uZC5zY3JpcHQudG9CdWZmZXIoKSlcbiAgICAgICAgfHwgZmlyc3QuaSAtIHNlY29uZC5pOyAgLy8gdG8gZW5zdXJlIHN0YWJsZSBzb3J0XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmFuZG9taXplIHRoaXMgdHJhbnNhY3Rpb24ncyBvdXRwdXRzIG9yZGVyaW5nLiBUaGUgc2h1ZmZsaW5nIGFsZ29yaXRobSBpcyBhXG4gKiB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXMgc2h1ZmZsZSwgcHJvdmlkZWQgYnkgbG9kYXNoJ3MgXy5zaHVmZmxlKCkuXG4gKlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNodWZmbGVPdXRwdXRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNvcnRPdXRwdXRzKF8uc2h1ZmZsZSk7XG59O1xuXG4vKipcbiAqIFNvcnQgdGhpcyB0cmFuc2FjdGlvbidzIG91dHB1dHMsIGFjY29yZGluZyB0byBhIGdpdmVuIHNvcnRpbmcgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4gYXJyYXkgYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYSBuZXcgYXJyYXksIHdpdGggdGhlIHNhbWUgZWxlbWVudHNcbiAqIGJ1dCB3aXRoIGEgZGlmZmVyZW50IG9yZGVyLiBUaGUgYXJndW1lbnQgZnVuY3Rpb24gTVVTVCBOT1QgbW9kaWZ5IHRoZSBvcmRlclxuICogb2YgdGhlIG9yaWdpbmFsIGFycmF5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydGluZ0Z1bmN0aW9uXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gdGhpc1xuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuc29ydE91dHB1dHMgPSBmdW5jdGlvbihzb3J0aW5nRnVuY3Rpb24pIHtcbiAgdmFyIG91dHMgPSBzb3J0aW5nRnVuY3Rpb24odGhpcy5vdXRwdXRzKTtcbiAgcmV0dXJuIHRoaXMuX25ld091dHB1dE9yZGVyKG91dHMpO1xufTtcblxuLyoqXG4gKiBTb3J0IHRoaXMgdHJhbnNhY3Rpb24ncyBpbnB1dHMsIGFjY29yZGluZyB0byBhIGdpdmVuIHNvcnRpbmcgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4gYXJyYXkgYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYSBuZXcgYXJyYXksIHdpdGggdGhlIHNhbWUgZWxlbWVudHNcbiAqIGJ1dCB3aXRoIGEgZGlmZmVyZW50IG9yZGVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRpbmdGdW5jdGlvblxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IHRoaXNcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNvcnRJbnB1dHMgPSBmdW5jdGlvbihzb3J0aW5nRnVuY3Rpb24pIHtcbiAgdGhpcy5pbnB1dHMgPSBzb3J0aW5nRnVuY3Rpb24odGhpcy5pbnB1dHMpO1xuICB0aGlzLl9jbGVhclNpZ25hdHVyZXMoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuX25ld091dHB1dE9yZGVyID0gZnVuY3Rpb24obmV3T3V0cHV0cykge1xuICB2YXIgaXNJbnZhbGlkU29ydGluZyA9ICh0aGlzLm91dHB1dHMubGVuZ3RoICE9PSBuZXdPdXRwdXRzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBfLmRpZmZlcmVuY2UodGhpcy5vdXRwdXRzLCBuZXdPdXRwdXRzKS5sZW5ndGggIT09IDApO1xuICBpZiAoaXNJbnZhbGlkU29ydGluZykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuVHJhbnNhY3Rpb24uSW52YWxpZFNvcnRpbmcoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9jaGFuZ2VJbmRleCAhPSBudWxsKSB7XG4gICAgdmFyIGNoYW5nZU91dHB1dCA9IHRoaXMub3V0cHV0c1t0aGlzLl9jaGFuZ2VJbmRleF07XG4gICAgdGhpcy5fY2hhbmdlSW5kZXggPSBuZXdPdXRwdXRzLmluZGV4T2YoY2hhbmdlT3V0cHV0KTtcbiAgfVxuXG4gIHRoaXMub3V0cHV0cyA9IG5ld091dHB1dHM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlbW92ZUlucHV0ID0gZnVuY3Rpb24odHhJZCwgb3V0cHV0SW5kZXgpIHtcbiAgdmFyIGluZGV4O1xuICBpZiAoIW91dHB1dEluZGV4ICYmICFpc05hTih0eElkKSkge1xuICAgIGluZGV4ID0gdHhJZDtcbiAgfSBlbHNlIHtcbiAgICBpbmRleCA9IHRoaXMuaW5wdXRzLmZpbmRJbmRleChmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0LnByZXZUeElkLnRvU3RyaW5nKCdoZXgnKSA9PT0gdHhJZCAmJiBpbnB1dC5vdXRwdXRJbmRleCA9PT0gb3V0cHV0SW5kZXg7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLkludmFsaWRJbmRleChpbmRleCwgdGhpcy5pbnB1dHMubGVuZ3RoKTtcbiAgfVxuICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpbmRleF07XG4gIHRoaXMuaW5wdXRzID0gXy53aXRob3V0KHRoaXMuaW5wdXRzLCBpbnB1dCk7XG4gIHRoaXMuX2lucHV0QW1vdW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLl91cGRhdGVDaGFuZ2VPdXRwdXQoKTtcbn07XG5cbi8qIFNpZ25hdHVyZSBoYW5kbGluZyAqL1xuXG4vKipcbiAqIFNpZ24gdGhlIHRyYW5zYWN0aW9uIHVzaW5nIG9uZSBvciBtb3JlIHByaXZhdGUga2V5cy5cbiAqXG4gKiBJdCB0cmllcyB0byBzaWduIGVhY2ggaW5wdXQsIHZlcmlmeWluZyB0aGF0IHRoZSBzaWduYXR1cmUgd2lsbCBiZSB2YWxpZFxuICogKG1hdGNoZXMgYSBwdWJsaWMga2V5KS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xQcml2YXRlS2V5fSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge251bWJlcn0gW3NpZ3R5cGVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NpZ25pbmdNZXRob2RdIC0gbWV0aG9kIHVzZWQgdG8gc2lnbiAtICdlY2RzYScgb3IgJ3NjaG5vcnInXG4gKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IFttZXJrbGVSb290XSAtIG1lcmtsZSByb290IGZvciB0YXByb290IHNpZ25pbmdcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbihwcml2YXRlS2V5LCBzaWd0eXBlLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSB7XG4gICQuY2hlY2tTdGF0ZSh0aGlzLmhhc0FsbFV0eG9JbmZvKCksICdOb3QgYWxsIHV0eG8gaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uLicpO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcml2YXRlS2V5KSkge1xuICAgIGZvciAoY29uc3QgcGsgb2YgcHJpdmF0ZUtleSkge1xuICAgICAgdGhpcy5zaWduKHBrLCBzaWd0eXBlLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZm9yIChjb25zdCBzaWduYXR1cmUgb2YgdGhpcy5nZXRTaWduYXR1cmVzKHByaXZhdGVLZXksIHNpZ3R5cGUsIHNpZ25pbmdNZXRob2QsIG1lcmtsZVJvb3QpKSB7XG4gICAgdGhpcy5hcHBseVNpZ25hdHVyZShzaWduYXR1cmUsIHNpZ25pbmdNZXRob2QpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldFNpZ25hdHVyZXMgPSBmdW5jdGlvbihwcml2S2V5LCBzaWd0eXBlLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSB7XG4gIGlmICh0eXBlb2YgbWVya2xlUm9vdCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXJrbGVSb290ID0gQnVmZmVyLmZyb20obWVya2xlUm9vdCwgJ2hleCcpO1xuICB9XG4gIHByaXZLZXkgPSBuZXcgUHJpdmF0ZUtleShwcml2S2V5KTtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCBoYXNoRGF0YSA9IEhhc2guc2hhMjU2cmlwZW1kMTYwKHByaXZLZXkucHVibGljS2V5LnRvQnVmZmVyKCkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcbiAgICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiBpbnB1dC5nZXRTaWduYXR1cmVzKHRoaXMsIHByaXZLZXksIGksIHNpZ3R5cGUsIGhhc2hEYXRhLCBzaWduaW5nTWV0aG9kLCBtZXJrbGVSb290KSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaWduYXR1cmUgdG8gdGhlIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IHNpZ25hdHVyZS5pbnB1dEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gc2lnbmF0dXJlLnNpZ3R5cGVcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBzaWduYXR1cmUucHVibGljS2V5XG4gKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlLnNpZ25hdHVyZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25pbmdNZXRob2QgLSAnZWNkc2EnIHRvIHNpZ24gdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSB0aGlzLCBmb3IgY2hhaW5pbmdcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFwcGx5U2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKSB7XG4gIHRoaXMuaW5wdXRzW3NpZ25hdHVyZS5pbnB1dEluZGV4XS5hZGRTaWduYXR1cmUodGhpcywgc2lnbmF0dXJlLCBzaWduaW5nTWV0aG9kKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuaXNGdWxseVNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKGNvbnN0IGlucHV0IG9mIHRoaXMuaW5wdXRzIHx8IFtdKSB7XG4gICAgaWYgKGlucHV0LmlzRnVsbHlTaWduZWQgPT09IElucHV0LnByb3RvdHlwZS5pc0Z1bGx5U2lnbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLlRyYW5zYWN0aW9uLlVuYWJsZVRvVmVyaWZ5U2lnbmF0dXJlKFxuICAgICAgICAnVW5yZWNvZ25pemVkIHNjcmlwdCBraW5kLCBvciBub3QgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGV4ZWN1dGUgc2NyaXB0LicgK1xuICAgICAgICAnVGhpcyB1c3VhbGx5IGhhcHBlbnMgd2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuaW5wdXRzLmV2ZXJ5KGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LmlzRnVsbHlTaWduZWQoKTtcbiAgfSk7XG59O1xuXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCkge1xuICBpZiAodGhpcy5pbnB1dHNbc2lnbmF0dXJlLmlucHV0SW5kZXhdLmlzVmFsaWRTaWduYXR1cmUgPT09IElucHV0LnByb3RvdHlwZS5pc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UcmFuc2FjdGlvbi5VbmFibGVUb1ZlcmlmeVNpZ25hdHVyZShcbiAgICAgICdVbnJlY29nbml6ZWQgc2NyaXB0IGtpbmQsIG9yIG5vdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZXhlY3V0ZSBzY3JpcHQuJyArXG4gICAgICAnVGhpcyB1c3VhbGx5IGhhcHBlbnMgd2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uJ1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaW5wdXRzW3NpZ25hdHVyZS5pbnB1dEluZGV4XS5pc1ZhbGlkU2lnbmF0dXJlKHRoaXMsIHNpZ25hdHVyZSwgc2lnbmluZ01ldGhvZCk7XG59O1xuXG5cbi8qKlxuICogVmVyaWZ5IEVDRFNBIHNpZ25hdHVyZVxuICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZyBcbiAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgXG4gKiBAcGFyYW0ge051bWJlcn0gbmluIFxuICogQHBhcmFtIHtTY3JpcHR9IHN1YnNjcmlwdCBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYXRvc2hpcyBcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuY2hlY2tFY2RzYVNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZywgcHVia2V5LCBuaW4sIHN1YnNjcmlwdCwgc2F0b3NoaXMpIHtcbiAgdmFyIHN1YnNjcmlwdEJ1ZmZlciA9IHN1YnNjcmlwdC50b0J1ZmZlcigpO1xuICB2YXIgc2NyaXB0Q29kZVdyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgc2NyaXB0Q29kZVdyaXRlci53cml0ZVZhcmludE51bShzdWJzY3JpcHRCdWZmZXIubGVuZ3RoKTtcbiAgc2NyaXB0Q29kZVdyaXRlci53cml0ZShzdWJzY3JpcHRCdWZmZXIpO1xuXG4gIHZhciBzYXRvc2hpc0J1ZmZlcjtcbiAgaWYgKHNhdG9zaGlzKSB7XG4gICAgJC5jaGVja1N0YXRlKEpTVXRpbC5pc05hdHVyYWxOdW1iZXIoc2F0b3NoaXMpLCAnc2F0b3NoaXMgbmVlZHMgdG8gYmUgYSBuYXR1cmFsIG51bWJlcicpO1xuICAgIHNhdG9zaGlzQnVmZmVyID0gbmV3IEJ1ZmZlcldyaXRlcigpLndyaXRlVUludDY0TEVCTihuZXcgQk4oc2F0b3NoaXMpKS50b0J1ZmZlcigpO1xuICB9IGVsc2Uge1xuICAgIHNhdG9zaGlzQnVmZmVyID0gdGhpcy5pbnB1dHNbbmluXS5nZXRTYXRvc2hpc0J1ZmZlcigpO1xuICB9XG4gIHZhciB2ZXJpZmllZCA9IFNpZ2hhc2hXaXRuZXNzLnZlcmlmeShcbiAgICB0aGlzLFxuICAgIHNpZyxcbiAgICBwdWJrZXksXG4gICAgbmluLFxuICAgIHNjcmlwdENvZGVXcml0ZXIudG9CdWZmZXIoKSxcbiAgICBzYXRvc2hpc0J1ZmZlclxuICApO1xuICByZXR1cm4gdmVyaWZpZWQ7XG59O1xuXG5cbi8qKlxuICogVmVyaWZ5IFNjaG5vcnIgc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZyBcbiAqIEBwYXJhbSB7UHVibGljS2V5fEJ1ZmZlcn0gcHVia2V5IFxuICogQHBhcmFtIHtOdW1iZXJ9IG5pbiBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaWd2ZXJzaW9uIFxuICogQHBhcmFtIHtPYmplY3R9IGV4ZWNkYXRhIFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5jaGVja1NjaG5vcnJTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcsIHB1YmtleSwgbmluLCBzaWd2ZXJzaW9uLCBleGVjZGF0YSkge1xuICBpZiAoJC5pc1R5cGUocHVia2V5LCAnUHVibGljS2V5JykpIHtcbiAgICBwdWJrZXkgPSBwdWJrZXkucG9pbnQueC50b0J1ZmZlcigpO1xuICB9XG4gICQuY2hlY2tBcmd1bWVudChwdWJrZXkgJiYgcHVia2V5Lmxlbmd0aCA9PT0gMzIsICdTY2hub3JyIHNpZ25hdHVyZXMgaGF2ZSAzMi1ieXRlIHB1YmxpYyBrZXlzLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbmZvcmNpbmcgdGhpcy4nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNpZykpIHtcbiAgICBpZiAoc2lnLmxlbmd0aCAhPT0gNjQgJiYgc2lnLmxlbmd0aCAhPT0gNjUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2lnID0gU2lnbmF0dXJlLmZyb21TY2hub3JyKHNpZyk7XG4gIH1cbiAgLy8gTm90ZSB0aGF0IGluIFRhcHNjcmlwdCBldmFsdWF0aW9uLCBlbXB0eSBzaWduYXR1cmVzIGFyZSB0cmVhdGVkIHNwZWNpYWxseSAoaW52YWxpZCBzaWduYXR1cmUgdGhhdCBkb2VzIG5vdFxuICAvLyBhYm9ydCBzY3JpcHQgZXhlY3V0aW9uKS4gVGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBJbnRlcnByZXRlci5ldmFsQ2hlY2tzaWdUYXBzY3JpcHQsIHdoaWNoIHdvbid0IGludm9rZVxuICAvLyBDaGVja1NjaG5vcnJTaWduYXR1cmUgaW4gdGhhdCBjYXNlLiBJbiBvdGhlciBjb250ZXh0cywgdGhleSBhcmUgaW52YWxpZCBsaWtlIGV2ZXJ5IG90aGVyIHNpZ25hdHVyZSB3aXRoXG4gIC8vIHNpemUgZGlmZmVyZW50IGZyb20gNjQgb3IgNjUuXG4gICQuY2hlY2tBcmd1bWVudChzaWcuaXNTY2hub3JyLCAnU2lnbmF0dXJlIG11c3QgYmUgc2Nobm9ycicpO1xuXG4gIGlmICghU2lnaGFzaFNjaG5vcnIudmVyaWZ5KHRoaXMsIHNpZywgcHVia2V5LCBzaWd2ZXJzaW9uLCBuaW4sIGV4ZWNkYXRhKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBoZXJlIGxhcmdlbHkgZm9yIGxlZ2FjeSByZWFzb25zLiBIb3dldmVyLCBpZiB0aGUgc2lnIHR5cGVcbiAqIGlzIGFscmVhZHkga25vd24gKHZpYSBzaWd2ZXJzaW9uKSwgdGhlbiBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gY2FsbFxuICogY2hlY2tFY2RzYVNpZ25hdHVyZSBvciBjaGVja1NjaG5vcnJTaWduYXR1cmUgZGlyZWN0bHkuXG4gKiBAcGFyYW0ge1NpZ25hdHVyZXxCdWZmZXJ9IHNpZyBTaWduYXR1cmUgdG8gdmVyaWZ5XG4gKiBAcGFyYW0ge1B1YmxpY0tleXxCdWZmZXJ9IHB1YmtleSBQdWJsaWMga2V5IHVzZWQgdG8gdmVyaWZ5IHNpZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG5pbiBUeCBpbnB1dCBpbmRleCB0byB2ZXJpZnkgc2lnbmF0dXJlIGFnYWluc3RcbiAqIEBwYXJhbSB7U2NyaXB0fSBzdWJzY3JpcHQgRUNEU0Egb25seVxuICogQHBhcmFtIHtOdW1iZXJ9IHNpZ3ZlcnNpb24gU2VlIFNpZ25hdHVyZS5WZXJzaW9uIGZvciB2YWxpZCB2ZXJzaW9ucyAoZGVmYXVsdDogMCBvciBTaWduYXR1cmUuVmVyc2lvbi5CQVNFKVxuICogQHBhcmFtIHtOdW1iZXJ9IHNhdG9zaGlzIEVDRFNBIG9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBleGVjZGF0YSBTY2hub3JyIG9ubHlcbiAqIEByZXR1cm5zIHtCb29sZWFufSB3aGV0aGVyIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQgZm9yIHRoaXMgdHJhbnNhY3Rpb24gaW5wdXRcbiAqL1xuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnZlcmlmeVNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZywgcHVia2V5LCBuaW4sIHN1YnNjcmlwdCwgc2lndmVyc2lvbiwgc2F0b3NoaXMsIGV4ZWNkYXRhKSB7XG4gIGlmIChzaWd2ZXJzaW9uID09IG51bGwpIHtcbiAgICBzaWd2ZXJzaW9uID0gU2lnbmF0dXJlLlZlcnNpb24uQkFTRTtcbiAgfVxuXG4gIHN3aXRjaChzaWd2ZXJzaW9uKSB7XG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5XSVRORVNTX1YwOlxuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFY2RzYVNpZ25hdHVyZShzaWcsIHB1YmtleSwgbmluLCBzdWJzY3JpcHQsIHNhdG9zaGlzKTtcbiAgICBjYXNlIFNpZ25hdHVyZS5WZXJzaW9uLlRBUFJPT1Q6XG4gICAgY2FzZSBTaWduYXR1cmUuVmVyc2lvbi5UQVBTQ1JJUFQ6XG4gICAgICByZXR1cm4gdGhpcy5jaGVja1NjaG5vcnJTaWduYXR1cmUoc2lnLCBwdWJrZXksIG5pbiwgc2lndmVyc2lvbiwgZXhlY2RhdGEpO1xuICAgIGNhc2UgU2lnbmF0dXJlLlZlcnNpb24uQkFTRTpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFNpZ2hhc2gudmVyaWZ5KHRoaXMsIHNpZywgcHVia2V5LCBuaW4sIHN1YnNjcmlwdCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgdGhhdCBhIHRyYW5zYWN0aW9uIHBhc3NlcyBiYXNpYyBzYW5pdHkgdGVzdHMuIElmIG5vdCwgcmV0dXJuIGEgc3RyaW5nXG4gKiBkZXNjcmliaW5nIHRoZSBlcnJvci4gVGhpcyBmdW5jdGlvbiBjb250YWlucyB0aGUgc2FtZSBsb2dpYyBhc1xuICogQ2hlY2tUcmFuc2FjdGlvbiBpbiBiaXRjb2luIGNvcmUuXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbigpIHtcbiAgLy8gQmFzaWMgY2hlY2tzIHRoYXQgZG9uJ3QgZGVwZW5kIG9uIGFueSBjb250ZXh0XG4gIGlmICh0aGlzLmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIHR4aW5zIGVtcHR5JztcbiAgfVxuXG4gIGlmICh0aGlzLm91dHB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dHMgZW1wdHknO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIG9yIG92ZXJmbG93IG91dHB1dCB2YWx1ZXNcbiAgdmFyIHZhbHVlb3V0Ym4gPSBuZXcgQk4oMCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR4b3V0ID0gdGhpcy5vdXRwdXRzW2ldO1xuXG4gICAgaWYgKHR4b3V0LmludmFsaWRTYXRvc2hpcygpKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIHR4b3V0ICcgKyBpICsgJyBzYXRvc2hpcyBpcyBpbnZhbGlkJztcbiAgICB9XG4gICAgaWYgKHR4b3V0Ll9zYXRvc2hpc0JOLmd0KG5ldyBCTihUcmFuc2FjdGlvbi5NQVhfTU9ORVksIDEwKSkpIHtcbiAgICAgIHJldHVybiAndHJhbnNhY3Rpb24gdHhvdXQgJyArIGkgKyAnIGdyZWF0ZXIgdGhhbiBNQVhfTU9ORVknO1xuICAgIH1cbiAgICB2YWx1ZW91dGJuID0gdmFsdWVvdXRibi5hZGQodHhvdXQuX3NhdG9zaGlzQk4pO1xuICAgIGlmICh2YWx1ZW91dGJuLmd0KG5ldyBCTihUcmFuc2FjdGlvbi5NQVhfTU9ORVkpKSkge1xuICAgICAgcmV0dXJuICd0cmFuc2FjdGlvbiB0eG91dCAnICsgaSArICcgdG90YWwgb3V0cHV0IGdyZWF0ZXIgdGhhbiBNQVhfTU9ORVknO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNpemUgbGltaXRzXG4gIGlmICh0aGlzLnRvQnVmZmVyKCkubGVuZ3RoID4gTUFYX0JMT0NLX1NJWkUpIHtcbiAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIG92ZXIgdGhlIG1heGltdW0gYmxvY2sgc2l6ZSc7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGlucHV0c1xuICB2YXIgdHhpbm1hcCA9IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHhpbiA9IHRoaXMuaW5wdXRzW2ldO1xuXG4gICAgdmFyIGlucHV0aWQgPSB0eGluLnByZXZUeElkICsgJzonICsgdHhpbi5vdXRwdXRJbmRleDtcbiAgICBpZiAodHhpbm1hcFtpbnB1dGlkXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zYWN0aW9uIGlucHV0ICcgKyBpICsgJyBkdXBsaWNhdGUgaW5wdXQnO1xuICAgIH1cbiAgICB0eGlubWFwW2lucHV0aWRdID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc0NvaW5iYXNlID0gdGhpcy5pc0NvaW5iYXNlKCk7XG4gIGlmIChpc0NvaW5iYXNlKSB7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuaW5wdXRzWzBdLl9zY3JpcHRCdWZmZXI7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPCAyIHx8IGJ1Zi5sZW5ndGggPiAxMDApIHtcbiAgICAgIHJldHVybiAnY29pbmJhc2UgdHJhbnNhY3Rpb24gc2NyaXB0IHNpemUgaW52YWxpZCc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuaW5wdXRzW2ldLmlzTnVsbCgpKSB7XG4gICAgICAgIHJldHVybiAndHJhbnNhY3Rpb24gaW5wdXQgJyArIGkgKyAnIGhhcyBudWxsIGlucHV0JztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFuYWxvZ291cyB0byBiaXRjb2luZCdzIElzQ29pbkJhc2UgZnVuY3Rpb24gaW4gdHJhbnNhY3Rpb24uaFxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuaXNDb2luYmFzZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmlucHV0c1swXS5pc051bGwoKSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhpcyB0cmFuc2FjdGlvbiBjYW4gYmUgcmVwbGFjZWQgaW4gdGhlIG1lbXBvb2wgd2l0aCBhbm90aGVyXG4gKiB0cmFuc2FjdGlvbiB0aGF0IHByb3ZpZGVzIGEgc3VmZmljaWVudGx5IGhpZ2hlciBmZWUgKFJCRikuXG4gKi9cblRyYW5zYWN0aW9uLnByb3RvdHlwZS5pc1JCRiA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XG4gICAgaWYgKGlucHV0LnNlcXVlbmNlTnVtYmVyIDwgSW5wdXQuTUFYSU5UIC0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRoaXMgdHJhbnNhY3Rpb24gdG8gYmUgcmVwbGFjZWQgaW4gdGhlIG1lbXBvb2wgKFJCRikgaWYgYSB0cmFuc2FjdGlvblxuICogaW5jbHVkZXMgYSBzdWZmaWNpZW50bHkgaGlnaGVyIGZlZS4gSXQgd2lsbCBzZXQgdGhlIHNlcXVlbmNlTnVtYmVyIHRvXG4gKiBERUZBVUxUX1JCRl9TRVFOVU1CRVIgZm9yIGFsbCBpbnB1dHMgaWYgdGhlIHNlcXVlbmNlIG51bWJlciBkb2VzIG5vdFxuICogYWxyZWFkeSBlbmFibGUgUkJGLlxuICovXG5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZW5hYmxlUkJGID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcbiAgICBpZiAoaW5wdXQuc2VxdWVuY2VOdW1iZXIgPj0gSW5wdXQuTUFYSU5UIC0gMSkge1xuICAgICAgaW5wdXQuc2VxdWVuY2VOdW1iZXIgPSBJbnB1dC5ERUZBVUxUX1JCRl9TRVFOVU1CRVI7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNldFZlcnNpb24gPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gICQuY2hlY2tBcmd1bWVudChcbiAgICBKU1V0aWwuaXNOYXR1cmFsTnVtYmVyKHZlcnNpb24pICYmIHZlcnNpb24gPD0gQ1VSUkVOVF9WRVJTSU9OLFxuICAgICdXcm9uZyB2ZXJzaW9uIG51bWJlcicpO1xuICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/transaction/unspentoutput.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/transaction/unspentoutput.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar $ = __webpack_require__(/*! ../util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\nvar JSUtil = __webpack_require__(/*! ../util/js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\n\nvar Script = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/bitcore-lib/lib/script/index.js\");\nvar Address = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Unit = __webpack_require__(/*! ../unit */ \"(ssr)/./node_modules/bitcore-lib/lib/unit.js\");\n\n/**\n * Represents an unspent output information: its script, associated amount and address,\n * transaction id and output index.\n *\n * @constructor\n * @param {object} data\n * @param {string} data.txid the previous transaction id\n * @param {string=} data.txId alias for `txid`\n * @param {number} data.vout the index in the transaction\n * @param {number=} data.outputIndex alias for `vout`\n * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds\n * @param {string|Script=} data.script alias for `scriptPubKey`\n * @param {number} data.amount amount of bitcoins associated\n * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis (1 BTC = 1e8 satoshis)\n * @param {string|Address=} data.address the associated address to the script, if provided\n */\nfunction UnspentOutput(data) {\n  /* jshint maxcomplexity: 20 */\n  /* jshint maxstatements: 20 */\n  if (!(this instanceof UnspentOutput)) {\n    return new UnspentOutput(data);\n  }\n  $.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');\n  var address = data.address ? new Address(data.address) : undefined;\n  var txId = data.txid ? data.txid : data.txId;\n  if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {\n    // TODO: Use the errors library\n    throw new Error('Invalid TXID in object', data);\n  }\n  var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;\n  if (!_.isNumber(outputIndex)) {\n    throw new Error('Invalid outputIndex, received ' + outputIndex);\n  }\n  $.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script),\n                  'Must provide the scriptPubKey for that output!');\n  var script = new Script(data.scriptPubKey || data.script);\n  $.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis),\n                      'Must provide an amount for the output');\n  var amount = !_.isUndefined(data.amount) ? new Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;\n  $.checkArgument(_.isNumber(amount), 'Amount must be a number');\n  JSUtil.defineImmutable(this, {\n    address: address,\n    txId: txId,\n    outputIndex: outputIndex,\n    script: script,\n    satoshis: amount\n  });\n}\n\n/**\n * Provide an informative output when displaying this object in the console\n * @returns string\n */\nUnspentOutput.prototype.inspect = function() {\n  return '<UnspentOutput: ' + this.txId + ':' + this.outputIndex +\n         ', satoshis: ' + this.satoshis + ', address: ' + this.address + '>';\n};\n\n/**\n * String representation: just \"txid:index\"\n * @returns string\n */\nUnspentOutput.prototype.toString = function() {\n  return this.txId + ':' + this.outputIndex;\n};\n\n/**\n * Deserialize an UnspentOutput from an object\n * @param {object|string} data\n * @return UnspentOutput\n */\nUnspentOutput.fromObject = function(data) {\n  return new UnspentOutput(data);\n};\n\n/**\n * Returns a plain object (no prototype or methods) with the associated info for this output\n * @return {object}\n */\nUnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject() {\n  return {\n    address: this.address ? this.address.toString() : undefined,\n    txid: this.txId,\n    vout: this.outputIndex,\n    scriptPubKey: this.script.toBuffer().toString('hex'),\n    amount: Unit.fromSatoshis(this.satoshis).toBTC()\n  };\n};\n\nmodule.exports = UnspentOutput;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3RyYW5zYWN0aW9uL3Vuc3BlbnRvdXRwdXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFRO0FBQ3hCLFFBQVEsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLG1FQUFZOztBQUVqQyxhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLG1FQUFZO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyw2REFBUzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi90cmFuc2FjdGlvbi91bnNwZW50b3V0cHV0LmpzPzlhOWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyICQgPSByZXF1aXJlKCcuLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcbnZhciBKU1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2pzJyk7XG5cbnZhciBTY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi4vYWRkcmVzcycpO1xudmFyIFVuaXQgPSByZXF1aXJlKCcuLi91bml0Jyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiB1bnNwZW50IG91dHB1dCBpbmZvcm1hdGlvbjogaXRzIHNjcmlwdCwgYXNzb2NpYXRlZCBhbW91bnQgYW5kIGFkZHJlc3MsXG4gKiB0cmFuc2FjdGlvbiBpZCBhbmQgb3V0cHV0IGluZGV4LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhLnR4aWQgdGhlIHByZXZpb3VzIHRyYW5zYWN0aW9uIGlkXG4gKiBAcGFyYW0ge3N0cmluZz19IGRhdGEudHhJZCBhbGlhcyBmb3IgYHR4aWRgXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YS52b3V0IHRoZSBpbmRleCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyPX0gZGF0YS5vdXRwdXRJbmRleCBhbGlhcyBmb3IgYHZvdXRgXG4gKiBAcGFyYW0ge3N0cmluZ3xTY3JpcHR9IGRhdGEuc2NyaXB0UHViS2V5IHRoZSBzY3JpcHQgdGhhdCBtdXN0IGJlIHJlc29sdmVkIHRvIHJlbGVhc2UgdGhlIGZ1bmRzXG4gKiBAcGFyYW0ge3N0cmluZ3xTY3JpcHQ9fSBkYXRhLnNjcmlwdCBhbGlhcyBmb3IgYHNjcmlwdFB1YktleWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFtb3VudCBhbW91bnQgb2YgYml0Y29pbnMgYXNzb2NpYXRlZFxuICogQHBhcmFtIHtudW1iZXI9fSBkYXRhLnNhdG9zaGlzIGFsaWFzIGZvciBgYW1vdW50YCwgYnV0IGV4cHJlc3NlZCBpbiBzYXRvc2hpcyAoMSBCVEMgPSAxZTggc2F0b3NoaXMpXG4gKiBAcGFyYW0ge3N0cmluZ3xBZGRyZXNzPX0gZGF0YS5hZGRyZXNzIHRoZSBhc3NvY2lhdGVkIGFkZHJlc3MgdG8gdGhlIHNjcmlwdCwgaWYgcHJvdmlkZWRcbiAqL1xuZnVuY3Rpb24gVW5zcGVudE91dHB1dChkYXRhKSB7XG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAyMCAqL1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAgKi9cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVuc3BlbnRPdXRwdXQpKSB7XG4gICAgcmV0dXJuIG5ldyBVbnNwZW50T3V0cHV0KGRhdGEpO1xuICB9XG4gICQuY2hlY2tBcmd1bWVudChfLmlzT2JqZWN0KGRhdGEpLCAnTXVzdCBwcm92aWRlIGFuIG9iamVjdCBmcm9tIHdoZXJlIHRvIGV4dHJhY3QgZGF0YScpO1xuICB2YXIgYWRkcmVzcyA9IGRhdGEuYWRkcmVzcyA/IG5ldyBBZGRyZXNzKGRhdGEuYWRkcmVzcykgOiB1bmRlZmluZWQ7XG4gIHZhciB0eElkID0gZGF0YS50eGlkID8gZGF0YS50eGlkIDogZGF0YS50eElkO1xuICBpZiAoIXR4SWQgfHwgIUpTVXRpbC5pc0hleGFTdHJpbmcodHhJZCkgfHwgdHhJZC5sZW5ndGggPiA2NCkge1xuICAgIC8vIFRPRE86IFVzZSB0aGUgZXJyb3JzIGxpYnJhcnlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVFhJRCBpbiBvYmplY3QnLCBkYXRhKTtcbiAgfVxuICB2YXIgb3V0cHV0SW5kZXggPSBfLmlzVW5kZWZpbmVkKGRhdGEudm91dCkgPyBkYXRhLm91dHB1dEluZGV4IDogZGF0YS52b3V0O1xuICBpZiAoIV8uaXNOdW1iZXIob3V0cHV0SW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG91dHB1dEluZGV4LCByZWNlaXZlZCAnICsgb3V0cHV0SW5kZXgpO1xuICB9XG4gICQuY2hlY2tBcmd1bWVudCghXy5pc1VuZGVmaW5lZChkYXRhLnNjcmlwdFB1YktleSkgfHwgIV8uaXNVbmRlZmluZWQoZGF0YS5zY3JpcHQpLFxuICAgICAgICAgICAgICAgICAgJ011c3QgcHJvdmlkZSB0aGUgc2NyaXB0UHViS2V5IGZvciB0aGF0IG91dHB1dCEnKTtcbiAgdmFyIHNjcmlwdCA9IG5ldyBTY3JpcHQoZGF0YS5zY3JpcHRQdWJLZXkgfHwgZGF0YS5zY3JpcHQpO1xuICAkLmNoZWNrQXJndW1lbnQoIV8uaXNVbmRlZmluZWQoZGF0YS5hbW91bnQpIHx8ICFfLmlzVW5kZWZpbmVkKGRhdGEuc2F0b3NoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICdNdXN0IHByb3ZpZGUgYW4gYW1vdW50IGZvciB0aGUgb3V0cHV0Jyk7XG4gIHZhciBhbW91bnQgPSAhXy5pc1VuZGVmaW5lZChkYXRhLmFtb3VudCkgPyBuZXcgVW5pdC5mcm9tQlRDKGRhdGEuYW1vdW50KS50b1NhdG9zaGlzKCkgOiBkYXRhLnNhdG9zaGlzO1xuICAkLmNoZWNrQXJndW1lbnQoXy5pc051bWJlcihhbW91bnQpLCAnQW1vdW50IG11c3QgYmUgYSBudW1iZXInKTtcbiAgSlNVdGlsLmRlZmluZUltbXV0YWJsZSh0aGlzLCB7XG4gICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICB0eElkOiB0eElkLFxuICAgIG91dHB1dEluZGV4OiBvdXRwdXRJbmRleCxcbiAgICBzY3JpcHQ6IHNjcmlwdCxcbiAgICBzYXRvc2hpczogYW1vdW50XG4gIH0pO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgYW4gaW5mb3JtYXRpdmUgb3V0cHV0IHdoZW4gZGlzcGxheWluZyB0aGlzIG9iamVjdCBpbiB0aGUgY29uc29sZVxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cblVuc3BlbnRPdXRwdXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8VW5zcGVudE91dHB1dDogJyArIHRoaXMudHhJZCArICc6JyArIHRoaXMub3V0cHV0SW5kZXggK1xuICAgICAgICAgJywgc2F0b3NoaXM6ICcgKyB0aGlzLnNhdG9zaGlzICsgJywgYWRkcmVzczogJyArIHRoaXMuYWRkcmVzcyArICc+Jztcbn07XG5cbi8qKlxuICogU3RyaW5nIHJlcHJlc2VudGF0aW9uOiBqdXN0IFwidHhpZDppbmRleFwiXG4gKiBAcmV0dXJucyBzdHJpbmdcbiAqL1xuVW5zcGVudE91dHB1dC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHhJZCArICc6JyArIHRoaXMub3V0cHV0SW5kZXg7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplIGFuIFVuc3BlbnRPdXRwdXQgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gZGF0YVxuICogQHJldHVybiBVbnNwZW50T3V0cHV0XG4gKi9cblVuc3BlbnRPdXRwdXQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBVbnNwZW50T3V0cHV0KGRhdGEpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IChubyBwcm90b3R5cGUgb3IgbWV0aG9kcykgd2l0aCB0aGUgYXNzb2NpYXRlZCBpbmZvIGZvciB0aGlzIG91dHB1dFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5VbnNwZW50T3V0cHV0LnByb3RvdHlwZS50b09iamVjdCA9IFVuc3BlbnRPdXRwdXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyA/IHRoaXMuYWRkcmVzcy50b1N0cmluZygpIDogdW5kZWZpbmVkLFxuICAgIHR4aWQ6IHRoaXMudHhJZCxcbiAgICB2b3V0OiB0aGlzLm91dHB1dEluZGV4LFxuICAgIHNjcmlwdFB1YktleTogdGhpcy5zY3JpcHQudG9CdWZmZXIoKS50b1N0cmluZygnaGV4JyksXG4gICAgYW1vdW50OiBVbml0LmZyb21TYXRvc2hpcyh0aGlzLnNhdG9zaGlzKS50b0JUQygpXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuc3BlbnRPdXRwdXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/transaction/unspentoutput.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/unit.js":
/*!**********************************************!*\
  !*** ./node_modules/bitcore-lib/lib/unit.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nvar errors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar $ = __webpack_require__(/*! ./util/preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nvar UNITS = {\n  'BTC'      : [1e8, 8],\n  'mBTC'     : [1e5, 5],\n  'uBTC'     : [1e2, 2],\n  'bits'     : [1e2, 2],\n  'satoshis' : [1, 0]\n};\n\n/**\n * Utility for handling and converting bitcoins units. The supported units are\n * BTC, mBTC, bits (also named uBTC) and satoshis. A unit instance can be created with an\n * amount and a unit code, or alternatively using static methods like {fromBTC}.\n * It also allows to be created from a fiat amount and the exchange rate, or\n * alternatively using the {fromFiat} static method.\n * You can consult for different representation of a unit instance using it's\n * {to} method, the fixed unit methods like {toSatoshis} or alternatively using\n * the unit accessors. It also can be converted to a fiat amount by providing the\n * corresponding BTC/fiat exchange rate.\n *\n * @example\n * ```javascript\n * var sats = Unit.fromBTC(1.3).toSatoshis();\n * var mili = Unit.fromBits(1.3).to(Unit.mBTC);\n * var bits = Unit.fromFiat(1.3, 350).bits;\n * var btc = new Unit(1.3, Unit.bits).BTC;\n * ```\n *\n * @param {Number} amount - The amount to be represented\n * @param {String|Number} code - The unit of the amount or the exchange rate\n * @returns {Unit} A new instance of an Unit\n * @constructor\n */\nfunction Unit(amount, code) {\n  if (!(this instanceof Unit)) {\n    return new Unit(amount, code);\n  }\n\n  // convert fiat to BTC\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n    amount = amount / code;\n    code = Unit.BTC;\n  }\n\n  this._value = this._from(amount, code);\n\n  var self = this;\n  var defineAccesor = function(key) {\n    Object.defineProperty(self, key, {\n      get: function() { return self.to(key); },\n      enumerable: true,\n    });\n  };\n\n  Object.keys(UNITS).forEach(defineAccesor);\n}\n\nObject.keys(UNITS).forEach(function(key) {\n  Unit[key] = key;\n});\n\n/**\n * Returns a Unit instance created from JSON string or object\n *\n * @param {String|Object} json - JSON with keys: amount and code\n * @returns {Unit} A Unit instance\n */\nUnit.fromObject = function fromObject(data){\n  $.checkArgument(_.isObject(data), 'Argument is expected to be an object');\n  return new Unit(data.amount, data.code);\n};\n\n/**\n * Returns a Unit instance created from an amount in BTC\n *\n * @param {Number} amount - The amount in BTC\n * @returns {Unit} A Unit instance\n */\nUnit.fromBTC = function(amount) {\n  return new Unit(amount, Unit.BTC);\n};\n\n/**\n * Returns a Unit instance created from an amount in mBTC\n *\n * @param {Number} amount - The amount in mBTC\n * @returns {Unit} A Unit instance\n */\nUnit.fromMillis = Unit.fromMilis = function(amount) {\n  return new Unit(amount, Unit.mBTC);\n};\n\n/**\n * Returns a Unit instance created from an amount in bits\n *\n * @param {Number} amount - The amount in bits\n * @returns {Unit} A Unit instance\n */\nUnit.fromMicros = Unit.fromBits = function(amount) {\n  return new Unit(amount, Unit.bits);\n};\n\n/**\n * Returns a Unit instance created from an amount in satoshis\n *\n * @param {Number} amount - The amount in satoshis\n * @returns {Unit} A Unit instance\n */\nUnit.fromSatoshis = function(amount) {\n  return new Unit(amount, Unit.satoshis);\n};\n\n/**\n * Returns a Unit instance created from a fiat amount and exchange rate.\n *\n * @param {Number} amount - The amount in fiat\n * @param {Number} rate - The exchange rate BTC/fiat\n * @returns {Unit} A Unit instance\n */\nUnit.fromFiat = function(amount, rate) {\n  return new Unit(amount, rate);\n};\n\nUnit.prototype._from = function(amount, code) {\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n  return parseInt((amount * UNITS[code][0]).toFixed());\n};\n\n/**\n * Returns the value represented in the specified unit\n *\n * @param {String|Number} code - The unit code or exchange rate\n * @returns {Number} The converted value\n */\nUnit.prototype.to = function(code) {\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n    return parseFloat((this.BTC * code).toFixed(2));\n  }\n\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n\n  var value = this._value / UNITS[code][0];\n  return parseFloat(value.toFixed(UNITS[code][1]));\n};\n\n/**\n * Returns the value represented in BTC\n *\n * @returns {Number} The value converted to BTC\n */\nUnit.prototype.toBTC = function() {\n  return this.to(Unit.BTC);\n};\n\n/**\n * Returns the value represented in mBTC\n *\n * @returns {Number} The value converted to mBTC\n */\nUnit.prototype.toMillis = Unit.prototype.toMilis = function() {\n  return this.to(Unit.mBTC);\n};\n\n/**\n * Returns the value represented in bits\n *\n * @returns {Number} The value converted to bits\n */\nUnit.prototype.toMicros = Unit.prototype.toBits = function() {\n  return this.to(Unit.bits);\n};\n\n/**\n * Returns the value represented in satoshis\n *\n * @returns {Number} The value converted to satoshis\n */\nUnit.prototype.toSatoshis = function() {\n  return this.to(Unit.satoshis);\n};\n\n/**\n * Returns the value represented in fiat\n *\n * @param {string} rate - The exchange rate between BTC/currency\n * @returns {Number} The value converted to satoshis\n */\nUnit.prototype.atRate = function(rate) {\n  return this.to(rate);\n};\n\n/**\n * Returns a the string representation of the value in satoshis\n *\n * @returns {string} the value in satoshis\n */\nUnit.prototype.toString = function() {\n  return this.satoshis + ' satoshis';\n};\n\n/**\n * Returns a plain object representation of the Unit\n *\n * @returns {Object} An object with the keys: amount and code\n */\nUnit.prototype.toObject = Unit.prototype.toJSON = function toObject() {\n  return {\n    amount: this.BTC,\n    code: Unit.BTC\n  };\n};\n\n/**\n * Returns a string formatted for the console\n *\n * @returns {string} the value in satoshis\n */\nUnit.prototype.inspect = function() {\n  return '<Unit: ' + this.toString() + '>';\n};\n\nmodule.exports = Unit;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3VuaXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFROztBQUV4QixhQUFhLG1CQUFPLENBQUMsc0VBQVU7QUFDL0IsUUFBUSxtQkFBTyxDQUFDLHdGQUFzQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBLElBQUksSUFBSSxxQ0FBcUMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi91bml0LmpzPzI2ODUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciAkID0gcmVxdWlyZSgnLi91dGlsL3ByZWNvbmRpdGlvbnMnKTtcblxudmFyIFVOSVRTID0ge1xuICAnQlRDJyAgICAgIDogWzFlOCwgOF0sXG4gICdtQlRDJyAgICAgOiBbMWU1LCA1XSxcbiAgJ3VCVEMnICAgICA6IFsxZTIsIDJdLFxuICAnYml0cycgICAgIDogWzFlMiwgMl0sXG4gICdzYXRvc2hpcycgOiBbMSwgMF1cbn07XG5cbi8qKlxuICogVXRpbGl0eSBmb3IgaGFuZGxpbmcgYW5kIGNvbnZlcnRpbmcgYml0Y29pbnMgdW5pdHMuIFRoZSBzdXBwb3J0ZWQgdW5pdHMgYXJlXG4gKiBCVEMsIG1CVEMsIGJpdHMgKGFsc28gbmFtZWQgdUJUQykgYW5kIHNhdG9zaGlzLiBBIHVuaXQgaW5zdGFuY2UgY2FuIGJlIGNyZWF0ZWQgd2l0aCBhblxuICogYW1vdW50IGFuZCBhIHVuaXQgY29kZSwgb3IgYWx0ZXJuYXRpdmVseSB1c2luZyBzdGF0aWMgbWV0aG9kcyBsaWtlIHtmcm9tQlRDfS5cbiAqIEl0IGFsc28gYWxsb3dzIHRvIGJlIGNyZWF0ZWQgZnJvbSBhIGZpYXQgYW1vdW50IGFuZCB0aGUgZXhjaGFuZ2UgcmF0ZSwgb3JcbiAqIGFsdGVybmF0aXZlbHkgdXNpbmcgdGhlIHtmcm9tRmlhdH0gc3RhdGljIG1ldGhvZC5cbiAqIFlvdSBjYW4gY29uc3VsdCBmb3IgZGlmZmVyZW50IHJlcHJlc2VudGF0aW9uIG9mIGEgdW5pdCBpbnN0YW5jZSB1c2luZyBpdCdzXG4gKiB7dG99IG1ldGhvZCwgdGhlIGZpeGVkIHVuaXQgbWV0aG9kcyBsaWtlIHt0b1NhdG9zaGlzfSBvciBhbHRlcm5hdGl2ZWx5IHVzaW5nXG4gKiB0aGUgdW5pdCBhY2Nlc3NvcnMuIEl0IGFsc28gY2FuIGJlIGNvbnZlcnRlZCB0byBhIGZpYXQgYW1vdW50IGJ5IHByb3ZpZGluZyB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgQlRDL2ZpYXQgZXhjaGFuZ2UgcmF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHNhdHMgPSBVbml0LmZyb21CVEMoMS4zKS50b1NhdG9zaGlzKCk7XG4gKiB2YXIgbWlsaSA9IFVuaXQuZnJvbUJpdHMoMS4zKS50byhVbml0Lm1CVEMpO1xuICogdmFyIGJpdHMgPSBVbml0LmZyb21GaWF0KDEuMywgMzUwKS5iaXRzO1xuICogdmFyIGJ0YyA9IG5ldyBVbml0KDEuMywgVW5pdC5iaXRzKS5CVEM7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gVGhlIGFtb3VudCB0byBiZSByZXByZXNlbnRlZFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBjb2RlIC0gVGhlIHVuaXQgb2YgdGhlIGFtb3VudCBvciB0aGUgZXhjaGFuZ2UgcmF0ZVxuICogQHJldHVybnMge1VuaXR9IEEgbmV3IGluc3RhbmNlIG9mIGFuIFVuaXRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVbml0KGFtb3VudCwgY29kZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW5pdCkpIHtcbiAgICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCBjb2RlKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgZmlhdCB0byBCVENcbiAgaWYgKF8uaXNOdW1iZXIoY29kZSkpIHtcbiAgICBpZiAoY29kZSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLlVuaXQuSW52YWxpZFJhdGUoY29kZSk7XG4gICAgfVxuICAgIGFtb3VudCA9IGFtb3VudCAvIGNvZGU7XG4gICAgY29kZSA9IFVuaXQuQlRDO1xuICB9XG5cbiAgdGhpcy5fdmFsdWUgPSB0aGlzLl9mcm9tKGFtb3VudCwgY29kZSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZGVmaW5lQWNjZXNvciA9IGZ1bmN0aW9uKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLnRvKGtleSk7IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH0pO1xuICB9O1xuXG4gIE9iamVjdC5rZXlzKFVOSVRTKS5mb3JFYWNoKGRlZmluZUFjY2Vzb3IpO1xufVxuXG5PYmplY3Qua2V5cyhVTklUUykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgVW5pdFtrZXldID0ga2V5O1xufSk7XG5cbi8qKlxuICogUmV0dXJucyBhIFVuaXQgaW5zdGFuY2UgY3JlYXRlZCBmcm9tIEpTT04gc3RyaW5nIG9yIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ganNvbiAtIEpTT04gd2l0aCBrZXlzOiBhbW91bnQgYW5kIGNvZGVcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcbiAqL1xuVW5pdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChkYXRhKXtcbiAgJC5jaGVja0FyZ3VtZW50KF8uaXNPYmplY3QoZGF0YSksICdBcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QnKTtcbiAgcmV0dXJuIG5ldyBVbml0KGRhdGEuYW1vdW50LCBkYXRhLmNvZGUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgVW5pdCBpbnN0YW5jZSBjcmVhdGVkIGZyb20gYW4gYW1vdW50IGluIEJUQ1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSBUaGUgYW1vdW50IGluIEJUQ1xuICogQHJldHVybnMge1VuaXR9IEEgVW5pdCBpbnN0YW5jZVxuICovXG5Vbml0LmZyb21CVEMgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgcmV0dXJuIG5ldyBVbml0KGFtb3VudCwgVW5pdC5CVEMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgVW5pdCBpbnN0YW5jZSBjcmVhdGVkIGZyb20gYW4gYW1vdW50IGluIG1CVENcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gVGhlIGFtb3VudCBpbiBtQlRDXG4gKiBAcmV0dXJucyB7VW5pdH0gQSBVbml0IGluc3RhbmNlXG4gKi9cblVuaXQuZnJvbU1pbGxpcyA9IFVuaXQuZnJvbU1pbGlzID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gIHJldHVybiBuZXcgVW5pdChhbW91bnQsIFVuaXQubUJUQyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBVbml0IGluc3RhbmNlIGNyZWF0ZWQgZnJvbSBhbiBhbW91bnQgaW4gYml0c1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSBUaGUgYW1vdW50IGluIGJpdHNcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcbiAqL1xuVW5pdC5mcm9tTWljcm9zID0gVW5pdC5mcm9tQml0cyA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCBVbml0LmJpdHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgVW5pdCBpbnN0YW5jZSBjcmVhdGVkIGZyb20gYW4gYW1vdW50IGluIHNhdG9zaGlzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIFRoZSBhbW91bnQgaW4gc2F0b3NoaXNcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcbiAqL1xuVW5pdC5mcm9tU2F0b3NoaXMgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgcmV0dXJuIG5ldyBVbml0KGFtb3VudCwgVW5pdC5zYXRvc2hpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBVbml0IGluc3RhbmNlIGNyZWF0ZWQgZnJvbSBhIGZpYXQgYW1vdW50IGFuZCBleGNoYW5nZSByYXRlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSBUaGUgYW1vdW50IGluIGZpYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYXRlIC0gVGhlIGV4Y2hhbmdlIHJhdGUgQlRDL2ZpYXRcbiAqIEByZXR1cm5zIHtVbml0fSBBIFVuaXQgaW5zdGFuY2VcbiAqL1xuVW5pdC5mcm9tRmlhdCA9IGZ1bmN0aW9uKGFtb3VudCwgcmF0ZSkge1xuICByZXR1cm4gbmV3IFVuaXQoYW1vdW50LCByYXRlKTtcbn07XG5cblVuaXQucHJvdG90eXBlLl9mcm9tID0gZnVuY3Rpb24oYW1vdW50LCBjb2RlKSB7XG4gIGlmICghVU5JVFNbY29kZV0pIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlVuaXQuVW5rbm93bkNvZGUoY29kZSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSW50KChhbW91bnQgKiBVTklUU1tjb2RlXVswXSkudG9GaXhlZCgpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgaW4gdGhlIHNwZWNpZmllZCB1bml0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBjb2RlIC0gVGhlIHVuaXQgY29kZSBvciBleGNoYW5nZSByYXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgY29udmVydGVkIHZhbHVlXG4gKi9cblVuaXQucHJvdG90eXBlLnRvID0gZnVuY3Rpb24oY29kZSkge1xuICBpZiAoXy5pc051bWJlcihjb2RlKSkge1xuICAgIGlmIChjb2RlIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuVW5pdC5JbnZhbGlkUmF0ZShjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoKHRoaXMuQlRDICogY29kZSkudG9GaXhlZCgyKSk7XG4gIH1cblxuICBpZiAoIVVOSVRTW2NvZGVdKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Vbml0LlVua25vd25Db2RlKGNvZGUpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWUgLyBVTklUU1tjb2RlXVswXTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZChVTklUU1tjb2RlXVsxXSkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBpbiBCVENcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIEJUQ1xuICovXG5Vbml0LnByb3RvdHlwZS50b0JUQyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50byhVbml0LkJUQyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIG1CVENcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIG1CVENcbiAqL1xuVW5pdC5wcm90b3R5cGUudG9NaWxsaXMgPSBVbml0LnByb3RvdHlwZS50b01pbGlzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvKFVuaXQubUJUQyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIGJpdHNcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIGJpdHNcbiAqL1xuVW5pdC5wcm90b3R5cGUudG9NaWNyb3MgPSBVbml0LnByb3RvdHlwZS50b0JpdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG8oVW5pdC5iaXRzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgaW4gc2F0b3NoaXNcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIHNhdG9zaGlzXG4gKi9cblVuaXQucHJvdG90eXBlLnRvU2F0b3NoaXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG8oVW5pdC5zYXRvc2hpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIGZpYXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF0ZSAtIFRoZSBleGNoYW5nZSByYXRlIGJldHdlZW4gQlRDL2N1cnJlbmN5XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgY29udmVydGVkIHRvIHNhdG9zaGlzXG4gKi9cblVuaXQucHJvdG90eXBlLmF0UmF0ZSA9IGZ1bmN0aW9uKHJhdGUpIHtcbiAgcmV0dXJuIHRoaXMudG8ocmF0ZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSBpbiBzYXRvc2hpc1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB2YWx1ZSBpbiBzYXRvc2hpc1xuICovXG5Vbml0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zYXRvc2hpcyArICcgc2F0b3NoaXMnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBVbml0XG4gKlxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGtleXM6IGFtb3VudCBhbmQgY29kZVxuICovXG5Vbml0LnByb3RvdHlwZS50b09iamVjdCA9IFVuaXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIGFtb3VudDogdGhpcy5CVEMsXG4gICAgY29kZTogVW5pdC5CVENcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyBmb3JtYXR0ZWQgZm9yIHRoZSBjb25zb2xlXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHZhbHVlIGluIHNhdG9zaGlzXG4gKi9cblVuaXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8VW5pdDogJyArIHRoaXMudG9TdHJpbmcoKSArICc+Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/unit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/uri.js":
/*!*********************************************!*\
  !*** ./node_modules/bitcore-lib/lib/uri.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\nvar URL = __webpack_require__(/*! url */ \"url\");\n\nvar Address = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/bitcore-lib/lib/address.js\");\nvar Unit = __webpack_require__(/*! ./unit */ \"(ssr)/./node_modules/bitcore-lib/lib/unit.js\");\n\n/**\n * Bitcore URI\n *\n * Instantiate an URI from a bitcoin URI String or an Object. An URI instance\n * can be created with a bitcoin uri string or an object. All instances of\n * URI are valid, the static method isValid allows checking before instantiation.\n *\n * All standard parameters can be found as members of the class, the address\n * is represented using an {Address} instance and the amount is represented in\n * satoshis. Any other non-standard parameters can be found under the extra member.\n *\n * @example\n * ```javascript\n *\n * var uri = new URI('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');\n * console.log(uri.address, uri.amount);\n * ```\n *\n * @param {string|Object} data - A bitcoin URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n * @returns {URI} A new valid and frozen instance of URI\n * @constructor\n */\nvar URI = function(data, knownParams) {\n  if (!(this instanceof URI)) {\n    return new URI(data, knownParams);\n  }\n\n  this.extras = {};\n  this.knownParams = knownParams || [];\n  this.address = this.network = this.amount = this.message = null;\n\n  if (typeof(data) === 'string') {\n    var params = URI.parse(data);\n    if (params.amount) {\n      params.amount = this._parseAmount(params.amount);\n    }\n    this._fromObject(params);\n  } else if (typeof(data) === 'object') {\n    this._fromObject(data);\n  } else {\n    throw new TypeError('Unrecognized data format.');\n  }\n};\n\n/**\n * Instantiate a URI from a String\n *\n * @param {string} str - JSON string or object of the URI\n * @returns {URI} A new instance of a URI\n */\nURI.fromString = function fromString(str) {\n  if (typeof(str) !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return new URI(str);\n};\n\n/**\n * Instantiate a URI from an Object\n *\n * @param {Object} data - object of the URI\n * @returns {URI} A new instance of a URI\n */\nURI.fromObject = function fromObject(json) {\n  return new URI(json);\n};\n\n/**\n * Check if an bitcoin URI string is valid\n *\n * @example\n * ```javascript\n *\n * var valid = URI.isValid('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');\n * // true\n * ```\n *\n * @param {string|Object} data - A bitcoin URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @returns {boolean} Result of uri validation\n */\nURI.isValid = function(arg, knownParams) {\n  try {\n    new URI(arg, knownParams);\n  } catch (err) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Convert a bitcoin URI string into a simple object.\n *\n * @param {string} uri - A bitcoin URI string\n * @throws {TypeError} Invalid bitcoin URI\n * @returns {Object} An object with the parsed params\n */\nURI.parse = function(uri) {\n  var info = URL.parse(uri, true);\n\n  if (info.protocol !== 'bitcoin:') {\n    throw new TypeError('Invalid bitcoin URI');\n  }\n\n  // workaround to host insensitiveness\n  var group = /[^:]*:\\/?\\/?([^?]*)/.exec(uri);\n  info.query.address = group && group[1] || undefined;\n\n  return info.query;\n};\n\nURI.Members = ['address', 'amount', 'message', 'label', 'r'];\n\n/**\n * Internal function to load the URI instance with an object.\n *\n * @param {Object} obj - Object with the information\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n */\nURI.prototype._fromObject = function(obj) {\n  /* jshint maxcomplexity: 10 */\n\n  if (!Address.isValid(obj.address)) {\n    throw new TypeError('Invalid bitcoin address');\n  }\n\n  this.address = new Address(obj.address);\n  this.network = this.address.network;\n  this.amount = obj.amount;\n\n  for (var key in obj) {\n    if (key === 'address' || key === 'amount') {\n      continue;\n    }\n\n    if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {\n      throw Error('Unknown required argument ' + key);\n    }\n\n    var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;\n    destination[key] = obj[key];\n  }\n};\n\n/**\n * Internal function to transform a BTC string amount into satoshis\n *\n * @param {string} amount - Amount BTC string\n * @throws {TypeError} Invalid amount\n * @returns {Object} Amount represented in satoshis\n */\nURI.prototype._parseAmount = function(amount) {\n  amount = Number(amount);\n  if (isNaN(amount)) {\n    throw new TypeError('Invalid amount');\n  }\n  return Unit.fromBTC(amount).toSatoshis();\n};\n\nURI.prototype.toObject = URI.prototype.toJSON = function toObject() {\n  var json = {};\n  for (var i = 0; i < URI.Members.length; i++) {\n    var m = URI.Members[i];\n    if (this.hasOwnProperty(m) && typeof(this[m]) !== 'undefined') {\n      json[m] = this[m].toString();\n    }\n  }\n  _.extend(json, this.extras);\n  return json;\n};\n\n/**\n * Will return a the string representation of the URI\n *\n * @returns {string} Bitcoin URI string\n */\nURI.prototype.toString = function() {\n  var query = {};\n  if (this.amount) {\n    query.amount = Unit.fromSatoshis(this.amount).toBTC();\n  }\n  if (this.message) {\n    query.message = this.message;\n  }\n  if (this.label) {\n    query.label = this.label;\n  }\n  if (this.r) {\n    query.r = this.r;\n  }\n  _.extend(query, this.extras);\n\n  return URL.format({\n    protocol: 'bitcoin:',\n    host: this.address,\n    query: query\n  });\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin URI\n */\nURI.prototype.inspect = function() {\n  return '<URI: ' + this.toString() + '>';\n};\n\nmodule.exports = URI;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3VyaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEIsVUFBVSxtQkFBTyxDQUFDLGdCQUFLOztBQUV2QixjQUFjLG1CQUFPLENBQUMsa0VBQVc7QUFDakMsV0FBVyxtQkFBTyxDQUFDLDREQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksV0FBVztBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdXJpLmpzPzk4N2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIFVSTCA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xudmFyIFVuaXQgPSByZXF1aXJlKCcuL3VuaXQnKTtcblxuLyoqXG4gKiBCaXRjb3JlIFVSSVxuICpcbiAqIEluc3RhbnRpYXRlIGFuIFVSSSBmcm9tIGEgYml0Y29pbiBVUkkgU3RyaW5nIG9yIGFuIE9iamVjdC4gQW4gVVJJIGluc3RhbmNlXG4gKiBjYW4gYmUgY3JlYXRlZCB3aXRoIGEgYml0Y29pbiB1cmkgc3RyaW5nIG9yIGFuIG9iamVjdC4gQWxsIGluc3RhbmNlcyBvZlxuICogVVJJIGFyZSB2YWxpZCwgdGhlIHN0YXRpYyBtZXRob2QgaXNWYWxpZCBhbGxvd3MgY2hlY2tpbmcgYmVmb3JlIGluc3RhbnRpYXRpb24uXG4gKlxuICogQWxsIHN0YW5kYXJkIHBhcmFtZXRlcnMgY2FuIGJlIGZvdW5kIGFzIG1lbWJlcnMgb2YgdGhlIGNsYXNzLCB0aGUgYWRkcmVzc1xuICogaXMgcmVwcmVzZW50ZWQgdXNpbmcgYW4ge0FkZHJlc3N9IGluc3RhbmNlIGFuZCB0aGUgYW1vdW50IGlzIHJlcHJlc2VudGVkIGluXG4gKiBzYXRvc2hpcy4gQW55IG90aGVyIG5vbi1zdGFuZGFyZCBwYXJhbWV0ZXJzIGNhbiBiZSBmb3VuZCB1bmRlciB0aGUgZXh0cmEgbWVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKlxuICogdmFyIHVyaSA9IG5ldyBVUkkoJ2JpdGNvaW46MTJBMU15ZlhiVzZSaGRSQVpFcW9mYWM1akNRUWp3RVBCdT9hbW91bnQ9MS4yJyk7XG4gKiBjb25zb2xlLmxvZyh1cmkuYWRkcmVzcywgdXJpLmFtb3VudCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGRhdGEgLSBBIGJpdGNvaW4gVVJJIHN0cmluZyBvciBhbiBPYmplY3RcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSBrbm93blBhcmFtcyAtIFJlcXVpcmVkIG5vbi1zdGFuZGFyZCBwYXJhbXNcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBiaXRjb2luIGFkZHJlc3NcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBhbW91bnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBVbmtub3duIHJlcXVpcmVkIGFyZ3VtZW50XG4gKiBAcmV0dXJucyB7VVJJfSBBIG5ldyB2YWxpZCBhbmQgZnJvemVuIGluc3RhbmNlIG9mIFVSSVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBVUkkgPSBmdW5jdGlvbihkYXRhLCBrbm93blBhcmFtcykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVVJJKSkge1xuICAgIHJldHVybiBuZXcgVVJJKGRhdGEsIGtub3duUGFyYW1zKTtcbiAgfVxuXG4gIHRoaXMuZXh0cmFzID0ge307XG4gIHRoaXMua25vd25QYXJhbXMgPSBrbm93blBhcmFtcyB8fCBbXTtcbiAgdGhpcy5hZGRyZXNzID0gdGhpcy5uZXR3b3JrID0gdGhpcy5hbW91bnQgPSB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuXG4gIGlmICh0eXBlb2YoZGF0YSkgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHBhcmFtcyA9IFVSSS5wYXJzZShkYXRhKTtcbiAgICBpZiAocGFyYW1zLmFtb3VudCkge1xuICAgICAgcGFyYW1zLmFtb3VudCA9IHRoaXMuX3BhcnNlQW1vdW50KHBhcmFtcy5hbW91bnQpO1xuICAgIH1cbiAgICB0aGlzLl9mcm9tT2JqZWN0KHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuX2Zyb21PYmplY3QoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0LicpO1xuICB9XG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgVVJJIGZyb20gYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gSlNPTiBzdHJpbmcgb3Igb2JqZWN0IG9mIHRoZSBVUklcbiAqIEByZXR1cm5zIHtVUkl9IEEgbmV3IGluc3RhbmNlIG9mIGEgVVJJXG4gKi9cblVSSS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgaWYgKHR5cGVvZihzdHIpICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkkoc3RyKTtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYSBVUkkgZnJvbSBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIG9iamVjdCBvZiB0aGUgVVJJXG4gKiBAcmV0dXJucyB7VVJJfSBBIG5ldyBpbnN0YW5jZSBvZiBhIFVSSVxuICovXG5VUkkuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3QoanNvbikge1xuICByZXR1cm4gbmV3IFVSSShqc29uKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYml0Y29pbiBVUkkgc3RyaW5nIGlzIHZhbGlkXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqXG4gKiB2YXIgdmFsaWQgPSBVUkkuaXNWYWxpZCgnYml0Y29pbjoxMkExTXlmWGJXNlJoZFJBWkVxb2ZhYzVqQ1FRandFUEJ1Jyk7XG4gKiAvLyB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGRhdGEgLSBBIGJpdGNvaW4gVVJJIHN0cmluZyBvciBhbiBPYmplY3RcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSBrbm93blBhcmFtcyAtIFJlcXVpcmVkIG5vbi1zdGFuZGFyZCBwYXJhbXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXN1bHQgb2YgdXJpIHZhbGlkYXRpb25cbiAqL1xuVVJJLmlzVmFsaWQgPSBmdW5jdGlvbihhcmcsIGtub3duUGFyYW1zKSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSSShhcmcsIGtub3duUGFyYW1zKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgYml0Y29pbiBVUkkgc3RyaW5nIGludG8gYSBzaW1wbGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBBIGJpdGNvaW4gVVJJIHN0cmluZ1xuICogQHRocm93cyB7VHlwZUVycm9yfSBJbnZhbGlkIGJpdGNvaW4gVVJJXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgcGFyc2VkIHBhcmFtc1xuICovXG5VUkkucGFyc2UgPSBmdW5jdGlvbih1cmkpIHtcbiAgdmFyIGluZm8gPSBVUkwucGFyc2UodXJpLCB0cnVlKTtcblxuICBpZiAoaW5mby5wcm90b2NvbCAhPT0gJ2JpdGNvaW46Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYml0Y29pbiBVUkknKTtcbiAgfVxuXG4gIC8vIHdvcmthcm91bmQgdG8gaG9zdCBpbnNlbnNpdGl2ZW5lc3NcbiAgdmFyIGdyb3VwID0gL1teOl0qOlxcLz9cXC8/KFteP10qKS8uZXhlYyh1cmkpO1xuICBpbmZvLnF1ZXJ5LmFkZHJlc3MgPSBncm91cCAmJiBncm91cFsxXSB8fCB1bmRlZmluZWQ7XG5cbiAgcmV0dXJuIGluZm8ucXVlcnk7XG59O1xuXG5VUkkuTWVtYmVycyA9IFsnYWRkcmVzcycsICdhbW91bnQnLCAnbWVzc2FnZScsICdsYWJlbCcsICdyJ107XG5cbi8qKlxuICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gbG9hZCB0aGUgVVJJIGluc3RhbmNlIHdpdGggYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3Qgd2l0aCB0aGUgaW5mb3JtYXRpb25cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBiaXRjb2luIGFkZHJlc3NcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBhbW91bnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBVbmtub3duIHJlcXVpcmVkIGFyZ3VtZW50XG4gKi9cblVSSS5wcm90b3R5cGUuX2Zyb21PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG5cbiAgaWYgKCFBZGRyZXNzLmlzVmFsaWQob2JqLmFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBiaXRjb2luIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRoaXMuYWRkcmVzcyA9IG5ldyBBZGRyZXNzKG9iai5hZGRyZXNzKTtcbiAgdGhpcy5uZXR3b3JrID0gdGhpcy5hZGRyZXNzLm5ldHdvcms7XG4gIHRoaXMuYW1vdW50ID0gb2JqLmFtb3VudDtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGtleSA9PT0gJ2FkZHJlc3MnIHx8IGtleSA9PT0gJ2Ftb3VudCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgvXnJlcS0vLmV4ZWMoa2V5KSAmJiB0aGlzLmtub3duUGFyYW1zLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHJlcXVpcmVkIGFyZ3VtZW50ICcgKyBrZXkpO1xuICAgIH1cblxuICAgIHZhciBkZXN0aW5hdGlvbiA9IFVSSS5NZW1iZXJzLmluZGV4T2Yoa2V5KSA+IC0xID8gdGhpcyA6IHRoaXMuZXh0cmFzO1xuICAgIGRlc3RpbmF0aW9uW2tleV0gPSBvYmpba2V5XTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYSBCVEMgc3RyaW5nIGFtb3VudCBpbnRvIHNhdG9zaGlzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIEFtb3VudCBCVEMgc3RyaW5nXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IEludmFsaWQgYW1vdW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbW91bnQgcmVwcmVzZW50ZWQgaW4gc2F0b3NoaXNcbiAqL1xuVVJJLnByb3RvdHlwZS5fcGFyc2VBbW91bnQgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgYW1vdW50ID0gTnVtYmVyKGFtb3VudCk7XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhbW91bnQnKTtcbiAgfVxuICByZXR1cm4gVW5pdC5mcm9tQlRDKGFtb3VudCkudG9TYXRvc2hpcygpO1xufTtcblxuVVJJLnByb3RvdHlwZS50b09iamVjdCA9IFVSSS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIHZhciBqc29uID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVVJJLk1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IFVSSS5NZW1iZXJzW2ldO1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KG0pICYmIHR5cGVvZih0aGlzW21dKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGpzb25bbV0gPSB0aGlzW21dLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIF8uZXh0ZW5kKGpzb24sIHRoaXMuZXh0cmFzKTtcbiAgcmV0dXJuIGpzb247XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVVJJXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gQml0Y29pbiBVUkkgc3RyaW5nXG4gKi9cblVSSS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHF1ZXJ5ID0ge307XG4gIGlmICh0aGlzLmFtb3VudCkge1xuICAgIHF1ZXJ5LmFtb3VudCA9IFVuaXQuZnJvbVNhdG9zaGlzKHRoaXMuYW1vdW50KS50b0JUQygpO1xuICB9XG4gIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICBxdWVyeS5tZXNzYWdlID0gdGhpcy5tZXNzYWdlO1xuICB9XG4gIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgcXVlcnkubGFiZWwgPSB0aGlzLmxhYmVsO1xuICB9XG4gIGlmICh0aGlzLnIpIHtcbiAgICBxdWVyeS5yID0gdGhpcy5yO1xuICB9XG4gIF8uZXh0ZW5kKHF1ZXJ5LCB0aGlzLmV4dHJhcyk7XG5cbiAgcmV0dXJuIFVSTC5mb3JtYXQoe1xuICAgIHByb3RvY29sOiAnYml0Y29pbjonLFxuICAgIGhvc3Q6IHRoaXMuYWRkcmVzcyxcbiAgICBxdWVyeTogcXVlcnlcbiAgfSk7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGZvcm1hdHRlZCBmb3IgdGhlIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCaXRjb2luIFVSSVxuICovXG5VUkkucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8VVJJOiAnICsgdGhpcy50b1N0cmluZygpICsgJz4nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVUkk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/uri.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/util/buffer.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\nvar js = __webpack_require__(/*! ./js */ \"(ssr)/./node_modules/bitcore-lib/lib/util/js.js\");\nvar $ = __webpack_require__(/*! ./preconditions */ \"(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\");\n\nfunction equals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = {\n  /**\n   * Fill a buffer with a value.\n   *\n   * @param {Buffer} buffer\n   * @param {number} value\n   * @return {Buffer}\n   */\n  fill: function fill(buffer, value) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    $.checkArgumentType(value, 'number', 'value');\n    var length = buffer.length;\n    for (var i = 0; i < length; i++) {\n      buffer[i] = value;\n    }\n    return buffer;\n  },\n\n  /**\n   * Return a copy of a buffer\n   *\n   * @param {Buffer} original\n   * @return {Buffer}\n   */\n  copy: function(original) {\n    var buffer = Buffer.alloc(original.length);\n    original.copy(buffer);\n    return buffer;\n  },\n\n  /**\n   * Returns true if the given argument is an instance of a buffer. Tests for\n   * both node's Buffer and Uint8Array\n   *\n   * @param {*} arg\n   * @return {boolean}\n   */\n  isBuffer: function isBuffer(arg) {\n    return buffer.Buffer.isBuffer(arg) || arg instanceof Uint8Array;\n  },\n\n  /**\n   * Returns a zero-filled byte array\n   *\n   * @param {number} bytes\n   * @return {Buffer}\n   */\n  emptyBuffer: function emptyBuffer(bytes) {\n    $.checkArgumentType(bytes, 'number', 'bytes');\n    var result = Buffer.alloc(bytes);\n    for (var i = 0; i < bytes; i++) {\n      result.write('\\0', i);\n    }\n    return result;\n  },\n\n  /**\n   * Concatenates a buffer\n   *\n   * Shortcut for <tt>buffer.Buffer.concat</tt>\n   */\n  concat: buffer.Buffer.concat,\n\n  equals: equals,\n  equal: equals,\n\n  /**\n   * Transforms a number from 0 to 255 into a Buffer of size 1 with that value\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {\n    $.checkArgumentType(integer, 'number', 'integer');\n    return Buffer.from([integer & 0xff]);\n  },\n\n  /**\n   * Transform a 4-byte integer into a Buffer of length 4.\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsBuffer: function integerAsBuffer(integer) {\n    $.checkArgumentType(integer, 'number', 'integer');\n    var bytes = [];\n    bytes.push((integer >> 24) & 0xff);\n    bytes.push((integer >> 16) & 0xff);\n    bytes.push((integer >> 8) & 0xff);\n    bytes.push(integer & 0xff);\n    return Buffer.from(bytes);\n  },\n\n  /**\n   * Transform the first 4 values of a Buffer into a number, in little endian encoding\n   *\n   * @param {Buffer} buffer\n   * @return {number}\n   */\n  integerFromBuffer: function integerFromBuffer(buffer) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    return buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];\n  },\n\n  /**\n   * Transforms the first byte of an array into a number ranging from -128 to 127\n   * @param {Buffer} buffer\n   * @return {number}\n   */\n  integerFromSingleByteBuffer: function integerFromBuffer(buffer) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    return buffer[0];\n  },\n\n  /**\n   * Transforms a buffer into a string with a number in hexa representation\n   *\n   * Shorthand for <tt>buffer.toString('hex')</tt>\n   *\n   * @param {Buffer} buffer\n   * @return {string}\n   */\n  bufferToHex: function bufferToHex(buffer) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    return buffer.toString('hex');\n  },\n\n  /**\n   * Reverse a buffer\n   * @param {Buffer} param\n   * @return {Buffer}\n   */\n  reverse: function reverse(param) {\n    return (Buffer.from(param)).reverse();\n  },\n};\n\nmodule.exports.NULL_HASH = module.exports.fill(Buffer.alloc(32), 0);\nmodule.exports.EMPTY_BUFFER = Buffer.alloc(0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3V0aWwvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7O0FBRTdCLFNBQVMsbUJBQU8sQ0FBQyw2REFBTTtBQUN2QixRQUFRLG1CQUFPLENBQUMsbUZBQWlCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsd0JBQXdCO0FBQ3hCLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL2xpYi91dGlsL2J1ZmZlci5qcz9hNTZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIganMgPSByZXF1aXJlKCcuL2pzJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4vcHJlY29uZGl0aW9ucycpO1xuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsZW5ndGggPSBhLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEZpbGwgYSBidWZmZXIgd2l0aCBhIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAqL1xuICBmaWxsOiBmdW5jdGlvbiBmaWxsKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGJ1ZmZlciwgJ0J1ZmZlcicsICdidWZmZXInKTtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKHZhbHVlLCAnbnVtYmVyJywgJ3ZhbHVlJyk7XG4gICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmZmVyW2ldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvcHkgb2YgYSBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IG9yaWdpbmFsXG4gICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhvcmlnaW5hbC5sZW5ndGgpO1xuICAgIG9yaWdpbmFsLmNvcHkoYnVmZmVyKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGEgYnVmZmVyLiBUZXN0cyBmb3JcbiAgICogYm90aCBub2RlJ3MgQnVmZmVyIGFuZCBVaW50OEFycmF5XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYXJnXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0J1ZmZlcjogZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYXJnKSB8fCBhcmcgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgemVyby1maWxsZWQgYnl0ZSBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNcbiAgICogQHJldHVybiB7QnVmZmVyfVxuICAgKi9cbiAgZW1wdHlCdWZmZXI6IGZ1bmN0aW9uIGVtcHR5QnVmZmVyKGJ5dGVzKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50VHlwZShieXRlcywgJ251bWJlcicsICdieXRlcycpO1xuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MoYnl0ZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykge1xuICAgICAgcmVzdWx0LndyaXRlKCdcXDAnLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGEgYnVmZmVyXG4gICAqXG4gICAqIFNob3J0Y3V0IGZvciA8dHQ+YnVmZmVyLkJ1ZmZlci5jb25jYXQ8L3R0PlxuICAgKi9cbiAgY29uY2F0OiBidWZmZXIuQnVmZmVyLmNvbmNhdCxcblxuICBlcXVhbHM6IGVxdWFscyxcbiAgZXF1YWw6IGVxdWFscyxcblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIG51bWJlciBmcm9tIDAgdG8gMjU1IGludG8gYSBCdWZmZXIgb2Ygc2l6ZSAxIHdpdGggdGhhdCB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZWdlclxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICAqL1xuICBpbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyOiBmdW5jdGlvbiBpbnRlZ2VyQXNTaW5nbGVCeXRlQnVmZmVyKGludGVnZXIpIHtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGludGVnZXIsICdudW1iZXInLCAnaW50ZWdlcicpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShbaW50ZWdlciAmIDB4ZmZdKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhbnNmb3JtIGEgNC1ieXRlIGludGVnZXIgaW50byBhIEJ1ZmZlciBvZiBsZW5ndGggNC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVnZXJcbiAgICogQHJldHVybiB7QnVmZmVyfVxuICAgKi9cbiAgaW50ZWdlckFzQnVmZmVyOiBmdW5jdGlvbiBpbnRlZ2VyQXNCdWZmZXIoaW50ZWdlcikge1xuICAgICQuY2hlY2tBcmd1bWVudFR5cGUoaW50ZWdlciwgJ251bWJlcicsICdpbnRlZ2VyJyk7XG4gICAgdmFyIGJ5dGVzID0gW107XG4gICAgYnl0ZXMucHVzaCgoaW50ZWdlciA+PiAyNCkgJiAweGZmKTtcbiAgICBieXRlcy5wdXNoKChpbnRlZ2VyID4+IDE2KSAmIDB4ZmYpO1xuICAgIGJ5dGVzLnB1c2goKGludGVnZXIgPj4gOCkgJiAweGZmKTtcbiAgICBieXRlcy5wdXNoKGludGVnZXIgJiAweGZmKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIGZpcnN0IDQgdmFsdWVzIG9mIGEgQnVmZmVyIGludG8gYSBudW1iZXIsIGluIGxpdHRsZSBlbmRpYW4gZW5jb2RpbmdcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBpbnRlZ2VyRnJvbUJ1ZmZlcjogZnVuY3Rpb24gaW50ZWdlckZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgJC5jaGVja0FyZ3VtZW50VHlwZShidWZmZXIsICdCdWZmZXInLCAnYnVmZmVyJyk7XG4gICAgcmV0dXJuIGJ1ZmZlclswXSA8PCAyNCB8IGJ1ZmZlclsxXSA8PCAxNiB8IGJ1ZmZlclsyXSA8PCA4IHwgYnVmZmVyWzNdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoZSBmaXJzdCBieXRlIG9mIGFuIGFycmF5IGludG8gYSBudW1iZXIgcmFuZ2luZyBmcm9tIC0xMjggdG8gMTI3XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgaW50ZWdlckZyb21TaW5nbGVCeXRlQnVmZmVyOiBmdW5jdGlvbiBpbnRlZ2VyRnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGJ1ZmZlciwgJ0J1ZmZlcicsICdidWZmZXInKTtcbiAgICByZXR1cm4gYnVmZmVyWzBdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgYnVmZmVyIGludG8gYSBzdHJpbmcgd2l0aCBhIG51bWJlciBpbiBoZXhhIHJlcHJlc2VudGF0aW9uXG4gICAqXG4gICAqIFNob3J0aGFuZCBmb3IgPHR0PmJ1ZmZlci50b1N0cmluZygnaGV4Jyk8L3R0PlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGJ1ZmZlclRvSGV4OiBmdW5jdGlvbiBidWZmZXJUb0hleChidWZmZXIpIHtcbiAgICAkLmNoZWNrQXJndW1lbnRUeXBlKGJ1ZmZlciwgJ0J1ZmZlcicsICdidWZmZXInKTtcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV2ZXJzZSBhIGJ1ZmZlclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcGFyYW1cbiAgICogQHJldHVybiB7QnVmZmVyfVxuICAgKi9cbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZShwYXJhbSkge1xuICAgIHJldHVybiAoQnVmZmVyLmZyb20ocGFyYW0pKS5yZXZlcnNlKCk7XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5OVUxMX0hBU0ggPSBtb2R1bGUuZXhwb3J0cy5maWxsKEJ1ZmZlci5hbGxvYygzMiksIDApO1xubW9kdWxlLmV4cG9ydHMuRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jKDApO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/util/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/util/js.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/util/js.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\n/**\n * Determines whether a string contains only hexadecimal values\n *\n * @name JSUtil.isHexa\n * @param {string} value\n * @return {boolean} true if the string is the hexa representation of a number\n */\nvar isHexa = function isHexa(value) {\n  if (!_.isString(value)) {\n    return false;\n  }\n  return /^[0-9a-fA-F]+$/.test(value);\n};\n\n/**\n * @namespace JSUtil\n */\nmodule.exports = {\n  /**\n   * Test if an argument is a valid JSON object. If it is, returns a truthy\n   * value (the json object decoded), so no double JSON.parse call is necessary\n   *\n   * @param {string} arg\n   * @return {Object|boolean} false if the argument is not a JSON string.\n   */\n  isValidJSON: function isValidJSON(arg) {\n    var parsed;\n    if (!_.isString(arg)) {\n      return false;\n    }\n    try {\n      parsed = JSON.parse(arg);\n    } catch (e) {\n      return false;\n    }\n    if (typeof(parsed) === 'object') {\n      return true;\n    }\n    return false;\n  },\n  isHexa: isHexa,\n  isHexaString: isHexa,\n\n  /**\n   * Clone an array\n   */\n  cloneArray: function(array) {\n    return [].concat(array);\n  },\n\n  /**\n   * Define immutable properties on a target object\n   *\n   * @param {Object} target - An object to be extended\n   * @param {Object} values - An object of properties\n   * @return {Object} The target object\n   */\n  defineImmutable: function defineImmutable(target, values) {\n    Object.keys(values).forEach(function(key){\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        value: values[key]\n      });\n    });\n    return target;\n  },\n  /**\n   * Checks that a value is a natural number, a positive integer or zero.\n   *\n   * @param {*} value\n   * @return {Boolean}\n   */\n  isNaturalNumber: function isNaturalNumber(value) {\n    return typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value &&\n      value >= 0;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3V0aWwvanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLHFEQUFROztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9iaXRjb3JlLWxpYi9saWIvdXRpbC9qcy5qcz9hMDEwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgY29udGFpbnMgb25seSBoZXhhZGVjaW1hbCB2YWx1ZXNcbiAqXG4gKiBAbmFtZSBKU1V0aWwuaXNIZXhhXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHN0cmluZyBpcyB0aGUgaGV4YSByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlclxuICovXG52YXIgaXNIZXhhID0gZnVuY3Rpb24gaXNIZXhhKHZhbHVlKSB7XG4gIGlmICghXy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIC9eWzAtOWEtZkEtRl0rJC8udGVzdCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSlNVdGlsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVGVzdCBpZiBhbiBhcmd1bWVudCBpcyBhIHZhbGlkIEpTT04gb2JqZWN0LiBJZiBpdCBpcywgcmV0dXJucyBhIHRydXRoeVxuICAgKiB2YWx1ZSAodGhlIGpzb24gb2JqZWN0IGRlY29kZWQpLCBzbyBubyBkb3VibGUgSlNPTi5wYXJzZSBjYWxsIGlzIG5lY2Vzc2FyeVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnXG4gICAqIEByZXR1cm4ge09iamVjdHxib29sZWFufSBmYWxzZSBpZiB0aGUgYXJndW1lbnQgaXMgbm90IGEgSlNPTiBzdHJpbmcuXG4gICAqL1xuICBpc1ZhbGlkSlNPTjogZnVuY3Rpb24gaXNWYWxpZEpTT04oYXJnKSB7XG4gICAgdmFyIHBhcnNlZDtcbiAgICBpZiAoIV8uaXNTdHJpbmcoYXJnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShhcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZihwYXJzZWQpID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgaXNIZXhhOiBpc0hleGEsXG4gIGlzSGV4YVN0cmluZzogaXNIZXhhLFxuXG4gIC8qKlxuICAgKiBDbG9uZSBhbiBhcnJheVxuICAgKi9cbiAgY2xvbmVBcnJheTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGFycmF5KTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmaW5lIGltbXV0YWJsZSBwcm9wZXJ0aWVzIG9uIGEgdGFyZ2V0IG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gQW4gb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YXJnZXQgb2JqZWN0XG4gICAqL1xuICBkZWZpbmVJbW11dGFibGU6IGZ1bmN0aW9uIGRlZmluZUltbXV0YWJsZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZXNba2V5XVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgLyoqXG4gICAqIENoZWNrcyB0aGF0IGEgdmFsdWUgaXMgYSBuYXR1cmFsIG51bWJlciwgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8uXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzTmF0dXJhbE51bWJlcjogZnVuY3Rpb24gaXNOYXR1cmFsTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgIGlzRmluaXRlKHZhbHVlKSAmJlxuICAgICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlICYmXG4gICAgICB2YWx1ZSA+PSAwO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/util/js.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js":
/*!************************************************************!*\
  !*** ./node_modules/bitcore-lib/lib/util/preconditions.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/bitcore-lib/lib/errors/index.js\");\nvar _ = __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\");\n\nmodule.exports = {\n  checkState: function(condition, message) {\n    if (!condition) {\n      throw new errors.InvalidState(message);\n    }\n  },\n  checkArgument: function(condition, argumentName, message, docsPath) {\n    if (!condition) {\n      throw new errors.InvalidArgument(argumentName, message, docsPath);\n    }\n  },\n  checkArgumentType: function(argument, type, argumentName) {\n    argumentName = argumentName || '(unknown name)';\n    if (_.isString(type)) {\n      if (type === 'Buffer') {\n        var buffer = __webpack_require__(/*! buffer */ \"buffer\"); // './buffer' fails on cordova & RN\n        if (!buffer.Buffer.isBuffer(argument)) {\n          throw new errors.InvalidArgumentType(argument, type, argumentName);\n        }\n      } else if (typeof argument !== type && (argument && argument.constructor && argument.constructor.name !== type)) {\n        // Note that the constructor check is more reliable than the `instanceof` check below.\n        throw new errors.InvalidArgumentType(argument, type, argumentName);\n      }\n    } else {\n      if (!(argument instanceof type)) {\n        throw new errors.InvalidArgumentType(argument, type.name, argumentName);\n      }\n    }\n  },\n  isType: function(argument, type, argumentName) {\n    try {\n      this.checkArgumentType(argument, type, argumentName);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3V0aWwvcHJlY29uZGl0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsdUVBQVc7QUFDaEMsUUFBUSxtQkFBTyxDQUFDLHFEQUFROztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsc0JBQVEsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbGliL3V0aWwvcHJlY29uZGl0aW9ucy5qcz83NTg5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoZWNrU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRTdGF0ZShtZXNzYWdlKTtcbiAgICB9XG4gIH0sXG4gIGNoZWNrQXJndW1lbnQ6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYXJndW1lbnROYW1lLCBtZXNzYWdlLCBkb2NzUGF0aCkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudChhcmd1bWVudE5hbWUsIG1lc3NhZ2UsIGRvY3NQYXRoKTtcbiAgICB9XG4gIH0sXG4gIGNoZWNrQXJndW1lbnRUeXBlOiBmdW5jdGlvbihhcmd1bWVudCwgdHlwZSwgYXJndW1lbnROYW1lKSB7XG4gICAgYXJndW1lbnROYW1lID0gYXJndW1lbnROYW1lIHx8ICcodW5rbm93biBuYW1lKSc7XG4gICAgaWYgKF8uaXNTdHJpbmcodHlwZSkpIHtcbiAgICAgIGlmICh0eXBlID09PSAnQnVmZmVyJykge1xuICAgICAgICB2YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7IC8vICcuL2J1ZmZlcicgZmFpbHMgb24gY29yZG92YSAmIFJOXG4gICAgICAgIGlmICghYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihhcmd1bWVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudFR5cGUoYXJndW1lbnQsIHR5cGUsIGFyZ3VtZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50ICE9PSB0eXBlICYmIChhcmd1bWVudCAmJiBhcmd1bWVudC5jb25zdHJ1Y3RvciAmJiBhcmd1bWVudC5jb25zdHJ1Y3Rvci5uYW1lICE9PSB0eXBlKSkge1xuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGNvbnN0cnVjdG9yIGNoZWNrIGlzIG1vcmUgcmVsaWFibGUgdGhhbiB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJlbG93LlxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudFR5cGUoYXJndW1lbnQsIHR5cGUsIGFyZ3VtZW50TmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKGFyZ3VtZW50IGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnRUeXBlKGFyZ3VtZW50LCB0eXBlLm5hbWUsIGFyZ3VtZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpc1R5cGU6IGZ1bmN0aW9uKGFyZ3VtZW50LCB0eXBlLCBhcmd1bWVudE5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jaGVja0FyZ3VtZW50VHlwZShhcmd1bWVudCwgdHlwZSwgYXJndW1lbnROYW1lKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/lib/util/preconditions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js":
/*!********************************************************************!*\
  !*** ./node_modules/bitcore-lib/node_modules/inherits/inherits.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! util */ \"util\").inherits\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYml0Y29yZS1saWIvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlFQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2JpdGNvcmUtbGliL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0cy5qcz8zNjM2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bitcore-lib/node_modules/inherits/inherits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bitcore-lib/package.json":
/*!***********************************************!*\
  !*** ./node_modules/bitcore-lib/package.json ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"bitcore-lib","version":"10.10.5","description":"A pure and powerful JavaScript Bitcoin library.","author":"BitPay <dev@bitpay.com>","main":"index.js","scripts":{"test":"gulp test","test:ci":"npm run test","coverage":"gulp coverage","build":"gulp","pub":"npm run build && npm publish"},"keywords":["bitcoin","transaction","address","p2p","ecies","cryptocurrency","blockchain","payment","bip21","bip32","bip37","bip69","bip70","multisig"],"repository":{"type":"git","url":"https://github.com/bitpay/bitcore/tree/master/packages/bitcore-lib"},"browser":{"request":"browser-request"},"dependencies":{"bech32":"=2.0.0","bn.js":"=4.11.8","bs58":"^4.0.1","buffer-compare":"=1.1.1","elliptic":"^6.5.3","inherits":"=2.0.1","lodash":"^4.17.20"},"devDependencies":{"bitcore-build":"^10.10.5","brfs":"^2.0.1","chai":"^4.2.0","gulp":"^4.0.0","sinon":"^7.1.1"},"license":"MIT","gitHead":"7728de62626d3c53c89d09a04722e98d7e461b31"}');

/***/ })

};
;
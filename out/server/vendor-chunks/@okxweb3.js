/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = 'vendor-chunks/@okxweb3';
exports.ids = ['vendor-chunks/@okxweb3'];
exports.modules = {
  /***/ '(ssr)/./node_modules/@okxweb3/coin-base/dist/basic/ed25519.js':
    /*!***************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-base/dist/basic/ed25519.js ***!
  \***************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ed25519_getDerivedPrivateKey = exports.isValidPath = exports.ed25519_getRandomPrivateKey = exports.ed25519SignTest = void 0;\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nfunction ed25519SignTest(privateKey) {\n    const msgHash = crypto_lib_1.base.sha256("ed25519-test");\n    const publicKey = crypto_lib_1.signUtil.ed25519.publicKeyCreate(privateKey);\n    const signature = crypto_lib_1.signUtil.ed25519.sign(msgHash, privateKey);\n    return crypto_lib_1.signUtil.ed25519.verify(msgHash, signature, publicKey);\n}\nexports.ed25519SignTest = ed25519SignTest;\nfunction ed25519_getRandomPrivateKey(concatPub, encode) {\n    while (true) {\n        const randBytes = crypto_lib_1.base.randomBytes(32);\n        if (crypto_lib_1.signUtil.ed25519.privateKeyVerify(randBytes)) {\n            if (ed25519SignTest(randBytes)) {\n                const publicKey = crypto_lib_1.signUtil.ed25519.publicKeyCreate(randBytes);\n                const privateKey = concatPub ? crypto_lib_1.base.concatBytes(randBytes, publicKey) : randBytes;\n                return encode === "base58" ? crypto_lib_1.base.toBase58(privateKey) : crypto_lib_1.base.toHex(privateKey);\n            }\n        }\n    }\n}\nexports.ed25519_getRandomPrivateKey = ed25519_getRandomPrivateKey;\nconst pathRegex = new RegExp("^m(\\\\/[0-9]+\')+$");\nconst replaceDerive = (val) => val.replace("\'", \'\');\nconst HARDENED_OFFSET = 0x80000000;\nfunction getMasterKeyFromSeed(seed) {\n    const I = crypto_lib_1.base.hmacSHA512("ed25519 seed", seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n}\nfunction CKDPriv({ key, chainCode }, index) {\n    const indexBuffer = Buffer.allocUnsafe(4);\n    indexBuffer.writeUInt32BE(index, 0);\n    const data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);\n    const I = crypto_lib_1.base.hmacSHA512(chainCode, data);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n}\nconst isValidPath = (path) => {\n    if (!pathRegex.test(path)) {\n        return false;\n    }\n    return !path\n        .split(\'/\')\n        .slice(1)\n        .map(replaceDerive)\n        .some(isNaN);\n};\nexports.isValidPath = isValidPath;\nfunction derivePath(path, seed, offset = HARDENED_OFFSET) {\n    if (!(0, exports.isValidPath)(path)) {\n        throw new Error(\'Invalid derivation path\');\n    }\n    const { key, chainCode } = getMasterKeyFromSeed(seed);\n    const segments = path\n        .split(\'/\')\n        .slice(1)\n        .map(replaceDerive)\n        .map(el => parseInt(el, 10));\n    return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), { key, chainCode });\n}\nasync function ed25519_getDerivedPrivateKey(param, concatPub, encode) {\n    const seed = await crypto_lib_1.bip39.mnemonicToSeed(param.mnemonic);\n    const derivedSeed = derivePath(param.hdPath, seed).key;\n    const publicKey = crypto_lib_1.signUtil.ed25519.publicKeyCreate(derivedSeed);\n    const privateKey = concatPub ? crypto_lib_1.base.concatBytes(derivedSeed, publicKey) : derivedSeed;\n    return encode === \'base58\' ? Promise.resolve(crypto_lib_1.base.toBase58(privateKey)) : Promise.resolve(crypto_lib_1.base.toHex(privateKey));\n}\nexports.ed25519_getDerivedPrivateKey = ed25519_getDerivedPrivateKey;\n//# sourceMappingURL=ed25519.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvYmFzaWMvZWQyNTUxOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0MsR0FBRyxtQkFBbUIsR0FBRyxtQ0FBbUMsR0FBRyx1QkFBdUI7QUFDMUgscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGdCQUFnQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvYmFzaWMvZWQyNTUxOS5qcz80OGNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lZDI1NTE5X2dldERlcml2ZWRQcml2YXRlS2V5ID0gZXhwb3J0cy5pc1ZhbGlkUGF0aCA9IGV4cG9ydHMuZWQyNTUxOV9nZXRSYW5kb21Qcml2YXRlS2V5ID0gZXhwb3J0cy5lZDI1NTE5U2lnblRlc3QgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmZ1bmN0aW9uIGVkMjU1MTlTaWduVGVzdChwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGNyeXB0b19saWJfMS5iYXNlLnNoYTI1NihcImVkMjU1MTktdGVzdFwiKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG9fbGliXzEuc2lnblV0aWwuZWQyNTUxOS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gY3J5cHRvX2xpYl8xLnNpZ25VdGlsLmVkMjU1MTkuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gY3J5cHRvX2xpYl8xLnNpZ25VdGlsLmVkMjU1MTkudmVyaWZ5KG1zZ0hhc2gsIHNpZ25hdHVyZSwgcHVibGljS2V5KTtcbn1cbmV4cG9ydHMuZWQyNTUxOVNpZ25UZXN0ID0gZWQyNTUxOVNpZ25UZXN0O1xuZnVuY3Rpb24gZWQyNTUxOV9nZXRSYW5kb21Qcml2YXRlS2V5KGNvbmNhdFB1YiwgZW5jb2RlKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgcmFuZEJ5dGVzID0gY3J5cHRvX2xpYl8xLmJhc2UucmFuZG9tQnl0ZXMoMzIpO1xuICAgICAgICBpZiAoY3J5cHRvX2xpYl8xLnNpZ25VdGlsLmVkMjU1MTkucHJpdmF0ZUtleVZlcmlmeShyYW5kQnl0ZXMpKSB7XG4gICAgICAgICAgICBpZiAoZWQyNTUxOVNpZ25UZXN0KHJhbmRCeXRlcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG9fbGliXzEuc2lnblV0aWwuZWQyNTUxOS5wdWJsaWNLZXlDcmVhdGUocmFuZEJ5dGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gY29uY2F0UHViID8gY3J5cHRvX2xpYl8xLmJhc2UuY29uY2F0Qnl0ZXMocmFuZEJ5dGVzLCBwdWJsaWNLZXkpIDogcmFuZEJ5dGVzO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUgPT09IFwiYmFzZTU4XCIgPyBjcnlwdG9fbGliXzEuYmFzZS50b0Jhc2U1OChwcml2YXRlS2V5KSA6IGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5lZDI1NTE5X2dldFJhbmRvbVByaXZhdGVLZXkgPSBlZDI1NTE5X2dldFJhbmRvbVByaXZhdGVLZXk7XG5jb25zdCBwYXRoUmVnZXggPSBuZXcgUmVnRXhwKFwiXm0oXFxcXC9bMC05XSsnKSskXCIpO1xuY29uc3QgcmVwbGFjZURlcml2ZSA9ICh2YWwpID0+IHZhbC5yZXBsYWNlKFwiJ1wiLCAnJyk7XG5jb25zdCBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwO1xuZnVuY3Rpb24gZ2V0TWFzdGVyS2V5RnJvbVNlZWQoc2VlZCkge1xuICAgIGNvbnN0IEkgPSBjcnlwdG9fbGliXzEuYmFzZS5obWFjU0hBNTEyKFwiZWQyNTUxOSBzZWVkXCIsIHNlZWQpO1xuICAgIGNvbnN0IElMID0gSS5zbGljZSgwLCAzMik7XG4gICAgY29uc3QgSVIgPSBJLnNsaWNlKDMyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IElMLFxuICAgICAgICBjaGFpbkNvZGU6IElSLFxuICAgIH07XG59XG5mdW5jdGlvbiBDS0RQcml2KHsga2V5LCBjaGFpbkNvZGUgfSwgaW5kZXgpIHtcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KTtcbiAgICBpbmRleEJ1ZmZlci53cml0ZVVJbnQzMkJFKGluZGV4LCAwKTtcbiAgICBjb25zdCBkYXRhID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmFsbG9jKDEsIDApLCBrZXksIGluZGV4QnVmZmVyXSk7XG4gICAgY29uc3QgSSA9IGNyeXB0b19saWJfMS5iYXNlLmhtYWNTSEE1MTIoY2hhaW5Db2RlLCBkYXRhKTtcbiAgICBjb25zdCBJTCA9IEkuc2xpY2UoMCwgMzIpO1xuICAgIGNvbnN0IElSID0gSS5zbGljZSgzMik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBJTCxcbiAgICAgICAgY2hhaW5Db2RlOiBJUixcbiAgICB9O1xufVxuY29uc3QgaXNWYWxpZFBhdGggPSAocGF0aCkgPT4ge1xuICAgIGlmICghcGF0aFJlZ2V4LnRlc3QocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gIXBhdGhcbiAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5tYXAocmVwbGFjZURlcml2ZSlcbiAgICAgICAgLnNvbWUoaXNOYU4pO1xufTtcbmV4cG9ydHMuaXNWYWxpZFBhdGggPSBpc1ZhbGlkUGF0aDtcbmZ1bmN0aW9uIGRlcml2ZVBhdGgocGF0aCwgc2VlZCwgb2Zmc2V0ID0gSEFSREVORURfT0ZGU0VUKSB7XG4gICAgaWYgKCEoMCwgZXhwb3J0cy5pc1ZhbGlkUGF0aCkocGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRlcml2YXRpb24gcGF0aCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGtleSwgY2hhaW5Db2RlIH0gPSBnZXRNYXN0ZXJLZXlGcm9tU2VlZChzZWVkKTtcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGhcbiAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5tYXAocmVwbGFjZURlcml2ZSlcbiAgICAgICAgLm1hcChlbCA9PiBwYXJzZUludChlbCwgMTApKTtcbiAgICByZXR1cm4gc2VnbWVudHMucmVkdWNlKChwYXJlbnRLZXlzLCBzZWdtZW50KSA9PiBDS0RQcml2KHBhcmVudEtleXMsIHNlZ21lbnQgKyBvZmZzZXQpLCB7IGtleSwgY2hhaW5Db2RlIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZWQyNTUxOV9nZXREZXJpdmVkUHJpdmF0ZUtleShwYXJhbSwgY29uY2F0UHViLCBlbmNvZGUpIHtcbiAgICBjb25zdCBzZWVkID0gYXdhaXQgY3J5cHRvX2xpYl8xLmJpcDM5Lm1uZW1vbmljVG9TZWVkKHBhcmFtLm1uZW1vbmljKTtcbiAgICBjb25zdCBkZXJpdmVkU2VlZCA9IGRlcml2ZVBhdGgocGFyYW0uaGRQYXRoLCBzZWVkKS5rZXk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvX2xpYl8xLnNpZ25VdGlsLmVkMjU1MTkucHVibGljS2V5Q3JlYXRlKGRlcml2ZWRTZWVkKTtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gY29uY2F0UHViID8gY3J5cHRvX2xpYl8xLmJhc2UuY29uY2F0Qnl0ZXMoZGVyaXZlZFNlZWQsIHB1YmxpY0tleSkgOiBkZXJpdmVkU2VlZDtcbiAgICByZXR1cm4gZW5jb2RlID09PSAnYmFzZTU4JyA/IFByb21pc2UucmVzb2x2ZShjcnlwdG9fbGliXzEuYmFzZS50b0Jhc2U1OChwcml2YXRlS2V5KSkgOiBQcm9taXNlLnJlc29sdmUoY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgocHJpdmF0ZUtleSkpO1xufVxuZXhwb3J0cy5lZDI1NTE5X2dldERlcml2ZWRQcml2YXRlS2V5ID0gZWQyNTUxOV9nZXREZXJpdmVkUHJpdmF0ZUtleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkMjU1MTkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-base/dist/basic/ed25519.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-base/dist/basic/index.js':
    /*!*************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-base/dist/basic/index.js ***!
  \*************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./ed25519 */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/basic/ed25519.js"), exports);\n__exportStar(__webpack_require__(/*! ./typeUtils */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/basic/typeUtils.js"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvYmFzaWMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLGdGQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxvRkFBYTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYmFzZS9kaXN0L2Jhc2ljL2luZGV4LmpzP2I1NGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lZDI1NTE5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlVXRpbHNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-base/dist/basic/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-base/dist/basic/typeUtils.js':
    /*!*****************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-base/dist/basic/typeUtils.js ***!
  \*****************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.jsonStringifyUniform = exports.cloneObject = exports.assertBufferLength = exports.convert2BigNumber = exports.convert2Number = void 0;\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nfunction convert2Number(data) {\n    if (data == undefined) {\n        return undefined;\n    }\n    if (typeof data === "string") {\n        return parseInt(data);\n    }\n    return data;\n}\nexports.convert2Number = convert2Number;\nfunction convert2BigNumber(data) {\n    if (data == undefined) {\n        return undefined;\n    }\n    if (crypto_lib_1.BigNumber.isBigNumber(data)) {\n        return data;\n    }\n    return new crypto_lib_1.BigNumber(data);\n}\nexports.convert2BigNumber = convert2BigNumber;\nfunction assertBufferLength(data, length) {\n    if (data.length != length) {\n        throw Error("buffer length is illegal");\n    }\n}\nexports.assertBufferLength = assertBufferLength;\nfunction cloneObject(data) {\n    return JSON.parse(JSON.stringify(data));\n}\nexports.cloneObject = cloneObject;\nfunction jsonStringifyUniform(data) {\n    return JSON.stringify(data, (key, value) => {\n        if (!value) {\n            return value;\n        }\n        if (value.type === "Buffer") {\n            return crypto_lib_1.base.toHex(value);\n        }\n        else if (value instanceof Uint8Array) {\n            return crypto_lib_1.base.toHex(value);\n        }\n        else if (typeof value === \'bigint\') {\n            return value.toString();\n        }\n        else {\n            return value;\n        }\n    });\n}\nexports.jsonStringifyUniform = jsonStringifyUniform;\n//# sourceMappingURL=typeUtils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvYmFzaWMvdHlwZVV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQjtBQUNwSSxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvYmFzaWMvdHlwZVV0aWxzLmpzPzlmNzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmpzb25TdHJpbmdpZnlVbmlmb3JtID0gZXhwb3J0cy5jbG9uZU9iamVjdCA9IGV4cG9ydHMuYXNzZXJ0QnVmZmVyTGVuZ3RoID0gZXhwb3J0cy5jb252ZXJ0MkJpZ051bWJlciA9IGV4cG9ydHMuY29udmVydDJOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmZ1bmN0aW9uIGNvbnZlcnQyTnVtYmVyKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLmNvbnZlcnQyTnVtYmVyID0gY29udmVydDJOdW1iZXI7XG5mdW5jdGlvbiBjb252ZXJ0MkJpZ051bWJlcihkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChjcnlwdG9fbGliXzEuQmlnTnVtYmVyLmlzQmlnTnVtYmVyKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGNyeXB0b19saWJfMS5CaWdOdW1iZXIoZGF0YSk7XG59XG5leHBvcnRzLmNvbnZlcnQyQmlnTnVtYmVyID0gY29udmVydDJCaWdOdW1iZXI7XG5mdW5jdGlvbiBhc3NlcnRCdWZmZXJMZW5ndGgoZGF0YSwgbGVuZ3RoKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoICE9IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcImJ1ZmZlciBsZW5ndGggaXMgaWxsZWdhbFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydEJ1ZmZlckxlbmd0aCA9IGFzc2VydEJ1ZmZlckxlbmd0aDtcbmZ1bmN0aW9uIGNsb25lT2JqZWN0KGRhdGEpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59XG5leHBvcnRzLmNsb25lT2JqZWN0ID0gY2xvbmVPYmplY3Q7XG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5VW5pZm9ybShkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJCdWZmZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS50b0hleCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuanNvblN0cmluZ2lmeVVuaWZvcm0gPSBqc29uU3RyaW5naWZ5VW5pZm9ybTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVVdGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-base/dist/basic/typeUtils.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-base/dist/common.js':
    /*!********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-base/dist/common.js ***!
  \********************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvY29tbW9uLmpzPzEzNWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-base/dist/common.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-base/dist/currency.js':
    /*!**********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-base/dist/currency.js ***!
  \**********************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CoinCurveMap = exports.MultiAddressCoins = exports.segwitType = exports.Currency = void 0;\nvar Currency;\n(function (Currency) {\n    Currency[Currency["NULL"] = -1] = "NULL";\n    Currency[Currency["BTC"] = 0] = "BTC";\n    Currency[Currency["TBTC"] = 1] = "TBTC";\n    Currency[Currency["ETH"] = 60] = "ETH";\n    Currency[Currency["LTC"] = 2] = "LTC";\n    Currency[Currency["DOGE"] = 3] = "DOGE";\n    Currency[Currency["BCH"] = 145] = "BCH";\n    Currency[Currency["BSV"] = 236] = "BSV";\n    Currency[Currency["TRX"] = 195] = "TRX";\n    Currency[Currency["SOL"] = 501] = "SOL";\n    Currency[Currency["APTOS"] = 637] = "APTOS";\n    Currency[Currency["OMNI_USDT"] = 20001] = "OMNI_USDT";\n    Currency[Currency["OMNI_USDT_TEST"] = 20002] = "OMNI_USDT_TEST";\n    Currency[Currency["SUI"] = 784] = "SUI";\n    Currency[Currency["ATOM"] = 118] = "ATOM";\n    Currency[Currency["OSMO"] = 1000] = "OSMO";\n    Currency[Currency["EVMOS"] = 1001] = "EVMOS";\n    Currency[Currency["AXL"] = 1002] = "AXL";\n    Currency[Currency["CRO"] = 1003] = "CRO";\n    Currency[Currency["Iris"] = 1004] = "Iris";\n    Currency[Currency["Juno"] = 1005] = "Juno";\n    Currency[Currency["Kava"] = 1006] = "Kava";\n    Currency[Currency["Kujira"] = 1007] = "Kujira";\n    Currency[Currency["SCRT"] = 1008] = "SCRT";\n    Currency[Currency["Stargaze"] = 1009] = "Stargaze";\n    Currency[Currency["Terra"] = 1010] = "Terra";\n    Currency[Currency["ZKSPACE"] = 1011] = "ZKSPACE";\n    Currency[Currency["ZKSYNC"] = 804] = "ZKSYNC";\n    Currency[Currency["Stx"] = 5757] = "Stx";\n    Currency[Currency["SEI"] = 2837] = "SEI";\n    Currency[Currency["WAX"] = 14001] = "WAX";\n    Currency[Currency["Starknet"] = 9004] = "Starknet";\n    Currency[Currency["ADA"] = 1815] = "ADA";\n    Currency[Currency["INJ"] = 2892] = "INJ";\n    Currency[Currency["Celestia"] = 2854] = "Celestia";\n    Currency[Currency["DYDX"] = 2897] = "DYDX";\n    Currency[Currency["Kaspa"] = 111111] = "Kaspa";\n    Currency[Currency["TON"] = 607] = "TON";\n    Currency[Currency["NostrAssets"] = 1237] = "NostrAssets";\n    Currency[Currency["Near"] = 397] = "Near";\n})(Currency = exports.Currency || (exports.Currency = {}));\nvar segwitType;\n(function (segwitType) {\n    segwitType[segwitType["SEGWIT_NESTED"] = 1] = "SEGWIT_NESTED";\n    segwitType[segwitType["SEGWIT_NESTED_49"] = 2] = "SEGWIT_NESTED_49";\n    segwitType[segwitType["SEGWIT_NATIVE"] = 3] = "SEGWIT_NATIVE";\n    segwitType[segwitType["SEGWIT_TAPROOT"] = 4] = "SEGWIT_TAPROOT";\n})(segwitType = exports.segwitType || (exports.segwitType = {}));\nexports.MultiAddressCoins = [\n    Currency.BTC, Currency.TBTC, Currency.LTC, Currency.DOGE, Currency.BSV, Currency.OMNI_USDT, Currency.OMNI_USDT_TEST\n];\nconst secp256k1 = "secp256k1";\nconst ed25519 = "ed25519";\nexports.CoinCurveMap = new Map([\n    [Currency.BTC, secp256k1],\n    [Currency.TBTC, secp256k1],\n    [Currency.ETH, secp256k1],\n    [Currency.LTC, secp256k1],\n    [Currency.DOGE, secp256k1],\n    [Currency.BCH, secp256k1],\n    [Currency.BSV, secp256k1],\n    [Currency.TRX, secp256k1],\n    [Currency.OMNI_USDT, secp256k1],\n    [Currency.OMNI_USDT_TEST, secp256k1],\n    [Currency.ATOM, secp256k1],\n    [Currency.OSMO, secp256k1],\n    [Currency.EVMOS, secp256k1],\n    [Currency.AXL, secp256k1],\n    [Currency.CRO, secp256k1],\n    [Currency.Iris, secp256k1],\n    [Currency.Juno, secp256k1],\n    [Currency.Kava, secp256k1],\n    [Currency.Kujira, secp256k1],\n    [Currency.SCRT, secp256k1],\n    [Currency.Stargaze, secp256k1],\n    [Currency.Terra, secp256k1],\n    [Currency.SEI, secp256k1],\n    [Currency.Celestia, secp256k1],\n    [Currency.DYDX, secp256k1],\n    [Currency.SOL, ed25519],\n    [Currency.APTOS, ed25519],\n    [Currency.SUI, ed25519],\n    [Currency.TON, ed25519],\n]);\n//# sourceMappingURL=currency.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvY3VycmVuY3kuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcseUJBQXlCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDLGdCQUFnQixLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDLGtCQUFrQixLQUFLO0FBQzlELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYmFzZS9kaXN0L2N1cnJlbmN5LmpzP2VlNzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvaW5DdXJ2ZU1hcCA9IGV4cG9ydHMuTXVsdGlBZGRyZXNzQ29pbnMgPSBleHBvcnRzLnNlZ3dpdFR5cGUgPSBleHBvcnRzLkN1cnJlbmN5ID0gdm9pZCAwO1xudmFyIEN1cnJlbmN5O1xuKGZ1bmN0aW9uIChDdXJyZW5jeSkge1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiTlVMTFwiXSA9IC0xXSA9IFwiTlVMTFwiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiQlRDXCJdID0gMF0gPSBcIkJUQ1wiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiVEJUQ1wiXSA9IDFdID0gXCJUQlRDXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJFVEhcIl0gPSA2MF0gPSBcIkVUSFwiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiTFRDXCJdID0gMl0gPSBcIkxUQ1wiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiRE9HRVwiXSA9IDNdID0gXCJET0dFXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJCQ0hcIl0gPSAxNDVdID0gXCJCQ0hcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIkJTVlwiXSA9IDIzNl0gPSBcIkJTVlwiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiVFJYXCJdID0gMTk1XSA9IFwiVFJYXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJTT0xcIl0gPSA1MDFdID0gXCJTT0xcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIkFQVE9TXCJdID0gNjM3XSA9IFwiQVBUT1NcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIk9NTklfVVNEVFwiXSA9IDIwMDAxXSA9IFwiT01OSV9VU0RUXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJPTU5JX1VTRFRfVEVTVFwiXSA9IDIwMDAyXSA9IFwiT01OSV9VU0RUX1RFU1RcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIlNVSVwiXSA9IDc4NF0gPSBcIlNVSVwiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiQVRPTVwiXSA9IDExOF0gPSBcIkFUT01cIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIk9TTU9cIl0gPSAxMDAwXSA9IFwiT1NNT1wiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiRVZNT1NcIl0gPSAxMDAxXSA9IFwiRVZNT1NcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIkFYTFwiXSA9IDEwMDJdID0gXCJBWExcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIkNST1wiXSA9IDEwMDNdID0gXCJDUk9cIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIklyaXNcIl0gPSAxMDA0XSA9IFwiSXJpc1wiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiSnVub1wiXSA9IDEwMDVdID0gXCJKdW5vXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJLYXZhXCJdID0gMTAwNl0gPSBcIkthdmFcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIkt1amlyYVwiXSA9IDEwMDddID0gXCJLdWppcmFcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIlNDUlRcIl0gPSAxMDA4XSA9IFwiU0NSVFwiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiU3RhcmdhemVcIl0gPSAxMDA5XSA9IFwiU3RhcmdhemVcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIlRlcnJhXCJdID0gMTAxMF0gPSBcIlRlcnJhXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJaS1NQQUNFXCJdID0gMTAxMV0gPSBcIlpLU1BBQ0VcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIlpLU1lOQ1wiXSA9IDgwNF0gPSBcIlpLU1lOQ1wiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiU3R4XCJdID0gNTc1N10gPSBcIlN0eFwiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiU0VJXCJdID0gMjgzN10gPSBcIlNFSVwiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiV0FYXCJdID0gMTQwMDFdID0gXCJXQVhcIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIlN0YXJrbmV0XCJdID0gOTAwNF0gPSBcIlN0YXJrbmV0XCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJBREFcIl0gPSAxODE1XSA9IFwiQURBXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJJTkpcIl0gPSAyODkyXSA9IFwiSU5KXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJDZWxlc3RpYVwiXSA9IDI4NTRdID0gXCJDZWxlc3RpYVwiO1xuICAgIEN1cnJlbmN5W0N1cnJlbmN5W1wiRFlEWFwiXSA9IDI4OTddID0gXCJEWURYXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJLYXNwYVwiXSA9IDExMTExMV0gPSBcIkthc3BhXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJUT05cIl0gPSA2MDddID0gXCJUT05cIjtcbiAgICBDdXJyZW5jeVtDdXJyZW5jeVtcIk5vc3RyQXNzZXRzXCJdID0gMTIzN10gPSBcIk5vc3RyQXNzZXRzXCI7XG4gICAgQ3VycmVuY3lbQ3VycmVuY3lbXCJOZWFyXCJdID0gMzk3XSA9IFwiTmVhclwiO1xufSkoQ3VycmVuY3kgPSBleHBvcnRzLkN1cnJlbmN5IHx8IChleHBvcnRzLkN1cnJlbmN5ID0ge30pKTtcbnZhciBzZWd3aXRUeXBlO1xuKGZ1bmN0aW9uIChzZWd3aXRUeXBlKSB7XG4gICAgc2Vnd2l0VHlwZVtzZWd3aXRUeXBlW1wiU0VHV0lUX05FU1RFRFwiXSA9IDFdID0gXCJTRUdXSVRfTkVTVEVEXCI7XG4gICAgc2Vnd2l0VHlwZVtzZWd3aXRUeXBlW1wiU0VHV0lUX05FU1RFRF80OVwiXSA9IDJdID0gXCJTRUdXSVRfTkVTVEVEXzQ5XCI7XG4gICAgc2Vnd2l0VHlwZVtzZWd3aXRUeXBlW1wiU0VHV0lUX05BVElWRVwiXSA9IDNdID0gXCJTRUdXSVRfTkFUSVZFXCI7XG4gICAgc2Vnd2l0VHlwZVtzZWd3aXRUeXBlW1wiU0VHV0lUX1RBUFJPT1RcIl0gPSA0XSA9IFwiU0VHV0lUX1RBUFJPT1RcIjtcbn0pKHNlZ3dpdFR5cGUgPSBleHBvcnRzLnNlZ3dpdFR5cGUgfHwgKGV4cG9ydHMuc2Vnd2l0VHlwZSA9IHt9KSk7XG5leHBvcnRzLk11bHRpQWRkcmVzc0NvaW5zID0gW1xuICAgIEN1cnJlbmN5LkJUQywgQ3VycmVuY3kuVEJUQywgQ3VycmVuY3kuTFRDLCBDdXJyZW5jeS5ET0dFLCBDdXJyZW5jeS5CU1YsIEN1cnJlbmN5Lk9NTklfVVNEVCwgQ3VycmVuY3kuT01OSV9VU0RUX1RFU1Rcbl07XG5jb25zdCBzZWNwMjU2azEgPSBcInNlY3AyNTZrMVwiO1xuY29uc3QgZWQyNTUxOSA9IFwiZWQyNTUxOVwiO1xuZXhwb3J0cy5Db2luQ3VydmVNYXAgPSBuZXcgTWFwKFtcbiAgICBbQ3VycmVuY3kuQlRDLCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5UQlRDLCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5FVEgsIHNlY3AyNTZrMV0sXG4gICAgW0N1cnJlbmN5LkxUQywgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuRE9HRSwgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuQkNILCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5CU1YsIHNlY3AyNTZrMV0sXG4gICAgW0N1cnJlbmN5LlRSWCwgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuT01OSV9VU0RULCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5PTU5JX1VTRFRfVEVTVCwgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuQVRPTSwgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuT1NNTywgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuRVZNT1MsIHNlY3AyNTZrMV0sXG4gICAgW0N1cnJlbmN5LkFYTCwgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuQ1JPLCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5JcmlzLCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5KdW5vLCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5LYXZhLCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5LdWppcmEsIHNlY3AyNTZrMV0sXG4gICAgW0N1cnJlbmN5LlNDUlQsIHNlY3AyNTZrMV0sXG4gICAgW0N1cnJlbmN5LlN0YXJnYXplLCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5UZXJyYSwgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuU0VJLCBzZWNwMjU2azFdLFxuICAgIFtDdXJyZW5jeS5DZWxlc3RpYSwgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuRFlEWCwgc2VjcDI1NmsxXSxcbiAgICBbQ3VycmVuY3kuU09MLCBlZDI1NTE5XSxcbiAgICBbQ3VycmVuY3kuQVBUT1MsIGVkMjU1MTldLFxuICAgIFtDdXJyZW5jeS5TVUksIGVkMjU1MTldLFxuICAgIFtDdXJyZW5jeS5UT04sIGVkMjU1MTldLFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJyZW5jeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-base/dist/currency.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-base/dist/error.js':
    /*!*******************************************************!*\
  !*** ./node_modules/@okxweb3/coin-base/dist/error.js ***!
  \*******************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.EstimateFeeError = exports.validSignedTransactionError = exports.GetPayLoadError = exports.HardwareDerivePubKeyError = exports.CalcTxHashError = exports.SignMsgStep3Error = exports.SignMsgSetupError = exports.Ed25519Step3Error = exports.Ed25519Step2Error = exports.Ed25519Step1Error = exports.Ed25519SetupError = exports.EcdsaStep3Error = exports.EcdsaStep2Error = exports.EcdsaStep1Error = exports.EcdsaSetupError = exports.MPCShakeHandsError = exports.MPCStepError = exports.MPCAesKeyMissError = exports.GetHardWareMessageHashError = exports.GetHardwareSignedTransactionError = exports.GetHardwareRawTransactionError = exports.GetMpcTransactionError = exports.GetMpcRawTransactionError = exports.DerivePathError = exports.GenMnemonicError = exports.GenPrivateKeyError = exports.UnsupportedCoinError = exports.SignMsgError = exports.SignTxError = exports.ValidAddressError = exports.NewAddressError = exports.NotImplementedError = void 0;\nexports.NotImplementedError = "no implementation method";\nexports.NewAddressError = "generate address error";\nexports.ValidAddressError = "valid address error";\nexports.SignTxError = "sign tx error";\nexports.SignMsgError = "sign message error";\nexports.UnsupportedCoinError = "unsupported currency";\nexports.GenPrivateKeyError = "generate private key error";\nexports.GenMnemonicError = "generate mnemonic error";\nexports.DerivePathError = "derive hdPath error";\nexports.GetMpcRawTransactionError = "get mpc raw transaction error";\nexports.GetMpcTransactionError = "get mpc transaction error";\nexports.GetHardwareRawTransactionError = "get hardware raw transaction error";\nexports.GetHardwareSignedTransactionError = "get hardware signed transaction error";\nexports.GetHardWareMessageHashError = "get hardware message hash error";\nexports.MPCAesKeyMissError = "mpc get aes key error";\nexports.MPCStepError = "mpc step error";\nexports.MPCShakeHandsError = \'mpc shake hands error\';\nexports.EcdsaSetupError = \'ecdsa setup error\';\nexports.EcdsaStep1Error = \'ecdsa step1 error\';\nexports.EcdsaStep2Error = \'ecdsa step2 error\';\nexports.EcdsaStep3Error = \'ecdsa step3 error\';\nexports.Ed25519SetupError = \'ed25519 setup error\';\nexports.Ed25519Step1Error = \'ed25519 step1 error\';\nexports.Ed25519Step2Error = \'ed25519 step2 error\';\nexports.Ed25519Step3Error = \'ed25519 step3 error\';\nexports.SignMsgSetupError = \'sign message setup error\';\nexports.SignMsgStep3Error = \'sign message step3 error\';\nexports.CalcTxHashError = "calculate tx hash error";\nexports.HardwareDerivePubKeyError = "derive sub pub key error";\nexports.GetPayLoadError = "get payload error";\nexports.validSignedTransactionError = "valid signed transaction error";\nexports.EstimateFeeError = "estimate fee error";\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQUcsdUJBQXVCLEdBQUcsaUNBQWlDLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsMEJBQTBCLEdBQUcsb0JBQW9CLEdBQUcsMEJBQTBCLEdBQUcsbUNBQW1DLEdBQUcseUNBQXlDLEdBQUcsc0NBQXNDLEdBQUcsOEJBQThCLEdBQUcsaUNBQWlDLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsMEJBQTBCLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCLEdBQUcsMkJBQTJCO0FBQ3o2QiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsbUNBQW1DO0FBQ25DLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsaUNBQWlDO0FBQ2pDLHVCQUF1QjtBQUN2QixtQ0FBbUM7QUFDbkMsd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvZXJyb3IuanM/ODhhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXN0aW1hdGVGZWVFcnJvciA9IGV4cG9ydHMudmFsaWRTaWduZWRUcmFuc2FjdGlvbkVycm9yID0gZXhwb3J0cy5HZXRQYXlMb2FkRXJyb3IgPSBleHBvcnRzLkhhcmR3YXJlRGVyaXZlUHViS2V5RXJyb3IgPSBleHBvcnRzLkNhbGNUeEhhc2hFcnJvciA9IGV4cG9ydHMuU2lnbk1zZ1N0ZXAzRXJyb3IgPSBleHBvcnRzLlNpZ25Nc2dTZXR1cEVycm9yID0gZXhwb3J0cy5FZDI1NTE5U3RlcDNFcnJvciA9IGV4cG9ydHMuRWQyNTUxOVN0ZXAyRXJyb3IgPSBleHBvcnRzLkVkMjU1MTlTdGVwMUVycm9yID0gZXhwb3J0cy5FZDI1NTE5U2V0dXBFcnJvciA9IGV4cG9ydHMuRWNkc2FTdGVwM0Vycm9yID0gZXhwb3J0cy5FY2RzYVN0ZXAyRXJyb3IgPSBleHBvcnRzLkVjZHNhU3RlcDFFcnJvciA9IGV4cG9ydHMuRWNkc2FTZXR1cEVycm9yID0gZXhwb3J0cy5NUENTaGFrZUhhbmRzRXJyb3IgPSBleHBvcnRzLk1QQ1N0ZXBFcnJvciA9IGV4cG9ydHMuTVBDQWVzS2V5TWlzc0Vycm9yID0gZXhwb3J0cy5HZXRIYXJkV2FyZU1lc3NhZ2VIYXNoRXJyb3IgPSBleHBvcnRzLkdldEhhcmR3YXJlU2lnbmVkVHJhbnNhY3Rpb25FcnJvciA9IGV4cG9ydHMuR2V0SGFyZHdhcmVSYXdUcmFuc2FjdGlvbkVycm9yID0gZXhwb3J0cy5HZXRNcGNUcmFuc2FjdGlvbkVycm9yID0gZXhwb3J0cy5HZXRNcGNSYXdUcmFuc2FjdGlvbkVycm9yID0gZXhwb3J0cy5EZXJpdmVQYXRoRXJyb3IgPSBleHBvcnRzLkdlbk1uZW1vbmljRXJyb3IgPSBleHBvcnRzLkdlblByaXZhdGVLZXlFcnJvciA9IGV4cG9ydHMuVW5zdXBwb3J0ZWRDb2luRXJyb3IgPSBleHBvcnRzLlNpZ25Nc2dFcnJvciA9IGV4cG9ydHMuU2lnblR4RXJyb3IgPSBleHBvcnRzLlZhbGlkQWRkcmVzc0Vycm9yID0gZXhwb3J0cy5OZXdBZGRyZXNzRXJyb3IgPSBleHBvcnRzLk5vdEltcGxlbWVudGVkRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLk5vdEltcGxlbWVudGVkRXJyb3IgPSBcIm5vIGltcGxlbWVudGF0aW9uIG1ldGhvZFwiO1xuZXhwb3J0cy5OZXdBZGRyZXNzRXJyb3IgPSBcImdlbmVyYXRlIGFkZHJlc3MgZXJyb3JcIjtcbmV4cG9ydHMuVmFsaWRBZGRyZXNzRXJyb3IgPSBcInZhbGlkIGFkZHJlc3MgZXJyb3JcIjtcbmV4cG9ydHMuU2lnblR4RXJyb3IgPSBcInNpZ24gdHggZXJyb3JcIjtcbmV4cG9ydHMuU2lnbk1zZ0Vycm9yID0gXCJzaWduIG1lc3NhZ2UgZXJyb3JcIjtcbmV4cG9ydHMuVW5zdXBwb3J0ZWRDb2luRXJyb3IgPSBcInVuc3VwcG9ydGVkIGN1cnJlbmN5XCI7XG5leHBvcnRzLkdlblByaXZhdGVLZXlFcnJvciA9IFwiZ2VuZXJhdGUgcHJpdmF0ZSBrZXkgZXJyb3JcIjtcbmV4cG9ydHMuR2VuTW5lbW9uaWNFcnJvciA9IFwiZ2VuZXJhdGUgbW5lbW9uaWMgZXJyb3JcIjtcbmV4cG9ydHMuRGVyaXZlUGF0aEVycm9yID0gXCJkZXJpdmUgaGRQYXRoIGVycm9yXCI7XG5leHBvcnRzLkdldE1wY1Jhd1RyYW5zYWN0aW9uRXJyb3IgPSBcImdldCBtcGMgcmF3IHRyYW5zYWN0aW9uIGVycm9yXCI7XG5leHBvcnRzLkdldE1wY1RyYW5zYWN0aW9uRXJyb3IgPSBcImdldCBtcGMgdHJhbnNhY3Rpb24gZXJyb3JcIjtcbmV4cG9ydHMuR2V0SGFyZHdhcmVSYXdUcmFuc2FjdGlvbkVycm9yID0gXCJnZXQgaGFyZHdhcmUgcmF3IHRyYW5zYWN0aW9uIGVycm9yXCI7XG5leHBvcnRzLkdldEhhcmR3YXJlU2lnbmVkVHJhbnNhY3Rpb25FcnJvciA9IFwiZ2V0IGhhcmR3YXJlIHNpZ25lZCB0cmFuc2FjdGlvbiBlcnJvclwiO1xuZXhwb3J0cy5HZXRIYXJkV2FyZU1lc3NhZ2VIYXNoRXJyb3IgPSBcImdldCBoYXJkd2FyZSBtZXNzYWdlIGhhc2ggZXJyb3JcIjtcbmV4cG9ydHMuTVBDQWVzS2V5TWlzc0Vycm9yID0gXCJtcGMgZ2V0IGFlcyBrZXkgZXJyb3JcIjtcbmV4cG9ydHMuTVBDU3RlcEVycm9yID0gXCJtcGMgc3RlcCBlcnJvclwiO1xuZXhwb3J0cy5NUENTaGFrZUhhbmRzRXJyb3IgPSAnbXBjIHNoYWtlIGhhbmRzIGVycm9yJztcbmV4cG9ydHMuRWNkc2FTZXR1cEVycm9yID0gJ2VjZHNhIHNldHVwIGVycm9yJztcbmV4cG9ydHMuRWNkc2FTdGVwMUVycm9yID0gJ2VjZHNhIHN0ZXAxIGVycm9yJztcbmV4cG9ydHMuRWNkc2FTdGVwMkVycm9yID0gJ2VjZHNhIHN0ZXAyIGVycm9yJztcbmV4cG9ydHMuRWNkc2FTdGVwM0Vycm9yID0gJ2VjZHNhIHN0ZXAzIGVycm9yJztcbmV4cG9ydHMuRWQyNTUxOVNldHVwRXJyb3IgPSAnZWQyNTUxOSBzZXR1cCBlcnJvcic7XG5leHBvcnRzLkVkMjU1MTlTdGVwMUVycm9yID0gJ2VkMjU1MTkgc3RlcDEgZXJyb3InO1xuZXhwb3J0cy5FZDI1NTE5U3RlcDJFcnJvciA9ICdlZDI1NTE5IHN0ZXAyIGVycm9yJztcbmV4cG9ydHMuRWQyNTUxOVN0ZXAzRXJyb3IgPSAnZWQyNTUxOSBzdGVwMyBlcnJvcic7XG5leHBvcnRzLlNpZ25Nc2dTZXR1cEVycm9yID0gJ3NpZ24gbWVzc2FnZSBzZXR1cCBlcnJvcic7XG5leHBvcnRzLlNpZ25Nc2dTdGVwM0Vycm9yID0gJ3NpZ24gbWVzc2FnZSBzdGVwMyBlcnJvcic7XG5leHBvcnRzLkNhbGNUeEhhc2hFcnJvciA9IFwiY2FsY3VsYXRlIHR4IGhhc2ggZXJyb3JcIjtcbmV4cG9ydHMuSGFyZHdhcmVEZXJpdmVQdWJLZXlFcnJvciA9IFwiZGVyaXZlIHN1YiBwdWIga2V5IGVycm9yXCI7XG5leHBvcnRzLkdldFBheUxvYWRFcnJvciA9IFwiZ2V0IHBheWxvYWQgZXJyb3JcIjtcbmV4cG9ydHMudmFsaWRTaWduZWRUcmFuc2FjdGlvbkVycm9yID0gXCJ2YWxpZCBzaWduZWQgdHJhbnNhY3Rpb24gZXJyb3JcIjtcbmV4cG9ydHMuRXN0aW1hdGVGZWVFcnJvciA9IFwiZXN0aW1hdGUgZmVlIGVycm9yXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-base/dist/error.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js':
    /*!*******************************************************!*\
  !*** ./node_modules/@okxweb3/coin-base/dist/index.js ***!
  \*******************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./common */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/common.js"), exports);\n__exportStar(__webpack_require__(/*! ./currency */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/currency.js"), exports);\n__exportStar(__webpack_require__(/*! ./error */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/error.js"), exports);\n__exportStar(__webpack_require__(/*! ./wallet */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/wallet.js"), exports);\n__exportStar(__webpack_require__(/*! ./basic */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/basic/index.js"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHdFQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyw0RUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsc0VBQVM7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLHdFQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyw0RUFBUztBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYmFzZS9kaXN0L2luZGV4LmpzPzBiMTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21tb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2N1cnJlbmN5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2FsbGV0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNpY1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-base/dist/wallet.js':
    /*!********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-base/dist/wallet.js ***!
  \********************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BaseWallet = exports.secp256k1SignTest = void 0;\nconst error_1 = __webpack_require__(/*! ./error */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/error.js");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nfunction secp256k1SignTest(privateKey) {\n    const msgHash = crypto_lib_1.base.sha256("secp256k1-test");\n    const publicKey = crypto_lib_1.signUtil.secp256k1.publicKeyCreate(privateKey, false);\n    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(msgHash), privateKey);\n    return crypto_lib_1.signUtil.secp256k1.verify(msgHash, signature, recovery, publicKey);\n}\nexports.secp256k1SignTest = secp256k1SignTest;\nclass BaseWallet {\n    getRandomPrivateKey() {\n        try {\n            while (true) {\n                const privateKey = crypto_lib_1.base.randomBytes(32);\n                if (secp256k1SignTest(privateKey)) {\n                    return Promise.resolve(crypto_lib_1.base.toHex(privateKey, true));\n                }\n            }\n        }\n        catch (e) {\n        }\n        return Promise.reject(error_1.GenPrivateKeyError);\n    }\n    getDerivedPrivateKey(param) {\n        return crypto_lib_1.bip39.mnemonicToSeed(param.mnemonic)\n            .then((masterSeed) => {\n            let childKey = crypto_lib_1.bip32.fromSeed(masterSeed).derivePath(param.hdPath);\n            if (childKey.privateKey) {\n                let privateKey = crypto_lib_1.base.toHex(childKey.privateKey);\n                return Promise.resolve("0x" + privateKey);\n            }\n            else {\n                return Promise.reject(error_1.GenPrivateKeyError);\n            }\n        }).catch((e) => {\n            return Promise.reject(error_1.GenPrivateKeyError);\n        });\n    }\n    getDerivedPath(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    validPrivateKey(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    signMessage(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    verifyMessage(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    ecRecover(message, signature) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    getAddressByPublicKey(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    getMPCRawTransaction(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    getMPCTransaction(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    getMPCRawMessage(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    getMPCSignedMessage(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    getHardWareRawTransaction(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    getHardWareSignedTransaction(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    getHardWareMessageHash(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    calcTxHash(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    getRawTransaction(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    validSignedTransaction(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n    estimateFee(param) {\n        return Promise.reject(error_1.NotImplementedError);\n    }\n}\nexports.BaseWallet = BaseWallet;\n//# sourceMappingURL=wallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3Qvd2FsbGV0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHlCQUF5QjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBUztBQUNqQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iYXNlL2Rpc3Qvd2FsbGV0LmpzPzNiMDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VXYWxsZXQgPSBleHBvcnRzLnNlY3AyNTZrMVNpZ25UZXN0ID0gdm9pZCAwO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuY29uc3QgY3J5cHRvX2xpYl8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NyeXB0by1saWJcIik7XG5mdW5jdGlvbiBzZWNwMjU2azFTaWduVGVzdChwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGNyeXB0b19saWJfMS5iYXNlLnNoYTI1NihcInNlY3AyNTZrMS10ZXN0XCIpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGNyeXB0b19saWJfMS5zaWduVXRpbC5zZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlKTtcbiAgICBjb25zdCB7IHNpZ25hdHVyZSwgcmVjb3ZlcnkgfSA9IGNyeXB0b19saWJfMS5zaWduVXRpbC5zZWNwMjU2azEuc2lnbihCdWZmZXIuZnJvbShtc2dIYXNoKSwgcHJpdmF0ZUtleSk7XG4gICAgcmV0dXJuIGNyeXB0b19saWJfMS5zaWduVXRpbC5zZWNwMjU2azEudmVyaWZ5KG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIHB1YmxpY0tleSk7XG59XG5leHBvcnRzLnNlY3AyNTZrMVNpZ25UZXN0ID0gc2VjcDI1NmsxU2lnblRlc3Q7XG5jbGFzcyBCYXNlV2FsbGV0IHtcbiAgICBnZXRSYW5kb21Qcml2YXRlS2V5KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gY3J5cHRvX2xpYl8xLmJhc2UucmFuZG9tQnl0ZXMoMzIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWNwMjU2azFTaWduVGVzdChwcml2YXRlS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KHByaXZhdGVLZXksIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JfMS5HZW5Qcml2YXRlS2V5RXJyb3IpO1xuICAgIH1cbiAgICBnZXREZXJpdmVkUHJpdmF0ZUtleShwYXJhbSkge1xuICAgICAgICByZXR1cm4gY3J5cHRvX2xpYl8xLmJpcDM5Lm1uZW1vbmljVG9TZWVkKHBhcmFtLm1uZW1vbmljKVxuICAgICAgICAgICAgLnRoZW4oKG1hc3RlclNlZWQpID0+IHtcbiAgICAgICAgICAgIGxldCBjaGlsZEtleSA9IGNyeXB0b19saWJfMS5iaXAzMi5mcm9tU2VlZChtYXN0ZXJTZWVkKS5kZXJpdmVQYXRoKHBhcmFtLmhkUGF0aCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRLZXkucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIGxldCBwcml2YXRlS2V5ID0gY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgoY2hpbGRLZXkucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcIjB4XCIgKyBwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcl8xLkdlblByaXZhdGVLZXlFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JfMS5HZW5Qcml2YXRlS2V5RXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RGVyaXZlZFBhdGgocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yXzEuTm90SW1wbGVtZW50ZWRFcnJvcik7XG4gICAgfVxuICAgIHZhbGlkUHJpdmF0ZUtleShwYXJhbSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yXzEuTm90SW1wbGVtZW50ZWRFcnJvcik7XG4gICAgfVxuICAgIHZlcmlmeU1lc3NhZ2UocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yXzEuTm90SW1wbGVtZW50ZWRFcnJvcik7XG4gICAgfVxuICAgIGVjUmVjb3ZlcihtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yXzEuTm90SW1wbGVtZW50ZWRFcnJvcik7XG4gICAgfVxuICAgIGdldEFkZHJlc3NCeVB1YmxpY0tleShwYXJhbSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKTtcbiAgICB9XG4gICAgZ2V0TVBDUmF3VHJhbnNhY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yXzEuTm90SW1wbGVtZW50ZWRFcnJvcik7XG4gICAgfVxuICAgIGdldE1QQ1RyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcl8xLk5vdEltcGxlbWVudGVkRXJyb3IpO1xuICAgIH1cbiAgICBnZXRNUENSYXdNZXNzYWdlKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcl8xLk5vdEltcGxlbWVudGVkRXJyb3IpO1xuICAgIH1cbiAgICBnZXRNUENTaWduZWRNZXNzYWdlKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcl8xLk5vdEltcGxlbWVudGVkRXJyb3IpO1xuICAgIH1cbiAgICBnZXRIYXJkV2FyZVJhd1RyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcl8xLk5vdEltcGxlbWVudGVkRXJyb3IpO1xuICAgIH1cbiAgICBnZXRIYXJkV2FyZVNpZ25lZFRyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcl8xLk5vdEltcGxlbWVudGVkRXJyb3IpO1xuICAgIH1cbiAgICBnZXRIYXJkV2FyZU1lc3NhZ2VIYXNoKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcl8xLk5vdEltcGxlbWVudGVkRXJyb3IpO1xuICAgIH1cbiAgICBjYWxjVHhIYXNoKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcl8xLk5vdEltcGxlbWVudGVkRXJyb3IpO1xuICAgIH1cbiAgICBnZXRSYXdUcmFuc2FjdGlvbihwYXJhbSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKTtcbiAgICB9XG4gICAgdmFsaWRTaWduZWRUcmFuc2FjdGlvbihwYXJhbSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKTtcbiAgICB9XG4gICAgZXN0aW1hdGVGZWUocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yXzEuTm90SW1wbGVtZW50ZWRFcnJvcik7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlV2FsbGV0ID0gQmFzZVdhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-base/dist/wallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/base32.js':
    /*!***********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/base32.js ***!
  \***********************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = void 0;\nconst validation_1 = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/validation.js\");\nconst CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst CHARSET_INVERSE_INDEX = {\n    'q': 0, 'p': 1, 'z': 2, 'r': 3, 'y': 4, '9': 5, 'x': 6, '8': 7,\n    'g': 8, 'f': 9, '2': 10, 't': 11, 'v': 12, 'd': 13, 'w': 14, '0': 15,\n    's': 16, '3': 17, 'j': 18, 'n': 19, '5': 20, '4': 21, 'k': 22, 'h': 23,\n    'c': 24, 'e': 25, '6': 26, 'm': 27, 'u': 28, 'a': 29, '7': 30, 'l': 31,\n};\nfunction encode(data) {\n    var base32 = '';\n    for (var i = 0; i < data.length; ++i) {\n        var value = data[i];\n        (0, validation_1.validate)(0 <= value && value < 32, 'Invalid value: ' + value + '.');\n        base32 += CHARSET[value];\n    }\n    return base32;\n}\nexports.encode = encode;\nfunction decode(str) {\n    var data = new Uint8Array(str.length);\n    for (var i = 0; i < str.length; ++i) {\n        var value = str[i];\n        (0, validation_1.validate)(value in CHARSET_INVERSE_INDEX, 'Invalid value: ' + value + '.');\n        data[i] = CHARSET_INVERSE_INDEX[value];\n    }\n    return data;\n}\nexports.decode = decode;\n//# sourceMappingURL=base32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmNhc2gvYmFzZTMyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLCtGQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5jYXNoL2Jhc2UzMi5qcz8xNzI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xuY29uc3QgQ0hBUlNFVCA9ICdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCc7XG5jb25zdCBDSEFSU0VUX0lOVkVSU0VfSU5ERVggPSB7XG4gICAgJ3EnOiAwLCAncCc6IDEsICd6JzogMiwgJ3InOiAzLCAneSc6IDQsICc5JzogNSwgJ3gnOiA2LCAnOCc6IDcsXG4gICAgJ2cnOiA4LCAnZic6IDksICcyJzogMTAsICd0JzogMTEsICd2JzogMTIsICdkJzogMTMsICd3JzogMTQsICcwJzogMTUsXG4gICAgJ3MnOiAxNiwgJzMnOiAxNywgJ2onOiAxOCwgJ24nOiAxOSwgJzUnOiAyMCwgJzQnOiAyMSwgJ2snOiAyMiwgJ2gnOiAyMyxcbiAgICAnYyc6IDI0LCAnZSc6IDI1LCAnNic6IDI2LCAnbSc6IDI3LCAndSc6IDI4LCAnYSc6IDI5LCAnNyc6IDMwLCAnbCc6IDMxLFxufTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgdmFyIGJhc2UzMiA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkYXRhW2ldO1xuICAgICAgICAoMCwgdmFsaWRhdGlvbl8xLnZhbGlkYXRlKSgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMzIsICdJbnZhbGlkIHZhbHVlOiAnICsgdmFsdWUgKyAnLicpO1xuICAgICAgICBiYXNlMzIgKz0gQ0hBUlNFVFt2YWx1ZV07XG4gICAgfVxuICAgIHJldHVybiBiYXNlMzI7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0cltpXTtcbiAgICAgICAgKDAsIHZhbGlkYXRpb25fMS52YWxpZGF0ZSkodmFsdWUgaW4gQ0hBUlNFVF9JTlZFUlNFX0lOREVYLCAnSW52YWxpZCB2YWx1ZTogJyArIHZhbHVlICsgJy4nKTtcbiAgICAgICAgZGF0YVtpXSA9IENIQVJTRVRfSU5WRVJTRV9JTkRFWFt2YWx1ZV07XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlMzIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/base32.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/cashaddr.js':
    /*!*************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/cashaddr.js ***!
  \*************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = void 0;\nconst base32 = __importStar(__webpack_require__(/*! ./base32 */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/base32.js\"));\nconst bigInt = __webpack_require__(/*! big-integer */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/node_modules/big-integer/BigInteger.js\");\nconst convertBits = __importStar(__webpack_require__(/*! ./convertBits */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/convertBits.js\"));\nconst validation_1 = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/validation.js\");\nfunction encode(prefix, type, hash) {\n    const prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n    const versionByte = getTypeBits(type) + getHashSizeBits(hash);\n    const payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));\n    const checksumData = concat(concat(prefixData, payloadData), new Uint8Array(8));\n    const payload = concat(payloadData, checksumToUint5Array(polymod(checksumData)));\n    return prefix + ':' + base32.encode(payload);\n}\nexports.encode = encode;\nfunction decode(address) {\n    const pieces = address.toLowerCase().split(':');\n    (0, validation_1.validate)(pieces.length === 2, 'Missing prefix: ' + address + '.');\n    const prefix = pieces[0];\n    const payload = base32.decode(pieces[1]);\n    (0, validation_1.validate)(validChecksum(prefix, payload), 'Invalid checksum: ' + address + '.');\n    const payloadData = fromUint5Array(payload.subarray(0, -8));\n    const versionByte = payloadData[0];\n    const hash = payloadData.subarray(1);\n    (0, validation_1.validate)(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size: ' + address + '.');\n    const type = getType(versionByte);\n    return {\n        prefix: prefix,\n        type: type,\n        hash: hash,\n    };\n}\nexports.decode = decode;\nvar VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];\nfunction isValidPrefix(prefix) {\n    return hasSingleCase(prefix) && VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1;\n}\nfunction prefixToUint5Array(prefix) {\n    var result = new Uint8Array(prefix.length);\n    for (var i = 0; i < prefix.length; ++i) {\n        result[i] = prefix[i].charCodeAt(0) & 31;\n    }\n    return result;\n}\nfunction checksumToUint5Array(checksum) {\n    var result = new Uint8Array(8);\n    for (var i = 0; i < 8; ++i) {\n        result[7 - i] = checksum.and(31).toJSNumber();\n        checksum = checksum.shiftRight(5);\n    }\n    return result;\n}\nfunction getTypeBits(type) {\n    switch (type) {\n        case 'P2PKH':\n            return 0;\n        case 'P2SH':\n            return 8;\n        default:\n            throw new Error('Invalid type: ' + type + '.');\n    }\n}\nfunction getType(versionByte) {\n    switch (versionByte & 120) {\n        case 0:\n            return 'P2PKH';\n        case 8:\n            return 'P2SH';\n        default:\n            throw new Error('Invalid address type in version byte: ' + versionByte + '.');\n    }\n}\nfunction getHashSizeBits(hash) {\n    switch (hash.length * 8) {\n        case 160:\n            return 0;\n        case 192:\n            return 1;\n        case 224:\n            return 2;\n        case 256:\n            return 3;\n        case 320:\n            return 4;\n        case 384:\n            return 5;\n        case 448:\n            return 6;\n        case 512:\n            return 7;\n        default:\n            throw new Error('Invalid hash size: ' + hash.length + '.');\n    }\n}\nfunction getHashSize(versionByte) {\n    switch (versionByte & 7) {\n        case 0:\n            return 160;\n        case 1:\n            return 192;\n        case 2:\n            return 224;\n        case 3:\n            return 256;\n        case 4:\n            return 320;\n        case 5:\n            return 384;\n        case 6:\n            return 448;\n        case 7:\n            return 512;\n    }\n}\nfunction toUint5Array(data) {\n    return convertBits.convert(data, 8, 5, false);\n}\nfunction fromUint5Array(data) {\n    return convertBits.convert(data, 5, 8, true);\n}\nfunction concat(a, b) {\n    var ab = new Uint8Array(a.length + b.length);\n    ab.set(a);\n    ab.set(b, a.length);\n    return ab;\n}\nfunction polymod(data) {\n    var GENERATOR = [0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470];\n    var checksum = bigInt(1);\n    for (var i = 0; i < data.length; ++i) {\n        var value = data[i];\n        var topBits = checksum.shiftRight(35);\n        checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);\n        for (var j = 0; j < GENERATOR.length; ++j) {\n            if (topBits.shiftRight(j).and(1).equals(1)) {\n                checksum = checksum.xor(GENERATOR[j]);\n            }\n        }\n    }\n    return checksum.xor(1);\n}\nfunction validChecksum(prefix, payload) {\n    var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n    var checksumData = concat(prefixData, payload);\n    return polymod(checksumData).equals(0);\n}\nfunction hasSingleCase(str) {\n    return str === str.toLowerCase() || str === str.toUpperCase();\n}\n//# sourceMappingURL=cashaddr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmNhc2gvY2FzaGFkZHIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjO0FBQy9CLDRCQUE0QixtQkFBTyxDQUFDLHVGQUFVO0FBQzlDLGVBQWUsbUJBQU8sQ0FBQyxzR0FBYTtBQUNwQyxpQ0FBaUMsbUJBQU8sQ0FBQyxpR0FBZTtBQUN4RCxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5jYXNoL2Nhc2hhZGRyLmpzPzYxNDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuY29uc3QgYmFzZTMyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2UzMlwiKSk7XG5jb25zdCBiaWdJbnQgPSByZXF1aXJlKCdiaWctaW50ZWdlcicpO1xuY29uc3QgY29udmVydEJpdHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29udmVydEJpdHNcIikpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHR5cGUsIGhhc2gpIHtcbiAgICBjb25zdCBwcmVmaXhEYXRhID0gY29uY2F0KHByZWZpeFRvVWludDVBcnJheShwcmVmaXgpLCBuZXcgVWludDhBcnJheSgxKSk7XG4gICAgY29uc3QgdmVyc2lvbkJ5dGUgPSBnZXRUeXBlQml0cyh0eXBlKSArIGdldEhhc2hTaXplQml0cyhoYXNoKTtcbiAgICBjb25zdCBwYXlsb2FkRGF0YSA9IHRvVWludDVBcnJheShjb25jYXQobmV3IFVpbnQ4QXJyYXkoW3ZlcnNpb25CeXRlXSksIGhhc2gpKTtcbiAgICBjb25zdCBjaGVja3N1bURhdGEgPSBjb25jYXQoY29uY2F0KHByZWZpeERhdGEsIHBheWxvYWREYXRhKSwgbmV3IFVpbnQ4QXJyYXkoOCkpO1xuICAgIGNvbnN0IHBheWxvYWQgPSBjb25jYXQocGF5bG9hZERhdGEsIGNoZWNrc3VtVG9VaW50NUFycmF5KHBvbHltb2QoY2hlY2tzdW1EYXRhKSkpO1xuICAgIHJldHVybiBwcmVmaXggKyAnOicgKyBiYXNlMzIuZW5jb2RlKHBheWxvYWQpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5mdW5jdGlvbiBkZWNvZGUoYWRkcmVzcykge1xuICAgIGNvbnN0IHBpZWNlcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5zcGxpdCgnOicpO1xuICAgICgwLCB2YWxpZGF0aW9uXzEudmFsaWRhdGUpKHBpZWNlcy5sZW5ndGggPT09IDIsICdNaXNzaW5nIHByZWZpeDogJyArIGFkZHJlc3MgKyAnLicpO1xuICAgIGNvbnN0IHByZWZpeCA9IHBpZWNlc1swXTtcbiAgICBjb25zdCBwYXlsb2FkID0gYmFzZTMyLmRlY29kZShwaWVjZXNbMV0pO1xuICAgICgwLCB2YWxpZGF0aW9uXzEudmFsaWRhdGUpKHZhbGlkQ2hlY2tzdW0ocHJlZml4LCBwYXlsb2FkKSwgJ0ludmFsaWQgY2hlY2tzdW06ICcgKyBhZGRyZXNzICsgJy4nKTtcbiAgICBjb25zdCBwYXlsb2FkRGF0YSA9IGZyb21VaW50NUFycmF5KHBheWxvYWQuc3ViYXJyYXkoMCwgLTgpKTtcbiAgICBjb25zdCB2ZXJzaW9uQnl0ZSA9IHBheWxvYWREYXRhWzBdO1xuICAgIGNvbnN0IGhhc2ggPSBwYXlsb2FkRGF0YS5zdWJhcnJheSgxKTtcbiAgICAoMCwgdmFsaWRhdGlvbl8xLnZhbGlkYXRlKShnZXRIYXNoU2l6ZSh2ZXJzaW9uQnl0ZSkgPT09IGhhc2gubGVuZ3RoICogOCwgJ0ludmFsaWQgaGFzaCBzaXplOiAnICsgYWRkcmVzcyArICcuJyk7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUodmVyc2lvbkJ5dGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBoYXNoOiBoYXNoLFxuICAgIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbnZhciBWQUxJRF9QUkVGSVhFUyA9IFsnYml0Y29pbmNhc2gnLCAnYmNodGVzdCcsICdiY2hyZWcnXTtcbmZ1bmN0aW9uIGlzVmFsaWRQcmVmaXgocHJlZml4KSB7XG4gICAgcmV0dXJuIGhhc1NpbmdsZUNhc2UocHJlZml4KSAmJiBWQUxJRF9QUkVGSVhFUy5pbmRleE9mKHByZWZpeC50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBwcmVmaXhUb1VpbnQ1QXJyYXkocHJlZml4KSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHByZWZpeC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IHByZWZpeFtpXS5jaGFyQ29kZUF0KDApICYgMzE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGVja3N1bVRvVWludDVBcnJheShjaGVja3N1bSkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICByZXN1bHRbNyAtIGldID0gY2hlY2tzdW0uYW5kKDMxKS50b0pTTnVtYmVyKCk7XG4gICAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0uc2hpZnRSaWdodCg1KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFR5cGVCaXRzKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnUDJQS0gnOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgJ1AyU0gnOlxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZTogJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFR5cGUodmVyc2lvbkJ5dGUpIHtcbiAgICBzd2l0Y2ggKHZlcnNpb25CeXRlICYgMTIwKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiAnUDJQS0gnO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gJ1AyU0gnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MgdHlwZSBpbiB2ZXJzaW9uIGJ5dGU6ICcgKyB2ZXJzaW9uQnl0ZSArICcuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SGFzaFNpemVCaXRzKGhhc2gpIHtcbiAgICBzd2l0Y2ggKGhhc2gubGVuZ3RoICogOCkge1xuICAgICAgICBjYXNlIDE2MDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlIDE5MjpcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjYXNlIDIyNDpcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICBjYXNlIDMyMDpcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICBjYXNlIDM4NDpcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICBjYXNlIDQ0ODpcbiAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhhc2ggc2l6ZTogJyArIGhhc2gubGVuZ3RoICsgJy4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRIYXNoU2l6ZSh2ZXJzaW9uQnl0ZSkge1xuICAgIHN3aXRjaCAodmVyc2lvbkJ5dGUgJiA3KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiAxNjA7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAxOTI7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAyMjQ7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAyNTY7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAzMjA7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiAzODQ7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiA0NDg7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiA1MTI7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9VaW50NUFycmF5KGRhdGEpIHtcbiAgICByZXR1cm4gY29udmVydEJpdHMuY29udmVydChkYXRhLCA4LCA1LCBmYWxzZSk7XG59XG5mdW5jdGlvbiBmcm9tVWludDVBcnJheShkYXRhKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCaXRzLmNvbnZlcnQoZGF0YSwgNSwgOCwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICAgIHZhciBhYiA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIGFiLnNldChhKTtcbiAgICBhYi5zZXQoYiwgYS5sZW5ndGgpO1xuICAgIHJldHVybiBhYjtcbn1cbmZ1bmN0aW9uIHBvbHltb2QoZGF0YSkge1xuICAgIHZhciBHRU5FUkFUT1IgPSBbMHg5OGYyYmM4ZTYxLCAweDc5Yjc2ZDk5ZTIsIDB4ZjMzZTVmYjNjNCwgMHhhZTJlYWJlMmE4LCAweDFlNGY0M2U0NzBdO1xuICAgIHZhciBjaGVja3N1bSA9IGJpZ0ludCgxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZGF0YVtpXTtcbiAgICAgICAgdmFyIHRvcEJpdHMgPSBjaGVja3N1bS5zaGlmdFJpZ2h0KDM1KTtcbiAgICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bS5hbmQoMHgwN2ZmZmZmZmZmKS5zaGlmdExlZnQoNSkueG9yKHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBHRU5FUkFUT1IubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGlmICh0b3BCaXRzLnNoaWZ0UmlnaHQoaikuYW5kKDEpLmVxdWFscygxKSkge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0ueG9yKEdFTkVSQVRPUltqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtLnhvcigxKTtcbn1cbmZ1bmN0aW9uIHZhbGlkQ2hlY2tzdW0ocHJlZml4LCBwYXlsb2FkKSB7XG4gICAgdmFyIHByZWZpeERhdGEgPSBjb25jYXQocHJlZml4VG9VaW50NUFycmF5KHByZWZpeCksIG5ldyBVaW50OEFycmF5KDEpKTtcbiAgICB2YXIgY2hlY2tzdW1EYXRhID0gY29uY2F0KHByZWZpeERhdGEsIHBheWxvYWQpO1xuICAgIHJldHVybiBwb2x5bW9kKGNoZWNrc3VtRGF0YSkuZXF1YWxzKDApO1xufVxuZnVuY3Rpb24gaGFzU2luZ2xlQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyID09PSBzdHIudG9Mb3dlckNhc2UoKSB8fCBzdHIgPT09IHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FzaGFkZHIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/cashaddr.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/convertBits.js':
    /*!****************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/convertBits.js ***!
  \****************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convert = void 0;\nconst validation_1 = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/validation.js\");\nfunction convert(data, from, to, strictMode) {\n    var length = strictMode\n        ? Math.floor(data.length * from / to)\n        : Math.ceil(data.length * from / to);\n    var mask = (1 << to) - 1;\n    var result = new Uint8Array(length);\n    var index = 0;\n    var accumulator = 0;\n    var bits = 0;\n    for (var i = 0; i < data.length; ++i) {\n        var value = data[i];\n        (0, validation_1.validate)(0 <= value && (value >> from) === 0, 'Invalid value: ' + value + '.');\n        accumulator = (accumulator << from) | value;\n        bits += from;\n        while (bits >= to) {\n            bits -= to;\n            result[index] = (accumulator >> bits) & mask;\n            ++index;\n        }\n    }\n    if (!strictMode) {\n        if (bits > 0) {\n            result[index] = (accumulator << (to - bits)) & mask;\n            ++index;\n        }\n    }\n    else {\n        (0, validation_1.validate)(bits < from && ((accumulator << (to - bits)) & mask) === 0, 'Input cannot be converted to ' + to + ' bits without padding, but strict mode was used.');\n    }\n    return result;\n}\nexports.convert = convert;\n//# sourceMappingURL=convertBits.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmNhc2gvY29udmVydEJpdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLHFCQUFxQixtQkFBTyxDQUFDLCtGQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmNhc2gvY29udmVydEJpdHMuanM/OWY3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnZlcnQgPSB2b2lkIDA7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xuZnVuY3Rpb24gY29udmVydChkYXRhLCBmcm9tLCB0bywgc3RyaWN0TW9kZSkge1xuICAgIHZhciBsZW5ndGggPSBzdHJpY3RNb2RlXG4gICAgICAgID8gTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAqIGZyb20gLyB0bylcbiAgICAgICAgOiBNYXRoLmNlaWwoZGF0YS5sZW5ndGggKiBmcm9tIC8gdG8pO1xuICAgIHZhciBtYXNrID0gKDEgPDwgdG8pIC0gMTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhY2N1bXVsYXRvciA9IDA7XG4gICAgdmFyIGJpdHMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkYXRhW2ldO1xuICAgICAgICAoMCwgdmFsaWRhdGlvbl8xLnZhbGlkYXRlKSgwIDw9IHZhbHVlICYmICh2YWx1ZSA+PiBmcm9tKSA9PT0gMCwgJ0ludmFsaWQgdmFsdWU6ICcgKyB2YWx1ZSArICcuJyk7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gKGFjY3VtdWxhdG9yIDw8IGZyb20pIHwgdmFsdWU7XG4gICAgICAgIGJpdHMgKz0gZnJvbTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPj0gdG8pIHtcbiAgICAgICAgICAgIGJpdHMgLT0gdG87XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gKGFjY3VtdWxhdG9yID4+IGJpdHMpICYgbWFzaztcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdHJpY3RNb2RlKSB7XG4gICAgICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IChhY2N1bXVsYXRvciA8PCAodG8gLSBiaXRzKSkgJiBtYXNrO1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIHZhbGlkYXRpb25fMS52YWxpZGF0ZSkoYml0cyA8IGZyb20gJiYgKChhY2N1bXVsYXRvciA8PCAodG8gLSBiaXRzKSkgJiBtYXNrKSA9PT0gMCwgJ0lucHV0IGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gJyArIHRvICsgJyBiaXRzIHdpdGhvdXQgcGFkZGluZywgYnV0IHN0cmljdCBtb2RlIHdhcyB1c2VkLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jb252ZXJ0ID0gY29udmVydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZlcnRCaXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/convertBits.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/index.js':
    /*!**********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/index.js ***!
  \**********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.convert2LegacyAddress = exports.isCashAddress = exports.ValidateBitcashP2PkHAddress = exports.GetBitcashP2PkHAddressByPublicKey = exports.GetBitcashAddressByPublicKey = exports.GetBitcashAddressByHash = void 0;\nconst crypto_1 = __webpack_require__(/*! ../bitcoinjs-lib/crypto */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js");\nconst cashAddrJs = __importStar(__webpack_require__(/*! ./cashaddr */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/cashaddr.js"));\nconst payments = __importStar(__webpack_require__(/*! ../bitcoinjs-lib/payments */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js"));\nfunction GetBitcashAddressByHash(prefix, type, hash) {\n    return cashAddrJs.encode(prefix, type, hash);\n}\nexports.GetBitcashAddressByHash = GetBitcashAddressByHash;\nfunction GetBitcashAddressByPublicKey(prefix, type, publicKey) {\n    const hash = (0, crypto_1.hash160)(Buffer.from(publicKey));\n    return GetBitcashAddressByHash(prefix, type, hash);\n}\nexports.GetBitcashAddressByPublicKey = GetBitcashAddressByPublicKey;\nfunction GetBitcashP2PkHAddressByPublicKey(publicKey) {\n    const hash = (0, crypto_1.hash160)(Buffer.from(publicKey));\n    return GetBitcashAddressByHash("bitcoincash", "P2PKH", hash);\n}\nexports.GetBitcashP2PkHAddressByPublicKey = GetBitcashP2PkHAddressByPublicKey;\nfunction ValidateBitcashP2PkHAddress(address) {\n    try {\n        if (address.indexOf(":") === -1) {\n            address = "bitcoincash:" + address;\n        }\n        const { prefix, type, hash } = cashAddrJs.decode(address);\n        return type === "P2PKH" && hash.length === 20;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexports.ValidateBitcashP2PkHAddress = ValidateBitcashP2PkHAddress;\nfunction isCashAddress(address) {\n    try {\n        if (address.startsWith("bitcoincash:")) {\n            return true;\n        }\n        address = "bitcoincash:" + address;\n        cashAddrJs.decode(address);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexports.isCashAddress = isCashAddress;\nfunction convert2LegacyAddress(address, network) {\n    if (address.indexOf(":") === -1) {\n        address = "bitcoincash:" + address;\n    }\n    const { type, hash } = cashAddrJs.decode(address);\n    if (type == "P2PKH") {\n        const result = payments.p2pkh({ hash: Buffer.from(hash), network });\n        return result.address;\n    }\n    else if (type == "P2SH") {\n        const result = payments.p2sh({ hash: Buffer.from(hash), network });\n        return result.address;\n    }\n    else {\n        throw new Error("convert2LegacyAddress error");\n    }\n}\nexports.convert2LegacyAddress = convert2LegacyAddress;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmNhc2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLHFCQUFxQixHQUFHLG1DQUFtQyxHQUFHLHlDQUF5QyxHQUFHLG9DQUFvQyxHQUFHLCtCQUErQjtBQUNoTixpQkFBaUIsbUJBQU8sQ0FBQyx3R0FBeUI7QUFDbEQsZ0NBQWdDLG1CQUFPLENBQUMsMkZBQVk7QUFDcEQsOEJBQThCLG1CQUFPLENBQUMsa0hBQTJCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQSx3Q0FBd0Msa0NBQWtDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQ0FBa0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmNhc2gvaW5kZXguanM/ZmUwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb252ZXJ0MkxlZ2FjeUFkZHJlc3MgPSBleHBvcnRzLmlzQ2FzaEFkZHJlc3MgPSBleHBvcnRzLlZhbGlkYXRlQml0Y2FzaFAyUGtIQWRkcmVzcyA9IGV4cG9ydHMuR2V0Qml0Y2FzaFAyUGtIQWRkcmVzc0J5UHVibGljS2V5ID0gZXhwb3J0cy5HZXRCaXRjYXNoQWRkcmVzc0J5UHVibGljS2V5ID0gZXhwb3J0cy5HZXRCaXRjYXNoQWRkcmVzc0J5SGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2JpdGNvaW5qcy1saWIvY3J5cHRvXCIpO1xuY29uc3QgY2FzaEFkZHJKcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jYXNoYWRkclwiKSk7XG5jb25zdCBwYXltZW50cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vYml0Y29pbmpzLWxpYi9wYXltZW50c1wiKSk7XG5mdW5jdGlvbiBHZXRCaXRjYXNoQWRkcmVzc0J5SGFzaChwcmVmaXgsIHR5cGUsIGhhc2gpIHtcbiAgICByZXR1cm4gY2FzaEFkZHJKcy5lbmNvZGUocHJlZml4LCB0eXBlLCBoYXNoKTtcbn1cbmV4cG9ydHMuR2V0Qml0Y2FzaEFkZHJlc3NCeUhhc2ggPSBHZXRCaXRjYXNoQWRkcmVzc0J5SGFzaDtcbmZ1bmN0aW9uIEdldEJpdGNhc2hBZGRyZXNzQnlQdWJsaWNLZXkocHJlZml4LCB0eXBlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBoYXNoID0gKDAsIGNyeXB0b18xLmhhc2gxNjApKEJ1ZmZlci5mcm9tKHB1YmxpY0tleSkpO1xuICAgIHJldHVybiBHZXRCaXRjYXNoQWRkcmVzc0J5SGFzaChwcmVmaXgsIHR5cGUsIGhhc2gpO1xufVxuZXhwb3J0cy5HZXRCaXRjYXNoQWRkcmVzc0J5UHVibGljS2V5ID0gR2V0Qml0Y2FzaEFkZHJlc3NCeVB1YmxpY0tleTtcbmZ1bmN0aW9uIEdldEJpdGNhc2hQMlBrSEFkZHJlc3NCeVB1YmxpY0tleShwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBoYXNoID0gKDAsIGNyeXB0b18xLmhhc2gxNjApKEJ1ZmZlci5mcm9tKHB1YmxpY0tleSkpO1xuICAgIHJldHVybiBHZXRCaXRjYXNoQWRkcmVzc0J5SGFzaChcImJpdGNvaW5jYXNoXCIsIFwiUDJQS0hcIiwgaGFzaCk7XG59XG5leHBvcnRzLkdldEJpdGNhc2hQMlBrSEFkZHJlc3NCeVB1YmxpY0tleSA9IEdldEJpdGNhc2hQMlBrSEFkZHJlc3NCeVB1YmxpY0tleTtcbmZ1bmN0aW9uIFZhbGlkYXRlQml0Y2FzaFAyUGtIQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGFkZHJlc3MuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gXCJiaXRjb2luY2FzaDpcIiArIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHR5cGUsIGhhc2ggfSA9IGNhc2hBZGRySnMuZGVjb2RlKGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJQMlBLSFwiICYmIGhhc2gubGVuZ3RoID09PSAyMDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsaWRhdGVCaXRjYXNoUDJQa0hBZGRyZXNzID0gVmFsaWRhdGVCaXRjYXNoUDJQa0hBZGRyZXNzO1xuZnVuY3Rpb24gaXNDYXNoQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGFkZHJlc3Muc3RhcnRzV2l0aChcImJpdGNvaW5jYXNoOlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzcyA9IFwiYml0Y29pbmNhc2g6XCIgKyBhZGRyZXNzO1xuICAgICAgICBjYXNoQWRkckpzLmRlY29kZShhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzQ2FzaEFkZHJlc3MgPSBpc0Nhc2hBZGRyZXNzO1xuZnVuY3Rpb24gY29udmVydDJMZWdhY3lBZGRyZXNzKGFkZHJlc3MsIG5ldHdvcmspIHtcbiAgICBpZiAoYWRkcmVzcy5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgICAgICAgYWRkcmVzcyA9IFwiYml0Y29pbmNhc2g6XCIgKyBhZGRyZXNzO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGUsIGhhc2ggfSA9IGNhc2hBZGRySnMuZGVjb2RlKGFkZHJlc3MpO1xuICAgIGlmICh0eXBlID09IFwiUDJQS0hcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXltZW50cy5wMnBraCh7IGhhc2g6IEJ1ZmZlci5mcm9tKGhhc2gpLCBuZXR3b3JrIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmFkZHJlc3M7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJQMlNIXCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGF5bWVudHMucDJzaCh7IGhhc2g6IEJ1ZmZlci5mcm9tKGhhc2gpLCBuZXR3b3JrIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmFkZHJlc3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb252ZXJ0MkxlZ2FjeUFkZHJlc3MgZXJyb3JcIik7XG4gICAgfVxufVxuZXhwb3J0cy5jb252ZXJ0MkxlZ2FjeUFkZHJlc3MgPSBjb252ZXJ0MkxlZ2FjeUFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/validation.js':
    /*!***************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/validation.js ***!
  \***************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.validate = void 0;\nfunction validate(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\nexports.validate = validate;\n//# sourceMappingURL=validation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmNhc2gvdmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5jYXNoL3ZhbGlkYXRpb24uanM/MDQ0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlID0gdm9pZCAwO1xuZnVuY3Rpb24gdmFsaWRhdGUoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/validation.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/address.js':
    /*!**************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/address.js ***!
  \**************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toOutputScript = exports.fromOutputScript = exports.toBech32 = exports.toBase58Check = exports.fromBech32 = exports.fromBase58Check = void 0;\nconst networks = __importStar(__webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\"));\nconst payments = __importStar(__webpack_require__(/*! ./payments */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js\"));\nconst bscript = __importStar(__webpack_require__(/*! ./script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst types = __importStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\"));\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nconst { typeforce } = types;\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING = 'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n    'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n    'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n    'then decide when it is safe to use which version of segwit.';\nfunction _toFutureSegwitAddress(output, network) {\n    const data = output.slice(2);\n    if (data.length < FUTURE_SEGWIT_MIN_SIZE ||\n        data.length > FUTURE_SEGWIT_MAX_SIZE)\n        throw new TypeError('Invalid program length for segwit address');\n    const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n    if (version < FUTURE_SEGWIT_MIN_VERSION ||\n        version > FUTURE_SEGWIT_MAX_VERSION)\n        throw new TypeError('Invalid version for segwit address');\n    if (output[1] !== data.length)\n        throw new TypeError('Invalid script for segwit address');\n    console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n    return toBech32(data, version, network.bech32);\n}\nfunction fromBase58Check(address) {\n    const payload = crypto_lib_1.base.fromBase58Check(address);\n    if (payload.length < 21)\n        throw new TypeError(address + ' is too short');\n    if (payload.length > 21)\n        throw new TypeError(address + ' is too long');\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\nfunction fromBech32(address) {\n    let result;\n    let version;\n    try {\n        result = crypto_lib_1.base.bech32.decode(address);\n    }\n    catch (e) { }\n    if (result) {\n        version = result.words[0];\n        if (version !== 0)\n            throw new TypeError(address + ' uses wrong encoding');\n    }\n    else {\n        result = crypto_lib_1.base.bech32m.decode(address);\n        version = result.words[0];\n        if (version === 0)\n            throw new TypeError(address + ' uses wrong encoding');\n    }\n    const data = crypto_lib_1.base.bech32.fromWords(result.words.slice(1));\n    return {\n        version,\n        prefix: result.prefix,\n        data: Buffer.from(data),\n    };\n}\nexports.fromBech32 = fromBech32;\nfunction toBase58Check(hash, version) {\n    typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(version, 0);\n    hash.copy(payload, 1);\n    return crypto_lib_1.base.toBase58Check(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n    const words = crypto_lib_1.base.bech32.toWords(data);\n    words.unshift(version);\n    return version === 0\n        ? crypto_lib_1.base.bech32.encode(prefix, words)\n        : crypto_lib_1.base.bech32m.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction fromOutputScript(output, network) {\n    network = network || networks.bitcoin;\n    try {\n        return payments.p2pkh({ output, network }).address;\n    }\n    catch (e) { }\n    try {\n        return payments.p2sh({ output, network }).address;\n    }\n    catch (e) { }\n    try {\n        return payments.p2wpkh({ output, network }).address;\n    }\n    catch (e) { }\n    try {\n        return payments.p2wsh({ output, network }).address;\n    }\n    catch (e) { }\n    try {\n        return payments.p2tr({ output, network }).address;\n    }\n    catch (e) { }\n    try {\n        return _toFutureSegwitAddress(output, network);\n    }\n    catch (e) { }\n    throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\nfunction toOutputScript(address, network) {\n    network = network || networks.bitcoin;\n    let decodeBase58;\n    let decodeBech32;\n    try {\n        decodeBase58 = fromBase58Check(address);\n    }\n    catch (e) { }\n    if (decodeBase58) {\n        if (decodeBase58.version === network.pubKeyHash)\n            return payments.p2pkh({ hash: decodeBase58.hash }).output;\n        if (decodeBase58.version === network.scriptHash)\n            return payments.p2sh({ hash: decodeBase58.hash }).output;\n    }\n    else {\n        try {\n            decodeBech32 = fromBech32(address);\n        }\n        catch (e) { }\n        if (decodeBech32) {\n            if (decodeBech32.prefix !== network.bech32)\n                throw new Error(address + ' has an invalid prefix');\n            if (decodeBech32.version === 0) {\n                if (decodeBech32.data.length === 20)\n                    return payments.p2wpkh({ hash: decodeBech32.data }).output;\n                if (decodeBech32.data.length === 32)\n                    return payments.p2wsh({ hash: decodeBech32.data }).output;\n            }\n            else if (decodeBech32.version === 1) {\n                if (decodeBech32.data.length === 32)\n                    return payments.p2tr({ pubkey: decodeBech32.data }).output;\n            }\n            else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n                decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n                decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n                decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {\n                console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n                return bscript.compile([\n                    decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n                    decodeBech32.data,\n                ]);\n            }\n        }\n    }\n    throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDM0ksOEJBQThCLG1CQUFPLENBQUMsNkZBQVk7QUFDbEQsOEJBQThCLG1CQUFPLENBQUMsbUdBQVk7QUFDbEQsNkJBQTZCLG1CQUFPLENBQUMseUZBQVU7QUFDL0MsMkJBQTJCLG1CQUFPLENBQUMsdUZBQVM7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xELFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCO0FBQ3RFO0FBQ0EsNENBQTRDLHlCQUF5QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYWRkcmVzcy5qcz80MWM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvT3V0cHV0U2NyaXB0ID0gZXhwb3J0cy5mcm9tT3V0cHV0U2NyaXB0ID0gZXhwb3J0cy50b0JlY2gzMiA9IGV4cG9ydHMudG9CYXNlNThDaGVjayA9IGV4cG9ydHMuZnJvbUJlY2gzMiA9IGV4cG9ydHMuZnJvbUJhc2U1OENoZWNrID0gdm9pZCAwO1xuY29uc3QgbmV0d29ya3MgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbmV0d29ya3NcIikpO1xuY29uc3QgcGF5bWVudHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcGF5bWVudHNcIikpO1xuY29uc3QgYnNjcmlwdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zY3JpcHRcIikpO1xuY29uc3QgdHlwZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIikpO1xuY29uc3QgY3J5cHRvX2xpYl8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NyeXB0by1saWJcIik7XG5jb25zdCB7IHR5cGVmb3JjZSB9ID0gdHlwZXM7XG5jb25zdCBGVVRVUkVfU0VHV0lUX01BWF9TSVpFID0gNDA7XG5jb25zdCBGVVRVUkVfU0VHV0lUX01JTl9TSVpFID0gMjtcbmNvbnN0IEZVVFVSRV9TRUdXSVRfTUFYX1ZFUlNJT04gPSAxNjtcbmNvbnN0IEZVVFVSRV9TRUdXSVRfTUlOX1ZFUlNJT04gPSAyO1xuY29uc3QgRlVUVVJFX1NFR1dJVF9WRVJTSU9OX0RJRkYgPSAweDUwO1xuY29uc3QgRlVUVVJFX1NFR1dJVF9WRVJTSU9OX1dBUk5JTkcgPSAnV0FSTklORzogU2VuZGluZyB0byBhIGZ1dHVyZSBzZWd3aXQgdmVyc2lvbiBhZGRyZXNzIGNhbiBsZWFkIHRvIGxvc3Mgb2YgZnVuZHMuICcgK1xuICAgICdFbmQgdXNlcnMgTVVTVCBiZSB3YXJuZWQgY2FyZWZ1bGx5IGluIHRoZSBHVUkgYW5kIGFza2VkIGlmIHRoZXkgd2lzaCB0byBwcm9jZWVkICcgK1xuICAgICd3aXRoIGNhdXRpb24uIFdhbGxldHMgc2hvdWxkIHZlcmlmeSB0aGUgc2Vnd2l0IHZlcnNpb24gZnJvbSB0aGUgb3V0cHV0IG9mIGZyb21CZWNoMzIsICcgK1xuICAgICd0aGVuIGRlY2lkZSB3aGVuIGl0IGlzIHNhZmUgdG8gdXNlIHdoaWNoIHZlcnNpb24gb2Ygc2Vnd2l0Lic7XG5mdW5jdGlvbiBfdG9GdXR1cmVTZWd3aXRBZGRyZXNzKG91dHB1dCwgbmV0d29yaykge1xuICAgIGNvbnN0IGRhdGEgPSBvdXRwdXQuc2xpY2UoMik7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgRlVUVVJFX1NFR1dJVF9NSU5fU0laRSB8fFxuICAgICAgICBkYXRhLmxlbmd0aCA+IEZVVFVSRV9TRUdXSVRfTUFYX1NJWkUpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJvZ3JhbSBsZW5ndGggZm9yIHNlZ3dpdCBhZGRyZXNzJyk7XG4gICAgY29uc3QgdmVyc2lvbiA9IG91dHB1dFswXSAtIEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9ESUZGO1xuICAgIGlmICh2ZXJzaW9uIDwgRlVUVVJFX1NFR1dJVF9NSU5fVkVSU0lPTiB8fFxuICAgICAgICB2ZXJzaW9uID4gRlVUVVJFX1NFR1dJVF9NQVhfVkVSU0lPTilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2ZXJzaW9uIGZvciBzZWd3aXQgYWRkcmVzcycpO1xuICAgIGlmIChvdXRwdXRbMV0gIT09IGRhdGEubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNjcmlwdCBmb3Igc2Vnd2l0IGFkZHJlc3MnKTtcbiAgICBjb25zb2xlLndhcm4oRlVUVVJFX1NFR1dJVF9WRVJTSU9OX1dBUk5JTkcpO1xuICAgIHJldHVybiB0b0JlY2gzMihkYXRhLCB2ZXJzaW9uLCBuZXR3b3JrLmJlY2gzMik7XG59XG5mdW5jdGlvbiBmcm9tQmFzZTU4Q2hlY2soYWRkcmVzcykge1xuICAgIGNvbnN0IHBheWxvYWQgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tQmFzZTU4Q2hlY2soYWRkcmVzcyk7XG4gICAgaWYgKHBheWxvYWQubGVuZ3RoIDwgMjEpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgaXMgdG9vIHNob3J0Jyk7XG4gICAgaWYgKHBheWxvYWQubGVuZ3RoID4gMjEpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgaXMgdG9vIGxvbmcnKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gcGF5bG9hZC5yZWFkVUludDgoMCk7XG4gICAgY29uc3QgaGFzaCA9IHBheWxvYWQuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHsgdmVyc2lvbiwgaGFzaCB9O1xufVxuZXhwb3J0cy5mcm9tQmFzZTU4Q2hlY2sgPSBmcm9tQmFzZTU4Q2hlY2s7XG5mdW5jdGlvbiBmcm9tQmVjaDMyKGFkZHJlc3MpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGNyeXB0b19saWJfMS5iYXNlLmJlY2gzMi5kZWNvZGUoYWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHZlcnNpb24gPSByZXN1bHQud29yZHNbMF07XG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihhZGRyZXNzICsgJyB1c2VzIHdyb25nIGVuY29kaW5nJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcnlwdG9fbGliXzEuYmFzZS5iZWNoMzJtLmRlY29kZShhZGRyZXNzKTtcbiAgICAgICAgdmVyc2lvbiA9IHJlc3VsdC53b3Jkc1swXTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGFkZHJlc3MgKyAnIHVzZXMgd3JvbmcgZW5jb2RpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGNyeXB0b19saWJfMS5iYXNlLmJlY2gzMi5mcm9tV29yZHMocmVzdWx0LndvcmRzLnNsaWNlKDEpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmVmaXg6IHJlc3VsdC5wcmVmaXgsXG4gICAgICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGRhdGEpLFxuICAgIH07XG59XG5leHBvcnRzLmZyb21CZWNoMzIgPSBmcm9tQmVjaDMyO1xuZnVuY3Rpb24gdG9CYXNlNThDaGVjayhoYXNoLCB2ZXJzaW9uKSB7XG4gICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLkhhc2gxNjBiaXQsIHR5cGVzLlVJbnQ4KSwgYXJndW1lbnRzKTtcbiAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIxKTtcbiAgICBwYXlsb2FkLndyaXRlVUludDgodmVyc2lvbiwgMCk7XG4gICAgaGFzaC5jb3B5KHBheWxvYWQsIDEpO1xuICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS50b0Jhc2U1OENoZWNrKHBheWxvYWQpO1xufVxuZXhwb3J0cy50b0Jhc2U1OENoZWNrID0gdG9CYXNlNThDaGVjaztcbmZ1bmN0aW9uIHRvQmVjaDMyKGRhdGEsIHZlcnNpb24sIHByZWZpeCkge1xuICAgIGNvbnN0IHdvcmRzID0gY3J5cHRvX2xpYl8xLmJhc2UuYmVjaDMyLnRvV29yZHMoZGF0YSk7XG4gICAgd29yZHMudW5zaGlmdCh2ZXJzaW9uKTtcbiAgICByZXR1cm4gdmVyc2lvbiA9PT0gMFxuICAgICAgICA/IGNyeXB0b19saWJfMS5iYXNlLmJlY2gzMi5lbmNvZGUocHJlZml4LCB3b3JkcylcbiAgICAgICAgOiBjcnlwdG9fbGliXzEuYmFzZS5iZWNoMzJtLmVuY29kZShwcmVmaXgsIHdvcmRzKTtcbn1cbmV4cG9ydHMudG9CZWNoMzIgPSB0b0JlY2gzMjtcbmZ1bmN0aW9uIGZyb21PdXRwdXRTY3JpcHQob3V0cHV0LCBuZXR3b3JrKSB7XG4gICAgbmV0d29yayA9IG5ldHdvcmsgfHwgbmV0d29ya3MuYml0Y29pbjtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcGF5bWVudHMucDJwa2goeyBvdXRwdXQsIG5ldHdvcmsgfSkuYWRkcmVzcztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwYXltZW50cy5wMnNoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ3cGtoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ3c2goeyBvdXRwdXQsIG5ldHdvcmsgfSkuYWRkcmVzcztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwYXltZW50cy5wMnRyKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gX3RvRnV0dXJlU2Vnd2l0QWRkcmVzcyhvdXRwdXQsIG5ldHdvcmspO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGJzY3JpcHQudG9BU00ob3V0cHV0KSArICcgaGFzIG5vIG1hdGNoaW5nIEFkZHJlc3MnKTtcbn1cbmV4cG9ydHMuZnJvbU91dHB1dFNjcmlwdCA9IGZyb21PdXRwdXRTY3JpcHQ7XG5mdW5jdGlvbiB0b091dHB1dFNjcmlwdChhZGRyZXNzLCBuZXR3b3JrKSB7XG4gICAgbmV0d29yayA9IG5ldHdvcmsgfHwgbmV0d29ya3MuYml0Y29pbjtcbiAgICBsZXQgZGVjb2RlQmFzZTU4O1xuICAgIGxldCBkZWNvZGVCZWNoMzI7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlQmFzZTU4ID0gZnJvbUJhc2U1OENoZWNrKGFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgaWYgKGRlY29kZUJhc2U1OCkge1xuICAgICAgICBpZiAoZGVjb2RlQmFzZTU4LnZlcnNpb24gPT09IG5ldHdvcmsucHViS2V5SGFzaClcbiAgICAgICAgICAgIHJldHVybiBwYXltZW50cy5wMnBraCh7IGhhc2g6IGRlY29kZUJhc2U1OC5oYXNoIH0pLm91dHB1dDtcbiAgICAgICAgaWYgKGRlY29kZUJhc2U1OC52ZXJzaW9uID09PSBuZXR3b3JrLnNjcmlwdEhhc2gpXG4gICAgICAgICAgICByZXR1cm4gcGF5bWVudHMucDJzaCh7IGhhc2g6IGRlY29kZUJhc2U1OC5oYXNoIH0pLm91dHB1dDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNvZGVCZWNoMzIgPSBmcm9tQmVjaDMyKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgaWYgKGRlY29kZUJlY2gzMikge1xuICAgICAgICAgICAgaWYgKGRlY29kZUJlY2gzMi5wcmVmaXggIT09IG5ldHdvcmsuYmVjaDMyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhZGRyZXNzICsgJyBoYXMgYW4gaW52YWxpZCBwcmVmaXgnKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVCZWNoMzIudmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWNvZGVCZWNoMzIuZGF0YS5sZW5ndGggPT09IDIwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ3cGtoKHsgaGFzaDogZGVjb2RlQmVjaDMyLmRhdGEgfSkub3V0cHV0O1xuICAgICAgICAgICAgICAgIGlmIChkZWNvZGVCZWNoMzIuZGF0YS5sZW5ndGggPT09IDMyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ3c2goeyBoYXNoOiBkZWNvZGVCZWNoMzIuZGF0YSB9KS5vdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWNvZGVCZWNoMzIudmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWNvZGVCZWNoMzIuZGF0YS5sZW5ndGggPT09IDMyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ0cih7IHB1YmtleTogZGVjb2RlQmVjaDMyLmRhdGEgfSkub3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVjb2RlQmVjaDMyLnZlcnNpb24gPj0gRlVUVVJFX1NFR1dJVF9NSU5fVkVSU0lPTiAmJlxuICAgICAgICAgICAgICAgIGRlY29kZUJlY2gzMi52ZXJzaW9uIDw9IEZVVFVSRV9TRUdXSVRfTUFYX1ZFUlNJT04gJiZcbiAgICAgICAgICAgICAgICBkZWNvZGVCZWNoMzIuZGF0YS5sZW5ndGggPj0gRlVUVVJFX1NFR1dJVF9NSU5fU0laRSAmJlxuICAgICAgICAgICAgICAgIGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA8PSBGVVRVUkVfU0VHV0lUX01BWF9TSVpFKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9XQVJOSU5HKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlQmVjaDMyLnZlcnNpb24gKyBGVVRVUkVfU0VHV0lUX1ZFUlNJT05fRElGRixcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlQmVjaDMyLmRhdGEsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGFkZHJlc3MgKyAnIGhhcyBubyBtYXRjaGluZyBTY3JpcHQnKTtcbn1cbmV4cG9ydHMudG9PdXRwdXRTY3JpcHQgPSB0b091dHB1dFNjcmlwdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/address.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip0322.js':
    /*!**************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip0322.js ***!
  \**************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifySimple = exports.signSimple = exports.getSignatureFromPsbtOfBIP322Simple = exports.genPsbtOfBIP322Simple = void 0;\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nconst address_1 = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/address.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/transaction.js\");\nconst psbt_1 = __webpack_require__(/*! ./psbt */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt.js\");\nconst varuint_1 = __webpack_require__(/*! ./varuint */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/varuint.js\");\nconst psbtSign_1 = __webpack_require__(/*! ../psbtSign */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/psbtSign.js\");\nconst txBuild_1 = __webpack_require__(/*! ../txBuild */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js\");\nconst psbtutils_1 = __webpack_require__(/*! ./psbt/psbtutils */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/psbtutils.js\");\nfunction bip0322_hash(message) {\n    const tag = 'BIP0322-signed-message';\n    const tagHash = crypto_lib_1.base.sha256(Buffer.from(tag));\n    const result = crypto_lib_1.base.sha256(Buffer.concat([tagHash, tagHash, Buffer.from(message)]));\n    return crypto_lib_1.base.toHex(result);\n}\nfunction genPsbtOfBIP322Simple({ message, address, network }) {\n    const outputScript = (0, address_1.toOutputScript)(address, network);\n    const addressType = (0, txBuild_1.getAddressType)(address, network);\n    const supportedTypes = [\"segwit_native\", \"segwit_taproot\"];\n    if (supportedTypes.includes(addressType) == false) {\n        throw new Error('Not support address type to sign');\n    }\n    const prevoutHash = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\n    const prevoutIndex = 0xffffffff;\n    const sequence = 0;\n    const scriptSig = Buffer.concat([Buffer.from('0020', 'hex'), Buffer.from(bip0322_hash(message), 'hex')]);\n    const txToSpend = new transaction_1.Transaction();\n    txToSpend.version = 0;\n    txToSpend.addInput(prevoutHash, prevoutIndex, sequence, scriptSig);\n    txToSpend.addOutput(outputScript, 0);\n    const psbtToSign = new psbt_1.Psbt();\n    psbtToSign.setVersion(0);\n    psbtToSign.addInput({\n        hash: txToSpend.getHash(),\n        index: 0,\n        sequence: 0,\n        witnessUtxo: {\n            script: outputScript,\n            value: 0\n        }\n    });\n    psbtToSign.addOutput({ script: Buffer.from('6a', 'hex'), value: 0 });\n    return psbtToSign;\n}\nexports.genPsbtOfBIP322Simple = genPsbtOfBIP322Simple;\nfunction getSignatureFromPsbtOfBIP322Simple(psbt) {\n    const txToSign = psbt.extractTransaction();\n    const len = (0, varuint_1.encode)(txToSign.ins[0].witness.length);\n    function encodeVarString(b) {\n        return Buffer.concat([(0, varuint_1.encode)(b.byteLength), b]);\n    }\n    const result = Buffer.concat([len, ...txToSign.ins[0].witness.map((w) => encodeVarString(w))]);\n    const signature = result.toString('base64');\n    return signature;\n}\nexports.getSignatureFromPsbtOfBIP322Simple = getSignatureFromPsbtOfBIP322Simple;\nasync function signSimple(message, address, privateKey, network) {\n    const outputScript = (0, address_1.toOutputScript)(address, network);\n    const prevoutHash = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\n    const prevoutIndex = 0xffffffff;\n    const sequence = 0;\n    const scriptSig = Buffer.concat([Buffer.from('0020', 'hex'), Buffer.from(bip0322_hash(message), 'hex')]);\n    const txToSpend = new transaction_1.Transaction();\n    txToSpend.version = 0;\n    txToSpend.addInput(prevoutHash, prevoutIndex, sequence, scriptSig);\n    txToSpend.addOutput(outputScript, 0);\n    const psbtToSign = new psbt_1.Psbt({ network });\n    psbtToSign.setVersion(0);\n    psbtToSign.addInput({\n        hash: txToSpend.getHash(),\n        index: 0,\n        sequence: 0,\n        witnessUtxo: {\n            script: outputScript,\n            value: 0\n        },\n    });\n    if ((0, psbtutils_1.isP2TR)(outputScript)) {\n        psbtToSign.updateInput(0, {\n            tapInternalKey: (0, txBuild_1.wif2Public)(privateKey, network).slice(1),\n        });\n    }\n    psbtToSign.addOutput({ script: Buffer.from('6a', 'hex'), value: 0 });\n    (0, psbtSign_1.psbtSignImpl)(psbtToSign, privateKey, network);\n    psbtToSign.finalizeAllInputs();\n    const txToSign = psbtToSign.extractTransaction();\n    function encodeVarString(b) {\n        return Buffer.concat([(0, varuint_1.encode)(b.byteLength), b]);\n    }\n    const len = (0, varuint_1.encode)(txToSign.ins[0].witness.length);\n    const result = Buffer.concat([len, ...txToSign.ins[0].witness.map((w) => encodeVarString(w))]);\n    return crypto_lib_1.base.toBase64(result);\n}\nexports.signSimple = signSimple;\nfunction verifySimple(message, address, witness, publicKey, network) {\n    const outputScript = (0, address_1.toOutputScript)(address, network);\n    const prevoutHash = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\n    const prevoutIndex = 0xffffffff;\n    const sequence = 0;\n    const scriptSig = Buffer.concat([Buffer.from('0020', 'hex'), Buffer.from(bip0322_hash(message), 'hex')]);\n    const txToSpend = new transaction_1.Transaction();\n    txToSpend.version = 0;\n    txToSpend.addInput(prevoutHash, prevoutIndex, sequence, scriptSig);\n    txToSpend.addOutput(outputScript, 0);\n    const psbtToSign = new psbt_1.Psbt();\n    psbtToSign.setVersion(0);\n    psbtToSign.addInput({\n        hash: txToSpend.getHash(),\n        index: 0,\n        sequence: 0,\n        witnessUtxo: {\n            script: outputScript,\n            value: 0\n        },\n    });\n    const pubBuf = crypto_lib_1.base.fromHex(publicKey);\n    if ((0, psbtutils_1.isP2TR)(outputScript)) {\n        psbtToSign.updateInput(0, {\n            tapInternalKey: pubBuf.slice(1),\n        });\n    }\n    psbtToSign.addOutput({ script: Buffer.from('6a', 'hex'), value: 0 });\n    return psbtToSign.verify(pubBuf, Buffer.from(crypto_lib_1.base.fromBase64(witness)));\n}\nexports.verifySimple = verifySimple;\n//# sourceMappingURL=bip0322.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAwMzIyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLDBDQUEwQyxHQUFHLDZCQUE2QjtBQUN0SCxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsMkZBQVc7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsbUdBQWU7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHFGQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDJGQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFhO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLHlHQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsNENBQTRDO0FBQ3ZFO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkIsNENBQTRDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQiw0Q0FBNEM7QUFDdkU7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMDMyMi5qcz9lYzk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJpZnlTaW1wbGUgPSBleHBvcnRzLnNpZ25TaW1wbGUgPSBleHBvcnRzLmdldFNpZ25hdHVyZUZyb21Qc2J0T2ZCSVAzMjJTaW1wbGUgPSBleHBvcnRzLmdlblBzYnRPZkJJUDMyMlNpbXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIi4vYWRkcmVzc1wiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IHBzYnRfMSA9IHJlcXVpcmUoXCIuL3BzYnRcIik7XG5jb25zdCB2YXJ1aW50XzEgPSByZXF1aXJlKFwiLi92YXJ1aW50XCIpO1xuY29uc3QgcHNidFNpZ25fMSA9IHJlcXVpcmUoXCIuLi9wc2J0U2lnblwiKTtcbmNvbnN0IHR4QnVpbGRfMSA9IHJlcXVpcmUoXCIuLi90eEJ1aWxkXCIpO1xuY29uc3QgcHNidHV0aWxzXzEgPSByZXF1aXJlKFwiLi9wc2J0L3BzYnR1dGlsc1wiKTtcbmZ1bmN0aW9uIGJpcDAzMjJfaGFzaChtZXNzYWdlKSB7XG4gICAgY29uc3QgdGFnID0gJ0JJUDAzMjItc2lnbmVkLW1lc3NhZ2UnO1xuICAgIGNvbnN0IHRhZ0hhc2ggPSBjcnlwdG9fbGliXzEuYmFzZS5zaGEyNTYoQnVmZmVyLmZyb20odGFnKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gY3J5cHRvX2xpYl8xLmJhc2Uuc2hhMjU2KEJ1ZmZlci5jb25jYXQoW3RhZ0hhc2gsIHRhZ0hhc2gsIEJ1ZmZlci5mcm9tKG1lc3NhZ2UpXSkpO1xuICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS50b0hleChyZXN1bHQpO1xufVxuZnVuY3Rpb24gZ2VuUHNidE9mQklQMzIyU2ltcGxlKHsgbWVzc2FnZSwgYWRkcmVzcywgbmV0d29yayB9KSB7XG4gICAgY29uc3Qgb3V0cHV0U2NyaXB0ID0gKDAsIGFkZHJlc3NfMS50b091dHB1dFNjcmlwdCkoYWRkcmVzcywgbmV0d29yayk7XG4gICAgY29uc3QgYWRkcmVzc1R5cGUgPSAoMCwgdHhCdWlsZF8xLmdldEFkZHJlc3NUeXBlKShhZGRyZXNzLCBuZXR3b3JrKTtcbiAgICBjb25zdCBzdXBwb3J0ZWRUeXBlcyA9IFtcInNlZ3dpdF9uYXRpdmVcIiwgXCJzZWd3aXRfdGFwcm9vdFwiXTtcbiAgICBpZiAoc3VwcG9ydGVkVHlwZXMuaW5jbHVkZXMoYWRkcmVzc1R5cGUpID09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnQgYWRkcmVzcyB0eXBlIHRvIHNpZ24nKTtcbiAgICB9XG4gICAgY29uc3QgcHJldm91dEhhc2ggPSBCdWZmZXIuZnJvbSgnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsICdoZXgnKTtcbiAgICBjb25zdCBwcmV2b3V0SW5kZXggPSAweGZmZmZmZmZmO1xuICAgIGNvbnN0IHNlcXVlbmNlID0gMDtcbiAgICBjb25zdCBzY3JpcHRTaWcgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnMDAyMCcsICdoZXgnKSwgQnVmZmVyLmZyb20oYmlwMDMyMl9oYXNoKG1lc3NhZ2UpLCAnaGV4JyldKTtcbiAgICBjb25zdCB0eFRvU3BlbmQgPSBuZXcgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbigpO1xuICAgIHR4VG9TcGVuZC52ZXJzaW9uID0gMDtcbiAgICB0eFRvU3BlbmQuYWRkSW5wdXQocHJldm91dEhhc2gsIHByZXZvdXRJbmRleCwgc2VxdWVuY2UsIHNjcmlwdFNpZyk7XG4gICAgdHhUb1NwZW5kLmFkZE91dHB1dChvdXRwdXRTY3JpcHQsIDApO1xuICAgIGNvbnN0IHBzYnRUb1NpZ24gPSBuZXcgcHNidF8xLlBzYnQoKTtcbiAgICBwc2J0VG9TaWduLnNldFZlcnNpb24oMCk7XG4gICAgcHNidFRvU2lnbi5hZGRJbnB1dCh7XG4gICAgICAgIGhhc2g6IHR4VG9TcGVuZC5nZXRIYXNoKCksXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBzZXF1ZW5jZTogMCxcbiAgICAgICAgd2l0bmVzc1V0eG86IHtcbiAgICAgICAgICAgIHNjcmlwdDogb3V0cHV0U2NyaXB0LFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHBzYnRUb1NpZ24uYWRkT3V0cHV0KHsgc2NyaXB0OiBCdWZmZXIuZnJvbSgnNmEnLCAnaGV4JyksIHZhbHVlOiAwIH0pO1xuICAgIHJldHVybiBwc2J0VG9TaWduO1xufVxuZXhwb3J0cy5nZW5Qc2J0T2ZCSVAzMjJTaW1wbGUgPSBnZW5Qc2J0T2ZCSVAzMjJTaW1wbGU7XG5mdW5jdGlvbiBnZXRTaWduYXR1cmVGcm9tUHNidE9mQklQMzIyU2ltcGxlKHBzYnQpIHtcbiAgICBjb25zdCB0eFRvU2lnbiA9IHBzYnQuZXh0cmFjdFRyYW5zYWN0aW9uKCk7XG4gICAgY29uc3QgbGVuID0gKDAsIHZhcnVpbnRfMS5lbmNvZGUpKHR4VG9TaWduLmluc1swXS53aXRuZXNzLmxlbmd0aCk7XG4gICAgZnVuY3Rpb24gZW5jb2RlVmFyU3RyaW5nKGIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoWygwLCB2YXJ1aW50XzEuZW5jb2RlKShiLmJ5dGVMZW5ndGgpLCBiXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW2xlbiwgLi4udHhUb1NpZ24uaW5zWzBdLndpdG5lc3MubWFwKCh3KSA9PiBlbmNvZGVWYXJTdHJpbmcodykpXSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gcmVzdWx0LnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlO1xufVxuZXhwb3J0cy5nZXRTaWduYXR1cmVGcm9tUHNidE9mQklQMzIyU2ltcGxlID0gZ2V0U2lnbmF0dXJlRnJvbVBzYnRPZkJJUDMyMlNpbXBsZTtcbmFzeW5jIGZ1bmN0aW9uIHNpZ25TaW1wbGUobWVzc2FnZSwgYWRkcmVzcywgcHJpdmF0ZUtleSwgbmV0d29yaykge1xuICAgIGNvbnN0IG91dHB1dFNjcmlwdCA9ICgwLCBhZGRyZXNzXzEudG9PdXRwdXRTY3JpcHQpKGFkZHJlc3MsIG5ldHdvcmspO1xuICAgIGNvbnN0IHByZXZvdXRIYXNoID0gQnVmZmVyLmZyb20oJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAnaGV4Jyk7XG4gICAgY29uc3QgcHJldm91dEluZGV4ID0gMHhmZmZmZmZmZjtcbiAgICBjb25zdCBzZXF1ZW5jZSA9IDA7XG4gICAgY29uc3Qgc2NyaXB0U2lnID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oJzAwMjAnLCAnaGV4JyksIEJ1ZmZlci5mcm9tKGJpcDAzMjJfaGFzaChtZXNzYWdlKSwgJ2hleCcpXSk7XG4gICAgY29uc3QgdHhUb1NwZW5kID0gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24oKTtcbiAgICB0eFRvU3BlbmQudmVyc2lvbiA9IDA7XG4gICAgdHhUb1NwZW5kLmFkZElucHV0KHByZXZvdXRIYXNoLCBwcmV2b3V0SW5kZXgsIHNlcXVlbmNlLCBzY3JpcHRTaWcpO1xuICAgIHR4VG9TcGVuZC5hZGRPdXRwdXQob3V0cHV0U2NyaXB0LCAwKTtcbiAgICBjb25zdCBwc2J0VG9TaWduID0gbmV3IHBzYnRfMS5Qc2J0KHsgbmV0d29yayB9KTtcbiAgICBwc2J0VG9TaWduLnNldFZlcnNpb24oMCk7XG4gICAgcHNidFRvU2lnbi5hZGRJbnB1dCh7XG4gICAgICAgIGhhc2g6IHR4VG9TcGVuZC5nZXRIYXNoKCksXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBzZXF1ZW5jZTogMCxcbiAgICAgICAgd2l0bmVzc1V0eG86IHtcbiAgICAgICAgICAgIHNjcmlwdDogb3V0cHV0U2NyaXB0LFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJUUikob3V0cHV0U2NyaXB0KSkge1xuICAgICAgICBwc2J0VG9TaWduLnVwZGF0ZUlucHV0KDAsIHtcbiAgICAgICAgICAgIHRhcEludGVybmFsS2V5OiAoMCwgdHhCdWlsZF8xLndpZjJQdWJsaWMpKHByaXZhdGVLZXksIG5ldHdvcmspLnNsaWNlKDEpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHNidFRvU2lnbi5hZGRPdXRwdXQoeyBzY3JpcHQ6IEJ1ZmZlci5mcm9tKCc2YScsICdoZXgnKSwgdmFsdWU6IDAgfSk7XG4gICAgKDAsIHBzYnRTaWduXzEucHNidFNpZ25JbXBsKShwc2J0VG9TaWduLCBwcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICBwc2J0VG9TaWduLmZpbmFsaXplQWxsSW5wdXRzKCk7XG4gICAgY29uc3QgdHhUb1NpZ24gPSBwc2J0VG9TaWduLmV4dHJhY3RUcmFuc2FjdGlvbigpO1xuICAgIGZ1bmN0aW9uIGVuY29kZVZhclN0cmluZyhiKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFsoMCwgdmFydWludF8xLmVuY29kZSkoYi5ieXRlTGVuZ3RoKSwgYl0pO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSAoMCwgdmFydWludF8xLmVuY29kZSkodHhUb1NpZ24uaW5zWzBdLndpdG5lc3MubGVuZ3RoKTtcbiAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuY29uY2F0KFtsZW4sIC4uLnR4VG9TaWduLmluc1swXS53aXRuZXNzLm1hcCgodykgPT4gZW5jb2RlVmFyU3RyaW5nKHcpKV0pO1xuICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS50b0Jhc2U2NChyZXN1bHQpO1xufVxuZXhwb3J0cy5zaWduU2ltcGxlID0gc2lnblNpbXBsZTtcbmZ1bmN0aW9uIHZlcmlmeVNpbXBsZShtZXNzYWdlLCBhZGRyZXNzLCB3aXRuZXNzLCBwdWJsaWNLZXksIG5ldHdvcmspIHtcbiAgICBjb25zdCBvdXRwdXRTY3JpcHQgPSAoMCwgYWRkcmVzc18xLnRvT3V0cHV0U2NyaXB0KShhZGRyZXNzLCBuZXR3b3JrKTtcbiAgICBjb25zdCBwcmV2b3V0SGFzaCA9IEJ1ZmZlci5mcm9tKCcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgJ2hleCcpO1xuICAgIGNvbnN0IHByZXZvdXRJbmRleCA9IDB4ZmZmZmZmZmY7XG4gICAgY29uc3Qgc2VxdWVuY2UgPSAwO1xuICAgIGNvbnN0IHNjcmlwdFNpZyA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCcwMDIwJywgJ2hleCcpLCBCdWZmZXIuZnJvbShiaXAwMzIyX2hhc2gobWVzc2FnZSksICdoZXgnKV0pO1xuICAgIGNvbnN0IHR4VG9TcGVuZCA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKCk7XG4gICAgdHhUb1NwZW5kLnZlcnNpb24gPSAwO1xuICAgIHR4VG9TcGVuZC5hZGRJbnB1dChwcmV2b3V0SGFzaCwgcHJldm91dEluZGV4LCBzZXF1ZW5jZSwgc2NyaXB0U2lnKTtcbiAgICB0eFRvU3BlbmQuYWRkT3V0cHV0KG91dHB1dFNjcmlwdCwgMCk7XG4gICAgY29uc3QgcHNidFRvU2lnbiA9IG5ldyBwc2J0XzEuUHNidCgpO1xuICAgIHBzYnRUb1NpZ24uc2V0VmVyc2lvbigwKTtcbiAgICBwc2J0VG9TaWduLmFkZElucHV0KHtcbiAgICAgICAgaGFzaDogdHhUb1NwZW5kLmdldEhhc2goKSxcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIHNlcXVlbmNlOiAwLFxuICAgICAgICB3aXRuZXNzVXR4bzoge1xuICAgICAgICAgICAgc2NyaXB0OiBvdXRwdXRTY3JpcHQsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHB1YkJ1ZiA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgocHVibGljS2V5KTtcbiAgICBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJUUikob3V0cHV0U2NyaXB0KSkge1xuICAgICAgICBwc2J0VG9TaWduLnVwZGF0ZUlucHV0KDAsIHtcbiAgICAgICAgICAgIHRhcEludGVybmFsS2V5OiBwdWJCdWYuc2xpY2UoMSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwc2J0VG9TaWduLmFkZE91dHB1dCh7IHNjcmlwdDogQnVmZmVyLmZyb20oJzZhJywgJ2hleCcpLCB2YWx1ZTogMCB9KTtcbiAgICByZXR1cm4gcHNidFRvU2lnbi52ZXJpZnkocHViQnVmLCBCdWZmZXIuZnJvbShjcnlwdG9fbGliXzEuYmFzZS5mcm9tQmFzZTY0KHdpdG5lc3MpKSk7XG59XG5leHBvcnRzLnZlcmlmeVNpbXBsZSA9IHZlcmlmeVNpbXBsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpcDAzMjIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip0322.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/combiner/index.js':
    /*!****************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/combiner/index.js ***!
  \****************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.combine = void 0;\nconst parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/index.js\");\nfunction combine(psbts) {\n    const self = psbts[0];\n    const selfKeyVals = (0, parser_1.psbtToKeyVals)(self);\n    const others = psbts.slice(1);\n    if (others.length === 0)\n        throw new Error('Combine: Nothing to combine');\n    const selfTx = getTx(self);\n    if (selfTx === undefined) {\n        throw new Error('Combine: Self missing transaction');\n    }\n    const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n    const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n    const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n    for (const other of others) {\n        const otherTx = getTx(other);\n        if (otherTx === undefined ||\n            !otherTx.toBuffer().equals(selfTx.toBuffer())) {\n            throw new Error('Combine: One of the Psbts does not have the same transaction.');\n        }\n        const otherKeyVals = (0, parser_1.psbtToKeyVals)(other);\n        const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n        otherGlobalSet.forEach(keyPusher(selfGlobalSet, selfKeyVals.globalKeyVals, otherKeyVals.globalKeyVals));\n        const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n        otherInputSets.forEach((inputSet, idx) => inputSet.forEach(keyPusher(selfInputSets[idx], selfKeyVals.inputKeyVals[idx], otherKeyVals.inputKeyVals[idx])));\n        const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n        otherOutputSets.forEach((outputSet, idx) => outputSet.forEach(keyPusher(selfOutputSets[idx], selfKeyVals.outputKeyVals[idx], otherKeyVals.outputKeyVals[idx])));\n    }\n    return (0, parser_1.psbtFromKeyVals)(selfTx, {\n        globalMapKeyVals: selfKeyVals.globalKeyVals,\n        inputKeyVals: selfKeyVals.inputKeyVals,\n        outputKeyVals: selfKeyVals.outputKeyVals,\n    });\n}\nexports.combine = combine;\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n    return (key) => {\n        if (selfSet.has(key))\n            return;\n        const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];\n        selfKeyVals.push(newKv);\n        selfSet.add(key);\n    };\n}\nfunction getTx(psbt) {\n    return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n    const set = new Set();\n    keyVals.forEach(keyVal => {\n        const hex = keyVal.key.toString('hex');\n        if (set.has(hex))\n            throw new Error('Combine: KeyValue Map keys should be unique');\n        set.add(hex);\n    });\n    return set;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29tYmluZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGlCQUFpQixtQkFBTyxDQUFDLHVHQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L2NvbWJpbmVyL2luZGV4LmpzPzRhYTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbWJpbmUgPSB2b2lkIDA7XG5jb25zdCBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJcIik7XG5mdW5jdGlvbiBjb21iaW5lKHBzYnRzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHBzYnRzWzBdO1xuICAgIGNvbnN0IHNlbGZLZXlWYWxzID0gKDAsIHBhcnNlcl8xLnBzYnRUb0tleVZhbHMpKHNlbGYpO1xuICAgIGNvbnN0IG90aGVycyA9IHBzYnRzLnNsaWNlKDEpO1xuICAgIGlmIChvdGhlcnMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbWJpbmU6IE5vdGhpbmcgdG8gY29tYmluZScpO1xuICAgIGNvbnN0IHNlbGZUeCA9IGdldFR4KHNlbGYpO1xuICAgIGlmIChzZWxmVHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbWJpbmU6IFNlbGYgbWlzc2luZyB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBzZWxmR2xvYmFsU2V0ID0gZ2V0S2V5U2V0KHNlbGZLZXlWYWxzLmdsb2JhbEtleVZhbHMpO1xuICAgIGNvbnN0IHNlbGZJbnB1dFNldHMgPSBzZWxmS2V5VmFscy5pbnB1dEtleVZhbHMubWFwKGdldEtleVNldCk7XG4gICAgY29uc3Qgc2VsZk91dHB1dFNldHMgPSBzZWxmS2V5VmFscy5vdXRwdXRLZXlWYWxzLm1hcChnZXRLZXlTZXQpO1xuICAgIGZvciAoY29uc3Qgb3RoZXIgb2Ygb3RoZXJzKSB7XG4gICAgICAgIGNvbnN0IG90aGVyVHggPSBnZXRUeChvdGhlcik7XG4gICAgICAgIGlmIChvdGhlclR4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICFvdGhlclR4LnRvQnVmZmVyKCkuZXF1YWxzKHNlbGZUeC50b0J1ZmZlcigpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21iaW5lOiBPbmUgb2YgdGhlIFBzYnRzIGRvZXMgbm90IGhhdmUgdGhlIHNhbWUgdHJhbnNhY3Rpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3RoZXJLZXlWYWxzID0gKDAsIHBhcnNlcl8xLnBzYnRUb0tleVZhbHMpKG90aGVyKTtcbiAgICAgICAgY29uc3Qgb3RoZXJHbG9iYWxTZXQgPSBnZXRLZXlTZXQob3RoZXJLZXlWYWxzLmdsb2JhbEtleVZhbHMpO1xuICAgICAgICBvdGhlckdsb2JhbFNldC5mb3JFYWNoKGtleVB1c2hlcihzZWxmR2xvYmFsU2V0LCBzZWxmS2V5VmFscy5nbG9iYWxLZXlWYWxzLCBvdGhlcktleVZhbHMuZ2xvYmFsS2V5VmFscykpO1xuICAgICAgICBjb25zdCBvdGhlcklucHV0U2V0cyA9IG90aGVyS2V5VmFscy5pbnB1dEtleVZhbHMubWFwKGdldEtleVNldCk7XG4gICAgICAgIG90aGVySW5wdXRTZXRzLmZvckVhY2goKGlucHV0U2V0LCBpZHgpID0+IGlucHV0U2V0LmZvckVhY2goa2V5UHVzaGVyKHNlbGZJbnB1dFNldHNbaWR4XSwgc2VsZktleVZhbHMuaW5wdXRLZXlWYWxzW2lkeF0sIG90aGVyS2V5VmFscy5pbnB1dEtleVZhbHNbaWR4XSkpKTtcbiAgICAgICAgY29uc3Qgb3RoZXJPdXRwdXRTZXRzID0gb3RoZXJLZXlWYWxzLm91dHB1dEtleVZhbHMubWFwKGdldEtleVNldCk7XG4gICAgICAgIG90aGVyT3V0cHV0U2V0cy5mb3JFYWNoKChvdXRwdXRTZXQsIGlkeCkgPT4gb3V0cHV0U2V0LmZvckVhY2goa2V5UHVzaGVyKHNlbGZPdXRwdXRTZXRzW2lkeF0sIHNlbGZLZXlWYWxzLm91dHB1dEtleVZhbHNbaWR4XSwgb3RoZXJLZXlWYWxzLm91dHB1dEtleVZhbHNbaWR4XSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBwYXJzZXJfMS5wc2J0RnJvbUtleVZhbHMpKHNlbGZUeCwge1xuICAgICAgICBnbG9iYWxNYXBLZXlWYWxzOiBzZWxmS2V5VmFscy5nbG9iYWxLZXlWYWxzLFxuICAgICAgICBpbnB1dEtleVZhbHM6IHNlbGZLZXlWYWxzLmlucHV0S2V5VmFscyxcbiAgICAgICAgb3V0cHV0S2V5VmFsczogc2VsZktleVZhbHMub3V0cHV0S2V5VmFscyxcbiAgICB9KTtcbn1cbmV4cG9ydHMuY29tYmluZSA9IGNvbWJpbmU7XG5mdW5jdGlvbiBrZXlQdXNoZXIoc2VsZlNldCwgc2VsZktleVZhbHMsIG90aGVyS2V5VmFscykge1xuICAgIHJldHVybiAoa2V5KSA9PiB7XG4gICAgICAgIGlmIChzZWxmU2V0LmhhcyhrZXkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXdLdiA9IG90aGVyS2V5VmFscy5maWx0ZXIoa3YgPT4ga3Yua2V5LnRvU3RyaW5nKCdoZXgnKSA9PT0ga2V5KVswXTtcbiAgICAgICAgc2VsZktleVZhbHMucHVzaChuZXdLdik7XG4gICAgICAgIHNlbGZTZXQuYWRkKGtleSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFR4KHBzYnQpIHtcbiAgICByZXR1cm4gcHNidC5nbG9iYWxNYXAudW5zaWduZWRUeDtcbn1cbmZ1bmN0aW9uIGdldEtleVNldChrZXlWYWxzKSB7XG4gICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICAgIGtleVZhbHMuZm9yRWFjaChrZXlWYWwgPT4ge1xuICAgICAgICBjb25zdCBoZXggPSBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgaWYgKHNldC5oYXMoaGV4KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tYmluZTogS2V5VmFsdWUgTWFwIGtleXMgc2hvdWxkIGJlIHVuaXF1ZScpO1xuICAgICAgICBzZXQuYWRkKGhleCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/combiner/index.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/global/globalXpub.js':
    /*!*****************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/global/globalXpub.js ***!
  \*****************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAddToArray = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nconst range = (n) => [...Array(n).keys()];\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {\n        throw new Error('Decode Error: could not decode globalXpub with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {\n        throw new Error('Decode Error: globalXpub has invalid extended pubkey in key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n        throw new Error('Decode Error: Global GLOBAL_XPUB value length should be multiple of 4');\n    }\n    const extendedPubkey = keyVal.key.slice(1);\n    const data = {\n        masterFingerprint: keyVal.value.slice(0, 4),\n        extendedPubkey,\n        path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n        const val = keyVal.value.readUInt32LE(i * 4 + 4);\n        const isHard = !!(val & 0x80000000);\n        const idx = val & 0x7fffffff;\n        data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n}\nexports.decode = decode;\nfunction encode(data) {\n    const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);\n    const key = Buffer.concat([head, data.extendedPubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n        const isHard = level.slice(-1) === \"'\";\n        let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n        if (isHard)\n            num += 0x80000000;\n        value.writeUInt32LE(num, offset);\n        offset += 4;\n    });\n    return {\n        key,\n        value,\n    };\n}\nexports.encode = encode;\nexports.expected = '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';\nfunction check(data) {\n    const epk = data.extendedPubkey;\n    const mfp = data.masterFingerprint;\n    const p = data.path;\n    return (Buffer.isBuffer(epk) &&\n        epk.length === 78 &&\n        [2, 3].indexOf(epk[45]) > -1 &&\n        Buffer.isBuffer(mfp) &&\n        mfp.length === 4 &&\n        typeof p === 'string' &&\n        !!p.match(/^m(\\/\\d+'?)*$/));\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n    const dupeString = item.extendedPubkey.toString('hex');\n    if (dupeSet.has(dupeString))\n        return false;\n    dupeSet.add(dupeString);\n    return (array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0);\n}\nexports.canAddToArray = canAddToArray;\n//# sourceMappingURL=globalXpub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2dsb2JhbC9nbG9iYWxYcHViLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUMxRixxQkFBcUIsbUJBQU8sQ0FBQyw0R0FBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsTUFBTSwyQkFBMkIsd0JBQXdCLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2dsb2JhbC9nbG9iYWxYcHViLmpzPzdmOGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbkFkZFRvQXJyYXkgPSBleHBvcnRzLmNoZWNrID0gZXhwb3J0cy5leHBlY3RlZCA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZUZpZWxkc1wiKTtcbmNvbnN0IHJhbmdlID0gKG4pID0+IFsuLi5BcnJheShuKS5rZXlzKCldO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuR0xPQkFMX1hQVUIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgZ2xvYmFsWHB1YiB3aXRoIGtleSAweCcgK1xuICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgIH1cbiAgICBpZiAoa2V5VmFsLmtleS5sZW5ndGggIT09IDc5IHx8ICFbMiwgM10uaW5jbHVkZXMoa2V5VmFsLmtleVs0Nl0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiBnbG9iYWxYcHViIGhhcyBpbnZhbGlkIGV4dGVuZGVkIHB1YmtleSBpbiBrZXkgMHgnICtcbiAgICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICB9XG4gICAgaWYgKChrZXlWYWwudmFsdWUubGVuZ3RoIC8gNCkgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiBHbG9iYWwgR0xPQkFMX1hQVUIgdmFsdWUgbGVuZ3RoIHNob3VsZCBiZSBtdWx0aXBsZSBvZiA0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkUHVia2V5ID0ga2V5VmFsLmtleS5zbGljZSgxKTtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBtYXN0ZXJGaW5nZXJwcmludDoga2V5VmFsLnZhbHVlLnNsaWNlKDAsIDQpLFxuICAgICAgICBleHRlbmRlZFB1YmtleSxcbiAgICAgICAgcGF0aDogJ20nLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKGtleVZhbC52YWx1ZS5sZW5ndGggLyA0IC0gMSkpIHtcbiAgICAgICAgY29uc3QgdmFsID0ga2V5VmFsLnZhbHVlLnJlYWRVSW50MzJMRShpICogNCArIDQpO1xuICAgICAgICBjb25zdCBpc0hhcmQgPSAhISh2YWwgJiAweDgwMDAwMDAwKTtcbiAgICAgICAgY29uc3QgaWR4ID0gdmFsICYgMHg3ZmZmZmZmZjtcbiAgICAgICAgZGF0YS5wYXRoICs9ICcvJyArIGlkeC50b1N0cmluZygxMCkgKyAoaXNIYXJkID8gXCInXCIgOiAnJyk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLkdMT0JBTF9YUFVCXSk7XG4gICAgY29uc3Qga2V5ID0gQnVmZmVyLmNvbmNhdChbaGVhZCwgZGF0YS5leHRlbmRlZFB1YmtleV0pO1xuICAgIGNvbnN0IHNwbGl0UGF0aCA9IGRhdGEucGF0aC5zcGxpdCgnLycpO1xuICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNwbGl0UGF0aC5sZW5ndGggKiA0KTtcbiAgICBkYXRhLm1hc3RlckZpbmdlcnByaW50LmNvcHkodmFsdWUsIDApO1xuICAgIGxldCBvZmZzZXQgPSA0O1xuICAgIHNwbGl0UGF0aC5zbGljZSgxKS5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgY29uc3QgaXNIYXJkID0gbGV2ZWwuc2xpY2UoLTEpID09PSBcIidcIjtcbiAgICAgICAgbGV0IG51bSA9IDB4N2ZmZmZmZmYgJiBwYXJzZUludChpc0hhcmQgPyBsZXZlbC5zbGljZSgwLCAtMSkgOiBsZXZlbCwgMTApO1xuICAgICAgICBpZiAoaXNIYXJkKVxuICAgICAgICAgICAgbnVtICs9IDB4ODAwMDAwMDA7XG4gICAgICAgIHZhbHVlLndyaXRlVUludDMyTEUobnVtLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlLFxuICAgIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAneyBtYXN0ZXJGaW5nZXJwcmludDogQnVmZmVyOyBleHRlbmRlZFB1YmtleTogQnVmZmVyOyBwYXRoOiBzdHJpbmc7IH0nO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgIGNvbnN0IGVwayA9IGRhdGEuZXh0ZW5kZWRQdWJrZXk7XG4gICAgY29uc3QgbWZwID0gZGF0YS5tYXN0ZXJGaW5nZXJwcmludDtcbiAgICBjb25zdCBwID0gZGF0YS5wYXRoO1xuICAgIHJldHVybiAoQnVmZmVyLmlzQnVmZmVyKGVwaykgJiZcbiAgICAgICAgZXBrLmxlbmd0aCA9PT0gNzggJiZcbiAgICAgICAgWzIsIDNdLmluZGV4T2YoZXBrWzQ1XSkgPiAtMSAmJlxuICAgICAgICBCdWZmZXIuaXNCdWZmZXIobWZwKSAmJlxuICAgICAgICBtZnAubGVuZ3RoID09PSA0ICYmXG4gICAgICAgIHR5cGVvZiBwID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAhIXAubWF0Y2goL15tKFxcL1xcZCsnPykqJC8pKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZFRvQXJyYXkoYXJyYXksIGl0ZW0sIGR1cGVTZXQpIHtcbiAgICBjb25zdCBkdXBlU3RyaW5nID0gaXRlbS5leHRlbmRlZFB1YmtleS50b1N0cmluZygnaGV4Jyk7XG4gICAgaWYgKGR1cGVTZXQuaGFzKGR1cGVTdHJpbmcpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZHVwZVNldC5hZGQoZHVwZVN0cmluZyk7XG4gICAgcmV0dXJuIChhcnJheS5maWx0ZXIodiA9PiB2LmV4dGVuZGVkUHVia2V5LmVxdWFscyhpdGVtLmV4dGVuZGVkUHVia2V5KSkubGVuZ3RoID09PSAwKTtcbn1cbmV4cG9ydHMuY2FuQWRkVG9BcnJheSA9IGNhbkFkZFRvQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxYcHViLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/global/globalXpub.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/global/unsignedTx.js':
    /*!*****************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/global/unsignedTx.js ***!
  \*****************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js");\nfunction encode(data) {\n    return {\n        key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),\n        value: data.toBuffer(),\n    };\n}\nexports.encode = encode;\n//# sourceMappingURL=unsignedTx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2dsb2JhbC91bnNpZ25lZFR4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxxQkFBcUIsbUJBQU8sQ0FBQyw0R0FBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2dsb2JhbC91bnNpZ25lZFR4LmpzPzUwZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlRmllbGRzXCIpO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuVU5TSUdORURfVFhdKSxcbiAgICAgICAgdmFsdWU6IGRhdGEudG9CdWZmZXIoKSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bnNpZ25lZFR4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/global/unsignedTx.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/index.js':
    /*!*****************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/index.js ***!
  \*****************************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.outputs = exports.inputs = exports.globals = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../typeFields */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js");\nconst globalXpub = __importStar(__webpack_require__(/*! ./global/globalXpub */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/global/globalXpub.js"));\nconst unsignedTx = __importStar(__webpack_require__(/*! ./global/unsignedTx */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/global/unsignedTx.js"));\nconst finalScriptSig = __importStar(__webpack_require__(/*! ./input/finalScriptSig */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/finalScriptSig.js"));\nconst finalScriptWitness = __importStar(__webpack_require__(/*! ./input/finalScriptWitness */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/finalScriptWitness.js"));\nconst nonWitnessUtxo = __importStar(__webpack_require__(/*! ./input/nonWitnessUtxo */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/nonWitnessUtxo.js"));\nconst partialSig = __importStar(__webpack_require__(/*! ./input/partialSig */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/partialSig.js"));\nconst porCommitment = __importStar(__webpack_require__(/*! ./input/porCommitment */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/porCommitment.js"));\nconst sighashType = __importStar(__webpack_require__(/*! ./input/sighashType */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/sighashType.js"));\nconst tapKeySig = __importStar(__webpack_require__(/*! ./input/tapKeySig */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapKeySig.js"));\nconst tapLeafScript = __importStar(__webpack_require__(/*! ./input/tapLeafScript */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapLeafScript.js"));\nconst tapMerkleRoot = __importStar(__webpack_require__(/*! ./input/tapMerkleRoot */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapMerkleRoot.js"));\nconst tapScriptSig = __importStar(__webpack_require__(/*! ./input/tapScriptSig */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapScriptSig.js"));\nconst witnessUtxo = __importStar(__webpack_require__(/*! ./input/witnessUtxo */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/witnessUtxo.js"));\nconst tapTree = __importStar(__webpack_require__(/*! ./output/tapTree */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/output/tapTree.js"));\nconst bip32Derivation = __importStar(__webpack_require__(/*! ./shared/bip32Derivation */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/bip32Derivation.js"));\nconst checkPubkey = __importStar(__webpack_require__(/*! ./shared/checkPubkey */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/checkPubkey.js"));\nconst redeemScript = __importStar(__webpack_require__(/*! ./shared/redeemScript */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/redeemScript.js"));\nconst tapBip32Derivation = __importStar(__webpack_require__(/*! ./shared/tapBip32Derivation */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/tapBip32Derivation.js"));\nconst tapInternalKey = __importStar(__webpack_require__(/*! ./shared/tapInternalKey */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/tapInternalKey.js"));\nconst witnessScript = __importStar(__webpack_require__(/*! ./shared/witnessScript */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/witnessScript.js"));\nconst globals = {\n    unsignedTx,\n    globalXpub,\n    checkPubkey: checkPubkey.makeChecker([]),\n};\nexports.globals = globals;\nconst inputs = {\n    nonWitnessUtxo,\n    partialSig,\n    sighashType,\n    finalScriptSig,\n    finalScriptWitness,\n    porCommitment,\n    witnessUtxo,\n    bip32Derivation: bip32Derivation.makeConverter(typeFields_1.InputTypes.BIP32_DERIVATION),\n    redeemScript: redeemScript.makeConverter(typeFields_1.InputTypes.REDEEM_SCRIPT),\n    witnessScript: witnessScript.makeConverter(typeFields_1.InputTypes.WITNESS_SCRIPT),\n    checkPubkey: checkPubkey.makeChecker([\n        typeFields_1.InputTypes.PARTIAL_SIG,\n        typeFields_1.InputTypes.BIP32_DERIVATION,\n    ]),\n    tapKeySig,\n    tapScriptSig,\n    tapLeafScript,\n    tapBip32Derivation: tapBip32Derivation.makeConverter(typeFields_1.InputTypes.TAP_BIP32_DERIVATION),\n    tapInternalKey: tapInternalKey.makeConverter(typeFields_1.InputTypes.TAP_INTERNAL_KEY),\n    tapMerkleRoot,\n};\nexports.inputs = inputs;\nconst outputs = {\n    bip32Derivation: bip32Derivation.makeConverter(typeFields_1.OutputTypes.BIP32_DERIVATION),\n    redeemScript: redeemScript.makeConverter(typeFields_1.OutputTypes.REDEEM_SCRIPT),\n    witnessScript: witnessScript.makeConverter(typeFields_1.OutputTypes.WITNESS_SCRIPT),\n    checkPubkey: checkPubkey.makeChecker([typeFields_1.OutputTypes.BIP32_DERIVATION]),\n    tapBip32Derivation: tapBip32Derivation.makeConverter(typeFields_1.OutputTypes.TAP_BIP32_DERIVATION),\n    tapTree,\n    tapInternalKey: tapInternalKey.makeConverter(typeFields_1.OutputTypes.TAP_INTERNAL_KEY),\n};\nexports.outputs = outputs;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsY0FBYyxHQUFHLGVBQWU7QUFDbEQscUJBQXFCLG1CQUFPLENBQUMseUdBQWU7QUFDNUMsZ0NBQWdDLG1CQUFPLENBQUMsZ0lBQXFCO0FBQzdELGdDQUFnQyxtQkFBTyxDQUFDLGdJQUFxQjtBQUM3RCxvQ0FBb0MsbUJBQU8sQ0FBQyxzSUFBd0I7QUFDcEUsd0NBQXdDLG1CQUFPLENBQUMsOElBQTRCO0FBQzVFLG9DQUFvQyxtQkFBTyxDQUFDLHNJQUF3QjtBQUNwRSxnQ0FBZ0MsbUJBQU8sQ0FBQyw4SEFBb0I7QUFDNUQsbUNBQW1DLG1CQUFPLENBQUMsb0lBQXVCO0FBQ2xFLGlDQUFpQyxtQkFBTyxDQUFDLGdJQUFxQjtBQUM5RCwrQkFBK0IsbUJBQU8sQ0FBQyw0SEFBbUI7QUFDMUQsbUNBQW1DLG1CQUFPLENBQUMsb0lBQXVCO0FBQ2xFLG1DQUFtQyxtQkFBTyxDQUFDLG9JQUF1QjtBQUNsRSxrQ0FBa0MsbUJBQU8sQ0FBQyxrSUFBc0I7QUFDaEUsaUNBQWlDLG1CQUFPLENBQUMsZ0lBQXFCO0FBQzlELDZCQUE2QixtQkFBTyxDQUFDLDBIQUFrQjtBQUN2RCxxQ0FBcUMsbUJBQU8sQ0FBQywwSUFBMEI7QUFDdkUsaUNBQWlDLG1CQUFPLENBQUMsa0lBQXNCO0FBQy9ELGtDQUFrQyxtQkFBTyxDQUFDLG9JQUF1QjtBQUNqRSx3Q0FBd0MsbUJBQU8sQ0FBQyxnSkFBNkI7QUFDN0Usb0NBQW9DLG1CQUFPLENBQUMsd0lBQXlCO0FBQ3JFLG1DQUFtQyxtQkFBTyxDQUFDLHNJQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L2NvbnZlcnRlci9pbmRleC5qcz81NmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm91dHB1dHMgPSBleHBvcnRzLmlucHV0cyA9IGV4cG9ydHMuZ2xvYmFscyA9IHZvaWQgMDtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoXCIuLi90eXBlRmllbGRzXCIpO1xuY29uc3QgZ2xvYmFsWHB1YiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9nbG9iYWwvZ2xvYmFsWHB1YlwiKSk7XG5jb25zdCB1bnNpZ25lZFR4ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2dsb2JhbC91bnNpZ25lZFR4XCIpKTtcbmNvbnN0IGZpbmFsU2NyaXB0U2lnID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2lucHV0L2ZpbmFsU2NyaXB0U2lnXCIpKTtcbmNvbnN0IGZpbmFsU2NyaXB0V2l0bmVzcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnB1dC9maW5hbFNjcmlwdFdpdG5lc3NcIikpO1xuY29uc3Qgbm9uV2l0bmVzc1V0eG8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW5wdXQvbm9uV2l0bmVzc1V0eG9cIikpO1xuY29uc3QgcGFydGlhbFNpZyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnB1dC9wYXJ0aWFsU2lnXCIpKTtcbmNvbnN0IHBvckNvbW1pdG1lbnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW5wdXQvcG9yQ29tbWl0bWVudFwiKSk7XG5jb25zdCBzaWdoYXNoVHlwZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnB1dC9zaWdoYXNoVHlwZVwiKSk7XG5jb25zdCB0YXBLZXlTaWcgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW5wdXQvdGFwS2V5U2lnXCIpKTtcbmNvbnN0IHRhcExlYWZTY3JpcHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW5wdXQvdGFwTGVhZlNjcmlwdFwiKSk7XG5jb25zdCB0YXBNZXJrbGVSb290ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2lucHV0L3RhcE1lcmtsZVJvb3RcIikpO1xuY29uc3QgdGFwU2NyaXB0U2lnID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2lucHV0L3RhcFNjcmlwdFNpZ1wiKSk7XG5jb25zdCB3aXRuZXNzVXR4byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnB1dC93aXRuZXNzVXR4b1wiKSk7XG5jb25zdCB0YXBUcmVlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL291dHB1dC90YXBUcmVlXCIpKTtcbmNvbnN0IGJpcDMyRGVyaXZhdGlvbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zaGFyZWQvYmlwMzJEZXJpdmF0aW9uXCIpKTtcbmNvbnN0IGNoZWNrUHVia2V5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NoYXJlZC9jaGVja1B1YmtleVwiKSk7XG5jb25zdCByZWRlZW1TY3JpcHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2hhcmVkL3JlZGVlbVNjcmlwdFwiKSk7XG5jb25zdCB0YXBCaXAzMkRlcml2YXRpb24gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2hhcmVkL3RhcEJpcDMyRGVyaXZhdGlvblwiKSk7XG5jb25zdCB0YXBJbnRlcm5hbEtleSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zaGFyZWQvdGFwSW50ZXJuYWxLZXlcIikpO1xuY29uc3Qgd2l0bmVzc1NjcmlwdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zaGFyZWQvd2l0bmVzc1NjcmlwdFwiKSk7XG5jb25zdCBnbG9iYWxzID0ge1xuICAgIHVuc2lnbmVkVHgsXG4gICAgZ2xvYmFsWHB1YixcbiAgICBjaGVja1B1YmtleTogY2hlY2tQdWJrZXkubWFrZUNoZWNrZXIoW10pLFxufTtcbmV4cG9ydHMuZ2xvYmFscyA9IGdsb2JhbHM7XG5jb25zdCBpbnB1dHMgPSB7XG4gICAgbm9uV2l0bmVzc1V0eG8sXG4gICAgcGFydGlhbFNpZyxcbiAgICBzaWdoYXNoVHlwZSxcbiAgICBmaW5hbFNjcmlwdFNpZyxcbiAgICBmaW5hbFNjcmlwdFdpdG5lc3MsXG4gICAgcG9yQ29tbWl0bWVudCxcbiAgICB3aXRuZXNzVXR4byxcbiAgICBiaXAzMkRlcml2YXRpb246IGJpcDMyRGVyaXZhdGlvbi5tYWtlQ29udmVydGVyKHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkJJUDMyX0RFUklWQVRJT04pLFxuICAgIHJlZGVlbVNjcmlwdDogcmVkZWVtU2NyaXB0Lm1ha2VDb252ZXJ0ZXIodHlwZUZpZWxkc18xLklucHV0VHlwZXMuUkVERUVNX1NDUklQVCksXG4gICAgd2l0bmVzc1NjcmlwdDogd2l0bmVzc1NjcmlwdC5tYWtlQ29udmVydGVyKHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLldJVE5FU1NfU0NSSVBUKSxcbiAgICBjaGVja1B1YmtleTogY2hlY2tQdWJrZXkubWFrZUNoZWNrZXIoW1xuICAgICAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QQVJUSUFMX1NJRyxcbiAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuQklQMzJfREVSSVZBVElPTixcbiAgICBdKSxcbiAgICB0YXBLZXlTaWcsXG4gICAgdGFwU2NyaXB0U2lnLFxuICAgIHRhcExlYWZTY3JpcHQsXG4gICAgdGFwQmlwMzJEZXJpdmF0aW9uOiB0YXBCaXAzMkRlcml2YXRpb24ubWFrZUNvbnZlcnRlcih0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfQklQMzJfREVSSVZBVElPTiksXG4gICAgdGFwSW50ZXJuYWxLZXk6IHRhcEludGVybmFsS2V5Lm1ha2VDb252ZXJ0ZXIodHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0lOVEVSTkFMX0tFWSksXG4gICAgdGFwTWVya2xlUm9vdCxcbn07XG5leHBvcnRzLmlucHV0cyA9IGlucHV0cztcbmNvbnN0IG91dHB1dHMgPSB7XG4gICAgYmlwMzJEZXJpdmF0aW9uOiBiaXAzMkRlcml2YXRpb24ubWFrZUNvbnZlcnRlcih0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuQklQMzJfREVSSVZBVElPTiksXG4gICAgcmVkZWVtU2NyaXB0OiByZWRlZW1TY3JpcHQubWFrZUNvbnZlcnRlcih0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuUkVERUVNX1NDUklQVCksXG4gICAgd2l0bmVzc1NjcmlwdDogd2l0bmVzc1NjcmlwdC5tYWtlQ29udmVydGVyKHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5XSVRORVNTX1NDUklQVCksXG4gICAgY2hlY2tQdWJrZXk6IGNoZWNrUHVia2V5Lm1ha2VDaGVja2VyKFt0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuQklQMzJfREVSSVZBVElPTl0pLFxuICAgIHRhcEJpcDMyRGVyaXZhdGlvbjogdGFwQmlwMzJEZXJpdmF0aW9uLm1ha2VDb252ZXJ0ZXIodHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9CSVAzMl9ERVJJVkFUSU9OKSxcbiAgICB0YXBUcmVlLFxuICAgIHRhcEludGVybmFsS2V5OiB0YXBJbnRlcm5hbEtleS5tYWtlQ29udmVydGVyKHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5UQVBfSU5URVJOQUxfS0VZKSxcbn07XG5leHBvcnRzLm91dHB1dHMgPSBvdXRwdXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/finalScriptSig.js':
    /*!********************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/finalScriptSig.js ***!
  \********************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAdd = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {\n        throw new Error('Decode Error: could not decode finalScriptSig with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n    const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);\n    return {\n        key,\n        value: data,\n    };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n    return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.finalScriptSig === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceMappingURL=finalScriptSig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L2ZpbmFsU2NyaXB0U2lnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDbkYscUJBQXFCLG1CQUFPLENBQUMsNEdBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L2ZpbmFsU2NyaXB0U2lnLmpzP2ZkOTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbkFkZCA9IGV4cG9ydHMuY2hlY2sgPSBleHBvcnRzLmV4cGVjdGVkID0gZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlRmllbGRzXCIpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRTSUcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgZmluYWxTY3JpcHRTaWcgd2l0aCBrZXkgMHgnICtcbiAgICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVZhbC52YWx1ZTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUU0lHXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ0J1ZmZlcic7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5maW5hbFNjcmlwdFNpZyA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5jYW5BZGQgPSBjYW5BZGQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5hbFNjcmlwdFNpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/finalScriptSig.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/finalScriptWitness.js':
    /*!************************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/finalScriptWitness.js ***!
  \************************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAdd = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {\n        throw new Error('Decode Error: could not decode finalScriptWitness with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n    const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);\n    return {\n        key,\n        value: data,\n    };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n    return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n    return (!!currentData && !!newData && currentData.finalScriptWitness === undefined);\n}\nexports.canAdd = canAdd;\n//# sourceMappingURL=finalScriptWitness.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L2ZpbmFsU2NyaXB0V2l0bmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ25GLHFCQUFxQixtQkFBTyxDQUFDLDRHQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L2NvbnZlcnRlci9pbnB1dC9maW5hbFNjcmlwdFdpdG5lc3MuanM/ZDVhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FuQWRkID0gZXhwb3J0cy5jaGVjayA9IGV4cG9ydHMuZXhwZWN0ZWQgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVGaWVsZHNcIik7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gICAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFdJVE5FU1MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgZmluYWxTY3JpcHRXaXRuZXNzIHdpdGgga2V5IDB4JyArXG4gICAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlWYWwudmFsdWU7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFdJVE5FU1NdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlOiBkYXRhLFxuICAgIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAnQnVmZmVyJztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gICAgcmV0dXJuICghIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5maW5hbFNjcmlwdFdpdG5lc3MgPT09IHVuZGVmaW5lZCk7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmFsU2NyaXB0V2l0bmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/finalScriptWitness.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/nonWitnessUtxo.js':
    /*!********************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/nonWitnessUtxo.js ***!
  \********************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAdd = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {\n        throw new Error('Decode Error: could not decode nonWitnessUtxo with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n    return {\n        key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),\n        value: data,\n    };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n    return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceMappingURL=nonWitnessUtxo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L25vbldpdG5lc3NVdHhvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDbkYscUJBQXFCLG1CQUFPLENBQUMsNEdBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L2NvbnZlcnRlci9pbnB1dC9ub25XaXRuZXNzVXR4by5qcz82MjU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5BZGQgPSBleHBvcnRzLmNoZWNrID0gZXhwb3J0cy5leHBlY3RlZCA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZUZpZWxkc1wiKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuTk9OX1dJVE5FU1NfVVRYTykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSBub25XaXRuZXNzVXR4byB3aXRoIGtleSAweCcgK1xuICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5VmFsLnZhbHVlO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleTogQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLk5PTl9XSVRORVNTX1VUWE9dKSxcbiAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICdCdWZmZXInO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEubm9uV2l0bmVzc1V0eG8gPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9uV2l0bmVzc1V0eG8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/nonWitnessUtxo.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/partialSig.js':
    /*!****************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/partialSig.js ***!
  \****************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAddToArray = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {\n        throw new Error('Decode Error: could not decode partialSig with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    if (!(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n        ![2, 3, 4].includes(keyVal.key[1])) {\n        throw new Error('Decode Error: partialSig has invalid pubkey in key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    const pubkey = keyVal.key.slice(1);\n    return {\n        pubkey,\n        signature: keyVal.value,\n    };\n}\nexports.decode = decode;\nfunction encode(pSig) {\n    const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);\n    return {\n        key: Buffer.concat([head, pSig.pubkey]),\n        value: pSig.signature,\n    };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; signature: Buffer; }';\nfunction check(data) {\n    return (Buffer.isBuffer(data.pubkey) &&\n        Buffer.isBuffer(data.signature) &&\n        [33, 65].includes(data.pubkey.length) &&\n        [2, 3, 4].includes(data.pubkey[0]) &&\n        isDerSigWithSighash(data.signature));\n}\nexports.check = check;\nfunction isDerSigWithSighash(buf) {\n    if (!Buffer.isBuffer(buf) || buf.length < 9)\n        return false;\n    if (buf[0] !== 0x30)\n        return false;\n    if (buf.length !== buf[1] + 3)\n        return false;\n    if (buf[2] !== 0x02)\n        return false;\n    const rLen = buf[3];\n    if (rLen > 33 || rLen < 1)\n        return false;\n    if (buf[3 + rLen + 1] !== 0x02)\n        return false;\n    const sLen = buf[3 + rLen + 2];\n    if (sLen > 33 || sLen < 1)\n        return false;\n    if (buf.length !== 3 + rLen + 2 + sLen + 2)\n        return false;\n    return true;\n}\nfunction canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString))\n        return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n}\nexports.canAddToArray = canAddToArray;\n//# sourceMappingURL=partialSig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3BhcnRpYWxTaWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQzFGLHFCQUFxQixtQkFBTyxDQUFDLDRHQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsTUFBTSxnQkFBZ0Isb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3BhcnRpYWxTaWcuanM/ZjJjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FuQWRkVG9BcnJheSA9IGV4cG9ydHMuY2hlY2sgPSBleHBvcnRzLmV4cGVjdGVkID0gZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlRmllbGRzXCIpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QQVJUSUFMX1NJRykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSBwYXJ0aWFsU2lnIHdpdGgga2V5IDB4JyArXG4gICAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgfVxuICAgIGlmICghKGtleVZhbC5rZXkubGVuZ3RoID09PSAzNCB8fCBrZXlWYWwua2V5Lmxlbmd0aCA9PT0gNjYpIHx8XG4gICAgICAgICFbMiwgMywgNF0uaW5jbHVkZXMoa2V5VmFsLmtleVsxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IHBhcnRpYWxTaWcgaGFzIGludmFsaWQgcHVia2V5IGluIGtleSAweCcgK1xuICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgIH1cbiAgICBjb25zdCBwdWJrZXkgPSBrZXlWYWwua2V5LnNsaWNlKDEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHB1YmtleSxcbiAgICAgICAgc2lnbmF0dXJlOiBrZXlWYWwudmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHBTaWcpIHtcbiAgICBjb25zdCBoZWFkID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlBBUlRJQUxfU0lHXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBCdWZmZXIuY29uY2F0KFtoZWFkLCBwU2lnLnB1YmtleV0pLFxuICAgICAgICB2YWx1ZTogcFNpZy5zaWduYXR1cmUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICd7IHB1YmtleTogQnVmZmVyOyBzaWduYXR1cmU6IEJ1ZmZlcjsgfSc7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gICAgcmV0dXJuIChCdWZmZXIuaXNCdWZmZXIoZGF0YS5wdWJrZXkpICYmXG4gICAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnNpZ25hdHVyZSkgJiZcbiAgICAgICAgWzMzLCA2NV0uaW5jbHVkZXMoZGF0YS5wdWJrZXkubGVuZ3RoKSAmJlxuICAgICAgICBbMiwgMywgNF0uaW5jbHVkZXMoZGF0YS5wdWJrZXlbMF0pICYmXG4gICAgICAgIGlzRGVyU2lnV2l0aFNpZ2hhc2goZGF0YS5zaWduYXR1cmUpKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGlzRGVyU2lnV2l0aFNpZ2hhc2goYnVmKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSB8fCBidWYubGVuZ3RoIDwgOSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChidWZbMF0gIT09IDB4MzApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYnVmLmxlbmd0aCAhPT0gYnVmWzFdICsgMylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChidWZbMl0gIT09IDB4MDIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByTGVuID0gYnVmWzNdO1xuICAgIGlmIChyTGVuID4gMzMgfHwgckxlbiA8IDEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYnVmWzMgKyByTGVuICsgMV0gIT09IDB4MDIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzTGVuID0gYnVmWzMgKyByTGVuICsgMl07XG4gICAgaWYgKHNMZW4gPiAzMyB8fCBzTGVuIDwgMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChidWYubGVuZ3RoICE9PSAzICsgckxlbiArIDIgKyBzTGVuICsgMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2FuQWRkVG9BcnJheShhcnJheSwgaXRlbSwgZHVwZVNldCkge1xuICAgIGNvbnN0IGR1cGVTdHJpbmcgPSBpdGVtLnB1YmtleS50b1N0cmluZygnaGV4Jyk7XG4gICAgaWYgKGR1cGVTZXQuaGFzKGR1cGVTdHJpbmcpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZHVwZVNldC5hZGQoZHVwZVN0cmluZyk7XG4gICAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucHVia2V5LmVxdWFscyhpdGVtLnB1YmtleSkpLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydHMuY2FuQWRkVG9BcnJheSA9IGNhbkFkZFRvQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0aWFsU2lnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/partialSig.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/porCommitment.js':
    /*!*******************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/porCommitment.js ***!
  \*******************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAdd = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {\n        throw new Error('Decode Error: could not decode porCommitment with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    return keyVal.value.toString('utf8');\n}\nexports.decode = decode;\nfunction encode(data) {\n    const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);\n    return {\n        key,\n        value: Buffer.from(data, 'utf8'),\n    };\n}\nexports.encode = encode;\nexports.expected = 'string';\nfunction check(data) {\n    return typeof data === 'string';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.porCommitment === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceMappingURL=porCommitment.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3BvckNvbW1pdG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUNuRixxQkFBcUIsbUJBQU8sQ0FBQyw0R0FBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2JpcDE3NC9jb252ZXJ0ZXIvaW5wdXQvcG9yQ29tbWl0bWVudC5qcz9kYTRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5BZGQgPSBleHBvcnRzLmNoZWNrID0gZXhwb3J0cy5leHBlY3RlZCA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZUZpZWxkc1wiKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUE9SX0NPTU1JVE1FTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgcG9yQ29tbWl0bWVudCB3aXRoIGtleSAweCcgK1xuICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5VmFsLnZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlBPUl9DT01NSVRNRU5UXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZTogQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ3N0cmluZyc7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5wb3JDb21taXRtZW50ID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvckNvbW1pdG1lbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/porCommitment.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/sighashType.js':
    /*!*****************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/sighashType.js ***!
  \*****************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAdd = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {\n        throw new Error('Decode Error: could not decode sighashType with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    return keyVal.value.readUInt32LE(0);\n}\nexports.decode = decode;\nfunction encode(data) {\n    const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);\n    const value = Buffer.allocUnsafe(4);\n    value.writeUInt32LE(data, 0);\n    return {\n        key,\n        value,\n    };\n}\nexports.encode = encode;\nexports.expected = 'number';\nfunction check(data) {\n    return typeof data === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.sighashType === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceMappingURL=sighashType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3NpZ2hhc2hUeXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDbkYscUJBQXFCLG1CQUFPLENBQUMsNEdBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L2NvbnZlcnRlci9pbnB1dC9zaWdoYXNoVHlwZS5qcz80ZjEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5BZGQgPSBleHBvcnRzLmNoZWNrID0gZXhwb3J0cy5leHBlY3RlZCA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZUZpZWxkc1wiKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuU0lHSEFTSF9UWVBFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHNpZ2hhc2hUeXBlIHdpdGgga2V5IDB4JyArXG4gICAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlWYWwudmFsdWUucmVhZFVJbnQzMkxFKDApO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5TSUdIQVNIX1RZUEVdKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KTtcbiAgICB2YWx1ZS53cml0ZVVJbnQzMkxFKGRhdGEsIDApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICdudW1iZXInO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEuc2lnaGFzaFR5cGUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnaGFzaFR5cGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/sighashType.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapKeySig.js':
    /*!***************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapKeySig.js ***!
  \***************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAdd = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {\n        throw new Error('Decode Error: could not decode tapKeySig with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    if (!check(keyVal.value)) {\n        throw new Error('Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature');\n    }\n    return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n    const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);\n    return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n    return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.tapKeySig === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceMappingURL=tapKeySig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3RhcEtleVNpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ25GLHFCQUFxQixtQkFBTyxDQUFDLDRHQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3RhcEtleVNpZy5qcz83Mjk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5BZGQgPSBleHBvcnRzLmNoZWNrID0gZXhwb3J0cy5leHBlY3RlZCA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZUZpZWxkc1wiKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0tFWV9TSUcgfHwga2V5VmFsLmtleS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwS2V5U2lnIHdpdGgga2V5IDB4JyArXG4gICAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgfVxuICAgIGlmICghY2hlY2soa2V5VmFsLnZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZSBFcnJvcjogdGFwS2V5U2lnIG5vdCBhIHZhbGlkIDY0LTY1LWJ5dGUgQklQMzQwIHNpZ25hdHVyZScpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5VmFsLnZhbHVlO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUodmFsdWUpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0tFWV9TSUddKTtcbiAgICByZXR1cm4geyBrZXksIHZhbHVlIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAnQnVmZmVyJztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIChkYXRhLmxlbmd0aCA9PT0gNjQgfHwgZGF0YS5sZW5ndGggPT09IDY1KTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS50YXBLZXlTaWcgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFwS2V5U2lnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapKeySig.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapLeafScript.js':
    /*!*******************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapLeafScript.js ***!
  \*******************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAddToArray = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {\n        throw new Error('Decode Error: could not decode tapLeafScript with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    if ((keyVal.key.length - 2) % 32 !== 0) {\n        throw new Error('Decode Error: tapLeafScript has invalid control block in key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    const leafVersion = keyVal.value[keyVal.value.length - 1];\n    if ((keyVal.key[1] & 0xfe) !== leafVersion) {\n        throw new Error('Decode Error: tapLeafScript bad leaf version in key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    const script = keyVal.value.slice(0, -1);\n    const controlBlock = keyVal.key.slice(1);\n    return { controlBlock, script, leafVersion };\n}\nexports.decode = decode;\nfunction encode(tScript) {\n    const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);\n    const verBuf = Buffer.from([tScript.leafVersion]);\n    return {\n        key: Buffer.concat([head, tScript.controlBlock]),\n        value: Buffer.concat([tScript.script, verBuf]),\n    };\n}\nexports.encode = encode;\nexports.expected = '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';\nfunction check(data) {\n    return (Buffer.isBuffer(data.controlBlock) &&\n        (data.controlBlock.length - 1) % 32 === 0 &&\n        (data.controlBlock[0] & 0xfe) === data.leafVersion &&\n        Buffer.isBuffer(data.script));\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n    const dupeString = item.controlBlock.toString('hex');\n    if (dupeSet.has(dupeString))\n        return false;\n    dupeSet.add(dupeString);\n    return (array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0);\n}\nexports.canAddToArray = canAddToArray;\n//# sourceMappingURL=tapLeafScript.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3RhcExlYWZTY3JpcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQzFGLHFCQUFxQixtQkFBTyxDQUFDLDRHQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQixNQUFNLHNCQUFzQixzQ0FBc0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3RhcExlYWZTY3JpcHQuanM/NTkzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FuQWRkVG9BcnJheSA9IGV4cG9ydHMuY2hlY2sgPSBleHBvcnRzLmV4cGVjdGVkID0gZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlRmllbGRzXCIpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTEVBRl9TQ1JJUFQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwTGVhZlNjcmlwdCB3aXRoIGtleSAweCcgK1xuICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgIH1cbiAgICBpZiAoKGtleVZhbC5rZXkubGVuZ3RoIC0gMikgJSAzMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZSBFcnJvcjogdGFwTGVhZlNjcmlwdCBoYXMgaW52YWxpZCBjb250cm9sIGJsb2NrIGluIGtleSAweCcgK1xuICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgIH1cbiAgICBjb25zdCBsZWFmVmVyc2lvbiA9IGtleVZhbC52YWx1ZVtrZXlWYWwudmFsdWUubGVuZ3RoIC0gMV07XG4gICAgaWYgKChrZXlWYWwua2V5WzFdICYgMHhmZSkgIT09IGxlYWZWZXJzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiB0YXBMZWFmU2NyaXB0IGJhZCBsZWFmIHZlcnNpb24gaW4ga2V5IDB4JyArXG4gICAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgfVxuICAgIGNvbnN0IHNjcmlwdCA9IGtleVZhbC52YWx1ZS5zbGljZSgwLCAtMSk7XG4gICAgY29uc3QgY29udHJvbEJsb2NrID0ga2V5VmFsLmtleS5zbGljZSgxKTtcbiAgICByZXR1cm4geyBjb250cm9sQmxvY2ssIHNjcmlwdCwgbGVhZlZlcnNpb24gfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHRTY3JpcHQpIHtcbiAgICBjb25zdCBoZWFkID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9MRUFGX1NDUklQVF0pO1xuICAgIGNvbnN0IHZlckJ1ZiA9IEJ1ZmZlci5mcm9tKFt0U2NyaXB0LmxlYWZWZXJzaW9uXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBCdWZmZXIuY29uY2F0KFtoZWFkLCB0U2NyaXB0LmNvbnRyb2xCbG9ja10pLFxuICAgICAgICB2YWx1ZTogQnVmZmVyLmNvbmNhdChbdFNjcmlwdC5zY3JpcHQsIHZlckJ1Zl0pLFxuICAgIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAneyBjb250cm9sQmxvY2s6IEJ1ZmZlcjsgbGVhZlZlcnNpb246IG51bWJlciwgc2NyaXB0OiBCdWZmZXI7IH0nO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgIHJldHVybiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEuY29udHJvbEJsb2NrKSAmJlxuICAgICAgICAoZGF0YS5jb250cm9sQmxvY2subGVuZ3RoIC0gMSkgJSAzMiA9PT0gMCAmJlxuICAgICAgICAoZGF0YS5jb250cm9sQmxvY2tbMF0gJiAweGZlKSA9PT0gZGF0YS5sZWFmVmVyc2lvbiAmJlxuICAgICAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5zY3JpcHQpKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZFRvQXJyYXkoYXJyYXksIGl0ZW0sIGR1cGVTZXQpIHtcbiAgICBjb25zdCBkdXBlU3RyaW5nID0gaXRlbS5jb250cm9sQmxvY2sudG9TdHJpbmcoJ2hleCcpO1xuICAgIGlmIChkdXBlU2V0LmhhcyhkdXBlU3RyaW5nKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGR1cGVTZXQuYWRkKGR1cGVTdHJpbmcpO1xuICAgIHJldHVybiAoYXJyYXkuZmlsdGVyKHYgPT4gdi5jb250cm9sQmxvY2suZXF1YWxzKGl0ZW0uY29udHJvbEJsb2NrKSkubGVuZ3RoID09PSAwKTtcbn1cbmV4cG9ydHMuY2FuQWRkVG9BcnJheSA9IGNhbkFkZFRvQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXBMZWFmU2NyaXB0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapLeafScript.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapMerkleRoot.js':
    /*!*******************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapMerkleRoot.js ***!
  \*******************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAdd = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {\n        throw new Error('Decode Error: could not decode tapMerkleRoot with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    if (!check(keyVal.value)) {\n        throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');\n    }\n    return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n    const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);\n    return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n    return Buffer.isBuffer(data) && data.length === 32;\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceMappingURL=tapMerkleRoot.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3RhcE1lcmtsZVJvb3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUNuRixxQkFBcUIsbUJBQU8sQ0FBQyw0R0FBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L2NvbnZlcnRlci9pbnB1dC90YXBNZXJrbGVSb290LmpzPzQyMWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbkFkZCA9IGV4cG9ydHMuY2hlY2sgPSBleHBvcnRzLmV4cGVjdGVkID0gZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlRmllbGRzXCIpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTUVSS0xFX1JPT1QgfHwga2V5VmFsLmtleS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwTWVya2xlUm9vdCB3aXRoIGtleSAweCcgK1xuICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrKGtleVZhbC52YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IHRhcE1lcmtsZVJvb3Qgbm90IGEgMzItYnl0ZSBoYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXlWYWwudmFsdWU7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTUVSS0xFX1JPT1RdKTtcbiAgICByZXR1cm4geyBrZXksIHZhbHVlIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAnQnVmZmVyJztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIGRhdGEubGVuZ3RoID09PSAzMjtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS50YXBNZXJrbGVSb290ID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcE1lcmtsZVJvb3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapMerkleRoot.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapScriptSig.js':
    /*!******************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapScriptSig.js ***!
  \******************************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canAddToArray = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {\n        throw new Error('Decode Error: could not decode tapScriptSig with key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    if (keyVal.key.length !== 65) {\n        throw new Error('Decode Error: tapScriptSig has invalid key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {\n        throw new Error('Decode Error: tapScriptSig has invalid signature in key 0x' +\n            keyVal.key.toString('hex'));\n    }\n    const pubkey = keyVal.key.slice(1, 33);\n    const leafHash = keyVal.key.slice(33);\n    return {\n        pubkey,\n        leafHash,\n        signature: keyVal.value,\n    };\n}\nexports.decode = decode;\nfunction encode(tSig) {\n    const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);\n    return {\n        key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),\n        value: tSig.signature,\n    };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';\nfunction check(data) {\n    return (Buffer.isBuffer(data.pubkey) &&\n        Buffer.isBuffer(data.leafHash) &&\n        Buffer.isBuffer(data.signature) &&\n        data.pubkey.length === 32 &&\n        data.leafHash.length === 32 &&\n        (data.signature.length === 64 || data.signature.length === 65));\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex') + item.leafHash.toString('hex');\n    if (dupeSet.has(dupeString))\n        return false;\n    dupeSet.add(dupeString);\n    return (array.filter(v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash)).length === 0);\n}\nexports.canAddToArray = canAddToArray;\n//# sourceMappingURL=tapScriptSig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3RhcFNjcmlwdFNpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDMUYscUJBQXFCLG1CQUFPLENBQUMsNEdBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsTUFBTSxnQkFBZ0Isa0JBQWtCLG9CQUFvQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3RhcFNjcmlwdFNpZy5qcz83NjY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5BZGRUb0FycmF5ID0gZXhwb3J0cy5jaGVjayA9IGV4cG9ydHMuZXhwZWN0ZWQgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVGaWVsZHNcIik7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gICAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9TQ1JJUFRfU0lHKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHRhcFNjcmlwdFNpZyB3aXRoIGtleSAweCcgK1xuICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgIH1cbiAgICBpZiAoa2V5VmFsLmtleS5sZW5ndGggIT09IDY1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiB0YXBTY3JpcHRTaWcgaGFzIGludmFsaWQga2V5IDB4JyArXG4gICAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgfVxuICAgIGlmIChrZXlWYWwudmFsdWUubGVuZ3RoICE9PSA2NCAmJiBrZXlWYWwudmFsdWUubGVuZ3RoICE9PSA2NSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZSBFcnJvcjogdGFwU2NyaXB0U2lnIGhhcyBpbnZhbGlkIHNpZ25hdHVyZSBpbiBrZXkgMHgnICtcbiAgICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICB9XG4gICAgY29uc3QgcHVia2V5ID0ga2V5VmFsLmtleS5zbGljZSgxLCAzMyk7XG4gICAgY29uc3QgbGVhZkhhc2ggPSBrZXlWYWwua2V5LnNsaWNlKDMzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwdWJrZXksXG4gICAgICAgIGxlYWZIYXNoLFxuICAgICAgICBzaWduYXR1cmU6IGtleVZhbC52YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUodFNpZykge1xuICAgIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX1NDUklQVF9TSUddKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IEJ1ZmZlci5jb25jYXQoW2hlYWQsIHRTaWcucHVia2V5LCB0U2lnLmxlYWZIYXNoXSksXG4gICAgICAgIHZhbHVlOiB0U2lnLnNpZ25hdHVyZSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ3sgcHVia2V5OiBCdWZmZXI7IGxlYWZIYXNoOiBCdWZmZXI7IHNpZ25hdHVyZTogQnVmZmVyOyB9JztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICByZXR1cm4gKEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnB1YmtleSkgJiZcbiAgICAgICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEubGVhZkhhc2gpICYmXG4gICAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnNpZ25hdHVyZSkgJiZcbiAgICAgICAgZGF0YS5wdWJrZXkubGVuZ3RoID09PSAzMiAmJlxuICAgICAgICBkYXRhLmxlYWZIYXNoLmxlbmd0aCA9PT0gMzIgJiZcbiAgICAgICAgKGRhdGEuc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQgfHwgZGF0YS5zaWduYXR1cmUubGVuZ3RoID09PSA2NSkpO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkVG9BcnJheShhcnJheSwgaXRlbSwgZHVwZVNldCkge1xuICAgIGNvbnN0IGR1cGVTdHJpbmcgPSBpdGVtLnB1YmtleS50b1N0cmluZygnaGV4JykgKyBpdGVtLmxlYWZIYXNoLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAoZHVwZVNldC5oYXMoZHVwZVN0cmluZykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkdXBlU2V0LmFkZChkdXBlU3RyaW5nKTtcbiAgICByZXR1cm4gKGFycmF5LmZpbHRlcih2ID0+IHYucHVia2V5LmVxdWFscyhpdGVtLnB1YmtleSkgJiYgdi5sZWFmSGFzaC5lcXVhbHMoaXRlbS5sZWFmSGFzaCkpLmxlbmd0aCA9PT0gMCk7XG59XG5leHBvcnRzLmNhbkFkZFRvQXJyYXkgPSBjYW5BZGRUb0FycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFwU2NyaXB0U2lnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/tapScriptSig.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/witnessUtxo.js':
    /*!*****************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/witnessUtxo.js ***!
  \*****************************************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.canAdd = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js");\nconst tools_1 = __webpack_require__(/*! ../tools */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/tools.js");\nconst varuint = __importStar(__webpack_require__(/*! ../varint */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js"));\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {\n        throw new Error(\'Decode Error: could not decode witnessUtxo with key 0x\' +\n            keyVal.key.toString(\'hex\'));\n    }\n    const value = (0, tools_1.readUInt64LE)(keyVal.value, 0);\n    let _offset = 8;\n    const scriptLen = varuint.decode(keyVal.value, _offset);\n    _offset += varuint.encodingLength(scriptLen);\n    const script = keyVal.value.slice(_offset);\n    if (script.length !== scriptLen) {\n        throw new Error(\'Decode Error: WITNESS_UTXO script is not proper length\');\n    }\n    return {\n        script,\n        value,\n    };\n}\nexports.decode = decode;\nfunction encode(data) {\n    const { script, value } = data;\n    const varintLen = varuint.encodingLength(script.length);\n    const result = Buffer.allocUnsafe(8 + varintLen + script.length);\n    (0, tools_1.writeUInt64LE)(result, value, 0);\n    varuint.encode(script.length, result, 8);\n    script.copy(result, 8 + varintLen);\n    return {\n        key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),\n        value: result,\n    };\n}\nexports.encode = encode;\nexports.expected = \'{ script: Buffer; value: number; }\';\nfunction check(data) {\n    return Buffer.isBuffer(data.script) && typeof data.value === \'number\';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceMappingURL=witnessUtxo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL2lucHV0L3dpdG5lc3NVdHhvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ25GLHFCQUFxQixtQkFBTyxDQUFDLDRHQUFrQjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyx5R0FBVTtBQUNsQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsTUFBTSxnQkFBZ0IsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2JpcDE3NC9jb252ZXJ0ZXIvaW5wdXQvd2l0bmVzc1V0eG8uanM/NDhhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5BZGQgPSBleHBvcnRzLmNoZWNrID0gZXhwb3J0cy5leHBlY3RlZCA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZUZpZWxkc1wiKTtcbmNvbnN0IHRvb2xzXzEgPSByZXF1aXJlKFwiLi4vdG9vbHNcIik7XG5jb25zdCB2YXJ1aW50ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi92YXJpbnRcIikpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5XSVRORVNTX1VUWE8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgd2l0bmVzc1V0eG8gd2l0aCBrZXkgMHgnICtcbiAgICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSAoMCwgdG9vbHNfMS5yZWFkVUludDY0TEUpKGtleVZhbC52YWx1ZSwgMCk7XG4gICAgbGV0IF9vZmZzZXQgPSA4O1xuICAgIGNvbnN0IHNjcmlwdExlbiA9IHZhcnVpbnQuZGVjb2RlKGtleVZhbC52YWx1ZSwgX29mZnNldCk7XG4gICAgX29mZnNldCArPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHNjcmlwdExlbik7XG4gICAgY29uc3Qgc2NyaXB0ID0ga2V5VmFsLnZhbHVlLnNsaWNlKF9vZmZzZXQpO1xuICAgIGlmIChzY3JpcHQubGVuZ3RoICE9PSBzY3JpcHRMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IFdJVE5FU1NfVVRYTyBzY3JpcHQgaXMgbm90IHByb3BlciBsZW5ndGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NyaXB0LFxuICAgICAgICB2YWx1ZSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGNvbnN0IHsgc2NyaXB0LCB2YWx1ZSB9ID0gZGF0YTtcbiAgICBjb25zdCB2YXJpbnRMZW4gPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHNjcmlwdC5sZW5ndGgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg4ICsgdmFyaW50TGVuICsgc2NyaXB0Lmxlbmd0aCk7XG4gICAgKDAsIHRvb2xzXzEud3JpdGVVSW50NjRMRSkocmVzdWx0LCB2YWx1ZSwgMCk7XG4gICAgdmFydWludC5lbmNvZGUoc2NyaXB0Lmxlbmd0aCwgcmVzdWx0LCA4KTtcbiAgICBzY3JpcHQuY29weShyZXN1bHQsIDggKyB2YXJpbnRMZW4pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleTogQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLldJVE5FU1NfVVRYT10pLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAneyBzY3JpcHQ6IEJ1ZmZlcjsgdmFsdWU6IG51bWJlcjsgfSc7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnNjcmlwdCkgJiYgdHlwZW9mIGRhdGEudmFsdWUgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gICAgcmV0dXJuICEhY3VycmVudERhdGEgJiYgISFuZXdEYXRhICYmIGN1cnJlbnREYXRhLndpdG5lc3NVdHhvID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdG5lc3NVdHhvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/input/witnessUtxo.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/output/tapTree.js':
    /*!**************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/output/tapTree.js ***!
  \**************************************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.canAdd = exports.check = exports.expected = exports.encode = exports.decode = void 0;\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js");\nconst varuint = __importStar(__webpack_require__(/*! ../varint */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js"));\nfunction decode(keyVal) {\n    if (keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE || keyVal.key.length !== 1) {\n        throw new Error(\'Decode Error: could not decode tapTree with key 0x\' +\n            keyVal.key.toString(\'hex\'));\n    }\n    let _offset = 0;\n    const data = [];\n    while (_offset < keyVal.value.length) {\n        const depth = keyVal.value[_offset++];\n        const leafVersion = keyVal.value[_offset++];\n        const scriptLen = varuint.decode(keyVal.value, _offset);\n        _offset += varuint.encodingLength(scriptLen);\n        data.push({\n            depth,\n            leafVersion,\n            script: keyVal.value.slice(_offset, _offset + scriptLen),\n        });\n        _offset += scriptLen;\n    }\n    return { leaves: data };\n}\nexports.decode = decode;\nfunction encode(tree) {\n    const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);\n    const bufs = [].concat(...tree.leaves.map(tapLeaf => [\n        Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),\n        varuint.encode(tapLeaf.script.length),\n        tapLeaf.script,\n    ]));\n    return {\n        key,\n        value: Buffer.concat(bufs),\n    };\n}\nexports.encode = encode;\nexports.expected = \'{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }\';\nfunction check(data) {\n    return (Array.isArray(data.leaves) &&\n        data.leaves.every((tapLeaf) => tapLeaf.depth >= 0 &&\n            tapLeaf.depth <= 128 &&\n            (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&\n            Buffer.isBuffer(tapLeaf.script)));\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.tapTree === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceMappingURL=tapTree.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL291dHB1dC90YXBUcmVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ25GLHFCQUFxQixtQkFBTyxDQUFDLDRHQUFrQjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsTUFBTSxXQUFXLGVBQWUsc0NBQXNDLEdBQUc7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL291dHB1dC90YXBUcmVlLmpzP2U2ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FuQWRkID0gZXhwb3J0cy5jaGVjayA9IGV4cG9ydHMuZXhwZWN0ZWQgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVGaWVsZHNcIik7XG5jb25zdCB2YXJ1aW50ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi92YXJpbnRcIikpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuVEFQX1RSRUUgfHwga2V5VmFsLmtleS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwVHJlZSB3aXRoIGtleSAweCcgK1xuICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgIH1cbiAgICBsZXQgX29mZnNldCA9IDA7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIHdoaWxlIChfb2Zmc2V0IDwga2V5VmFsLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBkZXB0aCA9IGtleVZhbC52YWx1ZVtfb2Zmc2V0KytdO1xuICAgICAgICBjb25zdCBsZWFmVmVyc2lvbiA9IGtleVZhbC52YWx1ZVtfb2Zmc2V0KytdO1xuICAgICAgICBjb25zdCBzY3JpcHRMZW4gPSB2YXJ1aW50LmRlY29kZShrZXlWYWwudmFsdWUsIF9vZmZzZXQpO1xuICAgICAgICBfb2Zmc2V0ICs9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoc2NyaXB0TGVuKTtcbiAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgICAgbGVhZlZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHQ6IGtleVZhbC52YWx1ZS5zbGljZShfb2Zmc2V0LCBfb2Zmc2V0ICsgc2NyaXB0TGVuKSxcbiAgICAgICAgfSk7XG4gICAgICAgIF9vZmZzZXQgKz0gc2NyaXB0TGVuO1xuICAgIH1cbiAgICByZXR1cm4geyBsZWF2ZXM6IGRhdGEgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHRyZWUpIHtcbiAgICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9UUkVFXSk7XG4gICAgY29uc3QgYnVmcyA9IFtdLmNvbmNhdCguLi50cmVlLmxlYXZlcy5tYXAodGFwTGVhZiA9PiBbXG4gICAgICAgIEJ1ZmZlci5vZih0YXBMZWFmLmRlcHRoLCB0YXBMZWFmLmxlYWZWZXJzaW9uKSxcbiAgICAgICAgdmFydWludC5lbmNvZGUodGFwTGVhZi5zY3JpcHQubGVuZ3RoKSxcbiAgICAgICAgdGFwTGVhZi5zY3JpcHQsXG4gICAgXSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWU6IEJ1ZmZlci5jb25jYXQoYnVmcyksXG4gICAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICd7IGxlYXZlczogW3sgZGVwdGg6IG51bWJlcjsgbGVhZlZlcnNpb246IG51bWJlciwgc2NyaXB0OiBCdWZmZXI7IH1dIH0nO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShkYXRhLmxlYXZlcykgJiZcbiAgICAgICAgZGF0YS5sZWF2ZXMuZXZlcnkoKHRhcExlYWYpID0+IHRhcExlYWYuZGVwdGggPj0gMCAmJlxuICAgICAgICAgICAgdGFwTGVhZi5kZXB0aCA8PSAxMjggJiZcbiAgICAgICAgICAgICh0YXBMZWFmLmxlYWZWZXJzaW9uICYgMHhmZSkgPT09IHRhcExlYWYubGVhZlZlcnNpb24gJiZcbiAgICAgICAgICAgIEJ1ZmZlci5pc0J1ZmZlcih0YXBMZWFmLnNjcmlwdCkpKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS50YXBUcmVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcFRyZWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/output/tapTree.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/bip32Derivation.js':
    /*!**********************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/bip32Derivation.js ***!
  \**********************************************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeConverter = void 0;\nconst range = (n) => [...Array(n).keys()];\nconst isValidDERKey = (pubkey) => (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||\n    (pubkey.length === 65 && 4 === pubkey[0]);\nfunction makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {\n    function decode(keyVal) {\n        if (keyVal.key[0] !== TYPE_BYTE) {\n            throw new Error('Decode Error: could not decode bip32Derivation with key 0x' +\n                keyVal.key.toString('hex'));\n        }\n        const pubkey = keyVal.key.slice(1);\n        if (!isValidPubkey(pubkey)) {\n            throw new Error('Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n                keyVal.key.toString('hex'));\n        }\n        if ((keyVal.value.length / 4) % 1 !== 0) {\n            throw new Error('Decode Error: Input BIP32_DERIVATION value length should be multiple of 4');\n        }\n        const data = {\n            masterFingerprint: keyVal.value.slice(0, 4),\n            pubkey,\n            path: 'm',\n        };\n        for (const i of range(keyVal.value.length / 4 - 1)) {\n            const val = keyVal.value.readUInt32LE(i * 4 + 4);\n            const isHard = !!(val & 0x80000000);\n            const idx = val & 0x7fffffff;\n            data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n        }\n        return data;\n    }\n    function encode(data) {\n        const head = Buffer.from([TYPE_BYTE]);\n        const key = Buffer.concat([head, data.pubkey]);\n        const splitPath = data.path.split('/');\n        const value = Buffer.allocUnsafe(splitPath.length * 4);\n        data.masterFingerprint.copy(value, 0);\n        let offset = 4;\n        splitPath.slice(1).forEach(level => {\n            const isHard = level.slice(-1) === \"'\";\n            let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n            if (isHard)\n                num += 0x80000000;\n            value.writeUInt32LE(num, offset);\n            offset += 4;\n        });\n        return {\n            key,\n            value,\n        };\n    }\n    const expected = '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n    function check(data) {\n        return (Buffer.isBuffer(data.pubkey) &&\n            Buffer.isBuffer(data.masterFingerprint) &&\n            typeof data.path === 'string' &&\n            isValidPubkey(data.pubkey) &&\n            data.masterFingerprint.length === 4);\n    }\n    function canAddToArray(array, item, dupeSet) {\n        const dupeString = item.pubkey.toString('hex');\n        if (dupeSet.has(dupeString))\n            return false;\n        dupeSet.add(dupeString);\n        return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n    }\n    return {\n        decode,\n        encode,\n        check,\n        expected,\n        canAddToArray,\n    };\n}\nexports.makeConverter = makeConverter;\n//# sourceMappingURL=bip32Derivation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3NoYXJlZC9iaXAzMkRlcml2YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkIsZ0JBQWdCLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2JpcDE3NC9jb252ZXJ0ZXIvc2hhcmVkL2JpcDMyRGVyaXZhdGlvbi5qcz8xZmRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gdm9pZCAwO1xuY29uc3QgcmFuZ2UgPSAobikgPT4gWy4uLkFycmF5KG4pLmtleXMoKV07XG5jb25zdCBpc1ZhbGlkREVSS2V5ID0gKHB1YmtleSkgPT4gKHB1YmtleS5sZW5ndGggPT09IDMzICYmIFsyLCAzXS5pbmNsdWRlcyhwdWJrZXlbMF0pKSB8fFxuICAgIChwdWJrZXkubGVuZ3RoID09PSA2NSAmJiA0ID09PSBwdWJrZXlbMF0pO1xuZnVuY3Rpb24gbWFrZUNvbnZlcnRlcihUWVBFX0JZVEUsIGlzVmFsaWRQdWJrZXkgPSBpc1ZhbGlkREVSS2V5KSB7XG4gICAgZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgICAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gVFlQRV9CWVRFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSBiaXAzMkRlcml2YXRpb24gd2l0aCBrZXkgMHgnICtcbiAgICAgICAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVia2V5ID0ga2V5VmFsLmtleS5zbGljZSgxKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUHVia2V5KHB1YmtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiBiaXAzMkRlcml2YXRpb24gaGFzIGludmFsaWQgcHVia2V5IGluIGtleSAweCcgK1xuICAgICAgICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGtleVZhbC52YWx1ZS5sZW5ndGggLyA0KSAlIDEgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiBJbnB1dCBCSVAzMl9ERVJJVkFUSU9OIHZhbHVlIGxlbmd0aCBzaG91bGQgYmUgbXVsdGlwbGUgb2YgNCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBtYXN0ZXJGaW5nZXJwcmludDoga2V5VmFsLnZhbHVlLnNsaWNlKDAsIDQpLFxuICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgcGF0aDogJ20nLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2Uoa2V5VmFsLnZhbHVlLmxlbmd0aCAvIDQgLSAxKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0ga2V5VmFsLnZhbHVlLnJlYWRVSW50MzJMRShpICogNCArIDQpO1xuICAgICAgICAgICAgY29uc3QgaXNIYXJkID0gISEodmFsICYgMHg4MDAwMDAwMCk7XG4gICAgICAgICAgICBjb25zdCBpZHggPSB2YWwgJiAweDdmZmZmZmZmO1xuICAgICAgICAgICAgZGF0YS5wYXRoICs9ICcvJyArIGlkeC50b1N0cmluZygxMCkgKyAoaXNIYXJkID8gXCInXCIgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbShbVFlQRV9CWVRFXSk7XG4gICAgICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5jb25jYXQoW2hlYWQsIGRhdGEucHVia2V5XSk7XG4gICAgICAgIGNvbnN0IHNwbGl0UGF0aCA9IGRhdGEucGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzcGxpdFBhdGgubGVuZ3RoICogNCk7XG4gICAgICAgIGRhdGEubWFzdGVyRmluZ2VycHJpbnQuY29weSh2YWx1ZSwgMCk7XG4gICAgICAgIGxldCBvZmZzZXQgPSA0O1xuICAgICAgICBzcGxpdFBhdGguc2xpY2UoMSkuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0hhcmQgPSBsZXZlbC5zbGljZSgtMSkgPT09IFwiJ1wiO1xuICAgICAgICAgICAgbGV0IG51bSA9IDB4N2ZmZmZmZmYgJiBwYXJzZUludChpc0hhcmQgPyBsZXZlbC5zbGljZSgwLCAtMSkgOiBsZXZlbCwgMTApO1xuICAgICAgICAgICAgaWYgKGlzSGFyZClcbiAgICAgICAgICAgICAgICBudW0gKz0gMHg4MDAwMDAwMDtcbiAgICAgICAgICAgIHZhbHVlLndyaXRlVUludDMyTEUobnVtLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4cGVjdGVkID0gJ3sgbWFzdGVyRmluZ2VycHJpbnQ6IEJ1ZmZlcjsgcHVia2V5OiBCdWZmZXI7IHBhdGg6IHN0cmluZzsgfSc7XG4gICAgZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgICAgICByZXR1cm4gKEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnB1YmtleSkgJiZcbiAgICAgICAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLm1hc3RlckZpbmdlcnByaW50KSAmJlxuICAgICAgICAgICAgdHlwZW9mIGRhdGEucGF0aCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGlzVmFsaWRQdWJrZXkoZGF0YS5wdWJrZXkpICYmXG4gICAgICAgICAgICBkYXRhLm1hc3RlckZpbmdlcnByaW50Lmxlbmd0aCA9PT0gNCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbkFkZFRvQXJyYXkoYXJyYXksIGl0ZW0sIGR1cGVTZXQpIHtcbiAgICAgICAgY29uc3QgZHVwZVN0cmluZyA9IGl0ZW0ucHVia2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgaWYgKGR1cGVTZXQuaGFzKGR1cGVTdHJpbmcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkdXBlU2V0LmFkZChkdXBlU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucHVia2V5LmVxdWFscyhpdGVtLnB1YmtleSkpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGNoZWNrLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgY2FuQWRkVG9BcnJheSxcbiAgICB9O1xufVxuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gbWFrZUNvbnZlcnRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpcDMyRGVyaXZhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/bip32Derivation.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/checkPubkey.js':
    /*!******************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/checkPubkey.js ***!
  \******************************************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeChecker = void 0;\nfunction makeChecker(pubkeyTypes) {\n    return checkPubkey;\n    function checkPubkey(keyVal) {\n        let pubkey;\n        if (pubkeyTypes.includes(keyVal.key[0])) {\n            pubkey = keyVal.key.slice(1);\n            if (!(pubkey.length === 33 || pubkey.length === 65) ||\n                ![2, 3, 4].includes(pubkey[0])) {\n                throw new Error('Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'));\n            }\n        }\n        return pubkey;\n    }\n}\nexports.makeChecker = makeChecker;\n//# sourceMappingURL=checkPubkey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3NoYXJlZC9jaGVja1B1YmtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L2NvbnZlcnRlci9zaGFyZWQvY2hlY2tQdWJrZXkuanM/ZGQxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFrZUNoZWNrZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBtYWtlQ2hlY2tlcihwdWJrZXlUeXBlcykge1xuICAgIHJldHVybiBjaGVja1B1YmtleTtcbiAgICBmdW5jdGlvbiBjaGVja1B1YmtleShrZXlWYWwpIHtcbiAgICAgICAgbGV0IHB1YmtleTtcbiAgICAgICAgaWYgKHB1YmtleVR5cGVzLmluY2x1ZGVzKGtleVZhbC5rZXlbMF0pKSB7XG4gICAgICAgICAgICBwdWJrZXkgPSBrZXlWYWwua2V5LnNsaWNlKDEpO1xuICAgICAgICAgICAgaWYgKCEocHVia2V5Lmxlbmd0aCA9PT0gMzMgfHwgcHVia2V5Lmxlbmd0aCA9PT0gNjUpIHx8XG4gICAgICAgICAgICAgICAgIVsyLCAzLCA0XS5pbmNsdWRlcyhwdWJrZXlbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IGludmFsaWQgcHVia2V5IGluIGtleSAweCcgKyBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1YmtleTtcbiAgICB9XG59XG5leHBvcnRzLm1ha2VDaGVja2VyID0gbWFrZUNoZWNrZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja1B1YmtleS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/checkPubkey.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/redeemScript.js':
    /*!*******************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/redeemScript.js ***!
  \*******************************************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeConverter = void 0;\nfunction makeConverter(TYPE_BYTE) {\n    function decode(keyVal) {\n        if (keyVal.key[0] !== TYPE_BYTE) {\n            throw new Error('Decode Error: could not decode redeemScript with key 0x' +\n                keyVal.key.toString('hex'));\n        }\n        return keyVal.value;\n    }\n    function encode(data) {\n        const key = Buffer.from([TYPE_BYTE]);\n        return {\n            key,\n            value: data,\n        };\n    }\n    const expected = 'Buffer';\n    function check(data) {\n        return Buffer.isBuffer(data);\n    }\n    function canAdd(currentData, newData) {\n        return !!currentData && !!newData && currentData.redeemScript === undefined;\n    }\n    return {\n        decode,\n        encode,\n        check,\n        expected,\n        canAdd,\n    };\n}\nexports.makeConverter = makeConverter;\n//# sourceMappingURL=redeemScript.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3NoYXJlZC9yZWRlZW1TY3JpcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L2NvbnZlcnRlci9zaGFyZWQvcmVkZWVtU2NyaXB0LmpzP2FhMmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1ha2VDb252ZXJ0ZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBtYWtlQ29udmVydGVyKFRZUEVfQllURSkge1xuICAgIGZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICAgICAgaWYgKGtleVZhbC5rZXlbMF0gIT09IFRZUEVfQllURSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgcmVkZWVtU2NyaXB0IHdpdGgga2V5IDB4JyArXG4gICAgICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlWYWwudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFtUWVBFX0JZVEVdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZCA9ICdCdWZmZXInO1xuICAgIGZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gICAgICAgIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5yZWRlZW1TY3JpcHQgPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGNoZWNrLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgY2FuQWRkLFxuICAgIH07XG59XG5leHBvcnRzLm1ha2VDb252ZXJ0ZXIgPSBtYWtlQ29udmVydGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkZWVtU2NyaXB0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/redeemScript.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/tapBip32Derivation.js':
    /*!*************************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/tapBip32Derivation.js ***!
  \*************************************************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.makeConverter = void 0;\nconst varuint = __importStar(__webpack_require__(/*! ../varint */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js"));\nconst bip32Derivation = __importStar(__webpack_require__(/*! ./bip32Derivation */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/bip32Derivation.js"));\nconst isValidBIP340Key = (pubkey) => pubkey.length === 32;\nfunction makeConverter(TYPE_BYTE) {\n    const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);\n    function decode(keyVal) {\n        const nHashes = varuint.decode(keyVal.value);\n        const nHashesLen = varuint.encodingLength(nHashes);\n        const base = parent.decode({\n            key: keyVal.key,\n            value: keyVal.value.slice(nHashesLen + nHashes * 32),\n        });\n        const leafHashes = new Array(nHashes);\n        for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {\n            leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);\n        }\n        return { ...base, leafHashes };\n    }\n    function encode(data) {\n        const base = parent.encode(data);\n        const nHashesLen = varuint.encodingLength(data.leafHashes.length);\n        const nHashesBuf = Buffer.allocUnsafe(nHashesLen);\n        varuint.encode(data.leafHashes.length, nHashesBuf);\n        const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);\n        return { ...base, value };\n    }\n    const expected = \'{ \' +\n        \'masterFingerprint: Buffer; \' +\n        \'pubkey: Buffer; \' +\n        \'path: string; \' +\n        \'leafHashes: Buffer[]; \' +\n        \'}\';\n    function check(data) {\n        return (Array.isArray(data.leafHashes) &&\n            data.leafHashes.every((leafHash) => Buffer.isBuffer(leafHash) && leafHash.length === 32) &&\n            parent.check(data));\n    }\n    return {\n        decode,\n        encode,\n        check,\n        expected,\n        canAddToArray: parent.canAddToArray,\n    };\n}\nexports.makeConverter = makeConverter;\n//# sourceMappingURL=tapBip32Derivation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3NoYXJlZC90YXBCaXAzMkRlcml2YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQiw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBVztBQUNoRCxxQ0FBcUMsbUJBQU8sQ0FBQyxtSUFBbUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdCQUF3QjtBQUN4QixvQ0FBb0M7QUFDcEMseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3NoYXJlZC90YXBCaXAzMkRlcml2YXRpb24uanM/NjNjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gdm9pZCAwO1xuY29uc3QgdmFydWludCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdmFyaW50XCIpKTtcbmNvbnN0IGJpcDMyRGVyaXZhdGlvbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iaXAzMkRlcml2YXRpb25cIikpO1xuY29uc3QgaXNWYWxpZEJJUDM0MEtleSA9IChwdWJrZXkpID0+IHB1YmtleS5sZW5ndGggPT09IDMyO1xuZnVuY3Rpb24gbWFrZUNvbnZlcnRlcihUWVBFX0JZVEUpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBiaXAzMkRlcml2YXRpb24ubWFrZUNvbnZlcnRlcihUWVBFX0JZVEUsIGlzVmFsaWRCSVAzNDBLZXkpO1xuICAgIGZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICAgICAgY29uc3Qgbkhhc2hlcyA9IHZhcnVpbnQuZGVjb2RlKGtleVZhbC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5IYXNoZXNMZW4gPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKG5IYXNoZXMpO1xuICAgICAgICBjb25zdCBiYXNlID0gcGFyZW50LmRlY29kZSh7XG4gICAgICAgICAgICBrZXk6IGtleVZhbC5rZXksXG4gICAgICAgICAgICB2YWx1ZToga2V5VmFsLnZhbHVlLnNsaWNlKG5IYXNoZXNMZW4gKyBuSGFzaGVzICogMzIpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbGVhZkhhc2hlcyA9IG5ldyBBcnJheShuSGFzaGVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIF9vZmZzZXQgPSBuSGFzaGVzTGVuOyBpIDwgbkhhc2hlczsgaSsrLCBfb2Zmc2V0ICs9IDMyKSB7XG4gICAgICAgICAgICBsZWFmSGFzaGVzW2ldID0ga2V5VmFsLnZhbHVlLnNsaWNlKF9vZmZzZXQsIF9vZmZzZXQgKyAzMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uYmFzZSwgbGVhZkhhc2hlcyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgICAgICBjb25zdCBiYXNlID0gcGFyZW50LmVuY29kZShkYXRhKTtcbiAgICAgICAgY29uc3Qgbkhhc2hlc0xlbiA9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoZGF0YS5sZWFmSGFzaGVzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG5IYXNoZXNCdWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUobkhhc2hlc0xlbik7XG4gICAgICAgIHZhcnVpbnQuZW5jb2RlKGRhdGEubGVhZkhhc2hlcy5sZW5ndGgsIG5IYXNoZXNCdWYpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5jb25jYXQoW25IYXNoZXNCdWYsIC4uLmRhdGEubGVhZkhhc2hlcywgYmFzZS52YWx1ZV0pO1xuICAgICAgICByZXR1cm4geyAuLi5iYXNlLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZCA9ICd7ICcgK1xuICAgICAgICAnbWFzdGVyRmluZ2VycHJpbnQ6IEJ1ZmZlcjsgJyArXG4gICAgICAgICdwdWJrZXk6IEJ1ZmZlcjsgJyArXG4gICAgICAgICdwYXRoOiBzdHJpbmc7ICcgK1xuICAgICAgICAnbGVhZkhhc2hlczogQnVmZmVyW107ICcgK1xuICAgICAgICAnfSc7XG4gICAgZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoZGF0YS5sZWFmSGFzaGVzKSAmJlxuICAgICAgICAgICAgZGF0YS5sZWFmSGFzaGVzLmV2ZXJ5KChsZWFmSGFzaCkgPT4gQnVmZmVyLmlzQnVmZmVyKGxlYWZIYXNoKSAmJiBsZWFmSGFzaC5sZW5ndGggPT09IDMyKSAmJlxuICAgICAgICAgICAgcGFyZW50LmNoZWNrKGRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGNoZWNrLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgY2FuQWRkVG9BcnJheTogcGFyZW50LmNhbkFkZFRvQXJyYXksXG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZUNvbnZlcnRlciA9IG1ha2VDb252ZXJ0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXBCaXAzMkRlcml2YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/tapBip32Derivation.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/tapInternalKey.js':
    /*!*********************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/tapInternalKey.js ***!
  \*********************************************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeConverter = void 0;\nfunction makeConverter(TYPE_BYTE) {\n    function decode(keyVal) {\n        if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {\n            throw new Error('Decode Error: could not decode tapInternalKey with key 0x' +\n                keyVal.key.toString('hex'));\n        }\n        if (keyVal.value.length !== 32) {\n            throw new Error('Decode Error: tapInternalKey not a 32-byte x-only pubkey');\n        }\n        return keyVal.value;\n    }\n    function encode(value) {\n        const key = Buffer.from([TYPE_BYTE]);\n        return { key, value };\n    }\n    const expected = 'Buffer';\n    function check(data) {\n        return Buffer.isBuffer(data) && data.length === 32;\n    }\n    function canAdd(currentData, newData) {\n        return (!!currentData && !!newData && currentData.tapInternalKey === undefined);\n    }\n    return {\n        decode,\n        encode,\n        check,\n        expected,\n        canAdd,\n    };\n}\nexports.makeConverter = makeConverter;\n//# sourceMappingURL=tapInternalKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3NoYXJlZC90YXBJbnRlcm5hbEtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2JpcDE3NC9jb252ZXJ0ZXIvc2hhcmVkL3RhcEludGVybmFsS2V5LmpzPzI0ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1ha2VDb252ZXJ0ZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBtYWtlQ29udmVydGVyKFRZUEVfQllURSkge1xuICAgIGZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICAgICAgaWYgKGtleVZhbC5rZXlbMF0gIT09IFRZUEVfQllURSB8fCBrZXlWYWwua2V5Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwSW50ZXJuYWxLZXkgd2l0aCBrZXkgMHgnICtcbiAgICAgICAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleVZhbC52YWx1ZS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZSBFcnJvcjogdGFwSW50ZXJuYWxLZXkgbm90IGEgMzItYnl0ZSB4LW9ubHkgcHVia2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleVZhbC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFtUWVBFX0JZVEVdKTtcbiAgICAgICAgcmV0dXJuIHsga2V5LCB2YWx1ZSB9O1xuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZCA9ICdCdWZmZXInO1xuICAgIGZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSAmJiBkYXRhLmxlbmd0aCA9PT0gMzI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgICAgICByZXR1cm4gKCEhY3VycmVudERhdGEgJiYgISFuZXdEYXRhICYmIGN1cnJlbnREYXRhLnRhcEludGVybmFsS2V5ID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWNvZGUsXG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgY2hlY2ssXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBjYW5BZGQsXG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZUNvbnZlcnRlciA9IG1ha2VDb252ZXJ0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXBJbnRlcm5hbEtleS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/tapInternalKey.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/witnessScript.js':
    /*!********************************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/witnessScript.js ***!
  \********************************************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeConverter = void 0;\nfunction makeConverter(TYPE_BYTE) {\n    function decode(keyVal) {\n        if (keyVal.key[0] !== TYPE_BYTE) {\n            throw new Error('Decode Error: could not decode witnessScript with key 0x' +\n                keyVal.key.toString('hex'));\n        }\n        return keyVal.value;\n    }\n    function encode(data) {\n        const key = Buffer.from([TYPE_BYTE]);\n        return {\n            key,\n            value: data,\n        };\n    }\n    const expected = 'Buffer';\n    function check(data) {\n        return Buffer.isBuffer(data);\n    }\n    function canAdd(currentData, newData) {\n        return (!!currentData && !!newData && currentData.witnessScript === undefined);\n    }\n    return {\n        decode,\n        encode,\n        check,\n        expected,\n        canAdd,\n    };\n}\nexports.makeConverter = makeConverter;\n//# sourceMappingURL=witnessScript.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3NoYXJlZC93aXRuZXNzU2NyaXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2JpcDE3NC9jb252ZXJ0ZXIvc2hhcmVkL3dpdG5lc3NTY3JpcHQuanM/MDFkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFrZUNvbnZlcnRlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIG1ha2VDb252ZXJ0ZXIoVFlQRV9CWVRFKSB7XG4gICAgZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgICAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gVFlQRV9CWVRFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSB3aXRuZXNzU2NyaXB0IHdpdGgga2V5IDB4JyArXG4gICAgICAgICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlWYWwudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFtUWVBFX0JZVEVdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZCA9ICdCdWZmZXInO1xuICAgIGZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gICAgICAgIHJldHVybiAoISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEud2l0bmVzc1NjcmlwdCA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGNoZWNrLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgY2FuQWRkLFxuICAgIH07XG59XG5leHBvcnRzLm1ha2VDb252ZXJ0ZXIgPSBtYWtlQ29udmVydGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0bmVzc1NjcmlwdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/shared/witnessScript.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/tools.js':
    /*!*****************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/tools.js ***!
  \*****************************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.writeUInt64LE = exports.readUInt64LE = exports.keyValToBuffer = exports.keyValsToBuffer = exports.reverseBuffer = exports.range = void 0;\nconst varuint = __importStar(__webpack_require__(/*! ./varint */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js"));\nconst range = (n) => [...Array(n).keys()];\nexports.range = range;\nfunction reverseBuffer(buffer) {\n    if (buffer.length < 1)\n        return buffer;\n    let j = buffer.length - 1;\n    let tmp = 0;\n    for (let i = 0; i < buffer.length / 2; i++) {\n        tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n        j--;\n    }\n    return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction keyValsToBuffer(keyVals) {\n    const buffers = keyVals.map(keyValToBuffer);\n    buffers.push(Buffer.from([0]));\n    return Buffer.concat(buffers);\n}\nexports.keyValsToBuffer = keyValsToBuffer;\nfunction keyValToBuffer(keyVal) {\n    const keyLen = keyVal.key.length;\n    const valLen = keyVal.value.length;\n    const keyVarIntLen = varuint.encodingLength(keyLen);\n    const valVarIntLen = varuint.encodingLength(valLen);\n    const buffer = Buffer.allocUnsafe(keyVarIntLen + keyLen + valVarIntLen + valLen);\n    varuint.encode(keyLen, buffer, 0);\n    keyVal.key.copy(buffer, keyVarIntLen);\n    varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n    keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);\n    return buffer;\n}\nexports.keyValToBuffer = keyValToBuffer;\nfunction verifuint(value, max) {\n    if (typeof value !== \'number\')\n        throw new Error(\'cannot write a non-number as a number\');\n    if (value < 0)\n        throw new Error(\'specified a negative value for writing an unsigned value\');\n    if (value > max)\n        throw new Error(\'RangeError: value out of range\');\n    if (Math.floor(value) !== value)\n        throw new Error(\'value has a fractional component\');\n}\nfunction readUInt64LE(buffer, offset) {\n    const a = buffer.readUInt32LE(offset);\n    let b = buffer.readUInt32LE(offset + 4);\n    b *= 0x100000000;\n    verifuint(b + a, 0x001fffffffffffff);\n    return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n    verifuint(value, 0x001fffffffffffff);\n    buffer.writeInt32LE(value & -1, offset);\n    buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n    return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n//# sourceMappingURL=tools.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3Rvb2xzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyxhQUFhO0FBQ3ZJLDZCQUE2QixtQkFBTyxDQUFDLDBHQUFVO0FBQy9DO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3Rvb2xzLmpzPzI5YzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JpdGVVSW50NjRMRSA9IGV4cG9ydHMucmVhZFVJbnQ2NExFID0gZXhwb3J0cy5rZXlWYWxUb0J1ZmZlciA9IGV4cG9ydHMua2V5VmFsc1RvQnVmZmVyID0gZXhwb3J0cy5yZXZlcnNlQnVmZmVyID0gZXhwb3J0cy5yYW5nZSA9IHZvaWQgMDtcbmNvbnN0IHZhcnVpbnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdmFyaW50XCIpKTtcbmNvbnN0IHJhbmdlID0gKG4pID0+IFsuLi5BcnJheShuKS5rZXlzKCldO1xuZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xuZnVuY3Rpb24gcmV2ZXJzZUJ1ZmZlcihidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDEpXG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgbGV0IGogPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgICBsZXQgdG1wID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdG1wID0gYnVmZmVyW2ldO1xuICAgICAgICBidWZmZXJbaV0gPSBidWZmZXJbal07XG4gICAgICAgIGJ1ZmZlcltqXSA9IHRtcDtcbiAgICAgICAgai0tO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5yZXZlcnNlQnVmZmVyID0gcmV2ZXJzZUJ1ZmZlcjtcbmZ1bmN0aW9uIGtleVZhbHNUb0J1ZmZlcihrZXlWYWxzKSB7XG4gICAgY29uc3QgYnVmZmVycyA9IGtleVZhbHMubWFwKGtleVZhbFRvQnVmZmVyKTtcbiAgICBidWZmZXJzLnB1c2goQnVmZmVyLmZyb20oWzBdKSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG59XG5leHBvcnRzLmtleVZhbHNUb0J1ZmZlciA9IGtleVZhbHNUb0J1ZmZlcjtcbmZ1bmN0aW9uIGtleVZhbFRvQnVmZmVyKGtleVZhbCkge1xuICAgIGNvbnN0IGtleUxlbiA9IGtleVZhbC5rZXkubGVuZ3RoO1xuICAgIGNvbnN0IHZhbExlbiA9IGtleVZhbC52YWx1ZS5sZW5ndGg7XG4gICAgY29uc3Qga2V5VmFySW50TGVuID0gdmFydWludC5lbmNvZGluZ0xlbmd0aChrZXlMZW4pO1xuICAgIGNvbnN0IHZhbFZhckludExlbiA9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgodmFsTGVuKTtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoa2V5VmFySW50TGVuICsga2V5TGVuICsgdmFsVmFySW50TGVuICsgdmFsTGVuKTtcbiAgICB2YXJ1aW50LmVuY29kZShrZXlMZW4sIGJ1ZmZlciwgMCk7XG4gICAga2V5VmFsLmtleS5jb3B5KGJ1ZmZlciwga2V5VmFySW50TGVuKTtcbiAgICB2YXJ1aW50LmVuY29kZSh2YWxMZW4sIGJ1ZmZlciwga2V5VmFySW50TGVuICsga2V5TGVuKTtcbiAgICBrZXlWYWwudmFsdWUuY29weShidWZmZXIsIGtleVZhckludExlbiArIGtleUxlbiArIHZhbFZhckludExlbik7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMua2V5VmFsVG9CdWZmZXIgPSBrZXlWYWxUb0J1ZmZlcjtcbmZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSwgbWF4KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuICAgIGlmICh2YWx1ZSA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKTtcbiAgICBpZiAodmFsdWUgPiBtYXgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmFuZ2VFcnJvcjogdmFsdWUgb3V0IG9mIHJhbmdlJyk7XG4gICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuZnVuY3Rpb24gcmVhZFVJbnQ2NExFKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgY29uc3QgYSA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICBsZXQgYiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgYiAqPSAweDEwMDAwMDAwMDtcbiAgICB2ZXJpZnVpbnQoYiArIGEsIDB4MDAxZmZmZmZmZmZmZmZmZik7XG4gICAgcmV0dXJuIGIgKyBhO1xufVxuZXhwb3J0cy5yZWFkVUludDY0TEUgPSByZWFkVUludDY0TEU7XG5mdW5jdGlvbiB3cml0ZVVJbnQ2NExFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCkge1xuICAgIHZlcmlmdWludCh2YWx1ZSwgMHgwMDFmZmZmZmZmZmZmZmZmKTtcbiAgICBidWZmZXIud3JpdGVJbnQzMkxFKHZhbHVlICYgLTEsIG9mZnNldCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWx1ZSAvIDB4MTAwMDAwMDAwKSwgb2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIG9mZnNldCArIDg7XG59XG5leHBvcnRzLndyaXRlVUludDY0TEUgPSB3cml0ZVVJbnQ2NExFO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9vbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/tools.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js':
    /*!******************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js ***!
  \******************************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodingLength = exports.decode = exports.encode = void 0;\nconst MAX_SAFE_INTEGER = 9007199254740991;\nfunction checkUInt53(n) {\n    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)\n        throw new RangeError('value out of range');\n}\nfunction encode(_number, buffer, offset) {\n    checkUInt53(_number);\n    if (!buffer)\n        buffer = Buffer.allocUnsafe(encodingLength(_number));\n    if (!Buffer.isBuffer(buffer))\n        throw new TypeError('buffer must be a Buffer instance');\n    if (!offset)\n        offset = 0;\n    if (_number < 0xfd) {\n        buffer.writeUInt8(_number, offset);\n        Object.assign(encode, { bytes: 1 });\n    }\n    else if (_number <= 0xffff) {\n        buffer.writeUInt8(0xfd, offset);\n        buffer.writeUInt16LE(_number, offset + 1);\n        Object.assign(encode, { bytes: 3 });\n    }\n    else if (_number <= 0xffffffff) {\n        buffer.writeUInt8(0xfe, offset);\n        buffer.writeUInt32LE(_number, offset + 1);\n        Object.assign(encode, { bytes: 5 });\n    }\n    else {\n        buffer.writeUInt8(0xff, offset);\n        buffer.writeUInt32LE(_number >>> 0, offset + 1);\n        buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);\n        Object.assign(encode, { bytes: 9 });\n    }\n    return buffer;\n}\nexports.encode = encode;\nfunction decode(buffer, offset) {\n    if (!Buffer.isBuffer(buffer))\n        throw new TypeError('buffer must be a Buffer instance');\n    if (!offset)\n        offset = 0;\n    const first = buffer.readUInt8(offset);\n    if (first < 0xfd) {\n        Object.assign(decode, { bytes: 1 });\n        return first;\n    }\n    else if (first === 0xfd) {\n        Object.assign(decode, { bytes: 3 });\n        return buffer.readUInt16LE(offset + 1);\n    }\n    else if (first === 0xfe) {\n        Object.assign(decode, { bytes: 5 });\n        return buffer.readUInt32LE(offset + 1);\n    }\n    else {\n        Object.assign(decode, { bytes: 9 });\n        const lo = buffer.readUInt32LE(offset + 1);\n        const hi = buffer.readUInt32LE(offset + 5);\n        const _number = hi * 0x0100000000 + lo;\n        checkUInt53(_number);\n        return _number;\n    }\n}\nexports.decode = decode;\nfunction encodingLength(_number) {\n    checkUInt53(_number);\n    return _number < 0xfd\n        ? 1\n        : _number <= 0xffff\n            ? 3\n            : _number <= 0xffffffff\n                ? 5\n                : 9;\n}\nexports.encodingLength = encodingLength;\n//# sourceMappingURL=varint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3ZhcmludC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvY29udmVydGVyL3ZhcmludC5qcz9hZDliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbmZ1bmN0aW9uIGNoZWNrVUludDUzKG4pIHtcbiAgICBpZiAobiA8IDAgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgbiAlIDEgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBvdXQgb2YgcmFuZ2UnKTtcbn1cbmZ1bmN0aW9uIGVuY29kZShfbnVtYmVyLCBidWZmZXIsIG9mZnNldCkge1xuICAgIGNoZWNrVUludDUzKF9udW1iZXIpO1xuICAgIGlmICghYnVmZmVyKVxuICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgoX251bWJlcikpO1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gICAgaWYgKCFvZmZzZXQpXG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgaWYgKF9udW1iZXIgPCAweGZkKSB7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KF9udW1iZXIsIG9mZnNldCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZW5jb2RlLCB7IGJ5dGVzOiAxIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChfbnVtYmVyIDw9IDB4ZmZmZikge1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OCgweGZkLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MTZMRShfbnVtYmVyLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbmNvZGUsIHsgYnl0ZXM6IDMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9udW1iZXIgPD0gMHhmZmZmZmZmZikge1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OCgweGZlLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShfbnVtYmVyLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbmNvZGUsIHsgYnl0ZXM6IDUgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OCgweGZmLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShfbnVtYmVyID4+PiAwLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoKF9udW1iZXIgLyAweDEwMDAwMDAwMCkgfCAwLCBvZmZzZXQgKyA1KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbmNvZGUsIHsgYnl0ZXM6IDkgfSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmZ1bmN0aW9uIGRlY29kZShidWZmZXIsIG9mZnNldCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gICAgaWYgKCFvZmZzZXQpXG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgY29uc3QgZmlyc3QgPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgaWYgKGZpcnN0IDwgMHhmZCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGRlY29kZSwgeyBieXRlczogMSB9KTtcbiAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdCA9PT0gMHhmZCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGRlY29kZSwgeyBieXRlczogMyB9KTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDE2TEUob2Zmc2V0ICsgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0ID09PSAweGZlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVjb2RlLCB7IGJ5dGVzOiA1IH0pO1xuICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVjb2RlLCB7IGJ5dGVzOiA5IH0pO1xuICAgICAgICBjb25zdCBsbyA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgMSk7XG4gICAgICAgIGNvbnN0IGhpID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA1KTtcbiAgICAgICAgY29uc3QgX251bWJlciA9IGhpICogMHgwMTAwMDAwMDAwICsgbG87XG4gICAgICAgIGNoZWNrVUludDUzKF9udW1iZXIpO1xuICAgICAgICByZXR1cm4gX251bWJlcjtcbiAgICB9XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoKF9udW1iZXIpIHtcbiAgICBjaGVja1VJbnQ1MyhfbnVtYmVyKTtcbiAgICByZXR1cm4gX251bWJlciA8IDB4ZmRcbiAgICAgICAgPyAxXG4gICAgICAgIDogX251bWJlciA8PSAweGZmZmZcbiAgICAgICAgICAgID8gM1xuICAgICAgICAgICAgOiBfbnVtYmVyIDw9IDB4ZmZmZmZmZmZcbiAgICAgICAgICAgICAgICA/IDVcbiAgICAgICAgICAgICAgICA6IDk7XG59XG5leHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YXJpbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/fromBuffer.js':
    /*!*******************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/fromBuffer.js ***!
  \*******************************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.psbtFromKeyVals = exports.checkKeyBuffer = exports.psbtFromBuffer = void 0;\nconst convert = __importStar(__webpack_require__(/*! ../converter */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/index.js\"));\nconst tools_1 = __webpack_require__(/*! ../converter/tools */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/tools.js\");\nconst varuint = __importStar(__webpack_require__(/*! ../converter/varint */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js\"));\nconst typeFields_1 = __webpack_require__(/*! ../typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nfunction psbtFromBuffer(buffer, txGetter) {\n    let offset = 0;\n    function varSlice() {\n        const keyLen = varuint.decode(buffer, offset);\n        offset += varuint.encodingLength(keyLen);\n        const key = buffer.slice(offset, offset + keyLen);\n        offset += keyLen;\n        return key;\n    }\n    function readUInt32BE() {\n        const num = buffer.readUInt32BE(offset);\n        offset += 4;\n        return num;\n    }\n    function readUInt8() {\n        const num = buffer.readUInt8(offset);\n        offset += 1;\n        return num;\n    }\n    function getKeyValue() {\n        const key = varSlice();\n        const value = varSlice();\n        return {\n            key,\n            value,\n        };\n    }\n    function checkEndOfKeyValPairs() {\n        if (offset >= buffer.length) {\n            throw new Error('Format Error: Unexpected End of PSBT');\n        }\n        const isEnd = buffer.readUInt8(offset) === 0;\n        if (isEnd) {\n            offset++;\n        }\n        return isEnd;\n    }\n    if (readUInt32BE() !== 0x70736274) {\n        throw new Error('Format Error: Invalid Magic Number');\n    }\n    if (readUInt8() !== 0xff) {\n        throw new Error('Format Error: Magic Number must be followed by 0xff separator');\n    }\n    const globalMapKeyVals = [];\n    const globalKeyIndex = {};\n    while (!checkEndOfKeyValPairs()) {\n        const keyVal = getKeyValue();\n        const hexKey = keyVal.key.toString('hex');\n        if (globalKeyIndex[hexKey]) {\n            throw new Error('Format Error: Keys must be unique for global keymap: key ' + hexKey);\n        }\n        globalKeyIndex[hexKey] = 1;\n        globalMapKeyVals.push(keyVal);\n    }\n    const unsignedTxMaps = globalMapKeyVals.filter(keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX);\n    if (unsignedTxMaps.length !== 1) {\n        throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n    }\n    const unsignedTx = txGetter(unsignedTxMaps[0].value);\n    const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n    const inputKeyVals = [];\n    const outputKeyVals = [];\n    for (const index of (0, tools_1.range)(inputCount)) {\n        const inputKeyIndex = {};\n        const input = [];\n        while (!checkEndOfKeyValPairs()) {\n            const keyVal = getKeyValue();\n            const hexKey = keyVal.key.toString('hex');\n            if (inputKeyIndex[hexKey]) {\n                throw new Error('Format Error: Keys must be unique for each input: ' +\n                    'input index ' +\n                    index +\n                    ' key ' +\n                    hexKey);\n            }\n            inputKeyIndex[hexKey] = 1;\n            input.push(keyVal);\n        }\n        inputKeyVals.push(input);\n    }\n    for (const index of (0, tools_1.range)(outputCount)) {\n        const outputKeyIndex = {};\n        const output = [];\n        while (!checkEndOfKeyValPairs()) {\n            const keyVal = getKeyValue();\n            const hexKey = keyVal.key.toString('hex');\n            if (outputKeyIndex[hexKey]) {\n                throw new Error('Format Error: Keys must be unique for each output: ' +\n                    'output index ' +\n                    index +\n                    ' key ' +\n                    hexKey);\n            }\n            outputKeyIndex[hexKey] = 1;\n            output.push(keyVal);\n        }\n        outputKeyVals.push(output);\n    }\n    return psbtFromKeyVals(unsignedTx, {\n        globalMapKeyVals,\n        inputKeyVals,\n        outputKeyVals,\n    });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n    if (!keyBuf.equals(Buffer.from([keyNum]))) {\n        throw new Error(`Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`);\n    }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {\n    const globalMap = {\n        unsignedTx,\n    };\n    let txCount = 0;\n    for (const keyVal of globalMapKeyVals) {\n        switch (keyVal.key[0]) {\n            case typeFields_1.GlobalTypes.UNSIGNED_TX:\n                checkKeyBuffer('global', keyVal.key, typeFields_1.GlobalTypes.UNSIGNED_TX);\n                if (txCount > 0) {\n                    throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n                }\n                txCount++;\n                break;\n            case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n                if (globalMap.globalXpub === undefined) {\n                    globalMap.globalXpub = [];\n                }\n                globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n                break;\n            default:\n                if (!globalMap.unknownKeyVals)\n                    globalMap.unknownKeyVals = [];\n                globalMap.unknownKeyVals.push(keyVal);\n        }\n    }\n    const inputCount = inputKeyVals.length;\n    const outputCount = outputKeyVals.length;\n    const inputs = [];\n    const outputs = [];\n    for (const index of (0, tools_1.range)(inputCount)) {\n        const input = {};\n        for (const keyVal of inputKeyVals[index]) {\n            convert.inputs.checkPubkey(keyVal);\n            switch (keyVal.key[0]) {\n                case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.NON_WITNESS_UTXO);\n                    if (input.nonWitnessUtxo !== undefined) {\n                        throw new Error('Format Error: Input has multiple NON_WITNESS_UTXO');\n                    }\n                    input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.WITNESS_UTXO:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_UTXO);\n                    if (input.witnessUtxo !== undefined) {\n                        throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n                    }\n                    input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.PARTIAL_SIG:\n                    if (input.partialSig === undefined) {\n                        input.partialSig = [];\n                    }\n                    input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n                    break;\n                case typeFields_1.InputTypes.SIGHASH_TYPE:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.SIGHASH_TYPE);\n                    if (input.sighashType !== undefined) {\n                        throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n                    }\n                    input.sighashType = convert.inputs.sighashType.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.REDEEM_SCRIPT:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.REDEEM_SCRIPT);\n                    if (input.redeemScript !== undefined) {\n                        throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n                    }\n                    input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.WITNESS_SCRIPT:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_SCRIPT);\n                    if (input.witnessScript !== undefined) {\n                        throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n                    }\n                    input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.BIP32_DERIVATION:\n                    if (input.bip32Derivation === undefined) {\n                        input.bip32Derivation = [];\n                    }\n                    input.bip32Derivation.push(convert.inputs.bip32Derivation.decode(keyVal));\n                    break;\n                case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTSIG);\n                    input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTWITNESS);\n                    input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.POR_COMMITMENT:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.POR_COMMITMENT);\n                    input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.TAP_KEY_SIG:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.TAP_KEY_SIG);\n                    input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n                    if (input.tapScriptSig === undefined) {\n                        input.tapScriptSig = [];\n                    }\n                    input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n                    break;\n                case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n                    if (input.tapLeafScript === undefined) {\n                        input.tapLeafScript = [];\n                    }\n                    input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n                    break;\n                case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n                    if (input.tapBip32Derivation === undefined) {\n                        input.tapBip32Derivation = [];\n                    }\n                    input.tapBip32Derivation.push(convert.inputs.tapBip32Derivation.decode(keyVal));\n                    break;\n                case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.TAP_INTERNAL_KEY);\n                    input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n                    break;\n                case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n                    checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.TAP_MERKLE_ROOT);\n                    input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n                    break;\n                default:\n                    if (!input.unknownKeyVals)\n                        input.unknownKeyVals = [];\n                    input.unknownKeyVals.push(keyVal);\n            }\n        }\n        inputs.push(input);\n    }\n    for (const index of (0, tools_1.range)(outputCount)) {\n        const output = {};\n        for (const keyVal of outputKeyVals[index]) {\n            convert.outputs.checkPubkey(keyVal);\n            switch (keyVal.key[0]) {\n                case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n                    checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.REDEEM_SCRIPT);\n                    if (output.redeemScript !== undefined) {\n                        throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n                    }\n                    output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n                    break;\n                case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n                    checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.WITNESS_SCRIPT);\n                    if (output.witnessScript !== undefined) {\n                        throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n                    }\n                    output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n                    break;\n                case typeFields_1.OutputTypes.BIP32_DERIVATION:\n                    if (output.bip32Derivation === undefined) {\n                        output.bip32Derivation = [];\n                    }\n                    output.bip32Derivation.push(convert.outputs.bip32Derivation.decode(keyVal));\n                    break;\n                case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n                    checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.TAP_INTERNAL_KEY);\n                    output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n                    break;\n                case typeFields_1.OutputTypes.TAP_TREE:\n                    checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.TAP_TREE);\n                    output.tapTree = convert.outputs.tapTree.decode(keyVal);\n                    break;\n                case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n                    if (output.tapBip32Derivation === undefined) {\n                        output.tapBip32Derivation = [];\n                    }\n                    output.tapBip32Derivation.push(convert.outputs.tapBip32Derivation.decode(keyVal));\n                    break;\n                default:\n                    if (!output.unknownKeyVals)\n                        output.unknownKeyVals = [];\n                    output.unknownKeyVals.push(keyVal);\n            }\n        }\n        outputs.push(output);\n    }\n    return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n//# sourceMappingURL=fromBuffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvcGFyc2VyL2Zyb21CdWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQjtBQUN6RSw2QkFBNkIsbUJBQU8sQ0FBQyw2R0FBYztBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxtSEFBb0I7QUFDNUMsNkJBQTZCLG1CQUFPLENBQUMscUhBQXFCO0FBQzFELHFCQUFxQixtQkFBTyxDQUFDLHlHQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGlEQUFpRCxNQUFNLE9BQU8sdUJBQXVCO0FBQ3JGO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUNBQXVDLCtDQUErQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L3BhcnNlci9mcm9tQnVmZmVyLmpzP2E3NTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHNidEZyb21LZXlWYWxzID0gZXhwb3J0cy5jaGVja0tleUJ1ZmZlciA9IGV4cG9ydHMucHNidEZyb21CdWZmZXIgPSB2b2lkIDA7XG5jb25zdCBjb252ZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jb252ZXJ0ZXJcIikpO1xuY29uc3QgdG9vbHNfMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJ0ZXIvdG9vbHNcIik7XG5jb25zdCB2YXJ1aW50ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jb252ZXJ0ZXIvdmFyaW50XCIpKTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoXCIuLi90eXBlRmllbGRzXCIpO1xuZnVuY3Rpb24gcHNidEZyb21CdWZmZXIoYnVmZmVyLCB0eEdldHRlcikge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZ1bmN0aW9uIHZhclNsaWNlKCkge1xuICAgICAgICBjb25zdCBrZXlMZW4gPSB2YXJ1aW50LmRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGtleUxlbik7XG4gICAgICAgIGNvbnN0IGtleSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGtleUxlbik7XG4gICAgICAgIG9mZnNldCArPSBrZXlMZW47XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRVSW50MzJCRSgpIHtcbiAgICAgICAgY29uc3QgbnVtID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZFVJbnQ4KCkge1xuICAgICAgICBjb25zdCBudW0gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRLZXlWYWx1ZSgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdmFyU2xpY2UoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YXJTbGljZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRW5kT2ZLZXlWYWxQYWlycygpIHtcbiAgICAgICAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogVW5leHBlY3RlZCBFbmQgb2YgUFNCVCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRW5kID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpID09PSAwO1xuICAgICAgICBpZiAoaXNFbmQpIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0VuZDtcbiAgICB9XG4gICAgaWYgKHJlYWRVSW50MzJCRSgpICE9PSAweDcwNzM2Mjc0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBJbnZhbGlkIE1hZ2ljIE51bWJlcicpO1xuICAgIH1cbiAgICBpZiAocmVhZFVJbnQ4KCkgIT09IDB4ZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IE1hZ2ljIE51bWJlciBtdXN0IGJlIGZvbGxvd2VkIGJ5IDB4ZmYgc2VwYXJhdG9yJyk7XG4gICAgfVxuICAgIGNvbnN0IGdsb2JhbE1hcEtleVZhbHMgPSBbXTtcbiAgICBjb25zdCBnbG9iYWxLZXlJbmRleCA9IHt9O1xuICAgIHdoaWxlICghY2hlY2tFbmRPZktleVZhbFBhaXJzKCkpIHtcbiAgICAgICAgY29uc3Qga2V5VmFsID0gZ2V0S2V5VmFsdWUoKTtcbiAgICAgICAgY29uc3QgaGV4S2V5ID0ga2V5VmFsLmtleS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIGlmIChnbG9iYWxLZXlJbmRleFtoZXhLZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogS2V5cyBtdXN0IGJlIHVuaXF1ZSBmb3IgZ2xvYmFsIGtleW1hcDoga2V5ICcgKyBoZXhLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbEtleUluZGV4W2hleEtleV0gPSAxO1xuICAgICAgICBnbG9iYWxNYXBLZXlWYWxzLnB1c2goa2V5VmFsKTtcbiAgICB9XG4gICAgY29uc3QgdW5zaWduZWRUeE1hcHMgPSBnbG9iYWxNYXBLZXlWYWxzLmZpbHRlcihrZXlWYWwgPT4ga2V5VmFsLmtleVswXSA9PT0gdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLlVOU0lHTkVEX1RYKTtcbiAgICBpZiAodW5zaWduZWRUeE1hcHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBPbmx5IG9uZSBVTlNJR05FRF9UWCBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHVuc2lnbmVkVHggPSB0eEdldHRlcih1bnNpZ25lZFR4TWFwc1swXS52YWx1ZSk7XG4gICAgY29uc3QgeyBpbnB1dENvdW50LCBvdXRwdXRDb3VudCB9ID0gdW5zaWduZWRUeC5nZXRJbnB1dE91dHB1dENvdW50cygpO1xuICAgIGNvbnN0IGlucHV0S2V5VmFscyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dEtleVZhbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mICgwLCB0b29sc18xLnJhbmdlKShpbnB1dENvdW50KSkge1xuICAgICAgICBjb25zdCBpbnB1dEtleUluZGV4ID0ge307XG4gICAgICAgIGNvbnN0IGlucHV0ID0gW107XG4gICAgICAgIHdoaWxlICghY2hlY2tFbmRPZktleVZhbFBhaXJzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbCA9IGdldEtleVZhbHVlKCk7XG4gICAgICAgICAgICBjb25zdCBoZXhLZXkgPSBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIGlmIChpbnB1dEtleUluZGV4W2hleEtleV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogS2V5cyBtdXN0IGJlIHVuaXF1ZSBmb3IgZWFjaCBpbnB1dDogJyArXG4gICAgICAgICAgICAgICAgICAgICdpbnB1dCBpbmRleCAnICtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAnIGtleSAnICtcbiAgICAgICAgICAgICAgICAgICAgaGV4S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0S2V5SW5kZXhbaGV4S2V5XSA9IDE7XG4gICAgICAgICAgICBpbnB1dC5wdXNoKGtleVZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRLZXlWYWxzLnB1c2goaW5wdXQpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mICgwLCB0b29sc18xLnJhbmdlKShvdXRwdXRDb3VudCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0S2V5SW5kZXggPSB7fTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIHdoaWxlICghY2hlY2tFbmRPZktleVZhbFBhaXJzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbCA9IGdldEtleVZhbHVlKCk7XG4gICAgICAgICAgICBjb25zdCBoZXhLZXkgPSBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXRLZXlJbmRleFtoZXhLZXldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IEtleXMgbXVzdCBiZSB1bmlxdWUgZm9yIGVhY2ggb3V0cHV0OiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ291dHB1dCBpbmRleCAnICtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAnIGtleSAnICtcbiAgICAgICAgICAgICAgICAgICAgaGV4S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dEtleUluZGV4W2hleEtleV0gPSAxO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goa2V5VmFsKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRLZXlWYWxzLnB1c2gob3V0cHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBzYnRGcm9tS2V5VmFscyh1bnNpZ25lZFR4LCB7XG4gICAgICAgIGdsb2JhbE1hcEtleVZhbHMsXG4gICAgICAgIGlucHV0S2V5VmFscyxcbiAgICAgICAgb3V0cHV0S2V5VmFscyxcbiAgICB9KTtcbn1cbmV4cG9ydHMucHNidEZyb21CdWZmZXIgPSBwc2J0RnJvbUJ1ZmZlcjtcbmZ1bmN0aW9uIGNoZWNrS2V5QnVmZmVyKHR5cGUsIGtleUJ1Ziwga2V5TnVtKSB7XG4gICAgaWYgKCFrZXlCdWYuZXF1YWxzKEJ1ZmZlci5mcm9tKFtrZXlOdW1dKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtYXQgRXJyb3I6IEludmFsaWQgJHt0eXBlfSBrZXk6ICR7a2V5QnVmLnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrS2V5QnVmZmVyID0gY2hlY2tLZXlCdWZmZXI7XG5mdW5jdGlvbiBwc2J0RnJvbUtleVZhbHModW5zaWduZWRUeCwgeyBnbG9iYWxNYXBLZXlWYWxzLCBpbnB1dEtleVZhbHMsIG91dHB1dEtleVZhbHMgfSkge1xuICAgIGNvbnN0IGdsb2JhbE1hcCA9IHtcbiAgICAgICAgdW5zaWduZWRUeCxcbiAgICB9O1xuICAgIGxldCB0eENvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleVZhbCBvZiBnbG9iYWxNYXBLZXlWYWxzKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5VmFsLmtleVswXSkge1xuICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuVU5TSUdORURfVFg6XG4gICAgICAgICAgICAgICAgY2hlY2tLZXlCdWZmZXIoJ2dsb2JhbCcsIGtleVZhbC5rZXksIHR5cGVGaWVsZHNfMS5HbG9iYWxUeXBlcy5VTlNJR05FRF9UWCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBHbG9iYWxNYXAgaGFzIG11bHRpcGxlIFVOU0lHTkVEX1RYJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4Q291bnQrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLkdMT0JBTF9YUFVCOlxuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxNYXAuZ2xvYmFsWHB1YiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbE1hcC5nbG9iYWxYcHViID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsb2JhbE1hcC5nbG9iYWxYcHViLnB1c2goY29udmVydC5nbG9iYWxzLmdsb2JhbFhwdWIuZGVjb2RlKGtleVZhbCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbE1hcC51bmtub3duS2V5VmFscylcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsTWFwLnVua25vd25LZXlWYWxzID0gW107XG4gICAgICAgICAgICAgICAgZ2xvYmFsTWFwLnVua25vd25LZXlWYWxzLnB1c2goa2V5VmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnB1dENvdW50ID0gaW5wdXRLZXlWYWxzLmxlbmd0aDtcbiAgICBjb25zdCBvdXRwdXRDb3VudCA9IG91dHB1dEtleVZhbHMubGVuZ3RoO1xuICAgIGNvbnN0IGlucHV0cyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mICgwLCB0b29sc18xLnJhbmdlKShpbnB1dENvdW50KSkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleVZhbCBvZiBpbnB1dEtleVZhbHNbaW5kZXhdKSB7XG4gICAgICAgICAgICBjb252ZXJ0LmlucHV0cy5jaGVja1B1YmtleShrZXlWYWwpO1xuICAgICAgICAgICAgc3dpdGNoIChrZXlWYWwua2V5WzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5OT05fV0lUTkVTU19VVFhPOlxuICAgICAgICAgICAgICAgICAgICBjaGVja0tleUJ1ZmZlcignaW5wdXQnLCBrZXlWYWwua2V5LCB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5OT05fV0lUTkVTU19VVFhPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBJbnB1dCBoYXMgbXVsdGlwbGUgTk9OX1dJVE5FU1NfVVRYTycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlucHV0Lm5vbldpdG5lc3NVdHhvID0gY29udmVydC5pbnB1dHMubm9uV2l0bmVzc1V0eG8uZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19VVFhPOlxuICAgICAgICAgICAgICAgICAgICBjaGVja0tleUJ1ZmZlcignaW5wdXQnLCBrZXlWYWwua2V5LCB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5XSVRORVNTX1VUWE8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQud2l0bmVzc1V0eG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBXSVRORVNTX1VUWE8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dC53aXRuZXNzVXR4byA9IGNvbnZlcnQuaW5wdXRzLndpdG5lc3NVdHhvLmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlBBUlRJQUxfU0lHOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQucGFydGlhbFNpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5wYXJ0aWFsU2lnID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5wdXQucGFydGlhbFNpZy5wdXNoKGNvbnZlcnQuaW5wdXRzLnBhcnRpYWxTaWcuZGVjb2RlKGtleVZhbCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlNJR0hBU0hfVFlQRTpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXlCdWZmZXIoJ2lucHV0Jywga2V5VmFsLmtleSwgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuU0lHSEFTSF9UWVBFKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnNpZ2hhc2hUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBJbnB1dCBoYXMgbXVsdGlwbGUgU0lHSEFTSF9UWVBFJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2lnaGFzaFR5cGUgPSBjb252ZXJ0LmlucHV0cy5zaWdoYXNoVHlwZS5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5SRURFRU1fU0NSSVBUOlxuICAgICAgICAgICAgICAgICAgICBjaGVja0tleUJ1ZmZlcignaW5wdXQnLCBrZXlWYWwua2V5LCB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5SRURFRU1fU0NSSVBUKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnJlZGVlbVNjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogSW5wdXQgaGFzIG11bHRpcGxlIFJFREVFTV9TQ1JJUFQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5yZWRlZW1TY3JpcHQgPSBjb252ZXJ0LmlucHV0cy5yZWRlZW1TY3JpcHQuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19TQ1JJUFQ6XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKCdpbnB1dCcsIGtleVZhbC5rZXksIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLldJVE5FU1NfU0NSSVBUKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LndpdG5lc3NTY3JpcHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBXSVRORVNTX1NDUklQVCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LndpdG5lc3NTY3JpcHQgPSBjb252ZXJ0LmlucHV0cy53aXRuZXNzU2NyaXB0LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkJJUDMyX0RFUklWQVRJT046XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5iaXAzMkRlcml2YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuYmlwMzJEZXJpdmF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYmlwMzJEZXJpdmF0aW9uLnB1c2goY29udmVydC5pbnB1dHMuYmlwMzJEZXJpdmF0aW9uLmRlY29kZShrZXlWYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRTSUc6XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKCdpbnB1dCcsIGtleVZhbC5rZXksIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFNJRyk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmZpbmFsU2NyaXB0U2lnID0gY29udmVydC5pbnB1dHMuZmluYWxTY3JpcHRTaWcuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUV0lUTkVTUzpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXlCdWZmZXIoJ2lucHV0Jywga2V5VmFsLmtleSwgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUV0lUTkVTUyk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcyA9IGNvbnZlcnQuaW5wdXRzLmZpbmFsU2NyaXB0V2l0bmVzcy5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QT1JfQ09NTUlUTUVOVDpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXlCdWZmZXIoJ2lucHV0Jywga2V5VmFsLmtleSwgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUE9SX0NPTU1JVE1FTlQpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5wb3JDb21taXRtZW50ID0gY29udmVydC5pbnB1dHMucG9yQ29tbWl0bWVudC5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfS0VZX1NJRzpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXlCdWZmZXIoJ2lucHV0Jywga2V5VmFsLmtleSwgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0tFWV9TSUcpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC50YXBLZXlTaWcgPSBjb252ZXJ0LmlucHV0cy50YXBLZXlTaWcuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX1NDUklQVF9TSUc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC50YXBTY3JpcHRTaWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudGFwU2NyaXB0U2lnID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudGFwU2NyaXB0U2lnLnB1c2goY29udmVydC5pbnB1dHMudGFwU2NyaXB0U2lnLmRlY29kZShrZXlWYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTEVBRl9TQ1JJUFQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnRhcExlYWZTY3JpcHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dC50YXBMZWFmU2NyaXB0LnB1c2goY29udmVydC5pbnB1dHMudGFwTGVhZlNjcmlwdC5kZWNvZGUoa2V5VmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0JJUDMyX0RFUklWQVRJT046XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC50YXBCaXAzMkRlcml2YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uLnB1c2goY29udmVydC5pbnB1dHMudGFwQmlwMzJEZXJpdmF0aW9uLmRlY29kZShrZXlWYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfSU5URVJOQUxfS0VZOlxuICAgICAgICAgICAgICAgICAgICBjaGVja0tleUJ1ZmZlcignaW5wdXQnLCBrZXlWYWwua2V5LCB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfSU5URVJOQUxfS0VZKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudGFwSW50ZXJuYWxLZXkgPSBjb252ZXJ0LmlucHV0cy50YXBJbnRlcm5hbEtleS5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTUVSS0xFX1JPT1Q6XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKCdpbnB1dCcsIGtleVZhbC5rZXksIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9NRVJLTEVfUk9PVCk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnRhcE1lcmtsZVJvb3QgPSBjb252ZXJ0LmlucHV0cy50YXBNZXJrbGVSb290LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0LnVua25vd25LZXlWYWxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudW5rbm93bktleVZhbHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0cy5wdXNoKGlucHV0KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiAoMCwgdG9vbHNfMS5yYW5nZSkob3V0cHV0Q291bnQpKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleVZhbCBvZiBvdXRwdXRLZXlWYWxzW2luZGV4XSkge1xuICAgICAgICAgICAgY29udmVydC5vdXRwdXRzLmNoZWNrUHVia2V5KGtleVZhbCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleVZhbC5rZXlbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5SRURFRU1fU0NSSVBUOlxuICAgICAgICAgICAgICAgICAgICBjaGVja0tleUJ1ZmZlcignb3V0cHV0Jywga2V5VmFsLmtleSwgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlJFREVFTV9TQ1JJUFQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0LnJlZGVlbVNjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogT3V0cHV0IGhhcyBtdWx0aXBsZSBSRURFRU1fU0NSSVBUJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnJlZGVlbVNjcmlwdCA9IGNvbnZlcnQub3V0cHV0cy5yZWRlZW1TY3JpcHQuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLldJVE5FU1NfU0NSSVBUOlxuICAgICAgICAgICAgICAgICAgICBjaGVja0tleUJ1ZmZlcignb3V0cHV0Jywga2V5VmFsLmtleSwgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLldJVE5FU1NfU0NSSVBUKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC53aXRuZXNzU2NyaXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBPdXRwdXQgaGFzIG11bHRpcGxlIFdJVE5FU1NfU0NSSVBUJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LndpdG5lc3NTY3JpcHQgPSBjb252ZXJ0Lm91dHB1dHMud2l0bmVzc1NjcmlwdC5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuQklQMzJfREVSSVZBVElPTjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5iaXAzMkRlcml2YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmJpcDMyRGVyaXZhdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5iaXAzMkRlcml2YXRpb24ucHVzaChjb252ZXJ0Lm91dHB1dHMuYmlwMzJEZXJpdmF0aW9uLmRlY29kZShrZXlWYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuVEFQX0lOVEVSTkFMX0tFWTpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXlCdWZmZXIoJ291dHB1dCcsIGtleVZhbC5rZXksIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5UQVBfSU5URVJOQUxfS0VZKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRhcEludGVybmFsS2V5ID0gY29udmVydC5vdXRwdXRzLnRhcEludGVybmFsS2V5LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5UQVBfVFJFRTpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXlCdWZmZXIoJ291dHB1dCcsIGtleVZhbC5rZXksIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5UQVBfVFJFRSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC50YXBUcmVlID0gY29udmVydC5vdXRwdXRzLnRhcFRyZWUuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9CSVAzMl9ERVJJVkFUSU9OOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0LnRhcEJpcDMyRGVyaXZhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudGFwQmlwMzJEZXJpdmF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRhcEJpcDMyRGVyaXZhdGlvbi5wdXNoKGNvbnZlcnQub3V0cHV0cy50YXBCaXAzMkRlcml2YXRpb24uZGVjb2RlKGtleVZhbCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW91dHB1dC51bmtub3duS2V5VmFscylcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC51bmtub3duS2V5VmFscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgIH1cbiAgICByZXR1cm4geyBnbG9iYWxNYXAsIGlucHV0cywgb3V0cHV0cyB9O1xufVxuZXhwb3J0cy5wc2J0RnJvbUtleVZhbHMgPSBwc2J0RnJvbUtleVZhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tQnVmZmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/fromBuffer.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/index.js':
    /*!**************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/index.js ***!
  \**************************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./fromBuffer */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/fromBuffer.js"), exports);\n__exportStar(__webpack_require__(/*! ./toBuffer */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/toBuffer.js"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvcGFyc2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywrR0FBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsMkdBQVk7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2JpcDE3NC9wYXJzZXIvaW5kZXguanM/MjZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Zyb21CdWZmZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RvQnVmZmVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/toBuffer.js':
    /*!*****************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/toBuffer.js ***!
  \*****************************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.psbtToKeyVals = exports.psbtToBuffer = void 0;\nconst convert = __importStar(__webpack_require__(/*! ../converter */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/index.js"));\nconst tools_1 = __webpack_require__(/*! ../converter/tools */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/tools.js");\nfunction psbtToBuffer({ globalMap, inputs, outputs, }) {\n    const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n        globalMap,\n        inputs,\n        outputs,\n    });\n    const globalBuffer = (0, tools_1.keyValsToBuffer)(globalKeyVals);\n    const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [Buffer.from([0])] : keyVals.map(tools_1.keyValsToBuffer);\n    const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n    const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n    const header = Buffer.allocUnsafe(5);\n    header.writeUIntBE(0x70736274ff, 0, 5);\n    return Buffer.concat([header, globalBuffer].concat(inputBuffers, outputBuffers));\n}\nexports.psbtToBuffer = psbtToBuffer;\nconst sortKeyVals = (a, b) => {\n    return a.key.compare(b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n    const keyHexSet = new Set();\n    const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n        if (key === \'unknownKeyVals\')\n            return result;\n        const converter = converterFactory[key];\n        if (converter === undefined)\n            return result;\n        const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(converter.encode);\n        const keyHexes = encodedKeyVals.map(kv => kv.key.toString(\'hex\'));\n        keyHexes.forEach(hex => {\n            if (keyHexSet.has(hex))\n                throw new Error(\'Serialize Error: Duplicate key: \' + hex);\n            keyHexSet.add(hex);\n        });\n        return result.concat(encodedKeyVals);\n    }, []);\n    const otherKeyVals = keyValMap.unknownKeyVals\n        ? keyValMap.unknownKeyVals.filter((keyVal) => {\n            return !keyHexSet.has(keyVal.key.toString(\'hex\'));\n        })\n        : [];\n    return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nfunction psbtToKeyVals({ globalMap, inputs, outputs, }) {\n    return {\n        globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n        inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n        outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n    };\n}\nexports.psbtToKeyVals = psbtToKeyVals;\n//# sourceMappingURL=toBuffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvcGFyc2VyL3RvQnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxvQkFBb0I7QUFDNUMsNkJBQTZCLG1CQUFPLENBQUMsNkdBQWM7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsbUhBQW9CO0FBQzVDLHdCQUF3Qiw2QkFBNkI7QUFDckQsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2JpcDE3NC9wYXJzZXIvdG9CdWZmZXIuanM/ZjRlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wc2J0VG9LZXlWYWxzID0gZXhwb3J0cy5wc2J0VG9CdWZmZXIgPSB2b2lkIDA7XG5jb25zdCBjb252ZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jb252ZXJ0ZXJcIikpO1xuY29uc3QgdG9vbHNfMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJ0ZXIvdG9vbHNcIik7XG5mdW5jdGlvbiBwc2J0VG9CdWZmZXIoeyBnbG9iYWxNYXAsIGlucHV0cywgb3V0cHV0cywgfSkge1xuICAgIGNvbnN0IHsgZ2xvYmFsS2V5VmFscywgaW5wdXRLZXlWYWxzLCBvdXRwdXRLZXlWYWxzIH0gPSBwc2J0VG9LZXlWYWxzKHtcbiAgICAgICAgZ2xvYmFsTWFwLFxuICAgICAgICBpbnB1dHMsXG4gICAgICAgIG91dHB1dHMsXG4gICAgfSk7XG4gICAgY29uc3QgZ2xvYmFsQnVmZmVyID0gKDAsIHRvb2xzXzEua2V5VmFsc1RvQnVmZmVyKShnbG9iYWxLZXlWYWxzKTtcbiAgICBjb25zdCBrZXlWYWxzT3JFbXB0eVRvQnVmZmVyID0gKGtleVZhbHMpID0+IGtleVZhbHMubGVuZ3RoID09PSAwID8gW0J1ZmZlci5mcm9tKFswXSldIDoga2V5VmFscy5tYXAodG9vbHNfMS5rZXlWYWxzVG9CdWZmZXIpO1xuICAgIGNvbnN0IGlucHV0QnVmZmVycyA9IGtleVZhbHNPckVtcHR5VG9CdWZmZXIoaW5wdXRLZXlWYWxzKTtcbiAgICBjb25zdCBvdXRwdXRCdWZmZXJzID0ga2V5VmFsc09yRW1wdHlUb0J1ZmZlcihvdXRwdXRLZXlWYWxzKTtcbiAgICBjb25zdCBoZWFkZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNSk7XG4gICAgaGVhZGVyLndyaXRlVUludEJFKDB4NzA3MzYyNzRmZiwgMCwgNSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2hlYWRlciwgZ2xvYmFsQnVmZmVyXS5jb25jYXQoaW5wdXRCdWZmZXJzLCBvdXRwdXRCdWZmZXJzKSk7XG59XG5leHBvcnRzLnBzYnRUb0J1ZmZlciA9IHBzYnRUb0J1ZmZlcjtcbmNvbnN0IHNvcnRLZXlWYWxzID0gKGEsIGIpID0+IHtcbiAgICByZXR1cm4gYS5rZXkuY29tcGFyZShiLmtleSk7XG59O1xuZnVuY3Rpb24ga2V5VmFsc0Zyb21NYXAoa2V5VmFsTWFwLCBjb252ZXJ0ZXJGYWN0b3J5KSB7XG4gICAgY29uc3Qga2V5SGV4U2V0ID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGtleVZhbHMgPSBPYmplY3QuZW50cmllcyhrZXlWYWxNYXApLnJlZHVjZSgocmVzdWx0LCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ3Vua25vd25LZXlWYWxzJylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IGNvbnZlcnRlckZhY3Rvcnlba2V5XTtcbiAgICAgICAgaWYgKGNvbnZlcnRlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY29uc3QgZW5jb2RlZEtleVZhbHMgPSAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pLm1hcChjb252ZXJ0ZXIuZW5jb2RlKTtcbiAgICAgICAgY29uc3Qga2V5SGV4ZXMgPSBlbmNvZGVkS2V5VmFscy5tYXAoa3YgPT4ga3Yua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgIGtleUhleGVzLmZvckVhY2goaGV4ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXlIZXhTZXQuaGFzKGhleCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJpYWxpemUgRXJyb3I6IER1cGxpY2F0ZSBrZXk6ICcgKyBoZXgpO1xuICAgICAgICAgICAga2V5SGV4U2V0LmFkZChoZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoZW5jb2RlZEtleVZhbHMpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBvdGhlcktleVZhbHMgPSBrZXlWYWxNYXAudW5rbm93bktleVZhbHNcbiAgICAgICAgPyBrZXlWYWxNYXAudW5rbm93bktleVZhbHMuZmlsdGVyKChrZXlWYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAha2V5SGV4U2V0LmhhcyhrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgcmV0dXJuIGtleVZhbHMuY29uY2F0KG90aGVyS2V5VmFscykuc29ydChzb3J0S2V5VmFscyk7XG59XG5mdW5jdGlvbiBwc2J0VG9LZXlWYWxzKHsgZ2xvYmFsTWFwLCBpbnB1dHMsIG91dHB1dHMsIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnbG9iYWxLZXlWYWxzOiBrZXlWYWxzRnJvbU1hcChnbG9iYWxNYXAsIGNvbnZlcnQuZ2xvYmFscyksXG4gICAgICAgIGlucHV0S2V5VmFsczogaW5wdXRzLm1hcChpID0+IGtleVZhbHNGcm9tTWFwKGksIGNvbnZlcnQuaW5wdXRzKSksXG4gICAgICAgIG91dHB1dEtleVZhbHM6IG91dHB1dHMubWFwKG8gPT4ga2V5VmFsc0Zyb21NYXAobywgY29udmVydC5vdXRwdXRzKSksXG4gICAgfTtcbn1cbmV4cG9ydHMucHNidFRvS2V5VmFscyA9IHBzYnRUb0tleVZhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0J1ZmZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/toBuffer.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/psbt.js':
    /*!******************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/psbt.js ***!
  \******************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Psbt = void 0;\nconst combiner_1 = __webpack_require__(/*! ./combiner */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/combiner/index.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/parser/index.js\");\nconst typeFields_1 = __webpack_require__(/*! ./typeFields */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/utils.js\");\nclass Psbt {\n    static fromBase64(data, txFromBuffer) {\n        const buffer = Buffer.from(data, 'base64');\n        return this.fromBuffer(buffer, txFromBuffer);\n    }\n    static fromHex(data, txFromBuffer) {\n        const buffer = Buffer.from(data, 'hex');\n        return this.fromBuffer(buffer, txFromBuffer);\n    }\n    static fromBuffer(buffer, txFromBuffer) {\n        const results = (0, parser_1.psbtFromBuffer)(buffer, txFromBuffer);\n        const psbt = new this(results.globalMap.unsignedTx);\n        Object.assign(psbt, results);\n        return psbt;\n    }\n    constructor(tx) {\n        this.inputs = [];\n        this.outputs = [];\n        this.globalMap = {\n            unsignedTx: tx,\n        };\n    }\n    toBase64() {\n        const buffer = this.toBuffer();\n        return buffer.toString('base64');\n    }\n    toHex() {\n        const buffer = this.toBuffer();\n        return buffer.toString('hex');\n    }\n    toBuffer() {\n        return (0, parser_1.psbtToBuffer)(this);\n    }\n    updateGlobal(updateData) {\n        (0, utils_1.updateGlobal)(updateData, this.globalMap);\n        return this;\n    }\n    updateInput(inputIndex, updateData) {\n        const input = (0, utils_1.checkForInput)(this.inputs, inputIndex);\n        (0, utils_1.updateInput)(updateData, input);\n        return this;\n    }\n    updateOutput(outputIndex, updateData) {\n        const output = (0, utils_1.checkForOutput)(this.outputs, outputIndex);\n        (0, utils_1.updateOutput)(updateData, output);\n        return this;\n    }\n    addUnknownKeyValToGlobal(keyVal) {\n        (0, utils_1.checkHasKey)(keyVal, this.globalMap.unknownKeyVals, (0, utils_1.getEnumLength)(typeFields_1.GlobalTypes));\n        if (!this.globalMap.unknownKeyVals)\n            this.globalMap.unknownKeyVals = [];\n        this.globalMap.unknownKeyVals.push(keyVal);\n        return this;\n    }\n    addUnknownKeyValToInput(inputIndex, keyVal) {\n        const input = (0, utils_1.checkForInput)(this.inputs, inputIndex);\n        (0, utils_1.checkHasKey)(keyVal, input.unknownKeyVals, (0, utils_1.getEnumLength)(typeFields_1.InputTypes));\n        if (!input.unknownKeyVals)\n            input.unknownKeyVals = [];\n        input.unknownKeyVals.push(keyVal);\n        return this;\n    }\n    addUnknownKeyValToOutput(outputIndex, keyVal) {\n        const output = (0, utils_1.checkForOutput)(this.outputs, outputIndex);\n        (0, utils_1.checkHasKey)(keyVal, output.unknownKeyVals, (0, utils_1.getEnumLength)(typeFields_1.OutputTypes));\n        if (!output.unknownKeyVals)\n            output.unknownKeyVals = [];\n        output.unknownKeyVals.push(keyVal);\n        return this;\n    }\n    addInput(inputData) {\n        this.globalMap.unsignedTx.addInput(inputData);\n        this.inputs.push({\n            unknownKeyVals: [],\n        });\n        const addKeyVals = inputData.unknownKeyVals || [];\n        const inputIndex = this.inputs.length - 1;\n        if (!Array.isArray(addKeyVals)) {\n            throw new Error('unknownKeyVals must be an Array');\n        }\n        addKeyVals.forEach((keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal));\n        (0, utils_1.addInputAttributes)(this.inputs, inputData);\n        return this;\n    }\n    addOutput(outputData) {\n        this.globalMap.unsignedTx.addOutput(outputData);\n        this.outputs.push({\n            unknownKeyVals: [],\n        });\n        const addKeyVals = outputData.unknownKeyVals || [];\n        const outputIndex = this.outputs.length - 1;\n        if (!Array.isArray(addKeyVals)) {\n            throw new Error('unknownKeyVals must be an Array');\n        }\n        addKeyVals.forEach((keyVal) => this.addUnknownKeyValToInput(outputIndex, keyVal));\n        (0, utils_1.addOutputAttributes)(this.outputs, outputData);\n        return this;\n    }\n    clearFinalizedInput(inputIndex) {\n        const input = (0, utils_1.checkForInput)(this.inputs, inputIndex);\n        (0, utils_1.inputCheckUncleanFinalized)(inputIndex, input);\n        for (const key of Object.keys(input)) {\n            if (![\n                'witnessUtxo',\n                'nonWitnessUtxo',\n                'finalScriptSig',\n                'finalScriptWitness',\n                'unknownKeyVals',\n            ].includes(key)) {\n                delete input[key];\n            }\n        }\n        return this;\n    }\n    combine(...those) {\n        const result = (0, combiner_1.combine)([this].concat(those));\n        Object.assign(this, result);\n        return this;\n    }\n    getTransaction() {\n        return this.globalMap.unsignedTx.toBuffer();\n    }\n}\nexports.Psbt = Psbt;\n//# sourceMappingURL=psbt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvcHNidC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osbUJBQW1CLG1CQUFPLENBQUMsMEdBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsc0dBQVU7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsd0dBQWM7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsOEZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L3BzYnQuanM/OTljNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHNidCA9IHZvaWQgMDtcbmNvbnN0IGNvbWJpbmVyXzEgPSByZXF1aXJlKFwiLi9jb21iaW5lclwiKTtcbmNvbnN0IHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZShcIi4vdHlwZUZpZWxkc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNsYXNzIFBzYnQge1xuICAgIHN0YXRpYyBmcm9tQmFzZTY0KGRhdGEsIHR4RnJvbUJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCAnYmFzZTY0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmZmVyLCB0eEZyb21CdWZmZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChkYXRhLCB0eEZyb21CdWZmZXIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2hleCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlciwgdHhGcm9tQnVmZmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCB0eEZyb21CdWZmZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9ICgwLCBwYXJzZXJfMS5wc2J0RnJvbUJ1ZmZlcikoYnVmZmVyLCB0eEZyb21CdWZmZXIpO1xuICAgICAgICBjb25zdCBwc2J0ID0gbmV3IHRoaXMocmVzdWx0cy5nbG9iYWxNYXAudW5zaWduZWRUeCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocHNidCwgcmVzdWx0cyk7XG4gICAgICAgIHJldHVybiBwc2J0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0eCkge1xuICAgICAgICB0aGlzLmlucHV0cyA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICAgICAgdGhpcy5nbG9iYWxNYXAgPSB7XG4gICAgICAgICAgICB1bnNpZ25lZFR4OiB0eCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9CYXNlNjQoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZXJfMS5wc2J0VG9CdWZmZXIpKHRoaXMpO1xuICAgIH1cbiAgICB1cGRhdGVHbG9iYWwodXBkYXRlRGF0YSkge1xuICAgICAgICAoMCwgdXRpbHNfMS51cGRhdGVHbG9iYWwpKHVwZGF0ZURhdGEsIHRoaXMuZ2xvYmFsTWFwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHVwZGF0ZURhdGEpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgICAgICgwLCB1dGlsc18xLnVwZGF0ZUlucHV0KSh1cGRhdGVEYXRhLCBpbnB1dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGVPdXRwdXQob3V0cHV0SW5kZXgsIHVwZGF0ZURhdGEpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JPdXRwdXQpKHRoaXMub3V0cHV0cywgb3V0cHV0SW5kZXgpO1xuICAgICAgICAoMCwgdXRpbHNfMS51cGRhdGVPdXRwdXQpKHVwZGF0ZURhdGEsIG91dHB1dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRVbmtub3duS2V5VmFsVG9HbG9iYWwoa2V5VmFsKSB7XG4gICAgICAgICgwLCB1dGlsc18xLmNoZWNrSGFzS2V5KShrZXlWYWwsIHRoaXMuZ2xvYmFsTWFwLnVua25vd25LZXlWYWxzLCAoMCwgdXRpbHNfMS5nZXRFbnVtTGVuZ3RoKSh0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMpKTtcbiAgICAgICAgaWYgKCF0aGlzLmdsb2JhbE1hcC51bmtub3duS2V5VmFscylcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTWFwLnVua25vd25LZXlWYWxzID0gW107XG4gICAgICAgIHRoaXMuZ2xvYmFsTWFwLnVua25vd25LZXlWYWxzLnB1c2goa2V5VmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZFVua25vd25LZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIGtleVZhbCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICAgICAgKDAsIHV0aWxzXzEuY2hlY2tIYXNLZXkpKGtleVZhbCwgaW5wdXQudW5rbm93bktleVZhbHMsICgwLCB1dGlsc18xLmdldEVudW1MZW5ndGgpKHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzKSk7XG4gICAgICAgIGlmICghaW5wdXQudW5rbm93bktleVZhbHMpXG4gICAgICAgICAgICBpbnB1dC51bmtub3duS2V5VmFscyA9IFtdO1xuICAgICAgICBpbnB1dC51bmtub3duS2V5VmFscy5wdXNoKGtleVZhbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRVbmtub3duS2V5VmFsVG9PdXRwdXQob3V0cHV0SW5kZXgsIGtleVZhbCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoMCwgdXRpbHNfMS5jaGVja0Zvck91dHB1dCkodGhpcy5vdXRwdXRzLCBvdXRwdXRJbmRleCk7XG4gICAgICAgICgwLCB1dGlsc18xLmNoZWNrSGFzS2V5KShrZXlWYWwsIG91dHB1dC51bmtub3duS2V5VmFscywgKDAsIHV0aWxzXzEuZ2V0RW51bUxlbmd0aCkodHlwZUZpZWxkc18xLk91dHB1dFR5cGVzKSk7XG4gICAgICAgIGlmICghb3V0cHV0LnVua25vd25LZXlWYWxzKVxuICAgICAgICAgICAgb3V0cHV0LnVua25vd25LZXlWYWxzID0gW107XG4gICAgICAgIG91dHB1dC51bmtub3duS2V5VmFscy5wdXNoKGtleVZhbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRJbnB1dChpbnB1dERhdGEpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxNYXAudW5zaWduZWRUeC5hZGRJbnB1dChpbnB1dERhdGEpO1xuICAgICAgICB0aGlzLmlucHV0cy5wdXNoKHtcbiAgICAgICAgICAgIHVua25vd25LZXlWYWxzOiBbXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFkZEtleVZhbHMgPSBpbnB1dERhdGEudW5rbm93bktleVZhbHMgfHwgW107XG4gICAgICAgIGNvbnN0IGlucHV0SW5kZXggPSB0aGlzLmlucHV0cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWRkS2V5VmFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93bktleVZhbHMgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEtleVZhbHMuZm9yRWFjaCgoa2V5VmFsKSA9PiB0aGlzLmFkZFVua25vd25LZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIGtleVZhbCkpO1xuICAgICAgICAoMCwgdXRpbHNfMS5hZGRJbnB1dEF0dHJpYnV0ZXMpKHRoaXMuaW5wdXRzLCBpbnB1dERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkT3V0cHV0KG91dHB1dERhdGEpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxNYXAudW5zaWduZWRUeC5hZGRPdXRwdXQob3V0cHV0RGF0YSk7XG4gICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIHVua25vd25LZXlWYWxzOiBbXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFkZEtleVZhbHMgPSBvdXRwdXREYXRhLnVua25vd25LZXlWYWxzIHx8IFtdO1xuICAgICAgICBjb25zdCBvdXRwdXRJbmRleCA9IHRoaXMub3V0cHV0cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWRkS2V5VmFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93bktleVZhbHMgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEtleVZhbHMuZm9yRWFjaCgoa2V5VmFsKSA9PiB0aGlzLmFkZFVua25vd25LZXlWYWxUb0lucHV0KG91dHB1dEluZGV4LCBrZXlWYWwpKTtcbiAgICAgICAgKDAsIHV0aWxzXzEuYWRkT3V0cHV0QXR0cmlidXRlcykodGhpcy5vdXRwdXRzLCBvdXRwdXREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNsZWFyRmluYWxpemVkSW5wdXQoaW5wdXRJbmRleCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICAgICAgKDAsIHV0aWxzXzEuaW5wdXRDaGVja1VuY2xlYW5GaW5hbGl6ZWQpKGlucHV0SW5kZXgsIGlucHV0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5wdXQpKSB7XG4gICAgICAgICAgICBpZiAoIVtcbiAgICAgICAgICAgICAgICAnd2l0bmVzc1V0eG8nLFxuICAgICAgICAgICAgICAgICdub25XaXRuZXNzVXR4bycsXG4gICAgICAgICAgICAgICAgJ2ZpbmFsU2NyaXB0U2lnJyxcbiAgICAgICAgICAgICAgICAnZmluYWxTY3JpcHRXaXRuZXNzJyxcbiAgICAgICAgICAgICAgICAndW5rbm93bktleVZhbHMnLFxuICAgICAgICAgICAgXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGlucHV0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbWJpbmUoLi4udGhvc2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIGNvbWJpbmVyXzEuY29tYmluZSkoW3RoaXNdLmNvbmNhdCh0aG9zZSkpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsTWFwLnVuc2lnbmVkVHgudG9CdWZmZXIoKTtcbiAgICB9XG59XG5leHBvcnRzLlBzYnQgPSBQc2J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHNidC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/psbt.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js':
    /*!************************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js ***!
  \************************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.OUTPUT_TYPE_NAMES = exports.OutputTypes = exports.INPUT_TYPE_NAMES = exports.InputTypes = exports.GLOBAL_TYPE_NAMES = exports.GlobalTypes = void 0;\nvar GlobalTypes;\n(function (GlobalTypes) {\n    GlobalTypes[GlobalTypes["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";\n    GlobalTypes[GlobalTypes["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";\n})(GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {}));\nexports.GLOBAL_TYPE_NAMES = [\'unsignedTx\', \'globalXpub\'];\nvar InputTypes;\n(function (InputTypes) {\n    InputTypes[InputTypes["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";\n    InputTypes[InputTypes["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";\n    InputTypes[InputTypes["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";\n    InputTypes[InputTypes["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";\n    InputTypes[InputTypes["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";\n    InputTypes[InputTypes["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";\n    InputTypes[InputTypes["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";\n    InputTypes[InputTypes["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";\n    InputTypes[InputTypes["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";\n    InputTypes[InputTypes["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";\n    InputTypes[InputTypes["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";\n    InputTypes[InputTypes["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";\n    InputTypes[InputTypes["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";\n    InputTypes[InputTypes["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";\n    InputTypes[InputTypes["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";\n    InputTypes[InputTypes["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";\n})(InputTypes = exports.InputTypes || (exports.InputTypes = {}));\nexports.INPUT_TYPE_NAMES = [\n    \'nonWitnessUtxo\',\n    \'witnessUtxo\',\n    \'partialSig\',\n    \'sighashType\',\n    \'redeemScript\',\n    \'witnessScript\',\n    \'bip32Derivation\',\n    \'finalScriptSig\',\n    \'finalScriptWitness\',\n    \'porCommitment\',\n    \'tapKeySig\',\n    \'tapScriptSig\',\n    \'tapLeafScript\',\n    \'tapBip32Derivation\',\n    \'tapInternalKey\',\n    \'tapMerkleRoot\',\n];\nvar OutputTypes;\n(function (OutputTypes) {\n    OutputTypes[OutputTypes["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";\n    OutputTypes[OutputTypes["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";\n    OutputTypes[OutputTypes["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";\n    OutputTypes[OutputTypes["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";\n    OutputTypes[OutputTypes["TAP_TREE"] = 6] = "TAP_TREE";\n    OutputTypes[OutputTypes["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";\n})(OutputTypes = exports.OutputTypes || (exports.OutputTypes = {}));\nexports.OUTPUT_TYPE_NAMES = [\n    \'redeemScript\',\n    \'witnessScript\',\n    \'bip32Derivation\',\n    \'tapInternalKey\',\n    \'tapTree\',\n    \'tapBip32Derivation\',\n];\n//# sourceMappingURL=typeFields.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvdHlwZUZpZWxkcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxtQkFBbUI7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QyxtQkFBbUIsS0FBSztBQUNqRSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0Msa0JBQWtCLEtBQUs7QUFDOUQsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0MsbUJBQW1CLEtBQUs7QUFDakUseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2JpcDE3NC90eXBlRmllbGRzLmpzPzllMzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9VVFBVVF9UWVBFX05BTUVTID0gZXhwb3J0cy5PdXRwdXRUeXBlcyA9IGV4cG9ydHMuSU5QVVRfVFlQRV9OQU1FUyA9IGV4cG9ydHMuSW5wdXRUeXBlcyA9IGV4cG9ydHMuR0xPQkFMX1RZUEVfTkFNRVMgPSBleHBvcnRzLkdsb2JhbFR5cGVzID0gdm9pZCAwO1xudmFyIEdsb2JhbFR5cGVzO1xuKGZ1bmN0aW9uIChHbG9iYWxUeXBlcykge1xuICAgIEdsb2JhbFR5cGVzW0dsb2JhbFR5cGVzW1wiVU5TSUdORURfVFhcIl0gPSAwXSA9IFwiVU5TSUdORURfVFhcIjtcbiAgICBHbG9iYWxUeXBlc1tHbG9iYWxUeXBlc1tcIkdMT0JBTF9YUFVCXCJdID0gMV0gPSBcIkdMT0JBTF9YUFVCXCI7XG59KShHbG9iYWxUeXBlcyA9IGV4cG9ydHMuR2xvYmFsVHlwZXMgfHwgKGV4cG9ydHMuR2xvYmFsVHlwZXMgPSB7fSkpO1xuZXhwb3J0cy5HTE9CQUxfVFlQRV9OQU1FUyA9IFsndW5zaWduZWRUeCcsICdnbG9iYWxYcHViJ107XG52YXIgSW5wdXRUeXBlcztcbihmdW5jdGlvbiAoSW5wdXRUeXBlcykge1xuICAgIElucHV0VHlwZXNbSW5wdXRUeXBlc1tcIk5PTl9XSVRORVNTX1VUWE9cIl0gPSAwXSA9IFwiTk9OX1dJVE5FU1NfVVRYT1wiO1xuICAgIElucHV0VHlwZXNbSW5wdXRUeXBlc1tcIldJVE5FU1NfVVRYT1wiXSA9IDFdID0gXCJXSVRORVNTX1VUWE9cIjtcbiAgICBJbnB1dFR5cGVzW0lucHV0VHlwZXNbXCJQQVJUSUFMX1NJR1wiXSA9IDJdID0gXCJQQVJUSUFMX1NJR1wiO1xuICAgIElucHV0VHlwZXNbSW5wdXRUeXBlc1tcIlNJR0hBU0hfVFlQRVwiXSA9IDNdID0gXCJTSUdIQVNIX1RZUEVcIjtcbiAgICBJbnB1dFR5cGVzW0lucHV0VHlwZXNbXCJSRURFRU1fU0NSSVBUXCJdID0gNF0gPSBcIlJFREVFTV9TQ1JJUFRcIjtcbiAgICBJbnB1dFR5cGVzW0lucHV0VHlwZXNbXCJXSVRORVNTX1NDUklQVFwiXSA9IDVdID0gXCJXSVRORVNTX1NDUklQVFwiO1xuICAgIElucHV0VHlwZXNbSW5wdXRUeXBlc1tcIkJJUDMyX0RFUklWQVRJT05cIl0gPSA2XSA9IFwiQklQMzJfREVSSVZBVElPTlwiO1xuICAgIElucHV0VHlwZXNbSW5wdXRUeXBlc1tcIkZJTkFMX1NDUklQVFNJR1wiXSA9IDddID0gXCJGSU5BTF9TQ1JJUFRTSUdcIjtcbiAgICBJbnB1dFR5cGVzW0lucHV0VHlwZXNbXCJGSU5BTF9TQ1JJUFRXSVRORVNTXCJdID0gOF0gPSBcIkZJTkFMX1NDUklQVFdJVE5FU1NcIjtcbiAgICBJbnB1dFR5cGVzW0lucHV0VHlwZXNbXCJQT1JfQ09NTUlUTUVOVFwiXSA9IDldID0gXCJQT1JfQ09NTUlUTUVOVFwiO1xuICAgIElucHV0VHlwZXNbSW5wdXRUeXBlc1tcIlRBUF9LRVlfU0lHXCJdID0gMTldID0gXCJUQVBfS0VZX1NJR1wiO1xuICAgIElucHV0VHlwZXNbSW5wdXRUeXBlc1tcIlRBUF9TQ1JJUFRfU0lHXCJdID0gMjBdID0gXCJUQVBfU0NSSVBUX1NJR1wiO1xuICAgIElucHV0VHlwZXNbSW5wdXRUeXBlc1tcIlRBUF9MRUFGX1NDUklQVFwiXSA9IDIxXSA9IFwiVEFQX0xFQUZfU0NSSVBUXCI7XG4gICAgSW5wdXRUeXBlc1tJbnB1dFR5cGVzW1wiVEFQX0JJUDMyX0RFUklWQVRJT05cIl0gPSAyMl0gPSBcIlRBUF9CSVAzMl9ERVJJVkFUSU9OXCI7XG4gICAgSW5wdXRUeXBlc1tJbnB1dFR5cGVzW1wiVEFQX0lOVEVSTkFMX0tFWVwiXSA9IDIzXSA9IFwiVEFQX0lOVEVSTkFMX0tFWVwiO1xuICAgIElucHV0VHlwZXNbSW5wdXRUeXBlc1tcIlRBUF9NRVJLTEVfUk9PVFwiXSA9IDI0XSA9IFwiVEFQX01FUktMRV9ST09UXCI7XG59KShJbnB1dFR5cGVzID0gZXhwb3J0cy5JbnB1dFR5cGVzIHx8IChleHBvcnRzLklucHV0VHlwZXMgPSB7fSkpO1xuZXhwb3J0cy5JTlBVVF9UWVBFX05BTUVTID0gW1xuICAgICdub25XaXRuZXNzVXR4bycsXG4gICAgJ3dpdG5lc3NVdHhvJyxcbiAgICAncGFydGlhbFNpZycsXG4gICAgJ3NpZ2hhc2hUeXBlJyxcbiAgICAncmVkZWVtU2NyaXB0JyxcbiAgICAnd2l0bmVzc1NjcmlwdCcsXG4gICAgJ2JpcDMyRGVyaXZhdGlvbicsXG4gICAgJ2ZpbmFsU2NyaXB0U2lnJyxcbiAgICAnZmluYWxTY3JpcHRXaXRuZXNzJyxcbiAgICAncG9yQ29tbWl0bWVudCcsXG4gICAgJ3RhcEtleVNpZycsXG4gICAgJ3RhcFNjcmlwdFNpZycsXG4gICAgJ3RhcExlYWZTY3JpcHQnLFxuICAgICd0YXBCaXAzMkRlcml2YXRpb24nLFxuICAgICd0YXBJbnRlcm5hbEtleScsXG4gICAgJ3RhcE1lcmtsZVJvb3QnLFxuXTtcbnZhciBPdXRwdXRUeXBlcztcbihmdW5jdGlvbiAoT3V0cHV0VHlwZXMpIHtcbiAgICBPdXRwdXRUeXBlc1tPdXRwdXRUeXBlc1tcIlJFREVFTV9TQ1JJUFRcIl0gPSAwXSA9IFwiUkVERUVNX1NDUklQVFwiO1xuICAgIE91dHB1dFR5cGVzW091dHB1dFR5cGVzW1wiV0lUTkVTU19TQ1JJUFRcIl0gPSAxXSA9IFwiV0lUTkVTU19TQ1JJUFRcIjtcbiAgICBPdXRwdXRUeXBlc1tPdXRwdXRUeXBlc1tcIkJJUDMyX0RFUklWQVRJT05cIl0gPSAyXSA9IFwiQklQMzJfREVSSVZBVElPTlwiO1xuICAgIE91dHB1dFR5cGVzW091dHB1dFR5cGVzW1wiVEFQX0lOVEVSTkFMX0tFWVwiXSA9IDVdID0gXCJUQVBfSU5URVJOQUxfS0VZXCI7XG4gICAgT3V0cHV0VHlwZXNbT3V0cHV0VHlwZXNbXCJUQVBfVFJFRVwiXSA9IDZdID0gXCJUQVBfVFJFRVwiO1xuICAgIE91dHB1dFR5cGVzW091dHB1dFR5cGVzW1wiVEFQX0JJUDMyX0RFUklWQVRJT05cIl0gPSA3XSA9IFwiVEFQX0JJUDMyX0RFUklWQVRJT05cIjtcbn0pKE91dHB1dFR5cGVzID0gZXhwb3J0cy5PdXRwdXRUeXBlcyB8fCAoZXhwb3J0cy5PdXRwdXRUeXBlcyA9IHt9KSk7XG5leHBvcnRzLk9VVFBVVF9UWVBFX05BTUVTID0gW1xuICAgICdyZWRlZW1TY3JpcHQnLFxuICAgICd3aXRuZXNzU2NyaXB0JyxcbiAgICAnYmlwMzJEZXJpdmF0aW9uJyxcbiAgICAndGFwSW50ZXJuYWxLZXknLFxuICAgICd0YXBUcmVlJyxcbiAgICAndGFwQmlwMzJEZXJpdmF0aW9uJyxcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlRmllbGRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/typeFields.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/utils.js':
    /*!*******************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/utils.js ***!
  \*******************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultLocktimeSetter = exports.defaultVersionSetter = exports.addOutputAttributes = exports.addInputAttributes = exports.updateOutput = exports.updateInput = exports.updateGlobal = exports.inputCheckUncleanFinalized = exports.getEnumLength = exports.checkHasKey = exports.checkForOutput = exports.checkForInput = void 0;\nconst converter = __importStar(__webpack_require__(/*! ./converter */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/index.js\"));\nfunction checkForInput(inputs, inputIndex) {\n    const input = inputs[inputIndex];\n    if (input === undefined)\n        throw new Error(`No input #${inputIndex}`);\n    return input;\n}\nexports.checkForInput = checkForInput;\nfunction checkForOutput(outputs, outputIndex) {\n    const output = outputs[outputIndex];\n    if (output === undefined)\n        throw new Error(`No output #${outputIndex}`);\n    return output;\n}\nexports.checkForOutput = checkForOutput;\nfunction checkHasKey(checkKeyVal, keyVals, enumLength) {\n    if (checkKeyVal.key[0] < enumLength) {\n        throw new Error(`Use the method for your specific key instead of addUnknownKeyVal*`);\n    }\n    if (keyVals &&\n        keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0) {\n        throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);\n    }\n}\nexports.checkHasKey = checkHasKey;\nfunction getEnumLength(myenum) {\n    let count = 0;\n    Object.keys(myenum).forEach(val => {\n        if (Number(isNaN(Number(val)))) {\n            count++;\n        }\n    });\n    return count;\n}\nexports.getEnumLength = getEnumLength;\nfunction inputCheckUncleanFinalized(inputIndex, input) {\n    let result = false;\n    if (input.nonWitnessUtxo || input.witnessUtxo) {\n        const needScriptSig = !!input.redeemScript;\n        const needWitnessScript = !!input.witnessScript;\n        const scriptSigOK = !needScriptSig || !!input.finalScriptSig;\n        const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;\n        const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;\n        result = scriptSigOK && witnessScriptOK && hasOneFinal;\n    }\n    if (result === false) {\n        throw new Error(`Input #${inputIndex} has too much or too little data to clean`);\n    }\n}\nexports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;\nfunction throwForUpdateMaker(typeName, name, expected, data) {\n    throw new Error(`Data for ${typeName} key ${name} is incorrect: Expected ` +\n        `${expected} and got ${JSON.stringify(data)}`);\n}\nfunction updateMaker(typeName) {\n    return (updateData, mainData) => {\n        for (const name of Object.keys(updateData)) {\n            const data = updateData[name];\n            const { canAdd, canAddToArray, check, expected } = converter[typeName + 's'][name] || {};\n            const isArray = !!canAddToArray;\n            if (check) {\n                if (isArray) {\n                    if (!Array.isArray(data) ||\n                        (mainData[name] && !Array.isArray(mainData[name]))) {\n                        throw new Error(`Key type ${name} must be an array`);\n                    }\n                    if (!data.every(check)) {\n                        throwForUpdateMaker(typeName, name, expected, data);\n                    }\n                    const arr = mainData[name] || [];\n                    const dupeCheckSet = new Set();\n                    if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {\n                        throw new Error('Can not add duplicate data to array');\n                    }\n                    mainData[name] = arr.concat(data);\n                }\n                else {\n                    if (!check(data)) {\n                        throwForUpdateMaker(typeName, name, expected, data);\n                    }\n                    if (!canAdd(mainData, data)) {\n                        throw new Error(`Can not add duplicate data to ${typeName}`);\n                    }\n                    mainData[name] = data;\n                }\n            }\n        }\n    };\n}\nexports.updateGlobal = updateMaker('global');\nexports.updateInput = updateMaker('input');\nexports.updateOutput = updateMaker('output');\nfunction addInputAttributes(inputs, data) {\n    const index = inputs.length - 1;\n    const input = checkForInput(inputs, index);\n    (0, exports.updateInput)(data, input);\n}\nexports.addInputAttributes = addInputAttributes;\nfunction addOutputAttributes(outputs, data) {\n    const index = outputs.length - 1;\n    const output = checkForOutput(outputs, index);\n    (0, exports.updateOutput)(data, output);\n}\nexports.addOutputAttributes = addOutputAttributes;\nfunction defaultVersionSetter(version, txBuf) {\n    if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n        throw new Error('Set Version: Invalid Transaction');\n    }\n    txBuf.writeUInt32LE(version, 0);\n    return txBuf;\n}\nexports.defaultVersionSetter = defaultVersionSetter;\nfunction defaultLocktimeSetter(locktime, txBuf) {\n    if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n        throw new Error('Set Locktime: Invalid Transaction');\n    }\n    txBuf.writeUInt32LE(locktime, txBuf.length - 4);\n    return txBuf;\n}\nexports.defaultLocktimeSetter = defaultLocktimeSetter;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXAxNzQvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLDJCQUEyQixHQUFHLDBCQUEwQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLGtDQUFrQyxHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQjtBQUMvVCwrQkFBK0IsbUJBQU8sQ0FBQyw0R0FBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdDQUFnQztBQUMxRTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsZ0NBQWdDLFVBQVUsTUFBTSxNQUFNO0FBQ3RELFdBQVcsVUFBVSxVQUFVLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsU0FBUztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvYmlwMTc0L3V0aWxzLmpzP2MzOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdExvY2t0aW1lU2V0dGVyID0gZXhwb3J0cy5kZWZhdWx0VmVyc2lvblNldHRlciA9IGV4cG9ydHMuYWRkT3V0cHV0QXR0cmlidXRlcyA9IGV4cG9ydHMuYWRkSW5wdXRBdHRyaWJ1dGVzID0gZXhwb3J0cy51cGRhdGVPdXRwdXQgPSBleHBvcnRzLnVwZGF0ZUlucHV0ID0gZXhwb3J0cy51cGRhdGVHbG9iYWwgPSBleHBvcnRzLmlucHV0Q2hlY2tVbmNsZWFuRmluYWxpemVkID0gZXhwb3J0cy5nZXRFbnVtTGVuZ3RoID0gZXhwb3J0cy5jaGVja0hhc0tleSA9IGV4cG9ydHMuY2hlY2tGb3JPdXRwdXQgPSBleHBvcnRzLmNoZWNrRm9ySW5wdXQgPSB2b2lkIDA7XG5jb25zdCBjb252ZXJ0ZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29udmVydGVyXCIpKTtcbmZ1bmN0aW9uIGNoZWNrRm9ySW5wdXQoaW5wdXRzLCBpbnB1dEluZGV4KSB7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dHNbaW5wdXRJbmRleF07XG4gICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gaW5wdXQgIyR7aW5wdXRJbmRleH1gKTtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5leHBvcnRzLmNoZWNrRm9ySW5wdXQgPSBjaGVja0ZvcklucHV0O1xuZnVuY3Rpb24gY2hlY2tGb3JPdXRwdXQob3V0cHV0cywgb3V0cHV0SW5kZXgpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzW291dHB1dEluZGV4XTtcbiAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gb3V0cHV0ICMke291dHB1dEluZGV4fWApO1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLmNoZWNrRm9yT3V0cHV0ID0gY2hlY2tGb3JPdXRwdXQ7XG5mdW5jdGlvbiBjaGVja0hhc0tleShjaGVja0tleVZhbCwga2V5VmFscywgZW51bUxlbmd0aCkge1xuICAgIGlmIChjaGVja0tleVZhbC5rZXlbMF0gPCBlbnVtTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVXNlIHRoZSBtZXRob2QgZm9yIHlvdXIgc3BlY2lmaWMga2V5IGluc3RlYWQgb2YgYWRkVW5rbm93bktleVZhbCpgKTtcbiAgICB9XG4gICAgaWYgKGtleVZhbHMgJiZcbiAgICAgICAga2V5VmFscy5maWx0ZXIoa3YgPT4ga3Yua2V5LmVxdWFscyhjaGVja0tleVZhbC5rZXkpKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgS2V5OiAke2NoZWNrS2V5VmFsLmtleS50b1N0cmluZygnaGV4Jyl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0hhc0tleSA9IGNoZWNrSGFzS2V5O1xuZnVuY3Rpb24gZ2V0RW51bUxlbmd0aChteWVudW0pIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIE9iamVjdC5rZXlzKG15ZW51bSkuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgICBpZiAoTnVtYmVyKGlzTmFOKE51bWJlcih2YWwpKSkpIHtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY291bnQ7XG59XG5leHBvcnRzLmdldEVudW1MZW5ndGggPSBnZXRFbnVtTGVuZ3RoO1xuZnVuY3Rpb24gaW5wdXRDaGVja1VuY2xlYW5GaW5hbGl6ZWQoaW5wdXRJbmRleCwgaW5wdXQpIHtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvIHx8IGlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgICAgIGNvbnN0IG5lZWRTY3JpcHRTaWcgPSAhIWlucHV0LnJlZGVlbVNjcmlwdDtcbiAgICAgICAgY29uc3QgbmVlZFdpdG5lc3NTY3JpcHQgPSAhIWlucHV0LndpdG5lc3NTY3JpcHQ7XG4gICAgICAgIGNvbnN0IHNjcmlwdFNpZ09LID0gIW5lZWRTY3JpcHRTaWcgfHwgISFpbnB1dC5maW5hbFNjcmlwdFNpZztcbiAgICAgICAgY29uc3Qgd2l0bmVzc1NjcmlwdE9LID0gIW5lZWRXaXRuZXNzU2NyaXB0IHx8ICEhaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzO1xuICAgICAgICBjb25zdCBoYXNPbmVGaW5hbCA9ICEhaW5wdXQuZmluYWxTY3JpcHRTaWcgfHwgISFpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3M7XG4gICAgICAgIHJlc3VsdCA9IHNjcmlwdFNpZ09LICYmIHdpdG5lc3NTY3JpcHRPSyAmJiBoYXNPbmVGaW5hbDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAjJHtpbnB1dEluZGV4fSBoYXMgdG9vIG11Y2ggb3IgdG9vIGxpdHRsZSBkYXRhIHRvIGNsZWFuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5pbnB1dENoZWNrVW5jbGVhbkZpbmFsaXplZCA9IGlucHV0Q2hlY2tVbmNsZWFuRmluYWxpemVkO1xuZnVuY3Rpb24gdGhyb3dGb3JVcGRhdGVNYWtlcih0eXBlTmFtZSwgbmFtZSwgZXhwZWN0ZWQsIGRhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGEgZm9yICR7dHlwZU5hbWV9IGtleSAke25hbWV9IGlzIGluY29ycmVjdDogRXhwZWN0ZWQgYCArXG4gICAgICAgIGAke2V4cGVjdGVkfSBhbmQgZ290ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG59XG5mdW5jdGlvbiB1cGRhdGVNYWtlcih0eXBlTmFtZSkge1xuICAgIHJldHVybiAodXBkYXRlRGF0YSwgbWFpbkRhdGEpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHVwZGF0ZURhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdXBkYXRlRGF0YVtuYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FuQWRkLCBjYW5BZGRUb0FycmF5LCBjaGVjaywgZXhwZWN0ZWQgfSA9IGNvbnZlcnRlclt0eXBlTmFtZSArICdzJ11bbmFtZV0gfHwge307XG4gICAgICAgICAgICBjb25zdCBpc0FycmF5ID0gISFjYW5BZGRUb0FycmF5O1xuICAgICAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobWFpbkRhdGFbbmFtZV0gJiYgIUFycmF5LmlzQXJyYXkobWFpbkRhdGFbbmFtZV0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgdHlwZSAke25hbWV9IG11c3QgYmUgYW4gYXJyYXlgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuZXZlcnkoY2hlY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0ZvclVwZGF0ZU1ha2VyKHR5cGVOYW1lLCBuYW1lLCBleHBlY3RlZCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyID0gbWFpbkRhdGFbbmFtZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cGVDaGVja1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmV2ZXJ5KHYgPT4gY2FuQWRkVG9BcnJheShhcnIsIHYsIGR1cGVDaGVja1NldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWRkIGR1cGxpY2F0ZSBkYXRhIHRvIGFycmF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFpbkRhdGFbbmFtZV0gPSBhcnIuY29uY2F0KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVjayhkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dGb3JVcGRhdGVNYWtlcih0eXBlTmFtZSwgbmFtZSwgZXhwZWN0ZWQsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuQWRkKG1haW5EYXRhLCBkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGFkZCBkdXBsaWNhdGUgZGF0YSB0byAke3R5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1haW5EYXRhW25hbWVdID0gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy51cGRhdGVHbG9iYWwgPSB1cGRhdGVNYWtlcignZ2xvYmFsJyk7XG5leHBvcnRzLnVwZGF0ZUlucHV0ID0gdXBkYXRlTWFrZXIoJ2lucHV0Jyk7XG5leHBvcnRzLnVwZGF0ZU91dHB1dCA9IHVwZGF0ZU1ha2VyKCdvdXRwdXQnKTtcbmZ1bmN0aW9uIGFkZElucHV0QXR0cmlidXRlcyhpbnB1dHMsIGRhdGEpIHtcbiAgICBjb25zdCBpbmRleCA9IGlucHV0cy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dChpbnB1dHMsIGluZGV4KTtcbiAgICAoMCwgZXhwb3J0cy51cGRhdGVJbnB1dCkoZGF0YSwgaW5wdXQpO1xufVxuZXhwb3J0cy5hZGRJbnB1dEF0dHJpYnV0ZXMgPSBhZGRJbnB1dEF0dHJpYnV0ZXM7XG5mdW5jdGlvbiBhZGRPdXRwdXRBdHRyaWJ1dGVzKG91dHB1dHMsIGRhdGEpIHtcbiAgICBjb25zdCBpbmRleCA9IG91dHB1dHMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBvdXRwdXQgPSBjaGVja0Zvck91dHB1dChvdXRwdXRzLCBpbmRleCk7XG4gICAgKDAsIGV4cG9ydHMudXBkYXRlT3V0cHV0KShkYXRhLCBvdXRwdXQpO1xufVxuZXhwb3J0cy5hZGRPdXRwdXRBdHRyaWJ1dGVzID0gYWRkT3V0cHV0QXR0cmlidXRlcztcbmZ1bmN0aW9uIGRlZmF1bHRWZXJzaW9uU2V0dGVyKHZlcnNpb24sIHR4QnVmKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodHhCdWYpIHx8IHR4QnVmLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXQgVmVyc2lvbjogSW52YWxpZCBUcmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICB0eEJ1Zi53cml0ZVVJbnQzMkxFKHZlcnNpb24sIDApO1xuICAgIHJldHVybiB0eEJ1Zjtcbn1cbmV4cG9ydHMuZGVmYXVsdFZlcnNpb25TZXR0ZXIgPSBkZWZhdWx0VmVyc2lvblNldHRlcjtcbmZ1bmN0aW9uIGRlZmF1bHRMb2NrdGltZVNldHRlcihsb2NrdGltZSwgdHhCdWYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0eEJ1ZikgfHwgdHhCdWYubGVuZ3RoIDwgNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldCBMb2NrdGltZTogSW52YWxpZCBUcmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICB0eEJ1Zi53cml0ZVVJbnQzMkxFKGxvY2t0aW1lLCB0eEJ1Zi5sZW5ndGggLSA0KTtcbiAgICByZXR1cm4gdHhCdWY7XG59XG5leHBvcnRzLmRlZmF1bHRMb2NrdGltZVNldHRlciA9IGRlZmF1bHRMb2NrdGltZVNldHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/utils.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip66.js':
    /*!************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip66.js ***!
  \************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = exports.check = void 0;\nfunction check(buffer) {\n    if (buffer.length < 8)\n        return false;\n    if (buffer.length > 72)\n        return false;\n    if (buffer[0] !== 0x30)\n        return false;\n    if (buffer[1] !== buffer.length - 2)\n        return false;\n    if (buffer[2] !== 0x02)\n        return false;\n    const lenR = buffer[3];\n    if (lenR === 0)\n        return false;\n    if (5 + lenR >= buffer.length)\n        return false;\n    if (buffer[4 + lenR] !== 0x02)\n        return false;\n    const lenS = buffer[5 + lenR];\n    if (lenS === 0)\n        return false;\n    if (6 + lenR + lenS !== buffer.length)\n        return false;\n    if (buffer[4] & 0x80)\n        return false;\n    if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n        return false;\n    if (buffer[lenR + 6] & 0x80)\n        return false;\n    if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n        return false;\n    return true;\n}\nexports.check = check;\nfunction decode(buffer) {\n    if (buffer.length < 8)\n        throw new Error('DER sequence length is too short');\n    if (buffer.length > 72)\n        throw new Error('DER sequence length is too long');\n    if (buffer[0] !== 0x30)\n        throw new Error('Expected DER sequence');\n    if (buffer[1] !== buffer.length - 2)\n        throw new Error('DER sequence length is invalid');\n    if (buffer[2] !== 0x02)\n        throw new Error('Expected DER integer');\n    const lenR = buffer[3];\n    if (lenR === 0)\n        throw new Error('R length is zero');\n    if (5 + lenR >= buffer.length)\n        throw new Error('R length is too long');\n    if (buffer[4 + lenR] !== 0x02)\n        throw new Error('Expected DER integer (2)');\n    const lenS = buffer[5 + lenR];\n    if (lenS === 0)\n        throw new Error('S length is zero');\n    if (6 + lenR + lenS !== buffer.length)\n        throw new Error('S length is invalid');\n    if (buffer[4] & 0x80)\n        throw new Error('R value is negative');\n    if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n        throw new Error('R value excessively padded');\n    if (buffer[lenR + 6] & 0x80)\n        throw new Error('S value is negative');\n    if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n        throw new Error('S value excessively padded');\n    return {\n        r: buffer.slice(4, 4 + lenR),\n        s: buffer.slice(6 + lenR),\n    };\n}\nexports.decode = decode;\nfunction encode(r, s) {\n    const lenR = r.length;\n    const lenS = s.length;\n    if (lenR === 0)\n        throw new Error('R length is zero');\n    if (lenS === 0)\n        throw new Error('S length is zero');\n    if (lenR > 33)\n        throw new Error('R length is too long');\n    if (lenS > 33)\n        throw new Error('S length is too long');\n    if (r[0] & 0x80)\n        throw new Error('R value is negative');\n    if (s[0] & 0x80)\n        throw new Error('S value is negative');\n    if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))\n        throw new Error('R value excessively padded');\n    if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))\n        throw new Error('S value excessively padded');\n    const signature = Buffer.allocUnsafe(6 + lenR + lenS);\n    signature[0] = 0x30;\n    signature[1] = signature.length - 2;\n    signature[2] = 0x02;\n    signature[3] = r.length;\n    r.copy(signature, 4);\n    signature[4 + lenR] = 0x02;\n    signature[5 + lenR] = s.length;\n    s.copy(signature, 6 + lenR);\n    return signature;\n}\nexports.encode = encode;\n//# sourceMappingURL=bip66.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9iaXA2Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2JpcDY2LmpzP2ZhODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5jaGVjayA9IHZvaWQgMDtcbmZ1bmN0aW9uIGNoZWNrKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgOClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChidWZmZXIubGVuZ3RoID4gNzIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYnVmZmVyWzBdICE9PSAweDMwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGJ1ZmZlclsxXSAhPT0gYnVmZmVyLmxlbmd0aCAtIDIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYnVmZmVyWzJdICE9PSAweDAyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGVuUiA9IGJ1ZmZlclszXTtcbiAgICBpZiAobGVuUiA9PT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICg1ICsgbGVuUiA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGJ1ZmZlcls0ICsgbGVuUl0gIT09IDB4MDIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBsZW5TID0gYnVmZmVyWzUgKyBsZW5SXTtcbiAgICBpZiAobGVuUyA9PT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICg2ICsgbGVuUiArIGxlblMgIT09IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYnVmZmVyWzRdICYgMHg4MClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChsZW5SID4gMSAmJiBidWZmZXJbNF0gPT09IDB4MDAgJiYgIShidWZmZXJbNV0gJiAweDgwKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChidWZmZXJbbGVuUiArIDZdICYgMHg4MClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChsZW5TID4gMSAmJiBidWZmZXJbbGVuUiArIDZdID09PSAweDAwICYmICEoYnVmZmVyW2xlblIgKyA3XSAmIDB4ODApKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBkZWNvZGUoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCA4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RFUiBzZXF1ZW5jZSBsZW5ndGggaXMgdG9vIHNob3J0Jyk7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPiA3MilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdERVIgc2VxdWVuY2UgbGVuZ3RoIGlzIHRvbyBsb25nJyk7XG4gICAgaWYgKGJ1ZmZlclswXSAhPT0gMHgzMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBERVIgc2VxdWVuY2UnKTtcbiAgICBpZiAoYnVmZmVyWzFdICE9PSBidWZmZXIubGVuZ3RoIC0gMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdERVIgc2VxdWVuY2UgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICBpZiAoYnVmZmVyWzJdICE9PSAweDAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIERFUiBpbnRlZ2VyJyk7XG4gICAgY29uc3QgbGVuUiA9IGJ1ZmZlclszXTtcbiAgICBpZiAobGVuUiA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSIGxlbmd0aCBpcyB6ZXJvJyk7XG4gICAgaWYgKDUgKyBsZW5SID49IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgdG9vIGxvbmcnKTtcbiAgICBpZiAoYnVmZmVyWzQgKyBsZW5SXSAhPT0gMHgwMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBERVIgaW50ZWdlciAoMiknKTtcbiAgICBjb25zdCBsZW5TID0gYnVmZmVyWzUgKyBsZW5SXTtcbiAgICBpZiAobGVuUyA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB6ZXJvJyk7XG4gICAgaWYgKDYgKyBsZW5SICsgbGVuUyAhPT0gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgaWYgKGJ1ZmZlcls0XSAmIDB4ODApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUiB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICAgIGlmIChsZW5SID4gMSAmJiBidWZmZXJbNF0gPT09IDB4MDAgJiYgIShidWZmZXJbNV0gJiAweDgwKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZCcpO1xuICAgIGlmIChidWZmZXJbbGVuUiArIDZdICYgMHg4MClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG4gICAgaWYgKGxlblMgPiAxICYmIGJ1ZmZlcltsZW5SICsgNl0gPT09IDB4MDAgJiYgIShidWZmZXJbbGVuUiArIDddICYgMHg4MCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUyB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBidWZmZXIuc2xpY2UoNCwgNCArIGxlblIpLFxuICAgICAgICBzOiBidWZmZXIuc2xpY2UoNiArIGxlblIpLFxuICAgIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShyLCBzKSB7XG4gICAgY29uc3QgbGVuUiA9IHIubGVuZ3RoO1xuICAgIGNvbnN0IGxlblMgPSBzLmxlbmd0aDtcbiAgICBpZiAobGVuUiA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSIGxlbmd0aCBpcyB6ZXJvJyk7XG4gICAgaWYgKGxlblMgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUyBsZW5ndGggaXMgemVybycpO1xuICAgIGlmIChsZW5SID4gMzMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgdG9vIGxvbmcnKTtcbiAgICBpZiAobGVuUyA+IDMzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHRvbyBsb25nJyk7XG4gICAgaWYgKHJbMF0gJiAweDgwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1IgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgICBpZiAoc1swXSAmIDB4ODApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUyB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICAgIGlmIChsZW5SID4gMSAmJiByWzBdID09PSAweDAwICYmICEoclsxXSAmIDB4ODApKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1IgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJyk7XG4gICAgaWYgKGxlblMgPiAxICYmIHNbMF0gPT09IDB4MDAgJiYgIShzWzFdICYgMHg4MCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUyB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNiArIGxlblIgKyBsZW5TKTtcbiAgICBzaWduYXR1cmVbMF0gPSAweDMwO1xuICAgIHNpZ25hdHVyZVsxXSA9IHNpZ25hdHVyZS5sZW5ndGggLSAyO1xuICAgIHNpZ25hdHVyZVsyXSA9IDB4MDI7XG4gICAgc2lnbmF0dXJlWzNdID0gci5sZW5ndGg7XG4gICAgci5jb3B5KHNpZ25hdHVyZSwgNCk7XG4gICAgc2lnbmF0dXJlWzQgKyBsZW5SXSA9IDB4MDI7XG4gICAgc2lnbmF0dXJlWzUgKyBsZW5SXSA9IHMubGVuZ3RoO1xuICAgIHMuY29weShzaWduYXR1cmUsIDYgKyBsZW5SKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaXA2Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip66.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js':
    /*!******************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js ***!
  \******************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BufferReader = exports.BufferWriter = exports.cloneBuffer = exports.reverseBuffer = exports.writeUInt64LE = exports.readUInt64LE = exports.varuint = void 0;\nconst types = __importStar(__webpack_require__(/*! ./types */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js"));\nconst { typeforce } = types;\nconst varuint = __importStar(__webpack_require__(/*! ./varuint */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/varuint.js"));\nexports.varuint = varuint;\nfunction verifuint(value, max) {\n    if (typeof value !== \'number\')\n        throw new Error(\'cannot write a non-number as a number\');\n    if (value < 0)\n        throw new Error(\'specified a negative value for writing an unsigned value\');\n    if (value > max)\n        throw new Error(\'RangeError: value out of range\');\n    if (Math.floor(value) !== value)\n        throw new Error(\'value has a fractional component\');\n}\nfunction readUInt64LE(buffer, offset) {\n    const a = buffer.readUInt32LE(offset);\n    let b = buffer.readUInt32LE(offset + 4);\n    b *= 0x100000000;\n    verifuint(b + a, 0x001fffffffffffff);\n    return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n    verifuint(value, 0x001fffffffffffff);\n    buffer.writeInt32LE(value & -1, offset);\n    buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n    return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\nfunction reverseBuffer(buffer) {\n    if (buffer.length < 1)\n        return buffer;\n    let j = buffer.length - 1;\n    let tmp = 0;\n    for (let i = 0; i < buffer.length / 2; i++) {\n        tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n        j--;\n    }\n    return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n    const clone = Buffer.allocUnsafe(buffer.length);\n    buffer.copy(clone);\n    return clone;\n}\nexports.cloneBuffer = cloneBuffer;\nclass BufferWriter {\n    static withCapacity(size) {\n        return new BufferWriter(Buffer.alloc(size));\n    }\n    constructor(buffer, offset = 0) {\n        this.buffer = buffer;\n        this.offset = offset;\n        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n    }\n    writeUInt8(i) {\n        this.offset = this.buffer.writeUInt8(i, this.offset);\n    }\n    writeInt32(i) {\n        this.offset = this.buffer.writeInt32LE(i, this.offset);\n    }\n    writeUInt32(i) {\n        this.offset = this.buffer.writeUInt32LE(i, this.offset);\n    }\n    writeUInt64(i) {\n        this.offset = writeUInt64LE(this.buffer, i, this.offset);\n    }\n    writeVarInt(i) {\n        varuint.encode(i, this.buffer, this.offset);\n        this.offset += varuint.encode.bytes;\n    }\n    writeSlice(slice) {\n        if (this.buffer.length < this.offset + slice.length) {\n            throw new Error(\'Cannot write slice out of bounds\');\n        }\n        this.offset += slice.copy(this.buffer, this.offset);\n    }\n    writeVarSlice(slice) {\n        this.writeVarInt(slice.length);\n        this.writeSlice(slice);\n    }\n    writeVector(vector) {\n        this.writeVarInt(vector.length);\n        vector.forEach((buf) => this.writeVarSlice(buf));\n    }\n    end() {\n        if (this.buffer.length === this.offset) {\n            return this.buffer;\n        }\n        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n    }\n}\nexports.BufferWriter = BufferWriter;\nclass BufferReader {\n    constructor(buffer, offset = 0) {\n        this.buffer = buffer;\n        this.offset = offset;\n        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n    }\n    readUInt8() {\n        const result = this.buffer.readUInt8(this.offset);\n        this.offset++;\n        return result;\n    }\n    readInt32() {\n        const result = this.buffer.readInt32LE(this.offset);\n        this.offset += 4;\n        return result;\n    }\n    readUInt32() {\n        const result = this.buffer.readUInt32LE(this.offset);\n        this.offset += 4;\n        return result;\n    }\n    readUInt64() {\n        const result = readUInt64LE(this.buffer, this.offset);\n        this.offset += 8;\n        return result;\n    }\n    readVarInt() {\n        const vi = varuint.decode(this.buffer, this.offset);\n        this.offset += varuint.decode.bytes;\n        return vi;\n    }\n    readSlice(n) {\n        if (this.buffer.length < this.offset + n) {\n            throw new Error(\'Cannot read slice out of bounds\');\n        }\n        const result = this.buffer.slice(this.offset, this.offset + n);\n        this.offset += n;\n        return result;\n    }\n    readVarSlice() {\n        return this.readSlice(this.readVarInt());\n    }\n    readVector() {\n        const count = this.readVarInt();\n        const vector = [];\n        for (let i = 0; i < count; i++)\n            vector.push(this.readVarSlice());\n        return vector;\n    }\n}\nexports.BufferReader = BufferReader;\n//# sourceMappingURL=bufferutils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9idWZmZXJ1dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsZUFBZTtBQUMxSiwyQkFBMkIsbUJBQU8sQ0FBQyx1RkFBUztBQUM1QyxRQUFRLFlBQVk7QUFDcEIsNkJBQTZCLG1CQUFPLENBQUMsMkZBQVc7QUFDaEQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CLFdBQVcsWUFBWTtBQUNqRjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9idWZmZXJ1dGlscy5qcz9iMzAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1ZmZlclJlYWRlciA9IGV4cG9ydHMuQnVmZmVyV3JpdGVyID0gZXhwb3J0cy5jbG9uZUJ1ZmZlciA9IGV4cG9ydHMucmV2ZXJzZUJ1ZmZlciA9IGV4cG9ydHMud3JpdGVVSW50NjRMRSA9IGV4cG9ydHMucmVhZFVJbnQ2NExFID0gZXhwb3J0cy52YXJ1aW50ID0gdm9pZCAwO1xuY29uc3QgdHlwZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIikpO1xuY29uc3QgeyB0eXBlZm9yY2UgfSA9IHR5cGVzO1xuY29uc3QgdmFydWludCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92YXJ1aW50XCIpKTtcbmV4cG9ydHMudmFydWludCA9IHZhcnVpbnQ7XG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcbiAgICBpZiAodmFsdWUgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG4gICAgaWYgKHZhbHVlID4gbWF4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhbmdlRXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZScpO1xuICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cbmZ1bmN0aW9uIHJlYWRVSW50NjRMRShidWZmZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGEgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgbGV0IGIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDQpO1xuICAgIGIgKj0gMHgxMDAwMDAwMDA7XG4gICAgdmVyaWZ1aW50KGIgKyBhLCAweDAwMWZmZmZmZmZmZmZmZmYpO1xuICAgIHJldHVybiBiICsgYTtcbn1cbmV4cG9ydHMucmVhZFVJbnQ2NExFID0gcmVhZFVJbnQ2NExFO1xuZnVuY3Rpb24gd3JpdGVVSW50NjRMRShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4MDAxZmZmZmZmZmZmZmZmZik7XG4gICAgYnVmZmVyLndyaXRlSW50MzJMRSh2YWx1ZSAmIC0xLCBvZmZzZXQpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKE1hdGguZmxvb3IodmFsdWUgLyAweDEwMDAwMDAwMCksIG9mZnNldCArIDQpO1xuICAgIHJldHVybiBvZmZzZXQgKyA4O1xufVxuZXhwb3J0cy53cml0ZVVJbnQ2NExFID0gd3JpdGVVSW50NjRMRTtcbmZ1bmN0aW9uIHJldmVyc2VCdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGxldCBqID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgbGV0IHRtcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHRtcCA9IGJ1ZmZlcltpXTtcbiAgICAgICAgYnVmZmVyW2ldID0gYnVmZmVyW2pdO1xuICAgICAgICBidWZmZXJbal0gPSB0bXA7XG4gICAgICAgIGotLTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMucmV2ZXJzZUJ1ZmZlciA9IHJldmVyc2VCdWZmZXI7XG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIpIHtcbiAgICBjb25zdCBjbG9uZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZmZXIubGVuZ3RoKTtcbiAgICBidWZmZXIuY29weShjbG9uZSk7XG4gICAgcmV0dXJuIGNsb25lO1xufVxuZXhwb3J0cy5jbG9uZUJ1ZmZlciA9IGNsb25lQnVmZmVyO1xuY2xhc3MgQnVmZmVyV3JpdGVyIHtcbiAgICBzdGF0aWMgd2l0aENhcGFjaXR5KHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoQnVmZmVyLmFsbG9jKHNpemUpKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLkJ1ZmZlciwgdHlwZXMuVUludDMyKSwgW2J1ZmZlciwgb2Zmc2V0XSk7XG4gICAgfVxuICAgIHdyaXRlVUludDgoaSkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuYnVmZmVyLndyaXRlVUludDgoaSwgdGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICB3cml0ZUludDMyKGkpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLmJ1ZmZlci53cml0ZUludDMyTEUoaSwgdGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICB3cml0ZVVJbnQzMihpKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5idWZmZXIud3JpdGVVSW50MzJMRShpLCB0aGlzLm9mZnNldCk7XG4gICAgfVxuICAgIHdyaXRlVUludDY0KGkpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB3cml0ZVVJbnQ2NExFKHRoaXMuYnVmZmVyLCBpLCB0aGlzLm9mZnNldCk7XG4gICAgfVxuICAgIHdyaXRlVmFySW50KGkpIHtcbiAgICAgICAgdmFydWludC5lbmNvZGUoaSwgdGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gdmFydWludC5lbmNvZGUuYnl0ZXM7XG4gICAgfVxuICAgIHdyaXRlU2xpY2Uoc2xpY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IHRoaXMub2Zmc2V0ICsgc2xpY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB3cml0ZSBzbGljZSBvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gc2xpY2UuY29weSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICB3cml0ZVZhclNsaWNlKHNsaWNlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJJbnQoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgdGhpcy53cml0ZVNsaWNlKHNsaWNlKTtcbiAgICB9XG4gICAgd3JpdGVWZWN0b3IodmVjdG9yKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJJbnQodmVjdG9yLmxlbmd0aCk7XG4gICAgICAgIHZlY3Rvci5mb3JFYWNoKChidWYpID0+IHRoaXMud3JpdGVWYXJTbGljZShidWYpKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09PSB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYnVmZmVyIHNpemUgJHt0aGlzLmJ1ZmZlci5sZW5ndGh9LCBvZmZzZXQgJHt0aGlzLm9mZnNldH1gKTtcbiAgICB9XG59XG5leHBvcnRzLkJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcjtcbmNsYXNzIEJ1ZmZlclJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLkJ1ZmZlciwgdHlwZXMuVUludDMyKSwgW2J1ZmZlciwgb2Zmc2V0XSk7XG4gICAgfVxuICAgIHJlYWRVSW50OCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVhZEludDMyKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1ZmZlci5yZWFkSW50MzJMRSh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlYWRVSW50MzIoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJMRSh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlYWRVSW50NjQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRVSW50NjRMRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWFkVmFySW50KCkge1xuICAgICAgICBjb25zdCB2aSA9IHZhcnVpbnQuZGVjb2RlKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IHZhcnVpbnQuZGVjb2RlLmJ5dGVzO1xuICAgICAgICByZXR1cm4gdmk7XG4gICAgfVxuICAgIHJlYWRTbGljZShuKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPCB0aGlzLm9mZnNldCArIG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgc2xpY2Ugb3V0IG9mIGJvdW5kcycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIG4pO1xuICAgICAgICB0aGlzLm9mZnNldCArPSBuO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWFkVmFyU2xpY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRTbGljZSh0aGlzLnJlYWRWYXJJbnQoKSk7XG4gICAgfVxuICAgIHJlYWRWZWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5yZWFkVmFySW50KCk7XG4gICAgICAgIGNvbnN0IHZlY3RvciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICAgICAgICB2ZWN0b3IucHVzaCh0aGlzLnJlYWRWYXJTbGljZSgpKTtcbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG59XG5leHBvcnRzLkJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlcnV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js':
    /*!*************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js ***!
  \*************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.taggedHash = exports.hash256 = exports.hash160 = exports.sha256 = exports.ripemd160 = void 0;\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nfunction ripemd160(buffer) {\n    return Buffer.from(crypto_lib_1.base.ripemd160(buffer));\n}\nexports.ripemd160 = ripemd160;\nfunction sha256(buffer) {\n    return Buffer.from(crypto_lib_1.base.sha256(buffer));\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n    return ripemd160(sha256(buffer));\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n    return sha256(sha256(buffer));\n}\nexports.hash256 = hash256;\nconst TAGS = [\n    'BIP0340/challenge',\n    'BIP0340/aux',\n    'BIP0340/nonce',\n    'TapLeaf',\n    'TapBranch',\n    'TapSighash',\n    'TapTweak',\n    'KeyAgg list',\n    'KeyAgg coefficient',\n];\nconst TAGGED_HASH_PREFIXES = Object.fromEntries(TAGS.map(tag => {\n    const tagHash = sha256(Buffer.from(tag));\n    return [tag, Buffer.concat([tagHash, tagHash])];\n}));\nfunction taggedHash(prefix, data) {\n    return sha256(Buffer.concat([TAGGED_HASH_PREFIXES[prefix], data]));\n}\nexports.taggedHash = taggedHash;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9jcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsaUJBQWlCO0FBQzNGLHFCQUFxQixtQkFBTyxDQUFDLG1GQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL2NyeXB0by5qcz8yNzYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50YWdnZWRIYXNoID0gZXhwb3J0cy5oYXNoMjU2ID0gZXhwb3J0cy5oYXNoMTYwID0gZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzLnJpcGVtZDE2MCA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuZnVuY3Rpb24gcmlwZW1kMTYwKGJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShjcnlwdG9fbGliXzEuYmFzZS5yaXBlbWQxNjAoYnVmZmVyKSk7XG59XG5leHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDtcbmZ1bmN0aW9uIHNoYTI1NihidWZmZXIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oY3J5cHRvX2xpYl8xLmJhc2Uuc2hhMjU2KGJ1ZmZlcikpO1xufVxuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5mdW5jdGlvbiBoYXNoMTYwKGJ1ZmZlcikge1xuICAgIHJldHVybiByaXBlbWQxNjAoc2hhMjU2KGJ1ZmZlcikpO1xufVxuZXhwb3J0cy5oYXNoMTYwID0gaGFzaDE2MDtcbmZ1bmN0aW9uIGhhc2gyNTYoYnVmZmVyKSB7XG4gICAgcmV0dXJuIHNoYTI1NihzaGEyNTYoYnVmZmVyKSk7XG59XG5leHBvcnRzLmhhc2gyNTYgPSBoYXNoMjU2O1xuY29uc3QgVEFHUyA9IFtcbiAgICAnQklQMDM0MC9jaGFsbGVuZ2UnLFxuICAgICdCSVAwMzQwL2F1eCcsXG4gICAgJ0JJUDAzNDAvbm9uY2UnLFxuICAgICdUYXBMZWFmJyxcbiAgICAnVGFwQnJhbmNoJyxcbiAgICAnVGFwU2lnaGFzaCcsXG4gICAgJ1RhcFR3ZWFrJyxcbiAgICAnS2V5QWdnIGxpc3QnLFxuICAgICdLZXlBZ2cgY29lZmZpY2llbnQnLFxuXTtcbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0gT2JqZWN0LmZyb21FbnRyaWVzKFRBR1MubWFwKHRhZyA9PiB7XG4gICAgY29uc3QgdGFnSGFzaCA9IHNoYTI1NihCdWZmZXIuZnJvbSh0YWcpKTtcbiAgICByZXR1cm4gW3RhZywgQnVmZmVyLmNvbmNhdChbdGFnSGFzaCwgdGFnSGFzaF0pXTtcbn0pKTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2gocHJlZml4LCBkYXRhKSB7XG4gICAgcmV0dXJuIHNoYTI1NihCdWZmZXIuY29uY2F0KFtUQUdHRURfSEFTSF9QUkVGSVhFU1twcmVmaXhdLCBkYXRhXSkpO1xufVxuZXhwb3J0cy50YWdnZWRIYXNoID0gdGFnZ2VkSGFzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js':
    /*!************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js ***!
  \************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BufferWriter = exports.Transaction = exports.bip0322 = exports.script = exports.payments = exports.networks = exports.crypto = exports.address = void 0;\nconst address = __importStar(__webpack_require__(/*! ./address */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/address.js"));\nexports.address = address;\nconst crypto = __importStar(__webpack_require__(/*! ./crypto */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js"));\nexports.crypto = crypto;\nconst networks = __importStar(__webpack_require__(/*! ./networks */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js"));\nexports.networks = networks;\nconst payments = __importStar(__webpack_require__(/*! ./payments */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js"));\nexports.payments = payments;\nconst script = __importStar(__webpack_require__(/*! ./script */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js"));\nexports.script = script;\nconst bip0322 = __importStar(__webpack_require__(/*! ./bip0322 */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip0322.js"));\nexports.bip0322 = bip0322;\nvar transaction_1 = __webpack_require__(/*! ./transaction */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/transaction.js");\nObject.defineProperty(exports, "Transaction", ({ enumerable: true, get: function () { return transaction_1.Transaction; } }));\nvar bufferutils_1 = __webpack_require__(/*! ./bufferutils */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js");\nObject.defineProperty(exports, "BufferWriter", ({ enumerable: true, get: function () { return bufferutils_1.BufferWriter; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsZUFBZTtBQUN0Siw2QkFBNkIsbUJBQU8sQ0FBQywyRkFBVztBQUNoRCxlQUFlO0FBQ2YsNEJBQTRCLG1CQUFPLENBQUMseUZBQVU7QUFDOUMsY0FBYztBQUNkLDhCQUE4QixtQkFBTyxDQUFDLDZGQUFZO0FBQ2xELGdCQUFnQjtBQUNoQiw4QkFBOEIsbUJBQU8sQ0FBQyxtR0FBWTtBQUNsRCxnQkFBZ0I7QUFDaEIsNEJBQTRCLG1CQUFPLENBQUMseUZBQVU7QUFDOUMsY0FBYztBQUNkLDZCQUE2QixtQkFBTyxDQUFDLDJGQUFXO0FBQ2hELGVBQWU7QUFDZixvQkFBb0IsbUJBQU8sQ0FBQyxtR0FBZTtBQUMzQywrQ0FBOEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDM0gsb0JBQW9CLG1CQUFPLENBQUMsbUdBQWU7QUFDM0MsZ0RBQStDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzdIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9pbmRleC5qcz9iODkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1ZmZlcldyaXRlciA9IGV4cG9ydHMuVHJhbnNhY3Rpb24gPSBleHBvcnRzLmJpcDAzMjIgPSBleHBvcnRzLnNjcmlwdCA9IGV4cG9ydHMucGF5bWVudHMgPSBleHBvcnRzLm5ldHdvcmtzID0gZXhwb3J0cy5jcnlwdG8gPSBleHBvcnRzLmFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBhZGRyZXNzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FkZHJlc3NcIikpO1xuZXhwb3J0cy5hZGRyZXNzID0gYWRkcmVzcztcbmNvbnN0IGNyeXB0byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jcnlwdG9cIikpO1xuZXhwb3J0cy5jcnlwdG8gPSBjcnlwdG87XG5jb25zdCBuZXR3b3JrcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9uZXR3b3Jrc1wiKSk7XG5leHBvcnRzLm5ldHdvcmtzID0gbmV0d29ya3M7XG5jb25zdCBwYXltZW50cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9wYXltZW50c1wiKSk7XG5leHBvcnRzLnBheW1lbnRzID0gcGF5bWVudHM7XG5jb25zdCBzY3JpcHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2NyaXB0XCIpKTtcbmV4cG9ydHMuc2NyaXB0ID0gc2NyaXB0O1xuY29uc3QgYmlwMDMyMiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iaXAwMzIyXCIpKTtcbmV4cG9ydHMuYmlwMDMyMiA9IGJpcDAzMjI7XG52YXIgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb247IH0gfSk7XG52YXIgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoXCIuL2J1ZmZlcnV0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnVmZmVyV3JpdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js':
    /*!***************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js ***!
  \***************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.testnet = exports.regtest = exports.bitcoin = void 0;\nexports.bitcoin = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nexports.regtest = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bcrt',\n    bip32: {\n        public: 0x043587cf,\n        private: 0x04358394,\n    },\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef,\n};\nexports.testnet = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'tb',\n    bip32: {\n        public: 0x043587cf,\n        private: 0x04358394,\n    },\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef,\n};\n//# sourceMappingURL=networks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9uZXR3b3Jrcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsZUFBZSxHQUFHLGVBQWU7QUFDbkQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL25ldHdvcmtzLmpzPzJmMzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRlc3RuZXQgPSBleHBvcnRzLnJlZ3Rlc3QgPSBleHBvcnRzLmJpdGNvaW4gPSB2b2lkIDA7XG5leHBvcnRzLmJpdGNvaW4gPSB7XG4gICAgbWVzc2FnZVByZWZpeDogJ1xceDE4Qml0Y29pbiBTaWduZWQgTWVzc2FnZTpcXG4nLFxuICAgIGJlY2gzMjogJ2JjJyxcbiAgICBiaXAzMjoge1xuICAgICAgICBwdWJsaWM6IDB4MDQ4OGIyMWUsXG4gICAgICAgIHByaXZhdGU6IDB4MDQ4OGFkZTQsXG4gICAgfSxcbiAgICBwdWJLZXlIYXNoOiAweDAwLFxuICAgIHNjcmlwdEhhc2g6IDB4MDUsXG4gICAgd2lmOiAweDgwLFxufTtcbmV4cG9ydHMucmVndGVzdCA9IHtcbiAgICBtZXNzYWdlUHJlZml4OiAnXFx4MThCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcbicsXG4gICAgYmVjaDMyOiAnYmNydCcsXG4gICAgYmlwMzI6IHtcbiAgICAgICAgcHVibGljOiAweDA0MzU4N2NmLFxuICAgICAgICBwcml2YXRlOiAweDA0MzU4Mzk0LFxuICAgIH0sXG4gICAgcHViS2V5SGFzaDogMHg2ZixcbiAgICBzY3JpcHRIYXNoOiAweGM0LFxuICAgIHdpZjogMHhlZixcbn07XG5leHBvcnRzLnRlc3RuZXQgPSB7XG4gICAgbWVzc2FnZVByZWZpeDogJ1xceDE4Qml0Y29pbiBTaWduZWQgTWVzc2FnZTpcXG4nLFxuICAgIGJlY2gzMjogJ3RiJyxcbiAgICBiaXAzMjoge1xuICAgICAgICBwdWJsaWM6IDB4MDQzNTg3Y2YsXG4gICAgICAgIHByaXZhdGU6IDB4MDQzNTgzOTQsXG4gICAgfSxcbiAgICBwdWJLZXlIYXNoOiAweDZmLFxuICAgIHNjcmlwdEhhc2g6IDB4YzQsXG4gICAgd2lmOiAweGVmLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmtzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/ops.js':
    /*!**********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/ops.js ***!
  \**********************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.REVERSE_OPS = exports.OPS = void 0;\nconst OPS = {\n    OP_FALSE: 0,\n    OP_0: 0,\n    OP_DATA_1: 1,\n    OP_PUSHDATA1: 76,\n    OP_PUSHDATA2: 77,\n    OP_PUSHDATA4: 78,\n    OP_1NEGATE: 79,\n    OP_RESERVED: 80,\n    OP_TRUE: 81,\n    OP_1: 81,\n    OP_2: 82,\n    OP_3: 83,\n    OP_4: 84,\n    OP_5: 85,\n    OP_6: 86,\n    OP_7: 87,\n    OP_8: 88,\n    OP_9: 89,\n    OP_10: 90,\n    OP_11: 91,\n    OP_12: 92,\n    OP_13: 93,\n    OP_14: 94,\n    OP_15: 95,\n    OP_16: 96,\n    OP_NOP: 97,\n    OP_VER: 98,\n    OP_IF: 99,\n    OP_NOTIF: 100,\n    OP_VERIF: 101,\n    OP_VERNOTIF: 102,\n    OP_ELSE: 103,\n    OP_ENDIF: 104,\n    OP_VERIFY: 105,\n    OP_RETURN: 106,\n    OP_TOALTSTACK: 107,\n    OP_FROMALTSTACK: 108,\n    OP_2DROP: 109,\n    OP_2DUP: 110,\n    OP_3DUP: 111,\n    OP_2OVER: 112,\n    OP_2ROT: 113,\n    OP_2SWAP: 114,\n    OP_IFDUP: 115,\n    OP_DEPTH: 116,\n    OP_DROP: 117,\n    OP_DUP: 118,\n    OP_NIP: 119,\n    OP_OVER: 120,\n    OP_PICK: 121,\n    OP_ROLL: 122,\n    OP_ROT: 123,\n    OP_SWAP: 124,\n    OP_TUCK: 125,\n    OP_CAT: 126,\n    OP_SUBSTR: 127,\n    OP_LEFT: 128,\n    OP_RIGHT: 129,\n    OP_SIZE: 130,\n    OP_INVERT: 131,\n    OP_AND: 132,\n    OP_OR: 133,\n    OP_XOR: 134,\n    OP_EQUAL: 135,\n    OP_EQUALVERIFY: 136,\n    OP_RESERVED1: 137,\n    OP_RESERVED2: 138,\n    OP_1ADD: 139,\n    OP_1SUB: 140,\n    OP_2MUL: 141,\n    OP_2DIV: 142,\n    OP_NEGATE: 143,\n    OP_ABS: 144,\n    OP_NOT: 145,\n    OP_0NOTEQUAL: 146,\n    OP_ADD: 147,\n    OP_SUB: 148,\n    OP_MUL: 149,\n    OP_DIV: 150,\n    OP_MOD: 151,\n    OP_LSHIFT: 152,\n    OP_RSHIFT: 153,\n    OP_BOOLAND: 154,\n    OP_BOOLOR: 155,\n    OP_NUMEQUAL: 156,\n    OP_NUMEQUALVERIFY: 157,\n    OP_NUMNOTEQUAL: 158,\n    OP_LESSTHAN: 159,\n    OP_GREATERTHAN: 160,\n    OP_LESSTHANOREQUAL: 161,\n    OP_GREATERTHANOREQUAL: 162,\n    OP_MIN: 163,\n    OP_MAX: 164,\n    OP_WITHIN: 165,\n    OP_RIPEMD160: 166,\n    OP_SHA1: 167,\n    OP_SHA256: 168,\n    OP_HASH160: 169,\n    OP_HASH256: 170,\n    OP_CODESEPARATOR: 171,\n    OP_CHECKSIG: 172,\n    OP_CHECKSIGVERIFY: 173,\n    OP_CHECKMULTISIG: 174,\n    OP_CHECKMULTISIGVERIFY: 175,\n    OP_NOP1: 176,\n    OP_NOP2: 177,\n    OP_CHECKLOCKTIMEVERIFY: 177,\n    OP_NOP3: 178,\n    OP_CHECKSEQUENCEVERIFY: 178,\n    OP_NOP4: 179,\n    OP_NOP5: 180,\n    OP_NOP6: 181,\n    OP_NOP7: 182,\n    OP_NOP8: 183,\n    OP_NOP9: 184,\n    OP_NOP10: 185,\n    OP_CHECKSIGADD: 186,\n    OP_PUBKEYHASH: 253,\n    OP_PUBKEY: 254,\n    OP_INVALIDOPCODE: 255,\n};\nexports.OPS = OPS;\nconst REVERSE_OPS = {};\nexports.REVERSE_OPS = REVERSE_OPS;\nfor (const op of Object.keys(OPS)) {\n    const code = OPS[op];\n    REVERSE_OPS[code] = op;\n}\n//# sourceMappingURL=ops.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9vcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL29wcy5qcz8wYzE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SRVZFUlNFX09QUyA9IGV4cG9ydHMuT1BTID0gdm9pZCAwO1xuY29uc3QgT1BTID0ge1xuICAgIE9QX0ZBTFNFOiAwLFxuICAgIE9QXzA6IDAsXG4gICAgT1BfREFUQV8xOiAxLFxuICAgIE9QX1BVU0hEQVRBMTogNzYsXG4gICAgT1BfUFVTSERBVEEyOiA3NyxcbiAgICBPUF9QVVNIREFUQTQ6IDc4LFxuICAgIE9QXzFORUdBVEU6IDc5LFxuICAgIE9QX1JFU0VSVkVEOiA4MCxcbiAgICBPUF9UUlVFOiA4MSxcbiAgICBPUF8xOiA4MSxcbiAgICBPUF8yOiA4MixcbiAgICBPUF8zOiA4MyxcbiAgICBPUF80OiA4NCxcbiAgICBPUF81OiA4NSxcbiAgICBPUF82OiA4NixcbiAgICBPUF83OiA4NyxcbiAgICBPUF84OiA4OCxcbiAgICBPUF85OiA4OSxcbiAgICBPUF8xMDogOTAsXG4gICAgT1BfMTE6IDkxLFxuICAgIE9QXzEyOiA5MixcbiAgICBPUF8xMzogOTMsXG4gICAgT1BfMTQ6IDk0LFxuICAgIE9QXzE1OiA5NSxcbiAgICBPUF8xNjogOTYsXG4gICAgT1BfTk9QOiA5NyxcbiAgICBPUF9WRVI6IDk4LFxuICAgIE9QX0lGOiA5OSxcbiAgICBPUF9OT1RJRjogMTAwLFxuICAgIE9QX1ZFUklGOiAxMDEsXG4gICAgT1BfVkVSTk9USUY6IDEwMixcbiAgICBPUF9FTFNFOiAxMDMsXG4gICAgT1BfRU5ESUY6IDEwNCxcbiAgICBPUF9WRVJJRlk6IDEwNSxcbiAgICBPUF9SRVRVUk46IDEwNixcbiAgICBPUF9UT0FMVFNUQUNLOiAxMDcsXG4gICAgT1BfRlJPTUFMVFNUQUNLOiAxMDgsXG4gICAgT1BfMkRST1A6IDEwOSxcbiAgICBPUF8yRFVQOiAxMTAsXG4gICAgT1BfM0RVUDogMTExLFxuICAgIE9QXzJPVkVSOiAxMTIsXG4gICAgT1BfMlJPVDogMTEzLFxuICAgIE9QXzJTV0FQOiAxMTQsXG4gICAgT1BfSUZEVVA6IDExNSxcbiAgICBPUF9ERVBUSDogMTE2LFxuICAgIE9QX0RST1A6IDExNyxcbiAgICBPUF9EVVA6IDExOCxcbiAgICBPUF9OSVA6IDExOSxcbiAgICBPUF9PVkVSOiAxMjAsXG4gICAgT1BfUElDSzogMTIxLFxuICAgIE9QX1JPTEw6IDEyMixcbiAgICBPUF9ST1Q6IDEyMyxcbiAgICBPUF9TV0FQOiAxMjQsXG4gICAgT1BfVFVDSzogMTI1LFxuICAgIE9QX0NBVDogMTI2LFxuICAgIE9QX1NVQlNUUjogMTI3LFxuICAgIE9QX0xFRlQ6IDEyOCxcbiAgICBPUF9SSUdIVDogMTI5LFxuICAgIE9QX1NJWkU6IDEzMCxcbiAgICBPUF9JTlZFUlQ6IDEzMSxcbiAgICBPUF9BTkQ6IDEzMixcbiAgICBPUF9PUjogMTMzLFxuICAgIE9QX1hPUjogMTM0LFxuICAgIE9QX0VRVUFMOiAxMzUsXG4gICAgT1BfRVFVQUxWRVJJRlk6IDEzNixcbiAgICBPUF9SRVNFUlZFRDE6IDEzNyxcbiAgICBPUF9SRVNFUlZFRDI6IDEzOCxcbiAgICBPUF8xQUREOiAxMzksXG4gICAgT1BfMVNVQjogMTQwLFxuICAgIE9QXzJNVUw6IDE0MSxcbiAgICBPUF8yRElWOiAxNDIsXG4gICAgT1BfTkVHQVRFOiAxNDMsXG4gICAgT1BfQUJTOiAxNDQsXG4gICAgT1BfTk9UOiAxNDUsXG4gICAgT1BfME5PVEVRVUFMOiAxNDYsXG4gICAgT1BfQUREOiAxNDcsXG4gICAgT1BfU1VCOiAxNDgsXG4gICAgT1BfTVVMOiAxNDksXG4gICAgT1BfRElWOiAxNTAsXG4gICAgT1BfTU9EOiAxNTEsXG4gICAgT1BfTFNISUZUOiAxNTIsXG4gICAgT1BfUlNISUZUOiAxNTMsXG4gICAgT1BfQk9PTEFORDogMTU0LFxuICAgIE9QX0JPT0xPUjogMTU1LFxuICAgIE9QX05VTUVRVUFMOiAxNTYsXG4gICAgT1BfTlVNRVFVQUxWRVJJRlk6IDE1NyxcbiAgICBPUF9OVU1OT1RFUVVBTDogMTU4LFxuICAgIE9QX0xFU1NUSEFOOiAxNTksXG4gICAgT1BfR1JFQVRFUlRIQU46IDE2MCxcbiAgICBPUF9MRVNTVEhBTk9SRVFVQUw6IDE2MSxcbiAgICBPUF9HUkVBVEVSVEhBTk9SRVFVQUw6IDE2MixcbiAgICBPUF9NSU46IDE2MyxcbiAgICBPUF9NQVg6IDE2NCxcbiAgICBPUF9XSVRISU46IDE2NSxcbiAgICBPUF9SSVBFTUQxNjA6IDE2NixcbiAgICBPUF9TSEExOiAxNjcsXG4gICAgT1BfU0hBMjU2OiAxNjgsXG4gICAgT1BfSEFTSDE2MDogMTY5LFxuICAgIE9QX0hBU0gyNTY6IDE3MCxcbiAgICBPUF9DT0RFU0VQQVJBVE9SOiAxNzEsXG4gICAgT1BfQ0hFQ0tTSUc6IDE3MixcbiAgICBPUF9DSEVDS1NJR1ZFUklGWTogMTczLFxuICAgIE9QX0NIRUNLTVVMVElTSUc6IDE3NCxcbiAgICBPUF9DSEVDS01VTFRJU0lHVkVSSUZZOiAxNzUsXG4gICAgT1BfTk9QMTogMTc2LFxuICAgIE9QX05PUDI6IDE3NyxcbiAgICBPUF9DSEVDS0xPQ0tUSU1FVkVSSUZZOiAxNzcsXG4gICAgT1BfTk9QMzogMTc4LFxuICAgIE9QX0NIRUNLU0VRVUVOQ0VWRVJJRlk6IDE3OCxcbiAgICBPUF9OT1A0OiAxNzksXG4gICAgT1BfTk9QNTogMTgwLFxuICAgIE9QX05PUDY6IDE4MSxcbiAgICBPUF9OT1A3OiAxODIsXG4gICAgT1BfTk9QODogMTgzLFxuICAgIE9QX05PUDk6IDE4NCxcbiAgICBPUF9OT1AxMDogMTg1LFxuICAgIE9QX0NIRUNLU0lHQUREOiAxODYsXG4gICAgT1BfUFVCS0VZSEFTSDogMjUzLFxuICAgIE9QX1BVQktFWTogMjU0LFxuICAgIE9QX0lOVkFMSURPUENPREU6IDI1NSxcbn07XG5leHBvcnRzLk9QUyA9IE9QUztcbmNvbnN0IFJFVkVSU0VfT1BTID0ge307XG5leHBvcnRzLlJFVkVSU0VfT1BTID0gUkVWRVJTRV9PUFM7XG5mb3IgKGNvbnN0IG9wIG9mIE9iamVjdC5rZXlzKE9QUykpIHtcbiAgICBjb25zdCBjb2RlID0gT1BTW29wXTtcbiAgICBSRVZFUlNFX09QU1tjb2RlXSA9IG9wO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/ops.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/bip341.js':
    /*!**********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/bip341.js ***!
  \**********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.tweakKey = exports.tapTweakHash = exports.tapleafHash = exports.findScriptPath = exports.toHashTree = exports.rootHashFromPath = exports.MAX_TAPTREE_DEPTH = exports.LEAF_VERSION_TAPSCRIPT = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ "buffer");\nconst bcrypto = __importStar(__webpack_require__(/*! ../crypto */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js"));\nconst bufferutils_1 = __webpack_require__(/*! ../bufferutils */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js");\nconst types_1 = __webpack_require__(/*! ../types */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js");\nconst taproot_1 = __webpack_require__(/*! ../../taproot */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/taproot.js");\nexports.LEAF_VERSION_TAPSCRIPT = 0xc0;\nexports.MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = (ht) => \'left\' in ht && \'right\' in ht;\nfunction rootHashFromPath(controlBlock, leafHash) {\n    if (controlBlock.length < 33)\n        throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 33.`);\n    const m = (controlBlock.length - 33) / 32;\n    let kj = leafHash;\n    for (let j = 0; j < m; j++) {\n        const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n        if (kj.compare(ej) < 0) {\n            kj = tapBranchHash(kj, ej);\n        }\n        else {\n            kj = tapBranchHash(ej, kj);\n        }\n    }\n    return kj;\n}\nexports.rootHashFromPath = rootHashFromPath;\nfunction toHashTree(scriptTree) {\n    if ((0, types_1.isTapleaf)(scriptTree))\n        return { hash: tapleafHash(scriptTree) };\n    const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n    hashes.sort((a, b) => a.hash.compare(b.hash));\n    const [left, right] = hashes;\n    return {\n        hash: tapBranchHash(left.hash, right.hash),\n        left,\n        right,\n    };\n}\nexports.toHashTree = toHashTree;\nfunction findScriptPath(node, hash) {\n    if (isHashBranch(node)) {\n        const leftPath = findScriptPath(node.left, hash);\n        if (leftPath !== undefined)\n            return [...leftPath, node.right.hash];\n        const rightPath = findScriptPath(node.right, hash);\n        if (rightPath !== undefined)\n            return [...rightPath, node.left.hash];\n    }\n    else if (node.hash.equals(hash)) {\n        return [];\n    }\n    return undefined;\n}\nexports.findScriptPath = findScriptPath;\nfunction tapleafHash(leaf) {\n    const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;\n    return bcrypto.taggedHash(\'TapLeaf\', buffer_1.Buffer.concat([buffer_1.Buffer.from([version]), serializeScript(leaf.output)]));\n}\nexports.tapleafHash = tapleafHash;\nfunction tapTweakHash(pubKey, h) {\n    return bcrypto.taggedHash(\'TapTweak\', buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]));\n}\nexports.tapTweakHash = tapTweakHash;\nfunction tweakKey(pubKey, h) {\n    if (!buffer_1.Buffer.isBuffer(pubKey))\n        return null;\n    if (pubKey.length !== 32)\n        return null;\n    if (h && h.length !== 32)\n        return null;\n    const res = (0, taproot_1.taprootTweakPubkey)(pubKey, h);\n    return {\n        parity: res[1],\n        x: buffer_1.Buffer.from(res[0]),\n    };\n}\nexports.tweakKey = tweakKey;\nfunction tapBranchHash(a, b) {\n    return bcrypto.taggedHash(\'TapBranch\', buffer_1.Buffer.concat([a, b]));\n}\nfunction serializeScript(s) {\n    const varintLen = bufferutils_1.varuint.encodingLength(s.length);\n    const buffer = buffer_1.Buffer.allocUnsafe(varintLen);\n    bufferutils_1.varuint.encode(s.length, buffer);\n    return buffer_1.Buffer.concat([buffer, s]);\n}\n//# sourceMappingURL=bip341.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9iaXAzNDEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLDhCQUE4QjtBQUNuTSxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyw2QkFBNkIsbUJBQU8sQ0FBQywwRkFBVztBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyxvR0FBZ0I7QUFDOUMsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQVU7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsaUZBQWU7QUFDekMsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsb0JBQW9CO0FBQzlGO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvcGF5bWVudHMvYmlwMzQxLmpzPzUxMmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHdlYWtLZXkgPSBleHBvcnRzLnRhcFR3ZWFrSGFzaCA9IGV4cG9ydHMudGFwbGVhZkhhc2ggPSBleHBvcnRzLmZpbmRTY3JpcHRQYXRoID0gZXhwb3J0cy50b0hhc2hUcmVlID0gZXhwb3J0cy5yb290SGFzaEZyb21QYXRoID0gZXhwb3J0cy5NQVhfVEFQVFJFRV9ERVBUSCA9IGV4cG9ydHMuTEVBRl9WRVJTSU9OX1RBUFNDUklQVCA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmNvbnN0IGJjcnlwdG8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2NyeXB0b1wiKSk7XG5jb25zdCBidWZmZXJ1dGlsc18xID0gcmVxdWlyZShcIi4uL2J1ZmZlcnV0aWxzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmNvbnN0IHRhcHJvb3RfMSA9IHJlcXVpcmUoXCIuLi8uLi90YXByb290XCIpO1xuZXhwb3J0cy5MRUFGX1ZFUlNJT05fVEFQU0NSSVBUID0gMHhjMDtcbmV4cG9ydHMuTUFYX1RBUFRSRUVfREVQVEggPSAxMjg7XG5jb25zdCBpc0hhc2hCcmFuY2ggPSAoaHQpID0+ICdsZWZ0JyBpbiBodCAmJiAncmlnaHQnIGluIGh0O1xuZnVuY3Rpb24gcm9vdEhhc2hGcm9tUGF0aChjb250cm9sQmxvY2ssIGxlYWZIYXNoKSB7XG4gICAgaWYgKGNvbnRyb2xCbG9jay5sZW5ndGggPCAzMylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIGNvbnRyb2wtYmxvY2sgbGVuZ3RoIGlzIHRvbyBzbWFsbC4gR290ICR7Y29udHJvbEJsb2NrLmxlbmd0aH0sIGV4cGVjdGVkIG1pbiAzMy5gKTtcbiAgICBjb25zdCBtID0gKGNvbnRyb2xCbG9jay5sZW5ndGggLSAzMykgLyAzMjtcbiAgICBsZXQga2ogPSBsZWFmSGFzaDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICBjb25zdCBlaiA9IGNvbnRyb2xCbG9jay5zbGljZSgzMyArIDMyICogaiwgNjUgKyAzMiAqIGopO1xuICAgICAgICBpZiAoa2ouY29tcGFyZShlaikgPCAwKSB7XG4gICAgICAgICAgICBraiA9IHRhcEJyYW5jaEhhc2goa2osIGVqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtqID0gdGFwQnJhbmNoSGFzaChlaiwga2opO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrajtcbn1cbmV4cG9ydHMucm9vdEhhc2hGcm9tUGF0aCA9IHJvb3RIYXNoRnJvbVBhdGg7XG5mdW5jdGlvbiB0b0hhc2hUcmVlKHNjcmlwdFRyZWUpIHtcbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNUYXBsZWFmKShzY3JpcHRUcmVlKSlcbiAgICAgICAgcmV0dXJuIHsgaGFzaDogdGFwbGVhZkhhc2goc2NyaXB0VHJlZSkgfTtcbiAgICBjb25zdCBoYXNoZXMgPSBbdG9IYXNoVHJlZShzY3JpcHRUcmVlWzBdKSwgdG9IYXNoVHJlZShzY3JpcHRUcmVlWzFdKV07XG4gICAgaGFzaGVzLnNvcnQoKGEsIGIpID0+IGEuaGFzaC5jb21wYXJlKGIuaGFzaCkpO1xuICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBoYXNoZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaDogdGFwQnJhbmNoSGFzaChsZWZ0Lmhhc2gsIHJpZ2h0Lmhhc2gpLFxuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodCxcbiAgICB9O1xufVxuZXhwb3J0cy50b0hhc2hUcmVlID0gdG9IYXNoVHJlZTtcbmZ1bmN0aW9uIGZpbmRTY3JpcHRQYXRoKG5vZGUsIGhhc2gpIHtcbiAgICBpZiAoaXNIYXNoQnJhbmNoKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGxlZnRQYXRoID0gZmluZFNjcmlwdFBhdGgobm9kZS5sZWZ0LCBoYXNoKTtcbiAgICAgICAgaWYgKGxlZnRQYXRoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gWy4uLmxlZnRQYXRoLCBub2RlLnJpZ2h0Lmhhc2hdO1xuICAgICAgICBjb25zdCByaWdodFBhdGggPSBmaW5kU2NyaXB0UGF0aChub2RlLnJpZ2h0LCBoYXNoKTtcbiAgICAgICAgaWYgKHJpZ2h0UGF0aCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIFsuLi5yaWdodFBhdGgsIG5vZGUubGVmdC5oYXNoXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5oYXNoLmVxdWFscyhoYXNoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmZpbmRTY3JpcHRQYXRoID0gZmluZFNjcmlwdFBhdGg7XG5mdW5jdGlvbiB0YXBsZWFmSGFzaChsZWFmKSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IGxlYWYudmVyc2lvbiB8fCBleHBvcnRzLkxFQUZfVkVSU0lPTl9UQVBTQ1JJUFQ7XG4gICAgcmV0dXJuIGJjcnlwdG8udGFnZ2VkSGFzaCgnVGFwTGVhZicsIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW2J1ZmZlcl8xLkJ1ZmZlci5mcm9tKFt2ZXJzaW9uXSksIHNlcmlhbGl6ZVNjcmlwdChsZWFmLm91dHB1dCldKSk7XG59XG5leHBvcnRzLnRhcGxlYWZIYXNoID0gdGFwbGVhZkhhc2g7XG5mdW5jdGlvbiB0YXBUd2Vha0hhc2gocHViS2V5LCBoKSB7XG4gICAgcmV0dXJuIGJjcnlwdG8udGFnZ2VkSGFzaCgnVGFwVHdlYWsnLCBidWZmZXJfMS5CdWZmZXIuY29uY2F0KGggPyBbcHViS2V5LCBoXSA6IFtwdWJLZXldKSk7XG59XG5leHBvcnRzLnRhcFR3ZWFrSGFzaCA9IHRhcFR3ZWFrSGFzaDtcbmZ1bmN0aW9uIHR3ZWFrS2V5KHB1YktleSwgaCkge1xuICAgIGlmICghYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKHB1YktleSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChwdWJLZXkubGVuZ3RoICE9PSAzMilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGggJiYgaC5sZW5ndGggIT09IDMyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByZXMgPSAoMCwgdGFwcm9vdF8xLnRhcHJvb3RUd2Vha1B1YmtleSkocHViS2V5LCBoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJpdHk6IHJlc1sxXSxcbiAgICAgICAgeDogYnVmZmVyXzEuQnVmZmVyLmZyb20ocmVzWzBdKSxcbiAgICB9O1xufVxuZXhwb3J0cy50d2Vha0tleSA9IHR3ZWFrS2V5O1xuZnVuY3Rpb24gdGFwQnJhbmNoSGFzaChhLCBiKSB7XG4gICAgcmV0dXJuIGJjcnlwdG8udGFnZ2VkSGFzaCgnVGFwQnJhbmNoJywgYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbYSwgYl0pKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVNjcmlwdChzKSB7XG4gICAgY29uc3QgdmFyaW50TGVuID0gYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHMubGVuZ3RoKTtcbiAgICBjb25zdCBidWZmZXIgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2NVbnNhZmUodmFyaW50TGVuKTtcbiAgICBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RlKHMubGVuZ3RoLCBidWZmZXIpO1xuICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuY29uY2F0KFtidWZmZXIsIHNdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpcDM0MS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/bip341.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/embed.js':
    /*!*********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/embed.js ***!
  \*********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.p2data = void 0;\nconst networks_1 = __webpack_require__(/*! ../networks */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js");\nconst bscript = __importStar(__webpack_require__(/*! ../script */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js"));\nconst types_1 = __webpack_require__(/*! ../types */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js");\nconst lazy = __importStar(__webpack_require__(/*! ./lazy */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js"));\nconst OPS = bscript.OPS;\nfunction stacksEqual(a, b) {\n    if (a.length !== b.length)\n        return false;\n    return a.every((x, i) => {\n        return x.equals(b[i]);\n    });\n}\nfunction p2data(a, opts) {\n    if (!a.data && !a.output)\n        throw new TypeError(\'Not enough data\');\n    opts = Object.assign({ validate: true }, opts || {});\n    (0, types_1.typeforce)({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        data: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer)),\n    }, a);\n    const network = a.network || networks_1.bitcoin;\n    const o = { name: \'embed\', network };\n    lazy.prop(o, \'output\', () => {\n        if (!a.data)\n            return;\n        return bscript.compile([OPS.OP_RETURN].concat(a.data));\n    });\n    lazy.prop(o, \'data\', () => {\n        if (!a.output)\n            return;\n        return bscript.decompile(a.output).slice(1);\n    });\n    if (opts.validate) {\n        if (a.output) {\n            const chunks = bscript.decompile(a.output);\n            if (chunks[0] !== OPS.OP_RETURN)\n                throw new TypeError(\'Output is invalid\');\n            if (!chunks.slice(1).every(types_1.typeforce.Buffer))\n                throw new TypeError(\'Output is invalid\');\n            if (a.data && !stacksEqual(a.data, o.data))\n                throw new TypeError(\'Data mismatch\');\n        }\n    }\n    return Object.assign(o, a);\n}\nexports.p2data = p2data;\n//# sourceMappingURL=embed.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9lbWJlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLG1CQUFtQixtQkFBTyxDQUFDLDhGQUFhO0FBQ3hDLDZCQUE2QixtQkFBTyxDQUFDLDBGQUFXO0FBQ2hELGdCQUFnQixtQkFBTyxDQUFDLHdGQUFVO0FBQ2xDLDBCQUEwQixtQkFBTyxDQUFDLDhGQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvcGF5bWVudHMvZW1iZWQuanM/ZWYxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMmRhdGEgPSB2b2lkIDA7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZShcIi4uL25ldHdvcmtzXCIpO1xuY29uc3QgYnNjcmlwdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vc2NyaXB0XCIpKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5jb25zdCBsYXp5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2xhenlcIikpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG5mdW5jdGlvbiBzdGFja3NFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBhLmV2ZXJ5KCh4LCBpKSA9PiB7XG4gICAgICAgIHJldHVybiB4LmVxdWFscyhiW2ldKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHAyZGF0YShhLCBvcHRzKSB7XG4gICAgaWYgKCFhLmRhdGEgJiYgIWEub3V0cHV0KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGRhdGEnKTtcbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICAgICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoe1xuICAgICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIGRhdGE6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSksXG4gICAgfSwgYSk7XG4gICAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gICAgY29uc3QgbyA9IHsgbmFtZTogJ2VtYmVkJywgbmV0d29yayB9O1xuICAgIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgICAgICBpZiAoIWEuZGF0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbT1BTLk9QX1JFVFVSTl0uY29uY2F0KGEuZGF0YSkpO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnZGF0YScsICgpID0+IHtcbiAgICAgICAgaWYgKCFhLm91dHB1dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEub3V0cHV0KS5zbGljZSgxKTtcbiAgICB9KTtcbiAgICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgICAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGJzY3JpcHQuZGVjb21waWxlKGEub3V0cHV0KTtcbiAgICAgICAgICAgIGlmIChjaHVua3NbMF0gIT09IE9QUy5PUF9SRVRVUk4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGlmICghY2h1bmtzLnNsaWNlKDEpLmV2ZXJ5KHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlcikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGlmIChhLmRhdGEgJiYgIXN0YWNrc0VxdWFsKGEuZGF0YSwgby5kYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAyZGF0YSA9IHAyZGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmVkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/embed.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js':
    /*!*********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js ***!
  \*********************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.p2tr = exports.p2wsh = exports.p2wpkh = exports.p2sh = exports.p2pkh = exports.p2pk = exports.p2ms = exports.embed = void 0;\nconst embed_1 = __webpack_require__(/*! ./embed */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/embed.js");\nObject.defineProperty(exports, "embed", ({ enumerable: true, get: function () { return embed_1.p2data; } }));\nconst p2ms_1 = __webpack_require__(/*! ./p2ms */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2ms.js");\nObject.defineProperty(exports, "p2ms", ({ enumerable: true, get: function () { return p2ms_1.p2ms; } }));\nconst p2pk_1 = __webpack_require__(/*! ./p2pk */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2pk.js");\nObject.defineProperty(exports, "p2pk", ({ enumerable: true, get: function () { return p2pk_1.p2pk; } }));\nconst p2pkh_1 = __webpack_require__(/*! ./p2pkh */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2pkh.js");\nObject.defineProperty(exports, "p2pkh", ({ enumerable: true, get: function () { return p2pkh_1.p2pkh; } }));\nconst p2sh_1 = __webpack_require__(/*! ./p2sh */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2sh.js");\nObject.defineProperty(exports, "p2sh", ({ enumerable: true, get: function () { return p2sh_1.p2sh; } }));\nconst p2wpkh_1 = __webpack_require__(/*! ./p2wpkh */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2wpkh.js");\nObject.defineProperty(exports, "p2wpkh", ({ enumerable: true, get: function () { return p2wpkh_1.p2wpkh; } }));\nconst p2wsh_1 = __webpack_require__(/*! ./p2wsh */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2wsh.js");\nObject.defineProperty(exports, "p2wsh", ({ enumerable: true, get: function () { return p2wsh_1.p2wsh; } }));\nconst p2tr_1 = __webpack_require__(/*! ./p2tr */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2tr.js");\nObject.defineProperty(exports, "p2tr", ({ enumerable: true, get: function () { return p2tr_1.p2tr; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsYUFBYTtBQUMxSCxnQkFBZ0IsbUJBQU8sQ0FBQyxnR0FBUztBQUNqQyx5Q0FBd0MsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDMUcsZUFBZSxtQkFBTyxDQUFDLDhGQUFRO0FBQy9CLHdDQUF1QyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUN0RyxlQUFlLG1CQUFPLENBQUMsOEZBQVE7QUFDL0Isd0NBQXVDLEVBQUUscUNBQXFDLHVCQUF1QixFQUFDO0FBQ3RHLGdCQUFnQixtQkFBTyxDQUFDLGdHQUFTO0FBQ2pDLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RyxlQUFlLG1CQUFPLENBQUMsOEZBQVE7QUFDL0Isd0NBQXVDLEVBQUUscUNBQXFDLHVCQUF1QixFQUFDO0FBQ3RHLGlCQUFpQixtQkFBTyxDQUFDLGtHQUFVO0FBQ25DLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1RyxnQkFBZ0IsbUJBQU8sQ0FBQyxnR0FBUztBQUNqQyx5Q0FBd0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDekcsZUFBZSxtQkFBTyxDQUFDLDhGQUFRO0FBQy9CLHdDQUF1QyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUN0RyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvcGF5bWVudHMvaW5kZXguanM/OGNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucDJ0ciA9IGV4cG9ydHMucDJ3c2ggPSBleHBvcnRzLnAyd3BraCA9IGV4cG9ydHMucDJzaCA9IGV4cG9ydHMucDJwa2ggPSBleHBvcnRzLnAycGsgPSBleHBvcnRzLnAybXMgPSBleHBvcnRzLmVtYmVkID0gdm9pZCAwO1xuY29uc3QgZW1iZWRfMSA9IHJlcXVpcmUoXCIuL2VtYmVkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW1iZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVtYmVkXzEucDJkYXRhOyB9IH0pO1xuY29uc3QgcDJtc18xID0gcmVxdWlyZShcIi4vcDJtc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInAybXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHAybXNfMS5wMm1zOyB9IH0pO1xuY29uc3QgcDJwa18xID0gcmVxdWlyZShcIi4vcDJwa1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInAycGtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHAycGtfMS5wMnBrOyB9IH0pO1xuY29uc3QgcDJwa2hfMSA9IHJlcXVpcmUoXCIuL3AycGtoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicDJwa2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHAycGtoXzEucDJwa2g7IH0gfSk7XG5jb25zdCBwMnNoXzEgPSByZXF1aXJlKFwiLi9wMnNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicDJzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcDJzaF8xLnAyc2g7IH0gfSk7XG5jb25zdCBwMndwa2hfMSA9IHJlcXVpcmUoXCIuL3Ayd3BraFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInAyd3BraFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcDJ3cGtoXzEucDJ3cGtoOyB9IH0pO1xuY29uc3QgcDJ3c2hfMSA9IHJlcXVpcmUoXCIuL3Ayd3NoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicDJ3c2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHAyd3NoXzEucDJ3c2g7IH0gfSk7XG5jb25zdCBwMnRyXzEgPSByZXF1aXJlKFwiLi9wMnRyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicDJ0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcDJ0cl8xLnAydHI7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js':
    /*!********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js ***!
  \********************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.value = exports.prop = void 0;\nfunction prop(object, name, f) {\n    Object.defineProperty(object, name, {\n        configurable: true,\n        enumerable: true,\n        get() {\n            const _value = f.call(this);\n            this[name] = _value;\n            return _value;\n        },\n        set(_value) {\n            Object.defineProperty(this, name, {\n                configurable: true,\n                enumerable: true,\n                value: _value,\n                writable: true,\n            });\n        },\n    });\n}\nexports.prop = prop;\nfunction value(f) {\n    let _value;\n    return () => {\n        if (_value !== undefined)\n            return _value;\n        _value = f();\n        return _value;\n    };\n}\nexports.value = value;\n//# sourceMappingURL=lazy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9sYXp5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9sYXp5LmpzPzU5ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbHVlID0gZXhwb3J0cy5wcm9wID0gdm9pZCAwO1xuZnVuY3Rpb24gcHJvcChvYmplY3QsIG5hbWUsIGYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgX3ZhbHVlID0gZi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfdmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IF92YWx1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy5wcm9wID0gcHJvcDtcbmZ1bmN0aW9uIHZhbHVlKGYpIHtcbiAgICBsZXQgX3ZhbHVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChfdmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgICAgIF92YWx1ZSA9IGYoKTtcbiAgICAgICAgcmV0dXJuIF92YWx1ZTtcbiAgICB9O1xufVxuZXhwb3J0cy52YWx1ZSA9IHZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2ms.js':
    /*!********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2ms.js ***!
  \********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2ms = void 0;\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\");\nconst bscript = __importStar(__webpack_require__(/*! ../script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\");\nconst lazy = __importStar(__webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js\"));\nconst OPS = bscript.OPS;\nconst OP_INT_BASE = OPS.OP_RESERVED;\nfunction stacksEqual(a, b) {\n    if (a.length !== b.length)\n        return false;\n    return a.every((x, i) => {\n        return x.equals(b[i]);\n    });\n}\nfunction p2ms(a, opts) {\n    if (!a.input &&\n        !a.output &&\n        !(a.pubkeys && a.m !== undefined) &&\n        !a.signatures)\n        throw new TypeError('Not enough data');\n    opts = Object.assign({ validate: true }, opts || {});\n    function isAcceptableSignature(x) {\n        return (bscript.isCanonicalScriptSignature(x) ||\n            (opts.allowIncomplete && x === OPS.OP_0) !== undefined);\n    }\n    (0, types_1.typeforce)({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        m: types_1.typeforce.maybe(types_1.typeforce.Number),\n        n: types_1.typeforce.maybe(types_1.typeforce.Number),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        pubkeys: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.isPoint)),\n        signatures: types_1.typeforce.maybe(types_1.typeforce.arrayOf(isAcceptableSignature)),\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    }, a);\n    const network = a.network || networks_1.bitcoin;\n    const o = { network };\n    let chunks = [];\n    let decoded = false;\n    function decode(output) {\n        if (decoded)\n            return;\n        decoded = true;\n        chunks = bscript.decompile(output);\n        o.m = chunks[0] - OP_INT_BASE;\n        o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n        o.pubkeys = chunks.slice(1, -2);\n    }\n    lazy.prop(o, 'output', () => {\n        if (!a.m)\n            return;\n        if (!o.n)\n            return;\n        if (!a.pubkeys)\n            return;\n        return bscript.compile([].concat(OP_INT_BASE + a.m, a.pubkeys, OP_INT_BASE + o.n, OPS.OP_CHECKMULTISIG));\n    });\n    lazy.prop(o, 'm', () => {\n        if (!o.output)\n            return;\n        decode(o.output);\n        return o.m;\n    });\n    lazy.prop(o, 'n', () => {\n        if (!o.pubkeys)\n            return;\n        return o.pubkeys.length;\n    });\n    lazy.prop(o, 'pubkeys', () => {\n        if (!a.output)\n            return;\n        decode(a.output);\n        return o.pubkeys;\n    });\n    lazy.prop(o, 'signatures', () => {\n        if (!a.input)\n            return;\n        return bscript.decompile(a.input).slice(1);\n    });\n    lazy.prop(o, 'input', () => {\n        if (!a.signatures)\n            return;\n        return bscript.compile([OPS.OP_0].concat(a.signatures));\n    });\n    lazy.prop(o, 'witness', () => {\n        if (!o.input)\n            return;\n        return [];\n    });\n    lazy.prop(o, 'name', () => {\n        if (!o.m || !o.n)\n            return;\n        return `p2ms(${o.m} of ${o.n})`;\n    });\n    if (opts.validate) {\n        if (a.output) {\n            decode(a.output);\n            if (!types_1.typeforce.Number(chunks[0]))\n                throw new TypeError('Output is invalid');\n            if (!types_1.typeforce.Number(chunks[chunks.length - 2]))\n                throw new TypeError('Output is invalid');\n            if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n                throw new TypeError('Output is invalid');\n            if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n                throw new TypeError('Output is invalid');\n            if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))\n                throw new TypeError('Output is invalid');\n            if (a.m !== undefined && a.m !== o.m)\n                throw new TypeError('m mismatch');\n            if (a.n !== undefined && a.n !== o.n)\n                throw new TypeError('n mismatch');\n            if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))\n                throw new TypeError('Pubkeys mismatch');\n        }\n        if (a.pubkeys) {\n            if (a.n !== undefined && a.n !== a.pubkeys.length)\n                throw new TypeError('Pubkey count mismatch');\n            o.n = a.pubkeys.length;\n            if (o.n < o.m)\n                throw new TypeError('Pubkey count cannot be less than m');\n        }\n        if (a.signatures) {\n            if (a.signatures.length < o.m)\n                throw new TypeError('Not enough signatures provided');\n            if (a.signatures.length > o.m)\n                throw new TypeError('Too many signatures provided');\n        }\n        if (a.input) {\n            if (a.input[0] !== OPS.OP_0)\n                throw new TypeError('Input is invalid');\n            if (o.signatures.length === 0 ||\n                !o.signatures.every(isAcceptableSignature))\n                throw new TypeError('Input has invalid signature(s)');\n            if (a.signatures && !stacksEqual(a.signatures, o.signatures))\n                throw new TypeError('Signature mismatch');\n            if (a.m !== undefined && a.m !== a.signatures.length)\n                throw new TypeError('Signature count mismatch');\n        }\n    }\n    return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n//# sourceMappingURL=p2ms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9wMm1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osbUJBQW1CLG1CQUFPLENBQUMsOEZBQWE7QUFDeEMsNkJBQTZCLG1CQUFPLENBQUMsMEZBQVc7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQVU7QUFDbEMsMEJBQTBCLG1CQUFPLENBQUMsOEZBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxLQUFLLElBQUk7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL3BheW1lbnRzL3AybXMuanM/NDhiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMm1zID0gdm9pZCAwO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoXCIuLi9uZXR3b3Jrc1wiKTtcbmNvbnN0IGJzY3JpcHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3NjcmlwdFwiKSk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgbGF6eSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9sYXp5XCIpKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgT1BfSU5UX0JBU0UgPSBPUFMuT1BfUkVTRVJWRUQ7XG5mdW5jdGlvbiBzdGFja3NFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBhLmV2ZXJ5KCh4LCBpKSA9PiB7XG4gICAgICAgIHJldHVybiB4LmVxdWFscyhiW2ldKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHAybXMoYSwgb3B0cykge1xuICAgIGlmICghYS5pbnB1dCAmJlxuICAgICAgICAhYS5vdXRwdXQgJiZcbiAgICAgICAgIShhLnB1YmtleXMgJiYgYS5tICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICFhLnNpZ25hdHVyZXMpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICAgZnVuY3Rpb24gaXNBY2NlcHRhYmxlU2lnbmF0dXJlKHgpIHtcbiAgICAgICAgcmV0dXJuIChic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKHgpIHx8XG4gICAgICAgICAgICAob3B0cy5hbGxvd0luY29tcGxldGUgJiYgeCA9PT0gT1BTLk9QXzApICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKHtcbiAgICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgICAgbTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKSxcbiAgICAgICAgbjogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKSxcbiAgICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICBwdWJrZXlzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEuaXNQb2ludCkpLFxuICAgICAgICBzaWduYXR1cmVzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKGlzQWNjZXB0YWJsZVNpZ25hdHVyZSkpLFxuICAgICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICB9LCBhKTtcbiAgICBjb25zdCBuZXR3b3JrID0gYS5uZXR3b3JrIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgICBjb25zdCBvID0geyBuZXR3b3JrIH07XG4gICAgbGV0IGNodW5rcyA9IFtdO1xuICAgIGxldCBkZWNvZGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gZGVjb2RlKG91dHB1dCkge1xuICAgICAgICBpZiAoZGVjb2RlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVjb2RlZCA9IHRydWU7XG4gICAgICAgIGNodW5rcyA9IGJzY3JpcHQuZGVjb21waWxlKG91dHB1dCk7XG4gICAgICAgIG8ubSA9IGNodW5rc1swXSAtIE9QX0lOVF9CQVNFO1xuICAgICAgICBvLm4gPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDJdIC0gT1BfSU5UX0JBU0U7XG4gICAgICAgIG8ucHVia2V5cyA9IGNodW5rcy5zbGljZSgxLCAtMik7XG4gICAgfVxuICAgIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgICAgICBpZiAoIWEubSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFvLm4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghYS5wdWJrZXlzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtdLmNvbmNhdChPUF9JTlRfQkFTRSArIGEubSwgYS5wdWJrZXlzLCBPUF9JTlRfQkFTRSArIG8ubiwgT1BTLk9QX0NIRUNLTVVMVElTSUcpKTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ20nLCAoKSA9PiB7XG4gICAgICAgIGlmICghby5vdXRwdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlY29kZShvLm91dHB1dCk7XG4gICAgICAgIHJldHVybiBvLm07XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICduJywgKCkgPT4ge1xuICAgICAgICBpZiAoIW8ucHVia2V5cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIG8ucHVia2V5cy5sZW5ndGg7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdwdWJrZXlzJywgKCkgPT4ge1xuICAgICAgICBpZiAoIWEub3V0cHV0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWNvZGUoYS5vdXRwdXQpO1xuICAgICAgICByZXR1cm4gby5wdWJrZXlzO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnc2lnbmF0dXJlcycsICgpID0+IHtcbiAgICAgICAgaWYgKCFhLmlucHV0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gYnNjcmlwdC5kZWNvbXBpbGUoYS5pbnB1dCkuc2xpY2UoMSk7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdpbnB1dCcsICgpID0+IHtcbiAgICAgICAgaWYgKCFhLnNpZ25hdHVyZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF8wXS5jb25jYXQoYS5zaWduYXR1cmVzKSk7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgICAgICBpZiAoIW8uaW5wdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ25hbWUnLCAoKSA9PiB7XG4gICAgICAgIGlmICghby5tIHx8ICFvLm4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBgcDJtcygke28ubX0gb2YgJHtvLm59KWA7XG4gICAgfSk7XG4gICAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICAgICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICAgICAgICBkZWNvZGUoYS5vdXRwdXQpO1xuICAgICAgICAgICAgaWYgKCF0eXBlc18xLnR5cGVmb3JjZS5OdW1iZXIoY2h1bmtzWzBdKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgaWYgKCF0eXBlc18xLnR5cGVmb3JjZS5OdW1iZXIoY2h1bmtzW2NodW5rcy5sZW5ndGggLSAyXSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGlmIChjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdICE9PSBPUFMuT1BfQ0hFQ0tNVUxUSVNJRylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgaWYgKG8ubSA8PSAwIHx8IG8ubiA+IDE2IHx8IG8ubSA+IG8ubiB8fCBvLm4gIT09IGNodW5rcy5sZW5ndGggLSAzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBpZiAoIW8ucHVia2V5cy5ldmVyeSh4ID0+ICgwLCB0eXBlc18xLmlzUG9pbnQpKHgpKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgaWYgKGEubSAhPT0gdW5kZWZpbmVkICYmIGEubSAhPT0gby5tKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ20gbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGlmIChhLm4gIT09IHVuZGVmaW5lZCAmJiBhLm4gIT09IG8ubilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduIG1pc21hdGNoJyk7XG4gICAgICAgICAgICBpZiAoYS5wdWJrZXlzICYmICFzdGFja3NFcXVhbChhLnB1YmtleXMsIG8ucHVia2V5cykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5cyBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnB1YmtleXMpIHtcbiAgICAgICAgICAgIGlmIChhLm4gIT09IHVuZGVmaW5lZCAmJiBhLm4gIT09IGEucHVia2V5cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IGNvdW50IG1pc21hdGNoJyk7XG4gICAgICAgICAgICBvLm4gPSBhLnB1YmtleXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG8ubiA8IG8ubSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgY291bnQgY2Fubm90IGJlIGxlc3MgdGhhbiBtJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuc2lnbmF0dXJlcykge1xuICAgICAgICAgICAgaWYgKGEuc2lnbmF0dXJlcy5sZW5ndGggPCBvLm0pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBzaWduYXR1cmVzIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICBpZiAoYS5zaWduYXR1cmVzLmxlbmd0aCA+IG8ubSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb28gbWFueSBzaWduYXR1cmVzIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChhLmlucHV0WzBdICE9PSBPUFMuT1BfMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBpZiAoby5zaWduYXR1cmVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICFvLnNpZ25hdHVyZXMuZXZlcnkoaXNBY2NlcHRhYmxlU2lnbmF0dXJlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBoYXMgaW52YWxpZCBzaWduYXR1cmUocyknKTtcbiAgICAgICAgICAgIGlmIChhLnNpZ25hdHVyZXMgJiYgIXN0YWNrc0VxdWFsKGEuc2lnbmF0dXJlcywgby5zaWduYXR1cmVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaWduYXR1cmUgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGlmIChhLm0gIT09IHVuZGVmaW5lZCAmJiBhLm0gIT09IGEuc2lnbmF0dXJlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIGNvdW50IG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAybXMgPSBwMm1zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cDJtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2ms.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2pk.js':
    /*!********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2pk.js ***!
  \********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2pk = void 0;\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\");\nconst bscript = __importStar(__webpack_require__(/*! ../script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\");\nconst lazy = __importStar(__webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js\"));\nconst OPS = bscript.OPS;\nfunction p2pk(a, opts) {\n    if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n        throw new TypeError('Not enough data');\n    opts = Object.assign({ validate: true }, opts || {});\n    (0, types_1.typeforce)({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        pubkey: types_1.typeforce.maybe(types_1.isPoint),\n        signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    }, a);\n    const _chunks = lazy.value(() => {\n        return bscript.decompile(a.input);\n    });\n    const network = a.network || networks_1.bitcoin;\n    const o = { name: 'p2pk', network };\n    lazy.prop(o, 'output', () => {\n        if (!a.pubkey)\n            return;\n        return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n    });\n    lazy.prop(o, 'pubkey', () => {\n        if (!a.output)\n            return;\n        return a.output.slice(1, -1);\n    });\n    lazy.prop(o, 'signature', () => {\n        if (!a.input)\n            return;\n        return _chunks()[0];\n    });\n    lazy.prop(o, 'input', () => {\n        if (!a.signature)\n            return;\n        return bscript.compile([a.signature]);\n    });\n    lazy.prop(o, 'witness', () => {\n        if (!o.input)\n            return;\n        return [];\n    });\n    if (opts.validate) {\n        if (a.output) {\n            if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n                throw new TypeError('Output is invalid');\n            if (!(0, types_1.isPoint)(o.pubkey))\n                throw new TypeError('Output pubkey is invalid');\n            if (a.pubkey && !a.pubkey.equals(o.pubkey))\n                throw new TypeError('Pubkey mismatch');\n        }\n        if (a.signature) {\n            if (a.input && !a.input.equals(o.input))\n                throw new TypeError('Signature mismatch');\n        }\n        if (a.input) {\n            if (_chunks().length !== 1)\n                throw new TypeError('Input is invalid');\n            if (!bscript.isCanonicalScriptSignature(o.signature))\n                throw new TypeError('Input has invalid signature');\n        }\n    }\n    return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n//# sourceMappingURL=p2pk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9wMnBrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osbUJBQW1CLG1CQUFPLENBQUMsOEZBQWE7QUFDeEMsNkJBQTZCLG1CQUFPLENBQUMsMEZBQVc7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQVU7QUFDbEMsMEJBQTBCLG1CQUFPLENBQUMsOEZBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL3BheW1lbnRzL3AycGsuanM/NGM4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMnBrID0gdm9pZCAwO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoXCIuLi9uZXR3b3Jrc1wiKTtcbmNvbnN0IGJzY3JpcHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3NjcmlwdFwiKSk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgbGF6eSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9sYXp5XCIpKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuZnVuY3Rpb24gcDJwayhhLCBvcHRzKSB7XG4gICAgaWYgKCFhLmlucHV0ICYmICFhLm91dHB1dCAmJiAhYS5wdWJrZXkgJiYgIWEuaW5wdXQgJiYgIWEuc2lnbmF0dXJlKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGRhdGEnKTtcbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICAgICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoe1xuICAgICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIHB1YmtleTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS5pc1BvaW50KSxcbiAgICAgICAgc2lnbmF0dXJlOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKSxcbiAgICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgfSwgYSk7XG4gICAgY29uc3QgX2NodW5rcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gYnNjcmlwdC5kZWNvbXBpbGUoYS5pbnB1dCk7XG4gICAgfSk7XG4gICAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gICAgY29uc3QgbyA9IHsgbmFtZTogJ3AycGsnLCBuZXR3b3JrIH07XG4gICAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghYS5wdWJrZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW2EucHVia2V5LCBPUFMuT1BfQ0hFQ0tTSUddKTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ3B1YmtleScsICgpID0+IHtcbiAgICAgICAgaWYgKCFhLm91dHB1dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDEsIC0xKTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ3NpZ25hdHVyZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFhLmlucHV0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gX2NodW5rcygpWzBdO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghYS5zaWduYXR1cmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW2Euc2lnbmF0dXJlXSk7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgICAgICBpZiAoIW8uaW5wdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbiAgICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgICAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgICAgICAgIGlmIChhLm91dHB1dFthLm91dHB1dC5sZW5ndGggLSAxXSAhPT0gT1BTLk9QX0NIRUNLU0lHKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBpZiAoISgwLCB0eXBlc18xLmlzUG9pbnQpKG8ucHVia2V5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgcHVia2V5IGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGlmIChhLnB1YmtleSAmJiAhYS5wdWJrZXkuZXF1YWxzKG8ucHVia2V5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgIGlmIChhLmlucHV0ICYmICFhLmlucHV0LmVxdWFscyhvLmlucHV0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaWduYXR1cmUgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgICAgICAgaWYgKF9jaHVua3MoKS5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgaWYgKCFic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKG8uc2lnbmF0dXJlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBoYXMgaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJwayA9IHAycGs7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wMnBrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2pk.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2pkh.js':
    /*!*********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2pkh.js ***!
  \*********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2pkh = void 0;\nconst bcrypto = __importStar(__webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js\"));\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\");\nconst bscript = __importStar(__webpack_require__(/*! ../script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\");\nconst lazy = __importStar(__webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js\"));\nconst OPS = bscript.OPS;\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nfunction p2pkh(a, opts) {\n    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n        throw new TypeError('Not enough data');\n    opts = Object.assign({ validate: true }, opts || {});\n    (0, types_1.typeforce)({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        address: types_1.typeforce.maybe(types_1.typeforce.String),\n        hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n        output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),\n        pubkey: types_1.typeforce.maybe(types_1.isPoint),\n        signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    }, a);\n    const _address = lazy.value(() => {\n        const payload = crypto_lib_1.base.fromBase58Check(a.address);\n        const version = payload.readUInt8(0);\n        const hash = payload.slice(1);\n        return { version, hash };\n    });\n    const _chunks = lazy.value(() => {\n        return bscript.decompile(a.input);\n    });\n    const network = a.network || networks_1.bitcoin;\n    const o = { name: 'p2pkh', network };\n    lazy.prop(o, 'address', () => {\n        if (!o.hash)\n            return;\n        const payload = Buffer.allocUnsafe(21);\n        payload.writeUInt8(network.pubKeyHash, 0);\n        o.hash.copy(payload, 1);\n        return crypto_lib_1.base.toBase58Check(payload);\n    });\n    lazy.prop(o, 'hash', () => {\n        if (a.output)\n            return a.output.slice(3, 23);\n        if (a.address)\n            return _address().hash;\n        if (a.pubkey || o.pubkey)\n            return bcrypto.hash160(a.pubkey || o.pubkey);\n    });\n    lazy.prop(o, 'output', () => {\n        if (!o.hash)\n            return;\n        return bscript.compile([\n            OPS.OP_DUP,\n            OPS.OP_HASH160,\n            o.hash,\n            OPS.OP_EQUALVERIFY,\n            OPS.OP_CHECKSIG,\n        ]);\n    });\n    lazy.prop(o, 'pubkey', () => {\n        if (!a.input)\n            return;\n        return _chunks()[1];\n    });\n    lazy.prop(o, 'signature', () => {\n        if (!a.input)\n            return;\n        return _chunks()[0];\n    });\n    lazy.prop(o, 'input', () => {\n        if (!a.pubkey)\n            return;\n        if (!a.signature)\n            return;\n        return bscript.compile([a.signature, a.pubkey]);\n    });\n    lazy.prop(o, 'witness', () => {\n        if (!o.input)\n            return;\n        return [];\n    });\n    if (opts.validate) {\n        let hash = Buffer.from([]);\n        if (a.address) {\n            if (_address().version !== network.pubKeyHash)\n                throw new TypeError('Invalid version or Network mismatch');\n            if (_address().hash.length !== 20)\n                throw new TypeError('Invalid address');\n            hash = _address().hash;\n        }\n        if (a.hash) {\n            if (hash.length > 0 && !hash.equals(a.hash))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = a.hash;\n        }\n        if (a.output) {\n            if (a.output.length !== 25 ||\n                a.output[0] !== OPS.OP_DUP ||\n                a.output[1] !== OPS.OP_HASH160 ||\n                a.output[2] !== 0x14 ||\n                a.output[23] !== OPS.OP_EQUALVERIFY ||\n                a.output[24] !== OPS.OP_CHECKSIG)\n                throw new TypeError('Output is invalid');\n            const hash2 = a.output.slice(3, 23);\n            if (hash.length > 0 && !hash.equals(hash2))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = hash2;\n        }\n        if (a.pubkey) {\n            const pkh = bcrypto.hash160(a.pubkey);\n            if (hash.length > 0 && !hash.equals(pkh))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = pkh;\n        }\n        if (a.input) {\n            const chunks = _chunks();\n            if (chunks.length !== 2)\n                throw new TypeError('Input is invalid');\n            if (!bscript.isCanonicalScriptSignature(chunks[0]))\n                throw new TypeError('Input has invalid signature');\n            if (!(0, types_1.isPoint)(chunks[1]))\n                throw new TypeError('Input has invalid pubkey');\n            if (a.signature && !a.signature.equals(chunks[0]))\n                throw new TypeError('Signature mismatch');\n            if (a.pubkey && !a.pubkey.equals(chunks[1]))\n                throw new TypeError('Pubkey mismatch');\n            const pkh = bcrypto.hash160(chunks[1]);\n            if (hash.length > 0 && !hash.equals(pkh))\n                throw new TypeError('Hash mismatch');\n        }\n    }\n    return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n//# sourceMappingURL=p2pkh.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9wMnBraC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLDZCQUE2QixtQkFBTyxDQUFDLDBGQUFXO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLDhGQUFhO0FBQ3hDLDZCQUE2QixtQkFBTyxDQUFDLDBGQUFXO0FBQ2hELGdCQUFnQixtQkFBTyxDQUFDLHdGQUFVO0FBQ2xDLDBCQUEwQixtQkFBTyxDQUFDLDhGQUFRO0FBQzFDO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvcGF5bWVudHMvcDJwa2guanM/YjUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMnBraCA9IHZvaWQgMDtcbmNvbnN0IGJjcnlwdG8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2NyeXB0b1wiKSk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZShcIi4uL25ldHdvcmtzXCIpO1xuY29uc3QgYnNjcmlwdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vc2NyaXB0XCIpKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5jb25zdCBsYXp5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2xhenlcIikpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmZ1bmN0aW9uIHAycGtoKGEsIG9wdHMpIHtcbiAgICBpZiAoIWEuYWRkcmVzcyAmJiAhYS5oYXNoICYmICFhLm91dHB1dCAmJiAhYS5wdWJrZXkgJiYgIWEuaW5wdXQpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICAgKDAsIHR5cGVzXzEudHlwZWZvcmNlKSh7XG4gICAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICAgIGFkZHJlc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLlN0cmluZyksXG4gICAgICAgIGhhc2g6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMjApKSxcbiAgICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDI1KSksXG4gICAgICAgIHB1YmtleTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS5pc1BvaW50KSxcbiAgICAgICAgc2lnbmF0dXJlOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKSxcbiAgICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgfSwgYSk7XG4gICAgY29uc3QgX2FkZHJlc3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21CYXNlNThDaGVjayhhLmFkZHJlc3MpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gcGF5bG9hZC5yZWFkVUludDgoMCk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBwYXlsb2FkLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4geyB2ZXJzaW9uLCBoYXNoIH07XG4gICAgfSk7XG4gICAgY29uc3QgX2NodW5rcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gYnNjcmlwdC5kZWNvbXBpbGUoYS5pbnB1dCk7XG4gICAgfSk7XG4gICAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gICAgY29uc3QgbyA9IHsgbmFtZTogJ3AycGtoJywgbmV0d29yayB9O1xuICAgIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICAgICAgaWYgKCFvLmhhc2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjEpO1xuICAgICAgICBwYXlsb2FkLndyaXRlVUludDgobmV0d29yay5wdWJLZXlIYXNoLCAwKTtcbiAgICAgICAgby5oYXNoLmNvcHkocGF5bG9hZCwgMSk7XG4gICAgICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS50b0Jhc2U1OENoZWNrKHBheWxvYWQpO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnaGFzaCcsICgpID0+IHtcbiAgICAgICAgaWYgKGEub3V0cHV0KVxuICAgICAgICAgICAgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDMsIDIzKTtcbiAgICAgICAgaWYgKGEuYWRkcmVzcylcbiAgICAgICAgICAgIHJldHVybiBfYWRkcmVzcygpLmhhc2g7XG4gICAgICAgIGlmIChhLnB1YmtleSB8fCBvLnB1YmtleSlcbiAgICAgICAgICAgIHJldHVybiBiY3J5cHRvLmhhc2gxNjAoYS5wdWJrZXkgfHwgby5wdWJrZXkpO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgICAgICBpZiAoIW8uaGFzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbXG4gICAgICAgICAgICBPUFMuT1BfRFVQLFxuICAgICAgICAgICAgT1BTLk9QX0hBU0gxNjAsXG4gICAgICAgICAgICBvLmhhc2gsXG4gICAgICAgICAgICBPUFMuT1BfRVFVQUxWRVJJRlksXG4gICAgICAgICAgICBPUFMuT1BfQ0hFQ0tTSUcsXG4gICAgICAgIF0pO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAncHVia2V5JywgKCkgPT4ge1xuICAgICAgICBpZiAoIWEuaW5wdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBfY2h1bmtzKClbMV07XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgICAgIGlmICghYS5pbnB1dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIF9jaHVua3MoKVswXTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICBpZiAoIWEucHVia2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWEuc2lnbmF0dXJlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFthLnNpZ25hdHVyZSwgYS5wdWJrZXldKTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgICAgIGlmICghby5pbnB1dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xuICAgIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgICAgIGxldCBoYXNoID0gQnVmZmVyLmZyb20oW10pO1xuICAgICAgICBpZiAoYS5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoX2FkZHJlc3MoKS52ZXJzaW9uICE9PSBuZXR3b3JrLnB1YktleUhhc2gpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2ZXJzaW9uIG9yIE5ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGlmIChfYWRkcmVzcygpLmhhc2gubGVuZ3RoICE9PSAyMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgICAgIGhhc2ggPSBfYWRkcmVzcygpLmhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuaGFzaCkge1xuICAgICAgICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoYS5oYXNoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaGFzaCA9IGEuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgICAgICAgIGlmIChhLm91dHB1dC5sZW5ndGggIT09IDI1IHx8XG4gICAgICAgICAgICAgICAgYS5vdXRwdXRbMF0gIT09IE9QUy5PUF9EVVAgfHxcbiAgICAgICAgICAgICAgICBhLm91dHB1dFsxXSAhPT0gT1BTLk9QX0hBU0gxNjAgfHxcbiAgICAgICAgICAgICAgICBhLm91dHB1dFsyXSAhPT0gMHgxNCB8fFxuICAgICAgICAgICAgICAgIGEub3V0cHV0WzIzXSAhPT0gT1BTLk9QX0VRVUFMVkVSSUZZIHx8XG4gICAgICAgICAgICAgICAgYS5vdXRwdXRbMjRdICE9PSBPUFMuT1BfQ0hFQ0tTSUcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2gyID0gYS5vdXRwdXQuc2xpY2UoMywgMjMpO1xuICAgICAgICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoaGFzaDIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoYXNoID0gaGFzaDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEucHVia2V5KSB7XG4gICAgICAgICAgICBjb25zdCBwa2ggPSBiY3J5cHRvLmhhc2gxNjAoYS5wdWJrZXkpO1xuICAgICAgICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMocGtoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaGFzaCA9IHBraDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gX2NodW5rcygpO1xuICAgICAgICAgICAgaWYgKGNodW5rcy5sZW5ndGggIT09IDIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgaWYgKCFic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGNodW5rc1swXSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaGFzIGludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICAgICAgICBpZiAoISgwLCB0eXBlc18xLmlzUG9pbnQpKGNodW5rc1sxXSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaGFzIGludmFsaWQgcHVia2V5Jyk7XG4gICAgICAgICAgICBpZiAoYS5zaWduYXR1cmUgJiYgIWEuc2lnbmF0dXJlLmVxdWFscyhjaHVua3NbMF0pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpZ25hdHVyZSBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgaWYgKGEucHVia2V5ICYmICFhLnB1YmtleS5lcXVhbHMoY2h1bmtzWzFdKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChjaHVua3NbMV0pO1xuICAgICAgICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMocGtoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAycGtoID0gcDJwa2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wMnBraC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2pkh.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2sh.js':
    /*!********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2sh.js ***!
  \********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2sh = void 0;\nconst bcrypto = __importStar(__webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js\"));\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\");\nconst bscript = __importStar(__webpack_require__(/*! ../script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\");\nconst lazy = __importStar(__webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js\"));\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nconst OPS = bscript.OPS;\nfunction stacksEqual(a, b) {\n    if (a.length !== b.length)\n        return false;\n    return a.every((x, i) => {\n        return x.equals(b[i]);\n    });\n}\nfunction p2sh(a, opts) {\n    if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n        throw new TypeError('Not enough data');\n    opts = Object.assign({ validate: true }, opts || {});\n    (0, types_1.typeforce)({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        address: types_1.typeforce.maybe(types_1.typeforce.String),\n        hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n        output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),\n        redeem: types_1.typeforce.maybe({\n            network: types_1.typeforce.maybe(types_1.typeforce.Object),\n            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n            witness: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer)),\n        }),\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer)),\n    }, a);\n    let network = a.network;\n    if (!network) {\n        network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n    }\n    const o = { network };\n    const _address = lazy.value(() => {\n        const payload = crypto_lib_1.base.fromBase58Check(a.address);\n        const version = payload.readUInt8(0);\n        const hash = payload.slice(1);\n        return { version, hash };\n    });\n    const _chunks = lazy.value(() => {\n        return bscript.decompile(a.input);\n    });\n    const _redeem = lazy.value(() => {\n        const chunks = _chunks();\n        return {\n            network,\n            output: chunks[chunks.length - 1],\n            input: bscript.compile(chunks.slice(0, -1)),\n            witness: a.witness || [],\n        };\n    });\n    lazy.prop(o, 'address', () => {\n        if (!o.hash)\n            return;\n        const payload = Buffer.allocUnsafe(21);\n        payload.writeUInt8(o.network.scriptHash, 0);\n        o.hash.copy(payload, 1);\n        return crypto_lib_1.base.toBase58Check(payload);\n    });\n    lazy.prop(o, 'hash', () => {\n        if (a.output)\n            return a.output.slice(2, 22);\n        if (a.address)\n            return _address().hash;\n        if (o.redeem && o.redeem.output)\n            return bcrypto.hash160(o.redeem.output);\n    });\n    lazy.prop(o, 'output', () => {\n        if (!o.hash)\n            return;\n        return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n    });\n    lazy.prop(o, 'redeem', () => {\n        if (!a.input)\n            return;\n        return _redeem();\n    });\n    lazy.prop(o, 'input', () => {\n        if (!a.redeem || !a.redeem.input || !a.redeem.output)\n            return;\n        return bscript.compile([].concat(bscript.decompile(a.redeem.input), a.redeem.output));\n    });\n    lazy.prop(o, 'witness', () => {\n        if (o.redeem && o.redeem.witness)\n            return o.redeem.witness;\n        if (o.input)\n            return [];\n    });\n    lazy.prop(o, 'name', () => {\n        const nameParts = ['p2sh'];\n        if (o.redeem !== undefined && o.redeem.name !== undefined)\n            nameParts.push(o.redeem.name);\n        return nameParts.join('-');\n    });\n    if (opts.validate) {\n        let hash = Buffer.from([]);\n        if (a.address) {\n            if (_address().version !== network.scriptHash)\n                throw new TypeError('Invalid version or Network mismatch');\n            if (_address().hash.length !== 20)\n                throw new TypeError('Invalid address');\n            hash = _address().hash;\n        }\n        if (a.hash) {\n            if (hash.length > 0 && !hash.equals(a.hash))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = a.hash;\n        }\n        if (a.output) {\n            if (a.output.length !== 23 ||\n                a.output[0] !== OPS.OP_HASH160 ||\n                a.output[1] !== 0x14 ||\n                a.output[22] !== OPS.OP_EQUAL)\n                throw new TypeError('Output is invalid');\n            const hash2 = a.output.slice(2, 22);\n            if (hash.length > 0 && !hash.equals(hash2))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = hash2;\n        }\n        const checkRedeem = (redeem) => {\n            if (redeem.output) {\n                const decompile = bscript.decompile(redeem.output);\n                if (!decompile || decompile.length < 1)\n                    throw new TypeError('Redeem.output too short');\n                const hash2 = bcrypto.hash160(redeem.output);\n                if (hash.length > 0 && !hash.equals(hash2))\n                    throw new TypeError('Hash mismatch');\n                else\n                    hash = hash2;\n            }\n            if (redeem.input) {\n                const hasInput = redeem.input.length > 0;\n                const hasWitness = redeem.witness && redeem.witness.length > 0;\n                if (!hasInput && !hasWitness)\n                    throw new TypeError('Empty input');\n                if (hasInput && hasWitness)\n                    throw new TypeError('Input and witness provided');\n                if (hasInput) {\n                    const richunks = bscript.decompile(redeem.input);\n                    if (!bscript.isPushOnly(richunks))\n                        throw new TypeError('Non push-only scriptSig');\n                }\n            }\n        };\n        if (a.input) {\n            const chunks = _chunks();\n            if (!chunks || chunks.length < 1)\n                throw new TypeError('Input too short');\n            if (!Buffer.isBuffer(_redeem().output))\n                throw new TypeError('Input is invalid');\n            checkRedeem(_redeem());\n        }\n        if (a.redeem) {\n            if (a.redeem.network && a.redeem.network !== network)\n                throw new TypeError('Network mismatch');\n            if (a.input) {\n                const redeem = _redeem();\n                if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n                    throw new TypeError('Redeem.output mismatch');\n                if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n                    throw new TypeError('Redeem.input mismatch');\n            }\n            checkRedeem(a.redeem);\n        }\n        if (a.witness) {\n            if (a.redeem &&\n                a.redeem.witness &&\n                !stacksEqual(a.redeem.witness, a.witness))\n                throw new TypeError('Witness and redeem.witness mismatch');\n        }\n    }\n    return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n//# sourceMappingURL=p2sh.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9wMnNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osNkJBQTZCLG1CQUFPLENBQUMsMEZBQVc7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsOEZBQWE7QUFDeEMsNkJBQTZCLG1CQUFPLENBQUMsMEZBQVc7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQVU7QUFDbEMsMEJBQTBCLG1CQUFPLENBQUMsOEZBQVE7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvcGF5bWVudHMvcDJzaC5qcz8xMmI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAyc2ggPSB2b2lkIDA7XG5jb25zdCBiY3J5cHRvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jcnlwdG9cIikpO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoXCIuLi9uZXR3b3Jrc1wiKTtcbmNvbnN0IGJzY3JpcHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3NjcmlwdFwiKSk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgbGF6eSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9sYXp5XCIpKTtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG5mdW5jdGlvbiBzdGFja3NFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBhLmV2ZXJ5KCh4LCBpKSA9PiB7XG4gICAgICAgIHJldHVybiB4LmVxdWFscyhiW2ldKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHAyc2goYSwgb3B0cykge1xuICAgIGlmICghYS5hZGRyZXNzICYmICFhLmhhc2ggJiYgIWEub3V0cHV0ICYmICFhLnJlZGVlbSAmJiAhYS5pbnB1dClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKHtcbiAgICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgICAgYWRkcmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuU3RyaW5nKSxcbiAgICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigyMCkpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMjMpKSxcbiAgICAgICAgcmVkZWVtOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlcikpLFxuICAgICAgICB9KSxcbiAgICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIHdpdG5lc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSksXG4gICAgfSwgYSk7XG4gICAgbGV0IG5ldHdvcmsgPSBhLm5ldHdvcms7XG4gICAgaWYgKCFuZXR3b3JrKSB7XG4gICAgICAgIG5ldHdvcmsgPSAoYS5yZWRlZW0gJiYgYS5yZWRlZW0ubmV0d29yaykgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICAgIH1cbiAgICBjb25zdCBvID0geyBuZXR3b3JrIH07XG4gICAgY29uc3QgX2FkZHJlc3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21CYXNlNThDaGVjayhhLmFkZHJlc3MpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gcGF5bG9hZC5yZWFkVUludDgoMCk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBwYXlsb2FkLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4geyB2ZXJzaW9uLCBoYXNoIH07XG4gICAgfSk7XG4gICAgY29uc3QgX2NodW5rcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gYnNjcmlwdC5kZWNvbXBpbGUoYS5pbnB1dCk7XG4gICAgfSk7XG4gICAgY29uc3QgX3JlZGVlbSA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgICAgICBjb25zdCBjaHVua3MgPSBfY2h1bmtzKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXR3b3JrLFxuICAgICAgICAgICAgb3V0cHV0OiBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgaW5wdXQ6IGJzY3JpcHQuY29tcGlsZShjaHVua3Muc2xpY2UoMCwgLTEpKSxcbiAgICAgICAgICAgIHdpdG5lc3M6IGEud2l0bmVzcyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ2FkZHJlc3MnLCAoKSA9PiB7XG4gICAgICAgIGlmICghby5oYXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIxKTtcbiAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KG8ubmV0d29yay5zY3JpcHRIYXNoLCAwKTtcbiAgICAgICAgby5oYXNoLmNvcHkocGF5bG9hZCwgMSk7XG4gICAgICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS50b0Jhc2U1OENoZWNrKHBheWxvYWQpO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnaGFzaCcsICgpID0+IHtcbiAgICAgICAgaWYgKGEub3V0cHV0KVxuICAgICAgICAgICAgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDIsIDIyKTtcbiAgICAgICAgaWYgKGEuYWRkcmVzcylcbiAgICAgICAgICAgIHJldHVybiBfYWRkcmVzcygpLmhhc2g7XG4gICAgICAgIGlmIChvLnJlZGVlbSAmJiBvLnJlZGVlbS5vdXRwdXQpXG4gICAgICAgICAgICByZXR1cm4gYmNyeXB0by5oYXNoMTYwKG8ucmVkZWVtLm91dHB1dCk7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghby5oYXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfSEFTSDE2MCwgby5oYXNoLCBPUFMuT1BfRVFVQUxdKTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ3JlZGVlbScsICgpID0+IHtcbiAgICAgICAgaWYgKCFhLmlucHV0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gX3JlZGVlbSgpO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghYS5yZWRlZW0gfHwgIWEucmVkZWVtLmlucHV0IHx8ICFhLnJlZGVlbS5vdXRwdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW10uY29uY2F0KGJzY3JpcHQuZGVjb21waWxlKGEucmVkZWVtLmlucHV0KSwgYS5yZWRlZW0ub3V0cHV0KSk7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgICAgICBpZiAoby5yZWRlZW0gJiYgby5yZWRlZW0ud2l0bmVzcylcbiAgICAgICAgICAgIHJldHVybiBvLnJlZGVlbS53aXRuZXNzO1xuICAgICAgICBpZiAoby5pbnB1dClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ25hbWUnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWVQYXJ0cyA9IFsncDJzaCddO1xuICAgICAgICBpZiAoby5yZWRlZW0gIT09IHVuZGVmaW5lZCAmJiBvLnJlZGVlbS5uYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBuYW1lUGFydHMucHVzaChvLnJlZGVlbS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWVQYXJ0cy5qb2luKCctJyk7XG4gICAgfSk7XG4gICAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICAgICAgbGV0IGhhc2ggPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmIChfYWRkcmVzcygpLnZlcnNpb24gIT09IG5ldHdvcmsuc2NyaXB0SGFzaClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHZlcnNpb24gb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgaWYgKF9hZGRyZXNzKCkuaGFzaC5sZW5ndGggIT09IDIwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICAgICAgaGFzaCA9IF9hZGRyZXNzKCkuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5oYXNoKSB7XG4gICAgICAgICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLmhhc2gpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoYXNoID0gYS5oYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgICAgICAgaWYgKGEub3V0cHV0Lmxlbmd0aCAhPT0gMjMgfHxcbiAgICAgICAgICAgICAgICBhLm91dHB1dFswXSAhPT0gT1BTLk9QX0hBU0gxNjAgfHxcbiAgICAgICAgICAgICAgICBhLm91dHB1dFsxXSAhPT0gMHgxNCB8fFxuICAgICAgICAgICAgICAgIGEub3V0cHV0WzIyXSAhPT0gT1BTLk9QX0VRVUFMKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBoYXNoMiA9IGEub3V0cHV0LnNsaWNlKDIsIDIyKTtcbiAgICAgICAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGhhc2gyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaGFzaCA9IGhhc2gyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrUmVkZWVtID0gKHJlZGVlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlZGVlbS5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvbXBpbGUgPSBic2NyaXB0LmRlY29tcGlsZShyZWRlZW0ub3V0cHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlY29tcGlsZSB8fCBkZWNvbXBpbGUubGVuZ3RoIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLm91dHB1dCB0b28gc2hvcnQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoMiA9IGJjcnlwdG8uaGFzaDE2MChyZWRlZW0ub3V0cHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWRlZW0uaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNJbnB1dCA9IHJlZGVlbS5pbnB1dC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1dpdG5lc3MgPSByZWRlZW0ud2l0bmVzcyAmJiByZWRlZW0ud2l0bmVzcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGlmICghaGFzSW5wdXQgJiYgIWhhc1dpdG5lc3MpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VtcHR5IGlucHV0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0lucHV0ICYmIGhhc1dpdG5lc3MpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGFuZCB3aXRuZXNzIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUocmVkZWVtLmlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFic2NyaXB0LmlzUHVzaE9ubHkocmljaHVua3MpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9uIHB1c2gtb25seSBzY3JpcHRTaWcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhLmlucHV0KSB7XG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSBfY2h1bmtzKCk7XG4gICAgICAgICAgICBpZiAoIWNodW5rcyB8fCBjaHVua3MubGVuZ3RoIDwgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCB0b28gc2hvcnQnKTtcbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKF9yZWRlZW0oKS5vdXRwdXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNoZWNrUmVkZWVtKF9yZWRlZW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEucmVkZWVtKSB7XG4gICAgICAgICAgICBpZiAoYS5yZWRlZW0ubmV0d29yayAmJiBhLnJlZGVlbS5uZXR3b3JrICE9PSBuZXR3b3JrKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGlmIChhLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVkZWVtID0gX3JlZGVlbSgpO1xuICAgICAgICAgICAgICAgIGlmIChhLnJlZGVlbS5vdXRwdXQgJiYgIWEucmVkZWVtLm91dHB1dC5lcXVhbHMocmVkZWVtLm91dHB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgICAgICBpZiAoYS5yZWRlZW0uaW5wdXQgJiYgIWEucmVkZWVtLmlucHV0LmVxdWFscyhyZWRlZW0uaW5wdXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0uaW5wdXQgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrUmVkZWVtKGEucmVkZWVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS53aXRuZXNzKSB7XG4gICAgICAgICAgICBpZiAoYS5yZWRlZW0gJiZcbiAgICAgICAgICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICAgICAgICAgIXN0YWNrc0VxdWFsKGEucmVkZWVtLndpdG5lc3MsIGEud2l0bmVzcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBhbmQgcmVkZWVtLndpdG5lc3MgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJzaCA9IHAyc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wMnNoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2sh.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2tr.js':
    /*!********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2tr.js ***!
  \********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2tr = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\");\nconst bscript = __importStar(__webpack_require__(/*! ../script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\");\nconst bip341_1 = __webpack_require__(/*! ./bip341 */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/bip341.js\");\nconst lazy = __importStar(__webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js\"));\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\nfunction p2tr(a, opts) {\n    if (!a.address &&\n        !a.output &&\n        !a.pubkey &&\n        !a.internalPubkey &&\n        !(a.witness && a.witness.length > 1))\n        throw new TypeError('Not enough data');\n    opts = Object.assign({ validate: true }, opts || {});\n    (0, types_1.typeforce)({\n        address: types_1.typeforce.maybe(types_1.typeforce.String),\n        input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n        internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n        hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n        pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n        witness: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer)),\n        scriptTree: types_1.typeforce.maybe(types_1.isTaptree),\n        redeem: types_1.typeforce.maybe({\n            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n            redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n            witness: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer)),\n        }),\n        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n    }, a);\n    const _address = lazy.value(() => {\n        const result = crypto_lib_1.base.bech32m.decode(a.address);\n        const version = result.words.shift();\n        const data = crypto_lib_1.base.bech32m.fromWords(result.words);\n        return {\n            version,\n            prefix: result.prefix,\n            data: buffer_1.Buffer.from(data),\n        };\n    });\n    const _witness = lazy.value(() => {\n        if (!a.witness || !a.witness.length)\n            return;\n        if (a.witness.length >= 2 &&\n            a.witness[a.witness.length - 1][0] === ANNEX_PREFIX) {\n            return a.witness.slice(0, -1);\n        }\n        return a.witness.slice();\n    });\n    const _hashTree = lazy.value(() => {\n        if (a.scriptTree)\n            return (0, bip341_1.toHashTree)(a.scriptTree);\n        if (a.hash)\n            return { hash: a.hash };\n        return;\n    });\n    const network = a.network || networks_1.bitcoin;\n    const o = { name: 'p2tr', network };\n    lazy.prop(o, 'address', () => {\n        if (!o.pubkey)\n            return;\n        const words = crypto_lib_1.base.bech32m.toWords(o.pubkey);\n        words.unshift(TAPROOT_WITNESS_VERSION);\n        return crypto_lib_1.base.bech32m.encode(network.bech32, words);\n    });\n    lazy.prop(o, 'hash', () => {\n        const hashTree = _hashTree();\n        if (hashTree)\n            return hashTree.hash;\n        const w = _witness();\n        if (w && w.length > 1) {\n            const controlBlock = w[w.length - 1];\n            const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n            const script = w[w.length - 2];\n            const leafHash = (0, bip341_1.tapleafHash)({ output: script, version: leafVersion });\n            return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n        }\n        return null;\n    });\n    lazy.prop(o, 'output', () => {\n        if (!o.pubkey)\n            return;\n        return bscript.compile([OPS.OP_1, o.pubkey]);\n    });\n    lazy.prop(o, 'redeemVersion', () => {\n        if (a.redeemVersion)\n            return a.redeemVersion;\n        if (a.redeem &&\n            a.redeem.redeemVersion !== undefined &&\n            a.redeem.redeemVersion !== null) {\n            return a.redeem.redeemVersion;\n        }\n        return bip341_1.LEAF_VERSION_TAPSCRIPT;\n    });\n    lazy.prop(o, 'redeem', () => {\n        const witness = _witness();\n        if (!witness || witness.length < 2)\n            return;\n        return {\n            output: witness[witness.length - 2],\n            witness: witness.slice(0, -2),\n            redeemVersion: witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,\n        };\n    });\n    lazy.prop(o, 'pubkey', () => {\n        if (a.pubkey)\n            return a.pubkey;\n        if (a.output)\n            return a.output.slice(2);\n        if (a.address)\n            return _address().data;\n        if (o.internalPubkey) {\n            const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);\n            if (tweakedKey)\n                return tweakedKey.x;\n        }\n    });\n    lazy.prop(o, 'internalPubkey', () => {\n        if (a.internalPubkey)\n            return a.internalPubkey;\n        const witness = _witness();\n        if (witness && witness.length > 1)\n            return witness[witness.length - 1].slice(1, 33);\n    });\n    lazy.prop(o, 'signature', () => {\n        if (a.signature)\n            return a.signature;\n        const witness = _witness();\n        if (!witness || witness.length !== 1)\n            return;\n        return witness[0];\n    });\n    lazy.prop(o, 'witness', () => {\n        if (a.witness)\n            return a.witness;\n        const hashTree = _hashTree();\n        if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n            const leafHash = (0, bip341_1.tapleafHash)({\n                output: a.redeem.output,\n                version: o.redeemVersion,\n            });\n            const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);\n            if (!path)\n                return;\n            const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);\n            if (!outputKey)\n                return;\n            const controlBock = buffer_1.Buffer.concat([\n                buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),\n                a.internalPubkey,\n            ].concat(path));\n            return [a.redeem.output, controlBock];\n        }\n        if (a.signature)\n            return [a.signature];\n    });\n    if (opts.validate) {\n        let pubkey = buffer_1.Buffer.from([]);\n        if (a.address) {\n            if (network && network.bech32 !== _address().prefix)\n                throw new TypeError('Invalid prefix or Network mismatch');\n            if (_address().version !== TAPROOT_WITNESS_VERSION)\n                throw new TypeError('Invalid address version');\n            if (_address().data.length !== 32)\n                throw new TypeError('Invalid address data');\n            pubkey = _address().data;\n        }\n        if (a.pubkey) {\n            if (pubkey.length > 0 && !pubkey.equals(a.pubkey))\n                throw new TypeError('Pubkey mismatch');\n            else\n                pubkey = a.pubkey;\n        }\n        if (a.output) {\n            if (a.output.length !== 34 ||\n                a.output[0] !== OPS.OP_1 ||\n                a.output[1] !== 0x20)\n                throw new TypeError('Output is invalid');\n            if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))\n                throw new TypeError('Pubkey mismatch');\n            else\n                pubkey = a.output.slice(2);\n        }\n        if (a.internalPubkey) {\n            const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);\n            if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))\n                throw new TypeError('Pubkey mismatch');\n            else\n                pubkey = tweakedKey.x;\n        }\n        if (pubkey && pubkey.length) {\n            if (pubkey.length !== 32)\n                throw new TypeError('Invalid pubkey for p2tr');\n        }\n        const hashTree = _hashTree();\n        if (a.hash && hashTree) {\n            if (!a.hash.equals(hashTree.hash))\n                throw new TypeError('Hash mismatch');\n        }\n        if (a.redeem && a.redeem.output && hashTree) {\n            const leafHash = (0, bip341_1.tapleafHash)({\n                output: a.redeem.output,\n                version: o.redeemVersion,\n            });\n            if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))\n                throw new TypeError('Redeem script not in tree');\n        }\n        const witness = _witness();\n        if (a.redeem && o.redeem) {\n            if (a.redeem.redeemVersion) {\n                if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n                    throw new TypeError('Redeem.redeemVersion and witness mismatch');\n            }\n            if (a.redeem.output) {\n                if (bscript.decompile(a.redeem.output).length === 0)\n                    throw new TypeError('Redeem.output is invalid');\n                if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))\n                    throw new TypeError('Redeem.output and witness mismatch');\n            }\n            if (a.redeem.witness) {\n                if (o.redeem.witness &&\n                    !stacksEqual(a.redeem.witness, o.redeem.witness))\n                    throw new TypeError('Redeem.witness and witness mismatch');\n            }\n        }\n        if (witness && witness.length) {\n            if (witness.length === 1) {\n                if (a.signature && !a.signature.equals(witness[0]))\n                    throw new TypeError('Signature mismatch');\n            }\n            else {\n                const controlBlock = witness[witness.length - 1];\n                if (controlBlock.length < 33)\n                    throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 33.`);\n                if ((controlBlock.length - 33) % 32 !== 0)\n                    throw new TypeError(`The control-block length of ${controlBlock.length} is incorrect!`);\n                const m = (controlBlock.length - 33) / 32;\n                if (m > 128)\n                    throw new TypeError(`The script path is too long. Got ${m}, expected max 128.`);\n                const internalPubkey = controlBlock.slice(1, 33);\n                if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))\n                    throw new TypeError('Internal pubkey mismatch');\n                if (internalPubkey.length !== 32)\n                    throw new TypeError('Invalid internalPubkey for p2tr witness');\n                const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n                const script = witness[witness.length - 2];\n                const leafHash = (0, bip341_1.tapleafHash)({ output: script, version: leafVersion });\n                const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n                const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);\n                if (!outputKey)\n                    throw new TypeError('Invalid outputKey for p2tr witness');\n                if (pubkey.length && !pubkey.equals(outputKey.x))\n                    throw new TypeError('Pubkey mismatch for p2tr witness');\n                if (outputKey.parity !== (controlBlock[0] & 1))\n                    throw new Error('Incorrect parity');\n            }\n        }\n    }\n    return Object.assign(o, a);\n}\nexports.p2tr = p2tr;\nfunction stacksEqual(a, b) {\n    if (a.length !== b.length)\n        return false;\n    return a.every((x, i) => {\n        return x.equals(b[i]);\n    });\n}\n//# sourceMappingURL=p2tr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9wMnRyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsOEZBQWE7QUFDeEMsNkJBQTZCLG1CQUFPLENBQUMsMEZBQVc7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQVU7QUFDbEMsaUJBQWlCLG1CQUFPLENBQUMsa0dBQVU7QUFDbkMsMEJBQTBCLG1CQUFPLENBQUMsOEZBQVE7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQixZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzQ0FBc0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLG9CQUFvQjtBQUMxRztBQUNBLHVFQUF1RSxxQkFBcUI7QUFDNUY7QUFDQTtBQUNBLDRFQUE0RSxFQUFFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHNDQUFzQztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL3BheW1lbnRzL3AydHIuanM/OTBjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMnRyID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoXCIuLi9uZXR3b3Jrc1wiKTtcbmNvbnN0IGJzY3JpcHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3NjcmlwdFwiKSk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgYmlwMzQxXzEgPSByZXF1aXJlKFwiLi9iaXAzNDFcIik7XG5jb25zdCBsYXp5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2xhenlcIikpO1xuY29uc3QgY3J5cHRvX2xpYl8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NyeXB0by1saWJcIik7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmNvbnN0IFRBUFJPT1RfV0lUTkVTU19WRVJTSU9OID0gMHgwMTtcbmNvbnN0IEFOTkVYX1BSRUZJWCA9IDB4NTA7XG5mdW5jdGlvbiBwMnRyKGEsIG9wdHMpIHtcbiAgICBpZiAoIWEuYWRkcmVzcyAmJlxuICAgICAgICAhYS5vdXRwdXQgJiZcbiAgICAgICAgIWEucHVia2V5ICYmXG4gICAgICAgICFhLmludGVybmFsUHVia2V5ICYmXG4gICAgICAgICEoYS53aXRuZXNzICYmIGEud2l0bmVzcy5sZW5ndGggPiAxKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKHtcbiAgICAgICAgYWRkcmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuU3RyaW5nKSxcbiAgICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMCkpLFxuICAgICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMzQpKSxcbiAgICAgICAgaW50ZXJuYWxQdWJrZXk6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMzIpKSxcbiAgICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigzMikpLFxuICAgICAgICBwdWJrZXk6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMzIpKSxcbiAgICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpKSxcbiAgICAgICAgc2NyaXB0VHJlZTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS5pc1RhcHRyZWUpLFxuICAgICAgICByZWRlZW06IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHtcbiAgICAgICAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICAgICAgIHJlZGVlbVZlcnNpb246IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk51bWJlciksXG4gICAgICAgICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlcikpLFxuICAgICAgICB9KSxcbiAgICAgICAgcmVkZWVtVmVyc2lvbjogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKSxcbiAgICB9LCBhKTtcbiAgICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjcnlwdG9fbGliXzEuYmFzZS5iZWNoMzJtLmRlY29kZShhLmFkZHJlc3MpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gcmVzdWx0LndvcmRzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjcnlwdG9fbGliXzEuYmFzZS5iZWNoMzJtLmZyb21Xb3JkcyhyZXN1bHQud29yZHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIHByZWZpeDogcmVzdWx0LnByZWZpeCxcbiAgICAgICAgICAgIGRhdGE6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IF93aXRuZXNzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgICAgIGlmICghYS53aXRuZXNzIHx8ICFhLndpdG5lc3MubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoYS53aXRuZXNzLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgICBhLndpdG5lc3NbYS53aXRuZXNzLmxlbmd0aCAtIDFdWzBdID09PSBBTk5FWF9QUkVGSVgpIHtcbiAgICAgICAgICAgIHJldHVybiBhLndpdG5lc3Muc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLndpdG5lc3Muc2xpY2UoKTtcbiAgICB9KTtcbiAgICBjb25zdCBfaGFzaFRyZWUgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICAgICAgaWYgKGEuc2NyaXB0VHJlZSlcbiAgICAgICAgICAgIHJldHVybiAoMCwgYmlwMzQxXzEudG9IYXNoVHJlZSkoYS5zY3JpcHRUcmVlKTtcbiAgICAgICAgaWYgKGEuaGFzaClcbiAgICAgICAgICAgIHJldHVybiB7IGhhc2g6IGEuaGFzaCB9O1xuICAgICAgICByZXR1cm47XG4gICAgfSk7XG4gICAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gICAgY29uc3QgbyA9IHsgbmFtZTogJ3AydHInLCBuZXR3b3JrIH07XG4gICAgbGF6eS5wcm9wKG8sICdhZGRyZXNzJywgKCkgPT4ge1xuICAgICAgICBpZiAoIW8ucHVia2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB3b3JkcyA9IGNyeXB0b19saWJfMS5iYXNlLmJlY2gzMm0udG9Xb3JkcyhvLnB1YmtleSk7XG4gICAgICAgIHdvcmRzLnVuc2hpZnQoVEFQUk9PVF9XSVRORVNTX1ZFUlNJT04pO1xuICAgICAgICByZXR1cm4gY3J5cHRvX2xpYl8xLmJhc2UuYmVjaDMybS5lbmNvZGUobmV0d29yay5iZWNoMzIsIHdvcmRzKTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hUcmVlID0gX2hhc2hUcmVlKCk7XG4gICAgICAgIGlmIChoYXNoVHJlZSlcbiAgICAgICAgICAgIHJldHVybiBoYXNoVHJlZS5oYXNoO1xuICAgICAgICBjb25zdCB3ID0gX3dpdG5lc3MoKTtcbiAgICAgICAgaWYgKHcgJiYgdy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sQmxvY2sgPSB3W3cubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBsZWFmVmVyc2lvbiA9IGNvbnRyb2xCbG9ja1swXSAmIHR5cGVzXzEuVEFQTEVBRl9WRVJTSU9OX01BU0s7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSB3W3cubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoeyBvdXRwdXQ6IHNjcmlwdCwgdmVyc2lvbjogbGVhZlZlcnNpb24gfSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJpcDM0MV8xLnJvb3RIYXNoRnJvbVBhdGgpKGNvbnRyb2xCbG9jaywgbGVhZkhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgICAgICBpZiAoIW8ucHVia2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfMSwgby5wdWJrZXldKTtcbiAgICB9KTtcbiAgICBsYXp5LnByb3AobywgJ3JlZGVlbVZlcnNpb24nLCAoKSA9PiB7XG4gICAgICAgIGlmIChhLnJlZGVlbVZlcnNpb24pXG4gICAgICAgICAgICByZXR1cm4gYS5yZWRlZW1WZXJzaW9uO1xuICAgICAgICBpZiAoYS5yZWRlZW0gJiZcbiAgICAgICAgICAgIGEucmVkZWVtLnJlZGVlbVZlcnNpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgYS5yZWRlZW0ucmVkZWVtVmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGEucmVkZWVtLnJlZGVlbVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpcDM0MV8xLkxFQUZfVkVSU0lPTl9UQVBTQ1JJUFQ7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdyZWRlZW0nLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpdG5lc3MgPSBfd2l0bmVzcygpO1xuICAgICAgICBpZiAoIXdpdG5lc3MgfHwgd2l0bmVzcy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3V0cHV0OiB3aXRuZXNzW3dpdG5lc3MubGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICB3aXRuZXNzOiB3aXRuZXNzLnNsaWNlKDAsIC0yKSxcbiAgICAgICAgICAgIHJlZGVlbVZlcnNpb246IHdpdG5lc3Nbd2l0bmVzcy5sZW5ndGggLSAxXVswXSAmIHR5cGVzXzEuVEFQTEVBRl9WRVJTSU9OX01BU0ssXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdwdWJrZXknLCAoKSA9PiB7XG4gICAgICAgIGlmIChhLnB1YmtleSlcbiAgICAgICAgICAgIHJldHVybiBhLnB1YmtleTtcbiAgICAgICAgaWYgKGEub3V0cHV0KVxuICAgICAgICAgICAgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDIpO1xuICAgICAgICBpZiAoYS5hZGRyZXNzKVxuICAgICAgICAgICAgcmV0dXJuIF9hZGRyZXNzKCkuZGF0YTtcbiAgICAgICAgaWYgKG8uaW50ZXJuYWxQdWJrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHR3ZWFrZWRLZXkgPSAoMCwgYmlwMzQxXzEudHdlYWtLZXkpKG8uaW50ZXJuYWxQdWJrZXksIG8uaGFzaCk7XG4gICAgICAgICAgICBpZiAodHdlYWtlZEtleSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHdlYWtlZEtleS54O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdpbnRlcm5hbFB1YmtleScsICgpID0+IHtcbiAgICAgICAgaWYgKGEuaW50ZXJuYWxQdWJrZXkpXG4gICAgICAgICAgICByZXR1cm4gYS5pbnRlcm5hbFB1YmtleTtcbiAgICAgICAgY29uc3Qgd2l0bmVzcyA9IF93aXRuZXNzKCk7XG4gICAgICAgIGlmICh3aXRuZXNzICYmIHdpdG5lc3MubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiB3aXRuZXNzW3dpdG5lc3MubGVuZ3RoIC0gMV0uc2xpY2UoMSwgMzMpO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnc2lnbmF0dXJlJywgKCkgPT4ge1xuICAgICAgICBpZiAoYS5zaWduYXR1cmUpXG4gICAgICAgICAgICByZXR1cm4gYS5zaWduYXR1cmU7XG4gICAgICAgIGNvbnN0IHdpdG5lc3MgPSBfd2l0bmVzcygpO1xuICAgICAgICBpZiAoIXdpdG5lc3MgfHwgd2l0bmVzcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiB3aXRuZXNzWzBdO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICAgICAgaWYgKGEud2l0bmVzcylcbiAgICAgICAgICAgIHJldHVybiBhLndpdG5lc3M7XG4gICAgICAgIGNvbnN0IGhhc2hUcmVlID0gX2hhc2hUcmVlKCk7XG4gICAgICAgIGlmIChoYXNoVHJlZSAmJiBhLnJlZGVlbSAmJiBhLnJlZGVlbS5vdXRwdXQgJiYgYS5pbnRlcm5hbFB1YmtleSkge1xuICAgICAgICAgICAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IGEucmVkZWVtLm91dHB1dCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBvLnJlZGVlbVZlcnNpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSAoMCwgYmlwMzQxXzEuZmluZFNjcmlwdFBhdGgpKGhhc2hUcmVlLCBsZWFmSGFzaCk7XG4gICAgICAgICAgICBpZiAoIXBhdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0S2V5ID0gKDAsIGJpcDM0MV8xLnR3ZWFrS2V5KShhLmludGVybmFsUHVia2V5LCBoYXNoVHJlZS5oYXNoKTtcbiAgICAgICAgICAgIGlmICghb3V0cHV0S2V5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xCb2NrID0gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oW28ucmVkZWVtVmVyc2lvbiB8IG91dHB1dEtleS5wYXJpdHldKSxcbiAgICAgICAgICAgICAgICBhLmludGVybmFsUHVia2V5LFxuICAgICAgICAgICAgXS5jb25jYXQocGF0aCkpO1xuICAgICAgICAgICAgcmV0dXJuIFthLnJlZGVlbS5vdXRwdXQsIGNvbnRyb2xCb2NrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5zaWduYXR1cmUpXG4gICAgICAgICAgICByZXR1cm4gW2Euc2lnbmF0dXJlXTtcbiAgICB9KTtcbiAgICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgICAgICBsZXQgcHVia2V5ID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oW10pO1xuICAgICAgICBpZiAoYS5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAobmV0d29yayAmJiBuZXR3b3JrLmJlY2gzMiAhPT0gX2FkZHJlc3MoKS5wcmVmaXgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcmVmaXggb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gVEFQUk9PVF9XSVRORVNTX1ZFUlNJT04pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIHZlcnNpb24nKTtcbiAgICAgICAgICAgIGlmIChfYWRkcmVzcygpLmRhdGEubGVuZ3RoICE9PSAzMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgZGF0YScpO1xuICAgICAgICAgICAgcHVia2V5ID0gX2FkZHJlc3MoKS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnB1YmtleSkge1xuICAgICAgICAgICAgaWYgKHB1YmtleS5sZW5ndGggPiAwICYmICFwdWJrZXkuZXF1YWxzKGEucHVia2V5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwdWJrZXkgPSBhLnB1YmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgICAgICAgIGlmIChhLm91dHB1dC5sZW5ndGggIT09IDM0IHx8XG4gICAgICAgICAgICAgICAgYS5vdXRwdXRbMF0gIT09IE9QUy5PUF8xIHx8XG4gICAgICAgICAgICAgICAgYS5vdXRwdXRbMV0gIT09IDB4MjApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGlmIChwdWJrZXkubGVuZ3RoID4gMCAmJiAhcHVia2V5LmVxdWFscyhhLm91dHB1dC5zbGljZSgyKSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IG1pc21hdGNoJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcHVia2V5ID0gYS5vdXRwdXQuc2xpY2UoMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuaW50ZXJuYWxQdWJrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHR3ZWFrZWRLZXkgPSAoMCwgYmlwMzQxXzEudHdlYWtLZXkpKGEuaW50ZXJuYWxQdWJrZXksIG8uaGFzaCk7XG4gICAgICAgICAgICBpZiAocHVia2V5Lmxlbmd0aCA+IDAgJiYgIXB1YmtleS5lcXVhbHModHdlYWtlZEtleS54KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwdWJrZXkgPSB0d2Vha2VkS2V5Lng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1YmtleSAmJiBwdWJrZXkubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocHVia2V5Lmxlbmd0aCAhPT0gMzIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwdWJrZXkgZm9yIHAydHInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNoVHJlZSA9IF9oYXNoVHJlZSgpO1xuICAgICAgICBpZiAoYS5oYXNoICYmIGhhc2hUcmVlKSB7XG4gICAgICAgICAgICBpZiAoIWEuaGFzaC5lcXVhbHMoaGFzaFRyZWUuaGFzaCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnJlZGVlbSAmJiBhLnJlZGVlbS5vdXRwdXQgJiYgaGFzaFRyZWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWZIYXNoID0gKDAsIGJpcDM0MV8xLnRhcGxlYWZIYXNoKSh7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiBhLnJlZGVlbS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogby5yZWRlZW1WZXJzaW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoISgwLCBiaXAzNDFfMS5maW5kU2NyaXB0UGF0aCkoaGFzaFRyZWUsIGxlYWZIYXNoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0gc2NyaXB0IG5vdCBpbiB0cmVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2l0bmVzcyA9IF93aXRuZXNzKCk7XG4gICAgICAgIGlmIChhLnJlZGVlbSAmJiBvLnJlZGVlbSkge1xuICAgICAgICAgICAgaWYgKGEucmVkZWVtLnJlZGVlbVZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5yZWRlZW0ucmVkZWVtVmVyc2lvbiAhPT0gby5yZWRlZW0ucmVkZWVtVmVyc2lvbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLnJlZGVlbVZlcnNpb24gYW5kIHdpdG5lc3MgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhLnJlZGVlbS5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnNjcmlwdC5kZWNvbXBpbGUoYS5yZWRlZW0ub3V0cHV0KS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgICAgIGlmIChvLnJlZGVlbS5vdXRwdXQgJiYgIWEucmVkZWVtLm91dHB1dC5lcXVhbHMoby5yZWRlZW0ub3V0cHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLm91dHB1dCBhbmQgd2l0bmVzcyBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEucmVkZWVtLndpdG5lc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoby5yZWRlZW0ud2l0bmVzcyAmJlxuICAgICAgICAgICAgICAgICAgICAhc3RhY2tzRXF1YWwoYS5yZWRlZW0ud2l0bmVzcywgby5yZWRlZW0ud2l0bmVzcykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS53aXRuZXNzIGFuZCB3aXRuZXNzIG1pc21hdGNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpdG5lc3MgJiYgd2l0bmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh3aXRuZXNzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhLnNpZ25hdHVyZSAmJiAhYS5zaWduYXR1cmUuZXF1YWxzKHdpdG5lc3NbMF0pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaWduYXR1cmUgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xCbG9jayA9IHdpdG5lc3Nbd2l0bmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbEJsb2NrLmxlbmd0aCA8IDMzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgY29udHJvbC1ibG9jayBsZW5ndGggaXMgdG9vIHNtYWxsLiBHb3QgJHtjb250cm9sQmxvY2subGVuZ3RofSwgZXhwZWN0ZWQgbWluIDMzLmApO1xuICAgICAgICAgICAgICAgIGlmICgoY29udHJvbEJsb2NrLmxlbmd0aCAtIDMzKSAlIDMyICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgY29udHJvbC1ibG9jayBsZW5ndGggb2YgJHtjb250cm9sQmxvY2subGVuZ3RofSBpcyBpbmNvcnJlY3QhYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IChjb250cm9sQmxvY2subGVuZ3RoIC0gMzMpIC8gMzI7XG4gICAgICAgICAgICAgICAgaWYgKG0gPiAxMjgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzY3JpcHQgcGF0aCBpcyB0b28gbG9uZy4gR290ICR7bX0sIGV4cGVjdGVkIG1heCAxMjguYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxQdWJrZXkgPSBjb250cm9sQmxvY2suc2xpY2UoMSwgMzMpO1xuICAgICAgICAgICAgICAgIGlmIChhLmludGVybmFsUHVia2V5ICYmICFhLmludGVybmFsUHVia2V5LmVxdWFscyhpbnRlcm5hbFB1YmtleSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludGVybmFsIHB1YmtleSBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbFB1YmtleS5sZW5ndGggIT09IDMyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGludGVybmFsUHVia2V5IGZvciBwMnRyIHdpdG5lc3MnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWFmVmVyc2lvbiA9IGNvbnRyb2xCbG9ja1swXSAmIHR5cGVzXzEuVEFQTEVBRl9WRVJTSU9OX01BU0s7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gd2l0bmVzc1t3aXRuZXNzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlYWZIYXNoID0gKDAsIGJpcDM0MV8xLnRhcGxlYWZIYXNoKSh7IG91dHB1dDogc2NyaXB0LCB2ZXJzaW9uOiBsZWFmVmVyc2lvbiB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gKDAsIGJpcDM0MV8xLnJvb3RIYXNoRnJvbVBhdGgpKGNvbnRyb2xCbG9jaywgbGVhZkhhc2gpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dEtleSA9ICgwLCBiaXAzNDFfMS50d2Vha0tleSkoaW50ZXJuYWxQdWJrZXksIGhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0S2V5KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG91dHB1dEtleSBmb3IgcDJ0ciB3aXRuZXNzJyk7XG4gICAgICAgICAgICAgICAgaWYgKHB1YmtleS5sZW5ndGggJiYgIXB1YmtleS5lcXVhbHMob3V0cHV0S2V5LngpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2ggZm9yIHAydHIgd2l0bmVzcycpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXRLZXkucGFyaXR5ICE9PSAoY29udHJvbEJsb2NrWzBdICYgMSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHBhcml0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMnRyID0gcDJ0cjtcbmZ1bmN0aW9uIHN0YWNrc0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGEuZXZlcnkoKHgsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIHguZXF1YWxzKGJbaV0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cDJ0ci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2tr.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2wpkh.js':
    /*!**********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2wpkh.js ***!
  \**********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2wpkh = void 0;\nconst bcrypto = __importStar(__webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js\"));\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\");\nconst bscript = __importStar(__webpack_require__(/*! ../script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\");\nconst lazy = __importStar(__webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js\"));\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction p2wpkh(a, opts) {\n    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n        throw new TypeError('Not enough data');\n    opts = Object.assign({ validate: true }, opts || {});\n    (0, types_1.typeforce)({\n        address: types_1.typeforce.maybe(types_1.typeforce.String),\n        hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n        input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),\n        pubkey: types_1.typeforce.maybe(types_1.isPoint),\n        signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n        witness: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer)),\n    }, a);\n    const _address = lazy.value(() => {\n        const result = crypto_lib_1.base.bech32.decode(a.address);\n        const version = result.words.shift();\n        const data = crypto_lib_1.base.bech32.fromWords(result.words);\n        return {\n            version,\n            prefix: result.prefix,\n            data: Buffer.from(data),\n        };\n    });\n    const network = a.network || networks_1.bitcoin;\n    const o = { name: 'p2wpkh', network };\n    lazy.prop(o, 'address', () => {\n        if (!o.hash)\n            return;\n        const words = crypto_lib_1.base.bech32.toWords(o.hash);\n        words.unshift(0x00);\n        return crypto_lib_1.base.bech32.encode(network.bech32, words);\n    });\n    lazy.prop(o, 'hash', () => {\n        if (a.output)\n            return a.output.slice(2, 22);\n        if (a.address)\n            return _address().data;\n        if (a.pubkey || o.pubkey)\n            return bcrypto.hash160(a.pubkey || o.pubkey);\n    });\n    lazy.prop(o, 'output', () => {\n        if (!o.hash)\n            return;\n        return bscript.compile([OPS.OP_0, o.hash]);\n    });\n    lazy.prop(o, 'pubkey', () => {\n        if (a.pubkey)\n            return a.pubkey;\n        if (!a.witness)\n            return;\n        return a.witness[1];\n    });\n    lazy.prop(o, 'signature', () => {\n        if (!a.witness)\n            return;\n        return a.witness[0];\n    });\n    lazy.prop(o, 'input', () => {\n        if (!o.witness)\n            return;\n        return EMPTY_BUFFER;\n    });\n    lazy.prop(o, 'witness', () => {\n        if (!a.pubkey)\n            return;\n        if (!a.signature)\n            return;\n        return [a.signature, a.pubkey];\n    });\n    if (opts.validate) {\n        let hash = Buffer.from([]);\n        if (a.address) {\n            if (network && network.bech32 !== _address().prefix)\n                throw new TypeError('Invalid prefix or Network mismatch');\n            if (_address().version !== 0x00)\n                throw new TypeError('Invalid address version');\n            if (_address().data.length !== 20)\n                throw new TypeError('Invalid address data');\n            hash = _address().data;\n        }\n        if (a.hash) {\n            if (hash.length > 0 && !hash.equals(a.hash))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = a.hash;\n        }\n        if (a.output) {\n            if (a.output.length !== 22 ||\n                a.output[0] !== OPS.OP_0 ||\n                a.output[1] !== 0x14)\n                throw new TypeError('Output is invalid');\n            if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = a.output.slice(2);\n        }\n        if (a.pubkey) {\n            const pkh = bcrypto.hash160(a.pubkey);\n            if (hash.length > 0 && !hash.equals(pkh))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = pkh;\n            if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)\n                throw new TypeError('Invalid pubkey for p2wpkh');\n        }\n        if (a.witness) {\n            if (a.witness.length !== 2)\n                throw new TypeError('Witness is invalid');\n            if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n                throw new TypeError('Witness has invalid signature');\n            if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)\n                throw new TypeError('Witness has invalid pubkey');\n            if (a.signature && !a.signature.equals(a.witness[0]))\n                throw new TypeError('Signature mismatch');\n            if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n                throw new TypeError('Pubkey mismatch');\n            const pkh = bcrypto.hash160(a.witness[1]);\n            if (hash.length > 0 && !hash.equals(pkh))\n                throw new TypeError('Hash mismatch');\n        }\n    }\n    return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n//# sourceMappingURL=p2wpkh.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9wMndwa2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCw2QkFBNkIsbUJBQU8sQ0FBQywwRkFBVztBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBYTtBQUN4Qyw2QkFBNkIsbUJBQU8sQ0FBQywwRkFBVztBQUNoRCxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBVTtBQUNsQywwQkFBMEIsbUJBQU8sQ0FBQyw4RkFBUTtBQUMxQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvcGF5bWVudHMvcDJ3cGtoLmpzPzRiMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucDJ3cGtoID0gdm9pZCAwO1xuY29uc3QgYmNyeXB0byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vY3J5cHRvXCIpKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKFwiLi4vbmV0d29ya3NcIik7XG5jb25zdCBic2NyaXB0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9zY3JpcHRcIikpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmNvbnN0IGxhenkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbGF6eVwiKSk7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jKDApO1xuZnVuY3Rpb24gcDJ3cGtoKGEsIG9wdHMpIHtcbiAgICBpZiAoIWEuYWRkcmVzcyAmJiAhYS5oYXNoICYmICFhLm91dHB1dCAmJiAhYS5wdWJrZXkgJiYgIWEud2l0bmVzcylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKHtcbiAgICAgICAgYWRkcmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuU3RyaW5nKSxcbiAgICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigyMCkpLFxuICAgICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigwKSksXG4gICAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigyMikpLFxuICAgICAgICBwdWJrZXk6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEuaXNQb2ludCksXG4gICAgICAgIHNpZ25hdHVyZTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZSksXG4gICAgICAgIHdpdG5lc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSksXG4gICAgfSwgYSk7XG4gICAgY29uc3QgX2FkZHJlc3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY3J5cHRvX2xpYl8xLmJhc2UuYmVjaDMyLmRlY29kZShhLmFkZHJlc3MpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gcmVzdWx0LndvcmRzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjcnlwdG9fbGliXzEuYmFzZS5iZWNoMzIuZnJvbVdvcmRzKHJlc3VsdC53b3Jkcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgcHJlZml4OiByZXN1bHQucHJlZml4LFxuICAgICAgICAgICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YSksXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gICAgY29uc3QgbyA9IHsgbmFtZTogJ3Ayd3BraCcsIG5ldHdvcmsgfTtcbiAgICBsYXp5LnByb3AobywgJ2FkZHJlc3MnLCAoKSA9PiB7XG4gICAgICAgIGlmICghby5oYXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB3b3JkcyA9IGNyeXB0b19saWJfMS5iYXNlLmJlY2gzMi50b1dvcmRzKG8uaGFzaCk7XG4gICAgICAgIHdvcmRzLnVuc2hpZnQoMHgwMCk7XG4gICAgICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS5iZWNoMzIuZW5jb2RlKG5ldHdvcmsuYmVjaDMyLCB3b3Jkcyk7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdoYXNoJywgKCkgPT4ge1xuICAgICAgICBpZiAoYS5vdXRwdXQpXG4gICAgICAgICAgICByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMiwgMjIpO1xuICAgICAgICBpZiAoYS5hZGRyZXNzKVxuICAgICAgICAgICAgcmV0dXJuIF9hZGRyZXNzKCkuZGF0YTtcbiAgICAgICAgaWYgKGEucHVia2V5IHx8IG8ucHVia2V5KVxuICAgICAgICAgICAgcmV0dXJuIGJjcnlwdG8uaGFzaDE2MChhLnB1YmtleSB8fCBvLnB1YmtleSk7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghby5oYXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfMCwgby5oYXNoXSk7XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdwdWJrZXknLCAoKSA9PiB7XG4gICAgICAgIGlmIChhLnB1YmtleSlcbiAgICAgICAgICAgIHJldHVybiBhLnB1YmtleTtcbiAgICAgICAgaWYgKCFhLndpdG5lc3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBhLndpdG5lc3NbMV07XG4gICAgfSk7XG4gICAgbGF6eS5wcm9wKG8sICdzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgICAgIGlmICghYS53aXRuZXNzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gYS53aXRuZXNzWzBdO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghby53aXRuZXNzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICAgICAgaWYgKCFhLnB1YmtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFhLnNpZ25hdHVyZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIFthLnNpZ25hdHVyZSwgYS5wdWJrZXldO1xuICAgIH0pO1xuICAgIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgICAgIGxldCBoYXNoID0gQnVmZmVyLmZyb20oW10pO1xuICAgICAgICBpZiAoYS5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAobmV0d29yayAmJiBuZXR3b3JrLmJlY2gzMiAhPT0gX2FkZHJlc3MoKS5wcmVmaXgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcmVmaXggb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gMHgwMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgdmVyc2lvbicpO1xuICAgICAgICAgICAgaWYgKF9hZGRyZXNzKCkuZGF0YS5sZW5ndGggIT09IDIwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyBkYXRhJyk7XG4gICAgICAgICAgICBoYXNoID0gX2FkZHJlc3MoKS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmhhc2gpIHtcbiAgICAgICAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGEuaGFzaCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhhc2ggPSBhLmhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAoYS5vdXRwdXQubGVuZ3RoICE9PSAyMiB8fFxuICAgICAgICAgICAgICAgIGEub3V0cHV0WzBdICE9PSBPUFMuT1BfMCB8fFxuICAgICAgICAgICAgICAgIGEub3V0cHV0WzFdICE9PSAweDE0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLm91dHB1dC5zbGljZSgyKSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhhc2ggPSBhLm91dHB1dC5zbGljZSgyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5wdWJrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChhLnB1YmtleSk7XG4gICAgICAgICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhwa2gpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoYXNoID0gcGtoO1xuICAgICAgICAgICAgaWYgKCEoMCwgdHlwZXNfMS5pc1BvaW50KShhLnB1YmtleSkgfHwgYS5wdWJrZXkubGVuZ3RoICE9PSAzMylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHB1YmtleSBmb3IgcDJ3cGtoJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEud2l0bmVzcykge1xuICAgICAgICAgICAgaWYgKGEud2l0bmVzcy5sZW5ndGggIT09IDIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBpZiAoIWJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoYS53aXRuZXNzWzBdKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGhhcyBpbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgICAgICAgaWYgKCEoMCwgdHlwZXNfMS5pc1BvaW50KShhLndpdG5lc3NbMV0pIHx8IGEud2l0bmVzc1sxXS5sZW5ndGggIT09IDMzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgaGFzIGludmFsaWQgcHVia2V5Jyk7XG4gICAgICAgICAgICBpZiAoYS5zaWduYXR1cmUgJiYgIWEuc2lnbmF0dXJlLmVxdWFscyhhLndpdG5lc3NbMF0pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpZ25hdHVyZSBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgaWYgKGEucHVia2V5ICYmICFhLnB1YmtleS5lcXVhbHMoYS53aXRuZXNzWzFdKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChhLndpdG5lc3NbMV0pO1xuICAgICAgICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMocGtoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAyd3BraCA9IHAyd3BraDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXAyd3BraC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2wpkh.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2wsh.js':
    /*!*********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2wsh.js ***!
  \*********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2wsh = void 0;\nconst bcrypto = __importStar(__webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js\"));\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\");\nconst bscript = __importStar(__webpack_require__(/*! ../script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\");\nconst lazy = __importStar(__webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/lazy.js\"));\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction stacksEqual(a, b) {\n    if (a.length !== b.length)\n        return false;\n    return a.every((x, i) => {\n        return x.equals(b[i]);\n    });\n}\nfunction chunkHasUncompressedPubkey(chunk) {\n    if (Buffer.isBuffer(chunk) &&\n        chunk.length === 65 &&\n        chunk[0] === 0x04 &&\n        (0, types_1.isPoint)(chunk)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction p2wsh(a, opts) {\n    if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n        throw new TypeError('Not enough data');\n    opts = Object.assign({ validate: true }, opts || {});\n    (0, types_1.typeforce)({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        address: types_1.typeforce.maybe(types_1.typeforce.String),\n        hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n        output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n        redeem: types_1.typeforce.maybe({\n            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n            network: types_1.typeforce.maybe(types_1.typeforce.Object),\n            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n            witness: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer)),\n        }),\n        input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n        witness: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer)),\n    }, a);\n    const _address = lazy.value(() => {\n        const result = crypto_lib_1.base.bech32.decode(a.address);\n        const version = result.words.shift();\n        const data = crypto_lib_1.base.bech32.fromWords(result.words);\n        return {\n            version,\n            prefix: result.prefix,\n            data: Buffer.from(data),\n        };\n    });\n    const _rchunks = lazy.value(() => {\n        return bscript.decompile(a.redeem.input);\n    });\n    let network = a.network;\n    if (!network) {\n        network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n    }\n    const o = { network };\n    lazy.prop(o, 'address', () => {\n        if (!o.hash)\n            return;\n        const words = crypto_lib_1.base.bech32.toWords(o.hash);\n        words.unshift(0x00);\n        return crypto_lib_1.base.bech32.encode(network.bech32, words);\n    });\n    lazy.prop(o, 'hash', () => {\n        if (a.output)\n            return a.output.slice(2);\n        if (a.address)\n            return _address().data;\n        if (o.redeem && o.redeem.output)\n            return bcrypto.sha256(o.redeem.output);\n    });\n    lazy.prop(o, 'output', () => {\n        if (!o.hash)\n            return;\n        return bscript.compile([OPS.OP_0, o.hash]);\n    });\n    lazy.prop(o, 'redeem', () => {\n        if (!a.witness)\n            return;\n        return {\n            output: a.witness[a.witness.length - 1],\n            input: EMPTY_BUFFER,\n            witness: a.witness.slice(0, -1),\n        };\n    });\n    lazy.prop(o, 'input', () => {\n        if (!o.witness)\n            return;\n        return EMPTY_BUFFER;\n    });\n    lazy.prop(o, 'witness', () => {\n        if (a.redeem &&\n            a.redeem.input &&\n            a.redeem.input.length > 0 &&\n            a.redeem.output &&\n            a.redeem.output.length > 0) {\n            const stack = bscript.toStack(_rchunks());\n            o.redeem = Object.assign({ witness: stack }, a.redeem);\n            o.redeem.input = EMPTY_BUFFER;\n            return [].concat(stack, a.redeem.output);\n        }\n        if (!a.redeem)\n            return;\n        if (!a.redeem.output)\n            return;\n        if (!a.redeem.witness)\n            return;\n        return [].concat(a.redeem.witness, a.redeem.output);\n    });\n    lazy.prop(o, 'name', () => {\n        const nameParts = ['p2wsh'];\n        if (o.redeem !== undefined && o.redeem.name !== undefined)\n            nameParts.push(o.redeem.name);\n        return nameParts.join('-');\n    });\n    if (opts.validate) {\n        let hash = Buffer.from([]);\n        if (a.address) {\n            if (_address().prefix !== network.bech32)\n                throw new TypeError('Invalid prefix or Network mismatch');\n            if (_address().version !== 0x00)\n                throw new TypeError('Invalid address version');\n            if (_address().data.length !== 32)\n                throw new TypeError('Invalid address data');\n            hash = _address().data;\n        }\n        if (a.hash) {\n            if (hash.length > 0 && !hash.equals(a.hash))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = a.hash;\n        }\n        if (a.output) {\n            if (a.output.length !== 34 ||\n                a.output[0] !== OPS.OP_0 ||\n                a.output[1] !== 0x20)\n                throw new TypeError('Output is invalid');\n            const hash2 = a.output.slice(2);\n            if (hash.length > 0 && !hash.equals(hash2))\n                throw new TypeError('Hash mismatch');\n            else\n                hash = hash2;\n        }\n        if (a.redeem) {\n            if (a.redeem.network && a.redeem.network !== network)\n                throw new TypeError('Network mismatch');\n            if (a.redeem.input &&\n                a.redeem.input.length > 0 &&\n                a.redeem.witness &&\n                a.redeem.witness.length > 0)\n                throw new TypeError('Ambiguous witness source');\n            if (a.redeem.output) {\n                if (bscript.decompile(a.redeem.output).length === 0)\n                    throw new TypeError('Redeem.output is invalid');\n                const hash2 = bcrypto.sha256(a.redeem.output);\n                if (hash.length > 0 && !hash.equals(hash2))\n                    throw new TypeError('Hash mismatch');\n                else\n                    hash = hash2;\n            }\n            if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n                throw new TypeError('Non push-only scriptSig');\n            if (a.witness &&\n                a.redeem.witness &&\n                !stacksEqual(a.witness, a.redeem.witness))\n                throw new TypeError('Witness and redeem.witness mismatch');\n            if ((a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n                (a.redeem.output &&\n                    (bscript.decompile(a.redeem.output) || []).some(chunkHasUncompressedPubkey))) {\n                throw new TypeError('redeem.input or redeem.output contains uncompressed pubkey');\n            }\n        }\n        if (a.witness && a.witness.length > 0) {\n            const wScript = a.witness[a.witness.length - 1];\n            if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n                throw new TypeError('Witness and redeem.output mismatch');\n            if (a.witness.some(chunkHasUncompressedPubkey) ||\n                (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey))\n                throw new TypeError('Witness contains uncompressed pubkey');\n        }\n    }\n    return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n//# sourceMappingURL=p2wsh.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9wMndzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLDZCQUE2QixtQkFBTyxDQUFDLDBGQUFXO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLDhGQUFhO0FBQ3hDLDZCQUE2QixtQkFBTyxDQUFDLDBGQUFXO0FBQ2hELGdCQUFnQixtQkFBTyxDQUFDLHdGQUFVO0FBQ2xDLDBCQUEwQixtQkFBTyxDQUFDLDhGQUFRO0FBQzFDLHFCQUFxQixtQkFBTyxDQUFDLG1GQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wYXltZW50cy9wMndzaC5qcz9iNmRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAyd3NoID0gdm9pZCAwO1xuY29uc3QgYmNyeXB0byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vY3J5cHRvXCIpKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKFwiLi4vbmV0d29ya3NcIik7XG5jb25zdCBic2NyaXB0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9zY3JpcHRcIikpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmNvbnN0IGxhenkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbGF6eVwiKSk7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jKDApO1xuZnVuY3Rpb24gc3RhY2tzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYS5ldmVyeSgoeCwgaSkgPT4ge1xuICAgICAgICByZXR1cm4geC5lcXVhbHMoYltpXSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaHVua0hhc1VuY29tcHJlc3NlZFB1YmtleShjaHVuaykge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAgIGNodW5rLmxlbmd0aCA9PT0gNjUgJiZcbiAgICAgICAgY2h1bmtbMF0gPT09IDB4MDQgJiZcbiAgICAgICAgKDAsIHR5cGVzXzEuaXNQb2ludCkoY2h1bmspKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHAyd3NoKGEsIG9wdHMpIHtcbiAgICBpZiAoIWEuYWRkcmVzcyAmJiAhYS5oYXNoICYmICFhLm91dHB1dCAmJiAhYS5yZWRlZW0gJiYgIWEud2l0bmVzcylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKHtcbiAgICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgICAgYWRkcmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuU3RyaW5nKSxcbiAgICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigzMikpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMzQpKSxcbiAgICAgICAgcmVkZWVtOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh7XG4gICAgICAgICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlcikpLFxuICAgICAgICB9KSxcbiAgICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMCkpLFxuICAgICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlcikpLFxuICAgIH0sIGEpO1xuICAgIGNvbnN0IF9hZGRyZXNzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNyeXB0b19saWJfMS5iYXNlLmJlY2gzMi5kZWNvZGUoYS5hZGRyZXNzKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHJlc3VsdC53b3Jkcy5zaGlmdCgpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3J5cHRvX2xpYl8xLmJhc2UuYmVjaDMyLmZyb21Xb3JkcyhyZXN1bHQud29yZHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIHByZWZpeDogcmVzdWx0LnByZWZpeCxcbiAgICAgICAgICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IF9yY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBic2NyaXB0LmRlY29tcGlsZShhLnJlZGVlbS5pbnB1dCk7XG4gICAgfSk7XG4gICAgbGV0IG5ldHdvcmsgPSBhLm5ldHdvcms7XG4gICAgaWYgKCFuZXR3b3JrKSB7XG4gICAgICAgIG5ldHdvcmsgPSAoYS5yZWRlZW0gJiYgYS5yZWRlZW0ubmV0d29yaykgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICAgIH1cbiAgICBjb25zdCBvID0geyBuZXR3b3JrIH07XG4gICAgbGF6eS5wcm9wKG8sICdhZGRyZXNzJywgKCkgPT4ge1xuICAgICAgICBpZiAoIW8uaGFzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBjcnlwdG9fbGliXzEuYmFzZS5iZWNoMzIudG9Xb3JkcyhvLmhhc2gpO1xuICAgICAgICB3b3Jkcy51bnNoaWZ0KDB4MDApO1xuICAgICAgICByZXR1cm4gY3J5cHRvX2xpYl8xLmJhc2UuYmVjaDMyLmVuY29kZShuZXR3b3JrLmJlY2gzMiwgd29yZHMpO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnaGFzaCcsICgpID0+IHtcbiAgICAgICAgaWYgKGEub3V0cHV0KVxuICAgICAgICAgICAgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDIpO1xuICAgICAgICBpZiAoYS5hZGRyZXNzKVxuICAgICAgICAgICAgcmV0dXJuIF9hZGRyZXNzKCkuZGF0YTtcbiAgICAgICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLm91dHB1dClcbiAgICAgICAgICAgIHJldHVybiBiY3J5cHRvLnNoYTI1NihvLnJlZGVlbS5vdXRwdXQpO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgICAgICBpZiAoIW8uaGFzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbT1BTLk9QXzAsIG8uaGFzaF0pO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAncmVkZWVtJywgKCkgPT4ge1xuICAgICAgICBpZiAoIWEud2l0bmVzcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG91dHB1dDogYS53aXRuZXNzW2Eud2l0bmVzcy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGlucHV0OiBFTVBUWV9CVUZGRVIsXG4gICAgICAgICAgICB3aXRuZXNzOiBhLndpdG5lc3Muc2xpY2UoMCwgLTEpLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghby53aXRuZXNzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICAgICAgaWYgKGEucmVkZWVtICYmXG4gICAgICAgICAgICBhLnJlZGVlbS5pbnB1dCAmJlxuICAgICAgICAgICAgYS5yZWRlZW0uaW5wdXQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgYS5yZWRlZW0ub3V0cHV0ICYmXG4gICAgICAgICAgICBhLnJlZGVlbS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBic2NyaXB0LnRvU3RhY2soX3JjaHVua3MoKSk7XG4gICAgICAgICAgICBvLnJlZGVlbSA9IE9iamVjdC5hc3NpZ24oeyB3aXRuZXNzOiBzdGFjayB9LCBhLnJlZGVlbSk7XG4gICAgICAgICAgICBvLnJlZGVlbS5pbnB1dCA9IEVNUFRZX0JVRkZFUjtcbiAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoc3RhY2ssIGEucmVkZWVtLm91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhLnJlZGVlbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFhLnJlZGVlbS5vdXRwdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghYS5yZWRlZW0ud2l0bmVzcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChhLnJlZGVlbS53aXRuZXNzLCBhLnJlZGVlbS5vdXRwdXQpO1xuICAgIH0pO1xuICAgIGxhenkucHJvcChvLCAnbmFtZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZVBhcnRzID0gWydwMndzaCddO1xuICAgICAgICBpZiAoby5yZWRlZW0gIT09IHVuZGVmaW5lZCAmJiBvLnJlZGVlbS5uYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBuYW1lUGFydHMucHVzaChvLnJlZGVlbS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWVQYXJ0cy5qb2luKCctJyk7XG4gICAgfSk7XG4gICAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICAgICAgbGV0IGhhc2ggPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmIChfYWRkcmVzcygpLnByZWZpeCAhPT0gbmV0d29yay5iZWNoMzIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcmVmaXggb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gMHgwMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgdmVyc2lvbicpO1xuICAgICAgICAgICAgaWYgKF9hZGRyZXNzKCkuZGF0YS5sZW5ndGggIT09IDMyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyBkYXRhJyk7XG4gICAgICAgICAgICBoYXNoID0gX2FkZHJlc3MoKS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmhhc2gpIHtcbiAgICAgICAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGEuaGFzaCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhhc2ggPSBhLmhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAoYS5vdXRwdXQubGVuZ3RoICE9PSAzNCB8fFxuICAgICAgICAgICAgICAgIGEub3V0cHV0WzBdICE9PSBPUFMuT1BfMCB8fFxuICAgICAgICAgICAgICAgIGEub3V0cHV0WzFdICE9PSAweDIwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBoYXNoMiA9IGEub3V0cHV0LnNsaWNlKDIpO1xuICAgICAgICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoaGFzaDIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoYXNoID0gaGFzaDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEucmVkZWVtKSB7XG4gICAgICAgICAgICBpZiAoYS5yZWRlZW0ubmV0d29yayAmJiBhLnJlZGVlbS5uZXR3b3JrICE9PSBuZXR3b3JrKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGlmIChhLnJlZGVlbS5pbnB1dCAmJlxuICAgICAgICAgICAgICAgIGEucmVkZWVtLmlucHV0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICAgICAgICAgYS5yZWRlZW0ud2l0bmVzcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FtYmlndW91cyB3aXRuZXNzIHNvdXJjZScpO1xuICAgICAgICAgICAgaWYgKGEucmVkZWVtLm91dHB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChic2NyaXB0LmRlY29tcGlsZShhLnJlZGVlbS5vdXRwdXQpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLm91dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaDIgPSBiY3J5cHRvLnNoYTI1NihhLnJlZGVlbS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGhhc2gyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9IGhhc2gyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEucmVkZWVtLmlucHV0ICYmICFic2NyaXB0LmlzUHVzaE9ubHkoX3JjaHVua3MoKSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9uIHB1c2gtb25seSBzY3JpcHRTaWcnKTtcbiAgICAgICAgICAgIGlmIChhLndpdG5lc3MgJiZcbiAgICAgICAgICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICAgICAgICAgIXN0YWNrc0VxdWFsKGEud2l0bmVzcywgYS5yZWRlZW0ud2l0bmVzcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBhbmQgcmVkZWVtLndpdG5lc3MgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGlmICgoYS5yZWRlZW0uaW5wdXQgJiYgX3JjaHVua3MoKS5zb21lKGNodW5rSGFzVW5jb21wcmVzc2VkUHVia2V5KSkgfHxcbiAgICAgICAgICAgICAgICAoYS5yZWRlZW0ub3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIChic2NyaXB0LmRlY29tcGlsZShhLnJlZGVlbS5vdXRwdXQpIHx8IFtdKS5zb21lKGNodW5rSGFzVW5jb21wcmVzc2VkUHVia2V5KSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWRlZW0uaW5wdXQgb3IgcmVkZWVtLm91dHB1dCBjb250YWlucyB1bmNvbXByZXNzZWQgcHVia2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEud2l0bmVzcyAmJiBhLndpdG5lc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgd1NjcmlwdCA9IGEud2l0bmVzc1thLndpdG5lc3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoYS5yZWRlZW0gJiYgYS5yZWRlZW0ub3V0cHV0ICYmICFhLnJlZGVlbS5vdXRwdXQuZXF1YWxzKHdTY3JpcHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgYW5kIHJlZGVlbS5vdXRwdXQgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIGlmIChhLndpdG5lc3Muc29tZShjaHVua0hhc1VuY29tcHJlc3NlZFB1YmtleSkgfHxcbiAgICAgICAgICAgICAgICAoYnNjcmlwdC5kZWNvbXBpbGUod1NjcmlwdCkgfHwgW10pLnNvbWUoY2h1bmtIYXNVbmNvbXByZXNzZWRQdWJrZXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgY29udGFpbnMgdW5jb21wcmVzc2VkIHB1YmtleScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMndzaCA9IHAyd3NoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cDJ3c2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/p2wsh.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt.js':
    /*!***********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt.js ***!
  \***********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getHashAndSighashType = exports.Psbt = void 0;\nconst psbt_1 = __webpack_require__(/*! ./bip174/psbt */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/psbt.js\");\nconst varuint = __importStar(__webpack_require__(/*! ./bip174/converter/varint */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js\"));\nconst utils_1 = __webpack_require__(/*! ./bip174/utils */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/utils.js\");\nconst address_1 = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/address.js\");\nconst bufferutils_1 = __webpack_require__(/*! ./bufferutils */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js\");\nconst networks_1 = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js\");\nconst payments = __importStar(__webpack_require__(/*! ./payments */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js\"));\nconst bip341_1 = __webpack_require__(/*! ./payments/bip341 */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/bip341.js\");\nconst bscript = __importStar(__webpack_require__(/*! ./script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/transaction.js\");\nconst bip371_1 = __webpack_require__(/*! ./psbt/bip371 */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/bip371.js\");\nconst psbtutils_1 = __webpack_require__(/*! ./psbt/psbtutils */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/psbtutils.js\");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nconst script_1 = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\");\nconst taproot_1 = __webpack_require__(/*! ../taproot */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/taproot.js\");\nconst schnorr = crypto_lib_1.signUtil.schnorr.secp256k1.schnorr;\nconst DEFAULT_OPTS = {\n    network: networks_1.bitcoin,\n    maximumFeeRate: 5000,\n};\nclass Psbt {\n    static fromBase64(data, opts = {}) {\n        const buffer = Buffer.from(data, 'base64');\n        return this.fromBuffer(buffer, opts);\n    }\n    static fromHex(data, opts = {}) {\n        const buffer = Buffer.from(data, 'hex');\n        return this.fromBuffer(buffer, opts);\n    }\n    static fromBuffer(buffer, opts = {}) {\n        const psbtBase = psbt_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n        const psbt = new Psbt(opts, psbtBase);\n        checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n        return psbt;\n    }\n    constructor(opts = {}, data = new psbt_1.Psbt(new PsbtTransaction())) {\n        this.data = data;\n        this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n        this.__CACHE = {\n            __NON_WITNESS_UTXO_TX_CACHE: [],\n            __NON_WITNESS_UTXO_BUF_CACHE: [],\n            __TX_IN_CACHE: {},\n            __TX: this.data.globalMap.unsignedTx.tx,\n            __UNSAFE_SIGN_NONSEGWIT: false,\n        };\n        if (this.data.inputs.length === 0)\n            this.setVersion(2);\n        const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {\n            enumerable,\n            writable,\n        });\n        dpew(this, '__CACHE', false, true);\n        dpew(this, 'opts', false, true);\n    }\n    get inputCount() {\n        return this.data.inputs.length;\n    }\n    get version() {\n        return this.__CACHE.__TX.version;\n    }\n    set version(version) {\n        this.setVersion(version);\n    }\n    get locktime() {\n        return this.__CACHE.__TX.locktime;\n    }\n    set locktime(locktime) {\n        this.setLocktime(locktime);\n    }\n    get txInputs() {\n        return this.__CACHE.__TX.ins.map(input => ({\n            hash: (0, bufferutils_1.cloneBuffer)(input.hash),\n            index: input.index,\n            sequence: input.sequence,\n        }));\n    }\n    get txOutputs() {\n        return this.__CACHE.__TX.outs.map(output => {\n            let address;\n            try {\n                address = (0, address_1.fromOutputScript)(output.script, this.opts.network);\n            }\n            catch (_) {\n            }\n            return {\n                script: (0, bufferutils_1.cloneBuffer)(output.script),\n                value: output.value,\n                address,\n            };\n        });\n    }\n    combine(...those) {\n        this.data.combine(...those.map(o => o.data));\n        return this;\n    }\n    clone() {\n        const res = Psbt.fromBuffer(this.data.toBuffer());\n        res.opts = JSON.parse(JSON.stringify(this.opts));\n        return res;\n    }\n    setMaximumFeeRate(satoshiPerByte) {\n        check32Bit(satoshiPerByte);\n        this.opts.maximumFeeRate = satoshiPerByte;\n    }\n    setVersion(version) {\n        check32Bit(version);\n        checkInputsForPartialSig(this.data.inputs, 'setVersion');\n        const c = this.__CACHE;\n        c.__TX.version = version;\n        c.__EXTRACTED_TX = undefined;\n        return this;\n    }\n    setLocktime(locktime) {\n        check32Bit(locktime);\n        checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n        const c = this.__CACHE;\n        c.__TX.locktime = locktime;\n        c.__EXTRACTED_TX = undefined;\n        return this;\n    }\n    setInputSequence(inputIndex, sequence) {\n        check32Bit(sequence);\n        checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n        const c = this.__CACHE;\n        if (c.__TX.ins.length <= inputIndex) {\n            throw new Error('Input index too high');\n        }\n        c.__TX.ins[inputIndex].sequence = sequence;\n        c.__EXTRACTED_TX = undefined;\n        return this;\n    }\n    addInputs(inputDatas) {\n        inputDatas.forEach(inputData => this.addInput(inputData));\n        return this;\n    }\n    addInput(inputData) {\n        if (arguments.length > 1 ||\n            !inputData ||\n            inputData.hash === undefined ||\n            inputData.index === undefined) {\n            throw new Error(`Invalid arguments for Psbt.addInput. ` +\n                `Requires single object with at least [hash] and [index]`);\n        }\n        (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');\n        checkInputsForPartialSig(this.data.inputs, 'addInput');\n        if (inputData.witnessScript)\n            checkInvalidP2WSH(inputData.witnessScript);\n        const c = this.__CACHE;\n        this.data.addInput(inputData);\n        const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n        checkTxInputCache(c, txIn);\n        const inputIndex = this.data.inputs.length - 1;\n        const input = this.data.inputs[inputIndex];\n        if (input.nonWitnessUtxo) {\n            addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n        }\n        c.__FEE = undefined;\n        c.__FEE_RATE = undefined;\n        c.__EXTRACTED_TX = undefined;\n        return this;\n    }\n    addOutputs(outputDatas) {\n        outputDatas.forEach(outputData => this.addOutput(outputData));\n        return this;\n    }\n    addOutput(outputData) {\n        if (arguments.length > 1 ||\n            !outputData ||\n            outputData.value === undefined ||\n            (outputData.address === undefined &&\n                outputData.script === undefined)) {\n            throw new Error(`Invalid arguments for Psbt.addOutput. ` +\n                `Requires single object with at least [script or address] and [value]`);\n        }\n        checkInputsForPartialSig(this.data.inputs, 'addOutput');\n        const { address } = outputData;\n        if (typeof address === 'string') {\n            const { network } = this.opts;\n            const script = (0, address_1.toOutputScript)(address, network);\n            outputData = Object.assign(outputData, { script });\n        }\n        (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');\n        const c = this.__CACHE;\n        this.data.addOutput(outputData);\n        c.__FEE = undefined;\n        c.__FEE_RATE = undefined;\n        c.__EXTRACTED_TX = undefined;\n        return this;\n    }\n    extractTransaction(disableFeeCheck) {\n        if (!this.data.inputs.every(isFinalized))\n            throw new Error('Not finalized');\n        const c = this.__CACHE;\n        if (!disableFeeCheck) {\n            checkFees(this, c, this.opts);\n        }\n        if (c.__EXTRACTED_TX)\n            return c.__EXTRACTED_TX;\n        const tx = c.__TX.clone();\n        inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n        return tx;\n    }\n    getFeeRate() {\n        return getTxCacheValue('__FEE_RATE', 'fee rate', this.data.inputs, this.__CACHE);\n    }\n    getFee() {\n        return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n    }\n    finalizeAllInputs() {\n        (0, utils_1.checkForInput)(this.data.inputs, 0);\n        range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n        return this;\n    }\n    finalizeInput(inputIndex, finalScriptsFunc) {\n        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n        if ((0, bip371_1.isTaprootInput)(input))\n            return this._finalizeTaprootInput(inputIndex, input, undefined, finalScriptsFunc);\n        return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n    }\n    finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {\n        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n        if ((0, bip371_1.isTaprootInput)(input))\n            return this._finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc);\n        throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n    }\n    _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n        const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(inputIndex, input, this.__CACHE);\n        if (!script)\n            throw new Error(`No script found for input #${inputIndex}`);\n        checkPartialSigSighashes(input);\n        const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH);\n        if (finalScriptSig)\n            this.data.updateInput(inputIndex, { finalScriptSig });\n        if (finalScriptWitness)\n            this.data.updateInput(inputIndex, { finalScriptWitness });\n        if (!finalScriptSig && !finalScriptWitness)\n            throw new Error(`Unknown error finalizing input #${inputIndex}`);\n        this.data.clearFinalizedInput(inputIndex);\n        return this;\n    }\n    _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {\n        if (!input.witnessUtxo)\n            throw new Error(`Cannot finalize input #${inputIndex}. Missing withness utxo.`);\n        if (input.tapKeySig) {\n            const payment = payments.p2tr({\n                output: input.witnessUtxo.script,\n                signature: input.tapKeySig,\n            });\n            const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(payment.witness);\n            this.data.updateInput(inputIndex, { finalScriptWitness });\n        }\n        else {\n            const { finalScriptWitness } = finalScriptsFunc(inputIndex, input, tapLeafHashToFinalize);\n            this.data.updateInput(inputIndex, { finalScriptWitness });\n        }\n        this.data.clearFinalizedInput(inputIndex);\n        return this;\n    }\n    getInputType(inputIndex) {\n        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n        const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n        const result = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript ||\n            redeemFromFinalWitnessScript(input.finalScriptWitness));\n        const type = result.type === 'raw' ? '' : result.type + '-';\n        const mainType = classifyScript(result.meaningfulScript);\n        return (type + mainType);\n    }\n    inputHasPubkey(inputIndex, pubkey) {\n        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n        return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n    }\n    inputHasHDKey(inputIndex, root) {\n        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n        const derivationIsMine = bip32DerivationIsMine(root);\n        return (!!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine));\n    }\n    outputHasPubkey(outputIndex, pubkey) {\n        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n        return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n    }\n    outputHasHDKey(outputIndex, root) {\n        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n        const derivationIsMine = bip32DerivationIsMine(root);\n        return (!!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine));\n    }\n    validateSignaturesOfAllInputs(validator) {\n        (0, utils_1.checkForInput)(this.data.inputs, 0);\n        const results = range(this.data.inputs.length).map(idx => this.validateSignaturesOfInput(idx, validator));\n        return results.reduce((final, res) => res === true && final, true);\n    }\n    validateSignaturesOfInput(inputIndex, validator, pubkey) {\n        const input = this.data.inputs[inputIndex];\n        if ((0, bip371_1.isTaprootInput)(input))\n            return this.validateSignaturesOfTaprootInput(inputIndex, validator, pubkey);\n        return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n    }\n    _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n        const input = this.data.inputs[inputIndex];\n        const partialSig = (input || {}).partialSig;\n        if (!input || !partialSig || partialSig.length < 1)\n            throw new Error('No signatures to validate');\n        if (typeof validator !== 'function')\n            throw new Error('Need validator function to validate signatures');\n        const mySigs = pubkey\n            ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n            : partialSig;\n        if (mySigs.length < 1)\n            throw new Error('No signatures for this pubkey');\n        const results = [];\n        let hashCache;\n        let scriptCache;\n        let sighashCache;\n        for (const pSig of mySigs) {\n            const sig = bscript.signature.decode(pSig.signature);\n            const { hash, script } = sighashCache !== sig.hashType\n                ? getHashForSig(inputIndex, Object.assign({}, input, { sighashType: sig.hashType }), this.__CACHE, true)\n                : { hash: hashCache, script: scriptCache };\n            sighashCache = sig.hashType;\n            hashCache = hash;\n            scriptCache = script;\n            checkScriptForPubkey(pSig.pubkey, script, 'verify');\n            results.push(validator(pSig.pubkey, hash, sig.signature));\n        }\n        return results.every(res => res === true);\n    }\n    validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n        const input = this.data.inputs[inputIndex];\n        const tapKeySig = (input || {}).tapKeySig;\n        const tapScriptSig = (input || {}).tapScriptSig;\n        if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n            throw new Error('No signatures to validate');\n        if (typeof validator !== 'function')\n            throw new Error('Need validator function to validate signatures');\n        pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);\n        const allHashses = pubkey\n            ? getTaprootHashesForSig(inputIndex, input, this.data.inputs, pubkey, this.__CACHE)\n            : getAllTaprootHashesForSig(inputIndex, input, this.data.inputs, this.__CACHE);\n        if (!allHashses.length)\n            throw new Error('No signatures for this pubkey');\n        const tapKeyHash = allHashses.find(h => !!h.leafHash);\n        if (tapKeySig && tapKeyHash) {\n            const isValidTapkeySig = validator(tapKeyHash.pubkey, tapKeyHash.hash, tapKeySig);\n            if (!isValidTapkeySig)\n                return false;\n        }\n        if (tapScriptSig) {\n            for (const tapSig of tapScriptSig) {\n                const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));\n                if (tapSigHash) {\n                    const isValidTapScriptSig = validator(tapSig.pubkey, tapSigHash.hash, tapSig.signature);\n                    if (!isValidTapScriptSig)\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n    signAllInputsHD(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n            throw new Error('Need HDSigner to sign input');\n        }\n        const results = [];\n        for (const i of range(this.data.inputs.length)) {\n            try {\n                this.signInputHD(i, hdKeyPair, sighashTypes);\n                results.push(true);\n            }\n            catch (err) {\n                results.push(false);\n            }\n        }\n        if (results.every(v => v === false)) {\n            throw new Error('No inputs were signed');\n        }\n        return this;\n    }\n    signAllInputsHDAsync(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n        return new Promise((resolve, reject) => {\n            if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n                return reject(new Error('Need HDSigner to sign input'));\n            }\n            const results = [];\n            const promises = [];\n            for (const i of range(this.data.inputs.length)) {\n                promises.push(this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(() => {\n                    results.push(true);\n                }, () => {\n                    results.push(false);\n                }));\n            }\n            return Promise.all(promises).then(() => {\n                if (results.every(v => v === false)) {\n                    return reject(new Error('No inputs were signed'));\n                }\n                resolve();\n            });\n        });\n    }\n    signInputHD(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n            throw new Error('Need HDSigner to sign input');\n        }\n        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n        signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n        return this;\n    }\n    signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n        return new Promise((resolve, reject) => {\n            if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n                return reject(new Error('Need HDSigner to sign input'));\n            }\n            const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n            const promises = signers.map(signer => this.signInputAsync(inputIndex, signer, sighashTypes));\n            return Promise.all(promises)\n                .then(() => {\n                resolve();\n            })\n                .catch(reject);\n        });\n    }\n    signAllInputs(keyPair, sighashTypes) {\n        if (!keyPair || !keyPair.publicKey)\n            throw new Error('Need Signer to sign input');\n        const results = [];\n        for (const i of range(this.data.inputs.length)) {\n            try {\n                this.signInput(i, keyPair, sighashTypes);\n                results.push(true);\n            }\n            catch (err) {\n                results.push(false);\n            }\n        }\n        if (results.every(v => v === false)) {\n            throw new Error('No inputs were signed');\n        }\n        return this;\n    }\n    signAllInputsAsync(keyPair, sighashTypes) {\n        return new Promise((resolve, reject) => {\n            if (!keyPair || !keyPair.publicKey)\n                return reject(new Error('Need Signer to sign input'));\n            const results = [];\n            const promises = [];\n            for (const [i] of this.data.inputs.entries()) {\n                promises.push(this.signInputAsync(i, keyPair, sighashTypes).then(() => {\n                    results.push(true);\n                }, () => {\n                    results.push(false);\n                }));\n            }\n            return Promise.all(promises).then(() => {\n                if (results.every(v => v === false)) {\n                    return reject(new Error('No inputs were signed'));\n                }\n                resolve();\n            });\n        });\n    }\n    signInput(inputIndex, keyPair, sighashTypes) {\n        if (!keyPair || !keyPair.publicKey)\n            throw new Error('Need Signer to sign input');\n        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n        if ((0, bip371_1.isTaprootInput)(input)) {\n            return this._signTaprootInput(inputIndex, input, keyPair, undefined, sighashTypes);\n        }\n        return this._signInput(inputIndex, keyPair, sighashTypes);\n    }\n    signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n        if (!keyPair || !keyPair.publicKey)\n            throw new Error('Need Signer to sign input');\n        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n        if ((0, bip371_1.isTaprootInput)(input))\n            return this._signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, sighashTypes);\n        throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    }\n    getHashAndSighashType(inputIndex, publicKey, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n        const { hash, sighashType } = getHashAndSighashType(this.data.inputs, inputIndex, publicKey, this.__CACHE, sighashTypes);\n        return { hash, sighashType };\n    }\n    _signInput(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n        const { hash, sighashType } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);\n        const partialSig = [\n            {\n                pubkey: keyPair.publicKey,\n                signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n            },\n        ];\n        this.data.updateInput(inputIndex, { partialSig });\n        return this;\n    }\n    _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {\n        const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes);\n        const tapKeySig = hashesForSig\n            .filter(h => !h.leafHash)\n            .map(h => (0, bip371_1.serializeTaprootSignature)(keyPair.signSchnorr(h.hash), input.sighashType))[0];\n        const tapScriptSig = hashesForSig\n            .filter(h => !!h.leafHash)\n            .map(h => ({\n            pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n            signature: (0, bip371_1.serializeTaprootSignature)(keyPair.signSchnorr(h.hash), input.sighashType),\n            leafHash: h.leafHash,\n        }));\n        if (tapKeySig) {\n            this.data.updateInput(inputIndex, { tapKeySig });\n        }\n        if (tapScriptSig.length) {\n            this.data.updateInput(inputIndex, { tapScriptSig });\n        }\n        return this;\n    }\n    signInputAsync(inputIndex, keyPair, sighashTypes) {\n        return Promise.resolve().then(() => {\n            if (!keyPair || !keyPair.publicKey)\n                throw new Error('Need Signer to sign input');\n            const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n            if ((0, bip371_1.isTaprootInput)(input))\n                return this._signTaprootInputAsync(inputIndex, input, keyPair, undefined, sighashTypes);\n            return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n        });\n    }\n    signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n        return Promise.resolve().then(() => {\n            if (!keyPair || !keyPair.publicKey)\n                throw new Error('Need Signer to sign input');\n            const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n            if ((0, bip371_1.isTaprootInput)(input))\n                return this._signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes);\n            throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n        });\n    }\n    _signInputAsync(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n        const { hash, sighashType } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);\n        return Promise.resolve(keyPair.sign(hash)).then(signature => {\n            const partialSig = [\n                {\n                    pubkey: keyPair.publicKey,\n                    signature: bscript.signature.encode(signature, sighashType),\n                },\n            ];\n            this.data.updateInput(inputIndex, { partialSig });\n        });\n    }\n    async _signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {\n        const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHash, sighashTypes);\n        const signaturePromises = [];\n        const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n        if (tapKeyHash) {\n            const tapKeySigPromise = Promise.resolve(keyPair.signSchnorr(tapKeyHash.hash)).then(sig => {\n                return { tapKeySig: (0, bip371_1.serializeTaprootSignature)(sig, input.sighashType) };\n            });\n            signaturePromises.push(tapKeySigPromise);\n        }\n        const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n        if (tapScriptHashes.length) {\n            const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n                return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(signature => {\n                    const tapScriptSig = [\n                        {\n                            pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n                            signature: (0, bip371_1.serializeTaprootSignature)(signature, input.sighashType),\n                            leafHash: tsh.leafHash,\n                        },\n                    ];\n                    return { tapScriptSig };\n                });\n            });\n            signaturePromises.push(...tapScriptSigPromises);\n        }\n        return Promise.all(signaturePromises).then(results => {\n            results.forEach(v => this.data.updateInput(inputIndex, v));\n        });\n    }\n    checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {\n        if (typeof keyPair.signSchnorr !== 'function')\n            throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);\n        const hashesForSig = getTaprootHashesForSig(inputIndex, input, this.data.inputs, keyPair.publicKey, this.__CACHE, tapLeafHashToSign, allowedSighashTypes);\n        if (!hashesForSig || !hashesForSig.length)\n            throw new Error(`Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString('hex')}`);\n        return hashesForSig;\n    }\n    toBuffer() {\n        checkCache(this.__CACHE);\n        return this.data.toBuffer();\n    }\n    toHex() {\n        checkCache(this.__CACHE);\n        return this.data.toHex();\n    }\n    toBase64() {\n        checkCache(this.__CACHE);\n        return this.data.toBase64();\n    }\n    updateGlobal(updateData) {\n        this.data.updateGlobal(updateData);\n        return this;\n    }\n    updateInput(inputIndex, updateData) {\n        if (updateData.witnessScript)\n            checkInvalidP2WSH(updateData.witnessScript);\n        (0, bip371_1.checkTaprootInputFields)(this.data.inputs[inputIndex], updateData, 'updateInput');\n        this.data.updateInput(inputIndex, updateData);\n        if (updateData.nonWitnessUtxo) {\n            addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);\n        }\n        return this;\n    }\n    updateOutput(outputIndex, updateData) {\n        const outputData = this.data.outputs[outputIndex];\n        (0, bip371_1.checkTaprootOutputFields)(outputData, updateData, 'updateOutput');\n        this.data.updateOutput(outputIndex, updateData);\n        return this;\n    }\n    addUnknownKeyValToGlobal(keyVal) {\n        this.data.addUnknownKeyValToGlobal(keyVal);\n        return this;\n    }\n    addUnknownKeyValToInput(inputIndex, keyVal) {\n        this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n        return this;\n    }\n    addUnknownKeyValToOutput(outputIndex, keyVal) {\n        this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n        return this;\n    }\n    clearFinalizedInput(inputIndex) {\n        this.data.clearFinalizedInput(inputIndex);\n        return this;\n    }\n    verify(pubBuf, witness) {\n        const allowedSighashTypes = [\n            transaction_1.Transaction.SIGHASH_SINGLE | transaction_1.Transaction.SIGHASH_ANYONECANPAY,\n            transaction_1.Transaction.SIGHASH_ALL,\n            transaction_1.Transaction.SIGHASH_DEFAULT\n        ];\n        for (let i = 0; i < this.inputCount; i++) {\n            if ((0, bip371_1.isTaprootInput)(this.data.inputs[i])) {\n                const tweakKey = Buffer.from((0, taproot_1.taprootTweakPubkey)(pubBuf.slice(1))[0]);\n                const bufferReader = new bufferutils_1.BufferReader(witness);\n                const vector = bufferReader.readVector();\n                const signer = {\n                    publicKey: tweakKey,\n                    sign(hash) {\n                        return Buffer.alloc(64);\n                    },\n                    signSchnorr(hash) {\n                        return Buffer.alloc(64);\n                    },\n                };\n                const hashesForSig = this.checkTaprootHashesForSig(i, this.data.inputs[i], signer, undefined, allowedSighashTypes);\n                const messageToSign = hashesForSig.filter(h => !h.leafHash)[0].hash;\n                if (!schnorr.verify(crypto_lib_1.base.toHex(vector[0]), crypto_lib_1.base.toHex(messageToSign), crypto_lib_1.base.toHex(tweakKey))) {\n                    return false;\n                }\n            }\n            else {\n                const { hash } = getHashAndSighashType(this.data.inputs, i, pubBuf, this.__CACHE, allowedSighashTypes);\n                const bufferReader = new bufferutils_1.BufferReader(witness);\n                const vector = bufferReader.readVector();\n                const signature = script_1.signature.decode(vector[0]).signature;\n                const witnessPubKey = vector[1];\n                if (!pubBuf.equals(witnessPubKey)) {\n                    throw Error(\"pubKey error\");\n                }\n                if (!crypto_lib_1.signUtil.secp256k1.verifyWithNoRecovery(hash, signature, pubBuf)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\nexports.Psbt = Psbt;\nconst transactionFromBuffer = (buffer) => new PsbtTransaction(buffer);\nclass PsbtTransaction {\n    constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n        this.tx = transaction_1.Transaction.fromBuffer(buffer);\n        checkTxEmpty(this.tx);\n        Object.defineProperty(this, 'tx', {\n            enumerable: false,\n            writable: true,\n        });\n    }\n    getInputOutputCounts() {\n        return {\n            inputCount: this.tx.ins.length,\n            outputCount: this.tx.outs.length,\n        };\n    }\n    addInput(input) {\n        if (input.hash === undefined ||\n            input.index === undefined ||\n            (!Buffer.isBuffer(input.hash) &&\n                typeof input.hash !== 'string') ||\n            typeof input.index !== 'number') {\n            throw new Error('Error adding input.');\n        }\n        const hash = typeof input.hash === 'string'\n            ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))\n            : input.hash;\n        this.tx.addInput(hash, input.index, input.sequence);\n    }\n    addOutput(output) {\n        if (output.script === undefined ||\n            output.value === undefined ||\n            !Buffer.isBuffer(output.script) ||\n            typeof output.value !== 'number') {\n            throw new Error('Error adding output.');\n        }\n        this.tx.addOutput(output.script, output.value);\n    }\n    toBuffer() {\n        return this.tx.toBuffer();\n    }\n}\nfunction canFinalize(input, script, scriptType) {\n    switch (scriptType) {\n        case 'pubkey':\n        case 'pubkeyhash':\n        case 'witnesspubkeyhash':\n            return hasSigs(1, input.partialSig);\n        case 'multisig':\n            const p2ms = payments.p2ms({ output: script });\n            return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n        default:\n            return false;\n    }\n}\nfunction checkCache(cache) {\n    if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n        throw new Error('Not BIP174 compliant, can not export');\n    }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n    if (!partialSig)\n        return false;\n    let sigs;\n    if (pubkeys) {\n        sigs = pubkeys\n            .map(pkey => {\n            const pubkey = compressPubkey(pkey);\n            return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n        })\n            .filter(v => !!v);\n    }\n    else {\n        sigs = partialSig;\n    }\n    if (sigs.length > neededSigs)\n        throw new Error('Too many signatures');\n    return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n    return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n    return (d) => {\n        if (!d.masterFingerprint.equals(root.fingerprint))\n            return false;\n        if (!root.derivePath(d.path).publicKey.equals(d.pubkey))\n            return false;\n        return true;\n    };\n}\nfunction check32Bit(num) {\n    if (typeof num !== 'number' ||\n        num !== Math.floor(num) ||\n        num > 0xffffffff ||\n        num < 0) {\n        throw new Error('Invalid 32 bit integer');\n    }\n}\nfunction checkFees(psbt, cache, opts) {\n    const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n    const vsize = cache.__EXTRACTED_TX.virtualSize();\n    const satoshis = feeRate * vsize;\n    if (feeRate >= opts.maximumFeeRate) {\n        throw new Error(`Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n            `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n            `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n            `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n            `pass true to the first arg of extractTransaction.`);\n    }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n    inputs.forEach(input => {\n        const throws = (0, bip371_1.isTaprootInput)(input)\n            ? (0, bip371_1.checkTaprootInputForSigs)(input, action)\n            : (0, psbtutils_1.checkInputForSig)(input, action);\n        if (throws)\n            throw new Error('Can not modify transaction, signatures exist.');\n    });\n}\nfunction checkPartialSigSighashes(input) {\n    if (!input.sighashType || !input.partialSig)\n        return;\n    const { partialSig, sighashType } = input;\n    partialSig.forEach(pSig => {\n        const { hashType } = bscript.signature.decode(pSig.signature);\n        if (sighashType !== hashType) {\n            throw new Error('Signature sighash does not match input sighash type');\n        }\n    });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n    if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {\n        throw new Error(`Can not ${action} for this input with the key ${pubkey.toString('hex')}`);\n    }\n}\nfunction checkTxEmpty(tx) {\n    const isEmpty = tx.ins.every(input => input.script &&\n        input.script.length === 0 &&\n        input.witness &&\n        input.witness.length === 0);\n    if (!isEmpty) {\n        throw new Error('Format Error: Transaction ScriptSigs are not empty');\n    }\n}\nfunction checkTxForDupeIns(tx, cache) {\n    tx.ins.forEach(input => {\n        checkTxInputCache(cache, input);\n    });\n}\nfunction checkTxInputCache(cache, input) {\n    const key = (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') + ':' + input.index;\n    if (cache.__TX_IN_CACHE[key])\n        throw new Error('Duplicate input detected.');\n    cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n    return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n        const redeemScriptOutput = payment({\n            redeem: { output: redeemScript },\n        }).output;\n        if (!scriptPubKey.equals(redeemScriptOutput)) {\n            throw new Error(`${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`);\n        }\n    };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(payments.p2wsh, 'Witness script');\nfunction getTxCacheValue(key, name, inputs, c) {\n    if (!inputs.every(isFinalized))\n        throw new Error(`PSBT must be finalized to calculate ${name}`);\n    if (key === '__FEE_RATE' && c.__FEE_RATE)\n        return c.__FEE_RATE;\n    if (key === '__FEE' && c.__FEE)\n        return c.__FEE;\n    let tx;\n    let mustFinalize = true;\n    if (c.__EXTRACTED_TX) {\n        tx = c.__EXTRACTED_TX;\n        mustFinalize = false;\n    }\n    else {\n        tx = c.__TX.clone();\n    }\n    inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n    if (key === '__FEE_RATE')\n        return c.__FEE_RATE;\n    else if (key === '__FEE')\n        return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n    const scriptType = classifyScript(script);\n    if (!canFinalize(input, script, scriptType))\n        throw new Error(`Can not finalize input #${inputIndex}`);\n    return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH);\n}\nfunction prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {\n    let finalScriptSig;\n    let finalScriptWitness;\n    const payment = getPayment(script, scriptType, partialSig);\n    const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n    const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n    if (isSegwit) {\n        if (p2wsh) {\n            finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(p2wsh.witness);\n        }\n        else {\n            finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(payment.witness);\n        }\n        if (p2sh) {\n            finalScriptSig = p2sh.input;\n        }\n    }\n    else {\n        if (p2sh) {\n            finalScriptSig = p2sh.input;\n        }\n        else {\n            finalScriptSig = payment.input;\n        }\n    }\n    return {\n        finalScriptSig,\n        finalScriptWitness,\n    };\n}\nfunction getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {\n    const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n    const { hash, sighashType, script } = getHashForSig(inputIndex, input, cache, false, sighashTypes);\n    checkScriptForPubkey(pubkey, script, 'sign');\n    return {\n        hash,\n        sighashType,\n    };\n}\nexports.getHashAndSighashType = getHashAndSighashType;\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n    const unsignedTx = cache.__TX;\n    const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n    checkSighashTypeAllowed(sighashType, sighashTypes);\n    let hash;\n    let prevout;\n    if (input.nonWitnessUtxo) {\n        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n        const prevoutHash = unsignedTx.ins[inputIndex].hash;\n        const utxoHash = nonWitnessUtxoTx.getHash();\n        if (!prevoutHash.equals(utxoHash)) {\n            throw new Error(`Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`);\n        }\n        const prevoutIndex = unsignedTx.ins[inputIndex].index;\n        prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n    }\n    else if (input.witnessUtxo) {\n        prevout = input.witnessUtxo;\n    }\n    else {\n        throw new Error('Need a Utxo input item for signing');\n    }\n    const { meaningfulScript, type } = getMeaningfulScript(prevout.script, inputIndex, 'input', input.redeemScript, input.witnessScript);\n    if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n        hash = unsignedTx.hashForWitnessV0(inputIndex, meaningfulScript, prevout.value, sighashType);\n    }\n    else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {\n        const signingScript = payments.p2pkh({ hash: meaningfulScript.slice(2) })\n            .output;\n        hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);\n    }\n    else {\n        if (input.nonWitnessUtxo === undefined &&\n            cache.__UNSAFE_SIGN_NONSEGWIT === false)\n            throw new Error(`Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n                `${meaningfulScript.toString('hex')}`);\n        if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n            console.warn('Warning: Signing non-segwit inputs without the full parent transaction ' +\n                'means there is a chance that a miner could feed you incorrect information ' +\n                \"to trick you into paying large fees. This behavior is the same as Psbt's predecesor \" +\n                '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n                'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n                'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n                '*********************');\n        hash = unsignedTx.hashForSignature(inputIndex, meaningfulScript, sighashType);\n    }\n    return {\n        script: meaningfulScript,\n        sighashType,\n        hash,\n    };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n    const allPublicKeys = [];\n    if (input.tapInternalKey) {\n        const outputKey = (0, bip371_1.tweakInternalPubKey)(inputIndex, input);\n        allPublicKeys.push(outputKey);\n    }\n    if (input.tapScriptSig) {\n        const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n        allPublicKeys.push(...tapScriptPubkeys);\n    }\n    const allHashes = allPublicKeys.map(pubicKey => getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache));\n    return allHashes.flat();\n}\nfunction getTaprootHashesForSig(inputIndex, input, inputs, pubkey, cache, tapLeafHashToSign, allowedSighashTypes) {\n    const unsignedTx = cache.__TX;\n    const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;\n    checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n    const prevOuts = inputs.map((i, index) => getScriptAndAmountFromUtxo(index, i, cache));\n    const signingScripts = prevOuts.map(o => o.script);\n    const values = prevOuts.map(o => o.value);\n    const hashes = [];\n    if (input.tapInternalKey && !tapLeafHashToSign) {\n        const outputKey = (0, bip371_1.tweakInternalPubKey)(inputIndex, input);\n        if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {\n            const tapKeyHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType);\n            hashes.push({ pubkey, hash: tapKeyHash });\n        }\n    }\n    const tapLeafHashes = (input.tapLeafScript || [])\n        .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))\n        .map(tapLeaf => {\n        const hash = (0, bip341_1.tapleafHash)({\n            output: tapLeaf.script,\n            version: tapLeaf.leafVersion,\n        });\n        return Object.assign({ hash }, tapLeaf);\n    })\n        .filter(tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash))\n        .map(tapLeaf => {\n        const tapScriptHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, transaction_1.Transaction.SIGHASH_DEFAULT, tapLeaf.hash);\n        return {\n            pubkey,\n            hash: tapScriptHash,\n            leafHash: tapLeaf.hash,\n        };\n    });\n    return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n    if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n        const str = sighashTypeToString(sighashType);\n        throw new Error(`Sighash type is not allowed. Retry the sign method passing the ` +\n            `sighashTypes array of whitelisted types. Sighash type: ${str}`);\n    }\n}\nfunction getPayment(script, scriptType, partialSig) {\n    let payment;\n    switch (scriptType) {\n        case 'multisig':\n            const sigs = getSortedSigs(script, partialSig);\n            payment = payments.p2ms({\n                output: script,\n                signatures: sigs,\n            });\n            break;\n        case 'pubkey':\n            payment = payments.p2pk({\n                output: script,\n                signature: partialSig[0].signature,\n            });\n            break;\n        case 'pubkeyhash':\n            payment = payments.p2pkh({\n                output: script,\n                pubkey: partialSig[0].pubkey,\n                signature: partialSig[0].signature,\n            });\n            break;\n        case 'witnesspubkeyhash':\n            payment = payments.p2wpkh({\n                output: script,\n                pubkey: partialSig[0].pubkey,\n                signature: partialSig[0].signature,\n            });\n            break;\n    }\n    return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n    const unsignedTx = cache.__TX;\n    const res = {\n        script: null,\n        isSegwit: false,\n        isP2SH: false,\n        isP2WSH: false,\n    };\n    res.isP2SH = !!input.redeemScript;\n    res.isP2WSH = !!input.witnessScript;\n    if (input.witnessScript) {\n        res.script = input.witnessScript;\n    }\n    else if (input.redeemScript) {\n        res.script = input.redeemScript;\n    }\n    else {\n        if (input.nonWitnessUtxo) {\n            const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n            const prevoutIndex = unsignedTx.ins[inputIndex].index;\n            res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n        }\n        else if (input.witnessUtxo) {\n            res.script = input.witnessUtxo.script;\n        }\n    }\n    if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {\n        res.isSegwit = true;\n    }\n    return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n    const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n    if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n        throw new Error('Need bip32Derivation to sign with HD');\n    }\n    const myDerivations = input.bip32Derivation\n        .map(bipDv => {\n        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n            return bipDv;\n        }\n        else {\n            return;\n        }\n    })\n        .filter(v => !!v);\n    if (myDerivations.length === 0) {\n        throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');\n    }\n    const signers = myDerivations.map(bipDv => {\n        const node = hdKeyPair.derivePath(bipDv.path);\n        if (!bipDv.pubkey.equals(node.publicKey)) {\n            throw new Error('pubkey did not match bip32Derivation');\n        }\n        return node;\n    });\n    return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n    const p2ms = payments.p2ms({ output: script });\n    return p2ms\n        .pubkeys.map(pk => {\n        return (partialSig.filter(ps => {\n            return ps.pubkey.equals(pk);\n        })[0] || {}).signature;\n    })\n        .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n    let offset = 0;\n    function readSlice(n) {\n        offset += n;\n        return buffer.slice(offset - n, offset);\n    }\n    function readVarInt() {\n        const vi = varuint.decode(buffer, offset);\n        offset += varuint.decode.bytes;\n        return vi;\n    }\n    function readVarSlice() {\n        return readSlice(readVarInt());\n    }\n    function readVector() {\n        const count = readVarInt();\n        const vector = [];\n        for (let i = 0; i < count; i++)\n            vector.push(readVarSlice());\n        return vector;\n    }\n    return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n    let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n        ? 'SIGHASH_ANYONECANPAY | '\n        : '';\n    const sigMod = sighashType & 0x1f;\n    switch (sigMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n            text += 'SIGHASH_ALL';\n            break;\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n            text += 'SIGHASH_SINGLE';\n            break;\n        case transaction_1.Transaction.SIGHASH_NONE:\n            text += 'SIGHASH_NONE';\n            break;\n    }\n    return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n    cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n    const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n    cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n    const self = cache;\n    const selfIndex = inputIndex;\n    delete input.nonWitnessUtxo;\n    Object.defineProperty(input, 'nonWitnessUtxo', {\n        enumerable: true,\n        get() {\n            const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n            const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n            if (buf !== undefined) {\n                return buf;\n            }\n            else {\n                const newBuf = txCache.toBuffer();\n                self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n                return newBuf;\n            }\n        },\n        set(data) {\n            self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n        },\n    });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n    let inputAmount = 0;\n    inputs.forEach((input, idx) => {\n        if (mustFinalize && input.finalScriptSig)\n            tx.ins[idx].script = input.finalScriptSig;\n        if (mustFinalize && input.finalScriptWitness) {\n            tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);\n        }\n        if (input.witnessUtxo) {\n            inputAmount += input.witnessUtxo.value;\n        }\n        else if (input.nonWitnessUtxo) {\n            const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n            const vout = tx.ins[idx].index;\n            const out = nwTx.outs[vout];\n            inputAmount += out.value;\n        }\n    });\n    const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n    const fee = inputAmount - outputAmount;\n    if (fee < 0) {\n        throw new Error('Outputs are spending more than Inputs');\n    }\n    const bytes = tx.virtualSize();\n    cache.__FEE = fee;\n    cache.__EXTRACTED_TX = tx;\n    cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n    const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n    if (!c[inputIndex]) {\n        addNonWitnessTxCache(cache, input, inputIndex);\n    }\n    return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n    const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n    return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n    if (input.witnessUtxo !== undefined) {\n        return {\n            script: input.witnessUtxo.script,\n            value: input.witnessUtxo.value,\n        };\n    }\n    else if (input.nonWitnessUtxo !== undefined) {\n        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n        const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n        return { script: o.script, value: o.value };\n    }\n    else {\n        throw new Error(\"Can't find pubkey in input without Utxo data\");\n    }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n    const script = getScriptFromUtxo(inputIndex, input, cache);\n    const { meaningfulScript } = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript, input.witnessScript);\n    return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n    const script = cache.__TX.outs[outputIndex].script;\n    const { meaningfulScript } = getMeaningfulScript(script, outputIndex, 'output', output.redeemScript, output.witnessScript);\n    return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n    if (!finalScript)\n        return;\n    const decomp = bscript.decompile(finalScript);\n    if (!decomp)\n        return;\n    const lastItem = decomp[decomp.length - 1];\n    if (!Buffer.isBuffer(lastItem) ||\n        isPubkeyLike(lastItem) ||\n        isSigLike(lastItem))\n        return;\n    const sDecomp = bscript.decompile(lastItem);\n    if (!sDecomp)\n        return;\n    return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n    if (!finalScript)\n        return;\n    const decomp = scriptWitnessToWitnessStack(finalScript);\n    const lastItem = decomp[decomp.length - 1];\n    if (isPubkeyLike(lastItem))\n        return;\n    const sDecomp = bscript.decompile(lastItem);\n    if (!sDecomp)\n        return;\n    return lastItem;\n}\nfunction compressPubkey(pubkey) {\n    if (pubkey.length === 65) {\n        const parity = pubkey[64] & 1;\n        const newKey = pubkey.slice(0, 33);\n        newKey[0] = 2 | parity;\n        return newKey;\n    }\n    return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n    return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n    return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {\n    const isP2SH = (0, psbtutils_1.isP2SHScript)(script);\n    const isP2SHP2WSH = isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);\n    const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);\n    if (isP2SH && redeemScript === undefined)\n        throw new Error('scriptPubkey is P2SH but redeemScript missing');\n    if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n        throw new Error('scriptPubkey or redeemScript is P2WSH but witnessScript missing');\n    let meaningfulScript;\n    if (isP2SHP2WSH) {\n        meaningfulScript = witnessScript;\n        checkRedeemScript(index, script, redeemScript, ioType);\n        checkWitnessScript(index, redeemScript, witnessScript, ioType);\n        checkInvalidP2WSH(meaningfulScript);\n    }\n    else if (isP2WSH) {\n        meaningfulScript = witnessScript;\n        checkWitnessScript(index, script, witnessScript, ioType);\n        checkInvalidP2WSH(meaningfulScript);\n    }\n    else if (isP2SH) {\n        meaningfulScript = redeemScript;\n        checkRedeemScript(index, script, redeemScript, ioType);\n    }\n    else {\n        meaningfulScript = script;\n    }\n    return {\n        meaningfulScript,\n        type: isP2SHP2WSH\n            ? 'p2sh-p2wsh'\n            : isP2SH\n                ? 'p2sh'\n                : isP2WSH\n                    ? 'p2wsh'\n                    : 'raw',\n    };\n}\nfunction checkInvalidP2WSH(script) {\n    if ((0, psbtutils_1.isP2WPKH)(script) || (0, psbtutils_1.isP2SHScript)(script)) {\n        throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n    }\n}\nfunction classifyScript(script) {\n    if ((0, psbtutils_1.isP2WPKH)(script))\n        return 'witnesspubkeyhash';\n    if ((0, psbtutils_1.isP2PKH)(script))\n        return 'pubkeyhash';\n    if ((0, psbtutils_1.isP2MS)(script))\n        return 'multisig';\n    if ((0, psbtutils_1.isP2PK)(script))\n        return 'pubkey';\n    return 'nonstandard';\n}\nfunction range(n) {\n    return [...Array(n).keys()];\n}\n//# sourceMappingURL=psbt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wc2J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxZQUFZO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxtR0FBZTtBQUN0Qyw2QkFBNkIsbUJBQU8sQ0FBQywySEFBMkI7QUFDaEUsZ0JBQWdCLG1CQUFPLENBQUMscUdBQWdCO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLDJGQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLG1HQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDZGQUFZO0FBQ3ZDLDhCQUE4QixtQkFBTyxDQUFDLG1HQUFZO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLDJHQUFtQjtBQUM1Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBVTtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyxtR0FBZTtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyxtR0FBZTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyx5R0FBa0I7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLHlGQUFVO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQ7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekMsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLDREQUE0RCxXQUFXLDJCQUEyQjtBQUNsRyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdEQUFnRCxZQUFZO0FBQzVELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxXQUFXO0FBQ3JGO0FBQ0E7QUFDQSx1REFBdUQsWUFBWSxlQUFlLGtDQUFrQztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw2QkFBNkI7QUFDdkYsOEJBQThCLFNBQVM7QUFDdkMsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRLDhCQUE4Qix1QkFBdUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUMsU0FBUztBQUNUO0FBQ0EsK0JBQStCLG1CQUFtQixNQUFNLFFBQVEsR0FBRyxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEtBQUs7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQsbUJBQW1CLGlDQUFpQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtCQUErQixNQUFNO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL3BzYnQuanM/ZThiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRIYXNoQW5kU2lnaGFzaFR5cGUgPSBleHBvcnRzLlBzYnQgPSB2b2lkIDA7XG5jb25zdCBwc2J0XzEgPSByZXF1aXJlKFwiLi9iaXAxNzQvcHNidFwiKTtcbmNvbnN0IHZhcnVpbnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmlwMTc0L2NvbnZlcnRlci92YXJpbnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2JpcDE3NC91dGlsc1wiKTtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3NcIik7XG5jb25zdCBidWZmZXJ1dGlsc18xID0gcmVxdWlyZShcIi4vYnVmZmVydXRpbHNcIik7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZShcIi4vbmV0d29ya3NcIik7XG5jb25zdCBwYXltZW50cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9wYXltZW50c1wiKSk7XG5jb25zdCBiaXAzNDFfMSA9IHJlcXVpcmUoXCIuL3BheW1lbnRzL2JpcDM0MVwiKTtcbmNvbnN0IGJzY3JpcHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2NyaXB0XCIpKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IGJpcDM3MV8xID0gcmVxdWlyZShcIi4vcHNidC9iaXAzNzFcIik7XG5jb25zdCBwc2J0dXRpbHNfMSA9IHJlcXVpcmUoXCIuL3BzYnQvcHNidHV0aWxzXCIpO1xuY29uc3QgY3J5cHRvX2xpYl8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NyeXB0by1saWJcIik7XG5jb25zdCBzY3JpcHRfMSA9IHJlcXVpcmUoXCIuL3NjcmlwdFwiKTtcbmNvbnN0IHRhcHJvb3RfMSA9IHJlcXVpcmUoXCIuLi90YXByb290XCIpO1xuY29uc3Qgc2Nobm9yciA9IGNyeXB0b19saWJfMS5zaWduVXRpbC5zY2hub3JyLnNlY3AyNTZrMS5zY2hub3JyO1xuY29uc3QgREVGQVVMVF9PUFRTID0ge1xuICAgIG5ldHdvcms6IG5ldHdvcmtzXzEuYml0Y29pbixcbiAgICBtYXhpbXVtRmVlUmF0ZTogNTAwMCxcbn07XG5jbGFzcyBQc2J0IHtcbiAgICBzdGF0aWMgZnJvbUJhc2U2NChkYXRhLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlciwgb3B0cyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGRhdGEsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCAnaGV4Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmZmVyLCBvcHRzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgcHNidEJhc2UgPSBwc2J0XzEuUHNidC5mcm9tQnVmZmVyKGJ1ZmZlciwgdHJhbnNhY3Rpb25Gcm9tQnVmZmVyKTtcbiAgICAgICAgY29uc3QgcHNidCA9IG5ldyBQc2J0KG9wdHMsIHBzYnRCYXNlKTtcbiAgICAgICAgY2hlY2tUeEZvckR1cGVJbnMocHNidC5fX0NBQ0hFLl9fVFgsIHBzYnQuX19DQUNIRSk7XG4gICAgICAgIHJldHVybiBwc2J0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30sIGRhdGEgPSBuZXcgcHNidF8xLlBzYnQobmV3IFBzYnRUcmFuc2FjdGlvbigpKSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVFMsIG9wdHMpO1xuICAgICAgICB0aGlzLl9fQ0FDSEUgPSB7XG4gICAgICAgICAgICBfX05PTl9XSVRORVNTX1VUWE9fVFhfQ0FDSEU6IFtdLFxuICAgICAgICAgICAgX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRTogW10sXG4gICAgICAgICAgICBfX1RYX0lOX0NBQ0hFOiB7fSxcbiAgICAgICAgICAgIF9fVFg6IHRoaXMuZGF0YS5nbG9iYWxNYXAudW5zaWduZWRUeC50eCxcbiAgICAgICAgICAgIF9fVU5TQUZFX1NJR05fTk9OU0VHV0lUOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhpcy5zZXRWZXJzaW9uKDIpO1xuICAgICAgICBjb25zdCBkcGV3ID0gKG9iaiwgYXR0ciwgZW51bWVyYWJsZSwgd3JpdGFibGUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGF0dHIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGUsXG4gICAgICAgICAgICB3cml0YWJsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRwZXcodGhpcywgJ19fQ0FDSEUnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRwZXcodGhpcywgJ29wdHMnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGdldCBpbnB1dENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmlucHV0cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX0NBQ0hFLl9fVFgudmVyc2lvbjtcbiAgICB9XG4gICAgc2V0IHZlcnNpb24odmVyc2lvbikge1xuICAgICAgICB0aGlzLnNldFZlcnNpb24odmVyc2lvbik7XG4gICAgfVxuICAgIGdldCBsb2NrdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19DQUNIRS5fX1RYLmxvY2t0aW1lO1xuICAgIH1cbiAgICBzZXQgbG9ja3RpbWUobG9ja3RpbWUpIHtcbiAgICAgICAgdGhpcy5zZXRMb2NrdGltZShsb2NrdGltZSk7XG4gICAgfVxuICAgIGdldCB0eElucHV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19DQUNIRS5fX1RYLmlucy5tYXAoaW5wdXQgPT4gKHtcbiAgICAgICAgICAgIGhhc2g6ICgwLCBidWZmZXJ1dGlsc18xLmNsb25lQnVmZmVyKShpbnB1dC5oYXNoKSxcbiAgICAgICAgICAgIGluZGV4OiBpbnB1dC5pbmRleCxcbiAgICAgICAgICAgIHNlcXVlbmNlOiBpbnB1dC5zZXF1ZW5jZSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBnZXQgdHhPdXRwdXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX0NBQ0hFLl9fVFgub3V0cy5tYXAob3V0cHV0ID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gKDAsIGFkZHJlc3NfMS5mcm9tT3V0cHV0U2NyaXB0KShvdXRwdXQuc2NyaXB0LCB0aGlzLm9wdHMubmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQ6ICgwLCBidWZmZXJ1dGlsc18xLmNsb25lQnVmZmVyKShvdXRwdXQuc2NyaXB0KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3V0cHV0LnZhbHVlLFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tYmluZSguLi50aG9zZSkge1xuICAgICAgICB0aGlzLmRhdGEuY29tYmluZSguLi50aG9zZS5tYXAobyA9PiBvLmRhdGEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCByZXMgPSBQc2J0LmZyb21CdWZmZXIodGhpcy5kYXRhLnRvQnVmZmVyKCkpO1xuICAgICAgICByZXMub3B0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vcHRzKSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHNldE1heGltdW1GZWVSYXRlKHNhdG9zaGlQZXJCeXRlKSB7XG4gICAgICAgIGNoZWNrMzJCaXQoc2F0b3NoaVBlckJ5dGUpO1xuICAgICAgICB0aGlzLm9wdHMubWF4aW11bUZlZVJhdGUgPSBzYXRvc2hpUGVyQnl0ZTtcbiAgICB9XG4gICAgc2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIGNoZWNrMzJCaXQodmVyc2lvbik7XG4gICAgICAgIGNoZWNrSW5wdXRzRm9yUGFydGlhbFNpZyh0aGlzLmRhdGEuaW5wdXRzLCAnc2V0VmVyc2lvbicpO1xuICAgICAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgICAgICBjLl9fVFgudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIGMuX19FWFRSQUNURURfVFggPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRMb2NrdGltZShsb2NrdGltZSkge1xuICAgICAgICBjaGVjazMyQml0KGxvY2t0aW1lKTtcbiAgICAgICAgY2hlY2tJbnB1dHNGb3JQYXJ0aWFsU2lnKHRoaXMuZGF0YS5pbnB1dHMsICdzZXRMb2NrdGltZScpO1xuICAgICAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgICAgICBjLl9fVFgubG9ja3RpbWUgPSBsb2NrdGltZTtcbiAgICAgICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldElucHV0U2VxdWVuY2UoaW5wdXRJbmRleCwgc2VxdWVuY2UpIHtcbiAgICAgICAgY2hlY2szMkJpdChzZXF1ZW5jZSk7XG4gICAgICAgIGNoZWNrSW5wdXRzRm9yUGFydGlhbFNpZyh0aGlzLmRhdGEuaW5wdXRzLCAnc2V0SW5wdXRTZXF1ZW5jZScpO1xuICAgICAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgICAgICBpZiAoYy5fX1RYLmlucy5sZW5ndGggPD0gaW5wdXRJbmRleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpbmRleCB0b28gaGlnaCcpO1xuICAgICAgICB9XG4gICAgICAgIGMuX19UWC5pbnNbaW5wdXRJbmRleF0uc2VxdWVuY2UgPSBzZXF1ZW5jZTtcbiAgICAgICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZElucHV0cyhpbnB1dERhdGFzKSB7XG4gICAgICAgIGlucHV0RGF0YXMuZm9yRWFjaChpbnB1dERhdGEgPT4gdGhpcy5hZGRJbnB1dChpbnB1dERhdGEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZElucHV0KGlucHV0RGF0YSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgfHxcbiAgICAgICAgICAgICFpbnB1dERhdGEgfHxcbiAgICAgICAgICAgIGlucHV0RGF0YS5oYXNoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGlucHV0RGF0YS5pbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LmFkZElucHV0LiBgICtcbiAgICAgICAgICAgICAgICBgUmVxdWlyZXMgc2luZ2xlIG9iamVjdCB3aXRoIGF0IGxlYXN0IFtoYXNoXSBhbmQgW2luZGV4XWApO1xuICAgICAgICB9XG4gICAgICAgICgwLCBiaXAzNzFfMS5jaGVja1RhcHJvb3RJbnB1dEZpZWxkcykoaW5wdXREYXRhLCBpbnB1dERhdGEsICdhZGRJbnB1dCcpO1xuICAgICAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ2FkZElucHV0Jyk7XG4gICAgICAgIGlmIChpbnB1dERhdGEud2l0bmVzc1NjcmlwdClcbiAgICAgICAgICAgIGNoZWNrSW52YWxpZFAyV1NIKGlucHV0RGF0YS53aXRuZXNzU2NyaXB0KTtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICAgICAgdGhpcy5kYXRhLmFkZElucHV0KGlucHV0RGF0YSk7XG4gICAgICAgIGNvbnN0IHR4SW4gPSBjLl9fVFguaW5zW2MuX19UWC5pbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNoZWNrVHhJbnB1dENhY2hlKGMsIHR4SW4pO1xuICAgICAgICBjb25zdCBpbnB1dEluZGV4ID0gdGhpcy5kYXRhLmlucHV0cy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgICAgIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgICAgICAgICAgYWRkTm9uV2l0bmVzc1R4Q2FjaGUodGhpcy5fX0NBQ0hFLCBpbnB1dCwgaW5wdXRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgYy5fX0ZFRSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYy5fX0ZFRV9SQVRFID0gdW5kZWZpbmVkO1xuICAgICAgICBjLl9fRVhUUkFDVEVEX1RYID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkT3V0cHV0cyhvdXRwdXREYXRhcykge1xuICAgICAgICBvdXRwdXREYXRhcy5mb3JFYWNoKG91dHB1dERhdGEgPT4gdGhpcy5hZGRPdXRwdXQob3V0cHV0RGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkT3V0cHV0KG91dHB1dERhdGEpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxIHx8XG4gICAgICAgICAgICAhb3V0cHV0RGF0YSB8fFxuICAgICAgICAgICAgb3V0cHV0RGF0YS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAob3V0cHV0RGF0YS5hZGRyZXNzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvdXRwdXREYXRhLnNjcmlwdCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgUHNidC5hZGRPdXRwdXQuIGAgK1xuICAgICAgICAgICAgICAgIGBSZXF1aXJlcyBzaW5nbGUgb2JqZWN0IHdpdGggYXQgbGVhc3QgW3NjcmlwdCBvciBhZGRyZXNzXSBhbmQgW3ZhbHVlXWApO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrSW5wdXRzRm9yUGFydGlhbFNpZyh0aGlzLmRhdGEuaW5wdXRzLCAnYWRkT3V0cHV0Jyk7XG4gICAgICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gb3V0cHV0RGF0YTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgeyBuZXR3b3JrIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSAoMCwgYWRkcmVzc18xLnRvT3V0cHV0U2NyaXB0KShhZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIG91dHB1dERhdGEgPSBPYmplY3QuYXNzaWduKG91dHB1dERhdGEsIHsgc2NyaXB0IH0pO1xuICAgICAgICB9XG4gICAgICAgICgwLCBiaXAzNzFfMS5jaGVja1RhcHJvb3RPdXRwdXRGaWVsZHMpKG91dHB1dERhdGEsIG91dHB1dERhdGEsICdhZGRPdXRwdXQnKTtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICAgICAgdGhpcy5kYXRhLmFkZE91dHB1dChvdXRwdXREYXRhKTtcbiAgICAgICAgYy5fX0ZFRSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYy5fX0ZFRV9SQVRFID0gdW5kZWZpbmVkO1xuICAgICAgICBjLl9fRVhUUkFDVEVEX1RYID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXh0cmFjdFRyYW5zYWN0aW9uKGRpc2FibGVGZWVDaGVjaykge1xuICAgICAgICBpZiAoIXRoaXMuZGF0YS5pbnB1dHMuZXZlcnkoaXNGaW5hbGl6ZWQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZmluYWxpemVkJyk7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLl9fQ0FDSEU7XG4gICAgICAgIGlmICghZGlzYWJsZUZlZUNoZWNrKSB7XG4gICAgICAgICAgICBjaGVja0ZlZXModGhpcywgYywgdGhpcy5vcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYy5fX0VYVFJBQ1RFRF9UWClcbiAgICAgICAgICAgIHJldHVybiBjLl9fRVhUUkFDVEVEX1RYO1xuICAgICAgICBjb25zdCB0eCA9IGMuX19UWC5jbG9uZSgpO1xuICAgICAgICBpbnB1dEZpbmFsaXplR2V0QW10cyh0aGlzLmRhdGEuaW5wdXRzLCB0eCwgYywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgZ2V0RmVlUmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGdldFR4Q2FjaGVWYWx1ZSgnX19GRUVfUkFURScsICdmZWUgcmF0ZScsIHRoaXMuZGF0YS5pbnB1dHMsIHRoaXMuX19DQUNIRSk7XG4gICAgfVxuICAgIGdldEZlZSgpIHtcbiAgICAgICAgcmV0dXJuIGdldFR4Q2FjaGVWYWx1ZSgnX19GRUUnLCAnZmVlJywgdGhpcy5kYXRhLmlucHV0cywgdGhpcy5fX0NBQ0hFKTtcbiAgICB9XG4gICAgZmluYWxpemVBbGxJbnB1dHMoKSB7XG4gICAgICAgICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuZGF0YS5pbnB1dHMsIDApO1xuICAgICAgICByYW5nZSh0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCkuZm9yRWFjaChpZHggPT4gdGhpcy5maW5hbGl6ZUlucHV0KGlkeCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluYWxpemVJbnB1dChpbnB1dEluZGV4LCBmaW5hbFNjcmlwdHNGdW5jKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVRhcHJvb3RJbnB1dChpbnB1dEluZGV4LCBpbnB1dCwgdW5kZWZpbmVkLCBmaW5hbFNjcmlwdHNGdW5jKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplSW5wdXQoaW5wdXRJbmRleCwgaW5wdXQsIGZpbmFsU2NyaXB0c0Z1bmMpO1xuICAgIH1cbiAgICBmaW5hbGl6ZVRhcHJvb3RJbnB1dChpbnB1dEluZGV4LCB0YXBMZWFmSGFzaFRvRmluYWxpemUsIGZpbmFsU2NyaXB0c0Z1bmMgPSBiaXAzNzFfMS50YXBTY3JpcHRGaW5hbGl6ZXIpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICAgICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVGFwcm9vdElucHV0KGlucHV0SW5kZXgsIGlucHV0LCB0YXBMZWFmSGFzaFRvRmluYWxpemUsIGZpbmFsU2NyaXB0c0Z1bmMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5hbGl6ZSBpbnB1dCAjJHtpbnB1dEluZGV4fS4gTm90IFRhcHJvb3QuYCk7XG4gICAgfVxuICAgIF9maW5hbGl6ZUlucHV0KGlucHV0SW5kZXgsIGlucHV0LCBmaW5hbFNjcmlwdHNGdW5jID0gZ2V0RmluYWxTY3JpcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2NyaXB0LCBpc1AyU0gsIGlzUDJXU0gsIGlzU2Vnd2l0IH0gPSBnZXRTY3JpcHRGcm9tSW5wdXQoaW5wdXRJbmRleCwgaW5wdXQsIHRoaXMuX19DQUNIRSk7XG4gICAgICAgIGlmICghc2NyaXB0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzY3JpcHQgZm91bmQgZm9yIGlucHV0ICMke2lucHV0SW5kZXh9YCk7XG4gICAgICAgIGNoZWNrUGFydGlhbFNpZ1NpZ2hhc2hlcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHsgZmluYWxTY3JpcHRTaWcsIGZpbmFsU2NyaXB0V2l0bmVzcyB9ID0gZmluYWxTY3JpcHRzRnVuYyhpbnB1dEluZGV4LCBpbnB1dCwgc2NyaXB0LCBpc1NlZ3dpdCwgaXNQMlNILCBpc1AyV1NIKTtcbiAgICAgICAgaWYgKGZpbmFsU2NyaXB0U2lnKVxuICAgICAgICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgZmluYWxTY3JpcHRTaWcgfSk7XG4gICAgICAgIGlmIChmaW5hbFNjcmlwdFdpdG5lc3MpXG4gICAgICAgICAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBmaW5hbFNjcmlwdFdpdG5lc3MgfSk7XG4gICAgICAgIGlmICghZmluYWxTY3JpcHRTaWcgJiYgIWZpbmFsU2NyaXB0V2l0bmVzcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBlcnJvciBmaW5hbGl6aW5nIGlucHV0ICMke2lucHV0SW5kZXh9YCk7XG4gICAgICAgIHRoaXMuZGF0YS5jbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2ZpbmFsaXplVGFwcm9vdElucHV0KGlucHV0SW5kZXgsIGlucHV0LCB0YXBMZWFmSGFzaFRvRmluYWxpemUsIGZpbmFsU2NyaXB0c0Z1bmMgPSBiaXAzNzFfMS50YXBTY3JpcHRGaW5hbGl6ZXIpIHtcbiAgICAgICAgaWYgKCFpbnB1dC53aXRuZXNzVXR4bylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmFsaXplIGlucHV0ICMke2lucHV0SW5kZXh9LiBNaXNzaW5nIHdpdGhuZXNzIHV0eG8uYCk7XG4gICAgICAgIGlmIChpbnB1dC50YXBLZXlTaWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheW1lbnQgPSBwYXltZW50cy5wMnRyKHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdCxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGlucHV0LnRhcEtleVNpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZmluYWxTY3JpcHRXaXRuZXNzID0gKDAsIHBzYnR1dGlsc18xLndpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcykocGF5bWVudC53aXRuZXNzKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IGZpbmFsU2NyaXB0V2l0bmVzcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmluYWxTY3JpcHRXaXRuZXNzIH0gPSBmaW5hbFNjcmlwdHNGdW5jKGlucHV0SW5kZXgsIGlucHV0LCB0YXBMZWFmSGFzaFRvRmluYWxpemUpO1xuICAgICAgICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgZmluYWxTY3JpcHRXaXRuZXNzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YS5jbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0SW5wdXRUeXBlKGlucHV0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gZ2V0U2NyaXB0RnJvbVV0eG8oaW5wdXRJbmRleCwgaW5wdXQsIHRoaXMuX19DQUNIRSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldE1lYW5pbmdmdWxTY3JpcHQoc2NyaXB0LCBpbnB1dEluZGV4LCAnaW5wdXQnLCBpbnB1dC5yZWRlZW1TY3JpcHQgfHwgcmVkZWVtRnJvbUZpbmFsU2NyaXB0U2lnKGlucHV0LmZpbmFsU2NyaXB0U2lnKSwgaW5wdXQud2l0bmVzc1NjcmlwdCB8fFxuICAgICAgICAgICAgcmVkZWVtRnJvbUZpbmFsV2l0bmVzc1NjcmlwdChpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MpKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHJlc3VsdC50eXBlID09PSAncmF3JyA/ICcnIDogcmVzdWx0LnR5cGUgKyAnLSc7XG4gICAgICAgIGNvbnN0IG1haW5UeXBlID0gY2xhc3NpZnlTY3JpcHQocmVzdWx0Lm1lYW5pbmdmdWxTY3JpcHQpO1xuICAgICAgICByZXR1cm4gKHR5cGUgKyBtYWluVHlwZSk7XG4gICAgfVxuICAgIGlucHV0SGFzUHVia2V5KGlucHV0SW5kZXgsIHB1YmtleSkge1xuICAgICAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgICAgICByZXR1cm4gcHVia2V5SW5JbnB1dChwdWJrZXksIGlucHV0LCBpbnB1dEluZGV4LCB0aGlzLl9fQ0FDSEUpO1xuICAgIH1cbiAgICBpbnB1dEhhc0hES2V5KGlucHV0SW5kZXgsIHJvb3QpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICAgICAgY29uc3QgZGVyaXZhdGlvbklzTWluZSA9IGJpcDMyRGVyaXZhdGlvbklzTWluZShyb290KTtcbiAgICAgICAgcmV0dXJuICghIWlucHV0LmJpcDMyRGVyaXZhdGlvbiAmJiBpbnB1dC5iaXAzMkRlcml2YXRpb24uc29tZShkZXJpdmF0aW9uSXNNaW5lKSk7XG4gICAgfVxuICAgIG91dHB1dEhhc1B1YmtleShvdXRwdXRJbmRleCwgcHVia2V5KSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9yT3V0cHV0KSh0aGlzLmRhdGEub3V0cHV0cywgb3V0cHV0SW5kZXgpO1xuICAgICAgICByZXR1cm4gcHVia2V5SW5PdXRwdXQocHVia2V5LCBvdXRwdXQsIG91dHB1dEluZGV4LCB0aGlzLl9fQ0FDSEUpO1xuICAgIH1cbiAgICBvdXRwdXRIYXNIREtleShvdXRwdXRJbmRleCwgcm9vdCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAoMCwgdXRpbHNfMS5jaGVja0Zvck91dHB1dCkodGhpcy5kYXRhLm91dHB1dHMsIG91dHB1dEluZGV4KTtcbiAgICAgICAgY29uc3QgZGVyaXZhdGlvbklzTWluZSA9IGJpcDMyRGVyaXZhdGlvbklzTWluZShyb290KTtcbiAgICAgICAgcmV0dXJuICghIW91dHB1dC5iaXAzMkRlcml2YXRpb24gJiYgb3V0cHV0LmJpcDMyRGVyaXZhdGlvbi5zb21lKGRlcml2YXRpb25Jc01pbmUpKTtcbiAgICB9XG4gICAgdmFsaWRhdGVTaWduYXR1cmVzT2ZBbGxJbnB1dHModmFsaWRhdG9yKSB7XG4gICAgICAgICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuZGF0YS5pbnB1dHMsIDApO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpLm1hcChpZHggPT4gdGhpcy52YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0KGlkeCwgdmFsaWRhdG9yKSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoZmluYWwsIHJlcykgPT4gcmVzID09PSB0cnVlICYmIGZpbmFsLCB0cnVlKTtcbiAgICB9XG4gICAgdmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dChpbnB1dEluZGV4LCB2YWxpZGF0b3IsIHB1YmtleSkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2lnbmF0dXJlc09mVGFwcm9vdElucHV0KGlucHV0SW5kZXgsIHZhbGlkYXRvciwgcHVia2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXQoaW5wdXRJbmRleCwgdmFsaWRhdG9yLCBwdWJrZXkpO1xuICAgIH1cbiAgICBfdmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dChpbnB1dEluZGV4LCB2YWxpZGF0b3IsIHB1YmtleSkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgICAgIGNvbnN0IHBhcnRpYWxTaWcgPSAoaW5wdXQgfHwge30pLnBhcnRpYWxTaWc7XG4gICAgICAgIGlmICghaW5wdXQgfHwgIXBhcnRpYWxTaWcgfHwgcGFydGlhbFNpZy5sZW5ndGggPCAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduYXR1cmVzIHRvIHZhbGlkYXRlJyk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIHZhbGlkYXRvciBmdW5jdGlvbiB0byB2YWxpZGF0ZSBzaWduYXR1cmVzJyk7XG4gICAgICAgIGNvbnN0IG15U2lncyA9IHB1YmtleVxuICAgICAgICAgICAgPyBwYXJ0aWFsU2lnLmZpbHRlcihzaWcgPT4gc2lnLnB1YmtleS5lcXVhbHMocHVia2V5KSlcbiAgICAgICAgICAgIDogcGFydGlhbFNpZztcbiAgICAgICAgaWYgKG15U2lncy5sZW5ndGggPCAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduYXR1cmVzIGZvciB0aGlzIHB1YmtleScpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGxldCBoYXNoQ2FjaGU7XG4gICAgICAgIGxldCBzY3JpcHRDYWNoZTtcbiAgICAgICAgbGV0IHNpZ2hhc2hDYWNoZTtcbiAgICAgICAgZm9yIChjb25zdCBwU2lnIG9mIG15U2lncykge1xuICAgICAgICAgICAgY29uc3Qgc2lnID0gYnNjcmlwdC5zaWduYXR1cmUuZGVjb2RlKHBTaWcuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFzaCwgc2NyaXB0IH0gPSBzaWdoYXNoQ2FjaGUgIT09IHNpZy5oYXNoVHlwZVxuICAgICAgICAgICAgICAgID8gZ2V0SGFzaEZvclNpZyhpbnB1dEluZGV4LCBPYmplY3QuYXNzaWduKHt9LCBpbnB1dCwgeyBzaWdoYXNoVHlwZTogc2lnLmhhc2hUeXBlIH0pLCB0aGlzLl9fQ0FDSEUsIHRydWUpXG4gICAgICAgICAgICAgICAgOiB7IGhhc2g6IGhhc2hDYWNoZSwgc2NyaXB0OiBzY3JpcHRDYWNoZSB9O1xuICAgICAgICAgICAgc2lnaGFzaENhY2hlID0gc2lnLmhhc2hUeXBlO1xuICAgICAgICAgICAgaGFzaENhY2hlID0gaGFzaDtcbiAgICAgICAgICAgIHNjcmlwdENhY2hlID0gc2NyaXB0O1xuICAgICAgICAgICAgY2hlY2tTY3JpcHRGb3JQdWJrZXkocFNpZy5wdWJrZXksIHNjcmlwdCwgJ3ZlcmlmeScpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbGlkYXRvcihwU2lnLnB1YmtleSwgaGFzaCwgc2lnLnNpZ25hdHVyZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzLmV2ZXJ5KHJlcyA9PiByZXMgPT09IHRydWUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVNpZ25hdHVyZXNPZlRhcHJvb3RJbnB1dChpbnB1dEluZGV4LCB2YWxpZGF0b3IsIHB1YmtleSkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgICAgIGNvbnN0IHRhcEtleVNpZyA9IChpbnB1dCB8fCB7fSkudGFwS2V5U2lnO1xuICAgICAgICBjb25zdCB0YXBTY3JpcHRTaWcgPSAoaW5wdXQgfHwge30pLnRhcFNjcmlwdFNpZztcbiAgICAgICAgaWYgKCFpbnB1dCAmJiAhdGFwS2V5U2lnICYmICEodGFwU2NyaXB0U2lnICYmICF0YXBTY3JpcHRTaWcubGVuZ3RoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyB0byB2YWxpZGF0ZScpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCB2YWxpZGF0b3IgZnVuY3Rpb24gdG8gdmFsaWRhdGUgc2lnbmF0dXJlcycpO1xuICAgICAgICBwdWJrZXkgPSBwdWJrZXkgJiYgKDAsIGJpcDM3MV8xLnRvWE9ubHkpKHB1YmtleSk7XG4gICAgICAgIGNvbnN0IGFsbEhhc2hzZXMgPSBwdWJrZXlcbiAgICAgICAgICAgID8gZ2V0VGFwcm9vdEhhc2hlc0ZvclNpZyhpbnB1dEluZGV4LCBpbnB1dCwgdGhpcy5kYXRhLmlucHV0cywgcHVia2V5LCB0aGlzLl9fQ0FDSEUpXG4gICAgICAgICAgICA6IGdldEFsbFRhcHJvb3RIYXNoZXNGb3JTaWcoaW5wdXRJbmRleCwgaW5wdXQsIHRoaXMuZGF0YS5pbnB1dHMsIHRoaXMuX19DQUNIRSk7XG4gICAgICAgIGlmICghYWxsSGFzaHNlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZXMgZm9yIHRoaXMgcHVia2V5Jyk7XG4gICAgICAgIGNvbnN0IHRhcEtleUhhc2ggPSBhbGxIYXNoc2VzLmZpbmQoaCA9PiAhIWgubGVhZkhhc2gpO1xuICAgICAgICBpZiAodGFwS2V5U2lnICYmIHRhcEtleUhhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRUYXBrZXlTaWcgPSB2YWxpZGF0b3IodGFwS2V5SGFzaC5wdWJrZXksIHRhcEtleUhhc2guaGFzaCwgdGFwS2V5U2lnKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFRhcGtleVNpZylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcFNjcmlwdFNpZykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YXBTaWcgb2YgdGFwU2NyaXB0U2lnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFwU2lnSGFzaCA9IGFsbEhhc2hzZXMuZmluZChoID0+IHRhcFNpZy5wdWJrZXkuZXF1YWxzKGgucHVia2V5KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcFNpZ0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZFRhcFNjcmlwdFNpZyA9IHZhbGlkYXRvcih0YXBTaWcucHVia2V5LCB0YXBTaWdIYXNoLmhhc2gsIHRhcFNpZy5zaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUYXBTY3JpcHRTaWcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzaWduQWxsSW5wdXRzSEQoaGRLZXlQYWlyLCBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0pIHtcbiAgICAgICAgaWYgKCFoZEtleVBhaXIgfHwgIWhkS2V5UGFpci5wdWJsaWNLZXkgfHwgIWhkS2V5UGFpci5maW5nZXJwcmludCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIEhEU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiByYW5nZSh0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduSW5wdXRIRChpLCBoZEtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNpZ25BbGxJbnB1dHNIREFzeW5jKGhkS2V5UGFpciwgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnNpZ25JbnB1dEhEQXN5bmMoaSwgaGRLZXlQYWlyLCBzaWdoYXNoVHlwZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIGlucHV0cyB3ZXJlIHNpZ25lZCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduSW5wdXRIRChpbnB1dEluZGV4LCBoZEtleVBhaXIsIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSkge1xuICAgICAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25lcnMgPSBnZXRTaWduZXJzRnJvbUhEKGlucHV0SW5kZXgsIHRoaXMuZGF0YS5pbnB1dHMsIGhkS2V5UGFpcik7XG4gICAgICAgIHNpZ25lcnMuZm9yRWFjaChzaWduZXIgPT4gdGhpcy5zaWduSW5wdXQoaW5wdXRJbmRleCwgc2lnbmVyLCBzaWdoYXNoVHlwZXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNpZ25JbnB1dEhEQXN5bmMoaW5wdXRJbmRleCwgaGRLZXlQYWlyLCBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghaGRLZXlQYWlyIHx8ICFoZEtleVBhaXIucHVibGljS2V5IHx8ICFoZEtleVBhaXIuZmluZ2VycHJpbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTmVlZCBIRFNpZ25lciB0byBzaWduIGlucHV0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbmVycyA9IGdldFNpZ25lcnNGcm9tSEQoaW5wdXRJbmRleCwgdGhpcy5kYXRhLmlucHV0cywgaGRLZXlQYWlyKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gc2lnbmVycy5tYXAoc2lnbmVyID0+IHRoaXMuc2lnbklucHV0QXN5bmMoaW5wdXRJbmRleCwgc2lnbmVyLCBzaWdoYXNoVHlwZXMpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25BbGxJbnB1dHMoa2V5UGFpciwgc2lnaGFzaFR5cGVzKSB7XG4gICAgICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbklucHV0KGksIGtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNpZ25BbGxJbnB1dHNBc3luYyhrZXlQYWlyLCBzaWdoYXNoVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaV0gb2YgdGhpcy5kYXRhLmlucHV0cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2lnbklucHV0QXN5bmMoaSwga2V5UGFpciwgc2lnaGFzaFR5cGVzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmV2ZXJ5KHYgPT4gdiA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdObyBpbnB1dHMgd2VyZSBzaWduZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbklucHV0KGlucHV0SW5kZXgsIGtleVBhaXIsIHNpZ2hhc2hUeXBlcykge1xuICAgICAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIFNpZ25lciB0byBzaWduIGlucHV0Jyk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UYXByb290SW5wdXQoaW5wdXRJbmRleCwgaW5wdXQsIGtleVBhaXIsIHVuZGVmaW5lZCwgc2lnaGFzaFR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbklucHV0KGlucHV0SW5kZXgsIGtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gICAgfVxuICAgIHNpZ25UYXByb290SW5wdXQoaW5wdXRJbmRleCwga2V5UGFpciwgdGFwTGVhZkhhc2hUb1NpZ24sIHNpZ2hhc2hUeXBlcykge1xuICAgICAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIFNpZ25lciB0byBzaWduIGlucHV0Jyk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduVGFwcm9vdElucHV0KGlucHV0SW5kZXgsIGlucHV0LCBrZXlQYWlyLCB0YXBMZWFmSGFzaFRvU2lnbiwgc2lnaGFzaFR5cGVzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAjJHtpbnB1dEluZGV4fSBpcyBub3Qgb2YgdHlwZSBUYXByb290LmApO1xuICAgIH1cbiAgICBnZXRIYXNoQW5kU2lnaGFzaFR5cGUoaW5wdXRJbmRleCwgcHVibGljS2V5LCBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0pIHtcbiAgICAgICAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSB9ID0gZ2V0SGFzaEFuZFNpZ2hhc2hUeXBlKHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgsIHB1YmxpY0tleSwgdGhpcy5fX0NBQ0hFLCBzaWdoYXNoVHlwZXMpO1xuICAgICAgICByZXR1cm4geyBoYXNoLCBzaWdoYXNoVHlwZSB9O1xuICAgIH1cbiAgICBfc2lnbklucHV0KGlucHV0SW5kZXgsIGtleVBhaXIsIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSkge1xuICAgICAgICBjb25zdCB7IGhhc2gsIHNpZ2hhc2hUeXBlIH0gPSBnZXRIYXNoQW5kU2lnaGFzaFR5cGUodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCwga2V5UGFpci5wdWJsaWNLZXksIHRoaXMuX19DQUNIRSwgc2lnaGFzaFR5cGVzKTtcbiAgICAgICAgY29uc3QgcGFydGlhbFNpZyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwdWJrZXk6IGtleVBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYnNjcmlwdC5zaWduYXR1cmUuZW5jb2RlKGtleVBhaXIuc2lnbihoYXNoKSwgc2lnaGFzaFR5cGUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgcGFydGlhbFNpZyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9zaWduVGFwcm9vdElucHV0KGlucHV0SW5kZXgsIGlucHV0LCBrZXlQYWlyLCB0YXBMZWFmSGFzaFRvU2lnbiwgYWxsb3dlZFNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVF0pIHtcbiAgICAgICAgY29uc3QgaGFzaGVzRm9yU2lnID0gdGhpcy5jaGVja1RhcHJvb3RIYXNoZXNGb3JTaWcoaW5wdXRJbmRleCwgaW5wdXQsIGtleVBhaXIsIHRhcExlYWZIYXNoVG9TaWduLCBhbGxvd2VkU2lnaGFzaFR5cGVzKTtcbiAgICAgICAgY29uc3QgdGFwS2V5U2lnID0gaGFzaGVzRm9yU2lnXG4gICAgICAgICAgICAuZmlsdGVyKGggPT4gIWgubGVhZkhhc2gpXG4gICAgICAgICAgICAubWFwKGggPT4gKDAsIGJpcDM3MV8xLnNlcmlhbGl6ZVRhcHJvb3RTaWduYXR1cmUpKGtleVBhaXIuc2lnblNjaG5vcnIoaC5oYXNoKSwgaW5wdXQuc2lnaGFzaFR5cGUpKVswXTtcbiAgICAgICAgY29uc3QgdGFwU2NyaXB0U2lnID0gaGFzaGVzRm9yU2lnXG4gICAgICAgICAgICAuZmlsdGVyKGggPT4gISFoLmxlYWZIYXNoKVxuICAgICAgICAgICAgLm1hcChoID0+ICh7XG4gICAgICAgICAgICBwdWJrZXk6ICgwLCBiaXAzNzFfMS50b1hPbmx5KShrZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICBzaWduYXR1cmU6ICgwLCBiaXAzNzFfMS5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlKShrZXlQYWlyLnNpZ25TY2hub3JyKGguaGFzaCksIGlucHV0LnNpZ2hhc2hUeXBlKSxcbiAgICAgICAgICAgIGxlYWZIYXNoOiBoLmxlYWZIYXNoLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh0YXBLZXlTaWcpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IHRhcEtleVNpZyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFwU2NyaXB0U2lnLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgdGFwU2NyaXB0U2lnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzaWduSW5wdXRBc3luYyhpbnB1dEluZGV4LCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFrZXlQYWlyIHx8ICFrZXlQYWlyLnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgICAgICAgICBpZiAoKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KShpbnB1dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UYXByb290SW5wdXRBc3luYyhpbnB1dEluZGV4LCBpbnB1dCwga2V5UGFpciwgdW5kZWZpbmVkLCBzaWdoYXNoVHlwZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25JbnB1dEFzeW5jKGlucHV0SW5kZXgsIGtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduVGFwcm9vdElucHV0QXN5bmMoaW5wdXRJbmRleCwga2V5UGFpciwgdGFwTGVhZkhhc2gsIHNpZ2hhc2hUeXBlcykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICAgICAgICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnblRhcHJvb3RJbnB1dEFzeW5jKGlucHV0SW5kZXgsIGlucHV0LCBrZXlQYWlyLCB0YXBMZWFmSGFzaCwgc2lnaGFzaFR5cGVzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgIyR7aW5wdXRJbmRleH0gaXMgbm90IG9mIHR5cGUgVGFwcm9vdC5gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zaWduSW5wdXRBc3luYyhpbnB1dEluZGV4LCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0pIHtcbiAgICAgICAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSB9ID0gZ2V0SGFzaEFuZFNpZ2hhc2hUeXBlKHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgsIGtleVBhaXIucHVibGljS2V5LCB0aGlzLl9fQ0FDSEUsIHNpZ2hhc2hUeXBlcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5UGFpci5zaWduKGhhc2gpKS50aGVuKHNpZ25hdHVyZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWFsU2lnID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBrZXlQYWlyLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBic2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoc2lnbmF0dXJlLCBzaWdoYXNoVHlwZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBwYXJ0aWFsU2lnIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NpZ25UYXByb290SW5wdXRBc3luYyhpbnB1dEluZGV4LCBpbnB1dCwga2V5UGFpciwgdGFwTGVhZkhhc2gsIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVF0pIHtcbiAgICAgICAgY29uc3QgaGFzaGVzRm9yU2lnID0gdGhpcy5jaGVja1RhcHJvb3RIYXNoZXNGb3JTaWcoaW5wdXRJbmRleCwgaW5wdXQsIGtleVBhaXIsIHRhcExlYWZIYXNoLCBzaWdoYXNoVHlwZXMpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVQcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCB0YXBLZXlIYXNoID0gaGFzaGVzRm9yU2lnLmZpbHRlcihoID0+ICFoLmxlYWZIYXNoKVswXTtcbiAgICAgICAgaWYgKHRhcEtleUhhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcEtleVNpZ1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoa2V5UGFpci5zaWduU2Nobm9ycih0YXBLZXlIYXNoLmhhc2gpKS50aGVuKHNpZyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFwS2V5U2lnOiAoMCwgYmlwMzcxXzEuc2VyaWFsaXplVGFwcm9vdFNpZ25hdHVyZSkoc2lnLCBpbnB1dC5zaWdoYXNoVHlwZSkgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2lnbmF0dXJlUHJvbWlzZXMucHVzaCh0YXBLZXlTaWdQcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXBTY3JpcHRIYXNoZXMgPSBoYXNoZXNGb3JTaWcuZmlsdGVyKGggPT4gISFoLmxlYWZIYXNoKTtcbiAgICAgICAgaWYgKHRhcFNjcmlwdEhhc2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcFNjcmlwdFNpZ1Byb21pc2VzID0gdGFwU2NyaXB0SGFzaGVzLm1hcCh0c2ggPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5UGFpci5zaWduU2Nobm9ycih0c2guaGFzaCkpLnRoZW4oc2lnbmF0dXJlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFwU2NyaXB0U2lnID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogKDAsIGJpcDM3MV8xLnRvWE9ubHkpKGtleVBhaXIucHVibGljS2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICgwLCBiaXAzNzFfMS5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlKShzaWduYXR1cmUsIGlucHV0LnNpZ2hhc2hUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFmSGFzaDogdHNoLmxlYWZIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFwU2NyaXB0U2lnIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNpZ25hdHVyZVByb21pc2VzLnB1c2goLi4udGFwU2NyaXB0U2lnUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChzaWduYXR1cmVQcm9taXNlcykudGhlbihyZXN1bHRzID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaCh2ID0+IHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB2KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVja1RhcHJvb3RIYXNoZXNGb3JTaWcoaW5wdXRJbmRleCwgaW5wdXQsIGtleVBhaXIsIHRhcExlYWZIYXNoVG9TaWduLCBhbGxvd2VkU2lnaGFzaFR5cGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5UGFpci5zaWduU2Nobm9yciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmVlZCBTY2hub3JyIFNpZ25lciB0byBzaWduIHRhcHJvb3QgaW5wdXQgIyR7aW5wdXRJbmRleH0uYCk7XG4gICAgICAgIGNvbnN0IGhhc2hlc0ZvclNpZyA9IGdldFRhcHJvb3RIYXNoZXNGb3JTaWcoaW5wdXRJbmRleCwgaW5wdXQsIHRoaXMuZGF0YS5pbnB1dHMsIGtleVBhaXIucHVibGljS2V5LCB0aGlzLl9fQ0FDSEUsIHRhcExlYWZIYXNoVG9TaWduLCBhbGxvd2VkU2lnaGFzaFR5cGVzKTtcbiAgICAgICAgaWYgKCFoYXNoZXNGb3JTaWcgfHwgIWhhc2hlc0ZvclNpZy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3Qgc2lnbiBmb3IgaW5wdXQgIyR7aW5wdXRJbmRleH0gd2l0aCB0aGUga2V5ICR7a2V5UGFpci5wdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpfWApO1xuICAgICAgICByZXR1cm4gaGFzaGVzRm9yU2lnO1xuICAgIH1cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgY2hlY2tDYWNoZSh0aGlzLl9fQ0FDSEUpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnRvQnVmZmVyKCk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICBjaGVja0NhY2hlKHRoaXMuX19DQUNIRSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudG9IZXgoKTtcbiAgICB9XG4gICAgdG9CYXNlNjQoKSB7XG4gICAgICAgIGNoZWNrQ2FjaGUodGhpcy5fX0NBQ0hFKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50b0Jhc2U2NCgpO1xuICAgIH1cbiAgICB1cGRhdGVHbG9iYWwodXBkYXRlRGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEudXBkYXRlR2xvYmFsKHVwZGF0ZURhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgdXBkYXRlRGF0YSkge1xuICAgICAgICBpZiAodXBkYXRlRGF0YS53aXRuZXNzU2NyaXB0KVxuICAgICAgICAgICAgY2hlY2tJbnZhbGlkUDJXU0godXBkYXRlRGF0YS53aXRuZXNzU2NyaXB0KTtcbiAgICAgICAgKDAsIGJpcDM3MV8xLmNoZWNrVGFwcm9vdElucHV0RmllbGRzKSh0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdLCB1cGRhdGVEYXRhLCAndXBkYXRlSW5wdXQnKTtcbiAgICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHVwZGF0ZURhdGEpO1xuICAgICAgICBpZiAodXBkYXRlRGF0YS5ub25XaXRuZXNzVXR4bykge1xuICAgICAgICAgICAgYWRkTm9uV2l0bmVzc1R4Q2FjaGUodGhpcy5fX0NBQ0hFLCB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdLCBpbnB1dEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlT3V0cHV0KG91dHB1dEluZGV4LCB1cGRhdGVEYXRhKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dERhdGEgPSB0aGlzLmRhdGEub3V0cHV0c1tvdXRwdXRJbmRleF07XG4gICAgICAgICgwLCBiaXAzNzFfMS5jaGVja1RhcHJvb3RPdXRwdXRGaWVsZHMpKG91dHB1dERhdGEsIHVwZGF0ZURhdGEsICd1cGRhdGVPdXRwdXQnKTtcbiAgICAgICAgdGhpcy5kYXRhLnVwZGF0ZU91dHB1dChvdXRwdXRJbmRleCwgdXBkYXRlRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRVbmtub3duS2V5VmFsVG9HbG9iYWwoa2V5VmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5hZGRVbmtub3duS2V5VmFsVG9HbG9iYWwoa2V5VmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZFVua25vd25LZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIGtleVZhbCkge1xuICAgICAgICB0aGlzLmRhdGEuYWRkVW5rbm93bktleVZhbFRvSW5wdXQoaW5wdXRJbmRleCwga2V5VmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZFVua25vd25LZXlWYWxUb091dHB1dChvdXRwdXRJbmRleCwga2V5VmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5hZGRVbmtub3duS2V5VmFsVG9PdXRwdXQob3V0cHV0SW5kZXgsIGtleVZhbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpIHtcbiAgICAgICAgdGhpcy5kYXRhLmNsZWFyRmluYWxpemVkSW5wdXQoaW5wdXRJbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2ZXJpZnkocHViQnVmLCB3aXRuZXNzKSB7XG4gICAgICAgIGNvbnN0IGFsbG93ZWRTaWdoYXNoVHlwZXMgPSBbXG4gICAgICAgICAgICB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFIHwgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KSh0aGlzLmRhdGEuaW5wdXRzW2ldKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR3ZWFrS2V5ID0gQnVmZmVyLmZyb20oKDAsIHRhcHJvb3RfMS50YXByb290VHdlYWtQdWJrZXkpKHB1YkJ1Zi5zbGljZSgxKSlbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclJlYWRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlclJlYWRlcih3aXRuZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZWN0b3IgPSBidWZmZXJSZWFkZXIucmVhZFZlY3RvcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiB0d2Vha0tleSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbihoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDY0KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2lnblNjaG5vcnIoaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyg2NCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoZXNGb3JTaWcgPSB0aGlzLmNoZWNrVGFwcm9vdEhhc2hlc0ZvclNpZyhpLCB0aGlzLmRhdGEuaW5wdXRzW2ldLCBzaWduZXIsIHVuZGVmaW5lZCwgYWxsb3dlZFNpZ2hhc2hUeXBlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVRvU2lnbiA9IGhhc2hlc0ZvclNpZy5maWx0ZXIoaCA9PiAhaC5sZWFmSGFzaClbMF0uaGFzaDtcbiAgICAgICAgICAgICAgICBpZiAoIXNjaG5vcnIudmVyaWZ5KGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KHZlY3RvclswXSksIGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KG1lc3NhZ2VUb1NpZ24pLCBjcnlwdG9fbGliXzEuYmFzZS50b0hleCh0d2Vha0tleSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhhc2ggfSA9IGdldEhhc2hBbmRTaWdoYXNoVHlwZSh0aGlzLmRhdGEuaW5wdXRzLCBpLCBwdWJCdWYsIHRoaXMuX19DQUNIRSwgYWxsb3dlZFNpZ2hhc2hUeXBlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyUmVhZGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyUmVhZGVyKHdpdG5lc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlY3RvciA9IGJ1ZmZlclJlYWRlci5yZWFkVmVjdG9yKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2NyaXB0XzEuc2lnbmF0dXJlLmRlY29kZSh2ZWN0b3JbMF0pLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRuZXNzUHViS2V5ID0gdmVjdG9yWzFdO1xuICAgICAgICAgICAgICAgIGlmICghcHViQnVmLmVxdWFscyh3aXRuZXNzUHViS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInB1YktleSBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjcnlwdG9fbGliXzEuc2lnblV0aWwuc2VjcDI1NmsxLnZlcmlmeVdpdGhOb1JlY292ZXJ5KGhhc2gsIHNpZ25hdHVyZSwgcHViQnVmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuUHNidCA9IFBzYnQ7XG5jb25zdCB0cmFuc2FjdGlvbkZyb21CdWZmZXIgPSAoYnVmZmVyKSA9PiBuZXcgUHNidFRyYW5zYWN0aW9uKGJ1ZmZlcik7XG5jbGFzcyBQc2J0VHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKFsyLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSkpIHtcbiAgICAgICAgdGhpcy50eCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICBjaGVja1R4RW1wdHkodGhpcy50eCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHgnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5wdXRPdXRwdXRDb3VudHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dENvdW50OiB0aGlzLnR4Lmlucy5sZW5ndGgsXG4gICAgICAgICAgICBvdXRwdXRDb3VudDogdGhpcy50eC5vdXRzLmxlbmd0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lmhhc2ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaW5wdXQuaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKCFCdWZmZXIuaXNCdWZmZXIoaW5wdXQuaGFzaCkgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5wdXQuaGFzaCAhPT0gJ3N0cmluZycpIHx8XG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQuaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFkZGluZyBpbnB1dC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNoID0gdHlwZW9mIGlucHV0Lmhhc2ggPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/ICgwLCBidWZmZXJ1dGlsc18xLnJldmVyc2VCdWZmZXIpKEJ1ZmZlci5mcm9tKGlucHV0Lmhhc2gsICdoZXgnKSlcbiAgICAgICAgICAgIDogaW5wdXQuaGFzaDtcbiAgICAgICAgdGhpcy50eC5hZGRJbnB1dChoYXNoLCBpbnB1dC5pbmRleCwgaW5wdXQuc2VxdWVuY2UpO1xuICAgIH1cbiAgICBhZGRPdXRwdXQob3V0cHV0KSB7XG4gICAgICAgIGlmIChvdXRwdXQuc2NyaXB0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG91dHB1dC52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAhQnVmZmVyLmlzQnVmZmVyKG91dHB1dC5zY3JpcHQpIHx8XG4gICAgICAgICAgICB0eXBlb2Ygb3V0cHV0LnZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgb3V0cHV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHguYWRkT3V0cHV0KG91dHB1dC5zY3JpcHQsIG91dHB1dC52YWx1ZSk7XG4gICAgfVxuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eC50b0J1ZmZlcigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbkZpbmFsaXplKGlucHV0LCBzY3JpcHQsIHNjcmlwdFR5cGUpIHtcbiAgICBzd2l0Y2ggKHNjcmlwdFR5cGUpIHtcbiAgICAgICAgY2FzZSAncHVia2V5JzpcbiAgICAgICAgY2FzZSAncHVia2V5aGFzaCc6XG4gICAgICAgIGNhc2UgJ3dpdG5lc3NwdWJrZXloYXNoJzpcbiAgICAgICAgICAgIHJldHVybiBoYXNTaWdzKDEsIGlucHV0LnBhcnRpYWxTaWcpO1xuICAgICAgICBjYXNlICdtdWx0aXNpZyc6XG4gICAgICAgICAgICBjb25zdCBwMm1zID0gcGF5bWVudHMucDJtcyh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGhhc1NpZ3MocDJtcy5tLCBpbnB1dC5wYXJ0aWFsU2lnLCBwMm1zLnB1YmtleXMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ2FjaGUoY2FjaGUpIHtcbiAgICBpZiAoY2FjaGUuX19VTlNBRkVfU0lHTl9OT05TRUdXSVQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IEJJUDE3NCBjb21wbGlhbnQsIGNhbiBub3QgZXhwb3J0Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzU2lncyhuZWVkZWRTaWdzLCBwYXJ0aWFsU2lnLCBwdWJrZXlzKSB7XG4gICAgaWYgKCFwYXJ0aWFsU2lnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpZ3M7XG4gICAgaWYgKHB1YmtleXMpIHtcbiAgICAgICAgc2lncyA9IHB1YmtleXNcbiAgICAgICAgICAgIC5tYXAocGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwdWJrZXkgPSBjb21wcmVzc1B1YmtleShwa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsU2lnLmZpbmQocFNpZyA9PiBwU2lnLnB1YmtleS5lcXVhbHMocHVia2V5KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKHYgPT4gISF2KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNpZ3MgPSBwYXJ0aWFsU2lnO1xuICAgIH1cbiAgICBpZiAoc2lncy5sZW5ndGggPiBuZWVkZWRTaWdzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHNpZ25hdHVyZXMnKTtcbiAgICByZXR1cm4gc2lncy5sZW5ndGggPT09IG5lZWRlZFNpZ3M7XG59XG5mdW5jdGlvbiBpc0ZpbmFsaXplZChpbnB1dCkge1xuICAgIHJldHVybiAhIWlucHV0LmZpbmFsU2NyaXB0U2lnIHx8ICEhaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzO1xufVxuZnVuY3Rpb24gYmlwMzJEZXJpdmF0aW9uSXNNaW5lKHJvb3QpIHtcbiAgICByZXR1cm4gKGQpID0+IHtcbiAgICAgICAgaWYgKCFkLm1hc3RlckZpbmdlcnByaW50LmVxdWFscyhyb290LmZpbmdlcnByaW50KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFyb290LmRlcml2ZVBhdGgoZC5wYXRoKS5wdWJsaWNLZXkuZXF1YWxzKGQucHVia2V5KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrMzJCaXQobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInIHx8XG4gICAgICAgIG51bSAhPT0gTWF0aC5mbG9vcihudW0pIHx8XG4gICAgICAgIG51bSA+IDB4ZmZmZmZmZmYgfHxcbiAgICAgICAgbnVtIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgMzIgYml0IGludGVnZXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0ZlZXMocHNidCwgY2FjaGUsIG9wdHMpIHtcbiAgICBjb25zdCBmZWVSYXRlID0gY2FjaGUuX19GRUVfUkFURSB8fCBwc2J0LmdldEZlZVJhdGUoKTtcbiAgICBjb25zdCB2c2l6ZSA9IGNhY2hlLl9fRVhUUkFDVEVEX1RYLnZpcnR1YWxTaXplKCk7XG4gICAgY29uc3Qgc2F0b3NoaXMgPSBmZWVSYXRlICogdnNpemU7XG4gICAgaWYgKGZlZVJhdGUgPj0gb3B0cy5tYXhpbXVtRmVlUmF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdhcm5pbmc6IFlvdSBhcmUgcGF5aW5nIGFyb3VuZCAkeyhzYXRvc2hpcyAvIDFlOCkudG9GaXhlZCg4KX0gaW4gYCArXG4gICAgICAgICAgICBgZmVlcywgd2hpY2ggaXMgJHtmZWVSYXRlfSBzYXRvc2hpIHBlciBieXRlIGZvciBhIHRyYW5zYWN0aW9uIGAgK1xuICAgICAgICAgICAgYHdpdGggYSBWU2l6ZSBvZiAke3ZzaXplfSBieXRlcyAoc2Vnd2l0IGNvdW50ZWQgYXMgMC4yNSBieXRlIHBlciBgICtcbiAgICAgICAgICAgIGBieXRlKS4gVXNlIHNldE1heGltdW1GZWVSYXRlIG1ldGhvZCB0byByYWlzZSB5b3VyIHRocmVzaG9sZCwgb3IgYCArXG4gICAgICAgICAgICBgcGFzcyB0cnVlIHRvIHRoZSBmaXJzdCBhcmcgb2YgZXh0cmFjdFRyYW5zYWN0aW9uLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSW5wdXRzRm9yUGFydGlhbFNpZyhpbnB1dHMsIGFjdGlvbikge1xuICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgY29uc3QgdGhyb3dzID0gKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KShpbnB1dClcbiAgICAgICAgICAgID8gKDAsIGJpcDM3MV8xLmNoZWNrVGFwcm9vdElucHV0Rm9yU2lncykoaW5wdXQsIGFjdGlvbilcbiAgICAgICAgICAgIDogKDAsIHBzYnR1dGlsc18xLmNoZWNrSW5wdXRGb3JTaWcpKGlucHV0LCBhY3Rpb24pO1xuICAgICAgICBpZiAodGhyb3dzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IG1vZGlmeSB0cmFuc2FjdGlvbiwgc2lnbmF0dXJlcyBleGlzdC4nKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUGFydGlhbFNpZ1NpZ2hhc2hlcyhpbnB1dCkge1xuICAgIGlmICghaW5wdXQuc2lnaGFzaFR5cGUgfHwgIWlucHV0LnBhcnRpYWxTaWcpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHBhcnRpYWxTaWcsIHNpZ2hhc2hUeXBlIH0gPSBpbnB1dDtcbiAgICBwYXJ0aWFsU2lnLmZvckVhY2gocFNpZyA9PiB7XG4gICAgICAgIGNvbnN0IHsgaGFzaFR5cGUgfSA9IGJzY3JpcHQuc2lnbmF0dXJlLmRlY29kZShwU2lnLnNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWdoYXNoVHlwZSAhPT0gaGFzaFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIHNpZ2hhc2ggZG9lcyBub3QgbWF0Y2ggaW5wdXQgc2lnaGFzaCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2NyaXB0Rm9yUHVia2V5KHB1YmtleSwgc2NyaXB0LCBhY3Rpb24pIHtcbiAgICBpZiAoISgwLCBwc2J0dXRpbHNfMS5wdWJrZXlJblNjcmlwdCkocHVia2V5LCBzY3JpcHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCAke2FjdGlvbn0gZm9yIHRoaXMgaW5wdXQgd2l0aCB0aGUga2V5ICR7cHVia2V5LnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1R4RW1wdHkodHgpIHtcbiAgICBjb25zdCBpc0VtcHR5ID0gdHguaW5zLmV2ZXJ5KGlucHV0ID0+IGlucHV0LnNjcmlwdCAmJlxuICAgICAgICBpbnB1dC5zY3JpcHQubGVuZ3RoID09PSAwICYmXG4gICAgICAgIGlucHV0LndpdG5lc3MgJiZcbiAgICAgICAgaW5wdXQud2l0bmVzcy5sZW5ndGggPT09IDApO1xuICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogVHJhbnNhY3Rpb24gU2NyaXB0U2lncyBhcmUgbm90IGVtcHR5Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tUeEZvckR1cGVJbnModHgsIGNhY2hlKSB7XG4gICAgdHguaW5zLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICBjaGVja1R4SW5wdXRDYWNoZShjYWNoZSwgaW5wdXQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tUeElucHV0Q2FjaGUoY2FjaGUsIGlucHV0KSB7XG4gICAgY29uc3Qga2V5ID0gKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikoQnVmZmVyLmZyb20oaW5wdXQuaGFzaCkpLnRvU3RyaW5nKCdoZXgnKSArICc6JyArIGlucHV0LmluZGV4O1xuICAgIGlmIChjYWNoZS5fX1RYX0lOX0NBQ0hFW2tleV0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlIGlucHV0IGRldGVjdGVkLicpO1xuICAgIGNhY2hlLl9fVFhfSU5fQ0FDSEVba2V5XSA9IDE7XG59XG5mdW5jdGlvbiBzY3JpcHRDaGVja2VyRmFjdG9yeShwYXltZW50LCBwYXltZW50U2NyaXB0TmFtZSkge1xuICAgIHJldHVybiAoaW5wdXRJbmRleCwgc2NyaXB0UHViS2V5LCByZWRlZW1TY3JpcHQsIGlvVHlwZSkgPT4ge1xuICAgICAgICBjb25zdCByZWRlZW1TY3JpcHRPdXRwdXQgPSBwYXltZW50KHtcbiAgICAgICAgICAgIHJlZGVlbTogeyBvdXRwdXQ6IHJlZGVlbVNjcmlwdCB9LFxuICAgICAgICB9KS5vdXRwdXQ7XG4gICAgICAgIGlmICghc2NyaXB0UHViS2V5LmVxdWFscyhyZWRlZW1TY3JpcHRPdXRwdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cGF5bWVudFNjcmlwdE5hbWV9IGZvciAke2lvVHlwZX0gIyR7aW5wdXRJbmRleH0gZG9lc24ndCBtYXRjaCB0aGUgc2NyaXB0UHViS2V5IGluIHRoZSBwcmV2b3V0YCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgY2hlY2tSZWRlZW1TY3JpcHQgPSBzY3JpcHRDaGVja2VyRmFjdG9yeShwYXltZW50cy5wMnNoLCAnUmVkZWVtIHNjcmlwdCcpO1xuY29uc3QgY2hlY2tXaXRuZXNzU2NyaXB0ID0gc2NyaXB0Q2hlY2tlckZhY3RvcnkocGF5bWVudHMucDJ3c2gsICdXaXRuZXNzIHNjcmlwdCcpO1xuZnVuY3Rpb24gZ2V0VHhDYWNoZVZhbHVlKGtleSwgbmFtZSwgaW5wdXRzLCBjKSB7XG4gICAgaWYgKCFpbnB1dHMuZXZlcnkoaXNGaW5hbGl6ZWQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBTQlQgbXVzdCBiZSBmaW5hbGl6ZWQgdG8gY2FsY3VsYXRlICR7bmFtZX1gKTtcbiAgICBpZiAoa2V5ID09PSAnX19GRUVfUkFURScgJiYgYy5fX0ZFRV9SQVRFKVxuICAgICAgICByZXR1cm4gYy5fX0ZFRV9SQVRFO1xuICAgIGlmIChrZXkgPT09ICdfX0ZFRScgJiYgYy5fX0ZFRSlcbiAgICAgICAgcmV0dXJuIGMuX19GRUU7XG4gICAgbGV0IHR4O1xuICAgIGxldCBtdXN0RmluYWxpemUgPSB0cnVlO1xuICAgIGlmIChjLl9fRVhUUkFDVEVEX1RYKSB7XG4gICAgICAgIHR4ID0gYy5fX0VYVFJBQ1RFRF9UWDtcbiAgICAgICAgbXVzdEZpbmFsaXplID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0eCA9IGMuX19UWC5jbG9uZSgpO1xuICAgIH1cbiAgICBpbnB1dEZpbmFsaXplR2V0QW10cyhpbnB1dHMsIHR4LCBjLCBtdXN0RmluYWxpemUpO1xuICAgIGlmIChrZXkgPT09ICdfX0ZFRV9SQVRFJylcbiAgICAgICAgcmV0dXJuIGMuX19GRUVfUkFURTtcbiAgICBlbHNlIGlmIChrZXkgPT09ICdfX0ZFRScpXG4gICAgICAgIHJldHVybiBjLl9fRkVFO1xufVxuZnVuY3Rpb24gZ2V0RmluYWxTY3JpcHRzKGlucHV0SW5kZXgsIGlucHV0LCBzY3JpcHQsIGlzU2Vnd2l0LCBpc1AyU0gsIGlzUDJXU0gpIHtcbiAgICBjb25zdCBzY3JpcHRUeXBlID0gY2xhc3NpZnlTY3JpcHQoc2NyaXB0KTtcbiAgICBpZiAoIWNhbkZpbmFsaXplKGlucHV0LCBzY3JpcHQsIHNjcmlwdFR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgZmluYWxpemUgaW5wdXQgIyR7aW5wdXRJbmRleH1gKTtcbiAgICByZXR1cm4gcHJlcGFyZUZpbmFsU2NyaXB0cyhzY3JpcHQsIHNjcmlwdFR5cGUsIGlucHV0LnBhcnRpYWxTaWcsIGlzU2Vnd2l0LCBpc1AyU0gsIGlzUDJXU0gpO1xufVxuZnVuY3Rpb24gcHJlcGFyZUZpbmFsU2NyaXB0cyhzY3JpcHQsIHNjcmlwdFR5cGUsIHBhcnRpYWxTaWcsIGlzU2Vnd2l0LCBpc1AyU0gsIGlzUDJXU0gpIHtcbiAgICBsZXQgZmluYWxTY3JpcHRTaWc7XG4gICAgbGV0IGZpbmFsU2NyaXB0V2l0bmVzcztcbiAgICBjb25zdCBwYXltZW50ID0gZ2V0UGF5bWVudChzY3JpcHQsIHNjcmlwdFR5cGUsIHBhcnRpYWxTaWcpO1xuICAgIGNvbnN0IHAyd3NoID0gIWlzUDJXU0ggPyBudWxsIDogcGF5bWVudHMucDJ3c2goeyByZWRlZW06IHBheW1lbnQgfSk7XG4gICAgY29uc3QgcDJzaCA9ICFpc1AyU0ggPyBudWxsIDogcGF5bWVudHMucDJzaCh7IHJlZGVlbTogcDJ3c2ggfHwgcGF5bWVudCB9KTtcbiAgICBpZiAoaXNTZWd3aXQpIHtcbiAgICAgICAgaWYgKHAyd3NoKSB7XG4gICAgICAgICAgICBmaW5hbFNjcmlwdFdpdG5lc3MgPSAoMCwgcHNidHV0aWxzXzEud2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzKShwMndzaC53aXRuZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmFsU2NyaXB0V2l0bmVzcyA9ICgwLCBwc2J0dXRpbHNfMS53aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MpKHBheW1lbnQud2l0bmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAyc2gpIHtcbiAgICAgICAgICAgIGZpbmFsU2NyaXB0U2lnID0gcDJzaC5pbnB1dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHAyc2gpIHtcbiAgICAgICAgICAgIGZpbmFsU2NyaXB0U2lnID0gcDJzaC5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmFsU2NyaXB0U2lnID0gcGF5bWVudC5pbnB1dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmaW5hbFNjcmlwdFNpZyxcbiAgICAgICAgZmluYWxTY3JpcHRXaXRuZXNzLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRIYXNoQW5kU2lnaGFzaFR5cGUoaW5wdXRzLCBpbnB1dEluZGV4LCBwdWJrZXksIGNhY2hlLCBzaWdoYXNoVHlwZXMpIHtcbiAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKGlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSwgc2NyaXB0IH0gPSBnZXRIYXNoRm9yU2lnKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSwgZmFsc2UsIHNpZ2hhc2hUeXBlcyk7XG4gICAgY2hlY2tTY3JpcHRGb3JQdWJrZXkocHVia2V5LCBzY3JpcHQsICdzaWduJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgc2lnaGFzaFR5cGUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0SGFzaEFuZFNpZ2hhc2hUeXBlID0gZ2V0SGFzaEFuZFNpZ2hhc2hUeXBlO1xuZnVuY3Rpb24gZ2V0SGFzaEZvclNpZyhpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUsIGZvclZhbGlkYXRlLCBzaWdoYXNoVHlwZXMpIHtcbiAgICBjb25zdCB1bnNpZ25lZFR4ID0gY2FjaGUuX19UWDtcbiAgICBjb25zdCBzaWdoYXNoVHlwZSA9IGlucHV0LnNpZ2hhc2hUeXBlIHx8IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw7XG4gICAgY2hlY2tTaWdoYXNoVHlwZUFsbG93ZWQoc2lnaGFzaFR5cGUsIHNpZ2hhc2hUeXBlcyk7XG4gICAgbGV0IGhhc2g7XG4gICAgbGV0IHByZXZvdXQ7XG4gICAgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvKSB7XG4gICAgICAgIGNvbnN0IG5vbldpdG5lc3NVdHhvVHggPSBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKGNhY2hlLCBpbnB1dCwgaW5wdXRJbmRleCk7XG4gICAgICAgIGNvbnN0IHByZXZvdXRIYXNoID0gdW5zaWduZWRUeC5pbnNbaW5wdXRJbmRleF0uaGFzaDtcbiAgICAgICAgY29uc3QgdXR4b0hhc2ggPSBub25XaXRuZXNzVXR4b1R4LmdldEhhc2goKTtcbiAgICAgICAgaWYgKCFwcmV2b3V0SGFzaC5lcXVhbHModXR4b0hhc2gpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi13aXRuZXNzIFVUWE8gaGFzaCBmb3IgaW5wdXQgIyR7aW5wdXRJbmRleH0gZG9lc24ndCBtYXRjaCB0aGUgaGFzaCBzcGVjaWZpZWQgaW4gdGhlIHByZXZvdXRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2b3V0SW5kZXggPSB1bnNpZ25lZFR4Lmluc1tpbnB1dEluZGV4XS5pbmRleDtcbiAgICAgICAgcHJldm91dCA9IG5vbldpdG5lc3NVdHhvVHgub3V0c1twcmV2b3V0SW5kZXhdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnB1dC53aXRuZXNzVXR4bykge1xuICAgICAgICBwcmV2b3V0ID0gaW5wdXQud2l0bmVzc1V0eG87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgYSBVdHhvIGlucHV0IGl0ZW0gZm9yIHNpZ25pbmcnKTtcbiAgICB9XG4gICAgY29uc3QgeyBtZWFuaW5nZnVsU2NyaXB0LCB0eXBlIH0gPSBnZXRNZWFuaW5nZnVsU2NyaXB0KHByZXZvdXQuc2NyaXB0LCBpbnB1dEluZGV4LCAnaW5wdXQnLCBpbnB1dC5yZWRlZW1TY3JpcHQsIGlucHV0LndpdG5lc3NTY3JpcHQpO1xuICAgIGlmIChbJ3Ayc2gtcDJ3c2gnLCAncDJ3c2gnXS5pbmRleE9mKHR5cGUpID49IDApIHtcbiAgICAgICAgaGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvcldpdG5lc3NWMChpbnB1dEluZGV4LCBtZWFuaW5nZnVsU2NyaXB0LCBwcmV2b3V0LnZhbHVlLCBzaWdoYXNoVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBwc2J0dXRpbHNfMS5pc1AyV1BLSCkobWVhbmluZ2Z1bFNjcmlwdCkpIHtcbiAgICAgICAgY29uc3Qgc2lnbmluZ1NjcmlwdCA9IHBheW1lbnRzLnAycGtoKHsgaGFzaDogbWVhbmluZ2Z1bFNjcmlwdC5zbGljZSgyKSB9KVxuICAgICAgICAgICAgLm91dHB1dDtcbiAgICAgICAgaGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvcldpdG5lc3NWMChpbnB1dEluZGV4LCBzaWduaW5nU2NyaXB0LCBwcmV2b3V0LnZhbHVlLCBzaWdoYXNoVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5wdXQubm9uV2l0bmVzc1V0eG8gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgY2FjaGUuX19VTlNBRkVfU0lHTl9OT05TRUdXSVQgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAjJHtpbnB1dEluZGV4fSBoYXMgd2l0bmVzc1V0eG8gYnV0IG5vbi1zZWd3aXQgc2NyaXB0OiBgICtcbiAgICAgICAgICAgICAgICBgJHttZWFuaW5nZnVsU2NyaXB0LnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgICAgICAgaWYgKCFmb3JWYWxpZGF0ZSAmJiBjYWNoZS5fX1VOU0FGRV9TSUdOX05PTlNFR1dJVCAhPT0gZmFsc2UpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IFNpZ25pbmcgbm9uLXNlZ3dpdCBpbnB1dHMgd2l0aG91dCB0aGUgZnVsbCBwYXJlbnQgdHJhbnNhY3Rpb24gJyArXG4gICAgICAgICAgICAgICAgJ21lYW5zIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgYSBtaW5lciBjb3VsZCBmZWVkIHlvdSBpbmNvcnJlY3QgaW5mb3JtYXRpb24gJyArXG4gICAgICAgICAgICAgICAgXCJ0byB0cmljayB5b3UgaW50byBwYXlpbmcgbGFyZ2UgZmVlcy4gVGhpcyBiZWhhdmlvciBpcyB0aGUgc2FtZSBhcyBQc2J0J3MgcHJlZGVjZXNvciBcIiArXG4gICAgICAgICAgICAgICAgJyhUcmFuc2FjdGlvbkJ1aWxkZXIgLSBub3cgcmVtb3ZlZCkgd2hlbiBzaWduaW5nIG5vbi1zZWd3aXQgc2NyaXB0cy4gWW91IGFyZSBub3QgJyArXG4gICAgICAgICAgICAgICAgJ2FibGUgdG8gZXhwb3J0IHRoaXMgUHNidCB3aXRoIHRvQnVmZmVyfHRvQmFzZTY0fHRvSGV4IHNpbmNlIGl0IGlzIG5vdCAnICtcbiAgICAgICAgICAgICAgICAnQklQMTc0IGNvbXBsaWFudC5cXG4qKioqKioqKioqKioqKioqKioqKipcXG5QUk9DRUVEIFdJVEggQ0FVVElPTiFcXG4nICtcbiAgICAgICAgICAgICAgICAnKioqKioqKioqKioqKioqKioqKioqJyk7XG4gICAgICAgIGhhc2ggPSB1bnNpZ25lZFR4Lmhhc2hGb3JTaWduYXR1cmUoaW5wdXRJbmRleCwgbWVhbmluZ2Z1bFNjcmlwdCwgc2lnaGFzaFR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY3JpcHQ6IG1lYW5pbmdmdWxTY3JpcHQsXG4gICAgICAgIHNpZ2hhc2hUeXBlLFxuICAgICAgICBoYXNoLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRBbGxUYXByb290SGFzaGVzRm9yU2lnKGlucHV0SW5kZXgsIGlucHV0LCBpbnB1dHMsIGNhY2hlKSB7XG4gICAgY29uc3QgYWxsUHVibGljS2V5cyA9IFtdO1xuICAgIGlmIChpbnB1dC50YXBJbnRlcm5hbEtleSkge1xuICAgICAgICBjb25zdCBvdXRwdXRLZXkgPSAoMCwgYmlwMzcxXzEudHdlYWtJbnRlcm5hbFB1YktleSkoaW5wdXRJbmRleCwgaW5wdXQpO1xuICAgICAgICBhbGxQdWJsaWNLZXlzLnB1c2gob3V0cHV0S2V5KTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnRhcFNjcmlwdFNpZykge1xuICAgICAgICBjb25zdCB0YXBTY3JpcHRQdWJrZXlzID0gaW5wdXQudGFwU2NyaXB0U2lnLm1hcCh0c3MgPT4gdHNzLnB1YmtleSk7XG4gICAgICAgIGFsbFB1YmxpY0tleXMucHVzaCguLi50YXBTY3JpcHRQdWJrZXlzKTtcbiAgICB9XG4gICAgY29uc3QgYWxsSGFzaGVzID0gYWxsUHVibGljS2V5cy5tYXAocHViaWNLZXkgPT4gZ2V0VGFwcm9vdEhhc2hlc0ZvclNpZyhpbnB1dEluZGV4LCBpbnB1dCwgaW5wdXRzLCBwdWJpY0tleSwgY2FjaGUpKTtcbiAgICByZXR1cm4gYWxsSGFzaGVzLmZsYXQoKTtcbn1cbmZ1bmN0aW9uIGdldFRhcHJvb3RIYXNoZXNGb3JTaWcoaW5wdXRJbmRleCwgaW5wdXQsIGlucHV0cywgcHVia2V5LCBjYWNoZSwgdGFwTGVhZkhhc2hUb1NpZ24sIGFsbG93ZWRTaWdoYXNoVHlwZXMpIHtcbiAgICBjb25zdCB1bnNpZ25lZFR4ID0gY2FjaGUuX19UWDtcbiAgICBjb25zdCBzaWdoYXNoVHlwZSA9IGlucHV0LnNpZ2hhc2hUeXBlIHx8IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUO1xuICAgIGNoZWNrU2lnaGFzaFR5cGVBbGxvd2VkKHNpZ2hhc2hUeXBlLCBhbGxvd2VkU2lnaGFzaFR5cGVzKTtcbiAgICBjb25zdCBwcmV2T3V0cyA9IGlucHV0cy5tYXAoKGksIGluZGV4KSA9PiBnZXRTY3JpcHRBbmRBbW91bnRGcm9tVXR4byhpbmRleCwgaSwgY2FjaGUpKTtcbiAgICBjb25zdCBzaWduaW5nU2NyaXB0cyA9IHByZXZPdXRzLm1hcChvID0+IG8uc2NyaXB0KTtcbiAgICBjb25zdCB2YWx1ZXMgPSBwcmV2T3V0cy5tYXAobyA9PiBvLnZhbHVlKTtcbiAgICBjb25zdCBoYXNoZXMgPSBbXTtcbiAgICBpZiAoaW5wdXQudGFwSW50ZXJuYWxLZXkgJiYgIXRhcExlYWZIYXNoVG9TaWduKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEtleSA9ICgwLCBiaXAzNzFfMS50d2Vha0ludGVybmFsUHViS2V5KShpbnB1dEluZGV4LCBpbnB1dCk7XG4gICAgICAgIGlmICgoMCwgYmlwMzcxXzEudG9YT25seSkocHVia2V5KS5lcXVhbHMob3V0cHV0S2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdGFwS2V5SGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvcldpdG5lc3NWMShpbnB1dEluZGV4LCBzaWduaW5nU2NyaXB0cywgdmFsdWVzLCBzaWdoYXNoVHlwZSk7XG4gICAgICAgICAgICBoYXNoZXMucHVzaCh7IHB1YmtleSwgaGFzaDogdGFwS2V5SGFzaCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXBMZWFmSGFzaGVzID0gKGlucHV0LnRhcExlYWZTY3JpcHQgfHwgW10pXG4gICAgICAgIC5maWx0ZXIodGFwTGVhZiA9PiAoMCwgcHNidHV0aWxzXzEucHVia2V5SW5TY3JpcHQpKHB1YmtleSwgdGFwTGVhZi5zY3JpcHQpKVxuICAgICAgICAubWFwKHRhcExlYWYgPT4ge1xuICAgICAgICBjb25zdCBoYXNoID0gKDAsIGJpcDM0MV8xLnRhcGxlYWZIYXNoKSh7XG4gICAgICAgICAgICBvdXRwdXQ6IHRhcExlYWYuc2NyaXB0LFxuICAgICAgICAgICAgdmVyc2lvbjogdGFwTGVhZi5sZWFmVmVyc2lvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgaGFzaCB9LCB0YXBMZWFmKTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKHRhcExlYWYgPT4gIXRhcExlYWZIYXNoVG9TaWduIHx8IHRhcExlYWZIYXNoVG9TaWduLmVxdWFscyh0YXBMZWFmLmhhc2gpKVxuICAgICAgICAubWFwKHRhcExlYWYgPT4ge1xuICAgICAgICBjb25zdCB0YXBTY3JpcHRIYXNoID0gdW5zaWduZWRUeC5oYXNoRm9yV2l0bmVzc1YxKGlucHV0SW5kZXgsIHNpZ25pbmdTY3JpcHRzLCB2YWx1ZXMsIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxULCB0YXBMZWFmLmhhc2gpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgaGFzaDogdGFwU2NyaXB0SGFzaCxcbiAgICAgICAgICAgIGxlYWZIYXNoOiB0YXBMZWFmLmhhc2gsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhc2hlcy5jb25jYXQodGFwTGVhZkhhc2hlcyk7XG59XG5mdW5jdGlvbiBjaGVja1NpZ2hhc2hUeXBlQWxsb3dlZChzaWdoYXNoVHlwZSwgc2lnaGFzaFR5cGVzKSB7XG4gICAgaWYgKHNpZ2hhc2hUeXBlcyAmJiBzaWdoYXNoVHlwZXMuaW5kZXhPZihzaWdoYXNoVHlwZSkgPCAwKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IHNpZ2hhc2hUeXBlVG9TdHJpbmcoc2lnaGFzaFR5cGUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ2hhc2ggdHlwZSBpcyBub3QgYWxsb3dlZC4gUmV0cnkgdGhlIHNpZ24gbWV0aG9kIHBhc3NpbmcgdGhlIGAgK1xuICAgICAgICAgICAgYHNpZ2hhc2hUeXBlcyBhcnJheSBvZiB3aGl0ZWxpc3RlZCB0eXBlcy4gU2lnaGFzaCB0eXBlOiAke3N0cn1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQYXltZW50KHNjcmlwdCwgc2NyaXB0VHlwZSwgcGFydGlhbFNpZykge1xuICAgIGxldCBwYXltZW50O1xuICAgIHN3aXRjaCAoc2NyaXB0VHlwZSkge1xuICAgICAgICBjYXNlICdtdWx0aXNpZyc6XG4gICAgICAgICAgICBjb25zdCBzaWdzID0gZ2V0U29ydGVkU2lncyhzY3JpcHQsIHBhcnRpYWxTaWcpO1xuICAgICAgICAgICAgcGF5bWVudCA9IHBheW1lbnRzLnAybXMoe1xuICAgICAgICAgICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZXM6IHNpZ3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwdWJrZXknOlxuICAgICAgICAgICAgcGF5bWVudCA9IHBheW1lbnRzLnAycGsoe1xuICAgICAgICAgICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcGFydGlhbFNpZ1swXS5zaWduYXR1cmUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwdWJrZXloYXNoJzpcbiAgICAgICAgICAgIHBheW1lbnQgPSBwYXltZW50cy5wMnBraCh7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgcHVia2V5OiBwYXJ0aWFsU2lnWzBdLnB1YmtleSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHBhcnRpYWxTaWdbMF0uc2lnbmF0dXJlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2l0bmVzc3B1YmtleWhhc2gnOlxuICAgICAgICAgICAgcGF5bWVudCA9IHBheW1lbnRzLnAyd3BraCh7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgcHVia2V5OiBwYXJ0aWFsU2lnWzBdLnB1YmtleSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHBhcnRpYWxTaWdbMF0uc2lnbmF0dXJlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBheW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRTY3JpcHRGcm9tSW5wdXQoaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKSB7XG4gICAgY29uc3QgdW5zaWduZWRUeCA9IGNhY2hlLl9fVFg7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgICBzY3JpcHQ6IG51bGwsXG4gICAgICAgIGlzU2Vnd2l0OiBmYWxzZSxcbiAgICAgICAgaXNQMlNIOiBmYWxzZSxcbiAgICAgICAgaXNQMldTSDogZmFsc2UsXG4gICAgfTtcbiAgICByZXMuaXNQMlNIID0gISFpbnB1dC5yZWRlZW1TY3JpcHQ7XG4gICAgcmVzLmlzUDJXU0ggPSAhIWlucHV0LndpdG5lc3NTY3JpcHQ7XG4gICAgaWYgKGlucHV0LndpdG5lc3NTY3JpcHQpIHtcbiAgICAgICAgcmVzLnNjcmlwdCA9IGlucHV0LndpdG5lc3NTY3JpcHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0LnJlZGVlbVNjcmlwdCkge1xuICAgICAgICByZXMuc2NyaXB0ID0gaW5wdXQucmVkZWVtU2NyaXB0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvKSB7XG4gICAgICAgICAgICBjb25zdCBub25XaXRuZXNzVXR4b1R4ID0gbm9uV2l0bmVzc1V0eG9UeEZyb21DYWNoZShjYWNoZSwgaW5wdXQsIGlucHV0SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgcHJldm91dEluZGV4ID0gdW5zaWduZWRUeC5pbnNbaW5wdXRJbmRleF0uaW5kZXg7XG4gICAgICAgICAgICByZXMuc2NyaXB0ID0gbm9uV2l0bmVzc1V0eG9UeC5vdXRzW3ByZXZvdXRJbmRleF0uc2NyaXB0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgICAgICAgICByZXMuc2NyaXB0ID0gaW5wdXQud2l0bmVzc1V0eG8uc2NyaXB0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dC53aXRuZXNzU2NyaXB0IHx8ICgwLCBwc2J0dXRpbHNfMS5pc1AyV1BLSCkocmVzLnNjcmlwdCkpIHtcbiAgICAgICAgcmVzLmlzU2Vnd2l0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldFNpZ25lcnNGcm9tSEQoaW5wdXRJbmRleCwgaW5wdXRzLCBoZEtleVBhaXIpIHtcbiAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKGlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCFpbnB1dC5iaXAzMkRlcml2YXRpb24gfHwgaW5wdXQuYmlwMzJEZXJpdmF0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgYmlwMzJEZXJpdmF0aW9uIHRvIHNpZ24gd2l0aCBIRCcpO1xuICAgIH1cbiAgICBjb25zdCBteURlcml2YXRpb25zID0gaW5wdXQuYmlwMzJEZXJpdmF0aW9uXG4gICAgICAgIC5tYXAoYmlwRHYgPT4ge1xuICAgICAgICBpZiAoYmlwRHYubWFzdGVyRmluZ2VycHJpbnQuZXF1YWxzKGhkS2V5UGFpci5maW5nZXJwcmludCkpIHtcbiAgICAgICAgICAgIHJldHVybiBiaXBEdjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5maWx0ZXIodiA9PiAhIXYpO1xuICAgIGlmIChteURlcml2YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgb25lIGJpcDMyRGVyaXZhdGlvbiBtYXN0ZXJGaW5nZXJwcmludCB0byBtYXRjaCB0aGUgSERTaWduZXIgZmluZ2VycHJpbnQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IG15RGVyaXZhdGlvbnMubWFwKGJpcER2ID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGhkS2V5UGFpci5kZXJpdmVQYXRoKGJpcER2LnBhdGgpO1xuICAgICAgICBpZiAoIWJpcER2LnB1YmtleS5lcXVhbHMobm9kZS5wdWJsaWNLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YmtleSBkaWQgbm90IG1hdGNoIGJpcDMyRGVyaXZhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHJldHVybiBzaWduZXJzO1xufVxuZnVuY3Rpb24gZ2V0U29ydGVkU2lncyhzY3JpcHQsIHBhcnRpYWxTaWcpIHtcbiAgICBjb25zdCBwMm1zID0gcGF5bWVudHMucDJtcyh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAgIHJldHVybiBwMm1zXG4gICAgICAgIC5wdWJrZXlzLm1hcChwayA9PiB7XG4gICAgICAgIHJldHVybiAocGFydGlhbFNpZy5maWx0ZXIocHMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBzLnB1YmtleS5lcXVhbHMocGspO1xuICAgICAgICB9KVswXSB8fCB7fSkuc2lnbmF0dXJlO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIodiA9PiAhIXYpO1xufVxuZnVuY3Rpb24gc2NyaXB0V2l0bmVzc1RvV2l0bmVzc1N0YWNrKGJ1ZmZlcikge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZ1bmN0aW9uIHJlYWRTbGljZShuKSB7XG4gICAgICAgIG9mZnNldCArPSBuO1xuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKG9mZnNldCAtIG4sIG9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRWYXJJbnQoKSB7XG4gICAgICAgIGNvbnN0IHZpID0gdmFydWludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gdmFydWludC5kZWNvZGUuYnl0ZXM7XG4gICAgICAgIHJldHVybiB2aTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZFZhclNsaWNlKCkge1xuICAgICAgICByZXR1cm4gcmVhZFNsaWNlKHJlYWRWYXJJbnQoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRWZWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gcmVhZFZhckludCgpO1xuICAgICAgICBjb25zdCB2ZWN0b3IgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgICAgICAgdmVjdG9yLnB1c2gocmVhZFZhclNsaWNlKCkpO1xuICAgICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVhZFZlY3RvcigpO1xufVxuZnVuY3Rpb24gc2lnaGFzaFR5cGVUb1N0cmluZyhzaWdoYXNoVHlwZSkge1xuICAgIGxldCB0ZXh0ID0gc2lnaGFzaFR5cGUgJiB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZXG4gICAgICAgID8gJ1NJR0hBU0hfQU5ZT05FQ0FOUEFZIHwgJ1xuICAgICAgICA6ICcnO1xuICAgIGNvbnN0IHNpZ01vZCA9IHNpZ2hhc2hUeXBlICYgMHgxZjtcbiAgICBzd2l0Y2ggKHNpZ01vZCkge1xuICAgICAgICBjYXNlIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw6XG4gICAgICAgICAgICB0ZXh0ICs9ICdTSUdIQVNIX0FMTCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFOlxuICAgICAgICAgICAgdGV4dCArPSAnU0lHSEFTSF9TSU5HTEUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX05PTkU6XG4gICAgICAgICAgICB0ZXh0ICs9ICdTSUdIQVNIX05PTkUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gYWRkTm9uV2l0bmVzc1R4Q2FjaGUoY2FjaGUsIGlucHV0LCBpbnB1dEluZGV4KSB7XG4gICAgY2FjaGUuX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRVtpbnB1dEluZGV4XSA9IGlucHV0Lm5vbldpdG5lc3NVdHhvO1xuICAgIGNvbnN0IHR4ID0gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tQnVmZmVyKGlucHV0Lm5vbldpdG5lc3NVdHhvKTtcbiAgICBjYWNoZS5fX05PTl9XSVRORVNTX1VUWE9fVFhfQ0FDSEVbaW5wdXRJbmRleF0gPSB0eDtcbiAgICBjb25zdCBzZWxmID0gY2FjaGU7XG4gICAgY29uc3Qgc2VsZkluZGV4ID0gaW5wdXRJbmRleDtcbiAgICBkZWxldGUgaW5wdXQubm9uV2l0bmVzc1V0eG87XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGlucHV0LCAnbm9uV2l0bmVzc1V0eG8nLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHNlbGYuX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRVtzZWxmSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgdHhDYWNoZSA9IHNlbGYuX19OT05fV0lUTkVTU19VVFhPX1RYX0NBQ0hFW3NlbGZJbmRleF07XG4gICAgICAgICAgICBpZiAoYnVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QnVmID0gdHhDYWNoZS50b0J1ZmZlcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRVtzZWxmSW5kZXhdID0gbmV3QnVmO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdCdWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldChkYXRhKSB7XG4gICAgICAgICAgICBzZWxmLl9fTk9OX1dJVE5FU1NfVVRYT19CVUZfQ0FDSEVbc2VsZkluZGV4XSA9IGRhdGE7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbnB1dEZpbmFsaXplR2V0QW10cyhpbnB1dHMsIHR4LCBjYWNoZSwgbXVzdEZpbmFsaXplKSB7XG4gICAgbGV0IGlucHV0QW1vdW50ID0gMDtcbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGlkeCkgPT4ge1xuICAgICAgICBpZiAobXVzdEZpbmFsaXplICYmIGlucHV0LmZpbmFsU2NyaXB0U2lnKVxuICAgICAgICAgICAgdHguaW5zW2lkeF0uc2NyaXB0ID0gaW5wdXQuZmluYWxTY3JpcHRTaWc7XG4gICAgICAgIGlmIChtdXN0RmluYWxpemUgJiYgaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzKSB7XG4gICAgICAgICAgICB0eC5pbnNbaWR4XS53aXRuZXNzID0gc2NyaXB0V2l0bmVzc1RvV2l0bmVzc1N0YWNrKGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgICAgICAgICBpbnB1dEFtb3VudCArPSBpbnB1dC53aXRuZXNzVXR4by52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgICAgICAgICAgY29uc3QgbndUeCA9IG5vbldpdG5lc3NVdHhvVHhGcm9tQ2FjaGUoY2FjaGUsIGlucHV0LCBpZHgpO1xuICAgICAgICAgICAgY29uc3Qgdm91dCA9IHR4Lmluc1tpZHhdLmluZGV4O1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gbndUeC5vdXRzW3ZvdXRdO1xuICAgICAgICAgICAgaW5wdXRBbW91bnQgKz0gb3V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gdHgub3V0cy5yZWR1Y2UoKHRvdGFsLCBvKSA9PiB0b3RhbCArIG8udmFsdWUsIDApO1xuICAgIGNvbnN0IGZlZSA9IGlucHV0QW1vdW50IC0gb3V0cHV0QW1vdW50O1xuICAgIGlmIChmZWUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0cyBhcmUgc3BlbmRpbmcgbW9yZSB0aGFuIElucHV0cycpO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IHR4LnZpcnR1YWxTaXplKCk7XG4gICAgY2FjaGUuX19GRUUgPSBmZWU7XG4gICAgY2FjaGUuX19FWFRSQUNURURfVFggPSB0eDtcbiAgICBjYWNoZS5fX0ZFRV9SQVRFID0gTWF0aC5mbG9vcihmZWUgLyBieXRlcyk7XG59XG5mdW5jdGlvbiBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKGNhY2hlLCBpbnB1dCwgaW5wdXRJbmRleCkge1xuICAgIGNvbnN0IGMgPSBjYWNoZS5fX05PTl9XSVRORVNTX1VUWE9fVFhfQ0FDSEU7XG4gICAgaWYgKCFjW2lucHV0SW5kZXhdKSB7XG4gICAgICAgIGFkZE5vbldpdG5lc3NUeENhY2hlKGNhY2hlLCBpbnB1dCwgaW5wdXRJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBjW2lucHV0SW5kZXhdO1xufVxuZnVuY3Rpb24gZ2V0U2NyaXB0RnJvbVV0eG8oaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKSB7XG4gICAgY29uc3QgeyBzY3JpcHQgfSA9IGdldFNjcmlwdEFuZEFtb3VudEZyb21VdHhvKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSk7XG4gICAgcmV0dXJuIHNjcmlwdDtcbn1cbmZ1bmN0aW9uIGdldFNjcmlwdEFuZEFtb3VudEZyb21VdHhvKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSkge1xuICAgIGlmIChpbnB1dC53aXRuZXNzVXR4byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY3JpcHQ6IGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdCxcbiAgICAgICAgICAgIHZhbHVlOiBpbnB1dC53aXRuZXNzVXR4by52YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQubm9uV2l0bmVzc1V0eG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBub25XaXRuZXNzVXR4b1R4ID0gbm9uV2l0bmVzc1V0eG9UeEZyb21DYWNoZShjYWNoZSwgaW5wdXQsIGlucHV0SW5kZXgpO1xuICAgICAgICBjb25zdCBvID0gbm9uV2l0bmVzc1V0eG9UeC5vdXRzW2NhY2hlLl9fVFguaW5zW2lucHV0SW5kZXhdLmluZGV4XTtcbiAgICAgICAgcmV0dXJuIHsgc2NyaXB0OiBvLnNjcmlwdCwgdmFsdWU6IG8udmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgcHVia2V5IGluIGlucHV0IHdpdGhvdXQgVXR4byBkYXRhXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1YmtleUluSW5wdXQocHVia2V5LCBpbnB1dCwgaW5wdXRJbmRleCwgY2FjaGUpIHtcbiAgICBjb25zdCBzY3JpcHQgPSBnZXRTY3JpcHRGcm9tVXR4byhpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpO1xuICAgIGNvbnN0IHsgbWVhbmluZ2Z1bFNjcmlwdCB9ID0gZ2V0TWVhbmluZ2Z1bFNjcmlwdChzY3JpcHQsIGlucHV0SW5kZXgsICdpbnB1dCcsIGlucHV0LnJlZGVlbVNjcmlwdCwgaW5wdXQud2l0bmVzc1NjcmlwdCk7XG4gICAgcmV0dXJuICgwLCBwc2J0dXRpbHNfMS5wdWJrZXlJblNjcmlwdCkocHVia2V5LCBtZWFuaW5nZnVsU2NyaXB0KTtcbn1cbmZ1bmN0aW9uIHB1YmtleUluT3V0cHV0KHB1YmtleSwgb3V0cHV0LCBvdXRwdXRJbmRleCwgY2FjaGUpIHtcbiAgICBjb25zdCBzY3JpcHQgPSBjYWNoZS5fX1RYLm91dHNbb3V0cHV0SW5kZXhdLnNjcmlwdDtcbiAgICBjb25zdCB7IG1lYW5pbmdmdWxTY3JpcHQgfSA9IGdldE1lYW5pbmdmdWxTY3JpcHQoc2NyaXB0LCBvdXRwdXRJbmRleCwgJ291dHB1dCcsIG91dHB1dC5yZWRlZW1TY3JpcHQsIG91dHB1dC53aXRuZXNzU2NyaXB0KTtcbiAgICByZXR1cm4gKDAsIHBzYnR1dGlsc18xLnB1YmtleUluU2NyaXB0KShwdWJrZXksIG1lYW5pbmdmdWxTY3JpcHQpO1xufVxuZnVuY3Rpb24gcmVkZWVtRnJvbUZpbmFsU2NyaXB0U2lnKGZpbmFsU2NyaXB0KSB7XG4gICAgaWYgKCFmaW5hbFNjcmlwdClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRlY29tcCA9IGJzY3JpcHQuZGVjb21waWxlKGZpbmFsU2NyaXB0KTtcbiAgICBpZiAoIWRlY29tcClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxhc3RJdGVtID0gZGVjb21wW2RlY29tcC5sZW5ndGggLSAxXTtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihsYXN0SXRlbSkgfHxcbiAgICAgICAgaXNQdWJrZXlMaWtlKGxhc3RJdGVtKSB8fFxuICAgICAgICBpc1NpZ0xpa2UobGFzdEl0ZW0pKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qgc0RlY29tcCA9IGJzY3JpcHQuZGVjb21waWxlKGxhc3RJdGVtKTtcbiAgICBpZiAoIXNEZWNvbXApXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gbGFzdEl0ZW07XG59XG5mdW5jdGlvbiByZWRlZW1Gcm9tRmluYWxXaXRuZXNzU2NyaXB0KGZpbmFsU2NyaXB0KSB7XG4gICAgaWYgKCFmaW5hbFNjcmlwdClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRlY29tcCA9IHNjcmlwdFdpdG5lc3NUb1dpdG5lc3NTdGFjayhmaW5hbFNjcmlwdCk7XG4gICAgY29uc3QgbGFzdEl0ZW0gPSBkZWNvbXBbZGVjb21wLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc1B1YmtleUxpa2UobGFzdEl0ZW0pKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qgc0RlY29tcCA9IGJzY3JpcHQuZGVjb21waWxlKGxhc3RJdGVtKTtcbiAgICBpZiAoIXNEZWNvbXApXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gbGFzdEl0ZW07XG59XG5mdW5jdGlvbiBjb21wcmVzc1B1YmtleShwdWJrZXkpIHtcbiAgICBpZiAocHVia2V5Lmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgY29uc3QgcGFyaXR5ID0gcHVia2V5WzY0XSAmIDE7XG4gICAgICAgIGNvbnN0IG5ld0tleSA9IHB1YmtleS5zbGljZSgwLCAzMyk7XG4gICAgICAgIG5ld0tleVswXSA9IDIgfCBwYXJpdHk7XG4gICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfVxuICAgIHJldHVybiBwdWJrZXkuc2xpY2UoKTtcbn1cbmZ1bmN0aW9uIGlzUHVia2V5TGlrZShidWYpIHtcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA9PT0gMzMgJiYgYnNjcmlwdC5pc0Nhbm9uaWNhbFB1YktleShidWYpO1xufVxuZnVuY3Rpb24gaXNTaWdMaWtlKGJ1Zikge1xuICAgIHJldHVybiBic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGJ1Zik7XG59XG5mdW5jdGlvbiBnZXRNZWFuaW5nZnVsU2NyaXB0KHNjcmlwdCwgaW5kZXgsIGlvVHlwZSwgcmVkZWVtU2NyaXB0LCB3aXRuZXNzU2NyaXB0KSB7XG4gICAgY29uc3QgaXNQMlNIID0gKDAsIHBzYnR1dGlsc18xLmlzUDJTSFNjcmlwdCkoc2NyaXB0KTtcbiAgICBjb25zdCBpc1AyU0hQMldTSCA9IGlzUDJTSCAmJiByZWRlZW1TY3JpcHQgJiYgKDAsIHBzYnR1dGlsc18xLmlzUDJXU0hTY3JpcHQpKHJlZGVlbVNjcmlwdCk7XG4gICAgY29uc3QgaXNQMldTSCA9ICgwLCBwc2J0dXRpbHNfMS5pc1AyV1NIU2NyaXB0KShzY3JpcHQpO1xuICAgIGlmIChpc1AyU0ggJiYgcmVkZWVtU2NyaXB0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2NyaXB0UHVia2V5IGlzIFAyU0ggYnV0IHJlZGVlbVNjcmlwdCBtaXNzaW5nJyk7XG4gICAgaWYgKChpc1AyV1NIIHx8IGlzUDJTSFAyV1NIKSAmJiB3aXRuZXNzU2NyaXB0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2NyaXB0UHVia2V5IG9yIHJlZGVlbVNjcmlwdCBpcyBQMldTSCBidXQgd2l0bmVzc1NjcmlwdCBtaXNzaW5nJyk7XG4gICAgbGV0IG1lYW5pbmdmdWxTY3JpcHQ7XG4gICAgaWYgKGlzUDJTSFAyV1NIKSB7XG4gICAgICAgIG1lYW5pbmdmdWxTY3JpcHQgPSB3aXRuZXNzU2NyaXB0O1xuICAgICAgICBjaGVja1JlZGVlbVNjcmlwdChpbmRleCwgc2NyaXB0LCByZWRlZW1TY3JpcHQsIGlvVHlwZSk7XG4gICAgICAgIGNoZWNrV2l0bmVzc1NjcmlwdChpbmRleCwgcmVkZWVtU2NyaXB0LCB3aXRuZXNzU2NyaXB0LCBpb1R5cGUpO1xuICAgICAgICBjaGVja0ludmFsaWRQMldTSChtZWFuaW5nZnVsU2NyaXB0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQMldTSCkge1xuICAgICAgICBtZWFuaW5nZnVsU2NyaXB0ID0gd2l0bmVzc1NjcmlwdDtcbiAgICAgICAgY2hlY2tXaXRuZXNzU2NyaXB0KGluZGV4LCBzY3JpcHQsIHdpdG5lc3NTY3JpcHQsIGlvVHlwZSk7XG4gICAgICAgIGNoZWNrSW52YWxpZFAyV1NIKG1lYW5pbmdmdWxTY3JpcHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1AyU0gpIHtcbiAgICAgICAgbWVhbmluZ2Z1bFNjcmlwdCA9IHJlZGVlbVNjcmlwdDtcbiAgICAgICAgY2hlY2tSZWRlZW1TY3JpcHQoaW5kZXgsIHNjcmlwdCwgcmVkZWVtU2NyaXB0LCBpb1R5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWVhbmluZ2Z1bFNjcmlwdCA9IHNjcmlwdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVhbmluZ2Z1bFNjcmlwdCxcbiAgICAgICAgdHlwZTogaXNQMlNIUDJXU0hcbiAgICAgICAgICAgID8gJ3Ayc2gtcDJ3c2gnXG4gICAgICAgICAgICA6IGlzUDJTSFxuICAgICAgICAgICAgICAgID8gJ3Ayc2gnXG4gICAgICAgICAgICAgICAgOiBpc1AyV1NIXG4gICAgICAgICAgICAgICAgICAgID8gJ3Ayd3NoJ1xuICAgICAgICAgICAgICAgICAgICA6ICdyYXcnLFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja0ludmFsaWRQMldTSChzY3JpcHQpIHtcbiAgICBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJXUEtIKShzY3JpcHQpIHx8ICgwLCBwc2J0dXRpbHNfMS5pc1AyU0hTY3JpcHQpKHNjcmlwdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQMldQS0ggb3IgUDJTSCBjYW4gbm90IGJlIGNvbnRhaW5lZCB3aXRoaW4gUDJXU0gnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGFzc2lmeVNjcmlwdChzY3JpcHQpIHtcbiAgICBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJXUEtIKShzY3JpcHQpKVxuICAgICAgICByZXR1cm4gJ3dpdG5lc3NwdWJrZXloYXNoJztcbiAgICBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJQS0gpKHNjcmlwdCkpXG4gICAgICAgIHJldHVybiAncHVia2V5aGFzaCc7XG4gICAgaWYgKCgwLCBwc2J0dXRpbHNfMS5pc1AyTVMpKHNjcmlwdCkpXG4gICAgICAgIHJldHVybiAnbXVsdGlzaWcnO1xuICAgIGlmICgoMCwgcHNidHV0aWxzXzEuaXNQMlBLKShzY3JpcHQpKVxuICAgICAgICByZXR1cm4gJ3B1YmtleSc7XG4gICAgcmV0dXJuICdub25zdGFuZGFyZCc7XG59XG5mdW5jdGlvbiByYW5nZShuKSB7XG4gICAgcmV0dXJuIFsuLi5BcnJheShuKS5rZXlzKCldO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHNidC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/bip371.js':
    /*!******************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/bip371.js ***!
  \******************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.checkTaprootInputForSigs = exports.tapTreeFromList = exports.tapTreeToList = exports.tweakInternalPubKey = exports.checkTaprootOutputFields = exports.checkTaprootInputFields = exports.isTaprootOutput = exports.isTaprootInput = exports.serializeTaprootSignature = exports.tapScriptFinalizer = exports.toXOnly = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js");\nconst transaction_1 = __webpack_require__(/*! ../transaction */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/transaction.js");\nconst psbtutils_1 = __webpack_require__(/*! ./psbtutils */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/psbtutils.js");\nconst bip341_1 = __webpack_require__(/*! ../payments/bip341 */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/bip341.js");\nconst payments_1 = __webpack_require__(/*! ../payments */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js");\nconst psbtutils_2 = __webpack_require__(/*! ./psbtutils */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/psbtutils.js");\nconst toXOnly = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);\nexports.toXOnly = toXOnly;\nfunction tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n    const tapLeaf = findTapLeafToFinalize(input, inputIndex, tapLeafHashToFinalize);\n    try {\n        const sigs = sortSignatures(input, tapLeaf);\n        const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n        return { finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness) };\n    }\n    catch (err) {\n        throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n    }\n}\nexports.tapScriptFinalizer = tapScriptFinalizer;\nfunction serializeTaprootSignature(sig, sighashType) {\n    const sighashTypeByte = sighashType\n        ? Buffer.from([sighashType])\n        : Buffer.from([]);\n    return Buffer.concat([sig, sighashTypeByte]);\n}\nexports.serializeTaprootSignature = serializeTaprootSignature;\nfunction isTaprootInput(input) {\n    return (input &&\n        !!(input.tapInternalKey ||\n            input.tapMerkleRoot ||\n            (input.tapLeafScript && input.tapLeafScript.length) ||\n            (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n            (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))));\n}\nexports.isTaprootInput = isTaprootInput;\nfunction isTaprootOutput(output, script) {\n    return (output &&\n        !!(output.tapInternalKey ||\n            output.tapTree ||\n            (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n            (script && (0, psbtutils_1.isP2TR)(script))));\n}\nexports.isTaprootOutput = isTaprootOutput;\nfunction checkTaprootInputFields(inputData, newInputData, action) {\n    checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n    checkIfTapLeafInTree(inputData, newInputData, action);\n}\nexports.checkTaprootInputFields = checkTaprootInputFields;\nfunction checkTaprootOutputFields(outputData, newOutputData, action) {\n    checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n    checkTaprootScriptPubkey(outputData, newOutputData);\n}\nexports.checkTaprootOutputFields = checkTaprootOutputFields;\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n    if (!newOutputData.tapTree && !newOutputData.tapInternalKey)\n        return;\n    const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;\n    const tapTree = newOutputData.tapTree || outputData.tapTree;\n    if (tapInternalKey) {\n        const { script: scriptPubkey } = outputData;\n        const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n        if (scriptPubkey && !scriptPubkey.equals(script))\n            throw new Error(\'Error adding output. Script or address missmatch.\');\n    }\n}\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n    const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n    const { output } = (0, payments_1.p2tr)({\n        internalPubkey: tapInternalKey,\n        scriptTree,\n    });\n    return output;\n}\nfunction tweakInternalPubKey(inputIndex, input) {\n    const tapInternalKey = input.tapInternalKey;\n    const outputKey = tapInternalKey && (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);\n    if (!outputKey)\n        throw new Error(`Cannot tweak tap internal key for input #${inputIndex}. Public key: ${tapInternalKey && tapInternalKey.toString(\'hex\')}`);\n    return outputKey.x;\n}\nexports.tweakInternalPubKey = tweakInternalPubKey;\nfunction tapTreeToList(tree) {\n    if (!(0, types_1.isTaptree)(tree))\n        throw new Error(\'Cannot convert taptree to tapleaf list. Expecting a tapree structure.\');\n    return _tapTreeToList(tree);\n}\nexports.tapTreeToList = tapTreeToList;\nfunction tapTreeFromList(leaves = []) {\n    if (leaves.length === 1 && leaves[0].depth === 0)\n        return {\n            output: leaves[0].script,\n            version: leaves[0].leafVersion,\n        };\n    return instertLeavesInTree(leaves);\n}\nexports.tapTreeFromList = tapTreeFromList;\nfunction checkTaprootInputForSigs(input, action) {\n    const sigs = extractTaprootSigs(input);\n    return sigs.some(sig => (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action));\n}\nexports.checkTaprootInputForSigs = checkTaprootInputForSigs;\nfunction decodeSchnorrSignature(signature) {\n    return {\n        signature: signature.slice(0, 64),\n        hashType: signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,\n    };\n}\nfunction extractTaprootSigs(input) {\n    const sigs = [];\n    if (input.tapKeySig)\n        sigs.push(input.tapKeySig);\n    if (input.tapScriptSig)\n        sigs.push(...input.tapScriptSig.map(s => s.signature));\n    if (!sigs.length) {\n        const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n        if (finalTapKeySig)\n            sigs.push(finalTapKeySig);\n    }\n    return sigs;\n}\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n    if (!finalScriptWitness)\n        return;\n    const witness = finalScriptWitness.slice(2);\n    if (witness.length === 64 || witness.length === 65)\n        return witness;\n}\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n    if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n        throw new Error(\'Max taptree depth exceeded.\');\n    if (!tree)\n        return [];\n    if ((0, types_1.isTapleaf)(tree)) {\n        leaves.push({\n            depth,\n            leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,\n            script: tree.output,\n        });\n        return leaves;\n    }\n    if (tree[0])\n        _tapTreeToList(tree[0], leaves, depth + 1);\n    if (tree[1])\n        _tapTreeToList(tree[1], leaves, depth + 1);\n    return leaves;\n}\nfunction instertLeavesInTree(leaves) {\n    let tree;\n    for (const leaf of leaves) {\n        tree = instertLeafInTree(leaf, tree);\n        if (!tree)\n            throw new Error(`No room left to insert tapleaf in tree`);\n    }\n    return tree;\n}\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n    if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n        throw new Error(\'Max taptree depth exceeded.\');\n    if (leaf.depth === depth) {\n        if (!tree)\n            return {\n                output: leaf.script,\n                version: leaf.leafVersion,\n            };\n        return;\n    }\n    if ((0, types_1.isTapleaf)(tree))\n        return;\n    const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n    if (leftSide)\n        return [leftSide, tree && tree[1]];\n    const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n    if (rightSide)\n        return [tree && tree[0], rightSide];\n}\nfunction checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {\n    const isBadTaprootUpdate = isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n    const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n    const hasMixedFields = inputData === newInputData &&\n        isTaprootInput(newInputData) &&\n        hasNonTaprootFields(newInputData);\n    if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n        throw new Error(`Invalid arguments for Psbt.${action}. ` +\n            `Cannot use both taproot and non-taproot fields.`);\n}\nfunction checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {\n    const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n    const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n    const hasMixedFields = inputData === newInputData &&\n        isTaprootOutput(newInputData) &&\n        hasNonTaprootFields(newInputData);\n    if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n        throw new Error(`Invalid arguments for Psbt.${action}. ` +\n            `Cannot use both taproot and non-taproot fields.`);\n}\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n    if (newInputData.tapMerkleRoot) {\n        const newLeafsInTree = (newInputData.tapLeafScript || []).every(l => isTapLeafInTree(l, newInputData.tapMerkleRoot));\n        const oldLeafsInTree = (inputData.tapLeafScript || []).every(l => isTapLeafInTree(l, newInputData.tapMerkleRoot));\n        if (!newLeafsInTree || !oldLeafsInTree)\n            throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);\n    }\n    else if (inputData.tapMerkleRoot) {\n        const newLeafsInTree = (newInputData.tapLeafScript || []).every(l => isTapLeafInTree(l, inputData.tapMerkleRoot));\n        if (!newLeafsInTree)\n            throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);\n    }\n}\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n    if (!merkleRoot)\n        return true;\n    const leafHash = (0, bip341_1.tapleafHash)({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n    });\n    const rootHash = (0, bip341_1.rootHashFromPath)(tapLeaf.controlBlock, leafHash);\n    return rootHash.equals(merkleRoot);\n}\nfunction sortSignatures(input, tapLeaf) {\n    const leafHash = (0, bip341_1.tapleafHash)({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n    });\n    return (input.tapScriptSig || [])\n        .filter(tss => tss.leafHash.equals(leafHash))\n        .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n        .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n        .map(t => t.signature);\n}\nfunction addPubkeyPositionInScript(script, tss) {\n    return Object.assign({\n        positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(tss.pubkey, script),\n    }, tss);\n}\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n    if (!input.tapScriptSig || !input.tapScriptSig.length)\n        throw new Error(`Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`);\n    const tapLeaf = (input.tapLeafScript || [])\n        .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n        .find(leaf => canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize));\n    if (!tapLeaf)\n        throw new Error(`Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`);\n    return tapLeaf;\n}\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n    const leafHash = (0, bip341_1.tapleafHash)({\n        output: leaf.script,\n        version: leaf.leafVersion,\n    });\n    const whiteListedHash = !hash || hash.equals(leafHash);\n    return (whiteListedHash &&\n        tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined);\n}\nfunction hasNonTaprootFields(io) {\n    return (io &&\n        !!(io.redeemScript ||\n            io.witnessScript ||\n            (io.bip32Derivation && io.bip32Derivation.length)));\n}\n//# sourceMappingURL=bip371.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wc2J0L2JpcDM3MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxnQ0FBZ0MsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxpQ0FBaUMsR0FBRywwQkFBMEIsR0FBRyxlQUFlO0FBQzNULGdCQUFnQixtQkFBTyxDQUFDLHdGQUFVO0FBQ2xDLHNCQUFzQixtQkFBTyxDQUFDLG9HQUFnQjtBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxvR0FBYTtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsb0dBQWE7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsb0dBQWE7QUFDekM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMkRBQTJELFdBQVcsSUFBSSxJQUFJO0FBQzlFO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXLGdCQUFnQixpREFBaUQ7QUFDaEo7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvcHNidC9iaXAzNzEuanM/M2Q0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tUYXByb290SW5wdXRGb3JTaWdzID0gZXhwb3J0cy50YXBUcmVlRnJvbUxpc3QgPSBleHBvcnRzLnRhcFRyZWVUb0xpc3QgPSBleHBvcnRzLnR3ZWFrSW50ZXJuYWxQdWJLZXkgPSBleHBvcnRzLmNoZWNrVGFwcm9vdE91dHB1dEZpZWxkcyA9IGV4cG9ydHMuY2hlY2tUYXByb290SW5wdXRGaWVsZHMgPSBleHBvcnRzLmlzVGFwcm9vdE91dHB1dCA9IGV4cG9ydHMuaXNUYXByb290SW5wdXQgPSBleHBvcnRzLnNlcmlhbGl6ZVRhcHJvb3RTaWduYXR1cmUgPSBleHBvcnRzLnRhcFNjcmlwdEZpbmFsaXplciA9IGV4cG9ydHMudG9YT25seSA9IHZvaWQgMDtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgcHNidHV0aWxzXzEgPSByZXF1aXJlKFwiLi9wc2J0dXRpbHNcIik7XG5jb25zdCBiaXAzNDFfMSA9IHJlcXVpcmUoXCIuLi9wYXltZW50cy9iaXAzNDFcIik7XG5jb25zdCBwYXltZW50c18xID0gcmVxdWlyZShcIi4uL3BheW1lbnRzXCIpO1xuY29uc3QgcHNidHV0aWxzXzIgPSByZXF1aXJlKFwiLi9wc2J0dXRpbHNcIik7XG5jb25zdCB0b1hPbmx5ID0gKHB1YktleSkgPT4gcHViS2V5Lmxlbmd0aCA9PT0gMzIgPyBwdWJLZXkgOiBwdWJLZXkuc2xpY2UoMSwgMzMpO1xuZXhwb3J0cy50b1hPbmx5ID0gdG9YT25seTtcbmZ1bmN0aW9uIHRhcFNjcmlwdEZpbmFsaXplcihpbnB1dEluZGV4LCBpbnB1dCwgdGFwTGVhZkhhc2hUb0ZpbmFsaXplKSB7XG4gICAgY29uc3QgdGFwTGVhZiA9IGZpbmRUYXBMZWFmVG9GaW5hbGl6ZShpbnB1dCwgaW5wdXRJbmRleCwgdGFwTGVhZkhhc2hUb0ZpbmFsaXplKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzaWdzID0gc29ydFNpZ25hdHVyZXMoaW5wdXQsIHRhcExlYWYpO1xuICAgICAgICBjb25zdCB3aXRuZXNzID0gc2lncy5jb25jYXQodGFwTGVhZi5zY3JpcHQpLmNvbmNhdCh0YXBMZWFmLmNvbnRyb2xCbG9jayk7XG4gICAgICAgIHJldHVybiB7IGZpbmFsU2NyaXB0V2l0bmVzczogKDAsIHBzYnR1dGlsc18xLndpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcykod2l0bmVzcykgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgZmluYWxpemUgdGFwcm9vdCBpbnB1dCAjJHtpbnB1dEluZGV4fTogJHtlcnJ9YCk7XG4gICAgfVxufVxuZXhwb3J0cy50YXBTY3JpcHRGaW5hbGl6ZXIgPSB0YXBTY3JpcHRGaW5hbGl6ZXI7XG5mdW5jdGlvbiBzZXJpYWxpemVUYXByb290U2lnbmF0dXJlKHNpZywgc2lnaGFzaFR5cGUpIHtcbiAgICBjb25zdCBzaWdoYXNoVHlwZUJ5dGUgPSBzaWdoYXNoVHlwZVxuICAgICAgICA/IEJ1ZmZlci5mcm9tKFtzaWdoYXNoVHlwZV0pXG4gICAgICAgIDogQnVmZmVyLmZyb20oW10pO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtzaWcsIHNpZ2hhc2hUeXBlQnl0ZV0pO1xufVxuZXhwb3J0cy5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlID0gc2VyaWFsaXplVGFwcm9vdFNpZ25hdHVyZTtcbmZ1bmN0aW9uIGlzVGFwcm9vdElucHV0KGlucHV0KSB7XG4gICAgcmV0dXJuIChpbnB1dCAmJlxuICAgICAgICAhIShpbnB1dC50YXBJbnRlcm5hbEtleSB8fFxuICAgICAgICAgICAgaW5wdXQudGFwTWVya2xlUm9vdCB8fFxuICAgICAgICAgICAgKGlucHV0LnRhcExlYWZTY3JpcHQgJiYgaW5wdXQudGFwTGVhZlNjcmlwdC5sZW5ndGgpIHx8XG4gICAgICAgICAgICAoaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uICYmIGlucHV0LnRhcEJpcDMyRGVyaXZhdGlvbi5sZW5ndGgpIHx8XG4gICAgICAgICAgICAoaW5wdXQud2l0bmVzc1V0eG8gJiYgKDAsIHBzYnR1dGlsc18xLmlzUDJUUikoaW5wdXQud2l0bmVzc1V0eG8uc2NyaXB0KSkpKTtcbn1cbmV4cG9ydHMuaXNUYXByb290SW5wdXQgPSBpc1RhcHJvb3RJbnB1dDtcbmZ1bmN0aW9uIGlzVGFwcm9vdE91dHB1dChvdXRwdXQsIHNjcmlwdCkge1xuICAgIHJldHVybiAob3V0cHV0ICYmXG4gICAgICAgICEhKG91dHB1dC50YXBJbnRlcm5hbEtleSB8fFxuICAgICAgICAgICAgb3V0cHV0LnRhcFRyZWUgfHxcbiAgICAgICAgICAgIChvdXRwdXQudGFwQmlwMzJEZXJpdmF0aW9uICYmIG91dHB1dC50YXBCaXAzMkRlcml2YXRpb24ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKHNjcmlwdCAmJiAoMCwgcHNidHV0aWxzXzEuaXNQMlRSKShzY3JpcHQpKSkpO1xufVxuZXhwb3J0cy5pc1RhcHJvb3RPdXRwdXQgPSBpc1RhcHJvb3RPdXRwdXQ7XG5mdW5jdGlvbiBjaGVja1RhcHJvb3RJbnB1dEZpZWxkcyhpbnB1dERhdGEsIG5ld0lucHV0RGF0YSwgYWN0aW9uKSB7XG4gICAgY2hlY2tNaXhlZFRhcHJvb3RBbmROb25UYXByb290SW5wdXRGaWVsZHMoaW5wdXREYXRhLCBuZXdJbnB1dERhdGEsIGFjdGlvbik7XG4gICAgY2hlY2tJZlRhcExlYWZJblRyZWUoaW5wdXREYXRhLCBuZXdJbnB1dERhdGEsIGFjdGlvbik7XG59XG5leHBvcnRzLmNoZWNrVGFwcm9vdElucHV0RmllbGRzID0gY2hlY2tUYXByb290SW5wdXRGaWVsZHM7XG5mdW5jdGlvbiBjaGVja1RhcHJvb3RPdXRwdXRGaWVsZHMob3V0cHV0RGF0YSwgbmV3T3V0cHV0RGF0YSwgYWN0aW9uKSB7XG4gICAgY2hlY2tNaXhlZFRhcHJvb3RBbmROb25UYXByb290T3V0cHV0RmllbGRzKG91dHB1dERhdGEsIG5ld091dHB1dERhdGEsIGFjdGlvbik7XG4gICAgY2hlY2tUYXByb290U2NyaXB0UHVia2V5KG91dHB1dERhdGEsIG5ld091dHB1dERhdGEpO1xufVxuZXhwb3J0cy5jaGVja1RhcHJvb3RPdXRwdXRGaWVsZHMgPSBjaGVja1RhcHJvb3RPdXRwdXRGaWVsZHM7XG5mdW5jdGlvbiBjaGVja1RhcHJvb3RTY3JpcHRQdWJrZXkob3V0cHV0RGF0YSwgbmV3T3V0cHV0RGF0YSkge1xuICAgIGlmICghbmV3T3V0cHV0RGF0YS50YXBUcmVlICYmICFuZXdPdXRwdXREYXRhLnRhcEludGVybmFsS2V5KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdGFwSW50ZXJuYWxLZXkgPSBuZXdPdXRwdXREYXRhLnRhcEludGVybmFsS2V5IHx8IG91dHB1dERhdGEudGFwSW50ZXJuYWxLZXk7XG4gICAgY29uc3QgdGFwVHJlZSA9IG5ld091dHB1dERhdGEudGFwVHJlZSB8fCBvdXRwdXREYXRhLnRhcFRyZWU7XG4gICAgaWYgKHRhcEludGVybmFsS2V5KSB7XG4gICAgICAgIGNvbnN0IHsgc2NyaXB0OiBzY3JpcHRQdWJrZXkgfSA9IG91dHB1dERhdGE7XG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IGdldFRhcHJvb3RTY3JpcFB1YmtleSh0YXBJbnRlcm5hbEtleSwgdGFwVHJlZSk7XG4gICAgICAgIGlmIChzY3JpcHRQdWJrZXkgJiYgIXNjcmlwdFB1YmtleS5lcXVhbHMoc2NyaXB0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIG91dHB1dC4gU2NyaXB0IG9yIGFkZHJlc3MgbWlzc21hdGNoLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRhcHJvb3RTY3JpcFB1YmtleSh0YXBJbnRlcm5hbEtleSwgdGFwVHJlZSkge1xuICAgIGNvbnN0IHNjcmlwdFRyZWUgPSB0YXBUcmVlICYmIHRhcFRyZWVGcm9tTGlzdCh0YXBUcmVlLmxlYXZlcyk7XG4gICAgY29uc3QgeyBvdXRwdXQgfSA9ICgwLCBwYXltZW50c18xLnAydHIpKHtcbiAgICAgICAgaW50ZXJuYWxQdWJrZXk6IHRhcEludGVybmFsS2V5LFxuICAgICAgICBzY3JpcHRUcmVlLFxuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiB0d2Vha0ludGVybmFsUHViS2V5KGlucHV0SW5kZXgsIGlucHV0KSB7XG4gICAgY29uc3QgdGFwSW50ZXJuYWxLZXkgPSBpbnB1dC50YXBJbnRlcm5hbEtleTtcbiAgICBjb25zdCBvdXRwdXRLZXkgPSB0YXBJbnRlcm5hbEtleSAmJiAoMCwgYmlwMzQxXzEudHdlYWtLZXkpKHRhcEludGVybmFsS2V5LCBpbnB1dC50YXBNZXJrbGVSb290KTtcbiAgICBpZiAoIW91dHB1dEtleSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdHdlYWsgdGFwIGludGVybmFsIGtleSBmb3IgaW5wdXQgIyR7aW5wdXRJbmRleH0uIFB1YmxpYyBrZXk6ICR7dGFwSW50ZXJuYWxLZXkgJiYgdGFwSW50ZXJuYWxLZXkudG9TdHJpbmcoJ2hleCcpfWApO1xuICAgIHJldHVybiBvdXRwdXRLZXkueDtcbn1cbmV4cG9ydHMudHdlYWtJbnRlcm5hbFB1YktleSA9IHR3ZWFrSW50ZXJuYWxQdWJLZXk7XG5mdW5jdGlvbiB0YXBUcmVlVG9MaXN0KHRyZWUpIHtcbiAgICBpZiAoISgwLCB0eXBlc18xLmlzVGFwdHJlZSkodHJlZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgdGFwdHJlZSB0byB0YXBsZWFmIGxpc3QuIEV4cGVjdGluZyBhIHRhcHJlZSBzdHJ1Y3R1cmUuJyk7XG4gICAgcmV0dXJuIF90YXBUcmVlVG9MaXN0KHRyZWUpO1xufVxuZXhwb3J0cy50YXBUcmVlVG9MaXN0ID0gdGFwVHJlZVRvTGlzdDtcbmZ1bmN0aW9uIHRhcFRyZWVGcm9tTGlzdChsZWF2ZXMgPSBbXSkge1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxICYmIGxlYXZlc1swXS5kZXB0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG91dHB1dDogbGVhdmVzWzBdLnNjcmlwdCxcbiAgICAgICAgICAgIHZlcnNpb246IGxlYXZlc1swXS5sZWFmVmVyc2lvbixcbiAgICAgICAgfTtcbiAgICByZXR1cm4gaW5zdGVydExlYXZlc0luVHJlZShsZWF2ZXMpO1xufVxuZXhwb3J0cy50YXBUcmVlRnJvbUxpc3QgPSB0YXBUcmVlRnJvbUxpc3Q7XG5mdW5jdGlvbiBjaGVja1RhcHJvb3RJbnB1dEZvclNpZ3MoaW5wdXQsIGFjdGlvbikge1xuICAgIGNvbnN0IHNpZ3MgPSBleHRyYWN0VGFwcm9vdFNpZ3MoaW5wdXQpO1xuICAgIHJldHVybiBzaWdzLnNvbWUoc2lnID0+ICgwLCBwc2J0dXRpbHNfMi5zaWduYXR1cmVCbG9ja3NBY3Rpb24pKHNpZywgZGVjb2RlU2Nobm9yclNpZ25hdHVyZSwgYWN0aW9uKSk7XG59XG5leHBvcnRzLmNoZWNrVGFwcm9vdElucHV0Rm9yU2lncyA9IGNoZWNrVGFwcm9vdElucHV0Rm9yU2lncztcbmZ1bmN0aW9uIGRlY29kZVNjaG5vcnJTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUuc2xpY2UoMCwgNjQpLFxuICAgICAgICBoYXNoVHlwZTogc2lnbmF0dXJlLnNsaWNlKDY0KVswXSB8fCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdFRhcHJvb3RTaWdzKGlucHV0KSB7XG4gICAgY29uc3Qgc2lncyA9IFtdO1xuICAgIGlmIChpbnB1dC50YXBLZXlTaWcpXG4gICAgICAgIHNpZ3MucHVzaChpbnB1dC50YXBLZXlTaWcpO1xuICAgIGlmIChpbnB1dC50YXBTY3JpcHRTaWcpXG4gICAgICAgIHNpZ3MucHVzaCguLi5pbnB1dC50YXBTY3JpcHRTaWcubWFwKHMgPT4gcy5zaWduYXR1cmUpKTtcbiAgICBpZiAoIXNpZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsVGFwS2V5U2lnID0gZ2V0VGFwS2V5U2lnRnJvbVdpdGhuZXNzKGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcyk7XG4gICAgICAgIGlmIChmaW5hbFRhcEtleVNpZylcbiAgICAgICAgICAgIHNpZ3MucHVzaChmaW5hbFRhcEtleVNpZyk7XG4gICAgfVxuICAgIHJldHVybiBzaWdzO1xufVxuZnVuY3Rpb24gZ2V0VGFwS2V5U2lnRnJvbVdpdGhuZXNzKGZpbmFsU2NyaXB0V2l0bmVzcykge1xuICAgIGlmICghZmluYWxTY3JpcHRXaXRuZXNzKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qgd2l0bmVzcyA9IGZpbmFsU2NyaXB0V2l0bmVzcy5zbGljZSgyKTtcbiAgICBpZiAod2l0bmVzcy5sZW5ndGggPT09IDY0IHx8IHdpdG5lc3MubGVuZ3RoID09PSA2NSlcbiAgICAgICAgcmV0dXJuIHdpdG5lc3M7XG59XG5mdW5jdGlvbiBfdGFwVHJlZVRvTGlzdCh0cmVlLCBsZWF2ZXMgPSBbXSwgZGVwdGggPSAwKSB7XG4gICAgaWYgKGRlcHRoID4gYmlwMzQxXzEuTUFYX1RBUFRSRUVfREVQVEgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWF4IHRhcHRyZWUgZGVwdGggZXhjZWVkZWQuJyk7XG4gICAgaWYgKCF0cmVlKVxuICAgICAgICByZXR1cm4gW107XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzVGFwbGVhZikodHJlZSkpIHtcbiAgICAgICAgbGVhdmVzLnB1c2goe1xuICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICBsZWFmVmVyc2lvbjogdHJlZS52ZXJzaW9uIHx8IGJpcDM0MV8xLkxFQUZfVkVSU0lPTl9UQVBTQ1JJUFQsXG4gICAgICAgICAgICBzY3JpcHQ6IHRyZWUub3V0cHV0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxlYXZlcztcbiAgICB9XG4gICAgaWYgKHRyZWVbMF0pXG4gICAgICAgIF90YXBUcmVlVG9MaXN0KHRyZWVbMF0sIGxlYXZlcywgZGVwdGggKyAxKTtcbiAgICBpZiAodHJlZVsxXSlcbiAgICAgICAgX3RhcFRyZWVUb0xpc3QodHJlZVsxXSwgbGVhdmVzLCBkZXB0aCArIDEpO1xuICAgIHJldHVybiBsZWF2ZXM7XG59XG5mdW5jdGlvbiBpbnN0ZXJ0TGVhdmVzSW5UcmVlKGxlYXZlcykge1xuICAgIGxldCB0cmVlO1xuICAgIGZvciAoY29uc3QgbGVhZiBvZiBsZWF2ZXMpIHtcbiAgICAgICAgdHJlZSA9IGluc3RlcnRMZWFmSW5UcmVlKGxlYWYsIHRyZWUpO1xuICAgICAgICBpZiAoIXRyZWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJvb20gbGVmdCB0byBpbnNlcnQgdGFwbGVhZiBpbiB0cmVlYCk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlO1xufVxuZnVuY3Rpb24gaW5zdGVydExlYWZJblRyZWUobGVhZiwgdHJlZSwgZGVwdGggPSAwKSB7XG4gICAgaWYgKGRlcHRoID4gYmlwMzQxXzEuTUFYX1RBUFRSRUVfREVQVEgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWF4IHRhcHRyZWUgZGVwdGggZXhjZWVkZWQuJyk7XG4gICAgaWYgKGxlYWYuZGVwdGggPT09IGRlcHRoKSB7XG4gICAgICAgIGlmICghdHJlZSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiBsZWFmLnNjcmlwdCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBsZWFmLmxlYWZWZXJzaW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNUYXBsZWFmKSh0cmVlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxlZnRTaWRlID0gaW5zdGVydExlYWZJblRyZWUobGVhZiwgdHJlZSAmJiB0cmVlWzBdLCBkZXB0aCArIDEpO1xuICAgIGlmIChsZWZ0U2lkZSlcbiAgICAgICAgcmV0dXJuIFtsZWZ0U2lkZSwgdHJlZSAmJiB0cmVlWzFdXTtcbiAgICBjb25zdCByaWdodFNpZGUgPSBpbnN0ZXJ0TGVhZkluVHJlZShsZWFmLCB0cmVlICYmIHRyZWVbMV0sIGRlcHRoICsgMSk7XG4gICAgaWYgKHJpZ2h0U2lkZSlcbiAgICAgICAgcmV0dXJuIFt0cmVlICYmIHRyZWVbMF0sIHJpZ2h0U2lkZV07XG59XG5mdW5jdGlvbiBjaGVja01peGVkVGFwcm9vdEFuZE5vblRhcHJvb3RJbnB1dEZpZWxkcyhpbnB1dERhdGEsIG5ld0lucHV0RGF0YSwgYWN0aW9uKSB7XG4gICAgY29uc3QgaXNCYWRUYXByb290VXBkYXRlID0gaXNUYXByb290SW5wdXQoaW5wdXREYXRhKSAmJiBoYXNOb25UYXByb290RmllbGRzKG5ld0lucHV0RGF0YSk7XG4gICAgY29uc3QgaXNCYWROb25UYXByb290VXBkYXRlID0gaGFzTm9uVGFwcm9vdEZpZWxkcyhpbnB1dERhdGEpICYmIGlzVGFwcm9vdElucHV0KG5ld0lucHV0RGF0YSk7XG4gICAgY29uc3QgaGFzTWl4ZWRGaWVsZHMgPSBpbnB1dERhdGEgPT09IG5ld0lucHV0RGF0YSAmJlxuICAgICAgICBpc1RhcHJvb3RJbnB1dChuZXdJbnB1dERhdGEpICYmXG4gICAgICAgIGhhc05vblRhcHJvb3RGaWVsZHMobmV3SW5wdXREYXRhKTtcbiAgICBpZiAoaXNCYWRUYXByb290VXBkYXRlIHx8IGlzQmFkTm9uVGFwcm9vdFVwZGF0ZSB8fCBoYXNNaXhlZEZpZWxkcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgUHNidC4ke2FjdGlvbn0uIGAgK1xuICAgICAgICAgICAgYENhbm5vdCB1c2UgYm90aCB0YXByb290IGFuZCBub24tdGFwcm9vdCBmaWVsZHMuYCk7XG59XG5mdW5jdGlvbiBjaGVja01peGVkVGFwcm9vdEFuZE5vblRhcHJvb3RPdXRwdXRGaWVsZHMoaW5wdXREYXRhLCBuZXdJbnB1dERhdGEsIGFjdGlvbikge1xuICAgIGNvbnN0IGlzQmFkVGFwcm9vdFVwZGF0ZSA9IGlzVGFwcm9vdE91dHB1dChpbnB1dERhdGEpICYmIGhhc05vblRhcHJvb3RGaWVsZHMobmV3SW5wdXREYXRhKTtcbiAgICBjb25zdCBpc0JhZE5vblRhcHJvb3RVcGRhdGUgPSBoYXNOb25UYXByb290RmllbGRzKGlucHV0RGF0YSkgJiYgaXNUYXByb290T3V0cHV0KG5ld0lucHV0RGF0YSk7XG4gICAgY29uc3QgaGFzTWl4ZWRGaWVsZHMgPSBpbnB1dERhdGEgPT09IG5ld0lucHV0RGF0YSAmJlxuICAgICAgICBpc1RhcHJvb3RPdXRwdXQobmV3SW5wdXREYXRhKSAmJlxuICAgICAgICBoYXNOb25UYXByb290RmllbGRzKG5ld0lucHV0RGF0YSk7XG4gICAgaWYgKGlzQmFkVGFwcm9vdFVwZGF0ZSB8fCBpc0JhZE5vblRhcHJvb3RVcGRhdGUgfHwgaGFzTWl4ZWRGaWVsZHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcmd1bWVudHMgZm9yIFBzYnQuJHthY3Rpb259LiBgICtcbiAgICAgICAgICAgIGBDYW5ub3QgdXNlIGJvdGggdGFwcm9vdCBhbmQgbm9uLXRhcHJvb3QgZmllbGRzLmApO1xufVxuZnVuY3Rpb24gY2hlY2tJZlRhcExlYWZJblRyZWUoaW5wdXREYXRhLCBuZXdJbnB1dERhdGEsIGFjdGlvbikge1xuICAgIGlmIChuZXdJbnB1dERhdGEudGFwTWVya2xlUm9vdCkge1xuICAgICAgICBjb25zdCBuZXdMZWFmc0luVHJlZSA9IChuZXdJbnB1dERhdGEudGFwTGVhZlNjcmlwdCB8fCBbXSkuZXZlcnkobCA9PiBpc1RhcExlYWZJblRyZWUobCwgbmV3SW5wdXREYXRhLnRhcE1lcmtsZVJvb3QpKTtcbiAgICAgICAgY29uc3Qgb2xkTGVhZnNJblRyZWUgPSAoaW5wdXREYXRhLnRhcExlYWZTY3JpcHQgfHwgW10pLmV2ZXJ5KGwgPT4gaXNUYXBMZWFmSW5UcmVlKGwsIG5ld0lucHV0RGF0YS50YXBNZXJrbGVSb290KSk7XG4gICAgICAgIGlmICghbmV3TGVhZnNJblRyZWUgfHwgIW9sZExlYWZzSW5UcmVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgUHNidC4ke2FjdGlvbn0uIFRhcGxlYWYgbm90IHBhcnQgb2YgdGFwdHJlZS5gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXREYXRhLnRhcE1lcmtsZVJvb3QpIHtcbiAgICAgICAgY29uc3QgbmV3TGVhZnNJblRyZWUgPSAobmV3SW5wdXREYXRhLnRhcExlYWZTY3JpcHQgfHwgW10pLmV2ZXJ5KGwgPT4gaXNUYXBMZWFmSW5UcmVlKGwsIGlucHV0RGF0YS50YXBNZXJrbGVSb290KSk7XG4gICAgICAgIGlmICghbmV3TGVhZnNJblRyZWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LiR7YWN0aW9ufS4gVGFwbGVhZiBub3QgcGFydCBvZiB0YXB0cmVlLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVGFwTGVhZkluVHJlZSh0YXBMZWFmLCBtZXJrbGVSb290KSB7XG4gICAgaWYgKCFtZXJrbGVSb290KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgICAgICBvdXRwdXQ6IHRhcExlYWYuc2NyaXB0LFxuICAgICAgICB2ZXJzaW9uOiB0YXBMZWFmLmxlYWZWZXJzaW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IHJvb3RIYXNoID0gKDAsIGJpcDM0MV8xLnJvb3RIYXNoRnJvbVBhdGgpKHRhcExlYWYuY29udHJvbEJsb2NrLCBsZWFmSGFzaCk7XG4gICAgcmV0dXJuIHJvb3RIYXNoLmVxdWFscyhtZXJrbGVSb290KTtcbn1cbmZ1bmN0aW9uIHNvcnRTaWduYXR1cmVzKGlucHV0LCB0YXBMZWFmKSB7XG4gICAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICAgICAgb3V0cHV0OiB0YXBMZWFmLnNjcmlwdCxcbiAgICAgICAgdmVyc2lvbjogdGFwTGVhZi5sZWFmVmVyc2lvbixcbiAgICB9KTtcbiAgICByZXR1cm4gKGlucHV0LnRhcFNjcmlwdFNpZyB8fCBbXSlcbiAgICAgICAgLmZpbHRlcih0c3MgPT4gdHNzLmxlYWZIYXNoLmVxdWFscyhsZWFmSGFzaCkpXG4gICAgICAgIC5tYXAodHNzID0+IGFkZFB1YmtleVBvc2l0aW9uSW5TY3JpcHQodGFwTGVhZi5zY3JpcHQsIHRzcykpXG4gICAgICAgIC5zb3J0KCh0MSwgdDIpID0+IHQyLnBvc2l0aW9uSW5TY3JpcHQgLSB0MS5wb3NpdGlvbkluU2NyaXB0KVxuICAgICAgICAubWFwKHQgPT4gdC5zaWduYXR1cmUpO1xufVxuZnVuY3Rpb24gYWRkUHVia2V5UG9zaXRpb25JblNjcmlwdChzY3JpcHQsIHRzcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgcG9zaXRpb25JblNjcmlwdDogKDAsIHBzYnR1dGlsc18xLnB1YmtleVBvc2l0aW9uSW5TY3JpcHQpKHRzcy5wdWJrZXksIHNjcmlwdCksXG4gICAgfSwgdHNzKTtcbn1cbmZ1bmN0aW9uIGZpbmRUYXBMZWFmVG9GaW5hbGl6ZShpbnB1dCwgaW5wdXRJbmRleCwgbGVhZkhhc2hUb0ZpbmFsaXplKSB7XG4gICAgaWYgKCFpbnB1dC50YXBTY3JpcHRTaWcgfHwgIWlucHV0LnRhcFNjcmlwdFNpZy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBmaW5hbGl6ZSB0YXByb290IGlucHV0ICMke2lucHV0SW5kZXh9LiBObyB0YXBsZWFmIHNjcmlwdCBzaWduYXR1cmUgcHJvdmlkZWQuYCk7XG4gICAgY29uc3QgdGFwTGVhZiA9IChpbnB1dC50YXBMZWFmU2NyaXB0IHx8IFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5jb250cm9sQmxvY2subGVuZ3RoIC0gYi5jb250cm9sQmxvY2subGVuZ3RoKVxuICAgICAgICAuZmluZChsZWFmID0+IGNhbkZpbmFsaXplTGVhZihsZWFmLCBpbnB1dC50YXBTY3JpcHRTaWcsIGxlYWZIYXNoVG9GaW5hbGl6ZSkpO1xuICAgIGlmICghdGFwTGVhZilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGZpbmFsaXplIHRhcHJvb3QgaW5wdXQgIyR7aW5wdXRJbmRleH0uIFNpZ25hdHVyZSBmb3IgdGFwbGVhZiBzY3JpcHQgbm90IGZvdW5kLmApO1xuICAgIHJldHVybiB0YXBMZWFmO1xufVxuZnVuY3Rpb24gY2FuRmluYWxpemVMZWFmKGxlYWYsIHRhcFNjcmlwdFNpZywgaGFzaCkge1xuICAgIGNvbnN0IGxlYWZIYXNoID0gKDAsIGJpcDM0MV8xLnRhcGxlYWZIYXNoKSh7XG4gICAgICAgIG91dHB1dDogbGVhZi5zY3JpcHQsXG4gICAgICAgIHZlcnNpb246IGxlYWYubGVhZlZlcnNpb24sXG4gICAgfSk7XG4gICAgY29uc3Qgd2hpdGVMaXN0ZWRIYXNoID0gIWhhc2ggfHwgaGFzaC5lcXVhbHMobGVhZkhhc2gpO1xuICAgIHJldHVybiAod2hpdGVMaXN0ZWRIYXNoICYmXG4gICAgICAgIHRhcFNjcmlwdFNpZy5maW5kKHRzcyA9PiB0c3MubGVhZkhhc2guZXF1YWxzKGxlYWZIYXNoKSkgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBoYXNOb25UYXByb290RmllbGRzKGlvKSB7XG4gICAgcmV0dXJuIChpbyAmJlxuICAgICAgICAhIShpby5yZWRlZW1TY3JpcHQgfHxcbiAgICAgICAgICAgIGlvLndpdG5lc3NTY3JpcHQgfHxcbiAgICAgICAgICAgIChpby5iaXAzMkRlcml2YXRpb24gJiYgaW8uYmlwMzJEZXJpdmF0aW9uLmxlbmd0aCkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpcDM3MS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/bip371.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/psbtutils.js':
    /*!*********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/psbtutils.js ***!
  \*********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.signatureBlocksAction = exports.checkInputForSig = exports.pubkeyInScript = exports.pubkeyPositionInScript = exports.witnessStackToScriptWitness = exports.isP2TR = exports.isP2SHScript = exports.isP2WSHScript = exports.isP2WPKH = exports.isP2PKH = exports.isP2PK = exports.isP2MS = void 0;\nconst varuint = __importStar(__webpack_require__(/*! ../bip174/converter/varint */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip174/converter/varint.js"));\nconst bscript = __importStar(__webpack_require__(/*! ../script */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js"));\nconst transaction_1 = __webpack_require__(/*! ../transaction */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/transaction.js");\nconst crypto_1 = __webpack_require__(/*! ../crypto */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js");\nconst payments = __importStar(__webpack_require__(/*! ../payments */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js"));\nfunction isPaymentFactory(payment) {\n    return (script) => {\n        try {\n            payment({ output: script });\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    };\n}\nexports.isP2MS = isPaymentFactory(payments.p2ms);\nexports.isP2PK = isPaymentFactory(payments.p2pk);\nexports.isP2PKH = isPaymentFactory(payments.p2pkh);\nexports.isP2WPKH = isPaymentFactory(payments.p2wpkh);\nexports.isP2WSHScript = isPaymentFactory(payments.p2wsh);\nexports.isP2SHScript = isPaymentFactory(payments.p2sh);\nexports.isP2TR = isPaymentFactory(payments.p2tr);\nfunction witnessStackToScriptWitness(witness) {\n    let buffer = Buffer.allocUnsafe(0);\n    function writeSlice(slice) {\n        buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n    }\n    function writeVarInt(i) {\n        const currentLen = buffer.length;\n        const varintLen = varuint.encodingLength(i);\n        buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n        varuint.encode(i, buffer, currentLen);\n    }\n    function writeVarSlice(slice) {\n        writeVarInt(slice.length);\n        writeSlice(slice);\n    }\n    function writeVector(vector) {\n        writeVarInt(vector.length);\n        vector.forEach(writeVarSlice);\n    }\n    writeVector(witness);\n    return buffer;\n}\nexports.witnessStackToScriptWitness = witnessStackToScriptWitness;\nfunction pubkeyPositionInScript(pubkey, script) {\n    const pubkeyHash = (0, crypto_1.hash160)(pubkey);\n    const pubkeyXOnly = pubkey.slice(1, 33);\n    const decompiled = bscript.decompile(script);\n    if (decompiled === null)\n        throw new Error(\'Unknown script error\');\n    return decompiled.findIndex(element => {\n        if (typeof element === \'number\')\n            return false;\n        return (element.equals(pubkey) ||\n            element.equals(pubkeyHash) ||\n            element.equals(pubkeyXOnly));\n    });\n}\nexports.pubkeyPositionInScript = pubkeyPositionInScript;\nfunction pubkeyInScript(pubkey, script) {\n    return pubkeyPositionInScript(pubkey, script) !== -1;\n}\nexports.pubkeyInScript = pubkeyInScript;\nfunction checkInputForSig(input, action) {\n    const pSigs = extractPartialSigs(input);\n    return pSigs.some(pSig => signatureBlocksAction(pSig, bscript.signature.decode, action));\n}\nexports.checkInputForSig = checkInputForSig;\nfunction signatureBlocksAction(signature, signatureDecodeFn, action) {\n    const { hashType } = signatureDecodeFn(signature);\n    const whitelist = [];\n    const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n    if (isAnyoneCanPay)\n        whitelist.push(\'addInput\');\n    const hashMod = hashType & 0x1f;\n    switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n            break;\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n            whitelist.push(\'addOutput\');\n            whitelist.push(\'setInputSequence\');\n            break;\n    }\n    if (whitelist.indexOf(action) === -1) {\n        return true;\n    }\n    return false;\n}\nexports.signatureBlocksAction = signatureBlocksAction;\nfunction extractPartialSigs(input) {\n    let pSigs = [];\n    if ((input.partialSig || []).length === 0) {\n        if (!input.finalScriptSig && !input.finalScriptWitness)\n            return [];\n        pSigs = getPsigsFromInputFinalScripts(input);\n    }\n    else {\n        pSigs = input.partialSig;\n    }\n    return pSigs.map(p => p.signature);\n}\nfunction getPsigsFromInputFinalScripts(input) {\n    const scriptItems = !input.finalScriptSig\n        ? []\n        : bscript.decompile(input.finalScriptSig) || [];\n    const witnessItems = !input.finalScriptWitness\n        ? []\n        : bscript.decompile(input.finalScriptWitness) || [];\n    return scriptItems\n        .concat(witnessItems)\n        .filter(item => {\n        return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n        .map(sig => ({ signature: sig }));\n}\n//# sourceMappingURL=psbtutils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wc2J0L3BzYnR1dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsOEJBQThCLEdBQUcsbUNBQW1DLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUMvUiw2QkFBNkIsbUJBQU8sQ0FBQyw0SEFBNEI7QUFDakUsNkJBQTZCLG1CQUFPLENBQUMsMEZBQVc7QUFDaEQsc0JBQXNCLG1CQUFPLENBQUMsb0dBQWdCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLDBGQUFXO0FBQ3BDLDhCQUE4QixtQkFBTyxDQUFDLG9HQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvcHNidC9wc2J0dXRpbHMuanM/NDIwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaWduYXR1cmVCbG9ja3NBY3Rpb24gPSBleHBvcnRzLmNoZWNrSW5wdXRGb3JTaWcgPSBleHBvcnRzLnB1YmtleUluU2NyaXB0ID0gZXhwb3J0cy5wdWJrZXlQb3NpdGlvbkluU2NyaXB0ID0gZXhwb3J0cy53aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MgPSBleHBvcnRzLmlzUDJUUiA9IGV4cG9ydHMuaXNQMlNIU2NyaXB0ID0gZXhwb3J0cy5pc1AyV1NIU2NyaXB0ID0gZXhwb3J0cy5pc1AyV1BLSCA9IGV4cG9ydHMuaXNQMlBLSCA9IGV4cG9ydHMuaXNQMlBLID0gZXhwb3J0cy5pc1AyTVMgPSB2b2lkIDA7XG5jb25zdCB2YXJ1aW50ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9iaXAxNzQvY29udmVydGVyL3ZhcmludFwiKSk7XG5jb25zdCBic2NyaXB0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9zY3JpcHRcIikpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0b1wiKTtcbmNvbnN0IHBheW1lbnRzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9wYXltZW50c1wiKSk7XG5mdW5jdGlvbiBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnQpIHtcbiAgICByZXR1cm4gKHNjcmlwdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGF5bWVudCh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuaXNQMk1TID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMm1zKTtcbmV4cG9ydHMuaXNQMlBLID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMnBrKTtcbmV4cG9ydHMuaXNQMlBLSCA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJwa2gpO1xuZXhwb3J0cy5pc1AyV1BLSCA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJ3cGtoKTtcbmV4cG9ydHMuaXNQMldTSFNjcmlwdCA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJ3c2gpO1xuZXhwb3J0cy5pc1AyU0hTY3JpcHQgPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAyc2gpO1xuZXhwb3J0cy5pc1AyVFIgPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAydHIpO1xuZnVuY3Rpb24gd2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzKHdpdG5lc3MpIHtcbiAgICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIGZ1bmN0aW9uIHdyaXRlU2xpY2Uoc2xpY2UpIHtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBCdWZmZXIuZnJvbShzbGljZSldKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVWYXJJbnQoaSkge1xuICAgICAgICBjb25zdCBjdXJyZW50TGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdmFyaW50TGVuID0gdmFydWludC5lbmNvZGluZ0xlbmd0aChpKTtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBCdWZmZXIuYWxsb2NVbnNhZmUodmFyaW50TGVuKV0pO1xuICAgICAgICB2YXJ1aW50LmVuY29kZShpLCBidWZmZXIsIGN1cnJlbnRMZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVZhclNsaWNlKHNsaWNlKSB7XG4gICAgICAgIHdyaXRlVmFySW50KHNsaWNlLmxlbmd0aCk7XG4gICAgICAgIHdyaXRlU2xpY2Uoc2xpY2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVZlY3Rvcih2ZWN0b3IpIHtcbiAgICAgICAgd3JpdGVWYXJJbnQodmVjdG9yLmxlbmd0aCk7XG4gICAgICAgIHZlY3Rvci5mb3JFYWNoKHdyaXRlVmFyU2xpY2UpO1xuICAgIH1cbiAgICB3cml0ZVZlY3Rvcih3aXRuZXNzKTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy53aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MgPSB3aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3M7XG5mdW5jdGlvbiBwdWJrZXlQb3NpdGlvbkluU2NyaXB0KHB1YmtleSwgc2NyaXB0KSB7XG4gICAgY29uc3QgcHVia2V5SGFzaCA9ICgwLCBjcnlwdG9fMS5oYXNoMTYwKShwdWJrZXkpO1xuICAgIGNvbnN0IHB1YmtleVhPbmx5ID0gcHVia2V5LnNsaWNlKDEsIDMzKTtcbiAgICBjb25zdCBkZWNvbXBpbGVkID0gYnNjcmlwdC5kZWNvbXBpbGUoc2NyaXB0KTtcbiAgICBpZiAoZGVjb21waWxlZCA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHNjcmlwdCBlcnJvcicpO1xuICAgIHJldHVybiBkZWNvbXBpbGVkLmZpbmRJbmRleChlbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIChlbGVtZW50LmVxdWFscyhwdWJrZXkpIHx8XG4gICAgICAgICAgICBlbGVtZW50LmVxdWFscyhwdWJrZXlIYXNoKSB8fFxuICAgICAgICAgICAgZWxlbWVudC5lcXVhbHMocHVia2V5WE9ubHkpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucHVia2V5UG9zaXRpb25JblNjcmlwdCA9IHB1YmtleVBvc2l0aW9uSW5TY3JpcHQ7XG5mdW5jdGlvbiBwdWJrZXlJblNjcmlwdChwdWJrZXksIHNjcmlwdCkge1xuICAgIHJldHVybiBwdWJrZXlQb3NpdGlvbkluU2NyaXB0KHB1YmtleSwgc2NyaXB0KSAhPT0gLTE7XG59XG5leHBvcnRzLnB1YmtleUluU2NyaXB0ID0gcHVia2V5SW5TY3JpcHQ7XG5mdW5jdGlvbiBjaGVja0lucHV0Rm9yU2lnKGlucHV0LCBhY3Rpb24pIHtcbiAgICBjb25zdCBwU2lncyA9IGV4dHJhY3RQYXJ0aWFsU2lncyhpbnB1dCk7XG4gICAgcmV0dXJuIHBTaWdzLnNvbWUocFNpZyA9PiBzaWduYXR1cmVCbG9ja3NBY3Rpb24ocFNpZywgYnNjcmlwdC5zaWduYXR1cmUuZGVjb2RlLCBhY3Rpb24pKTtcbn1cbmV4cG9ydHMuY2hlY2tJbnB1dEZvclNpZyA9IGNoZWNrSW5wdXRGb3JTaWc7XG5mdW5jdGlvbiBzaWduYXR1cmVCbG9ja3NBY3Rpb24oc2lnbmF0dXJlLCBzaWduYXR1cmVEZWNvZGVGbiwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBoYXNoVHlwZSB9ID0gc2lnbmF0dXJlRGVjb2RlRm4oc2lnbmF0dXJlKTtcbiAgICBjb25zdCB3aGl0ZWxpc3QgPSBbXTtcbiAgICBjb25zdCBpc0FueW9uZUNhblBheSA9IGhhc2hUeXBlICYgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWTtcbiAgICBpZiAoaXNBbnlvbmVDYW5QYXkpXG4gICAgICAgIHdoaXRlbGlzdC5wdXNoKCdhZGRJbnB1dCcpO1xuICAgIGNvbnN0IGhhc2hNb2QgPSBoYXNoVHlwZSAmIDB4MWY7XG4gICAgc3dpdGNoIChoYXNoTW9kKSB7XG4gICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEU6XG4gICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX05PTkU6XG4gICAgICAgICAgICB3aGl0ZWxpc3QucHVzaCgnYWRkT3V0cHV0Jyk7XG4gICAgICAgICAgICB3aGl0ZWxpc3QucHVzaCgnc2V0SW5wdXRTZXF1ZW5jZScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh3aGl0ZWxpc3QuaW5kZXhPZihhY3Rpb24pID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zaWduYXR1cmVCbG9ja3NBY3Rpb24gPSBzaWduYXR1cmVCbG9ja3NBY3Rpb247XG5mdW5jdGlvbiBleHRyYWN0UGFydGlhbFNpZ3MoaW5wdXQpIHtcbiAgICBsZXQgcFNpZ3MgPSBbXTtcbiAgICBpZiAoKGlucHV0LnBhcnRpYWxTaWcgfHwgW10pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoIWlucHV0LmZpbmFsU2NyaXB0U2lnICYmICFpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHBTaWdzID0gZ2V0UHNpZ3NGcm9tSW5wdXRGaW5hbFNjcmlwdHMoaW5wdXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcFNpZ3MgPSBpbnB1dC5wYXJ0aWFsU2lnO1xuICAgIH1cbiAgICByZXR1cm4gcFNpZ3MubWFwKHAgPT4gcC5zaWduYXR1cmUpO1xufVxuZnVuY3Rpb24gZ2V0UHNpZ3NGcm9tSW5wdXRGaW5hbFNjcmlwdHMoaW5wdXQpIHtcbiAgICBjb25zdCBzY3JpcHRJdGVtcyA9ICFpbnB1dC5maW5hbFNjcmlwdFNpZ1xuICAgICAgICA/IFtdXG4gICAgICAgIDogYnNjcmlwdC5kZWNvbXBpbGUoaW5wdXQuZmluYWxTY3JpcHRTaWcpIHx8IFtdO1xuICAgIGNvbnN0IHdpdG5lc3NJdGVtcyA9ICFpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3NcbiAgICAgICAgPyBbXVxuICAgICAgICA6IGJzY3JpcHQuZGVjb21waWxlKGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcykgfHwgW107XG4gICAgcmV0dXJuIHNjcmlwdEl0ZW1zXG4gICAgICAgIC5jb25jYXQod2l0bmVzc0l0ZW1zKVxuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGl0ZW0pICYmIGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoaXRlbSk7XG4gICAgfSlcbiAgICAgICAgLm1hcChzaWcgPT4gKHsgc2lnbmF0dXJlOiBzaWcgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHNidHV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/psbtutils.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/push_data.js':
    /*!****************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/push_data.js ***!
  \****************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.decode = exports.encode = exports.encodingLength = void 0;\nconst ops_1 = __webpack_require__(/*! ./ops */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/ops.js");\nfunction encodingLength(i) {\n    return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;\n}\nexports.encodingLength = encodingLength;\nfunction encode(buffer, num, offset) {\n    const size = encodingLength(num);\n    if (size === 1) {\n        buffer.writeUInt8(num, offset);\n    }\n    else if (size === 2) {\n        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);\n        buffer.writeUInt8(num, offset + 1);\n    }\n    else if (size === 3) {\n        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);\n        buffer.writeUInt16LE(num, offset + 1);\n    }\n    else {\n        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);\n        buffer.writeUInt32LE(num, offset + 1);\n    }\n    return size;\n}\nexports.encode = encode;\nfunction decode(buffer, offset) {\n    const opcode = buffer.readUInt8(offset);\n    let num;\n    let size;\n    if (opcode < ops_1.OPS.OP_PUSHDATA1) {\n        num = opcode;\n        size = 1;\n    }\n    else if (opcode === ops_1.OPS.OP_PUSHDATA1) {\n        if (offset + 2 > buffer.length)\n            return null;\n        num = buffer.readUInt8(offset + 1);\n        size = 2;\n    }\n    else if (opcode === ops_1.OPS.OP_PUSHDATA2) {\n        if (offset + 3 > buffer.length)\n            return null;\n        num = buffer.readUInt16LE(offset + 1);\n        size = 3;\n    }\n    else {\n        if (offset + 5 > buffer.length)\n            return null;\n        if (opcode !== ops_1.OPS.OP_PUSHDATA4)\n            throw new Error(\'Unexpected opcode\');\n        num = buffer.readUInt32LE(offset + 1);\n        size = 5;\n    }\n    return {\n        opcode,\n        number: num,\n        size,\n    };\n}\nexports.decode = decode;\n//# sourceMappingURL=push_data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9wdXNoX2RhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyxzQkFBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLG1GQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvcHVzaF9kYXRhLmpzPzk2MjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IHZvaWQgMDtcbmNvbnN0IG9wc18xID0gcmVxdWlyZShcIi4vb3BzXCIpO1xuZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGgoaSkge1xuICAgIHJldHVybiBpIDwgb3BzXzEuT1BTLk9QX1BVU0hEQVRBMSA/IDEgOiBpIDw9IDB4ZmYgPyAyIDogaSA8PSAweGZmZmYgPyAzIDogNTtcbn1cbmV4cG9ydHMuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aDtcbmZ1bmN0aW9uIGVuY29kZShidWZmZXIsIG51bSwgb2Zmc2V0KSB7XG4gICAgY29uc3Qgc2l6ZSA9IGVuY29kaW5nTGVuZ3RoKG51bSk7XG4gICAgaWYgKHNpemUgPT09IDEpIHtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgobnVtLCBvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaXplID09PSAyKSB7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG9wc18xLk9QUy5PUF9QVVNIREFUQTEsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG51bSwgb2Zmc2V0ICsgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpemUgPT09IDMpIHtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgob3BzXzEuT1BTLk9QX1BVU0hEQVRBMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDE2TEUobnVtLCBvZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG9wc18xLk9QUy5PUF9QVVNIREFUQTQsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKG51bSwgb2Zmc2V0ICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5mdW5jdGlvbiBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBvcGNvZGUgPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgbGV0IG51bTtcbiAgICBsZXQgc2l6ZTtcbiAgICBpZiAob3Bjb2RlIDwgb3BzXzEuT1BTLk9QX1BVU0hEQVRBMSkge1xuICAgICAgICBudW0gPSBvcGNvZGU7XG4gICAgICAgIHNpemUgPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGNvZGUgPT09IG9wc18xLk9QUy5PUF9QVVNIREFUQTEpIHtcbiAgICAgICAgaWYgKG9mZnNldCArIDIgPiBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIG51bSA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgIHNpemUgPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGNvZGUgPT09IG9wc18xLk9QUy5PUF9QVVNIREFUQTIpIHtcbiAgICAgICAgaWYgKG9mZnNldCArIDMgPiBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIG51bSA9IGJ1ZmZlci5yZWFkVUludDE2TEUob2Zmc2V0ICsgMSk7XG4gICAgICAgIHNpemUgPSAzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9mZnNldCArIDUgPiBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChvcGNvZGUgIT09IG9wc18xLk9QUy5PUF9QVVNIREFUQTQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgb3Bjb2RlJyk7XG4gICAgICAgIG51bSA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgMSk7XG4gICAgICAgIHNpemUgPSA1O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvcGNvZGUsXG4gICAgICAgIG51bWJlcjogbnVtLFxuICAgICAgICBzaXplLFxuICAgIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1c2hfZGF0YS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/push_data.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js':
    /*!*************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js ***!
  \*************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.signature = exports.number = exports.isCanonicalScriptSignature = exports.isDefinedHashType = exports.isCanonicalPubKey = exports.toStack = exports.fromASM = exports.toASM = exports.decompile = exports.compile = exports.isPushOnly = exports.OPS = void 0;\nconst bip66 = __importStar(__webpack_require__(/*! ./bip66 */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip66.js"));\nconst ops_1 = __webpack_require__(/*! ./ops */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/ops.js");\nObject.defineProperty(exports, "OPS", ({ enumerable: true, get: function () { return ops_1.OPS; } }));\nconst pushdata = __importStar(__webpack_require__(/*! ./push_data */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/push_data.js"));\nconst scriptNumber = __importStar(__webpack_require__(/*! ./script_number */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script_number.js"));\nconst scriptSignature = __importStar(__webpack_require__(/*! ./script_signature */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script_signature.js"));\nconst types = __importStar(__webpack_require__(/*! ./types */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js"));\nconst { typeforce } = types;\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED;\nfunction isOPInt(value) {\n    return (types.Number(value) &&\n        (value === ops_1.OPS.OP_0 ||\n            (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||\n            value === ops_1.OPS.OP_1NEGATE));\n}\nfunction isPushOnlyChunk(value) {\n    return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n    return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction asMinimalOP(buffer) {\n    if (buffer.length === 0)\n        return ops_1.OPS.OP_0;\n    if (buffer.length !== 1)\n        return;\n    if (buffer[0] >= 1 && buffer[0] <= 16)\n        return OP_INT_BASE + buffer[0];\n    if (buffer[0] === 0x81)\n        return ops_1.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n    return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n    return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n    return Buffer.isBuffer(buf);\n}\nfunction compile(chunks) {\n    if (chunksIsBuffer(chunks))\n        return chunks;\n    typeforce(types.Array, chunks);\n    const bufferSize = chunks.reduce((accum, chunk) => {\n        if (singleChunkIsBuffer(chunk)) {\n            if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n                return accum + 1;\n            }\n            return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n        }\n        return accum + 1;\n    }, 0.0);\n    const buffer = Buffer.allocUnsafe(bufferSize);\n    let offset = 0;\n    chunks.forEach(chunk => {\n        if (singleChunkIsBuffer(chunk)) {\n            const opcode = asMinimalOP(chunk);\n            if (opcode !== undefined) {\n                buffer.writeUInt8(opcode, offset);\n                offset += 1;\n                return;\n            }\n            offset += pushdata.encode(buffer, chunk.length, offset);\n            chunk.copy(buffer, offset);\n            offset += chunk.length;\n        }\n        else {\n            buffer.writeUInt8(chunk, offset);\n            offset += 1;\n        }\n    });\n    if (offset !== buffer.length)\n        throw new Error(\'Could not decode chunks\');\n    return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n    if (chunksIsArray(buffer))\n        return buffer;\n    typeforce(types.Buffer, buffer);\n    const chunks = [];\n    let i = 0;\n    while (i < buffer.length) {\n        const opcode = buffer[i];\n        if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {\n            const d = pushdata.decode(buffer, i);\n            if (d === null)\n                return null;\n            i += d.size;\n            if (i + d.number > buffer.length)\n                return null;\n            const data = buffer.slice(i, i + d.number);\n            i += d.number;\n            const op = asMinimalOP(data);\n            if (op !== undefined) {\n                chunks.push(op);\n            }\n            else {\n                chunks.push(data);\n            }\n        }\n        else {\n            chunks.push(opcode);\n            i += 1;\n        }\n    }\n    return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n    if (chunksIsBuffer(chunks)) {\n        chunks = decompile(chunks);\n    }\n    return chunks\n        .map(chunk => {\n        if (singleChunkIsBuffer(chunk)) {\n            const op = asMinimalOP(chunk);\n            if (op === undefined)\n                return chunk.toString(\'hex\');\n            chunk = op;\n        }\n        return ops_1.REVERSE_OPS[chunk];\n    })\n        .join(\' \');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n    typeforce(types.String, asm);\n    return compile(asm.split(\' \').map(chunkStr => {\n        if (ops_1.OPS[chunkStr] !== undefined)\n            return ops_1.OPS[chunkStr];\n        typeforce(types.Hex, chunkStr);\n        return Buffer.from(chunkStr, \'hex\');\n    }));\n}\nexports.fromASM = fromASM;\nfunction toStack(chunks) {\n    chunks = decompile(chunks);\n    typeforce(isPushOnly, chunks);\n    return chunks.map(op => {\n        if (singleChunkIsBuffer(op))\n            return op;\n        if (op === ops_1.OPS.OP_0)\n            return Buffer.allocUnsafe(0);\n        return scriptNumber.encode(op - OP_INT_BASE);\n    });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n    return types.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n    let hashTypeMod = hashType;\n    if (hashTypeMod & 0x80) {\n        hashTypeMod = hashTypeMod & ~0x80;\n    }\n    if (hashTypeMod & 0x40) {\n        hashTypeMod = hashTypeMod & ~0x40;\n    }\n    return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n    if (!Buffer.isBuffer(buffer))\n        return false;\n    if (!isDefinedHashType(buffer[buffer.length - 1]))\n        return false;\n    return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n//# sourceMappingURL=script.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9zY3JpcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGNBQWMsR0FBRyxrQ0FBa0MsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsV0FBVztBQUM1UCwyQkFBMkIsbUJBQU8sQ0FBQyx1RkFBUztBQUM1QyxjQUFjLG1CQUFPLENBQUMsbUZBQU87QUFDN0IsdUNBQXNDLEVBQUUscUNBQXFDLHFCQUFxQixFQUFDO0FBQ25HLDhCQUE4QixtQkFBTyxDQUFDLCtGQUFhO0FBQ25ELGtDQUFrQyxtQkFBTyxDQUFDLHVHQUFpQjtBQUMzRCxxQ0FBcUMsbUJBQU8sQ0FBQyw2R0FBb0I7QUFDakUsMkJBQTJCLG1CQUFPLENBQUMsdUZBQVM7QUFDNUMsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9zY3JpcHQuanM/MmY5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaWduYXR1cmUgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUgPSBleHBvcnRzLmlzRGVmaW5lZEhhc2hUeXBlID0gZXhwb3J0cy5pc0Nhbm9uaWNhbFB1YktleSA9IGV4cG9ydHMudG9TdGFjayA9IGV4cG9ydHMuZnJvbUFTTSA9IGV4cG9ydHMudG9BU00gPSBleHBvcnRzLmRlY29tcGlsZSA9IGV4cG9ydHMuY29tcGlsZSA9IGV4cG9ydHMuaXNQdXNoT25seSA9IGV4cG9ydHMuT1BTID0gdm9pZCAwO1xuY29uc3QgYmlwNjYgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmlwNjZcIikpO1xuY29uc3Qgb3BzXzEgPSByZXF1aXJlKFwiLi9vcHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPUFNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wc18xLk9QUzsgfSB9KTtcbmNvbnN0IHB1c2hkYXRhID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3B1c2hfZGF0YVwiKSk7XG5jb25zdCBzY3JpcHROdW1iZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2NyaXB0X251bWJlclwiKSk7XG5jb25zdCBzY3JpcHRTaWduYXR1cmUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2NyaXB0X3NpZ25hdHVyZVwiKSk7XG5jb25zdCB0eXBlcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSk7XG5jb25zdCB7IHR5cGVmb3JjZSB9ID0gdHlwZXM7XG5jb25zdCBPUF9JTlRfQkFTRSA9IG9wc18xLk9QUy5PUF9SRVNFUlZFRDtcbmZ1bmN0aW9uIGlzT1BJbnQodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVzLk51bWJlcih2YWx1ZSkgJiZcbiAgICAgICAgKHZhbHVlID09PSBvcHNfMS5PUFMuT1BfMCB8fFxuICAgICAgICAgICAgKHZhbHVlID49IG9wc18xLk9QUy5PUF8xICYmIHZhbHVlIDw9IG9wc18xLk9QUy5PUF8xNikgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSBvcHNfMS5PUFMuT1BfMU5FR0FURSkpO1xufVxuZnVuY3Rpb24gaXNQdXNoT25seUNodW5rKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVzLkJ1ZmZlcih2YWx1ZSkgfHwgaXNPUEludCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1B1c2hPbmx5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVzLkFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc1B1c2hPbmx5Q2h1bmspO1xufVxuZXhwb3J0cy5pc1B1c2hPbmx5ID0gaXNQdXNoT25seTtcbmZ1bmN0aW9uIGFzTWluaW1hbE9QKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gb3BzXzEuT1BTLk9QXzA7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoYnVmZmVyWzBdID49IDEgJiYgYnVmZmVyWzBdIDw9IDE2KVxuICAgICAgICByZXR1cm4gT1BfSU5UX0JBU0UgKyBidWZmZXJbMF07XG4gICAgaWYgKGJ1ZmZlclswXSA9PT0gMHg4MSlcbiAgICAgICAgcmV0dXJuIG9wc18xLk9QUy5PUF8xTkVHQVRFO1xufVxuZnVuY3Rpb24gY2h1bmtzSXNCdWZmZXIoYnVmKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihidWYpO1xufVxuZnVuY3Rpb24gY2h1bmtzSXNBcnJheShidWYpIHtcbiAgICByZXR1cm4gdHlwZXMuQXJyYXkoYnVmKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZUNodW5rSXNCdWZmZXIoYnVmKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihidWYpO1xufVxuZnVuY3Rpb24gY29tcGlsZShjaHVua3MpIHtcbiAgICBpZiAoY2h1bmtzSXNCdWZmZXIoY2h1bmtzKSlcbiAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICB0eXBlZm9yY2UodHlwZXMuQXJyYXksIGNodW5rcyk7XG4gICAgY29uc3QgYnVmZmVyU2l6ZSA9IGNodW5rcy5yZWR1Y2UoKGFjY3VtLCBjaHVuaykgPT4ge1xuICAgICAgICBpZiAoc2luZ2xlQ2h1bmtJc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IDEgJiYgYXNNaW5pbWFsT1AoY2h1bmspICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgcHVzaGRhdGEuZW5jb2RpbmdMZW5ndGgoY2h1bmsubGVuZ3RoKSArIGNodW5rLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW0gKyAxO1xuICAgIH0sIDAuMCk7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZmZlclNpemUpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNodW5rcy5mb3JFYWNoKGNodW5rID0+IHtcbiAgICAgICAgaWYgKHNpbmdsZUNodW5rSXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAgICAgICBjb25zdCBvcGNvZGUgPSBhc01pbmltYWxPUChjaHVuayk7XG4gICAgICAgICAgICBpZiAob3Bjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVSW50OChvcGNvZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IHB1c2hkYXRhLmVuY29kZShidWZmZXIsIGNodW5rLmxlbmd0aCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGNodW5rLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAob2Zmc2V0ICE9PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgY2h1bmtzJyk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG5mdW5jdGlvbiBkZWNvbXBpbGUoYnVmZmVyKSB7XG4gICAgaWYgKGNodW5rc0lzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB0eXBlZm9yY2UodHlwZXMuQnVmZmVyLCBidWZmZXIpO1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgb3Bjb2RlID0gYnVmZmVyW2ldO1xuICAgICAgICBpZiAob3Bjb2RlID4gb3BzXzEuT1BTLk9QXzAgJiYgb3Bjb2RlIDw9IG9wc18xLk9QUy5PUF9QVVNIREFUQTQpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBwdXNoZGF0YS5kZWNvZGUoYnVmZmVyLCBpKTtcbiAgICAgICAgICAgIGlmIChkID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaSArPSBkLnNpemU7XG4gICAgICAgICAgICBpZiAoaSArIGQubnVtYmVyID4gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuc2xpY2UoaSwgaSArIGQubnVtYmVyKTtcbiAgICAgICAgICAgIGkgKz0gZC5udW1iZXI7XG4gICAgICAgICAgICBjb25zdCBvcCA9IGFzTWluaW1hbE9QKGRhdGEpO1xuICAgICAgICAgICAgaWYgKG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKG9wY29kZSk7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcztcbn1cbmV4cG9ydHMuZGVjb21waWxlID0gZGVjb21waWxlO1xuZnVuY3Rpb24gdG9BU00oY2h1bmtzKSB7XG4gICAgaWYgKGNodW5rc0lzQnVmZmVyKGNodW5rcykpIHtcbiAgICAgICAgY2h1bmtzID0gZGVjb21waWxlKGNodW5rcyk7XG4gICAgfVxuICAgIHJldHVybiBjaHVua3NcbiAgICAgICAgLm1hcChjaHVuayA9PiB7XG4gICAgICAgIGlmIChzaW5nbGVDaHVua0lzQnVmZmVyKGNodW5rKSkge1xuICAgICAgICAgICAgY29uc3Qgb3AgPSBhc01pbmltYWxPUChjaHVuayk7XG4gICAgICAgICAgICBpZiAob3AgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgY2h1bmsgPSBvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BzXzEuUkVWRVJTRV9PUFNbY2h1bmtdO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcgJyk7XG59XG5leHBvcnRzLnRvQVNNID0gdG9BU007XG5mdW5jdGlvbiBmcm9tQVNNKGFzbSkge1xuICAgIHR5cGVmb3JjZSh0eXBlcy5TdHJpbmcsIGFzbSk7XG4gICAgcmV0dXJuIGNvbXBpbGUoYXNtLnNwbGl0KCcgJykubWFwKGNodW5rU3RyID0+IHtcbiAgICAgICAgaWYgKG9wc18xLk9QU1tjaHVua1N0cl0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBvcHNfMS5PUFNbY2h1bmtTdHJdO1xuICAgICAgICB0eXBlZm9yY2UodHlwZXMuSGV4LCBjaHVua1N0cik7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShjaHVua1N0ciwgJ2hleCcpO1xuICAgIH0pKTtcbn1cbmV4cG9ydHMuZnJvbUFTTSA9IGZyb21BU007XG5mdW5jdGlvbiB0b1N0YWNrKGNodW5rcykge1xuICAgIGNodW5rcyA9IGRlY29tcGlsZShjaHVua3MpO1xuICAgIHR5cGVmb3JjZShpc1B1c2hPbmx5LCBjaHVua3MpO1xuICAgIHJldHVybiBjaHVua3MubWFwKG9wID0+IHtcbiAgICAgICAgaWYgKHNpbmdsZUNodW5rSXNCdWZmZXIob3ApKVxuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICBpZiAob3AgPT09IG9wc18xLk9QUy5PUF8wKVxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgcmV0dXJuIHNjcmlwdE51bWJlci5lbmNvZGUob3AgLSBPUF9JTlRfQkFTRSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnRvU3RhY2sgPSB0b1N0YWNrO1xuZnVuY3Rpb24gaXNDYW5vbmljYWxQdWJLZXkoYnVmZmVyKSB7XG4gICAgcmV0dXJuIHR5cGVzLmlzUG9pbnQoYnVmZmVyKTtcbn1cbmV4cG9ydHMuaXNDYW5vbmljYWxQdWJLZXkgPSBpc0Nhbm9uaWNhbFB1YktleTtcbmZ1bmN0aW9uIGlzRGVmaW5lZEhhc2hUeXBlKGhhc2hUeXBlKSB7XG4gICAgbGV0IGhhc2hUeXBlTW9kID0gaGFzaFR5cGU7XG4gICAgaWYgKGhhc2hUeXBlTW9kICYgMHg4MCkge1xuICAgICAgICBoYXNoVHlwZU1vZCA9IGhhc2hUeXBlTW9kICYgfjB4ODA7XG4gICAgfVxuICAgIGlmIChoYXNoVHlwZU1vZCAmIDB4NDApIHtcbiAgICAgICAgaGFzaFR5cGVNb2QgPSBoYXNoVHlwZU1vZCAmIH4weDQwO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaFR5cGVNb2QgPiAweDAwICYmIGhhc2hUeXBlTW9kIDwgMHgwNDtcbn1cbmV4cG9ydHMuaXNEZWZpbmVkSGFzaFR5cGUgPSBpc0RlZmluZWRIYXNoVHlwZTtcbmZ1bmN0aW9uIGlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGJ1ZmZlcikge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVmaW5lZEhhc2hUeXBlKGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGJpcDY2LmNoZWNrKGJ1ZmZlci5zbGljZSgwLCAtMSkpO1xufVxuZXhwb3J0cy5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZSA9IGlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlO1xuZXhwb3J0cy5udW1iZXIgPSBzY3JpcHROdW1iZXI7XG5leHBvcnRzLnNpZ25hdHVyZSA9IHNjcmlwdFNpZ25hdHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcmlwdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script_number.js':
    /*!********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script_number.js ***!
  \********************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = void 0;\nfunction decode(buffer, maxLength, minimal) {\n    maxLength = maxLength || 4;\n    minimal = minimal === undefined ? true : minimal;\n    const length = buffer.length;\n    if (length === 0)\n        return 0;\n    if (length > maxLength)\n        throw new TypeError('Script number overflow');\n    if (minimal) {\n        if ((buffer[length - 1] & 0x7f) === 0) {\n            if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n                throw new Error('Non-minimally encoded script number');\n        }\n    }\n    if (length === 5) {\n        const a = buffer.readUInt32LE(0);\n        const b = buffer.readUInt8(4);\n        if (b & 0x80)\n            return -((b & ~0x80) * 0x100000000 + a);\n        return b * 0x100000000 + a;\n    }\n    let result = 0;\n    for (let i = 0; i < length; ++i) {\n        result |= buffer[i] << (8 * i);\n    }\n    if (buffer[length - 1] & 0x80)\n        return -(result & ~(0x80 << (8 * (length - 1))));\n    return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n    return i > 0x7fffffff\n        ? 5\n        : i > 0x7fffff\n            ? 4\n            : i > 0x7fff\n                ? 3\n                : i > 0x7f\n                    ? 2\n                    : i > 0x00\n                        ? 1\n                        : 0;\n}\nfunction encode(_number) {\n    let value = Math.abs(_number);\n    const size = scriptNumSize(value);\n    const buffer = Buffer.allocUnsafe(size);\n    const negative = _number < 0;\n    for (let i = 0; i < size; ++i) {\n        buffer.writeUInt8(value & 0xff, i);\n        value >>= 8;\n    }\n    if (buffer[size - 1] & 0x80) {\n        buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n    }\n    else if (negative) {\n        buffer[size - 1] |= 0x80;\n    }\n    return buffer;\n}\nexports.encode = encode;\n//# sourceMappingURL=script_number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9zY3JpcHRfbnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL3NjcmlwdF9udW1iZXIuanM/MjE0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBkZWNvZGUoYnVmZmVyLCBtYXhMZW5ndGgsIG1pbmltYWwpIHtcbiAgICBtYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgNDtcbiAgICBtaW5pbWFsID0gbWluaW1hbCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG1pbmltYWw7XG4gICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTY3JpcHQgbnVtYmVyIG92ZXJmbG93Jyk7XG4gICAgaWYgKG1pbmltYWwpIHtcbiAgICAgICAgaWYgKChidWZmZXJbbGVuZ3RoIC0gMV0gJiAweDdmKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAxIHx8IChidWZmZXJbbGVuZ3RoIC0gMl0gJiAweDgwKSA9PT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1taW5pbWFsbHkgZW5jb2RlZCBzY3JpcHQgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gNSkge1xuICAgICAgICBjb25zdCBhID0gYnVmZmVyLnJlYWRVSW50MzJMRSgwKTtcbiAgICAgICAgY29uc3QgYiA9IGJ1ZmZlci5yZWFkVUludDgoNCk7XG4gICAgICAgIGlmIChiICYgMHg4MClcbiAgICAgICAgICAgIHJldHVybiAtKChiICYgfjB4ODApICogMHgxMDAwMDAwMDAgKyBhKTtcbiAgICAgICAgcmV0dXJuIGIgKiAweDEwMDAwMDAwMCArIGE7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzdWx0IHw9IGJ1ZmZlcltpXSA8PCAoOCAqIGkpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyW2xlbmd0aCAtIDFdICYgMHg4MClcbiAgICAgICAgcmV0dXJuIC0ocmVzdWx0ICYgfigweDgwIDw8ICg4ICogKGxlbmd0aCAtIDEpKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIHNjcmlwdE51bVNpemUoaSkge1xuICAgIHJldHVybiBpID4gMHg3ZmZmZmZmZlxuICAgICAgICA/IDVcbiAgICAgICAgOiBpID4gMHg3ZmZmZmZcbiAgICAgICAgICAgID8gNFxuICAgICAgICAgICAgOiBpID4gMHg3ZmZmXG4gICAgICAgICAgICAgICAgPyAzXG4gICAgICAgICAgICAgICAgOiBpID4gMHg3ZlxuICAgICAgICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgICAgICAgOiBpID4gMHgwMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG59XG5mdW5jdGlvbiBlbmNvZGUoX251bWJlcikge1xuICAgIGxldCB2YWx1ZSA9IE1hdGguYWJzKF9udW1iZXIpO1xuICAgIGNvbnN0IHNpemUgPSBzY3JpcHROdW1TaXplKHZhbHVlKTtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgY29uc3QgbmVnYXRpdmUgPSBfbnVtYmVyIDwgMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OCh2YWx1ZSAmIDB4ZmYsIGkpO1xuICAgICAgICB2YWx1ZSA+Pj0gODtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlcltzaXplIC0gMV0gJiAweDgwKSB7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG5lZ2F0aXZlID8gMHg4MCA6IDB4MDAsIHNpemUgLSAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgYnVmZmVyW3NpemUgLSAxXSB8PSAweDgwO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JpcHRfbnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script_number.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script_signature.js':
    /*!***********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script_signature.js ***!
  \***********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.encode = exports.decode = void 0;\nconst bip66 = __importStar(__webpack_require__(/*! ./bip66 */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip66.js"));\nconst types = __importStar(__webpack_require__(/*! ./types */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js"));\nconst { typeforce } = types;\nconst ZERO = Buffer.alloc(1, 0);\nfunction toDER(x) {\n    let i = 0;\n    while (x[i] === 0)\n        ++i;\n    if (i === x.length)\n        return ZERO;\n    x = x.slice(i);\n    if (x[0] & 0x80)\n        return Buffer.concat([ZERO, x], 1 + x.length);\n    return x;\n}\nfunction fromDER(x) {\n    if (x[0] === 0x00)\n        x = x.slice(1);\n    const buffer = Buffer.alloc(32, 0);\n    const bstart = Math.max(0, 32 - x.length);\n    x.copy(buffer, bstart);\n    return buffer;\n}\nfunction decode(buffer) {\n    const hashType = buffer.readUInt8(buffer.length - 1);\n    const hashTypeMod = hashType & ~0xc0;\n    if (hashTypeMod <= 0 || hashTypeMod >= 4)\n        throw new Error(\'Invalid hashType \' + hashType);\n    const decoded = bip66.decode(buffer.slice(0, -1));\n    const r = fromDER(decoded.r);\n    const s = fromDER(decoded.s);\n    const signature = Buffer.concat([r, s], 64);\n    return { signature, hashType };\n}\nexports.decode = decode;\nfunction encode(signature, hashType) {\n    typeforce({\n        signature: types.BufferN(64),\n        hashType: types.UInt8,\n    }, { signature, hashType });\n    const hashTypeMod = hashType & ~0xc0;\n    if (hashTypeMod <= 0 || hashTypeMod >= 4)\n        throw new Error(\'Invalid hashType \' + hashType);\n    const hashTypeBuffer = Buffer.allocUnsafe(1);\n    hashTypeBuffer.writeUInt8(hashType, 0);\n    const r = toDER(signature.slice(0, 32));\n    const s = toDER(signature.slice(32, 64));\n    return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n//# sourceMappingURL=script_signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9zY3JpcHRfc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQiwyQkFBMkIsbUJBQU8sQ0FBQyx1RkFBUztBQUM1QywyQkFBMkIsbUJBQU8sQ0FBQyx1RkFBUztBQUM1QyxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSSxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi9zY3JpcHRfc2lnbmF0dXJlLmpzP2E5YTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG5jb25zdCBiaXA2NiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iaXA2NlwiKSk7XG5jb25zdCB0eXBlcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSk7XG5jb25zdCB7IHR5cGVmb3JjZSB9ID0gdHlwZXM7XG5jb25zdCBaRVJPID0gQnVmZmVyLmFsbG9jKDEsIDApO1xuZnVuY3Rpb24gdG9ERVIoeCkge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoeFtpXSA9PT0gMClcbiAgICAgICAgKytpO1xuICAgIGlmIChpID09PSB4Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFpFUk87XG4gICAgeCA9IHguc2xpY2UoaSk7XG4gICAgaWYgKHhbMF0gJiAweDgwKVxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbWkVSTywgeF0sIDEgKyB4Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBmcm9tREVSKHgpIHtcbiAgICBpZiAoeFswXSA9PT0gMHgwMClcbiAgICAgICAgeCA9IHguc2xpY2UoMSk7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgICBjb25zdCBic3RhcnQgPSBNYXRoLm1heCgwLCAzMiAtIHgubGVuZ3RoKTtcbiAgICB4LmNvcHkoYnVmZmVyLCBic3RhcnQpO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBkZWNvZGUoYnVmZmVyKSB7XG4gICAgY29uc3QgaGFzaFR5cGUgPSBidWZmZXIucmVhZFVJbnQ4KGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBoYXNoVHlwZU1vZCA9IGhhc2hUeXBlICYgfjB4YzA7XG4gICAgaWYgKGhhc2hUeXBlTW9kIDw9IDAgfHwgaGFzaFR5cGVNb2QgPj0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhhc2hUeXBlICcgKyBoYXNoVHlwZSk7XG4gICAgY29uc3QgZGVjb2RlZCA9IGJpcDY2LmRlY29kZShidWZmZXIuc2xpY2UoMCwgLTEpKTtcbiAgICBjb25zdCByID0gZnJvbURFUihkZWNvZGVkLnIpO1xuICAgIGNvbnN0IHMgPSBmcm9tREVSKGRlY29kZWQucyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbciwgc10sIDY0KTtcbiAgICByZXR1cm4geyBzaWduYXR1cmUsIGhhc2hUeXBlIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShzaWduYXR1cmUsIGhhc2hUeXBlKSB7XG4gICAgdHlwZWZvcmNlKHtcbiAgICAgICAgc2lnbmF0dXJlOiB0eXBlcy5CdWZmZXJOKDY0KSxcbiAgICAgICAgaGFzaFR5cGU6IHR5cGVzLlVJbnQ4LFxuICAgIH0sIHsgc2lnbmF0dXJlLCBoYXNoVHlwZSB9KTtcbiAgICBjb25zdCBoYXNoVHlwZU1vZCA9IGhhc2hUeXBlICYgfjB4YzA7XG4gICAgaWYgKGhhc2hUeXBlTW9kIDw9IDAgfHwgaGFzaFR5cGVNb2QgPj0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhhc2hUeXBlICcgKyBoYXNoVHlwZSk7XG4gICAgY29uc3QgaGFzaFR5cGVCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMSk7XG4gICAgaGFzaFR5cGVCdWZmZXIud3JpdGVVSW50OChoYXNoVHlwZSwgMCk7XG4gICAgY29uc3QgciA9IHRvREVSKHNpZ25hdHVyZS5zbGljZSgwLCAzMikpO1xuICAgIGNvbnN0IHMgPSB0b0RFUihzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2JpcDY2LmVuY29kZShyLCBzKSwgaGFzaFR5cGVCdWZmZXJdKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyaXB0X3NpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script_signature.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/transaction.js':
    /*!******************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/transaction.js ***!
  \******************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = exports.vectorSize = exports.varSliceSize = void 0;\nconst bufferutils_1 = __webpack_require__(/*! ./bufferutils */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js\");\nconst bcrypto = __importStar(__webpack_require__(/*! ./crypto */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js\"));\nconst bscript = __importStar(__webpack_require__(/*! ./script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\"));\nconst script_1 = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js\");\nconst types = __importStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\"));\nconst { typeforce } = types;\nfunction varSliceSize(someScript) {\n    const length = someScript.length;\n    return bufferutils_1.varuint.encodingLength(length) + length;\n}\nexports.varSliceSize = varSliceSize;\nfunction vectorSize(someVector) {\n    const length = someVector.length;\n    return (bufferutils_1.varuint.encodingLength(length) +\n        someVector.reduce((sum, witness) => {\n            return sum + varSliceSize(witness);\n        }, 0));\n}\nexports.vectorSize = vectorSize;\nconst EMPTY_BUFFER = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\nconst ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n    script: EMPTY_BUFFER,\n    valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n    return out.value !== undefined;\n}\nclass Transaction {\n    constructor() {\n        this.version = 1;\n        this.locktime = 0;\n        this.ins = [];\n        this.outs = [];\n    }\n    static fromBuffer(buffer, _NO_STRICT) {\n        const bufferReader = new bufferutils_1.BufferReader(buffer);\n        const tx = new Transaction();\n        tx.version = bufferReader.readInt32();\n        const marker = bufferReader.readUInt8();\n        const flag = bufferReader.readUInt8();\n        let hasWitnesses = false;\n        if (marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n            flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n            hasWitnesses = true;\n        }\n        else {\n            bufferReader.offset -= 2;\n        }\n        const vinLen = bufferReader.readVarInt();\n        for (let i = 0; i < vinLen; ++i) {\n            tx.ins.push({\n                hash: bufferReader.readSlice(32),\n                index: bufferReader.readUInt32(),\n                script: bufferReader.readVarSlice(),\n                sequence: bufferReader.readUInt32(),\n                witness: EMPTY_WITNESS,\n            });\n        }\n        const voutLen = bufferReader.readVarInt();\n        for (let i = 0; i < voutLen; ++i) {\n            tx.outs.push({\n                value: bufferReader.readUInt64(),\n                script: bufferReader.readVarSlice(),\n            });\n        }\n        if (hasWitnesses) {\n            for (let i = 0; i < vinLen; ++i) {\n                tx.ins[i].witness = bufferReader.readVector();\n            }\n            if (!tx.hasWitnesses())\n                throw new Error('Transaction has superfluous witness data');\n        }\n        tx.locktime = bufferReader.readUInt32();\n        if (_NO_STRICT)\n            return tx;\n        if (bufferReader.offset !== buffer.length)\n            throw new Error('Transaction has unexpected data');\n        return tx;\n    }\n    static fromHex(hex) {\n        return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n    }\n    static isCoinbaseHash(buffer) {\n        typeforce(types.Hash256bit, buffer);\n        for (let i = 0; i < 32; ++i) {\n            if (buffer[i] !== 0)\n                return false;\n        }\n        return true;\n    }\n    isCoinbase() {\n        return (this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash));\n    }\n    addInput(hash, index, sequence, scriptSig) {\n        typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);\n        if (types.Null(sequence)) {\n            sequence = Transaction.DEFAULT_SEQUENCE;\n        }\n        return (this.ins.push({\n            hash,\n            index,\n            script: scriptSig || EMPTY_BUFFER,\n            sequence: sequence,\n            witness: EMPTY_WITNESS,\n        }) - 1);\n    }\n    addOutput(scriptPubKey, value) {\n        typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n        return (this.outs.push({\n            script: scriptPubKey,\n            value,\n        }) - 1);\n    }\n    hasWitnesses() {\n        return this.ins.some(x => {\n            return x.witness.length !== 0;\n        });\n    }\n    weight() {\n        const base = this.byteLength(false);\n        const total = this.byteLength(true);\n        return base * 3 + total;\n    }\n    virtualSize() {\n        return Math.ceil(this.weight() / 4);\n    }\n    dogeByteLength() {\n        let result = 4 + 9 + 9 + 4 +\n            this.ins.reduce((sum, input) => {\n                let l = 32 + 4 + 4 + varSliceSize(input.script);\n                return sum + 32 + 4 + l;\n            }, 0) +\n            this.outs.reduce((sum, output) => {\n                return sum + 9 + output.script.length;\n            }, 0);\n        return Math.ceil(result);\n        ;\n    }\n    byteLength(_ALLOW_WITNESS = true) {\n        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n        return ((hasWitnesses ? 10 : 8) +\n            bufferutils_1.varuint.encodingLength(this.ins.length) +\n            bufferutils_1.varuint.encodingLength(this.outs.length) +\n            this.ins.reduce((sum, input) => {\n                return sum + 40 + varSliceSize(input.script);\n            }, 0) +\n            this.outs.reduce((sum, output) => {\n                return sum + 8 + varSliceSize(output.script);\n            }, 0) +\n            (hasWitnesses\n                ? this.ins.reduce((sum, input) => {\n                    return sum + vectorSize(input.witness);\n                }, 0)\n                : 0));\n    }\n    clone() {\n        const newTx = new Transaction();\n        newTx.version = this.version;\n        newTx.locktime = this.locktime;\n        newTx.ins = this.ins.map(txIn => {\n            return {\n                hash: txIn.hash,\n                index: txIn.index,\n                script: txIn.script,\n                sequence: txIn.sequence,\n                witness: txIn.witness,\n            };\n        });\n        newTx.outs = this.outs.map(txOut => {\n            return {\n                script: txOut.script,\n                value: txOut.value,\n            };\n        });\n        return newTx;\n    }\n    hashForSignature(inIndex, prevOutScript, hashType) {\n        typeforce(types.tuple(types.UInt32, types.Buffer, types.Number), arguments);\n        if (inIndex >= this.ins.length)\n            return ONE;\n        const ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(x => {\n            return x !== script_1.OPS.OP_CODESEPARATOR;\n        }));\n        const txTmp = this.clone();\n        if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n            txTmp.outs = [];\n            txTmp.ins.forEach((input, i) => {\n                if (i === inIndex)\n                    return;\n                input.sequence = 0;\n            });\n        }\n        else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n            if (inIndex >= this.outs.length)\n                return ONE;\n            txTmp.outs.length = inIndex + 1;\n            for (let i = 0; i < inIndex; i++) {\n                txTmp.outs[i] = BLANK_OUTPUT;\n            }\n            txTmp.ins.forEach((input, y) => {\n                if (y === inIndex)\n                    return;\n                input.sequence = 0;\n            });\n        }\n        if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n            txTmp.ins = [txTmp.ins[inIndex]];\n            txTmp.ins[0].script = ourScript;\n        }\n        else {\n            txTmp.ins.forEach(input => {\n                input.script = EMPTY_BUFFER;\n            });\n            txTmp.ins[inIndex].script = ourScript;\n        }\n        const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n        buffer.writeInt32LE(hashType, buffer.length - 4);\n        txTmp.__toBuffer(buffer, 0, false);\n        return bcrypto.hash256(buffer);\n    }\n    hashForCashSignature(inIndex, prevOutScript, inAmount, hashType) {\n        if (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) {\n            if (types.Null(inAmount)) {\n                throw new Error('Bitcoin Cash sighash requires value of input to be signed.');\n            }\n            return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, hashType);\n        }\n        else {\n            return this.hashForSignature(inIndex, prevOutScript, hashType);\n        }\n    }\n    hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n        typeforce(types.tuple(types.UInt32, typeforce.arrayOf(types.Buffer), typeforce.arrayOf(types.Satoshi), types.UInt32), arguments);\n        if (values.length !== this.ins.length ||\n            prevOutScripts.length !== this.ins.length) {\n            throw new Error('Must supply prevout script and value for all inputs');\n        }\n        const outputType = hashType === Transaction.SIGHASH_DEFAULT\n            ? Transaction.SIGHASH_ALL\n            : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n        const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n        const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n        const isNone = outputType === Transaction.SIGHASH_NONE;\n        const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n        let hashPrevouts = EMPTY_BUFFER;\n        let hashAmounts = EMPTY_BUFFER;\n        let hashScriptPubKeys = EMPTY_BUFFER;\n        let hashSequences = EMPTY_BUFFER;\n        let hashOutputs = EMPTY_BUFFER;\n        if (!isAnyoneCanPay) {\n            let bufferWriter = bufferutils_1.BufferWriter.withCapacity(36 * this.ins.length);\n            this.ins.forEach(txIn => {\n                bufferWriter.writeSlice(txIn.hash);\n                bufferWriter.writeUInt32(txIn.index);\n            });\n            hashPrevouts = bcrypto.sha256(bufferWriter.end());\n            bufferWriter = bufferutils_1.BufferWriter.withCapacity(8 * this.ins.length);\n            values.forEach(value => bufferWriter.writeUInt64(value));\n            hashAmounts = bcrypto.sha256(bufferWriter.end());\n            bufferWriter = bufferutils_1.BufferWriter.withCapacity(prevOutScripts.map(varSliceSize).reduce((a, b) => a + b));\n            prevOutScripts.forEach(prevOutScript => bufferWriter.writeVarSlice(prevOutScript));\n            hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());\n            bufferWriter = bufferutils_1.BufferWriter.withCapacity(4 * this.ins.length);\n            this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n            hashSequences = bcrypto.sha256(bufferWriter.end());\n        }\n        if (!(isNone || isSingle)) {\n            const txOutsSize = this.outs\n                .map(output => 8 + varSliceSize(output.script))\n                .reduce((a, b) => a + b);\n            const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);\n            this.outs.forEach(out => {\n                bufferWriter.writeUInt64(out.value);\n                bufferWriter.writeVarSlice(out.script);\n            });\n            hashOutputs = bcrypto.sha256(bufferWriter.end());\n        }\n        else if (isSingle && inIndex < this.outs.length) {\n            const output = this.outs[inIndex];\n            const bufferWriter = bufferutils_1.BufferWriter.withCapacity(8 + varSliceSize(output.script));\n            bufferWriter.writeUInt64(output.value);\n            bufferWriter.writeVarSlice(output.script);\n            hashOutputs = bcrypto.sha256(bufferWriter.end());\n        }\n        const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n        const sigMsgSize = 174 -\n            (isAnyoneCanPay ? 49 : 0) -\n            (isNone ? 32 : 0) +\n            (annex ? 32 : 0) +\n            (leafHash ? 37 : 0);\n        const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);\n        sigMsgWriter.writeUInt8(hashType);\n        sigMsgWriter.writeInt32(this.version);\n        sigMsgWriter.writeUInt32(this.locktime);\n        sigMsgWriter.writeSlice(hashPrevouts);\n        sigMsgWriter.writeSlice(hashAmounts);\n        sigMsgWriter.writeSlice(hashScriptPubKeys);\n        sigMsgWriter.writeSlice(hashSequences);\n        if (!(isNone || isSingle)) {\n            sigMsgWriter.writeSlice(hashOutputs);\n        }\n        sigMsgWriter.writeUInt8(spendType);\n        if (isAnyoneCanPay) {\n            const input = this.ins[inIndex];\n            sigMsgWriter.writeSlice(input.hash);\n            sigMsgWriter.writeUInt32(input.index);\n            sigMsgWriter.writeUInt64(values[inIndex]);\n            sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n            sigMsgWriter.writeUInt32(input.sequence);\n        }\n        else {\n            sigMsgWriter.writeUInt32(inIndex);\n        }\n        if (annex) {\n            const bufferWriter = bufferutils_1.BufferWriter.withCapacity(varSliceSize(annex));\n            bufferWriter.writeVarSlice(annex);\n            sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));\n        }\n        if (isSingle) {\n            sigMsgWriter.writeSlice(hashOutputs);\n        }\n        if (leafHash) {\n            sigMsgWriter.writeSlice(leafHash);\n            sigMsgWriter.writeUInt8(0);\n            sigMsgWriter.writeUInt32(0xffffffff);\n        }\n        return bcrypto.taggedHash('TapSighash', Buffer.concat([Buffer.of(0x00), sigMsgWriter.end()]));\n    }\n    hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n        typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n        let tbuffer = Buffer.from([]);\n        let bufferWriter;\n        let hashOutputs = ZERO;\n        let hashPrevouts = ZERO;\n        let hashSequence = ZERO;\n        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n            tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n            this.ins.forEach(txIn => {\n                bufferWriter.writeSlice(txIn.hash);\n                bufferWriter.writeUInt32(txIn.index);\n            });\n            hashPrevouts = bcrypto.hash256(tbuffer);\n        }\n        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n            (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n            (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n            tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n            this.ins.forEach(txIn => {\n                bufferWriter.writeUInt32(txIn.sequence);\n            });\n            hashSequence = bcrypto.hash256(tbuffer);\n        }\n        if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n            (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n            const txOutsSize = this.outs.reduce((sum, output) => {\n                return sum + 8 + varSliceSize(output.script);\n            }, 0);\n            tbuffer = Buffer.allocUnsafe(txOutsSize);\n            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n            this.outs.forEach(out => {\n                bufferWriter.writeUInt64(out.value);\n                bufferWriter.writeVarSlice(out.script);\n            });\n            hashOutputs = bcrypto.hash256(tbuffer);\n        }\n        else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n            inIndex < this.outs.length) {\n            const output = this.outs[inIndex];\n            tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n            bufferWriter.writeUInt64(output.value);\n            bufferWriter.writeVarSlice(output.script);\n            hashOutputs = bcrypto.hash256(tbuffer);\n        }\n        tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n        bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n        const input = this.ins[inIndex];\n        bufferWriter.writeInt32(this.version);\n        bufferWriter.writeSlice(hashPrevouts);\n        bufferWriter.writeSlice(hashSequence);\n        bufferWriter.writeSlice(input.hash);\n        bufferWriter.writeUInt32(input.index);\n        bufferWriter.writeVarSlice(prevOutScript);\n        bufferWriter.writeUInt64(value);\n        bufferWriter.writeUInt32(input.sequence);\n        bufferWriter.writeSlice(hashOutputs);\n        bufferWriter.writeUInt32(this.locktime);\n        bufferWriter.writeUInt32(hashType);\n        return bcrypto.hash256(tbuffer);\n    }\n    getHash(forWitness) {\n        if (forWitness && this.isCoinbase())\n            return Buffer.alloc(32, 0);\n        return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n    }\n    getId() {\n        return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString('hex');\n    }\n    toBuffer(buffer, initialOffset) {\n        return this.__toBuffer(buffer, initialOffset, true);\n    }\n    toHex() {\n        return this.toBuffer(undefined, undefined).toString('hex');\n    }\n    setInputScript(index, scriptSig) {\n        typeforce(types.tuple(types.Number, types.Buffer), arguments);\n        this.ins[index].script = scriptSig;\n    }\n    setWitness(index, witness) {\n        typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n        this.ins[index].witness = witness;\n    }\n    __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n        if (!buffer)\n            buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n        const bufferWriter = new bufferutils_1.BufferWriter(buffer, initialOffset || 0);\n        bufferWriter.writeInt32(this.version);\n        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n        if (hasWitnesses) {\n            bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n            bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n        }\n        bufferWriter.writeVarInt(this.ins.length);\n        this.ins.forEach(txIn => {\n            bufferWriter.writeSlice(txIn.hash);\n            bufferWriter.writeUInt32(txIn.index);\n            bufferWriter.writeVarSlice(txIn.script);\n            bufferWriter.writeUInt32(txIn.sequence);\n        });\n        bufferWriter.writeVarInt(this.outs.length);\n        this.outs.forEach(txOut => {\n            if (isOutput(txOut)) {\n                bufferWriter.writeUInt64(txOut.value);\n            }\n            else {\n                bufferWriter.writeSlice(txOut.valueBuffer);\n            }\n            bufferWriter.writeVarSlice(txOut.script);\n        });\n        if (hasWitnesses) {\n            this.ins.forEach(input => {\n                bufferWriter.writeVector(input.witness);\n            });\n        }\n        bufferWriter.writeUInt32(this.locktime);\n        if (initialOffset !== undefined)\n            return buffer.slice(initialOffset, bufferWriter.offset);\n        return buffer;\n    }\n    hashForWitness(inIndex, prevOutScript, value, hashType) {\n        typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n        let tbuffer = Buffer.from([]);\n        let bufferWriter;\n        let hashOutputs = ZERO;\n        let hashPrevouts = ZERO;\n        let hashSequence = ZERO;\n        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n            tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n            this.ins.forEach(txIn => {\n                bufferWriter.writeSlice(txIn.hash);\n                bufferWriter.writeUInt32(txIn.index);\n            });\n            hashPrevouts = bcrypto.hash256(tbuffer);\n        }\n        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n            (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n            (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n            tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n            this.ins.forEach(txIn => {\n                bufferWriter.writeUInt32(txIn.sequence);\n            });\n            hashSequence = bcrypto.hash256(tbuffer);\n        }\n        if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n            (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n            const txOutsSize = this.outs.reduce((sum, output) => {\n                return sum + 8 + varSliceSize(output.script);\n            }, 0);\n            tbuffer = Buffer.allocUnsafe(txOutsSize);\n            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n            this.outs.forEach(out => {\n                bufferWriter.writeUInt64(out.value);\n                bufferWriter.writeVarSlice(out.script);\n            });\n            hashOutputs = bcrypto.hash256(tbuffer);\n        }\n        else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n            inIndex < this.outs.length) {\n            const output = this.outs[inIndex];\n            tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n            bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n            bufferWriter.writeUInt64(output.value);\n            bufferWriter.writeVarSlice(output.script);\n            hashOutputs = bcrypto.hash256(tbuffer);\n        }\n        tbuffer = Buffer.allocUnsafe(156 + prevOutScript.length);\n        bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n        const input = this.ins[inIndex];\n        bufferWriter.writeInt32(this.version);\n        bufferWriter.writeSlice(hashPrevouts);\n        bufferWriter.writeSlice(hashSequence);\n        bufferWriter.writeSlice(input.hash);\n        bufferWriter.writeUInt32(input.index);\n        bufferWriter.writeSlice(prevOutScript);\n        bufferWriter.writeUInt64(value);\n        bufferWriter.writeUInt32(input.sequence);\n        bufferWriter.writeSlice(hashOutputs);\n        bufferWriter.writeUInt32(this.locktime);\n        bufferWriter.writeUInt32(hashType);\n        return bcrypto.hash256(tbuffer);\n    }\n}\nexports.Transaction = Transaction;\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_DEFAULT = 0x00;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_OUTPUT_MASK = 0x03;\nTransaction.SIGHASH_INPUT_MASK = 0x80;\nTransaction.SIGHASH_BITCOINCASHBIP143 = 0x40;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\n//# sourceMappingURL=transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsb0JBQW9CO0FBQy9ELHNCQUFzQixtQkFBTyxDQUFDLG1HQUFlO0FBQzdDLDZCQUE2QixtQkFBTyxDQUFDLHlGQUFVO0FBQy9DLDZCQUE2QixtQkFBTyxDQUFDLHlGQUFVO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLHlGQUFVO0FBQ25DLDJCQUEyQixtQkFBTyxDQUFDLHVGQUFTO0FBQzVDLFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9iaXRjb2luanMtbGliL3RyYW5zYWN0aW9uLmpzP2IzNmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBleHBvcnRzLnZlY3RvclNpemUgPSBleHBvcnRzLnZhclNsaWNlU2l6ZSA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcnV0aWxzXzEgPSByZXF1aXJlKFwiLi9idWZmZXJ1dGlsc1wiKTtcbmNvbnN0IGJjcnlwdG8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY3J5cHRvXCIpKTtcbmNvbnN0IGJzY3JpcHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2NyaXB0XCIpKTtcbmNvbnN0IHNjcmlwdF8xID0gcmVxdWlyZShcIi4vc2NyaXB0XCIpO1xuY29uc3QgdHlwZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIikpO1xuY29uc3QgeyB0eXBlZm9yY2UgfSA9IHR5cGVzO1xuZnVuY3Rpb24gdmFyU2xpY2VTaXplKHNvbWVTY3JpcHQpIHtcbiAgICBjb25zdCBsZW5ndGggPSBzb21lU2NyaXB0Lmxlbmd0aDtcbiAgICByZXR1cm4gYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGxlbmd0aCkgKyBsZW5ndGg7XG59XG5leHBvcnRzLnZhclNsaWNlU2l6ZSA9IHZhclNsaWNlU2l6ZTtcbmZ1bmN0aW9uIHZlY3RvclNpemUoc29tZVZlY3Rvcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHNvbWVWZWN0b3IubGVuZ3RoO1xuICAgIHJldHVybiAoYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGxlbmd0aCkgK1xuICAgICAgICBzb21lVmVjdG9yLnJlZHVjZSgoc3VtLCB3aXRuZXNzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgdmFyU2xpY2VTaXplKHdpdG5lc3MpO1xuICAgICAgICB9LCAwKSk7XG59XG5leHBvcnRzLnZlY3RvclNpemUgPSB2ZWN0b3JTaXplO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuY29uc3QgRU1QVFlfV0lUTkVTUyA9IFtdO1xuY29uc3QgWkVSTyA9IEJ1ZmZlci5mcm9tKCcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgJ2hleCcpO1xuY29uc3QgT05FID0gQnVmZmVyLmZyb20oJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAnaGV4Jyk7XG5jb25zdCBWQUxVRV9VSU5UNjRfTUFYID0gQnVmZmVyLmZyb20oJ2ZmZmZmZmZmZmZmZmZmZmYnLCAnaGV4Jyk7XG5jb25zdCBCTEFOS19PVVRQVVQgPSB7XG4gICAgc2NyaXB0OiBFTVBUWV9CVUZGRVIsXG4gICAgdmFsdWVCdWZmZXI6IFZBTFVFX1VJTlQ2NF9NQVgsXG59O1xuZnVuY3Rpb24gaXNPdXRwdXQob3V0KSB7XG4gICAgcmV0dXJuIG91dC52YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgICAgICB0aGlzLmxvY2t0aW1lID0gMDtcbiAgICAgICAgdGhpcy5pbnMgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlciwgX05PX1NUUklDVCkge1xuICAgICAgICBjb25zdCBidWZmZXJSZWFkZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgdHgudmVyc2lvbiA9IGJ1ZmZlclJlYWRlci5yZWFkSW50MzIoKTtcbiAgICAgICAgY29uc3QgbWFya2VyID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50OCgpO1xuICAgICAgICBjb25zdCBmbGFnID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50OCgpO1xuICAgICAgICBsZXQgaGFzV2l0bmVzc2VzID0gZmFsc2U7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IFRyYW5zYWN0aW9uLkFEVkFOQ0VEX1RSQU5TQUNUSU9OX01BUktFUiAmJlxuICAgICAgICAgICAgZmxhZyA9PT0gVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fRkxBRykge1xuICAgICAgICAgICAgaGFzV2l0bmVzc2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlclJlYWRlci5vZmZzZXQgLT0gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aW5MZW4gPSBidWZmZXJSZWFkZXIucmVhZFZhckludCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpbkxlbjsgKytpKSB7XG4gICAgICAgICAgICB0eC5pbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaGFzaDogYnVmZmVyUmVhZGVyLnJlYWRTbGljZSgzMiksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGJ1ZmZlclJlYWRlci5yZWFkVUludDMyKCksXG4gICAgICAgICAgICAgICAgc2NyaXB0OiBidWZmZXJSZWFkZXIucmVhZFZhclNsaWNlKCksXG4gICAgICAgICAgICAgICAgc2VxdWVuY2U6IGJ1ZmZlclJlYWRlci5yZWFkVUludDMyKCksXG4gICAgICAgICAgICAgICAgd2l0bmVzczogRU1QVFlfV0lUTkVTUyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZvdXRMZW4gPSBidWZmZXJSZWFkZXIucmVhZFZhckludCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZvdXRMZW47ICsraSkge1xuICAgICAgICAgICAgdHgub3V0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYnVmZmVyUmVhZGVyLnJlYWRVSW50NjQoKSxcbiAgICAgICAgICAgICAgICBzY3JpcHQ6IGJ1ZmZlclJlYWRlci5yZWFkVmFyU2xpY2UoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNXaXRuZXNzZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmluTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0eC5pbnNbaV0ud2l0bmVzcyA9IGJ1ZmZlclJlYWRlci5yZWFkVmVjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXR4Lmhhc1dpdG5lc3NlcygpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gaGFzIHN1cGVyZmx1b3VzIHdpdG5lc3MgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIHR4LmxvY2t0aW1lID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50MzIoKTtcbiAgICAgICAgaWYgKF9OT19TVFJJQ1QpXG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIGlmIChidWZmZXJSZWFkZXIub2Zmc2V0ICE9PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBoYXMgdW5leHBlY3RlZCBkYXRhJyk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpLCBmYWxzZSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0NvaW5iYXNlSGFzaChidWZmZXIpIHtcbiAgICAgICAgdHlwZWZvcmNlKHR5cGVzLkhhc2gyNTZiaXQsIGJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpXSAhPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzQ29pbmJhc2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbnMubGVuZ3RoID09PSAxICYmIFRyYW5zYWN0aW9uLmlzQ29pbmJhc2VIYXNoKHRoaXMuaW5zWzBdLmhhc2gpKTtcbiAgICB9XG4gICAgYWRkSW5wdXQoaGFzaCwgaW5kZXgsIHNlcXVlbmNlLCBzY3JpcHRTaWcpIHtcbiAgICAgICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLkhhc2gyNTZiaXQsIHR5cGVzLlVJbnQzMiwgdHlwZXMubWF5YmUodHlwZXMuVUludDMyKSwgdHlwZXMubWF5YmUodHlwZXMuQnVmZmVyKSksIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0eXBlcy5OdWxsKHNlcXVlbmNlKSkge1xuICAgICAgICAgICAgc2VxdWVuY2UgPSBUcmFuc2FjdGlvbi5ERUZBVUxUX1NFUVVFTkNFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5pbnMucHVzaCh7XG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBzY3JpcHQ6IHNjcmlwdFNpZyB8fCBFTVBUWV9CVUZGRVIsXG4gICAgICAgICAgICBzZXF1ZW5jZTogc2VxdWVuY2UsXG4gICAgICAgICAgICB3aXRuZXNzOiBFTVBUWV9XSVRORVNTLFxuICAgICAgICB9KSAtIDEpO1xuICAgIH1cbiAgICBhZGRPdXRwdXQoc2NyaXB0UHViS2V5LCB2YWx1ZSkge1xuICAgICAgICB0eXBlZm9yY2UodHlwZXMudHVwbGUodHlwZXMuQnVmZmVyLCB0eXBlcy5TYXRvc2hpKSwgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLm91dHMucHVzaCh7XG4gICAgICAgICAgICBzY3JpcHQ6IHNjcmlwdFB1YktleSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KSAtIDEpO1xuICAgIH1cbiAgICBoYXNXaXRuZXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucy5zb21lKHggPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgud2l0bmVzcy5sZW5ndGggIT09IDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3ZWlnaHQoKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLmJ5dGVMZW5ndGgoZmFsc2UpO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHRoaXMuYnl0ZUxlbmd0aCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGJhc2UgKiAzICsgdG90YWw7XG4gICAgfVxuICAgIHZpcnR1YWxTaXplKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMud2VpZ2h0KCkgLyA0KTtcbiAgICB9XG4gICAgZG9nZUJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSA0ICsgOSArIDkgKyA0ICtcbiAgICAgICAgICAgIHRoaXMuaW5zLnJlZHVjZSgoc3VtLCBpbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsID0gMzIgKyA0ICsgNCArIHZhclNsaWNlU2l6ZShpbnB1dC5zY3JpcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyAzMiArIDQgKyBsO1xuICAgICAgICAgICAgfSwgMCkgK1xuICAgICAgICAgICAgdGhpcy5vdXRzLnJlZHVjZSgoc3VtLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtICsgOSArIG91dHB1dC5zY3JpcHQubGVuZ3RoO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwocmVzdWx0KTtcbiAgICAgICAgO1xuICAgIH1cbiAgICBieXRlTGVuZ3RoKF9BTExPV19XSVRORVNTID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBoYXNXaXRuZXNzZXMgPSBfQUxMT1dfV0lUTkVTUyAmJiB0aGlzLmhhc1dpdG5lc3NlcygpO1xuICAgICAgICByZXR1cm4gKChoYXNXaXRuZXNzZXMgPyAxMCA6IDgpICtcbiAgICAgICAgICAgIGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aCh0aGlzLmlucy5sZW5ndGgpICtcbiAgICAgICAgICAgIGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aCh0aGlzLm91dHMubGVuZ3RoKSArXG4gICAgICAgICAgICB0aGlzLmlucy5yZWR1Y2UoKHN1bSwgaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtICsgNDAgKyB2YXJTbGljZVNpemUoaW5wdXQuc2NyaXB0KTtcbiAgICAgICAgICAgIH0sIDApICtcbiAgICAgICAgICAgIHRoaXMub3V0cy5yZWR1Y2UoKHN1bSwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCk7XG4gICAgICAgICAgICB9LCAwKSArXG4gICAgICAgICAgICAoaGFzV2l0bmVzc2VzXG4gICAgICAgICAgICAgICAgPyB0aGlzLmlucy5yZWR1Y2UoKHN1bSwgaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIHZlY3RvclNpemUoaW5wdXQud2l0bmVzcyk7XG4gICAgICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICAgICAgICA6IDApKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IG5ld1R4ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIG5ld1R4LnZlcnNpb24gPSB0aGlzLnZlcnNpb247XG4gICAgICAgIG5ld1R4LmxvY2t0aW1lID0gdGhpcy5sb2NrdGltZTtcbiAgICAgICAgbmV3VHguaW5zID0gdGhpcy5pbnMubWFwKHR4SW4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoYXNoOiB0eEluLmhhc2gsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHR4SW4uaW5kZXgsXG4gICAgICAgICAgICAgICAgc2NyaXB0OiB0eEluLnNjcmlwdCxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZTogdHhJbi5zZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICB3aXRuZXNzOiB0eEluLndpdG5lc3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgbmV3VHgub3V0cyA9IHRoaXMub3V0cy5tYXAodHhPdXQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQ6IHR4T3V0LnNjcmlwdCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHhPdXQudmFsdWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1R4O1xuICAgIH1cbiAgICBoYXNoRm9yU2lnbmF0dXJlKGluSW5kZXgsIHByZXZPdXRTY3JpcHQsIGhhc2hUeXBlKSB7XG4gICAgICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5VSW50MzIsIHR5cGVzLkJ1ZmZlciwgdHlwZXMuTnVtYmVyKSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGluSW5kZXggPj0gdGhpcy5pbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIE9ORTtcbiAgICAgICAgY29uc3Qgb3VyU2NyaXB0ID0gYnNjcmlwdC5jb21waWxlKGJzY3JpcHQuZGVjb21waWxlKHByZXZPdXRTY3JpcHQpLmZpbHRlcih4ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4ICE9PSBzY3JpcHRfMS5PUFMuT1BfQ09ERVNFUEFSQVRPUjtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB0eFRtcCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKChoYXNoVHlwZSAmIDB4MWYpID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX05PTkUpIHtcbiAgICAgICAgICAgIHR4VG1wLm91dHMgPSBbXTtcbiAgICAgICAgICAgIHR4VG1wLmlucy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBpbkluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaW5wdXQuc2VxdWVuY2UgPSAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGhhc2hUeXBlICYgMHgxZikgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFKSB7XG4gICAgICAgICAgICBpZiAoaW5JbmRleCA+PSB0aGlzLm91dHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XG4gICAgICAgICAgICB0eFRtcC5vdXRzLmxlbmd0aCA9IGluSW5kZXggKyAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbkluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0eFRtcC5vdXRzW2ldID0gQkxBTktfT1VUUFVUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHhUbXAuaW5zLmZvckVhY2goKGlucHV0LCB5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IGluSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSkge1xuICAgICAgICAgICAgdHhUbXAuaW5zID0gW3R4VG1wLmluc1tpbkluZGV4XV07XG4gICAgICAgICAgICB0eFRtcC5pbnNbMF0uc2NyaXB0ID0gb3VyU2NyaXB0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHhUbXAuaW5zLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LnNjcmlwdCA9IEVNUFRZX0JVRkZFUjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHhUbXAuaW5zW2luSW5kZXhdLnNjcmlwdCA9IG91clNjcmlwdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodHhUbXAuYnl0ZUxlbmd0aChmYWxzZSkgKyA0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlSW50MzJMRShoYXNoVHlwZSwgYnVmZmVyLmxlbmd0aCAtIDQpO1xuICAgICAgICB0eFRtcC5fX3RvQnVmZmVyKGJ1ZmZlciwgMCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gYmNyeXB0by5oYXNoMjU2KGJ1ZmZlcik7XG4gICAgfVxuICAgIGhhc2hGb3JDYXNoU2lnbmF0dXJlKGluSW5kZXgsIHByZXZPdXRTY3JpcHQsIGluQW1vdW50LCBoYXNoVHlwZSkge1xuICAgICAgICBpZiAoaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX0JJVENPSU5DQVNIQklQMTQzKSB7XG4gICAgICAgICAgICBpZiAodHlwZXMuTnVsbChpbkFtb3VudCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdGNvaW4gQ2FzaCBzaWdoYXNoIHJlcXVpcmVzIHZhbHVlIG9mIGlucHV0IHRvIGJlIHNpZ25lZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2hGb3JXaXRuZXNzVjAoaW5JbmRleCwgcHJldk91dFNjcmlwdCwgaW5BbW91bnQsIGhhc2hUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2hGb3JTaWduYXR1cmUoaW5JbmRleCwgcHJldk91dFNjcmlwdCwgaGFzaFR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc2hGb3JXaXRuZXNzVjEoaW5JbmRleCwgcHJldk91dFNjcmlwdHMsIHZhbHVlcywgaGFzaFR5cGUsIGxlYWZIYXNoLCBhbm5leCkge1xuICAgICAgICB0eXBlZm9yY2UodHlwZXMudHVwbGUodHlwZXMuVUludDMyLCB0eXBlZm9yY2UuYXJyYXlPZih0eXBlcy5CdWZmZXIpLCB0eXBlZm9yY2UuYXJyYXlPZih0eXBlcy5TYXRvc2hpKSwgdHlwZXMuVUludDMyKSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IHRoaXMuaW5zLmxlbmd0aCB8fFxuICAgICAgICAgICAgcHJldk91dFNjcmlwdHMubGVuZ3RoICE9PSB0aGlzLmlucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzdXBwbHkgcHJldm91dCBzY3JpcHQgYW5kIHZhbHVlIGZvciBhbGwgaW5wdXRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0VHlwZSA9IGhhc2hUeXBlID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFRcbiAgICAgICAgICAgID8gVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExcbiAgICAgICAgICAgIDogaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX09VVFBVVF9NQVNLO1xuICAgICAgICBjb25zdCBpbnB1dFR5cGUgPSBoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfSU5QVVRfTUFTSztcbiAgICAgICAgY29uc3QgaXNBbnlvbmVDYW5QYXkgPSBpbnB1dFR5cGUgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZO1xuICAgICAgICBjb25zdCBpc05vbmUgPSBvdXRwdXRUeXBlID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX05PTkU7XG4gICAgICAgIGNvbnN0IGlzU2luZ2xlID0gb3V0cHV0VHlwZSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEU7XG4gICAgICAgIGxldCBoYXNoUHJldm91dHMgPSBFTVBUWV9CVUZGRVI7XG4gICAgICAgIGxldCBoYXNoQW1vdW50cyA9IEVNUFRZX0JVRkZFUjtcbiAgICAgICAgbGV0IGhhc2hTY3JpcHRQdWJLZXlzID0gRU1QVFlfQlVGRkVSO1xuICAgICAgICBsZXQgaGFzaFNlcXVlbmNlcyA9IEVNUFRZX0JVRkZFUjtcbiAgICAgICAgbGV0IGhhc2hPdXRwdXRzID0gRU1QVFlfQlVGRkVSO1xuICAgICAgICBpZiAoIWlzQW55b25lQ2FuUGF5KSB7XG4gICAgICAgICAgICBsZXQgYnVmZmVyV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KDM2ICogdGhpcy5pbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UodHhJbi5oYXNoKTtcbiAgICAgICAgICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodHhJbi5pbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhc2hQcmV2b3V0cyA9IGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSk7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoOCAqIHRoaXMuaW5zLmxlbmd0aCk7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiBidWZmZXJXcml0ZXIud3JpdGVVSW50NjQodmFsdWUpKTtcbiAgICAgICAgICAgIGhhc2hBbW91bnRzID0gYmNyeXB0by5zaGEyNTYoYnVmZmVyV3JpdGVyLmVuZCgpKTtcbiAgICAgICAgICAgIGJ1ZmZlcldyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eShwcmV2T3V0U2NyaXB0cy5tYXAodmFyU2xpY2VTaXplKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSk7XG4gICAgICAgICAgICBwcmV2T3V0U2NyaXB0cy5mb3JFYWNoKHByZXZPdXRTY3JpcHQgPT4gYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2UocHJldk91dFNjcmlwdCkpO1xuICAgICAgICAgICAgaGFzaFNjcmlwdFB1YktleXMgPSBiY3J5cHRvLnNoYTI1NihidWZmZXJXcml0ZXIuZW5kKCkpO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KDQgKiB0aGlzLmlucy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5pbnMuZm9yRWFjaCh0eEluID0+IGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0eEluLnNlcXVlbmNlKSk7XG4gICAgICAgICAgICBoYXNoU2VxdWVuY2VzID0gYmNyeXB0by5zaGEyNTYoYnVmZmVyV3JpdGVyLmVuZCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShpc05vbmUgfHwgaXNTaW5nbGUpKSB7XG4gICAgICAgICAgICBjb25zdCB0eE91dHNTaXplID0gdGhpcy5vdXRzXG4gICAgICAgICAgICAgICAgLm1hcChvdXRwdXQgPT4gOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhICsgYik7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkodHhPdXRzU2l6ZSk7XG4gICAgICAgICAgICB0aGlzLm91dHMuZm9yRWFjaChvdXQgPT4ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NChvdXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKG91dC5zY3JpcHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYXNoT3V0cHV0cyA9IGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTaW5nbGUgJiYgaW5JbmRleCA8IHRoaXMub3V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMub3V0c1tpbkluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcldyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eSg4ICsgdmFyU2xpY2VTaXplKG91dHB1dC5zY3JpcHQpKTtcbiAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NChvdXRwdXQudmFsdWUpO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2Uob3V0cHV0LnNjcmlwdCk7XG4gICAgICAgICAgICBoYXNoT3V0cHV0cyA9IGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BlbmRUeXBlID0gKGxlYWZIYXNoID8gMiA6IDApICsgKGFubmV4ID8gMSA6IDApO1xuICAgICAgICBjb25zdCBzaWdNc2dTaXplID0gMTc0IC1cbiAgICAgICAgICAgIChpc0FueW9uZUNhblBheSA/IDQ5IDogMCkgLVxuICAgICAgICAgICAgKGlzTm9uZSA/IDMyIDogMCkgK1xuICAgICAgICAgICAgKGFubmV4ID8gMzIgOiAwKSArXG4gICAgICAgICAgICAobGVhZkhhc2ggPyAzNyA6IDApO1xuICAgICAgICBjb25zdCBzaWdNc2dXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoc2lnTXNnU2l6ZSk7XG4gICAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQ4KGhhc2hUeXBlKTtcbiAgICAgICAgc2lnTXNnV3JpdGVyLndyaXRlSW50MzIodGhpcy52ZXJzaW9uKTtcbiAgICAgICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDMyKHRoaXMubG9ja3RpbWUpO1xuICAgICAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShoYXNoUHJldm91dHMpO1xuICAgICAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShoYXNoQW1vdW50cyk7XG4gICAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGhhc2hTY3JpcHRQdWJLZXlzKTtcbiAgICAgICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UoaGFzaFNlcXVlbmNlcyk7XG4gICAgICAgIGlmICghKGlzTm9uZSB8fCBpc1NpbmdsZSkpIHtcbiAgICAgICAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGhhc2hPdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50OChzcGVuZFR5cGUpO1xuICAgICAgICBpZiAoaXNBbnlvbmVDYW5QYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnNbaW5JbmRleF07XG4gICAgICAgICAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShpbnB1dC5oYXNoKTtcbiAgICAgICAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQzMihpbnB1dC5pbmRleCk7XG4gICAgICAgICAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50NjQodmFsdWVzW2luSW5kZXhdKTtcbiAgICAgICAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVZhclNsaWNlKHByZXZPdXRTY3JpcHRzW2luSW5kZXhdKTtcbiAgICAgICAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQzMihpbnB1dC5zZXF1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50MzIoaW5JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubmV4KSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkodmFyU2xpY2VTaXplKGFubmV4KSk7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShhbm5leCk7XG4gICAgICAgICAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShiY3J5cHRvLnNoYTI1NihidWZmZXJXcml0ZXIuZW5kKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGhhc2hPdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZkhhc2gpIHtcbiAgICAgICAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGxlYWZIYXNoKTtcbiAgICAgICAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQ4KDApO1xuICAgICAgICAgICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDMyKDB4ZmZmZmZmZmYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiY3J5cHRvLnRhZ2dlZEhhc2goJ1RhcFNpZ2hhc2gnLCBCdWZmZXIuY29uY2F0KFtCdWZmZXIub2YoMHgwMCksIHNpZ01zZ1dyaXRlci5lbmQoKV0pKTtcbiAgICB9XG4gICAgaGFzaEZvcldpdG5lc3NWMChpbkluZGV4LCBwcmV2T3V0U2NyaXB0LCB2YWx1ZSwgaGFzaFR5cGUpIHtcbiAgICAgICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLlVJbnQzMiwgdHlwZXMuQnVmZmVyLCB0eXBlcy5TYXRvc2hpLCB0eXBlcy5VSW50MzIpLCBhcmd1bWVudHMpO1xuICAgICAgICBsZXQgdGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgbGV0IGJ1ZmZlcldyaXRlcjtcbiAgICAgICAgbGV0IGhhc2hPdXRwdXRzID0gWkVSTztcbiAgICAgICAgbGV0IGhhc2hQcmV2b3V0cyA9IFpFUk87XG4gICAgICAgIGxldCBoYXNoU2VxdWVuY2UgPSBaRVJPO1xuICAgICAgICBpZiAoIShoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSkge1xuICAgICAgICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzNiAqIHRoaXMuaW5zLmxlbmd0aCk7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgICAgICAgICB0aGlzLmlucy5mb3JFYWNoKHR4SW4gPT4ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKHR4SW4uaGFzaCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYXNoUHJldm91dHMgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSkgJiZcbiAgICAgICAgICAgIChoYXNoVHlwZSAmIDB4MWYpICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSAmJlxuICAgICAgICAgICAgKGhhc2hUeXBlICYgMHgxZikgIT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORSkge1xuICAgICAgICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICogdGhpcy5pbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIGJ1ZmZlcldyaXRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcih0YnVmZmVyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uc2VxdWVuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYXNoU2VxdWVuY2UgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoVHlwZSAmIDB4MWYpICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSAmJlxuICAgICAgICAgICAgKGhhc2hUeXBlICYgMHgxZikgIT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORSkge1xuICAgICAgICAgICAgY29uc3QgdHhPdXRzU2l6ZSA9IHRoaXMub3V0cy5yZWR1Y2UoKHN1bSwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodHhPdXRzU2l6ZSk7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgICAgICAgICB0aGlzLm91dHMuZm9yRWFjaChvdXQgPT4ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NChvdXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKG91dC5zY3JpcHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYXNoT3V0cHV0cyA9IGJjcnlwdG8uaGFzaDI1Nih0YnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoaGFzaFR5cGUgJiAweDFmKSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgJiZcbiAgICAgICAgICAgIGluSW5kZXggPCB0aGlzLm91dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLm91dHNbaW5JbmRleF07XG4gICAgICAgICAgICB0YnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCkpO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKHRidWZmZXIsIDApO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KG91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShvdXRwdXQuc2NyaXB0KTtcbiAgICAgICAgICAgIGhhc2hPdXRwdXRzID0gYmNyeXB0by5oYXNoMjU2KHRidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTU2ICsgdmFyU2xpY2VTaXplKHByZXZPdXRTY3JpcHQpKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKHRidWZmZXIsIDApO1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5zW2luSW5kZXhdO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVJbnQzMih0aGlzLnZlcnNpb24pO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZShoYXNoUHJldm91dHMpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZShoYXNoU2VxdWVuY2UpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZShpbnB1dC5oYXNoKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKGlucHV0LmluZGV4KTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2UocHJldk91dFNjcmlwdCk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NCh2YWx1ZSk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMihpbnB1dC5zZXF1ZW5jZSk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKGhhc2hPdXRwdXRzKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHRoaXMubG9ja3RpbWUpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIoaGFzaFR5cGUpO1xuICAgICAgICByZXR1cm4gYmNyeXB0by5oYXNoMjU2KHRidWZmZXIpO1xuICAgIH1cbiAgICBnZXRIYXNoKGZvcldpdG5lc3MpIHtcbiAgICAgICAgaWYgKGZvcldpdG5lc3MgJiYgdGhpcy5pc0NvaW5iYXNlKCkpXG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgICAgICAgcmV0dXJuIGJjcnlwdG8uaGFzaDI1Nih0aGlzLl9fdG9CdWZmZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIGZvcldpdG5lc3MpKTtcbiAgICB9XG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiAoMCwgYnVmZmVydXRpbHNfMS5yZXZlcnNlQnVmZmVyKSh0aGlzLmdldEhhc2goZmFsc2UpKS50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIHRvQnVmZmVyKGJ1ZmZlciwgaW5pdGlhbE9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3RvQnVmZmVyKGJ1ZmZlciwgaW5pdGlhbE9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcih1bmRlZmluZWQsIHVuZGVmaW5lZCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICBzZXRJbnB1dFNjcmlwdChpbmRleCwgc2NyaXB0U2lnKSB7XG4gICAgICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5OdW1iZXIsIHR5cGVzLkJ1ZmZlciksIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaW5zW2luZGV4XS5zY3JpcHQgPSBzY3JpcHRTaWc7XG4gICAgfVxuICAgIHNldFdpdG5lc3MoaW5kZXgsIHdpdG5lc3MpIHtcbiAgICAgICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLk51bWJlciwgW3R5cGVzLkJ1ZmZlcl0pLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmluc1tpbmRleF0ud2l0bmVzcyA9IHdpdG5lc3M7XG4gICAgfVxuICAgIF9fdG9CdWZmZXIoYnVmZmVyLCBpbml0aWFsT2Zmc2V0LCBfQUxMT1dfV0lUTkVTUyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghYnVmZmVyKVxuICAgICAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMuYnl0ZUxlbmd0aChfQUxMT1dfV0lUTkVTUykpO1xuICAgICAgICBjb25zdCBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIoYnVmZmVyLCBpbml0aWFsT2Zmc2V0IHx8IDApO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVJbnQzMih0aGlzLnZlcnNpb24pO1xuICAgICAgICBjb25zdCBoYXNXaXRuZXNzZXMgPSBfQUxMT1dfV0lUTkVTUyAmJiB0aGlzLmhhc1dpdG5lc3NlcygpO1xuICAgICAgICBpZiAoaGFzV2l0bmVzc2VzKSB7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50OChUcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9NQVJLRVIpO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDgoVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fRkxBRyk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFySW50KHRoaXMuaW5zLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZSh0eEluLmhhc2gpO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uaW5kZXgpO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2UodHhJbi5zY3JpcHQpO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uc2VxdWVuY2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFySW50KHRoaXMub3V0cy5sZW5ndGgpO1xuICAgICAgICB0aGlzLm91dHMuZm9yRWFjaCh0eE91dCA9PiB7XG4gICAgICAgICAgICBpZiAoaXNPdXRwdXQodHhPdXQpKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KHR4T3V0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKHR4T3V0LnZhbHVlQnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKHR4T3V0LnNjcmlwdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzV2l0bmVzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmlucy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVWZWN0b3IoaW5wdXQud2l0bmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodGhpcy5sb2NrdGltZSk7XG4gICAgICAgIGlmIChpbml0aWFsT2Zmc2V0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGluaXRpYWxPZmZzZXQsIGJ1ZmZlcldyaXRlci5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICBoYXNoRm9yV2l0bmVzcyhpbkluZGV4LCBwcmV2T3V0U2NyaXB0LCB2YWx1ZSwgaGFzaFR5cGUpIHtcbiAgICAgICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLlVJbnQzMiwgdHlwZXMuQnVmZmVyLCB0eXBlcy5TYXRvc2hpLCB0eXBlcy5VSW50MzIpLCBhcmd1bWVudHMpO1xuICAgICAgICBsZXQgdGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgbGV0IGJ1ZmZlcldyaXRlcjtcbiAgICAgICAgbGV0IGhhc2hPdXRwdXRzID0gWkVSTztcbiAgICAgICAgbGV0IGhhc2hQcmV2b3V0cyA9IFpFUk87XG4gICAgICAgIGxldCBoYXNoU2VxdWVuY2UgPSBaRVJPO1xuICAgICAgICBpZiAoIShoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSkge1xuICAgICAgICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzNiAqIHRoaXMuaW5zLmxlbmd0aCk7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgICAgICAgICB0aGlzLmlucy5mb3JFYWNoKHR4SW4gPT4ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKHR4SW4uaGFzaCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYXNoUHJldm91dHMgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSkgJiZcbiAgICAgICAgICAgIChoYXNoVHlwZSAmIDB4MWYpICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSAmJlxuICAgICAgICAgICAgKGhhc2hUeXBlICYgMHgxZikgIT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORSkge1xuICAgICAgICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICogdGhpcy5pbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIGJ1ZmZlcldyaXRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcih0YnVmZmVyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uc2VxdWVuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYXNoU2VxdWVuY2UgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoVHlwZSAmIDB4MWYpICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSAmJlxuICAgICAgICAgICAgKGhhc2hUeXBlICYgMHgxZikgIT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORSkge1xuICAgICAgICAgICAgY29uc3QgdHhPdXRzU2l6ZSA9IHRoaXMub3V0cy5yZWR1Y2UoKHN1bSwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodHhPdXRzU2l6ZSk7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgICAgICAgICB0aGlzLm91dHMuZm9yRWFjaChvdXQgPT4ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NChvdXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKG91dC5zY3JpcHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYXNoT3V0cHV0cyA9IGJjcnlwdG8uaGFzaDI1Nih0YnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoaGFzaFR5cGUgJiAweDFmKSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgJiZcbiAgICAgICAgICAgIGluSW5kZXggPCB0aGlzLm91dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLm91dHNbaW5JbmRleF07XG4gICAgICAgICAgICB0YnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCkpO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKHRidWZmZXIsIDApO1xuICAgICAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KG91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShvdXRwdXQuc2NyaXB0KTtcbiAgICAgICAgICAgIGhhc2hPdXRwdXRzID0gYmNyeXB0by5oYXNoMjU2KHRidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTU2ICsgcHJldk91dFNjcmlwdC5sZW5ndGgpO1xuICAgICAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnNbaW5JbmRleF07XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZUludDMyKHRoaXMudmVyc2lvbik7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKGhhc2hQcmV2b3V0cyk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKGhhc2hTZXF1ZW5jZSk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKGlucHV0Lmhhc2gpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIoaW5wdXQuaW5kZXgpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZShwcmV2T3V0U2NyaXB0KTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KHZhbHVlKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKGlucHV0LnNlcXVlbmNlKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UoaGFzaE91dHB1dHMpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodGhpcy5sb2NrdGltZSk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMihoYXNoVHlwZSk7XG4gICAgICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuVHJhbnNhY3Rpb24uREVGQVVMVF9TRVFVRU5DRSA9IDB4ZmZmZmZmZmY7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQgPSAweDAwO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwgPSAweDAxO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FID0gMHgwMjtcblRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFID0gMHgwMztcblRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZID0gMHg4MDtcblRyYW5zYWN0aW9uLlNJR0hBU0hfT1VUUFVUX01BU0sgPSAweDAzO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9JTlBVVF9NQVNLID0gMHg4MDtcblRyYW5zYWN0aW9uLlNJR0hBU0hfQklUQ09JTkNBU0hCSVAxNDMgPSAweDQwO1xuVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fTUFSS0VSID0gMHgwMDtcblRyYW5zYWN0aW9uLkFEVkFOQ0VEX1RSQU5TQUNUSU9OX0ZMQUcgPSAweDAxO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/transaction.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js':
    /*!************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js ***!
  \************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.oneOf = exports.Null = exports.BufferN = exports.Function = exports.UInt32 = exports.UInt8 = exports.tuple = exports.maybe = exports.Hex = exports.Buffer = exports.String = exports.Boolean = exports.Array = exports.Number = exports.Hash256bit = exports.Hash160bit = exports.Buffer256bit = exports.isTaptree = exports.isTapleaf = exports.TAPLEAF_VERSION_MASK = exports.Satoshi = exports.Signer = exports.BIP32Path = exports.UInt31 = exports.isPoint = exports.typeforce = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nObject.defineProperty(exports, \"typeforce\", ({ enumerable: true, get: function () { return crypto_lib_1.typeforce; } }));\nconst ZERO32 = buffer_1.Buffer.alloc(32, 0);\nconst EC_P = buffer_1.Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex');\nfunction isPoint(p) {\n    if (!buffer_1.Buffer.isBuffer(p))\n        return false;\n    if (p.length < 33)\n        return false;\n    const t = p[0];\n    const x = p.slice(1, 33);\n    if (x.compare(ZERO32) === 0)\n        return false;\n    if (x.compare(EC_P) >= 0)\n        return false;\n    if ((t === 0x02 || t === 0x03) && p.length === 33) {\n        return true;\n    }\n    const y = p.slice(33);\n    if (y.compare(ZERO32) === 0)\n        return false;\n    if (y.compare(EC_P) >= 0)\n        return false;\n    if (t === 0x04 && p.length === 65)\n        return true;\n    return false;\n}\nexports.isPoint = isPoint;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction UInt31(value) {\n    return crypto_lib_1.typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nexports.UInt31 = UInt31;\nfunction BIP32Path(value) {\n    return crypto_lib_1.typeforce.String(value) && !!value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/);\n}\nexports.BIP32Path = BIP32Path;\nBIP32Path.toJSON = () => {\n    return 'BIP32 derivation path';\n};\nfunction Signer(obj) {\n    return ((crypto_lib_1.typeforce.Buffer(obj.publicKey) ||\n        typeof obj.getPublicKey === 'function') &&\n        typeof obj.sign === 'function');\n}\nexports.Signer = Signer;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n    return crypto_lib_1.typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\nexports.TAPLEAF_VERSION_MASK = 0xfe;\nfunction isTapleaf(o) {\n    if (!o || !('output' in o))\n        return false;\n    if (!buffer_1.Buffer.isBuffer(o.output))\n        return false;\n    if (o.version !== undefined)\n        return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;\n    return true;\n}\nexports.isTapleaf = isTapleaf;\nfunction isTaptree(scriptTree) {\n    if (!(0, exports.Array)(scriptTree))\n        return isTapleaf(scriptTree);\n    if (scriptTree.length !== 2)\n        return false;\n    return scriptTree.every((t) => isTaptree(t));\n}\nexports.isTaptree = isTaptree;\nexports.Buffer256bit = crypto_lib_1.typeforce.BufferN(32);\nexports.Hash160bit = crypto_lib_1.typeforce.BufferN(20);\nexports.Hash256bit = crypto_lib_1.typeforce.BufferN(32);\nexports.Number = crypto_lib_1.typeforce.Number;\nexports.Array = crypto_lib_1.typeforce.Array;\nexports.Boolean = crypto_lib_1.typeforce.Boolean;\nexports.String = crypto_lib_1.typeforce.String;\nexports.Buffer = crypto_lib_1.typeforce.Buffer;\nexports.Hex = crypto_lib_1.typeforce.Hex;\nexports.maybe = crypto_lib_1.typeforce.maybe;\nexports.tuple = crypto_lib_1.typeforce.tuple;\nexports.UInt8 = crypto_lib_1.typeforce.UInt8;\nexports.UInt32 = crypto_lib_1.typeforce.UInt32;\nexports.Function = crypto_lib_1.typeforce.Function;\nexports.BufferN = crypto_lib_1.typeforce.BufferN;\nexports.Null = crypto_lib_1.typeforce.Null;\nexports.oneOf = crypto_lib_1.typeforce.oneOf;\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsNEJBQTRCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGlCQUFpQjtBQUMzZCxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQsNkNBQTRDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGFBQWE7QUFDYixlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWM7QUFDZCxXQUFXO0FBQ1gsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsWUFBWTtBQUNaLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2JpdGNvaW5qcy1saWIvdHlwZXMuanM/ZWM5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub25lT2YgPSBleHBvcnRzLk51bGwgPSBleHBvcnRzLkJ1ZmZlck4gPSBleHBvcnRzLkZ1bmN0aW9uID0gZXhwb3J0cy5VSW50MzIgPSBleHBvcnRzLlVJbnQ4ID0gZXhwb3J0cy50dXBsZSA9IGV4cG9ydHMubWF5YmUgPSBleHBvcnRzLkhleCA9IGV4cG9ydHMuQnVmZmVyID0gZXhwb3J0cy5TdHJpbmcgPSBleHBvcnRzLkJvb2xlYW4gPSBleHBvcnRzLkFycmF5ID0gZXhwb3J0cy5OdW1iZXIgPSBleHBvcnRzLkhhc2gyNTZiaXQgPSBleHBvcnRzLkhhc2gxNjBiaXQgPSBleHBvcnRzLkJ1ZmZlcjI1NmJpdCA9IGV4cG9ydHMuaXNUYXB0cmVlID0gZXhwb3J0cy5pc1RhcGxlYWYgPSBleHBvcnRzLlRBUExFQUZfVkVSU0lPTl9NQVNLID0gZXhwb3J0cy5TYXRvc2hpID0gZXhwb3J0cy5TaWduZXIgPSBleHBvcnRzLkJJUDMyUGF0aCA9IGV4cG9ydHMuVUludDMxID0gZXhwb3J0cy5pc1BvaW50ID0gZXhwb3J0cy50eXBlZm9yY2UgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInR5cGVmb3JjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3J5cHRvX2xpYl8xLnR5cGVmb3JjZTsgfSB9KTtcbmNvbnN0IFpFUk8zMiA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygzMiwgMCk7XG5jb25zdCBFQ19QID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnLCAnaGV4Jyk7XG5mdW5jdGlvbiBpc1BvaW50KHApIHtcbiAgICBpZiAoIWJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihwKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwLmxlbmd0aCA8IDMzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgdCA9IHBbMF07XG4gICAgY29uc3QgeCA9IHAuc2xpY2UoMSwgMzMpO1xuICAgIGlmICh4LmNvbXBhcmUoWkVSTzMyKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh4LmNvbXBhcmUoRUNfUCkgPj0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgodCA9PT0gMHgwMiB8fCB0ID09PSAweDAzKSAmJiBwLmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHkgPSBwLnNsaWNlKDMzKTtcbiAgICBpZiAoeS5jb21wYXJlKFpFUk8zMikgPT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoeS5jb21wYXJlKEVDX1ApID49IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodCA9PT0gMHgwNCAmJiBwLmxlbmd0aCA9PT0gNjUpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNQb2ludCA9IGlzUG9pbnQ7XG5jb25zdCBVSU5UMzFfTUFYID0gTWF0aC5wb3coMiwgMzEpIC0gMTtcbmZ1bmN0aW9uIFVJbnQzMSh2YWx1ZSkge1xuICAgIHJldHVybiBjcnlwdG9fbGliXzEudHlwZWZvcmNlLlVJbnQzMih2YWx1ZSkgJiYgdmFsdWUgPD0gVUlOVDMxX01BWDtcbn1cbmV4cG9ydHMuVUludDMxID0gVUludDMxO1xuZnVuY3Rpb24gQklQMzJQYXRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyeXB0b19saWJfMS50eXBlZm9yY2UuU3RyaW5nKHZhbHVlKSAmJiAhIXZhbHVlLm1hdGNoKC9eKG1cXC8pPyhcXGQrJz9cXC8pKlxcZCsnPyQvKTtcbn1cbmV4cG9ydHMuQklQMzJQYXRoID0gQklQMzJQYXRoO1xuQklQMzJQYXRoLnRvSlNPTiA9ICgpID0+IHtcbiAgICByZXR1cm4gJ0JJUDMyIGRlcml2YXRpb24gcGF0aCc7XG59O1xuZnVuY3Rpb24gU2lnbmVyKG9iaikge1xuICAgIHJldHVybiAoKGNyeXB0b19saWJfMS50eXBlZm9yY2UuQnVmZmVyKG9iai5wdWJsaWNLZXkpIHx8XG4gICAgICAgIHR5cGVvZiBvYmouZ2V0UHVibGljS2V5ID09PSAnZnVuY3Rpb24nKSAmJlxuICAgICAgICB0eXBlb2Ygb2JqLnNpZ24gPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5TaWduZXIgPSBTaWduZXI7XG5jb25zdCBTQVRPU0hJX01BWCA9IDIxICogMWUxNDtcbmZ1bmN0aW9uIFNhdG9zaGkodmFsdWUpIHtcbiAgICByZXR1cm4gY3J5cHRvX2xpYl8xLnR5cGVmb3JjZS5VSW50NTModmFsdWUpICYmIHZhbHVlIDw9IFNBVE9TSElfTUFYO1xufVxuZXhwb3J0cy5TYXRvc2hpID0gU2F0b3NoaTtcbmV4cG9ydHMuVEFQTEVBRl9WRVJTSU9OX01BU0sgPSAweGZlO1xuZnVuY3Rpb24gaXNUYXBsZWFmKG8pIHtcbiAgICBpZiAoIW8gfHwgISgnb3V0cHV0JyBpbiBvKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKG8ub3V0cHV0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChvLnZlcnNpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIChvLnZlcnNpb24gJiBleHBvcnRzLlRBUExFQUZfVkVSU0lPTl9NQVNLKSA9PT0gby52ZXJzaW9uO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc1RhcGxlYWYgPSBpc1RhcGxlYWY7XG5mdW5jdGlvbiBpc1RhcHRyZWUoc2NyaXB0VHJlZSkge1xuICAgIGlmICghKDAsIGV4cG9ydHMuQXJyYXkpKHNjcmlwdFRyZWUpKVxuICAgICAgICByZXR1cm4gaXNUYXBsZWFmKHNjcmlwdFRyZWUpO1xuICAgIGlmIChzY3JpcHRUcmVlLmxlbmd0aCAhPT0gMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBzY3JpcHRUcmVlLmV2ZXJ5KCh0KSA9PiBpc1RhcHRyZWUodCkpO1xufVxuZXhwb3J0cy5pc1RhcHRyZWUgPSBpc1RhcHRyZWU7XG5leHBvcnRzLkJ1ZmZlcjI1NmJpdCA9IGNyeXB0b19saWJfMS50eXBlZm9yY2UuQnVmZmVyTigzMik7XG5leHBvcnRzLkhhc2gxNjBiaXQgPSBjcnlwdG9fbGliXzEudHlwZWZvcmNlLkJ1ZmZlck4oMjApO1xuZXhwb3J0cy5IYXNoMjU2Yml0ID0gY3J5cHRvX2xpYl8xLnR5cGVmb3JjZS5CdWZmZXJOKDMyKTtcbmV4cG9ydHMuTnVtYmVyID0gY3J5cHRvX2xpYl8xLnR5cGVmb3JjZS5OdW1iZXI7XG5leHBvcnRzLkFycmF5ID0gY3J5cHRvX2xpYl8xLnR5cGVmb3JjZS5BcnJheTtcbmV4cG9ydHMuQm9vbGVhbiA9IGNyeXB0b19saWJfMS50eXBlZm9yY2UuQm9vbGVhbjtcbmV4cG9ydHMuU3RyaW5nID0gY3J5cHRvX2xpYl8xLnR5cGVmb3JjZS5TdHJpbmc7XG5leHBvcnRzLkJ1ZmZlciA9IGNyeXB0b19saWJfMS50eXBlZm9yY2UuQnVmZmVyO1xuZXhwb3J0cy5IZXggPSBjcnlwdG9fbGliXzEudHlwZWZvcmNlLkhleDtcbmV4cG9ydHMubWF5YmUgPSBjcnlwdG9fbGliXzEudHlwZWZvcmNlLm1heWJlO1xuZXhwb3J0cy50dXBsZSA9IGNyeXB0b19saWJfMS50eXBlZm9yY2UudHVwbGU7XG5leHBvcnRzLlVJbnQ4ID0gY3J5cHRvX2xpYl8xLnR5cGVmb3JjZS5VSW50ODtcbmV4cG9ydHMuVUludDMyID0gY3J5cHRvX2xpYl8xLnR5cGVmb3JjZS5VSW50MzI7XG5leHBvcnRzLkZ1bmN0aW9uID0gY3J5cHRvX2xpYl8xLnR5cGVmb3JjZS5GdW5jdGlvbjtcbmV4cG9ydHMuQnVmZmVyTiA9IGNyeXB0b19saWJfMS50eXBlZm9yY2UuQnVmZmVyTjtcbmV4cG9ydHMuTnVsbCA9IGNyeXB0b19saWJfMS50eXBlZm9yY2UuTnVsbDtcbmV4cG9ydHMub25lT2YgPSBjcnlwdG9fbGliXzEudHlwZWZvcmNlLm9uZU9mO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/types.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/varuint.js':
    /*!**************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/varuint.js ***!
  \**************************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer);\nvar MAX_SAFE_INTEGER = 9007199254740991;\nfunction checkUInt53(n) {\n    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)\n        throw new RangeError('value out of range');\n}\nfunction encode(number, buffer, offset) {\n    checkUInt53(number);\n    if (!buffer)\n        buffer = Buffer.allocUnsafe(encodingLength(number));\n    if (!Buffer.isBuffer(buffer))\n        throw new TypeError('buffer must be a Buffer instance');\n    if (!offset)\n        offset = 0;\n    if (number < 0xfd) {\n        buffer.writeUInt8(number, offset);\n        encode.bytes = 1;\n    }\n    else if (number <= 0xffff) {\n        buffer.writeUInt8(0xfd, offset);\n        buffer.writeUInt16LE(number, offset + 1);\n        encode.bytes = 3;\n    }\n    else if (number <= 0xffffffff) {\n        buffer.writeUInt8(0xfe, offset);\n        buffer.writeUInt32LE(number, offset + 1);\n        encode.bytes = 5;\n    }\n    else {\n        buffer.writeUInt8(0xff, offset);\n        buffer.writeUInt32LE(number >>> 0, offset + 1);\n        buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5);\n        encode.bytes = 9;\n    }\n    return buffer;\n}\nfunction decode(buffer, offset) {\n    if (!Buffer.isBuffer(buffer))\n        throw new TypeError('buffer must be a Buffer instance');\n    if (!offset)\n        offset = 0;\n    var first = buffer.readUInt8(offset);\n    if (first < 0xfd) {\n        decode.bytes = 1;\n        return first;\n    }\n    else if (first === 0xfd) {\n        decode.bytes = 3;\n        return buffer.readUInt16LE(offset + 1);\n    }\n    else if (first === 0xfe) {\n        decode.bytes = 5;\n        return buffer.readUInt32LE(offset + 1);\n    }\n    else {\n        decode.bytes = 9;\n        var lo = buffer.readUInt32LE(offset + 1);\n        var hi = buffer.readUInt32LE(offset + 5);\n        var number = hi * 0x0100000000 + lo;\n        checkUInt53(number);\n        return number;\n    }\n}\nfunction encodingLength(number) {\n    checkUInt53(number);\n    return (number < 0xfd ? 1\n        : number <= 0xffff ? 3\n            : number <= 0xffffffff ? 5\n                : 9);\n}\nmodule.exports = { encode: encode, decode: decode, encodingLength: encodingLength };\n//# sourceMappingURL=varuint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi92YXJ1aW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSw0RkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvYml0Y29pbmpzLWxpYi92YXJ1aW50LmpzPzEyZmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuZnVuY3Rpb24gY2hlY2tVSW50NTMobikge1xuICAgIGlmIChuIDwgMCB8fCBuID4gTUFYX1NBRkVfSU5URUdFUiB8fCBuICUgMSAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIG91dCBvZiByYW5nZScpO1xufVxuZnVuY3Rpb24gZW5jb2RlKG51bWJlciwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBjaGVja1VJbnQ1MyhudW1iZXIpO1xuICAgIGlmICghYnVmZmVyKVxuICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgobnVtYmVyKSk7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtcbiAgICBpZiAoIW9mZnNldClcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICBpZiAobnVtYmVyIDwgMHhmZCkge1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OChudW1iZXIsIG9mZnNldCk7XG4gICAgICAgIGVuY29kZS5ieXRlcyA9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKG51bWJlciA8PSAweGZmZmYpIHtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgoMHhmZCwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDE2TEUobnVtYmVyLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgZW5jb2RlLmJ5dGVzID0gMztcbiAgICB9XG4gICAgZWxzZSBpZiAobnVtYmVyIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgoMHhmZSwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUobnVtYmVyLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgZW5jb2RlLmJ5dGVzID0gNTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKG51bWJlciA+Pj4gMCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKChudW1iZXIgLyAweDEwMDAwMDAwMCkgfCAwLCBvZmZzZXQgKyA1KTtcbiAgICAgICAgZW5jb2RlLmJ5dGVzID0gOTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGRlY29kZShidWZmZXIsIG9mZnNldCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gICAgaWYgKCFvZmZzZXQpXG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgdmFyIGZpcnN0ID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIGlmIChmaXJzdCA8IDB4ZmQpIHtcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gMTtcbiAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdCA9PT0gMHhmZCkge1xuICAgICAgICBkZWNvZGUuYnl0ZXMgPSAzO1xuICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MTZMRShvZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3QgPT09IDB4ZmUpIHtcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gNTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWNvZGUuYnl0ZXMgPSA5O1xuICAgICAgICB2YXIgbG8gPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDEpO1xuICAgICAgICB2YXIgaGkgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDUpO1xuICAgICAgICB2YXIgbnVtYmVyID0gaGkgKiAweDAxMDAwMDAwMDAgKyBsbztcbiAgICAgICAgY2hlY2tVSW50NTMobnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmNvZGluZ0xlbmd0aChudW1iZXIpIHtcbiAgICBjaGVja1VJbnQ1MyhudW1iZXIpO1xuICAgIHJldHVybiAobnVtYmVyIDwgMHhmZCA/IDFcbiAgICAgICAgOiBudW1iZXIgPD0gMHhmZmZmID8gM1xuICAgICAgICAgICAgOiBudW1iZXIgPD0gMHhmZmZmZmZmZiA/IDVcbiAgICAgICAgICAgICAgICA6IDkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7IGVuY29kZTogZW5jb2RlLCBkZWNvZGU6IGRlY29kZSwgZW5jb2RpbmdMZW5ndGg6IGVuY29kaW5nTGVuZ3RoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YXJ1aW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/varuint.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/common.js':
    /*!***********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/common.js ***!
  \***********************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BtcXrcTypes = void 0;\nvar BtcXrcTypes;\n(function (BtcXrcTypes) {\n    BtcXrcTypes[BtcXrcTypes["INSCRIBE"] = 1] = "INSCRIBE";\n    BtcXrcTypes[BtcXrcTypes["PSBT"] = 2] = "PSBT";\n    BtcXrcTypes[BtcXrcTypes["PSBT_MPC_UNSIGNED_LIST"] = 21] = "PSBT_MPC_UNSIGNED_LIST";\n    BtcXrcTypes[BtcXrcTypes["PSBT_MPC_SIGNED_LIST"] = 22] = "PSBT_MPC_SIGNED_LIST";\n    BtcXrcTypes[BtcXrcTypes["PSBT_MPC_UNSIGNED_BUY"] = 23] = "PSBT_MPC_UNSIGNED_BUY";\n    BtcXrcTypes[BtcXrcTypes["PSBT_MPC_SIGNED_BUY"] = 24] = "PSBT_MPC_SIGNED_BUY";\n    BtcXrcTypes[BtcXrcTypes["PSBT_MPC_UNSIGNED"] = 25] = "PSBT_MPC_UNSIGNED";\n    BtcXrcTypes[BtcXrcTypes["PSBT_MPC_SIGNED"] = 26] = "PSBT_MPC_SIGNED";\n    BtcXrcTypes[BtcXrcTypes["PSBT_RUNEMAIN"] = 27] = "PSBT_RUNEMAIN";\n    BtcXrcTypes[BtcXrcTypes["PSBT_KEY_SCRIPT_PATH"] = 3] = "PSBT_KEY_SCRIPT_PATH";\n    BtcXrcTypes[BtcXrcTypes["PSBT_KEY_SCRIPT_PATH_BATCH"] = 4] = "PSBT_KEY_SCRIPT_PATH_BATCH";\n    BtcXrcTypes[BtcXrcTypes["SRC20"] = 101] = "SRC20";\n    BtcXrcTypes[BtcXrcTypes["RUNE"] = 102] = "RUNE";\n    BtcXrcTypes[BtcXrcTypes["RUNEMAIN"] = 103] = "RUNEMAIN";\n    BtcXrcTypes[BtcXrcTypes["PSBT_DEODE"] = 104] = "PSBT_DEODE";\n    BtcXrcTypes[BtcXrcTypes["ARC20"] = 114] = "ARC20";\n})(BtcXrcTypes = exports.BtcXrcTypes || (exports.BtcXrcTypes = {}));\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QyxtQkFBbUIsS0FBSztBQUNqRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L2NvbW1vbi5qcz80YTk2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdGNYcmNUeXBlcyA9IHZvaWQgMDtcbnZhciBCdGNYcmNUeXBlcztcbihmdW5jdGlvbiAoQnRjWHJjVHlwZXMpIHtcbiAgICBCdGNYcmNUeXBlc1tCdGNYcmNUeXBlc1tcIklOU0NSSUJFXCJdID0gMV0gPSBcIklOU0NSSUJFXCI7XG4gICAgQnRjWHJjVHlwZXNbQnRjWHJjVHlwZXNbXCJQU0JUXCJdID0gMl0gPSBcIlBTQlRcIjtcbiAgICBCdGNYcmNUeXBlc1tCdGNYcmNUeXBlc1tcIlBTQlRfTVBDX1VOU0lHTkVEX0xJU1RcIl0gPSAyMV0gPSBcIlBTQlRfTVBDX1VOU0lHTkVEX0xJU1RcIjtcbiAgICBCdGNYcmNUeXBlc1tCdGNYcmNUeXBlc1tcIlBTQlRfTVBDX1NJR05FRF9MSVNUXCJdID0gMjJdID0gXCJQU0JUX01QQ19TSUdORURfTElTVFwiO1xuICAgIEJ0Y1hyY1R5cGVzW0J0Y1hyY1R5cGVzW1wiUFNCVF9NUENfVU5TSUdORURfQlVZXCJdID0gMjNdID0gXCJQU0JUX01QQ19VTlNJR05FRF9CVVlcIjtcbiAgICBCdGNYcmNUeXBlc1tCdGNYcmNUeXBlc1tcIlBTQlRfTVBDX1NJR05FRF9CVVlcIl0gPSAyNF0gPSBcIlBTQlRfTVBDX1NJR05FRF9CVVlcIjtcbiAgICBCdGNYcmNUeXBlc1tCdGNYcmNUeXBlc1tcIlBTQlRfTVBDX1VOU0lHTkVEXCJdID0gMjVdID0gXCJQU0JUX01QQ19VTlNJR05FRFwiO1xuICAgIEJ0Y1hyY1R5cGVzW0J0Y1hyY1R5cGVzW1wiUFNCVF9NUENfU0lHTkVEXCJdID0gMjZdID0gXCJQU0JUX01QQ19TSUdORURcIjtcbiAgICBCdGNYcmNUeXBlc1tCdGNYcmNUeXBlc1tcIlBTQlRfUlVORU1BSU5cIl0gPSAyN10gPSBcIlBTQlRfUlVORU1BSU5cIjtcbiAgICBCdGNYcmNUeXBlc1tCdGNYcmNUeXBlc1tcIlBTQlRfS0VZX1NDUklQVF9QQVRIXCJdID0gM10gPSBcIlBTQlRfS0VZX1NDUklQVF9QQVRIXCI7XG4gICAgQnRjWHJjVHlwZXNbQnRjWHJjVHlwZXNbXCJQU0JUX0tFWV9TQ1JJUFRfUEFUSF9CQVRDSFwiXSA9IDRdID0gXCJQU0JUX0tFWV9TQ1JJUFRfUEFUSF9CQVRDSFwiO1xuICAgIEJ0Y1hyY1R5cGVzW0J0Y1hyY1R5cGVzW1wiU1JDMjBcIl0gPSAxMDFdID0gXCJTUkMyMFwiO1xuICAgIEJ0Y1hyY1R5cGVzW0J0Y1hyY1R5cGVzW1wiUlVORVwiXSA9IDEwMl0gPSBcIlJVTkVcIjtcbiAgICBCdGNYcmNUeXBlc1tCdGNYcmNUeXBlc1tcIlJVTkVNQUlOXCJdID0gMTAzXSA9IFwiUlVORU1BSU5cIjtcbiAgICBCdGNYcmNUeXBlc1tCdGNYcmNUeXBlc1tcIlBTQlRfREVPREVcIl0gPSAxMDRdID0gXCJQU0JUX0RFT0RFXCI7XG4gICAgQnRjWHJjVHlwZXNbQnRjWHJjVHlwZXNbXCJBUkMyMFwiXSA9IDExNF0gPSBcIkFSQzIwXCI7XG59KShCdGNYcmNUeXBlcyA9IGV4cG9ydHMuQnRjWHJjVHlwZXMgfHwgKGV4cG9ydHMuQnRjWHJjVHlwZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/common.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/doginals.js':
    /*!*************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/doginals.js ***!
  \*************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.dogInscribe = exports.DogInscriptionTool = exports.DogScript = exports.bufferToChunk = exports.bufferToBuffer = exports.CHANGE_OUTPUT_MAX_SIZE = void 0;\nconst bitcoin = __importStar(__webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js"));\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst bcrypto = __importStar(__webpack_require__(/*! ./bitcoinjs-lib/crypto */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js"));\nconst txBuild_1 = __webpack_require__(/*! ./txBuild */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js");\nconst bitcoinjs_lib_1 = __webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js");\nconst ops_1 = __webpack_require__(/*! ./bitcoinjs-lib/ops */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/ops.js");\nconst payments = __importStar(__webpack_require__(/*! ./bitcoinjs-lib/payments */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/payments/index.js"));\nconst bufferutils_1 = __webpack_require__(/*! ./bitcoinjs-lib/bufferutils */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js");\nexports.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;\nconst defaultTxVersion = 2;\nconst defaultSequenceNum = 0xfffffffd;\nconst defaultRevealOutValue = 100000;\nconst defaultMinChangeValue = 100000;\nconst MAX_CHUNK_LEN = 240;\nconst MAX_PAYLOAD_LEN = 1500;\nfunction numberToChunk(n) {\n    return {\n        buf: n <= 16 ? undefined : n < 128 ? Buffer.from([n]) : Buffer.from([n % 256, n / 256]),\n        len: n <= 16 ? 0 : n < 128 ? 1 : 2,\n        opcodenum: n == 0 ? 0 : n <= 16 ? 80 + n : n < 128 ? 1 : 2\n    };\n}\nfunction bufferToBuffer(b) {\n    let c = bufferToChunk(b);\n    let size = bufferutils_1.varuint.encodingLength(c.opcodenum);\n    var opcodenum = c.opcodenum;\n    if (c.buf) {\n        if (opcodenum === ops_1.OPS.OP_PUSHDATA1) {\n            size += bufferutils_1.varuint.encodingLength(c.len);\n        }\n        else if (opcodenum === ops_1.OPS.OP_PUSHDATA2) {\n            size += bufferutils_1.varuint.encodingLength(c.len);\n        }\n        else if (opcodenum === ops_1.OPS.OP_PUSHDATA4) {\n            size += bufferutils_1.varuint.encodingLength(c.len);\n        }\n        size += c.buf.length;\n    }\n    let bw = bitcoinjs_lib_1.BufferWriter.withCapacity(size);\n    bw.writeUInt8(c.opcodenum);\n    if (c.buf) {\n        if (opcodenum < ops_1.OPS.OP_PUSHDATA1) {\n            bw.writeSlice(c.buf);\n        }\n        else if (opcodenum === ops_1.OPS.OP_PUSHDATA1) {\n            bw.writeUInt8(c.len);\n            bw.writeSlice(c.buf);\n        }\n        else if (opcodenum === ops_1.OPS.OP_PUSHDATA2) {\n            bw.writeUInt64(c.len);\n            bw.writeSlice(c.buf);\n        }\n        else if (opcodenum === ops_1.OPS.OP_PUSHDATA4) {\n            bw.writeUInt32(c.len);\n            bw.writeSlice(c.buf);\n        }\n    }\n    return bw.end();\n}\nexports.bufferToBuffer = bufferToBuffer;\nfunction bufferToChunk(b) {\n    return {\n        buf: b.length ? b : undefined,\n        len: b.length,\n        opcodenum: b.length <= 75 ? b.length : b.length <= 255 ? 76 : 77\n    };\n}\nexports.bufferToChunk = bufferToChunk;\nfunction opcodeToChunk(op) {\n    return { opcodenum: op };\n}\nclass DogScript {\n    constructor() {\n        this.chunks = [];\n    }\n    total() {\n        if (this.chunks.length == 0) {\n            return 0;\n        }\n        const size = this.chunks\n            .map(chunk => {\n            let size = bufferutils_1.varuint.encodingLength(chunk.opcodenum);\n            var opcodenum = chunk.opcodenum;\n            if (chunk.buf) {\n                if (opcodenum < ops_1.OPS.OP_PUSHDATA1) {\n                }\n                else if (opcodenum === ops_1.OPS.OP_PUSHDATA1) {\n                    size += bufferutils_1.varuint.encodingLength(chunk.len);\n                }\n                else if (opcodenum === ops_1.OPS.OP_PUSHDATA2) {\n                    size += bufferutils_1.varuint.encodingLength(chunk.len);\n                }\n                else if (opcodenum === ops_1.OPS.OP_PUSHDATA4) {\n                    size += bufferutils_1.varuint.encodingLength(chunk.len);\n                }\n                size += chunk.buf.length;\n            }\n            return size;\n        })\n            .reduce((a, b) => a + b);\n        return size;\n    }\n    toBuffer() {\n        let total = this.total();\n        let bw = bitcoinjs_lib_1.BufferWriter.withCapacity(total);\n        for (var i = 0; i < this.chunks.length; i++) {\n            var chunk = this.chunks[i];\n            var opcodenum = chunk.opcodenum;\n            bw.writeUInt8(chunk.opcodenum);\n            if (chunk.buf) {\n                if (opcodenum < ops_1.OPS.OP_PUSHDATA1) {\n                    bw.writeSlice(chunk.buf);\n                }\n                else if (opcodenum === ops_1.OPS.OP_PUSHDATA1) {\n                    bw.writeUInt8(chunk.len);\n                    bw.writeSlice(chunk.buf);\n                }\n                else if (opcodenum === ops_1.OPS.OP_PUSHDATA2) {\n                    bw.writeUInt64(chunk.len);\n                    bw.writeSlice(chunk.buf);\n                }\n                else if (opcodenum === ops_1.OPS.OP_PUSHDATA4) {\n                    bw.writeUInt32(chunk.len);\n                    bw.writeSlice(chunk.buf);\n                }\n            }\n        }\n        return bw.end();\n    }\n}\nexports.DogScript = DogScript;\nclass DogInscriptionTool {\n    constructor() {\n        this.network = bitcoin.networks.bitcoin;\n        this.inscriptionTxCtxDataList = [];\n        this.revealTxs = [];\n        this.commitTx = new bitcoin.Transaction();\n        this.commitTxPrevOutputFetcher = [];\n        this.revealTxPrevOutputFetcher = [];\n        this.mustCommitTxFee = 0;\n        this.mustRevealTxFees = [];\n        this.commitAddrs = [];\n        this.fromAddr = \'\';\n        this.revealAddr = \'\';\n    }\n    static newDogInscriptionTool(network, request) {\n        const tool = new DogInscriptionTool();\n        tool.network = network;\n        const revealOutValue = request.revealOutValue || defaultRevealOutValue;\n        const minChangeValue = request.minChangeValue || defaultMinChangeValue;\n        const privateKey = request.commitTxPrevOutputList[0].privateKey;\n        tool.inscriptionTxCtxDataList = createInscriptionTxCtxData(network, request.inscriptionData, privateKey);\n        tool.revealAddr = request.inscriptionData.revealAddr;\n        const privateKeyHex = crypto_lib_1.base.toHex(crypto_lib_1.base.fromHex((0, txBuild_1.privateKeyFromWIF)(privateKey, network)));\n        const publicKey = (0, txBuild_1.private2public)(privateKeyHex);\n        tool.fromAddr = bitcoin.payments.p2pkh({ pubkey: publicKey, network: network }).address;\n        const totalRevealPrevOutputValue = tool.buildEmptyRevealTxs(network, revealOutValue, request.revealFeeRate);\n        const insufficient = tool.buildCommitTx(network, request.commitTxPrevOutputList, request.changeAddress, totalRevealPrevOutputValue, revealOutValue, request.commitFeeRate, minChangeValue);\n        if (insufficient) {\n            return tool;\n        }\n        tool.signCommitTx(request.commitTxPrevOutputList);\n        tool.completeRevealTx();\n        return tool;\n    }\n    buildEmptyRevealTxs(network, revealOutValue, revealFeeRate) {\n        let totalPrevOutputValue = 0;\n        const revealTxs = [];\n        const mustRevealTxFees = [];\n        const commitAddrs = [];\n        let left = 0;\n        for (let i = this.inscriptionTxCtxDataList.length - 1; i > -1; i--) {\n            let inscriptionTxCtxData = this.inscriptionTxCtxDataList[i];\n            const tx = new bitcoin.Transaction();\n            tx.version = defaultTxVersion;\n            tx.addInput(Buffer.alloc(32), 0, defaultSequenceNum);\n            tx.addInput(Buffer.alloc(32), 1, defaultSequenceNum);\n            tx.addOutput(i != this.inscriptionTxCtxDataList.length - 1 ? inscriptionTxCtxData.commitTxAddressPkScript : inscriptionTxCtxData.revealPkScript, revealOutValue);\n            const emptySignature = Buffer.alloc(72);\n            let unlock = Buffer.concat([inscriptionTxCtxData.inscriptionScript, bufferToBuffer(emptySignature), bufferToBuffer(inscriptionTxCtxData.redeemScript)]);\n            tx.ins[0].script = unlock;\n            if (i != this.inscriptionTxCtxDataList.length - 1) {\n                tx.addOutput(bitcoin.address.toOutputScript(this.fromAddr, network), left);\n            }\n            tx.ins[1].script = Buffer.alloc(106);\n            const fee = Math.floor((tx.dogeByteLength() + exports.CHANGE_OUTPUT_MAX_SIZE) * revealFeeRate);\n            left += fee;\n            const prevOutputValue = fee;\n            inscriptionTxCtxData.revealTxPrevOutput = {\n                pkScript: inscriptionTxCtxData.commitTxAddressPkScript,\n                value: prevOutputValue,\n            };\n            totalPrevOutputValue += prevOutputValue;\n            revealTxs.push(tx);\n            mustRevealTxFees.push(fee);\n            commitAddrs.push(inscriptionTxCtxData.commitTxAddress);\n        }\n        for (let i = 0, j = revealTxs.length - 1; i < j; i++, j--) {\n            [revealTxs[i], revealTxs[j]] = [revealTxs[j], revealTxs[i]];\n            [mustRevealTxFees[i], mustRevealTxFees[j]] = [mustRevealTxFees[j], mustRevealTxFees[i]];\n            [commitAddrs[i], commitAddrs[j]] = [commitAddrs[j], commitAddrs[i]];\n        }\n        this.revealTxs = revealTxs;\n        this.mustRevealTxFees = mustRevealTxFees;\n        this.commitAddrs = commitAddrs;\n        totalPrevOutputValue += revealOutValue;\n        return totalPrevOutputValue;\n    }\n    buildCommitTx(network, commitTxPrevOutputList, changeAddress, totalRevealPrevOutputValue, revealOutValue, commitFeeRate, minChangeValue) {\n        let totalSenderAmount = 0;\n        const tx = new bitcoin.Transaction();\n        tx.version = defaultTxVersion;\n        commitTxPrevOutputList.forEach(commitTxPrevOutput => {\n            const hash = crypto_lib_1.base.reverseBuffer(crypto_lib_1.base.fromHex(commitTxPrevOutput.txId));\n            tx.addInput(hash, commitTxPrevOutput.vOut, defaultSequenceNum);\n            this.commitTxPrevOutputFetcher.push(commitTxPrevOutput.amount);\n            totalSenderAmount += commitTxPrevOutput.amount;\n        });\n        tx.addOutput(this.inscriptionTxCtxDataList[0].revealTxPrevOutput.pkScript, revealOutValue);\n        tx.addOutput(bitcoin.address.toOutputScript(this.fromAddr, network), totalRevealPrevOutputValue);\n        const changePkScript = bitcoin.address.toOutputScript(changeAddress, network);\n        tx.addOutput(changePkScript, 0);\n        const txForEstimate = tx.clone();\n        signTx(txForEstimate, commitTxPrevOutputList, this.network);\n        const fee = Math.floor((txForEstimate.dogeByteLength() + exports.CHANGE_OUTPUT_MAX_SIZE) * commitFeeRate);\n        const changeAmount = totalSenderAmount - totalRevealPrevOutputValue - fee;\n        if (changeAmount >= minChangeValue) {\n            tx.outs[tx.outs.length - 1].value = changeAmount;\n        }\n        else {\n            tx.outs = tx.outs.slice(0, tx.outs.length - 1);\n            txForEstimate.outs = txForEstimate.outs.slice(0, txForEstimate.outs.length - 1);\n            const feeWithoutChange = Math.floor(txForEstimate.dogeByteLength() * commitFeeRate);\n            if (totalSenderAmount - totalRevealPrevOutputValue - feeWithoutChange < 0) {\n                this.mustCommitTxFee = fee;\n                return true;\n            }\n        }\n        this.commitTx = tx;\n        return false;\n    }\n    signCommitTx(commitTxPrevOutputList) {\n        signTx(this.commitTx, commitTxPrevOutputList, this.network);\n    }\n    completeRevealTx() {\n        for (let i = 0; i < this.revealTxs.length; i++) {\n            let revealTx = this.revealTxs[i];\n            revealTx.ins[0].hash = i == 0 ? this.commitTx.getHash() : this.revealTxs[i - 1].getHash();\n            revealTx.ins[1].hash = i == 0 ? this.commitTx.getHash() : this.revealTxs[i - 1].getHash();\n            this.revealTxPrevOutputFetcher.push(this.inscriptionTxCtxDataList[i].revealTxPrevOutput.value);\n            const prevOutScripts = this.inscriptionTxCtxDataList[i].redeemScript;\n            const hash = revealTx.hashForSignature(0, prevOutScripts, bitcoin.Transaction.SIGHASH_ALL);\n            const privateKeyHex = crypto_lib_1.base.toHex(this.inscriptionTxCtxDataList[i].privateKey);\n            const signature = (0, txBuild_1.sign)(hash, privateKeyHex);\n            let txsignature = bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL);\n            revealTx.ins[0].script = Buffer.concat([this.inscriptionTxCtxDataList[i].inscriptionScript, bufferToBuffer(txsignature), bufferToBuffer(this.inscriptionTxCtxDataList[i].redeemScript)]);\n            const prevScript = bitcoin.address.toOutputScript(this.fromAddr, this.network);\n            const hash2 = revealTx.hashForSignature(1, prevScript, bitcoin.Transaction.SIGHASH_ALL);\n            const signature2 = (0, txBuild_1.sign)(hash2, privateKeyHex);\n            const payment = bitcoin.payments.p2pkh({\n                signature: bitcoin.script.signature.encode(signature2, bitcoin.Transaction.SIGHASH_ALL),\n                pubkey: (0, txBuild_1.private2public)(privateKeyHex),\n            });\n            revealTx.ins[1].script = payment.input;\n        }\n    }\n    calculateFee() {\n        let commitTxFee = 0;\n        this.commitTx.ins.forEach((_, i) => {\n            commitTxFee += this.commitTxPrevOutputFetcher[i];\n        });\n        this.commitTx.outs.forEach(out => {\n            commitTxFee -= out.value;\n        });\n        let revealTxFees = [];\n        this.revealTxs.forEach((revealTx, i) => {\n            let revealTxFee = 0;\n            revealTxFee = this.revealTxPrevOutputFetcher[i];\n            revealTxFees.push(revealTxFee);\n        });\n        return {\n            commitTxFee,\n            revealTxFees,\n        };\n    }\n}\nexports.DogInscriptionTool = DogInscriptionTool;\nfunction signTx(tx, commitTxPrevOutputList, network) {\n    tx.ins.forEach((input, i) => {\n        const addressType = (0, txBuild_1.getAddressType)(commitTxPrevOutputList[i].address, network);\n        const privateKey = crypto_lib_1.base.fromHex((0, txBuild_1.privateKeyFromWIF)(commitTxPrevOutputList[i].privateKey, network));\n        const privateKeyHex = crypto_lib_1.base.toHex(privateKey);\n        const publicKey = (0, txBuild_1.private2public)(privateKeyHex);\n        if (addressType === \'legacy\') {\n            const prevScript = bitcoin.address.toOutputScript(commitTxPrevOutputList[i].address, network);\n            const hash = tx.hashForSignature(i, prevScript, bitcoin.Transaction.SIGHASH_ALL);\n            const signature = (0, txBuild_1.sign)(hash, privateKeyHex);\n            const payment = bitcoin.payments.p2pkh({\n                signature: bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL),\n                pubkey: publicKey,\n            });\n            input.script = payment.input;\n        }\n        else {\n            const pubKeyHash = bcrypto.hash160(publicKey);\n            const prevOutScript = Buffer.of(0x19, 0x76, 0xa9, 0x14, ...pubKeyHash, 0x88, 0xac);\n            const value = commitTxPrevOutputList[i].amount;\n            const hash = tx.hashForWitness(i, prevOutScript, value, bitcoin.Transaction.SIGHASH_ALL);\n            const signature = (0, txBuild_1.sign)(hash, privateKeyHex);\n            input.witness = [\n                bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL),\n                publicKey,\n            ];\n            const redeemScript = Buffer.of(0x16, 0, 20, ...pubKeyHash);\n            if (addressType === "segwit_nested") {\n                input.script = redeemScript;\n            }\n        }\n    });\n}\nfunction createInscriptionTxCtxData(network, inscriptionData, privateKeyWif) {\n    const privateKey = crypto_lib_1.base.fromHex((0, txBuild_1.privateKeyFromWIF)(privateKeyWif, network));\n    const pubKey = (0, txBuild_1.wif2Public)(privateKeyWif, network);\n    const ops = bitcoin.script.OPS;\n    let data;\n    if (typeof inscriptionData.body == \'string\') {\n        data = Buffer.from(inscriptionData.body);\n    }\n    else {\n        data = inscriptionData.body;\n    }\n    let parts = [];\n    while (data.length) {\n        let part = data.slice(0, Math.min(MAX_CHUNK_LEN, data.length));\n        data = data.slice(part.length);\n        parts.push(part);\n    }\n    let inscription = new DogScript();\n    inscription.chunks.push(bufferToChunk(Buffer.from(\'ord\')));\n    inscription.chunks.push(numberToChunk(parts.length));\n    inscription.chunks.push(bufferToChunk(Buffer.from(inscriptionData.contentType)));\n    parts.forEach((part, n) => {\n        inscription.chunks.push(numberToChunk(parts.length - n - 1));\n        inscription.chunks.push(bufferToChunk(part));\n    });\n    let ctxDatas = [];\n    while (inscription.chunks.length) {\n        let partial = new DogScript();\n        if (ctxDatas.length == 0) {\n            partial.chunks.push(inscription.chunks.shift());\n        }\n        while (partial.total() <= MAX_PAYLOAD_LEN && inscription.chunks.length) {\n            partial.chunks.push(inscription.chunks.shift());\n            partial.chunks.push(inscription.chunks.shift());\n        }\n        if (partial.total() > MAX_PAYLOAD_LEN) {\n            inscription.chunks.unshift(partial.chunks.pop());\n            inscription.chunks.unshift(partial.chunks.pop());\n        }\n        let lock = new DogScript();\n        lock.chunks.push(bufferToChunk(pubKey));\n        lock.chunks.push(opcodeToChunk(ops.OP_CHECKSIGVERIFY));\n        partial.chunks.forEach(() => {\n            lock.chunks.push(opcodeToChunk(ops.OP_DROP));\n        });\n        lock.chunks.push(opcodeToChunk(ops.OP_TRUE));\n        let lockhash = crypto_lib_1.base.ripemd160(crypto_lib_1.base.sha256(lock.toBuffer()));\n        let { output, address } = payments.p2sh({ hash: Buffer.from(lockhash), network: network });\n        let ctx = {\n            privateKey: privateKey,\n            inscriptionScript: partial.toBuffer(),\n            redeemScript: lock.toBuffer(),\n            commitTxAddress: address,\n            commitTxAddressPkScript: output,\n            revealTxPrevOutput: {\n                pkScript: Buffer.alloc(0),\n                value: 100000,\n            },\n            revealPkScript: bitcoin.address.toOutputScript(inscriptionData.revealAddr, network),\n        };\n        ctxDatas.push(ctx);\n    }\n    return ctxDatas;\n}\nfunction dogInscribe(network, request) {\n    const tool = DogInscriptionTool.newDogInscriptionTool(network, request);\n    if (tool.mustCommitTxFee > 0) {\n        return {\n            commitTx: "",\n            revealTxs: [],\n            commitTxFee: tool.mustCommitTxFee,\n            revealTxFees: tool.mustRevealTxFees,\n            commitAddrs: tool.commitAddrs,\n        };\n    }\n    return {\n        commitTx: tool.commitTx.toHex(),\n        revealTxs: tool.revealTxs.map(revealTx => revealTx.toHex()),\n        ...tool.calculateFee(),\n        commitAddrs: tool.commitAddrs,\n    };\n}\nexports.dogInscribe = dogInscribe;\n//# sourceMappingURL=doginals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvZG9naW5hbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLGlCQUFpQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLDhCQUE4QjtBQUN0Siw2QkFBNkIsbUJBQU8sQ0FBQywrRkFBaUI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xELDZCQUE2QixtQkFBTyxDQUFDLHVHQUF3QjtBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNyQyx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBaUI7QUFDakQsY0FBYyxtQkFBTyxDQUFDLGlHQUFxQjtBQUMzQyw4QkFBOEIsbUJBQU8sQ0FBQyxpSEFBMEI7QUFDaEUsc0JBQXNCLG1CQUFPLENBQUMsaUhBQTZCO0FBQzNELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxQ0FBcUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYyxrQkFBa0Isa0JBQWtCLCtDQUErQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvZG9naW5hbHMuanM/ZTUwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kb2dJbnNjcmliZSA9IGV4cG9ydHMuRG9nSW5zY3JpcHRpb25Ub29sID0gZXhwb3J0cy5Eb2dTY3JpcHQgPSBleHBvcnRzLmJ1ZmZlclRvQ2h1bmsgPSBleHBvcnRzLmJ1ZmZlclRvQnVmZmVyID0gZXhwb3J0cy5DSEFOR0VfT1VUUFVUX01BWF9TSVpFID0gdm9pZCAwO1xuY29uc3QgYml0Y29pbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iaXRjb2luanMtbGliXCIpKTtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuY29uc3QgYmNyeXB0byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL2NyeXB0b1wiKSk7XG5jb25zdCB0eEJ1aWxkXzEgPSByZXF1aXJlKFwiLi90eEJ1aWxkXCIpO1xuY29uc3QgYml0Y29pbmpzX2xpYl8xID0gcmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYlwiKTtcbmNvbnN0IG9wc18xID0gcmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYi9vcHNcIik7XG5jb25zdCBwYXltZW50cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL3BheW1lbnRzXCIpKTtcbmNvbnN0IGJ1ZmZlcnV0aWxzXzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL2J1ZmZlcnV0aWxzXCIpO1xuZXhwb3J0cy5DSEFOR0VfT1VUUFVUX01BWF9TSVpFID0gMjAgKyA0ICsgMzQgKyA0O1xuY29uc3QgZGVmYXVsdFR4VmVyc2lvbiA9IDI7XG5jb25zdCBkZWZhdWx0U2VxdWVuY2VOdW0gPSAweGZmZmZmZmZkO1xuY29uc3QgZGVmYXVsdFJldmVhbE91dFZhbHVlID0gMTAwMDAwO1xuY29uc3QgZGVmYXVsdE1pbkNoYW5nZVZhbHVlID0gMTAwMDAwO1xuY29uc3QgTUFYX0NIVU5LX0xFTiA9IDI0MDtcbmNvbnN0IE1BWF9QQVlMT0FEX0xFTiA9IDE1MDA7XG5mdW5jdGlvbiBudW1iZXJUb0NodW5rKG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBidWY6IG4gPD0gMTYgPyB1bmRlZmluZWQgOiBuIDwgMTI4ID8gQnVmZmVyLmZyb20oW25dKSA6IEJ1ZmZlci5mcm9tKFtuICUgMjU2LCBuIC8gMjU2XSksXG4gICAgICAgIGxlbjogbiA8PSAxNiA/IDAgOiBuIDwgMTI4ID8gMSA6IDIsXG4gICAgICAgIG9wY29kZW51bTogbiA9PSAwID8gMCA6IG4gPD0gMTYgPyA4MCArIG4gOiBuIDwgMTI4ID8gMSA6IDJcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVmZmVyVG9CdWZmZXIoYikge1xuICAgIGxldCBjID0gYnVmZmVyVG9DaHVuayhiKTtcbiAgICBsZXQgc2l6ZSA9IGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aChjLm9wY29kZW51bSk7XG4gICAgdmFyIG9wY29kZW51bSA9IGMub3Bjb2RlbnVtO1xuICAgIGlmIChjLmJ1Zikge1xuICAgICAgICBpZiAob3Bjb2RlbnVtID09PSBvcHNfMS5PUFMuT1BfUFVTSERBVEExKSB7XG4gICAgICAgICAgICBzaXplICs9IGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aChjLmxlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3Bjb2RlbnVtID09PSBvcHNfMS5PUFMuT1BfUFVTSERBVEEyKSB7XG4gICAgICAgICAgICBzaXplICs9IGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aChjLmxlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3Bjb2RlbnVtID09PSBvcHNfMS5PUFMuT1BfUFVTSERBVEE0KSB7XG4gICAgICAgICAgICBzaXplICs9IGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aChjLmxlbik7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZSArPSBjLmJ1Zi5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBidyA9IGJpdGNvaW5qc19saWJfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KHNpemUpO1xuICAgIGJ3LndyaXRlVUludDgoYy5vcGNvZGVudW0pO1xuICAgIGlmIChjLmJ1Zikge1xuICAgICAgICBpZiAob3Bjb2RlbnVtIDwgb3BzXzEuT1BTLk9QX1BVU0hEQVRBMSkge1xuICAgICAgICAgICAgYncud3JpdGVTbGljZShjLmJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3Bjb2RlbnVtID09PSBvcHNfMS5PUFMuT1BfUFVTSERBVEExKSB7XG4gICAgICAgICAgICBidy53cml0ZVVJbnQ4KGMubGVuKTtcbiAgICAgICAgICAgIGJ3LndyaXRlU2xpY2UoYy5idWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wY29kZW51bSA9PT0gb3BzXzEuT1BTLk9QX1BVU0hEQVRBMikge1xuICAgICAgICAgICAgYncud3JpdGVVSW50NjQoYy5sZW4pO1xuICAgICAgICAgICAgYncud3JpdGVTbGljZShjLmJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3Bjb2RlbnVtID09PSBvcHNfMS5PUFMuT1BfUFVTSERBVEE0KSB7XG4gICAgICAgICAgICBidy53cml0ZVVJbnQzMihjLmxlbik7XG4gICAgICAgICAgICBidy53cml0ZVNsaWNlKGMuYnVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYncuZW5kKCk7XG59XG5leHBvcnRzLmJ1ZmZlclRvQnVmZmVyID0gYnVmZmVyVG9CdWZmZXI7XG5mdW5jdGlvbiBidWZmZXJUb0NodW5rKGIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBidWY6IGIubGVuZ3RoID8gYiA6IHVuZGVmaW5lZCxcbiAgICAgICAgbGVuOiBiLmxlbmd0aCxcbiAgICAgICAgb3Bjb2RlbnVtOiBiLmxlbmd0aCA8PSA3NSA/IGIubGVuZ3RoIDogYi5sZW5ndGggPD0gMjU1ID8gNzYgOiA3N1xuICAgIH07XG59XG5leHBvcnRzLmJ1ZmZlclRvQ2h1bmsgPSBidWZmZXJUb0NodW5rO1xuZnVuY3Rpb24gb3Bjb2RlVG9DaHVuayhvcCkge1xuICAgIHJldHVybiB7IG9wY29kZW51bTogb3AgfTtcbn1cbmNsYXNzIERvZ1NjcmlwdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgfVxuICAgIHRvdGFsKCkge1xuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmNodW5rc1xuICAgICAgICAgICAgLm1hcChjaHVuayA9PiB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aChjaHVuay5vcGNvZGVudW0pO1xuICAgICAgICAgICAgdmFyIG9wY29kZW51bSA9IGNodW5rLm9wY29kZW51bTtcbiAgICAgICAgICAgIGlmIChjaHVuay5idWYpIHtcbiAgICAgICAgICAgICAgICBpZiAob3Bjb2RlbnVtIDwgb3BzXzEuT1BTLk9QX1BVU0hEQVRBMSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGNvZGVudW0gPT09IG9wc18xLk9QUy5PUF9QVVNIREFUQTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoY2h1bmsubGVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3Bjb2RlbnVtID09PSBvcHNfMS5PUFMuT1BfUFVTSERBVEEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgKz0gYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGNodW5rLmxlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wY29kZW51bSA9PT0gb3BzXzEuT1BTLk9QX1BVU0hEQVRBNCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9IGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGluZ0xlbmd0aChjaHVuay5sZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaXplICs9IGNodW5rLmJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICBsZXQgdG90YWwgPSB0aGlzLnRvdGFsKCk7XG4gICAgICAgIGxldCBidyA9IGJpdGNvaW5qc19saWJfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KHRvdGFsKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNodW5rID0gdGhpcy5jaHVua3NbaV07XG4gICAgICAgICAgICB2YXIgb3Bjb2RlbnVtID0gY2h1bmsub3Bjb2RlbnVtO1xuICAgICAgICAgICAgYncud3JpdGVVSW50OChjaHVuay5vcGNvZGVudW0pO1xuICAgICAgICAgICAgaWYgKGNodW5rLmJ1Zikge1xuICAgICAgICAgICAgICAgIGlmIChvcGNvZGVudW0gPCBvcHNfMS5PUFMuT1BfUFVTSERBVEExKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ3LndyaXRlU2xpY2UoY2h1bmsuYnVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3Bjb2RlbnVtID09PSBvcHNfMS5PUFMuT1BfUFVTSERBVEExKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ3LndyaXRlVUludDgoY2h1bmsubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgYncud3JpdGVTbGljZShjaHVuay5idWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGNvZGVudW0gPT09IG9wc18xLk9QUy5PUF9QVVNIREFUQTIpIHtcbiAgICAgICAgICAgICAgICAgICAgYncud3JpdGVVSW50NjQoY2h1bmsubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgYncud3JpdGVTbGljZShjaHVuay5idWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGNvZGVudW0gPT09IG9wc18xLk9QUy5PUF9QVVNIREFUQTQpIHtcbiAgICAgICAgICAgICAgICAgICAgYncud3JpdGVVSW50MzIoY2h1bmsubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgYncud3JpdGVTbGljZShjaHVuay5idWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYncuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Eb2dTY3JpcHQgPSBEb2dTY3JpcHQ7XG5jbGFzcyBEb2dJbnNjcmlwdGlvblRvb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm5ldHdvcmsgPSBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW47XG4gICAgICAgIHRoaXMuaW5zY3JpcHRpb25UeEN0eERhdGFMaXN0ID0gW107XG4gICAgICAgIHRoaXMucmV2ZWFsVHhzID0gW107XG4gICAgICAgIHRoaXMuY29tbWl0VHggPSBuZXcgYml0Y29pbi5UcmFuc2FjdGlvbigpO1xuICAgICAgICB0aGlzLmNvbW1pdFR4UHJldk91dHB1dEZldGNoZXIgPSBbXTtcbiAgICAgICAgdGhpcy5yZXZlYWxUeFByZXZPdXRwdXRGZXRjaGVyID0gW107XG4gICAgICAgIHRoaXMubXVzdENvbW1pdFR4RmVlID0gMDtcbiAgICAgICAgdGhpcy5tdXN0UmV2ZWFsVHhGZWVzID0gW107XG4gICAgICAgIHRoaXMuY29tbWl0QWRkcnMgPSBbXTtcbiAgICAgICAgdGhpcy5mcm9tQWRkciA9ICcnO1xuICAgICAgICB0aGlzLnJldmVhbEFkZHIgPSAnJztcbiAgICB9XG4gICAgc3RhdGljIG5ld0RvZ0luc2NyaXB0aW9uVG9vbChuZXR3b3JrLCByZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHRvb2wgPSBuZXcgRG9nSW5zY3JpcHRpb25Ub29sKCk7XG4gICAgICAgIHRvb2wubmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgIGNvbnN0IHJldmVhbE91dFZhbHVlID0gcmVxdWVzdC5yZXZlYWxPdXRWYWx1ZSB8fCBkZWZhdWx0UmV2ZWFsT3V0VmFsdWU7XG4gICAgICAgIGNvbnN0IG1pbkNoYW5nZVZhbHVlID0gcmVxdWVzdC5taW5DaGFuZ2VWYWx1ZSB8fCBkZWZhdWx0TWluQ2hhbmdlVmFsdWU7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSByZXF1ZXN0LmNvbW1pdFR4UHJldk91dHB1dExpc3RbMF0ucHJpdmF0ZUtleTtcbiAgICAgICAgdG9vbC5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3QgPSBjcmVhdGVJbnNjcmlwdGlvblR4Q3R4RGF0YShuZXR3b3JrLCByZXF1ZXN0Lmluc2NyaXB0aW9uRGF0YSwgcHJpdmF0ZUtleSk7XG4gICAgICAgIHRvb2wucmV2ZWFsQWRkciA9IHJlcXVlc3QuaW5zY3JpcHRpb25EYXRhLnJldmVhbEFkZHI7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXlIZXggPSBjcnlwdG9fbGliXzEuYmFzZS50b0hleChjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KCgwLCB0eEJ1aWxkXzEucHJpdmF0ZUtleUZyb21XSUYpKHByaXZhdGVLZXksIG5ldHdvcmspKSk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCB0eEJ1aWxkXzEucHJpdmF0ZTJwdWJsaWMpKHByaXZhdGVLZXlIZXgpO1xuICAgICAgICB0b29sLmZyb21BZGRyID0gYml0Y29pbi5wYXltZW50cy5wMnBraCh7IHB1YmtleTogcHVibGljS2V5LCBuZXR3b3JrOiBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gICAgICAgIGNvbnN0IHRvdGFsUmV2ZWFsUHJldk91dHB1dFZhbHVlID0gdG9vbC5idWlsZEVtcHR5UmV2ZWFsVHhzKG5ldHdvcmssIHJldmVhbE91dFZhbHVlLCByZXF1ZXN0LnJldmVhbEZlZVJhdGUpO1xuICAgICAgICBjb25zdCBpbnN1ZmZpY2llbnQgPSB0b29sLmJ1aWxkQ29tbWl0VHgobmV0d29yaywgcmVxdWVzdC5jb21taXRUeFByZXZPdXRwdXRMaXN0LCByZXF1ZXN0LmNoYW5nZUFkZHJlc3MsIHRvdGFsUmV2ZWFsUHJldk91dHB1dFZhbHVlLCByZXZlYWxPdXRWYWx1ZSwgcmVxdWVzdC5jb21taXRGZWVSYXRlLCBtaW5DaGFuZ2VWYWx1ZSk7XG4gICAgICAgIGlmIChpbnN1ZmZpY2llbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0b29sO1xuICAgICAgICB9XG4gICAgICAgIHRvb2wuc2lnbkNvbW1pdFR4KHJlcXVlc3QuY29tbWl0VHhQcmV2T3V0cHV0TGlzdCk7XG4gICAgICAgIHRvb2wuY29tcGxldGVSZXZlYWxUeCgpO1xuICAgICAgICByZXR1cm4gdG9vbDtcbiAgICB9XG4gICAgYnVpbGRFbXB0eVJldmVhbFR4cyhuZXR3b3JrLCByZXZlYWxPdXRWYWx1ZSwgcmV2ZWFsRmVlUmF0ZSkge1xuICAgICAgICBsZXQgdG90YWxQcmV2T3V0cHV0VmFsdWUgPSAwO1xuICAgICAgICBjb25zdCByZXZlYWxUeHMgPSBbXTtcbiAgICAgICAgY29uc3QgbXVzdFJldmVhbFR4RmVlcyA9IFtdO1xuICAgICAgICBjb25zdCBjb21taXRBZGRycyA9IFtdO1xuICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluc2NyaXB0aW9uVHhDdHhEYXRhTGlzdC5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgICAgICAgICAgbGV0IGluc2NyaXB0aW9uVHhDdHhEYXRhID0gdGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB0eCA9IG5ldyBiaXRjb2luLlRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICB0eC52ZXJzaW9uID0gZGVmYXVsdFR4VmVyc2lvbjtcbiAgICAgICAgICAgIHR4LmFkZElucHV0KEJ1ZmZlci5hbGxvYygzMiksIDAsIGRlZmF1bHRTZXF1ZW5jZU51bSk7XG4gICAgICAgICAgICB0eC5hZGRJbnB1dChCdWZmZXIuYWxsb2MoMzIpLCAxLCBkZWZhdWx0U2VxdWVuY2VOdW0pO1xuICAgICAgICAgICAgdHguYWRkT3V0cHV0KGkgIT0gdGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3QubGVuZ3RoIC0gMSA/IGluc2NyaXB0aW9uVHhDdHhEYXRhLmNvbW1pdFR4QWRkcmVzc1BrU2NyaXB0IDogaW5zY3JpcHRpb25UeEN0eERhdGEucmV2ZWFsUGtTY3JpcHQsIHJldmVhbE91dFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5U2lnbmF0dXJlID0gQnVmZmVyLmFsbG9jKDcyKTtcbiAgICAgICAgICAgIGxldCB1bmxvY2sgPSBCdWZmZXIuY29uY2F0KFtpbnNjcmlwdGlvblR4Q3R4RGF0YS5pbnNjcmlwdGlvblNjcmlwdCwgYnVmZmVyVG9CdWZmZXIoZW1wdHlTaWduYXR1cmUpLCBidWZmZXJUb0J1ZmZlcihpbnNjcmlwdGlvblR4Q3R4RGF0YS5yZWRlZW1TY3JpcHQpXSk7XG4gICAgICAgICAgICB0eC5pbnNbMF0uc2NyaXB0ID0gdW5sb2NrO1xuICAgICAgICAgICAgaWYgKGkgIT0gdGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHR4LmFkZE91dHB1dChiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQodGhpcy5mcm9tQWRkciwgbmV0d29yayksIGxlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHguaW5zWzFdLnNjcmlwdCA9IEJ1ZmZlci5hbGxvYygxMDYpO1xuICAgICAgICAgICAgY29uc3QgZmVlID0gTWF0aC5mbG9vcigodHguZG9nZUJ5dGVMZW5ndGgoKSArIGV4cG9ydHMuQ0hBTkdFX09VVFBVVF9NQVhfU0laRSkgKiByZXZlYWxGZWVSYXRlKTtcbiAgICAgICAgICAgIGxlZnQgKz0gZmVlO1xuICAgICAgICAgICAgY29uc3QgcHJldk91dHB1dFZhbHVlID0gZmVlO1xuICAgICAgICAgICAgaW5zY3JpcHRpb25UeEN0eERhdGEucmV2ZWFsVHhQcmV2T3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIHBrU2NyaXB0OiBpbnNjcmlwdGlvblR4Q3R4RGF0YS5jb21taXRUeEFkZHJlc3NQa1NjcmlwdCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJldk91dHB1dFZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRvdGFsUHJldk91dHB1dFZhbHVlICs9IHByZXZPdXRwdXRWYWx1ZTtcbiAgICAgICAgICAgIHJldmVhbFR4cy5wdXNoKHR4KTtcbiAgICAgICAgICAgIG11c3RSZXZlYWxUeEZlZXMucHVzaChmZWUpO1xuICAgICAgICAgICAgY29tbWl0QWRkcnMucHVzaChpbnNjcmlwdGlvblR4Q3R4RGF0YS5jb21taXRUeEFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gcmV2ZWFsVHhzLmxlbmd0aCAtIDE7IGkgPCBqOyBpKyssIGotLSkge1xuICAgICAgICAgICAgW3JldmVhbFR4c1tpXSwgcmV2ZWFsVHhzW2pdXSA9IFtyZXZlYWxUeHNbal0sIHJldmVhbFR4c1tpXV07XG4gICAgICAgICAgICBbbXVzdFJldmVhbFR4RmVlc1tpXSwgbXVzdFJldmVhbFR4RmVlc1tqXV0gPSBbbXVzdFJldmVhbFR4RmVlc1tqXSwgbXVzdFJldmVhbFR4RmVlc1tpXV07XG4gICAgICAgICAgICBbY29tbWl0QWRkcnNbaV0sIGNvbW1pdEFkZHJzW2pdXSA9IFtjb21taXRBZGRyc1tqXSwgY29tbWl0QWRkcnNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV2ZWFsVHhzID0gcmV2ZWFsVHhzO1xuICAgICAgICB0aGlzLm11c3RSZXZlYWxUeEZlZXMgPSBtdXN0UmV2ZWFsVHhGZWVzO1xuICAgICAgICB0aGlzLmNvbW1pdEFkZHJzID0gY29tbWl0QWRkcnM7XG4gICAgICAgIHRvdGFsUHJldk91dHB1dFZhbHVlICs9IHJldmVhbE91dFZhbHVlO1xuICAgICAgICByZXR1cm4gdG90YWxQcmV2T3V0cHV0VmFsdWU7XG4gICAgfVxuICAgIGJ1aWxkQ29tbWl0VHgobmV0d29yaywgY29tbWl0VHhQcmV2T3V0cHV0TGlzdCwgY2hhbmdlQWRkcmVzcywgdG90YWxSZXZlYWxQcmV2T3V0cHV0VmFsdWUsIHJldmVhbE91dFZhbHVlLCBjb21taXRGZWVSYXRlLCBtaW5DaGFuZ2VWYWx1ZSkge1xuICAgICAgICBsZXQgdG90YWxTZW5kZXJBbW91bnQgPSAwO1xuICAgICAgICBjb25zdCB0eCA9IG5ldyBiaXRjb2luLlRyYW5zYWN0aW9uKCk7XG4gICAgICAgIHR4LnZlcnNpb24gPSBkZWZhdWx0VHhWZXJzaW9uO1xuICAgICAgICBjb21taXRUeFByZXZPdXRwdXRMaXN0LmZvckVhY2goY29tbWl0VHhQcmV2T3V0cHV0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG9fbGliXzEuYmFzZS5yZXZlcnNlQnVmZmVyKGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoY29tbWl0VHhQcmV2T3V0cHV0LnR4SWQpKTtcbiAgICAgICAgICAgIHR4LmFkZElucHV0KGhhc2gsIGNvbW1pdFR4UHJldk91dHB1dC52T3V0LCBkZWZhdWx0U2VxdWVuY2VOdW0pO1xuICAgICAgICAgICAgdGhpcy5jb21taXRUeFByZXZPdXRwdXRGZXRjaGVyLnB1c2goY29tbWl0VHhQcmV2T3V0cHV0LmFtb3VudCk7XG4gICAgICAgICAgICB0b3RhbFNlbmRlckFtb3VudCArPSBjb21taXRUeFByZXZPdXRwdXQuYW1vdW50O1xuICAgICAgICB9KTtcbiAgICAgICAgdHguYWRkT3V0cHV0KHRoaXMuaW5zY3JpcHRpb25UeEN0eERhdGFMaXN0WzBdLnJldmVhbFR4UHJldk91dHB1dC5wa1NjcmlwdCwgcmV2ZWFsT3V0VmFsdWUpO1xuICAgICAgICB0eC5hZGRPdXRwdXQoYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KHRoaXMuZnJvbUFkZHIsIG5ldHdvcmspLCB0b3RhbFJldmVhbFByZXZPdXRwdXRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZVBrU2NyaXB0ID0gYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KGNoYW5nZUFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgICB0eC5hZGRPdXRwdXQoY2hhbmdlUGtTY3JpcHQsIDApO1xuICAgICAgICBjb25zdCB0eEZvckVzdGltYXRlID0gdHguY2xvbmUoKTtcbiAgICAgICAgc2lnblR4KHR4Rm9yRXN0aW1hdGUsIGNvbW1pdFR4UHJldk91dHB1dExpc3QsIHRoaXMubmV0d29yayk7XG4gICAgICAgIGNvbnN0IGZlZSA9IE1hdGguZmxvb3IoKHR4Rm9yRXN0aW1hdGUuZG9nZUJ5dGVMZW5ndGgoKSArIGV4cG9ydHMuQ0hBTkdFX09VVFBVVF9NQVhfU0laRSkgKiBjb21taXRGZWVSYXRlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlQW1vdW50ID0gdG90YWxTZW5kZXJBbW91bnQgLSB0b3RhbFJldmVhbFByZXZPdXRwdXRWYWx1ZSAtIGZlZTtcbiAgICAgICAgaWYgKGNoYW5nZUFtb3VudCA+PSBtaW5DaGFuZ2VWYWx1ZSkge1xuICAgICAgICAgICAgdHgub3V0c1t0eC5vdXRzLmxlbmd0aCAtIDFdLnZhbHVlID0gY2hhbmdlQW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHgub3V0cyA9IHR4Lm91dHMuc2xpY2UoMCwgdHgub3V0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHR4Rm9yRXN0aW1hdGUub3V0cyA9IHR4Rm9yRXN0aW1hdGUub3V0cy5zbGljZSgwLCB0eEZvckVzdGltYXRlLm91dHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBmZWVXaXRob3V0Q2hhbmdlID0gTWF0aC5mbG9vcih0eEZvckVzdGltYXRlLmRvZ2VCeXRlTGVuZ3RoKCkgKiBjb21taXRGZWVSYXRlKTtcbiAgICAgICAgICAgIGlmICh0b3RhbFNlbmRlckFtb3VudCAtIHRvdGFsUmV2ZWFsUHJldk91dHB1dFZhbHVlIC0gZmVlV2l0aG91dENoYW5nZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11c3RDb21taXRUeEZlZSA9IGZlZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbW1pdFR4ID0gdHg7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2lnbkNvbW1pdFR4KGNvbW1pdFR4UHJldk91dHB1dExpc3QpIHtcbiAgICAgICAgc2lnblR4KHRoaXMuY29tbWl0VHgsIGNvbW1pdFR4UHJldk91dHB1dExpc3QsIHRoaXMubmV0d29yayk7XG4gICAgfVxuICAgIGNvbXBsZXRlUmV2ZWFsVHgoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yZXZlYWxUeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXZlYWxUeCA9IHRoaXMucmV2ZWFsVHhzW2ldO1xuICAgICAgICAgICAgcmV2ZWFsVHguaW5zWzBdLmhhc2ggPSBpID09IDAgPyB0aGlzLmNvbW1pdFR4LmdldEhhc2goKSA6IHRoaXMucmV2ZWFsVHhzW2kgLSAxXS5nZXRIYXNoKCk7XG4gICAgICAgICAgICByZXZlYWxUeC5pbnNbMV0uaGFzaCA9IGkgPT0gMCA/IHRoaXMuY29tbWl0VHguZ2V0SGFzaCgpIDogdGhpcy5yZXZlYWxUeHNbaSAtIDFdLmdldEhhc2goKTtcbiAgICAgICAgICAgIHRoaXMucmV2ZWFsVHhQcmV2T3V0cHV0RmV0Y2hlci5wdXNoKHRoaXMuaW5zY3JpcHRpb25UeEN0eERhdGFMaXN0W2ldLnJldmVhbFR4UHJldk91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2T3V0U2NyaXB0cyA9IHRoaXMuaW5zY3JpcHRpb25UeEN0eERhdGFMaXN0W2ldLnJlZGVlbVNjcmlwdDtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSByZXZlYWxUeC5oYXNoRm9yU2lnbmF0dXJlKDAsIHByZXZPdXRTY3JpcHRzLCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMKTtcbiAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXlIZXggPSBjcnlwdG9fbGliXzEuYmFzZS50b0hleCh0aGlzLmluc2NyaXB0aW9uVHhDdHhEYXRhTGlzdFtpXS5wcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9ICgwLCB0eEJ1aWxkXzEuc2lnbikoaGFzaCwgcHJpdmF0ZUtleUhleCk7XG4gICAgICAgICAgICBsZXQgdHhzaWduYXR1cmUgPSBiaXRjb2luLnNjcmlwdC5zaWduYXR1cmUuZW5jb2RlKHNpZ25hdHVyZSwgYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCk7XG4gICAgICAgICAgICByZXZlYWxUeC5pbnNbMF0uc2NyaXB0ID0gQnVmZmVyLmNvbmNhdChbdGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3RbaV0uaW5zY3JpcHRpb25TY3JpcHQsIGJ1ZmZlclRvQnVmZmVyKHR4c2lnbmF0dXJlKSwgYnVmZmVyVG9CdWZmZXIodGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3RbaV0ucmVkZWVtU2NyaXB0KV0pO1xuICAgICAgICAgICAgY29uc3QgcHJldlNjcmlwdCA9IGJpdGNvaW4uYWRkcmVzcy50b091dHB1dFNjcmlwdCh0aGlzLmZyb21BZGRyLCB0aGlzLm5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgaGFzaDIgPSByZXZlYWxUeC5oYXNoRm9yU2lnbmF0dXJlKDEsIHByZXZTY3JpcHQsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlMiA9ICgwLCB0eEJ1aWxkXzEuc2lnbikoaGFzaDIsIHByaXZhdGVLZXlIZXgpO1xuICAgICAgICAgICAgY29uc3QgcGF5bWVudCA9IGJpdGNvaW4ucGF5bWVudHMucDJwa2goe1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUyLCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMKSxcbiAgICAgICAgICAgICAgICBwdWJrZXk6ICgwLCB0eEJ1aWxkXzEucHJpdmF0ZTJwdWJsaWMpKHByaXZhdGVLZXlIZXgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXZlYWxUeC5pbnNbMV0uc2NyaXB0ID0gcGF5bWVudC5pbnB1dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxjdWxhdGVGZWUoKSB7XG4gICAgICAgIGxldCBjb21taXRUeEZlZSA9IDA7XG4gICAgICAgIHRoaXMuY29tbWl0VHguaW5zLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgICAgICAgIGNvbW1pdFR4RmVlICs9IHRoaXMuY29tbWl0VHhQcmV2T3V0cHV0RmV0Y2hlcltpXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tbWl0VHgub3V0cy5mb3JFYWNoKG91dCA9PiB7XG4gICAgICAgICAgICBjb21taXRUeEZlZSAtPSBvdXQudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmV2ZWFsVHhGZWVzID0gW107XG4gICAgICAgIHRoaXMucmV2ZWFsVHhzLmZvckVhY2goKHJldmVhbFR4LCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmV2ZWFsVHhGZWUgPSAwO1xuICAgICAgICAgICAgcmV2ZWFsVHhGZWUgPSB0aGlzLnJldmVhbFR4UHJldk91dHB1dEZldGNoZXJbaV07XG4gICAgICAgICAgICByZXZlYWxUeEZlZXMucHVzaChyZXZlYWxUeEZlZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tbWl0VHhGZWUsXG4gICAgICAgICAgICByZXZlYWxUeEZlZXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Eb2dJbnNjcmlwdGlvblRvb2wgPSBEb2dJbnNjcmlwdGlvblRvb2w7XG5mdW5jdGlvbiBzaWduVHgodHgsIGNvbW1pdFR4UHJldk91dHB1dExpc3QsIG5ldHdvcmspIHtcbiAgICB0eC5pbnMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgYWRkcmVzc1R5cGUgPSAoMCwgdHhCdWlsZF8xLmdldEFkZHJlc3NUeXBlKShjb21taXRUeFByZXZPdXRwdXRMaXN0W2ldLmFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleCgoMCwgdHhCdWlsZF8xLnByaXZhdGVLZXlGcm9tV0lGKShjb21taXRUeFByZXZPdXRwdXRMaXN0W2ldLnByaXZhdGVLZXksIG5ldHdvcmspKTtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleUhleCA9IGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KHByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgdHhCdWlsZF8xLnByaXZhdGUycHVibGljKShwcml2YXRlS2V5SGV4KTtcbiAgICAgICAgaWYgKGFkZHJlc3NUeXBlID09PSAnbGVnYWN5Jykge1xuICAgICAgICAgICAgY29uc3QgcHJldlNjcmlwdCA9IGJpdGNvaW4uYWRkcmVzcy50b091dHB1dFNjcmlwdChjb21taXRUeFByZXZPdXRwdXRMaXN0W2ldLmFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHR4Lmhhc2hGb3JTaWduYXR1cmUoaSwgcHJldlNjcmlwdCwgYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSAoMCwgdHhCdWlsZF8xLnNpZ24pKGhhc2gsIHByaXZhdGVLZXlIZXgpO1xuICAgICAgICAgICAgY29uc3QgcGF5bWVudCA9IGJpdGNvaW4ucGF5bWVudHMucDJwa2goe1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpLFxuICAgICAgICAgICAgICAgIHB1YmtleTogcHVibGljS2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dC5zY3JpcHQgPSBwYXltZW50LmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHViS2V5SGFzaCA9IGJjcnlwdG8uaGFzaDE2MChwdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3QgcHJldk91dFNjcmlwdCA9IEJ1ZmZlci5vZigweDE5LCAweDc2LCAweGE5LCAweDE0LCAuLi5wdWJLZXlIYXNoLCAweDg4LCAweGFjKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29tbWl0VHhQcmV2T3V0cHV0TGlzdFtpXS5hbW91bnQ7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gdHguaGFzaEZvcldpdG5lc3MoaSwgcHJldk91dFNjcmlwdCwgdmFsdWUsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gKDAsIHR4QnVpbGRfMS5zaWduKShoYXNoLCBwcml2YXRlS2V5SGV4KTtcbiAgICAgICAgICAgIGlucHV0LndpdG5lc3MgPSBbXG4gICAgICAgICAgICAgICAgYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpLFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCByZWRlZW1TY3JpcHQgPSBCdWZmZXIub2YoMHgxNiwgMCwgMjAsIC4uLnB1YktleUhhc2gpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NUeXBlID09PSBcInNlZ3dpdF9uZXN0ZWRcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LnNjcmlwdCA9IHJlZGVlbVNjcmlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zY3JpcHRpb25UeEN0eERhdGEobmV0d29yaywgaW5zY3JpcHRpb25EYXRhLCBwcml2YXRlS2V5V2lmKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoKDAsIHR4QnVpbGRfMS5wcml2YXRlS2V5RnJvbVdJRikocHJpdmF0ZUtleVdpZiwgbmV0d29yaykpO1xuICAgIGNvbnN0IHB1YktleSA9ICgwLCB0eEJ1aWxkXzEud2lmMlB1YmxpYykocHJpdmF0ZUtleVdpZiwgbmV0d29yayk7XG4gICAgY29uc3Qgb3BzID0gYml0Y29pbi5zY3JpcHQuT1BTO1xuICAgIGxldCBkYXRhO1xuICAgIGlmICh0eXBlb2YgaW5zY3JpcHRpb25EYXRhLmJvZHkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGluc2NyaXB0aW9uRGF0YS5ib2R5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEgPSBpbnNjcmlwdGlvbkRhdGEuYm9keTtcbiAgICB9XG4gICAgbGV0IHBhcnRzID0gW107XG4gICAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwYXJ0ID0gZGF0YS5zbGljZSgwLCBNYXRoLm1pbihNQVhfQ0hVTktfTEVOLCBkYXRhLmxlbmd0aCkpO1xuICAgICAgICBkYXRhID0gZGF0YS5zbGljZShwYXJ0Lmxlbmd0aCk7XG4gICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGxldCBpbnNjcmlwdGlvbiA9IG5ldyBEb2dTY3JpcHQoKTtcbiAgICBpbnNjcmlwdGlvbi5jaHVua3MucHVzaChidWZmZXJUb0NodW5rKEJ1ZmZlci5mcm9tKCdvcmQnKSkpO1xuICAgIGluc2NyaXB0aW9uLmNodW5rcy5wdXNoKG51bWJlclRvQ2h1bmsocGFydHMubGVuZ3RoKSk7XG4gICAgaW5zY3JpcHRpb24uY2h1bmtzLnB1c2goYnVmZmVyVG9DaHVuayhCdWZmZXIuZnJvbShpbnNjcmlwdGlvbkRhdGEuY29udGVudFR5cGUpKSk7XG4gICAgcGFydHMuZm9yRWFjaCgocGFydCwgbikgPT4ge1xuICAgICAgICBpbnNjcmlwdGlvbi5jaHVua3MucHVzaChudW1iZXJUb0NodW5rKHBhcnRzLmxlbmd0aCAtIG4gLSAxKSk7XG4gICAgICAgIGluc2NyaXB0aW9uLmNodW5rcy5wdXNoKGJ1ZmZlclRvQ2h1bmsocGFydCkpO1xuICAgIH0pO1xuICAgIGxldCBjdHhEYXRhcyA9IFtdO1xuICAgIHdoaWxlIChpbnNjcmlwdGlvbi5jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwYXJ0aWFsID0gbmV3IERvZ1NjcmlwdCgpO1xuICAgICAgICBpZiAoY3R4RGF0YXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHBhcnRpYWwuY2h1bmtzLnB1c2goaW5zY3JpcHRpb24uY2h1bmtzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChwYXJ0aWFsLnRvdGFsKCkgPD0gTUFYX1BBWUxPQURfTEVOICYmIGluc2NyaXB0aW9uLmNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnRpYWwuY2h1bmtzLnB1c2goaW5zY3JpcHRpb24uY2h1bmtzLnNoaWZ0KCkpO1xuICAgICAgICAgICAgcGFydGlhbC5jaHVua3MucHVzaChpbnNjcmlwdGlvbi5jaHVua3Muc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWwudG90YWwoKSA+IE1BWF9QQVlMT0FEX0xFTikge1xuICAgICAgICAgICAgaW5zY3JpcHRpb24uY2h1bmtzLnVuc2hpZnQocGFydGlhbC5jaHVua3MucG9wKCkpO1xuICAgICAgICAgICAgaW5zY3JpcHRpb24uY2h1bmtzLnVuc2hpZnQocGFydGlhbC5jaHVua3MucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsb2NrID0gbmV3IERvZ1NjcmlwdCgpO1xuICAgICAgICBsb2NrLmNodW5rcy5wdXNoKGJ1ZmZlclRvQ2h1bmsocHViS2V5KSk7XG4gICAgICAgIGxvY2suY2h1bmtzLnB1c2gob3Bjb2RlVG9DaHVuayhvcHMuT1BfQ0hFQ0tTSUdWRVJJRlkpKTtcbiAgICAgICAgcGFydGlhbC5jaHVua3MuZm9yRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBsb2NrLmNodW5rcy5wdXNoKG9wY29kZVRvQ2h1bmsob3BzLk9QX0RST1ApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvY2suY2h1bmtzLnB1c2gob3Bjb2RlVG9DaHVuayhvcHMuT1BfVFJVRSkpO1xuICAgICAgICBsZXQgbG9ja2hhc2ggPSBjcnlwdG9fbGliXzEuYmFzZS5yaXBlbWQxNjAoY3J5cHRvX2xpYl8xLmJhc2Uuc2hhMjU2KGxvY2sudG9CdWZmZXIoKSkpO1xuICAgICAgICBsZXQgeyBvdXRwdXQsIGFkZHJlc3MgfSA9IHBheW1lbnRzLnAyc2goeyBoYXNoOiBCdWZmZXIuZnJvbShsb2NraGFzaCksIG5ldHdvcms6IG5ldHdvcmsgfSk7XG4gICAgICAgIGxldCBjdHggPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxuICAgICAgICAgICAgaW5zY3JpcHRpb25TY3JpcHQ6IHBhcnRpYWwudG9CdWZmZXIoKSxcbiAgICAgICAgICAgIHJlZGVlbVNjcmlwdDogbG9jay50b0J1ZmZlcigpLFxuICAgICAgICAgICAgY29tbWl0VHhBZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgY29tbWl0VHhBZGRyZXNzUGtTY3JpcHQ6IG91dHB1dCxcbiAgICAgICAgICAgIHJldmVhbFR4UHJldk91dHB1dDoge1xuICAgICAgICAgICAgICAgIHBrU2NyaXB0OiBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgICAgICAgICAgdmFsdWU6IDEwMDAwMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXZlYWxQa1NjcmlwdDogYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KGluc2NyaXB0aW9uRGF0YS5yZXZlYWxBZGRyLCBuZXR3b3JrKSxcbiAgICAgICAgfTtcbiAgICAgICAgY3R4RGF0YXMucHVzaChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gY3R4RGF0YXM7XG59XG5mdW5jdGlvbiBkb2dJbnNjcmliZShuZXR3b3JrLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgdG9vbCA9IERvZ0luc2NyaXB0aW9uVG9vbC5uZXdEb2dJbnNjcmlwdGlvblRvb2wobmV0d29yaywgcmVxdWVzdCk7XG4gICAgaWYgKHRvb2wubXVzdENvbW1pdFR4RmVlID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tbWl0VHg6IFwiXCIsXG4gICAgICAgICAgICByZXZlYWxUeHM6IFtdLFxuICAgICAgICAgICAgY29tbWl0VHhGZWU6IHRvb2wubXVzdENvbW1pdFR4RmVlLFxuICAgICAgICAgICAgcmV2ZWFsVHhGZWVzOiB0b29sLm11c3RSZXZlYWxUeEZlZXMsXG4gICAgICAgICAgICBjb21taXRBZGRyczogdG9vbC5jb21taXRBZGRycyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWl0VHg6IHRvb2wuY29tbWl0VHgudG9IZXgoKSxcbiAgICAgICAgcmV2ZWFsVHhzOiB0b29sLnJldmVhbFR4cy5tYXAocmV2ZWFsVHggPT4gcmV2ZWFsVHgudG9IZXgoKSksXG4gICAgICAgIC4uLnRvb2wuY2FsY3VsYXRlRmVlKCksXG4gICAgICAgIGNvbW1pdEFkZHJzOiB0b29sLmNvbW1pdEFkZHJzLFxuICAgIH07XG59XG5leHBvcnRzLmRvZ0luc2NyaWJlID0gZG9nSW5zY3JpYmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2dpbmFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/doginals.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js':
    /*!**********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/index.js ***!
  \**********************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.message = exports.wif = void 0;\n__exportStar(__webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js"), exports);\n__exportStar(__webpack_require__(/*! ./bitcoincash */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoincash/index.js"), exports);\n__exportStar(__webpack_require__(/*! ./txBuild */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js"), exports);\n__exportStar(__webpack_require__(/*! ./type */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/type.js"), exports);\nexports.wif = __importStar(__webpack_require__(/*! ./wif */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wif.js"));\n__exportStar(__webpack_require__(/*! ./src20 */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/src20.js"), exports);\n__exportStar(__webpack_require__(/*! ./inscribe */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/inscribe.js"), exports);\n__exportStar(__webpack_require__(/*! ./doginals */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/doginals.js"), exports);\n__exportStar(__webpack_require__(/*! ./psbtSign */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/psbtSign.js"), exports);\nexports.message = __importStar(__webpack_require__(/*! ./message */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/message.js"));\n__exportStar(__webpack_require__(/*! ./wallet/index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/index.js"), exports);\n__exportStar(__webpack_require__(/*! ./onekey */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/onekey.js"), exports);\n__exportStar(__webpack_require__(/*! ./common */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/common.js"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxXQUFXO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQywrRkFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLDJGQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyw2RUFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsdUVBQVE7QUFDN0IsV0FBVyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBTztBQUMxQyxhQUFhLG1CQUFPLENBQUMseUVBQVM7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywrRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsK0VBQVk7QUFDakMsZUFBZSxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNsRCxhQUFhLG1CQUFPLENBQUMsdUZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQywyRUFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsMkVBQVU7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9pbmRleC5qcz85N2ZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tZXNzYWdlID0gZXhwb3J0cy53aWYgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYml0Y29pbmNhc2hcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R4QnVpbGRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVcIiksIGV4cG9ydHMpO1xuZXhwb3J0cy53aWYgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vd2lmXCIpKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMyMFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5zY3JpYmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RvZ2luYWxzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wc2J0U2lnblwiKSwgZXhwb3J0cyk7XG5leHBvcnRzLm1lc3NhZ2UgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbWVzc2FnZVwiKSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2FsbGV0L2luZGV4XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vbmVrZXlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbW1vblwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/inscribe.js':
    /*!*************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/inscribe.js ***!
  \*************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.inscribeForMPCSigned = exports.inscribeForMPCUnsigned = exports.inscribe = exports.InscriptionTool = void 0;\nconst bitcoin = __importStar(__webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js"));\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst taproot = __importStar(__webpack_require__(/*! ./taproot */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/taproot.js"));\nconst bcrypto = __importStar(__webpack_require__(/*! ./bitcoinjs-lib/crypto */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js"));\nconst transaction_1 = __webpack_require__(/*! ./bitcoinjs-lib/transaction */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/transaction.js");\nconst txBuild_1 = __webpack_require__(/*! ./txBuild */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js");\nconst psbtutils_1 = __webpack_require__(/*! ./bitcoinjs-lib/psbt/psbtutils */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/psbtutils.js");\nconst sigcost_1 = __webpack_require__(/*! ./sigcost */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/sigcost.js");\nconst schnorr = crypto_lib_1.signUtil.schnorr.secp256k1.schnorr;\nconst defaultTxVersion = 2;\nconst defaultSequenceNum = 0xfffffffd;\nconst defaultRevealOutValue = 546;\nconst defaultMinChangeValue = 546;\nconst maxStandardTxWeight = 4000000 / 10;\nclass InscriptionTool {\n    constructor() {\n        this.network = bitcoin.networks.bitcoin;\n        this.inscriptionTxCtxDataList = [];\n        this.revealTxs = [];\n        this.commitTx = new bitcoin.Transaction();\n        this.commitTxPrevOutputFetcher = [];\n        this.revealTxPrevOutputFetcher = [];\n        this.mustCommitTxFee = 0;\n        this.mustRevealTxFees = [];\n        this.commitAddrs = [];\n    }\n    static newInscriptionTool(network, request) {\n        const tool = new InscriptionTool();\n        tool.network = network;\n        const revealOutValue = request.revealOutValue || defaultRevealOutValue;\n        const minChangeValue = request.minChangeValue || defaultMinChangeValue;\n        const privateKey = request.commitTxPrevOutputList[0].privateKey;\n        request.inscriptionDataList.forEach(inscriptionData => {\n            tool.inscriptionTxCtxDataList.push(createInscriptionTxCtxData(network, inscriptionData, privateKey));\n        });\n        const totalRevealPrevOutputValue = tool.buildEmptyRevealTx(network, revealOutValue, request.revealFeeRate);\n        const insufficient = tool.buildCommitTx(network, request.commitTxPrevOutputList, request.changeAddress, totalRevealPrevOutputValue, request.commitFeeRate, minChangeValue);\n        if (insufficient) {\n            return tool;\n        }\n        tool.signCommitTx(request.commitTxPrevOutputList);\n        tool.completeRevealTx();\n        return tool;\n    }\n    buildEmptyRevealTx(network, revealOutValue, revealFeeRate) {\n        let totalPrevOutputValue = 0;\n        const revealTxs = [];\n        const mustRevealTxFees = [];\n        const commitAddrs = [];\n        this.inscriptionTxCtxDataList.forEach((inscriptionTxCtxData, i) => {\n            const tx = new bitcoin.Transaction();\n            tx.version = defaultTxVersion;\n            tx.addInput(Buffer.alloc(32), i, defaultSequenceNum);\n            tx.addOutput(inscriptionTxCtxData.revealPkScript, revealOutValue);\n            const emptySignature = Buffer.alloc(64);\n            const emptyControlBlockWitness = Buffer.alloc(33);\n            const txWitness = [];\n            txWitness.push(emptySignature);\n            txWitness.push(inscriptionTxCtxData.inscriptionScript);\n            txWitness.push(emptyControlBlockWitness);\n            const fee = Math.floor((tx.byteLength() + Math.floor(((0, transaction_1.vectorSize)(txWitness) + 2 + 3) / 4)) * revealFeeRate);\n            const prevOutputValue = revealOutValue + fee;\n            inscriptionTxCtxData.revealTxPrevOutput = {\n                pkScript: inscriptionTxCtxData.commitTxAddressPkScript,\n                value: prevOutputValue,\n            };\n            totalPrevOutputValue += prevOutputValue;\n            revealTxs.push(tx);\n            mustRevealTxFees.push(fee);\n            commitAddrs.push(inscriptionTxCtxData.commitTxAddress);\n        });\n        this.revealTxs = revealTxs;\n        this.mustRevealTxFees = mustRevealTxFees;\n        this.commitAddrs = commitAddrs;\n        return totalPrevOutputValue;\n    }\n    buildCommitTx(network, commitTxPrevOutputList, changeAddress, totalRevealPrevOutputValue, commitFeeRate, minChangeValue) {\n        let totalSenderAmount = 0;\n        const tx = new bitcoin.Transaction();\n        tx.version = defaultTxVersion;\n        commitTxPrevOutputList.forEach(commitTxPrevOutput => {\n            const hash = crypto_lib_1.base.reverseBuffer(crypto_lib_1.base.fromHex(commitTxPrevOutput.txId));\n            tx.addInput(hash, commitTxPrevOutput.vOut, defaultSequenceNum);\n            this.commitTxPrevOutputFetcher.push(commitTxPrevOutput.amount);\n            totalSenderAmount += commitTxPrevOutput.amount;\n        });\n        this.inscriptionTxCtxDataList.forEach(inscriptionTxCtxData => {\n            tx.addOutput(inscriptionTxCtxData.revealTxPrevOutput.pkScript, inscriptionTxCtxData.revealTxPrevOutput.value);\n        });\n        const changePkScript = bitcoin.address.toOutputScript(changeAddress, network);\n        tx.addOutput(changePkScript, 0);\n        const txForEstimate = tx.clone();\n        signTx(txForEstimate, commitTxPrevOutputList, this.network);\n        const vsize = (0, sigcost_1.countAdjustedVsize)(txForEstimate, commitTxPrevOutputList.map(a => a.address), network);\n        const fee = Math.floor(vsize * commitFeeRate);\n        const changeAmount = totalSenderAmount - totalRevealPrevOutputValue - fee;\n        if (changeAmount >= minChangeValue) {\n            tx.outs[tx.outs.length - 1].value = changeAmount;\n        }\n        else {\n            tx.outs = tx.outs.slice(0, tx.outs.length - 1);\n            txForEstimate.outs = txForEstimate.outs.slice(0, txForEstimate.outs.length - 1);\n            const vsizeWithoutChange = (0, sigcost_1.countAdjustedVsize)(txForEstimate, commitTxPrevOutputList.map(a => a.address), network);\n            const feeWithoutChange = Math.floor(vsizeWithoutChange * commitFeeRate);\n            if (totalSenderAmount - totalRevealPrevOutputValue - feeWithoutChange < 0) {\n                this.mustCommitTxFee = fee;\n                return true;\n            }\n        }\n        this.commitTx = tx;\n        return false;\n    }\n    signCommitTx(commitTxPrevOutputList) {\n        signTx(this.commitTx, commitTxPrevOutputList, this.network);\n    }\n    completeRevealTx() {\n        this.revealTxs.forEach((revealTx, i) => {\n            revealTx.ins[0].hash = this.commitTx.getHash();\n            const prevOutScripts = [this.inscriptionTxCtxDataList[i].revealTxPrevOutput.pkScript];\n            const values = [this.inscriptionTxCtxDataList[i].revealTxPrevOutput.value];\n            this.revealTxPrevOutputFetcher.push(this.inscriptionTxCtxDataList[i].revealTxPrevOutput.value);\n            const hash = revealTx.hashForWitnessV1(0, prevOutScripts, values, bitcoin.Transaction.SIGHASH_DEFAULT, this.inscriptionTxCtxDataList[i].hash);\n            const signature = Buffer.from(schnorr.sign(hash, this.inscriptionTxCtxDataList[i].privateKey, crypto_lib_1.base.randomBytes(32)));\n            revealTx.ins[0].witness = [Buffer.from(signature), ...this.inscriptionTxCtxDataList[i].witness];\n            const revealWeight = revealTx.weight();\n            if (revealWeight > maxStandardTxWeight) {\n                throw new Error(`reveal(index ${i}) transaction weight greater than ${maxStandardTxWeight} (MAX_STANDARD_TX_WEIGHT): ${revealWeight}`);\n            }\n        });\n    }\n    calculateFee() {\n        let commitTxFee = 0;\n        this.commitTx.ins.forEach((_, i) => {\n            commitTxFee += this.commitTxPrevOutputFetcher[i];\n        });\n        this.commitTx.outs.forEach(out => {\n            commitTxFee -= out.value;\n        });\n        let revealTxFees = [];\n        this.revealTxs.forEach((revealTx, i) => {\n            let revealTxFee = 0;\n            revealTxFee += this.revealTxPrevOutputFetcher[i];\n            revealTxFee -= revealTx.outs[0].value;\n            revealTxFees.push(revealTxFee);\n        });\n        return {\n            commitTxFee,\n            revealTxFees,\n        };\n    }\n}\nexports.InscriptionTool = InscriptionTool;\nfunction signTx(tx, commitTxPrevOutputList, network) {\n    tx.ins.forEach((input, i) => {\n        const addressType = (0, txBuild_1.getAddressType)(commitTxPrevOutputList[i].address, network);\n        const privateKey = crypto_lib_1.base.fromHex((0, txBuild_1.privateKeyFromWIF)(commitTxPrevOutputList[i].privateKey, network));\n        const privateKeyHex = crypto_lib_1.base.toHex(privateKey);\n        const publicKey = (0, txBuild_1.private2public)(privateKeyHex);\n        if (addressType === \'segwit_taproot\') {\n            const prevOutScripts = commitTxPrevOutputList.map(o => bitcoin.address.toOutputScript(o.address, network));\n            const values = commitTxPrevOutputList.map(o => o.amount);\n            const hash = tx.hashForWitnessV1(i, prevOutScripts, values, bitcoin.Transaction.SIGHASH_DEFAULT);\n            const tweakedPrivKey = taproot.taprootTweakPrivKey(privateKey);\n            const signature = Buffer.from(schnorr.sign(hash, tweakedPrivKey, crypto_lib_1.base.randomBytes(32)));\n            input.witness = [Buffer.from(signature)];\n        }\n        else if (addressType === \'legacy\') {\n            const prevScript = bitcoin.address.toOutputScript(commitTxPrevOutputList[i].address, network);\n            const hash = tx.hashForSignature(i, prevScript, bitcoin.Transaction.SIGHASH_ALL);\n            const signature = (0, txBuild_1.sign)(hash, privateKeyHex);\n            const payment = bitcoin.payments.p2pkh({\n                signature: bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL),\n                pubkey: publicKey,\n            });\n            input.script = payment.input;\n        }\n        else {\n            const pubKeyHash = bcrypto.hash160(publicKey);\n            const prevOutScript = Buffer.of(0x19, 0x76, 0xa9, 0x14, ...pubKeyHash, 0x88, 0xac);\n            const value = commitTxPrevOutputList[i].amount;\n            const hash = tx.hashForWitness(i, prevOutScript, value, bitcoin.Transaction.SIGHASH_ALL);\n            const signature = (0, txBuild_1.sign)(hash, privateKeyHex);\n            input.witness = [\n                bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL),\n                publicKey,\n            ];\n            const redeemScript = Buffer.of(0x16, 0, 20, ...pubKeyHash);\n            if (addressType === "segwit_nested") {\n                input.script = redeemScript;\n            }\n        }\n    });\n}\nfunction createInscriptionTxCtxData(network, inscriptionData, privateKeyWif) {\n    const privateKey = crypto_lib_1.base.fromHex((0, txBuild_1.privateKeyFromWIF)(privateKeyWif, network));\n    const internalPubKey = (0, txBuild_1.wif2Public)(privateKeyWif, network).slice(1);\n    const ops = bitcoin.script.OPS;\n    const inscriptionBuilder = [];\n    inscriptionBuilder.push(internalPubKey);\n    inscriptionBuilder.push(ops.OP_CHECKSIG);\n    inscriptionBuilder.push(ops.OP_FALSE);\n    inscriptionBuilder.push(ops.OP_IF);\n    inscriptionBuilder.push(Buffer.from("ord"));\n    inscriptionBuilder.push(ops.OP_DATA_1);\n    inscriptionBuilder.push(ops.OP_DATA_1);\n    inscriptionBuilder.push(Buffer.from(inscriptionData.contentType));\n    inscriptionBuilder.push(ops.OP_0);\n    const maxChunkSize = 520;\n    let body = Buffer.from(inscriptionData.body);\n    let bodySize = body.length;\n    for (let i = 0; i < bodySize; i += maxChunkSize) {\n        let end = i + maxChunkSize;\n        if (end > bodySize) {\n            end = bodySize;\n        }\n        inscriptionBuilder.push(body.slice(i, end));\n    }\n    inscriptionBuilder.push(ops.OP_ENDIF);\n    const inscriptionScript = bitcoin.script.compile(inscriptionBuilder);\n    const scriptTree = {\n        output: inscriptionScript,\n    };\n    const redeem = {\n        output: inscriptionScript,\n        redeemVersion: 0xc0,\n    };\n    const { output, witness, hash, address } = bitcoin.payments.p2tr({\n        internalPubkey: internalPubKey,\n        scriptTree,\n        redeem,\n        network,\n    });\n    return {\n        privateKey,\n        inscriptionScript,\n        commitTxAddress: address,\n        commitTxAddressPkScript: output,\n        witness: witness,\n        hash: hash,\n        revealTxPrevOutput: {\n            pkScript: Buffer.alloc(0),\n            value: 0,\n        },\n        revealPkScript: bitcoin.address.toOutputScript(inscriptionData.revealAddr, network),\n    };\n}\nfunction inscribe(network, request) {\n    const tool = InscriptionTool.newInscriptionTool(network, request);\n    if (tool.mustCommitTxFee > 0) {\n        return {\n            commitTx: "",\n            revealTxs: [],\n            commitTxFee: tool.mustCommitTxFee,\n            revealTxFees: tool.mustRevealTxFees,\n            commitAddrs: tool.commitAddrs,\n        };\n    }\n    return {\n        commitTx: tool.commitTx.toHex(),\n        revealTxs: tool.revealTxs.map(revealTx => revealTx.toHex()),\n        ...tool.calculateFee(),\n        commitAddrs: tool.commitAddrs,\n    };\n}\nexports.inscribe = inscribe;\nfunction inscribeForMPCUnsigned(request, network, unsignedCommitTxHash, signedCommitTxHash) {\n    const privateKey = request.commitTxPrevOutputList[0].privateKey;\n    const scriptCtxList = [];\n    request.inscriptionDataList.forEach(inscriptionData => {\n        scriptCtxList.push(createInscriptionTxCtxData(network, inscriptionData, privateKey));\n    });\n    let totalRevealInValue = 0;\n    const revealOutValue = request.revealOutValue || defaultRevealOutValue;\n    const revealTxList = [];\n    scriptCtxList.forEach((ctx, i) => {\n        const tx = new bitcoin.Transaction();\n        tx.version = defaultTxVersion;\n        tx.addInput(Buffer.alloc(32), i, defaultSequenceNum);\n        tx.addOutput(ctx.revealPkScript, revealOutValue);\n        revealTxList.push(tx);\n        const emptySignature = Buffer.alloc(64);\n        const emptyControlBlockWitness = Buffer.alloc(33);\n        const txWitness = [];\n        txWitness.push(emptySignature);\n        txWitness.push(ctx.inscriptionScript);\n        txWitness.push(emptyControlBlockWitness);\n        const revealFee = Math.floor((tx.byteLength() + Math.floor(((0, transaction_1.vectorSize)(txWitness) + 2 + 3) / 4)) * request.revealFeeRate);\n        const revealInValue = revealOutValue + revealFee;\n        ctx.revealTxPrevOutput = {\n            pkScript: ctx.commitTxAddressPkScript,\n            value: revealInValue,\n        };\n        totalRevealInValue += revealInValue;\n    });\n    let totalCommitInValue = 0;\n    const commitTx = new bitcoin.Transaction();\n    commitTx.version = defaultTxVersion;\n    request.commitTxPrevOutputList.forEach(uxto => {\n        commitTx.addInput(crypto_lib_1.base.reverseBuffer(crypto_lib_1.base.fromHex(uxto.txId)), uxto.vOut, defaultSequenceNum);\n        totalCommitInValue += uxto.amount;\n    });\n    const commitAddrs = [];\n    scriptCtxList.forEach(ctx => {\n        commitTx.addOutput(ctx.revealTxPrevOutput.pkScript, ctx.revealTxPrevOutput.value);\n        commitAddrs.push(ctx.commitTxAddress);\n    });\n    const changePkScript = bitcoin.address.toOutputScript(request.changeAddress, network);\n    commitTx.addOutput(changePkScript, 0);\n    const estimateTx = commitTx.clone();\n    signTx(estimateTx, request.commitTxPrevOutputList, network);\n    const vsize = (0, sigcost_1.countAdjustedVsize)(estimateTx, request.commitTxPrevOutputList.map(a => a.address), network);\n    const fee = Math.floor(vsize * request.commitFeeRate);\n    const changeValue = totalCommitInValue - totalRevealInValue - fee;\n    if (changeValue >= (request.minChangeValue || defaultMinChangeValue)) {\n        commitTx.outs[commitTx.outs.length - 1].value = changeValue;\n    }\n    else {\n        commitTx.outs = commitTx.outs.slice(0, commitTx.outs.length - 1);\n        estimateTx.outs = estimateTx.outs.slice(0, estimateTx.outs.length - 1);\n        const vsizeWithoutChange = (0, sigcost_1.countAdjustedVsize)(estimateTx, request.commitTxPrevOutputList.map(a => a.address), network);\n        const feeWithoutChange = Math.floor(vsizeWithoutChange * request.commitFeeRate);\n        if (totalCommitInValue - totalRevealInValue - feeWithoutChange < 0) {\n            throw new Error("insufficient balance");\n        }\n    }\n    const sigHashList = calculateSigHash(commitTx, request.commitTxPrevOutputList, network);\n    let commitTxHash = commitTx.getHash();\n    if (signedCommitTxHash) {\n        commitTxHash = signedCommitTxHash;\n    }\n    revealTxList.forEach((revealTx, i) => {\n        revealTx.ins[0].hash = commitTxHash;\n        const prevOutScripts = [scriptCtxList[i].revealTxPrevOutput.pkScript];\n        const values = [scriptCtxList[i].revealTxPrevOutput.value];\n        const sigHash = revealTx.hashForWitnessV1(0, prevOutScripts, values, bitcoin.Transaction.SIGHASH_DEFAULT, scriptCtxList[i].hash);\n        const signature = Buffer.from(schnorr.sign(sigHash, scriptCtxList[i].privateKey, crypto_lib_1.base.randomBytes(32)));\n        revealTx.ins[0].witness = [signature, ...scriptCtxList[i].witness];\n    });\n    let commitTxFee = 0;\n    commitTx.ins.forEach((_, i) => {\n        commitTxFee += request.commitTxPrevOutputList[i].amount;\n    });\n    commitTx.outs.forEach(out => {\n        commitTxFee -= out.value;\n    });\n    let revealTxFees = [];\n    revealTxList.forEach((revealTx, i) => {\n        let revealTxFee = 0;\n        revealTxFee += scriptCtxList[i].revealTxPrevOutput.value;\n        revealTxFee -= revealTx.outs[0].value;\n        revealTxFees.push(revealTxFee);\n    });\n    return {\n        signHashList: sigHashList,\n        commitTx: commitTx.toHex(),\n        revealTxs: revealTxList.map(e => e.toHex()),\n        commitTxFee: commitTxFee,\n        revealTxFees: revealTxFees,\n        commitAddrs: commitAddrs,\n    };\n}\nexports.inscribeForMPCUnsigned = inscribeForMPCUnsigned;\nfunction inscribeForMPCSigned(request, network) {\n    const unsignedCommitTxHex = request.commitTx;\n    const signatures = request.signatureList;\n    const tx = bitcoin.Transaction.fromHex(unsignedCommitTxHex);\n    const unsignedCommitTxHash = tx.getHash();\n    tx.ins.forEach((input, i) => {\n        const signature = crypto_lib_1.base.fromHex(signatures[i]);\n        if (!input.witness) {\n            input.script = bitcoin.payments.p2pkh({\n                pubkey: bitcoin.payments.p2pkh({ input: input.script }).pubkey,\n                signature: bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL),\n            }).input;\n        }\n        else {\n            input.witness[0] = bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL);\n        }\n    });\n    const signedCommitTxHash = tx.getHash();\n    const res = inscribeForMPCUnsigned(request, network, unsignedCommitTxHash, signedCommitTxHash);\n    return {\n        signHashList: null,\n        commitTx: tx.toHex(),\n        revealTxs: res.revealTxs,\n        commitTxFee: res.commitTxFee,\n        revealTxFees: res.revealTxFees,\n        commitAddrs: res.commitAddrs,\n    };\n}\nexports.inscribeForMPCSigned = inscribeForMPCSigned;\nfunction calculateSigHash(tx, prevOutFetcher, network) {\n    const sigHashList = [];\n    tx.ins.forEach((input, i) => {\n        const publicKey = crypto_lib_1.base.fromHex(prevOutFetcher[i].publicKey);\n        const pkScript = bitcoin.address.toOutputScript(prevOutFetcher[i].address, network);\n        const placeholderSignature = Buffer.alloc(64, 0);\n        let sigHash;\n        if ((0, psbtutils_1.isP2TR)(pkScript)) {\n            const prevOutScripts = prevOutFetcher.map(o => bitcoin.address.toOutputScript(o.address, network));\n            const values = prevOutFetcher.map(o => o.amount);\n            sigHash = tx.hashForWitnessV1(i, prevOutScripts, values, bitcoin.Transaction.SIGHASH_DEFAULT);\n            input.witness = [placeholderSignature];\n        }\n        else if ((0, psbtutils_1.isP2PKH)(pkScript)) {\n            const prevScript = bitcoin.address.toOutputScript(prevOutFetcher[i].address, network);\n            sigHash = tx.hashForSignature(i, prevScript, bitcoin.Transaction.SIGHASH_ALL);\n            input.script = bitcoin.payments.p2pkh({\n                pubkey: publicKey,\n                signature: bitcoin.script.signature.encode(placeholderSignature, bitcoin.Transaction.SIGHASH_ALL),\n            }).input;\n        }\n        else {\n            const pubKeyHash = bcrypto.hash160(publicKey);\n            const prevOutScript = Buffer.of(0x19, 0x76, 0xa9, 0x14, ...pubKeyHash, 0x88, 0xac);\n            sigHash = tx.hashForWitness(i, prevOutScript, prevOutFetcher[i].amount, bitcoin.Transaction.SIGHASH_ALL);\n            input.witness = bitcoin.payments.p2wpkh({\n                pubkey: publicKey,\n                signature: bitcoin.script.signature.encode(placeholderSignature, bitcoin.Transaction.SIGHASH_ALL),\n            }).witness;\n            const redeemScript = Buffer.of(0x16, 0, 20, ...pubKeyHash);\n            if ((0, psbtutils_1.isP2SHScript)(pkScript)) {\n                input.script = redeemScript;\n            }\n        }\n        sigHashList.push(crypto_lib_1.base.toHex(sigHash));\n    });\n    return sigHashList;\n}\n//# sourceMappingURL=inscribe.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvaW5zY3JpYmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDhCQUE4QixHQUFHLGdCQUFnQixHQUFHLHVCQUF1QjtBQUMxRyw2QkFBNkIsbUJBQU8sQ0FBQywrRkFBaUI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xELDZCQUE2QixtQkFBTyxDQUFDLDZFQUFXO0FBQ2hELDZCQUE2QixtQkFBTyxDQUFDLHVHQUF3QjtBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQyxpSEFBNkI7QUFDM0Qsa0JBQWtCLG1CQUFPLENBQUMsNkVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsdUhBQWdDO0FBQzVELGtCQUFrQixtQkFBTyxDQUFDLDZFQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRSxvQ0FBb0MscUJBQXFCLDRCQUE0QixhQUFhO0FBQ3BKO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9pbnNjcmliZS5qcz9lZTMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluc2NyaWJlRm9yTVBDU2lnbmVkID0gZXhwb3J0cy5pbnNjcmliZUZvck1QQ1Vuc2lnbmVkID0gZXhwb3J0cy5pbnNjcmliZSA9IGV4cG9ydHMuSW5zY3JpcHRpb25Ub29sID0gdm9pZCAwO1xuY29uc3QgYml0Y29pbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iaXRjb2luanMtbGliXCIpKTtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuY29uc3QgdGFwcm9vdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi90YXByb290XCIpKTtcbmNvbnN0IGJjcnlwdG8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYi9jcnlwdG9cIikpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWIvdHJhbnNhY3Rpb25cIik7XG5jb25zdCB0eEJ1aWxkXzEgPSByZXF1aXJlKFwiLi90eEJ1aWxkXCIpO1xuY29uc3QgcHNidHV0aWxzXzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL3BzYnQvcHNidHV0aWxzXCIpO1xuY29uc3Qgc2lnY29zdF8xID0gcmVxdWlyZShcIi4vc2lnY29zdFwiKTtcbmNvbnN0IHNjaG5vcnIgPSBjcnlwdG9fbGliXzEuc2lnblV0aWwuc2Nobm9yci5zZWNwMjU2azEuc2Nobm9ycjtcbmNvbnN0IGRlZmF1bHRUeFZlcnNpb24gPSAyO1xuY29uc3QgZGVmYXVsdFNlcXVlbmNlTnVtID0gMHhmZmZmZmZmZDtcbmNvbnN0IGRlZmF1bHRSZXZlYWxPdXRWYWx1ZSA9IDU0NjtcbmNvbnN0IGRlZmF1bHRNaW5DaGFuZ2VWYWx1ZSA9IDU0NjtcbmNvbnN0IG1heFN0YW5kYXJkVHhXZWlnaHQgPSA0MDAwMDAwIC8gMTA7XG5jbGFzcyBJbnNjcmlwdGlvblRvb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm5ldHdvcmsgPSBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW47XG4gICAgICAgIHRoaXMuaW5zY3JpcHRpb25UeEN0eERhdGFMaXN0ID0gW107XG4gICAgICAgIHRoaXMucmV2ZWFsVHhzID0gW107XG4gICAgICAgIHRoaXMuY29tbWl0VHggPSBuZXcgYml0Y29pbi5UcmFuc2FjdGlvbigpO1xuICAgICAgICB0aGlzLmNvbW1pdFR4UHJldk91dHB1dEZldGNoZXIgPSBbXTtcbiAgICAgICAgdGhpcy5yZXZlYWxUeFByZXZPdXRwdXRGZXRjaGVyID0gW107XG4gICAgICAgIHRoaXMubXVzdENvbW1pdFR4RmVlID0gMDtcbiAgICAgICAgdGhpcy5tdXN0UmV2ZWFsVHhGZWVzID0gW107XG4gICAgICAgIHRoaXMuY29tbWl0QWRkcnMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIG5ld0luc2NyaXB0aW9uVG9vbChuZXR3b3JrLCByZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHRvb2wgPSBuZXcgSW5zY3JpcHRpb25Ub29sKCk7XG4gICAgICAgIHRvb2wubmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgIGNvbnN0IHJldmVhbE91dFZhbHVlID0gcmVxdWVzdC5yZXZlYWxPdXRWYWx1ZSB8fCBkZWZhdWx0UmV2ZWFsT3V0VmFsdWU7XG4gICAgICAgIGNvbnN0IG1pbkNoYW5nZVZhbHVlID0gcmVxdWVzdC5taW5DaGFuZ2VWYWx1ZSB8fCBkZWZhdWx0TWluQ2hhbmdlVmFsdWU7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSByZXF1ZXN0LmNvbW1pdFR4UHJldk91dHB1dExpc3RbMF0ucHJpdmF0ZUtleTtcbiAgICAgICAgcmVxdWVzdC5pbnNjcmlwdGlvbkRhdGFMaXN0LmZvckVhY2goaW5zY3JpcHRpb25EYXRhID0+IHtcbiAgICAgICAgICAgIHRvb2wuaW5zY3JpcHRpb25UeEN0eERhdGFMaXN0LnB1c2goY3JlYXRlSW5zY3JpcHRpb25UeEN0eERhdGEobmV0d29yaywgaW5zY3JpcHRpb25EYXRhLCBwcml2YXRlS2V5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b3RhbFJldmVhbFByZXZPdXRwdXRWYWx1ZSA9IHRvb2wuYnVpbGRFbXB0eVJldmVhbFR4KG5ldHdvcmssIHJldmVhbE91dFZhbHVlLCByZXF1ZXN0LnJldmVhbEZlZVJhdGUpO1xuICAgICAgICBjb25zdCBpbnN1ZmZpY2llbnQgPSB0b29sLmJ1aWxkQ29tbWl0VHgobmV0d29yaywgcmVxdWVzdC5jb21taXRUeFByZXZPdXRwdXRMaXN0LCByZXF1ZXN0LmNoYW5nZUFkZHJlc3MsIHRvdGFsUmV2ZWFsUHJldk91dHB1dFZhbHVlLCByZXF1ZXN0LmNvbW1pdEZlZVJhdGUsIG1pbkNoYW5nZVZhbHVlKTtcbiAgICAgICAgaWYgKGluc3VmZmljaWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbC5zaWduQ29tbWl0VHgocmVxdWVzdC5jb21taXRUeFByZXZPdXRwdXRMaXN0KTtcbiAgICAgICAgdG9vbC5jb21wbGV0ZVJldmVhbFR4KCk7XG4gICAgICAgIHJldHVybiB0b29sO1xuICAgIH1cbiAgICBidWlsZEVtcHR5UmV2ZWFsVHgobmV0d29yaywgcmV2ZWFsT3V0VmFsdWUsIHJldmVhbEZlZVJhdGUpIHtcbiAgICAgICAgbGV0IHRvdGFsUHJldk91dHB1dFZhbHVlID0gMDtcbiAgICAgICAgY29uc3QgcmV2ZWFsVHhzID0gW107XG4gICAgICAgIGNvbnN0IG11c3RSZXZlYWxUeEZlZXMgPSBbXTtcbiAgICAgICAgY29uc3QgY29tbWl0QWRkcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3QuZm9yRWFjaCgoaW5zY3JpcHRpb25UeEN0eERhdGEsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gbmV3IGJpdGNvaW4uVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIHR4LnZlcnNpb24gPSBkZWZhdWx0VHhWZXJzaW9uO1xuICAgICAgICAgICAgdHguYWRkSW5wdXQoQnVmZmVyLmFsbG9jKDMyKSwgaSwgZGVmYXVsdFNlcXVlbmNlTnVtKTtcbiAgICAgICAgICAgIHR4LmFkZE91dHB1dChpbnNjcmlwdGlvblR4Q3R4RGF0YS5yZXZlYWxQa1NjcmlwdCwgcmV2ZWFsT3V0VmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgZW1wdHlTaWduYXR1cmUgPSBCdWZmZXIuYWxsb2MoNjQpO1xuICAgICAgICAgICAgY29uc3QgZW1wdHlDb250cm9sQmxvY2tXaXRuZXNzID0gQnVmZmVyLmFsbG9jKDMzKTtcbiAgICAgICAgICAgIGNvbnN0IHR4V2l0bmVzcyA9IFtdO1xuICAgICAgICAgICAgdHhXaXRuZXNzLnB1c2goZW1wdHlTaWduYXR1cmUpO1xuICAgICAgICAgICAgdHhXaXRuZXNzLnB1c2goaW5zY3JpcHRpb25UeEN0eERhdGEuaW5zY3JpcHRpb25TY3JpcHQpO1xuICAgICAgICAgICAgdHhXaXRuZXNzLnB1c2goZW1wdHlDb250cm9sQmxvY2tXaXRuZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZSA9IE1hdGguZmxvb3IoKHR4LmJ5dGVMZW5ndGgoKSArIE1hdGguZmxvb3IoKCgwLCB0cmFuc2FjdGlvbl8xLnZlY3RvclNpemUpKHR4V2l0bmVzcykgKyAyICsgMykgLyA0KSkgKiByZXZlYWxGZWVSYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZPdXRwdXRWYWx1ZSA9IHJldmVhbE91dFZhbHVlICsgZmVlO1xuICAgICAgICAgICAgaW5zY3JpcHRpb25UeEN0eERhdGEucmV2ZWFsVHhQcmV2T3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIHBrU2NyaXB0OiBpbnNjcmlwdGlvblR4Q3R4RGF0YS5jb21taXRUeEFkZHJlc3NQa1NjcmlwdCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJldk91dHB1dFZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRvdGFsUHJldk91dHB1dFZhbHVlICs9IHByZXZPdXRwdXRWYWx1ZTtcbiAgICAgICAgICAgIHJldmVhbFR4cy5wdXNoKHR4KTtcbiAgICAgICAgICAgIG11c3RSZXZlYWxUeEZlZXMucHVzaChmZWUpO1xuICAgICAgICAgICAgY29tbWl0QWRkcnMucHVzaChpbnNjcmlwdGlvblR4Q3R4RGF0YS5jb21taXRUeEFkZHJlc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXZlYWxUeHMgPSByZXZlYWxUeHM7XG4gICAgICAgIHRoaXMubXVzdFJldmVhbFR4RmVlcyA9IG11c3RSZXZlYWxUeEZlZXM7XG4gICAgICAgIHRoaXMuY29tbWl0QWRkcnMgPSBjb21taXRBZGRycztcbiAgICAgICAgcmV0dXJuIHRvdGFsUHJldk91dHB1dFZhbHVlO1xuICAgIH1cbiAgICBidWlsZENvbW1pdFR4KG5ldHdvcmssIGNvbW1pdFR4UHJldk91dHB1dExpc3QsIGNoYW5nZUFkZHJlc3MsIHRvdGFsUmV2ZWFsUHJldk91dHB1dFZhbHVlLCBjb21taXRGZWVSYXRlLCBtaW5DaGFuZ2VWYWx1ZSkge1xuICAgICAgICBsZXQgdG90YWxTZW5kZXJBbW91bnQgPSAwO1xuICAgICAgICBjb25zdCB0eCA9IG5ldyBiaXRjb2luLlRyYW5zYWN0aW9uKCk7XG4gICAgICAgIHR4LnZlcnNpb24gPSBkZWZhdWx0VHhWZXJzaW9uO1xuICAgICAgICBjb21taXRUeFByZXZPdXRwdXRMaXN0LmZvckVhY2goY29tbWl0VHhQcmV2T3V0cHV0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG9fbGliXzEuYmFzZS5yZXZlcnNlQnVmZmVyKGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoY29tbWl0VHhQcmV2T3V0cHV0LnR4SWQpKTtcbiAgICAgICAgICAgIHR4LmFkZElucHV0KGhhc2gsIGNvbW1pdFR4UHJldk91dHB1dC52T3V0LCBkZWZhdWx0U2VxdWVuY2VOdW0pO1xuICAgICAgICAgICAgdGhpcy5jb21taXRUeFByZXZPdXRwdXRGZXRjaGVyLnB1c2goY29tbWl0VHhQcmV2T3V0cHV0LmFtb3VudCk7XG4gICAgICAgICAgICB0b3RhbFNlbmRlckFtb3VudCArPSBjb21taXRUeFByZXZPdXRwdXQuYW1vdW50O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3QuZm9yRWFjaChpbnNjcmlwdGlvblR4Q3R4RGF0YSA9PiB7XG4gICAgICAgICAgICB0eC5hZGRPdXRwdXQoaW5zY3JpcHRpb25UeEN0eERhdGEucmV2ZWFsVHhQcmV2T3V0cHV0LnBrU2NyaXB0LCBpbnNjcmlwdGlvblR4Q3R4RGF0YS5yZXZlYWxUeFByZXZPdXRwdXQudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhbmdlUGtTY3JpcHQgPSBiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQoY2hhbmdlQWRkcmVzcywgbmV0d29yayk7XG4gICAgICAgIHR4LmFkZE91dHB1dChjaGFuZ2VQa1NjcmlwdCwgMCk7XG4gICAgICAgIGNvbnN0IHR4Rm9yRXN0aW1hdGUgPSB0eC5jbG9uZSgpO1xuICAgICAgICBzaWduVHgodHhGb3JFc3RpbWF0ZSwgY29tbWl0VHhQcmV2T3V0cHV0TGlzdCwgdGhpcy5uZXR3b3JrKTtcbiAgICAgICAgY29uc3QgdnNpemUgPSAoMCwgc2lnY29zdF8xLmNvdW50QWRqdXN0ZWRWc2l6ZSkodHhGb3JFc3RpbWF0ZSwgY29tbWl0VHhQcmV2T3V0cHV0TGlzdC5tYXAoYSA9PiBhLmFkZHJlc3MpLCBuZXR3b3JrKTtcbiAgICAgICAgY29uc3QgZmVlID0gTWF0aC5mbG9vcih2c2l6ZSAqIGNvbW1pdEZlZVJhdGUpO1xuICAgICAgICBjb25zdCBjaGFuZ2VBbW91bnQgPSB0b3RhbFNlbmRlckFtb3VudCAtIHRvdGFsUmV2ZWFsUHJldk91dHB1dFZhbHVlIC0gZmVlO1xuICAgICAgICBpZiAoY2hhbmdlQW1vdW50ID49IG1pbkNoYW5nZVZhbHVlKSB7XG4gICAgICAgICAgICB0eC5vdXRzW3R4Lm91dHMubGVuZ3RoIC0gMV0udmFsdWUgPSBjaGFuZ2VBbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eC5vdXRzID0gdHgub3V0cy5zbGljZSgwLCB0eC5vdXRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgdHhGb3JFc3RpbWF0ZS5vdXRzID0gdHhGb3JFc3RpbWF0ZS5vdXRzLnNsaWNlKDAsIHR4Rm9yRXN0aW1hdGUub3V0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IHZzaXplV2l0aG91dENoYW5nZSA9ICgwLCBzaWdjb3N0XzEuY291bnRBZGp1c3RlZFZzaXplKSh0eEZvckVzdGltYXRlLCBjb21taXRUeFByZXZPdXRwdXRMaXN0Lm1hcChhID0+IGEuYWRkcmVzcyksIG5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgZmVlV2l0aG91dENoYW5nZSA9IE1hdGguZmxvb3IodnNpemVXaXRob3V0Q2hhbmdlICogY29tbWl0RmVlUmF0ZSk7XG4gICAgICAgICAgICBpZiAodG90YWxTZW5kZXJBbW91bnQgLSB0b3RhbFJldmVhbFByZXZPdXRwdXRWYWx1ZSAtIGZlZVdpdGhvdXRDaGFuZ2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXN0Q29tbWl0VHhGZWUgPSBmZWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21taXRUeCA9IHR4O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNpZ25Db21taXRUeChjb21taXRUeFByZXZPdXRwdXRMaXN0KSB7XG4gICAgICAgIHNpZ25UeCh0aGlzLmNvbW1pdFR4LCBjb21taXRUeFByZXZPdXRwdXRMaXN0LCB0aGlzLm5ldHdvcmspO1xuICAgIH1cbiAgICBjb21wbGV0ZVJldmVhbFR4KCkge1xuICAgICAgICB0aGlzLnJldmVhbFR4cy5mb3JFYWNoKChyZXZlYWxUeCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV2ZWFsVHguaW5zWzBdLmhhc2ggPSB0aGlzLmNvbW1pdFR4LmdldEhhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZPdXRTY3JpcHRzID0gW3RoaXMuaW5zY3JpcHRpb25UeEN0eERhdGFMaXN0W2ldLnJldmVhbFR4UHJldk91dHB1dC5wa1NjcmlwdF07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbdGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3RbaV0ucmV2ZWFsVHhQcmV2T3V0cHV0LnZhbHVlXTtcbiAgICAgICAgICAgIHRoaXMucmV2ZWFsVHhQcmV2T3V0cHV0RmV0Y2hlci5wdXNoKHRoaXMuaW5zY3JpcHRpb25UeEN0eERhdGFMaXN0W2ldLnJldmVhbFR4UHJldk91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gcmV2ZWFsVHguaGFzaEZvcldpdG5lc3NWMSgwLCBwcmV2T3V0U2NyaXB0cywgdmFsdWVzLCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCwgdGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3RbaV0uaGFzaCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzY2hub3JyLnNpZ24oaGFzaCwgdGhpcy5pbnNjcmlwdGlvblR4Q3R4RGF0YUxpc3RbaV0ucHJpdmF0ZUtleSwgY3J5cHRvX2xpYl8xLmJhc2UucmFuZG9tQnl0ZXMoMzIpKSk7XG4gICAgICAgICAgICByZXZlYWxUeC5pbnNbMF0ud2l0bmVzcyA9IFtCdWZmZXIuZnJvbShzaWduYXR1cmUpLCAuLi50aGlzLmluc2NyaXB0aW9uVHhDdHhEYXRhTGlzdFtpXS53aXRuZXNzXTtcbiAgICAgICAgICAgIGNvbnN0IHJldmVhbFdlaWdodCA9IHJldmVhbFR4LndlaWdodCgpO1xuICAgICAgICAgICAgaWYgKHJldmVhbFdlaWdodCA+IG1heFN0YW5kYXJkVHhXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJldmVhbChpbmRleCAke2l9KSB0cmFuc2FjdGlvbiB3ZWlnaHQgZ3JlYXRlciB0aGFuICR7bWF4U3RhbmRhcmRUeFdlaWdodH0gKE1BWF9TVEFOREFSRF9UWF9XRUlHSFQpOiAke3JldmVhbFdlaWdodH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUZlZSgpIHtcbiAgICAgICAgbGV0IGNvbW1pdFR4RmVlID0gMDtcbiAgICAgICAgdGhpcy5jb21taXRUeC5pbnMuZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgICAgICAgY29tbWl0VHhGZWUgKz0gdGhpcy5jb21taXRUeFByZXZPdXRwdXRGZXRjaGVyW2ldO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21taXRUeC5vdXRzLmZvckVhY2gob3V0ID0+IHtcbiAgICAgICAgICAgIGNvbW1pdFR4RmVlIC09IG91dC52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXZlYWxUeEZlZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZXZlYWxUeHMuZm9yRWFjaCgocmV2ZWFsVHgsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCByZXZlYWxUeEZlZSA9IDA7XG4gICAgICAgICAgICByZXZlYWxUeEZlZSArPSB0aGlzLnJldmVhbFR4UHJldk91dHB1dEZldGNoZXJbaV07XG4gICAgICAgICAgICByZXZlYWxUeEZlZSAtPSByZXZlYWxUeC5vdXRzWzBdLnZhbHVlO1xuICAgICAgICAgICAgcmV2ZWFsVHhGZWVzLnB1c2gocmV2ZWFsVHhGZWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbW1pdFR4RmVlLFxuICAgICAgICAgICAgcmV2ZWFsVHhGZWVzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5zY3JpcHRpb25Ub29sID0gSW5zY3JpcHRpb25Ub29sO1xuZnVuY3Rpb24gc2lnblR4KHR4LCBjb21taXRUeFByZXZPdXRwdXRMaXN0LCBuZXR3b3JrKSB7XG4gICAgdHguaW5zLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NUeXBlID0gKDAsIHR4QnVpbGRfMS5nZXRBZGRyZXNzVHlwZSkoY29tbWl0VHhQcmV2T3V0cHV0TGlzdFtpXS5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoKDAsIHR4QnVpbGRfMS5wcml2YXRlS2V5RnJvbVdJRikoY29tbWl0VHhQcmV2T3V0cHV0TGlzdFtpXS5wcml2YXRlS2V5LCBuZXR3b3JrKSk7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXlIZXggPSBjcnlwdG9fbGliXzEuYmFzZS50b0hleChwcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gKDAsIHR4QnVpbGRfMS5wcml2YXRlMnB1YmxpYykocHJpdmF0ZUtleUhleCk7XG4gICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gJ3NlZ3dpdF90YXByb290Jykge1xuICAgICAgICAgICAgY29uc3QgcHJldk91dFNjcmlwdHMgPSBjb21taXRUeFByZXZPdXRwdXRMaXN0Lm1hcChvID0+IGJpdGNvaW4uYWRkcmVzcy50b091dHB1dFNjcmlwdChvLmFkZHJlc3MsIG5ldHdvcmspKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGNvbW1pdFR4UHJldk91dHB1dExpc3QubWFwKG8gPT4gby5hbW91bnQpO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHR4Lmhhc2hGb3JXaXRuZXNzVjEoaSwgcHJldk91dFNjcmlwdHMsIHZhbHVlcywgYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQpO1xuICAgICAgICAgICAgY29uc3QgdHdlYWtlZFByaXZLZXkgPSB0YXByb290LnRhcHJvb3RUd2Vha1ByaXZLZXkocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzY2hub3JyLnNpZ24oaGFzaCwgdHdlYWtlZFByaXZLZXksIGNyeXB0b19saWJfMS5iYXNlLnJhbmRvbUJ5dGVzKDMyKSkpO1xuICAgICAgICAgICAgaW5wdXQud2l0bmVzcyA9IFtCdWZmZXIuZnJvbShzaWduYXR1cmUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhZGRyZXNzVHlwZSA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZTY3JpcHQgPSBiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQoY29tbWl0VHhQcmV2T3V0cHV0TGlzdFtpXS5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB0eC5oYXNoRm9yU2lnbmF0dXJlKGksIHByZXZTY3JpcHQsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gKDAsIHR4QnVpbGRfMS5zaWduKShoYXNoLCBwcml2YXRlS2V5SGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHBheW1lbnQgPSBiaXRjb2luLnBheW1lbnRzLnAycGtoKHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGJpdGNvaW4uc2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoc2lnbmF0dXJlLCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMKSxcbiAgICAgICAgICAgICAgICBwdWJrZXk6IHB1YmxpY0tleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5wdXQuc2NyaXB0ID0gcGF5bWVudC5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleUhhc2ggPSBiY3J5cHRvLmhhc2gxNjAocHVibGljS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZPdXRTY3JpcHQgPSBCdWZmZXIub2YoMHgxOSwgMHg3NiwgMHhhOSwgMHgxNCwgLi4ucHViS2V5SGFzaCwgMHg4OCwgMHhhYyk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbW1pdFR4UHJldk91dHB1dExpc3RbaV0uYW1vdW50O1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHR4Lmhhc2hGb3JXaXRuZXNzKGksIHByZXZPdXRTY3JpcHQsIHZhbHVlLCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9ICgwLCB0eEJ1aWxkXzEuc2lnbikoaGFzaCwgcHJpdmF0ZUtleUhleCk7XG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzID0gW1xuICAgICAgICAgICAgICAgIGJpdGNvaW4uc2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoc2lnbmF0dXJlLCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMKSxcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgcmVkZWVtU2NyaXB0ID0gQnVmZmVyLm9mKDB4MTYsIDAsIDIwLCAuLi5wdWJLZXlIYXNoKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gXCJzZWd3aXRfbmVzdGVkXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5zY3JpcHQgPSByZWRlZW1TY3JpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc2NyaXB0aW9uVHhDdHhEYXRhKG5ldHdvcmssIGluc2NyaXB0aW9uRGF0YSwgcHJpdmF0ZUtleVdpZikge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KCgwLCB0eEJ1aWxkXzEucHJpdmF0ZUtleUZyb21XSUYpKHByaXZhdGVLZXlXaWYsIG5ldHdvcmspKTtcbiAgICBjb25zdCBpbnRlcm5hbFB1YktleSA9ICgwLCB0eEJ1aWxkXzEud2lmMlB1YmxpYykocHJpdmF0ZUtleVdpZiwgbmV0d29yaykuc2xpY2UoMSk7XG4gICAgY29uc3Qgb3BzID0gYml0Y29pbi5zY3JpcHQuT1BTO1xuICAgIGNvbnN0IGluc2NyaXB0aW9uQnVpbGRlciA9IFtdO1xuICAgIGluc2NyaXB0aW9uQnVpbGRlci5wdXNoKGludGVybmFsUHViS2V5KTtcbiAgICBpbnNjcmlwdGlvbkJ1aWxkZXIucHVzaChvcHMuT1BfQ0hFQ0tTSUcpO1xuICAgIGluc2NyaXB0aW9uQnVpbGRlci5wdXNoKG9wcy5PUF9GQUxTRSk7XG4gICAgaW5zY3JpcHRpb25CdWlsZGVyLnB1c2gob3BzLk9QX0lGKTtcbiAgICBpbnNjcmlwdGlvbkJ1aWxkZXIucHVzaChCdWZmZXIuZnJvbShcIm9yZFwiKSk7XG4gICAgaW5zY3JpcHRpb25CdWlsZGVyLnB1c2gob3BzLk9QX0RBVEFfMSk7XG4gICAgaW5zY3JpcHRpb25CdWlsZGVyLnB1c2gob3BzLk9QX0RBVEFfMSk7XG4gICAgaW5zY3JpcHRpb25CdWlsZGVyLnB1c2goQnVmZmVyLmZyb20oaW5zY3JpcHRpb25EYXRhLmNvbnRlbnRUeXBlKSk7XG4gICAgaW5zY3JpcHRpb25CdWlsZGVyLnB1c2gob3BzLk9QXzApO1xuICAgIGNvbnN0IG1heENodW5rU2l6ZSA9IDUyMDtcbiAgICBsZXQgYm9keSA9IEJ1ZmZlci5mcm9tKGluc2NyaXB0aW9uRGF0YS5ib2R5KTtcbiAgICBsZXQgYm9keVNpemUgPSBib2R5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvZHlTaXplOyBpICs9IG1heENodW5rU2l6ZSkge1xuICAgICAgICBsZXQgZW5kID0gaSArIG1heENodW5rU2l6ZTtcbiAgICAgICAgaWYgKGVuZCA+IGJvZHlTaXplKSB7XG4gICAgICAgICAgICBlbmQgPSBib2R5U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpbnNjcmlwdGlvbkJ1aWxkZXIucHVzaChib2R5LnNsaWNlKGksIGVuZCkpO1xuICAgIH1cbiAgICBpbnNjcmlwdGlvbkJ1aWxkZXIucHVzaChvcHMuT1BfRU5ESUYpO1xuICAgIGNvbnN0IGluc2NyaXB0aW9uU2NyaXB0ID0gYml0Y29pbi5zY3JpcHQuY29tcGlsZShpbnNjcmlwdGlvbkJ1aWxkZXIpO1xuICAgIGNvbnN0IHNjcmlwdFRyZWUgPSB7XG4gICAgICAgIG91dHB1dDogaW5zY3JpcHRpb25TY3JpcHQsXG4gICAgfTtcbiAgICBjb25zdCByZWRlZW0gPSB7XG4gICAgICAgIG91dHB1dDogaW5zY3JpcHRpb25TY3JpcHQsXG4gICAgICAgIHJlZGVlbVZlcnNpb246IDB4YzAsXG4gICAgfTtcbiAgICBjb25zdCB7IG91dHB1dCwgd2l0bmVzcywgaGFzaCwgYWRkcmVzcyB9ID0gYml0Y29pbi5wYXltZW50cy5wMnRyKHtcbiAgICAgICAgaW50ZXJuYWxQdWJrZXk6IGludGVybmFsUHViS2V5LFxuICAgICAgICBzY3JpcHRUcmVlLFxuICAgICAgICByZWRlZW0sXG4gICAgICAgIG5ldHdvcmssXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgaW5zY3JpcHRpb25TY3JpcHQsXG4gICAgICAgIGNvbW1pdFR4QWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgY29tbWl0VHhBZGRyZXNzUGtTY3JpcHQ6IG91dHB1dCxcbiAgICAgICAgd2l0bmVzczogd2l0bmVzcyxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcmV2ZWFsVHhQcmV2T3V0cHV0OiB7XG4gICAgICAgICAgICBwa1NjcmlwdDogQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVhbFBrU2NyaXB0OiBiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQoaW5zY3JpcHRpb25EYXRhLnJldmVhbEFkZHIsIG5ldHdvcmspLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnNjcmliZShuZXR3b3JrLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgdG9vbCA9IEluc2NyaXB0aW9uVG9vbC5uZXdJbnNjcmlwdGlvblRvb2wobmV0d29yaywgcmVxdWVzdCk7XG4gICAgaWYgKHRvb2wubXVzdENvbW1pdFR4RmVlID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tbWl0VHg6IFwiXCIsXG4gICAgICAgICAgICByZXZlYWxUeHM6IFtdLFxuICAgICAgICAgICAgY29tbWl0VHhGZWU6IHRvb2wubXVzdENvbW1pdFR4RmVlLFxuICAgICAgICAgICAgcmV2ZWFsVHhGZWVzOiB0b29sLm11c3RSZXZlYWxUeEZlZXMsXG4gICAgICAgICAgICBjb21taXRBZGRyczogdG9vbC5jb21taXRBZGRycyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWl0VHg6IHRvb2wuY29tbWl0VHgudG9IZXgoKSxcbiAgICAgICAgcmV2ZWFsVHhzOiB0b29sLnJldmVhbFR4cy5tYXAocmV2ZWFsVHggPT4gcmV2ZWFsVHgudG9IZXgoKSksXG4gICAgICAgIC4uLnRvb2wuY2FsY3VsYXRlRmVlKCksXG4gICAgICAgIGNvbW1pdEFkZHJzOiB0b29sLmNvbW1pdEFkZHJzLFxuICAgIH07XG59XG5leHBvcnRzLmluc2NyaWJlID0gaW5zY3JpYmU7XG5mdW5jdGlvbiBpbnNjcmliZUZvck1QQ1Vuc2lnbmVkKHJlcXVlc3QsIG5ldHdvcmssIHVuc2lnbmVkQ29tbWl0VHhIYXNoLCBzaWduZWRDb21taXRUeEhhc2gpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gcmVxdWVzdC5jb21taXRUeFByZXZPdXRwdXRMaXN0WzBdLnByaXZhdGVLZXk7XG4gICAgY29uc3Qgc2NyaXB0Q3R4TGlzdCA9IFtdO1xuICAgIHJlcXVlc3QuaW5zY3JpcHRpb25EYXRhTGlzdC5mb3JFYWNoKGluc2NyaXB0aW9uRGF0YSA9PiB7XG4gICAgICAgIHNjcmlwdEN0eExpc3QucHVzaChjcmVhdGVJbnNjcmlwdGlvblR4Q3R4RGF0YShuZXR3b3JrLCBpbnNjcmlwdGlvbkRhdGEsIHByaXZhdGVLZXkpKTtcbiAgICB9KTtcbiAgICBsZXQgdG90YWxSZXZlYWxJblZhbHVlID0gMDtcbiAgICBjb25zdCByZXZlYWxPdXRWYWx1ZSA9IHJlcXVlc3QucmV2ZWFsT3V0VmFsdWUgfHwgZGVmYXVsdFJldmVhbE91dFZhbHVlO1xuICAgIGNvbnN0IHJldmVhbFR4TGlzdCA9IFtdO1xuICAgIHNjcmlwdEN0eExpc3QuZm9yRWFjaCgoY3R4LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHR4ID0gbmV3IGJpdGNvaW4uVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgdHgudmVyc2lvbiA9IGRlZmF1bHRUeFZlcnNpb247XG4gICAgICAgIHR4LmFkZElucHV0KEJ1ZmZlci5hbGxvYygzMiksIGksIGRlZmF1bHRTZXF1ZW5jZU51bSk7XG4gICAgICAgIHR4LmFkZE91dHB1dChjdHgucmV2ZWFsUGtTY3JpcHQsIHJldmVhbE91dFZhbHVlKTtcbiAgICAgICAgcmV2ZWFsVHhMaXN0LnB1c2godHgpO1xuICAgICAgICBjb25zdCBlbXB0eVNpZ25hdHVyZSA9IEJ1ZmZlci5hbGxvYyg2NCk7XG4gICAgICAgIGNvbnN0IGVtcHR5Q29udHJvbEJsb2NrV2l0bmVzcyA9IEJ1ZmZlci5hbGxvYygzMyk7XG4gICAgICAgIGNvbnN0IHR4V2l0bmVzcyA9IFtdO1xuICAgICAgICB0eFdpdG5lc3MucHVzaChlbXB0eVNpZ25hdHVyZSk7XG4gICAgICAgIHR4V2l0bmVzcy5wdXNoKGN0eC5pbnNjcmlwdGlvblNjcmlwdCk7XG4gICAgICAgIHR4V2l0bmVzcy5wdXNoKGVtcHR5Q29udHJvbEJsb2NrV2l0bmVzcyk7XG4gICAgICAgIGNvbnN0IHJldmVhbEZlZSA9IE1hdGguZmxvb3IoKHR4LmJ5dGVMZW5ndGgoKSArIE1hdGguZmxvb3IoKCgwLCB0cmFuc2FjdGlvbl8xLnZlY3RvclNpemUpKHR4V2l0bmVzcykgKyAyICsgMykgLyA0KSkgKiByZXF1ZXN0LnJldmVhbEZlZVJhdGUpO1xuICAgICAgICBjb25zdCByZXZlYWxJblZhbHVlID0gcmV2ZWFsT3V0VmFsdWUgKyByZXZlYWxGZWU7XG4gICAgICAgIGN0eC5yZXZlYWxUeFByZXZPdXRwdXQgPSB7XG4gICAgICAgICAgICBwa1NjcmlwdDogY3R4LmNvbW1pdFR4QWRkcmVzc1BrU2NyaXB0LFxuICAgICAgICAgICAgdmFsdWU6IHJldmVhbEluVmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIHRvdGFsUmV2ZWFsSW5WYWx1ZSArPSByZXZlYWxJblZhbHVlO1xuICAgIH0pO1xuICAgIGxldCB0b3RhbENvbW1pdEluVmFsdWUgPSAwO1xuICAgIGNvbnN0IGNvbW1pdFR4ID0gbmV3IGJpdGNvaW4uVHJhbnNhY3Rpb24oKTtcbiAgICBjb21taXRUeC52ZXJzaW9uID0gZGVmYXVsdFR4VmVyc2lvbjtcbiAgICByZXF1ZXN0LmNvbW1pdFR4UHJldk91dHB1dExpc3QuZm9yRWFjaCh1eHRvID0+IHtcbiAgICAgICAgY29tbWl0VHguYWRkSW5wdXQoY3J5cHRvX2xpYl8xLmJhc2UucmV2ZXJzZUJ1ZmZlcihjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHV4dG8udHhJZCkpLCB1eHRvLnZPdXQsIGRlZmF1bHRTZXF1ZW5jZU51bSk7XG4gICAgICAgIHRvdGFsQ29tbWl0SW5WYWx1ZSArPSB1eHRvLmFtb3VudDtcbiAgICB9KTtcbiAgICBjb25zdCBjb21taXRBZGRycyA9IFtdO1xuICAgIHNjcmlwdEN0eExpc3QuZm9yRWFjaChjdHggPT4ge1xuICAgICAgICBjb21taXRUeC5hZGRPdXRwdXQoY3R4LnJldmVhbFR4UHJldk91dHB1dC5wa1NjcmlwdCwgY3R4LnJldmVhbFR4UHJldk91dHB1dC52YWx1ZSk7XG4gICAgICAgIGNvbW1pdEFkZHJzLnB1c2goY3R4LmNvbW1pdFR4QWRkcmVzcyk7XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlUGtTY3JpcHQgPSBiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQocmVxdWVzdC5jaGFuZ2VBZGRyZXNzLCBuZXR3b3JrKTtcbiAgICBjb21taXRUeC5hZGRPdXRwdXQoY2hhbmdlUGtTY3JpcHQsIDApO1xuICAgIGNvbnN0IGVzdGltYXRlVHggPSBjb21taXRUeC5jbG9uZSgpO1xuICAgIHNpZ25UeChlc3RpbWF0ZVR4LCByZXF1ZXN0LmNvbW1pdFR4UHJldk91dHB1dExpc3QsIG5ldHdvcmspO1xuICAgIGNvbnN0IHZzaXplID0gKDAsIHNpZ2Nvc3RfMS5jb3VudEFkanVzdGVkVnNpemUpKGVzdGltYXRlVHgsIHJlcXVlc3QuY29tbWl0VHhQcmV2T3V0cHV0TGlzdC5tYXAoYSA9PiBhLmFkZHJlc3MpLCBuZXR3b3JrKTtcbiAgICBjb25zdCBmZWUgPSBNYXRoLmZsb29yKHZzaXplICogcmVxdWVzdC5jb21taXRGZWVSYXRlKTtcbiAgICBjb25zdCBjaGFuZ2VWYWx1ZSA9IHRvdGFsQ29tbWl0SW5WYWx1ZSAtIHRvdGFsUmV2ZWFsSW5WYWx1ZSAtIGZlZTtcbiAgICBpZiAoY2hhbmdlVmFsdWUgPj0gKHJlcXVlc3QubWluQ2hhbmdlVmFsdWUgfHwgZGVmYXVsdE1pbkNoYW5nZVZhbHVlKSkge1xuICAgICAgICBjb21taXRUeC5vdXRzW2NvbW1pdFR4Lm91dHMubGVuZ3RoIC0gMV0udmFsdWUgPSBjaGFuZ2VWYWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbW1pdFR4Lm91dHMgPSBjb21taXRUeC5vdXRzLnNsaWNlKDAsIGNvbW1pdFR4Lm91dHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGVzdGltYXRlVHgub3V0cyA9IGVzdGltYXRlVHgub3V0cy5zbGljZSgwLCBlc3RpbWF0ZVR4Lm91dHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IHZzaXplV2l0aG91dENoYW5nZSA9ICgwLCBzaWdjb3N0XzEuY291bnRBZGp1c3RlZFZzaXplKShlc3RpbWF0ZVR4LCByZXF1ZXN0LmNvbW1pdFR4UHJldk91dHB1dExpc3QubWFwKGEgPT4gYS5hZGRyZXNzKSwgbmV0d29yayk7XG4gICAgICAgIGNvbnN0IGZlZVdpdGhvdXRDaGFuZ2UgPSBNYXRoLmZsb29yKHZzaXplV2l0aG91dENoYW5nZSAqIHJlcXVlc3QuY29tbWl0RmVlUmF0ZSk7XG4gICAgICAgIGlmICh0b3RhbENvbW1pdEluVmFsdWUgLSB0b3RhbFJldmVhbEluVmFsdWUgLSBmZWVXaXRob3V0Q2hhbmdlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5zdWZmaWNpZW50IGJhbGFuY2VcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2lnSGFzaExpc3QgPSBjYWxjdWxhdGVTaWdIYXNoKGNvbW1pdFR4LCByZXF1ZXN0LmNvbW1pdFR4UHJldk91dHB1dExpc3QsIG5ldHdvcmspO1xuICAgIGxldCBjb21taXRUeEhhc2ggPSBjb21taXRUeC5nZXRIYXNoKCk7XG4gICAgaWYgKHNpZ25lZENvbW1pdFR4SGFzaCkge1xuICAgICAgICBjb21taXRUeEhhc2ggPSBzaWduZWRDb21taXRUeEhhc2g7XG4gICAgfVxuICAgIHJldmVhbFR4TGlzdC5mb3JFYWNoKChyZXZlYWxUeCwgaSkgPT4ge1xuICAgICAgICByZXZlYWxUeC5pbnNbMF0uaGFzaCA9IGNvbW1pdFR4SGFzaDtcbiAgICAgICAgY29uc3QgcHJldk91dFNjcmlwdHMgPSBbc2NyaXB0Q3R4TGlzdFtpXS5yZXZlYWxUeFByZXZPdXRwdXQucGtTY3JpcHRdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbc2NyaXB0Q3R4TGlzdFtpXS5yZXZlYWxUeFByZXZPdXRwdXQudmFsdWVdO1xuICAgICAgICBjb25zdCBzaWdIYXNoID0gcmV2ZWFsVHguaGFzaEZvcldpdG5lc3NWMSgwLCBwcmV2T3V0U2NyaXB0cywgdmFsdWVzLCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCwgc2NyaXB0Q3R4TGlzdFtpXS5oYXNoKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2Nobm9yci5zaWduKHNpZ0hhc2gsIHNjcmlwdEN0eExpc3RbaV0ucHJpdmF0ZUtleSwgY3J5cHRvX2xpYl8xLmJhc2UucmFuZG9tQnl0ZXMoMzIpKSk7XG4gICAgICAgIHJldmVhbFR4Lmluc1swXS53aXRuZXNzID0gW3NpZ25hdHVyZSwgLi4uc2NyaXB0Q3R4TGlzdFtpXS53aXRuZXNzXTtcbiAgICB9KTtcbiAgICBsZXQgY29tbWl0VHhGZWUgPSAwO1xuICAgIGNvbW1pdFR4Lmlucy5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgIGNvbW1pdFR4RmVlICs9IHJlcXVlc3QuY29tbWl0VHhQcmV2T3V0cHV0TGlzdFtpXS5hbW91bnQ7XG4gICAgfSk7XG4gICAgY29tbWl0VHgub3V0cy5mb3JFYWNoKG91dCA9PiB7XG4gICAgICAgIGNvbW1pdFR4RmVlIC09IG91dC52YWx1ZTtcbiAgICB9KTtcbiAgICBsZXQgcmV2ZWFsVHhGZWVzID0gW107XG4gICAgcmV2ZWFsVHhMaXN0LmZvckVhY2goKHJldmVhbFR4LCBpKSA9PiB7XG4gICAgICAgIGxldCByZXZlYWxUeEZlZSA9IDA7XG4gICAgICAgIHJldmVhbFR4RmVlICs9IHNjcmlwdEN0eExpc3RbaV0ucmV2ZWFsVHhQcmV2T3V0cHV0LnZhbHVlO1xuICAgICAgICByZXZlYWxUeEZlZSAtPSByZXZlYWxUeC5vdXRzWzBdLnZhbHVlO1xuICAgICAgICByZXZlYWxUeEZlZXMucHVzaChyZXZlYWxUeEZlZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbkhhc2hMaXN0OiBzaWdIYXNoTGlzdCxcbiAgICAgICAgY29tbWl0VHg6IGNvbW1pdFR4LnRvSGV4KCksXG4gICAgICAgIHJldmVhbFR4czogcmV2ZWFsVHhMaXN0Lm1hcChlID0+IGUudG9IZXgoKSksXG4gICAgICAgIGNvbW1pdFR4RmVlOiBjb21taXRUeEZlZSxcbiAgICAgICAgcmV2ZWFsVHhGZWVzOiByZXZlYWxUeEZlZXMsXG4gICAgICAgIGNvbW1pdEFkZHJzOiBjb21taXRBZGRycyxcbiAgICB9O1xufVxuZXhwb3J0cy5pbnNjcmliZUZvck1QQ1Vuc2lnbmVkID0gaW5zY3JpYmVGb3JNUENVbnNpZ25lZDtcbmZ1bmN0aW9uIGluc2NyaWJlRm9yTVBDU2lnbmVkKHJlcXVlc3QsIG5ldHdvcmspIHtcbiAgICBjb25zdCB1bnNpZ25lZENvbW1pdFR4SGV4ID0gcmVxdWVzdC5jb21taXRUeDtcbiAgICBjb25zdCBzaWduYXR1cmVzID0gcmVxdWVzdC5zaWduYXR1cmVMaXN0O1xuICAgIGNvbnN0IHR4ID0gYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHVuc2lnbmVkQ29tbWl0VHhIZXgpO1xuICAgIGNvbnN0IHVuc2lnbmVkQ29tbWl0VHhIYXNoID0gdHguZ2V0SGFzaCgpO1xuICAgIHR4Lmlucy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHNpZ25hdHVyZXNbaV0pO1xuICAgICAgICBpZiAoIWlucHV0LndpdG5lc3MpIHtcbiAgICAgICAgICAgIGlucHV0LnNjcmlwdCA9IGJpdGNvaW4ucGF5bWVudHMucDJwa2goe1xuICAgICAgICAgICAgICAgIHB1YmtleTogYml0Y29pbi5wYXltZW50cy5wMnBraCh7IGlucHV0OiBpbnB1dC5zY3JpcHQgfSkucHVia2V5LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpLFxuICAgICAgICAgICAgfSkuaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzWzBdID0gYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbmVkQ29tbWl0VHhIYXNoID0gdHguZ2V0SGFzaCgpO1xuICAgIGNvbnN0IHJlcyA9IGluc2NyaWJlRm9yTVBDVW5zaWduZWQocmVxdWVzdCwgbmV0d29yaywgdW5zaWduZWRDb21taXRUeEhhc2gsIHNpZ25lZENvbW1pdFR4SGFzaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbkhhc2hMaXN0OiBudWxsLFxuICAgICAgICBjb21taXRUeDogdHgudG9IZXgoKSxcbiAgICAgICAgcmV2ZWFsVHhzOiByZXMucmV2ZWFsVHhzLFxuICAgICAgICBjb21taXRUeEZlZTogcmVzLmNvbW1pdFR4RmVlLFxuICAgICAgICByZXZlYWxUeEZlZXM6IHJlcy5yZXZlYWxUeEZlZXMsXG4gICAgICAgIGNvbW1pdEFkZHJzOiByZXMuY29tbWl0QWRkcnMsXG4gICAgfTtcbn1cbmV4cG9ydHMuaW5zY3JpYmVGb3JNUENTaWduZWQgPSBpbnNjcmliZUZvck1QQ1NpZ25lZDtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpZ0hhc2godHgsIHByZXZPdXRGZXRjaGVyLCBuZXR3b3JrKSB7XG4gICAgY29uc3Qgc2lnSGFzaExpc3QgPSBbXTtcbiAgICB0eC5pbnMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChwcmV2T3V0RmV0Y2hlcltpXS5wdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBwa1NjcmlwdCA9IGJpdGNvaW4uYWRkcmVzcy50b091dHB1dFNjcmlwdChwcmV2T3V0RmV0Y2hlcltpXS5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJTaWduYXR1cmUgPSBCdWZmZXIuYWxsb2MoNjQsIDApO1xuICAgICAgICBsZXQgc2lnSGFzaDtcbiAgICAgICAgaWYgKCgwLCBwc2J0dXRpbHNfMS5pc1AyVFIpKHBrU2NyaXB0KSkge1xuICAgICAgICAgICAgY29uc3QgcHJldk91dFNjcmlwdHMgPSBwcmV2T3V0RmV0Y2hlci5tYXAobyA9PiBiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQoby5hZGRyZXNzLCBuZXR3b3JrKSk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBwcmV2T3V0RmV0Y2hlci5tYXAobyA9PiBvLmFtb3VudCk7XG4gICAgICAgICAgICBzaWdIYXNoID0gdHguaGFzaEZvcldpdG5lc3NWMShpLCBwcmV2T3V0U2NyaXB0cywgdmFsdWVzLCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCk7XG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzID0gW3BsYWNlaG9sZGVyU2lnbmF0dXJlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgcHNidHV0aWxzXzEuaXNQMlBLSCkocGtTY3JpcHQpKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2U2NyaXB0ID0gYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KHByZXZPdXRGZXRjaGVyW2ldLmFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgICAgICAgc2lnSGFzaCA9IHR4Lmhhc2hGb3JTaWduYXR1cmUoaSwgcHJldlNjcmlwdCwgYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCk7XG4gICAgICAgICAgICBpbnB1dC5zY3JpcHQgPSBiaXRjb2luLnBheW1lbnRzLnAycGtoKHtcbiAgICAgICAgICAgICAgICBwdWJrZXk6IHB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGJpdGNvaW4uc2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUocGxhY2Vob2xkZXJTaWduYXR1cmUsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpLFxuICAgICAgICAgICAgfSkuaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwdWJLZXlIYXNoID0gYmNyeXB0by5oYXNoMTYwKHB1YmxpY0tleSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2T3V0U2NyaXB0ID0gQnVmZmVyLm9mKDB4MTksIDB4NzYsIDB4YTksIDB4MTQsIC4uLnB1YktleUhhc2gsIDB4ODgsIDB4YWMpO1xuICAgICAgICAgICAgc2lnSGFzaCA9IHR4Lmhhc2hGb3JXaXRuZXNzKGksIHByZXZPdXRTY3JpcHQsIHByZXZPdXRGZXRjaGVyW2ldLmFtb3VudCwgYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCk7XG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzID0gYml0Y29pbi5wYXltZW50cy5wMndwa2goe1xuICAgICAgICAgICAgICAgIHB1YmtleTogcHVibGljS2V5LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShwbGFjZWhvbGRlclNpZ25hdHVyZSwgYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCksXG4gICAgICAgICAgICB9KS53aXRuZXNzO1xuICAgICAgICAgICAgY29uc3QgcmVkZWVtU2NyaXB0ID0gQnVmZmVyLm9mKDB4MTYsIDAsIDIwLCAuLi5wdWJLZXlIYXNoKTtcbiAgICAgICAgICAgIGlmICgoMCwgcHNidHV0aWxzXzEuaXNQMlNIU2NyaXB0KShwa1NjcmlwdCkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5zY3JpcHQgPSByZWRlZW1TY3JpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2lnSGFzaExpc3QucHVzaChjcnlwdG9fbGliXzEuYmFzZS50b0hleChzaWdIYXNoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZ0hhc2hMaXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zY3JpYmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/inscribe.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/message.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/message.js ***!
  \************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyWithAddress = exports.getMPCSignedMessage = exports.verify = exports.sign = exports.toCompact = exports.magicHash = void 0;\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nconst txBuild_1 = __webpack_require__(/*! ./txBuild */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js\");\nconst MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\nfunction varintBufNum(n) {\n    let buf;\n    if (n < 253) {\n        buf = Buffer.alloc(1);\n        buf.writeUInt8(n, 0);\n    }\n    else if (n < 0x10000) {\n        buf = Buffer.alloc(1 + 2);\n        buf.writeUInt8(253, 0);\n        buf.writeUInt16LE(n, 1);\n    }\n    else if (n < 0x100000000) {\n        buf = Buffer.alloc(1 + 4);\n        buf.writeUInt8(254, 0);\n        buf.writeUInt32LE(n, 1);\n    }\n    else {\n        buf = Buffer.alloc(1 + 8);\n        buf.writeUInt8(255, 0);\n        buf.writeInt32LE(n & -1, 1);\n        buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);\n    }\n    return buf;\n}\nfunction magicHash(message, messagePrefix) {\n    const messagePrefixBuffer = messagePrefix ? Buffer.from(messagePrefix, \"utf8\") : MAGIC_BYTES;\n    const prefix1 = varintBufNum(messagePrefixBuffer.length);\n    const messageBuffer = Buffer.from(message);\n    const prefix2 = varintBufNum(messageBuffer.length);\n    const buf = Buffer.concat([prefix1, messagePrefixBuffer, prefix2, messageBuffer]);\n    return crypto_lib_1.base.doubleSha256(buf);\n}\nexports.magicHash = magicHash;\nfunction toCompact(i, signature, compressed) {\n    if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n        throw new Error('i must be equal to 0, 1, 2, or 3');\n    }\n    let val = i + 27 + 4;\n    if (!compressed) {\n        val = val - 4;\n    }\n    return Buffer.concat([Uint8Array.of(val), Uint8Array.from(signature)]);\n}\nexports.toCompact = toCompact;\n;\nfunction sign(wifPrivate, message, network, messagePrefix) {\n    const hash = magicHash(message, messagePrefix);\n    if (!wifPrivate) {\n        return crypto_lib_1.base.toHex(hash);\n    }\n    const privateKey = crypto_lib_1.base.fromHex((0, txBuild_1.privateKeyFromWIF)(wifPrivate, network));\n    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(hash), privateKey);\n    return crypto_lib_1.base.toBase64(toCompact(recovery, signature, true));\n}\nexports.sign = sign;\nfunction verify(publicKey, message, sig, messagePrefix) {\n    const hash = magicHash(message, messagePrefix);\n    const sigBytes = crypto_lib_1.base.fromBase64(sig);\n    const v = sigBytes[0] - 27 - 4;\n    const rs = sigBytes.slice(1);\n    return crypto_lib_1.signUtil.secp256k1.verify(Buffer.from(hash), rs, v, crypto_lib_1.base.fromHex(publicKey));\n}\nexports.verify = verify;\nfunction getMPCSignedMessage(hash, sig, publicKey) {\n    const signature = crypto_lib_1.base.fromHex(sig);\n    const r = signature.slice(0, 32);\n    const s = signature.slice(32, 64);\n    const recovery = crypto_lib_1.signUtil.secp256k1.getV(crypto_lib_1.base.fromHex(hash), crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey));\n    return crypto_lib_1.base.toBase64(toCompact(recovery, signature, true));\n}\nexports.getMPCSignedMessage = getMPCSignedMessage;\nfunction verifyWithAddress(address, message, sig, messagePrefix) {\n    const hash = magicHash(message, messagePrefix);\n    const sigBytes = crypto_lib_1.base.fromBase64(sig);\n    const flagByte = sigBytes[0] - 27;\n    const rs = sigBytes.slice(1);\n    const r = flagByte & 3;\n    const segwitType = !(flagByte & 8)\n        ? null\n        : !(flagByte & 4)\n            ? SEGWIT_TYPES.P2SH_P2WPKH\n            : SEGWIT_TYPES.P2WPKH;\n    const compressed = !!(flagByte & 12);\n    const publicKey = crypto_lib_1.signUtil.secp256k1.recover(rs, r, Buffer.from(hash), compressed);\n    if (publicKey == null) {\n        return false;\n    }\n    const publicKeyHash = Buffer.from(crypto_lib_1.base.hash160(publicKey));\n    let actual, expected;\n    if (segwitType) {\n        if (segwitType === SEGWIT_TYPES.P2SH_P2WPKH) {\n            actual = segwitRedeemHash(publicKeyHash);\n            expected = crypto_lib_1.base.fromBase58Check(address).slice(1);\n        }\n        else {\n            actual = publicKeyHash;\n            expected = decodeBech32(address);\n        }\n    }\n    else {\n        try {\n            expected = decodeBech32(address);\n            return bufferEquals(publicKeyHash, expected);\n        }\n        catch (e) {\n            const redeemHash = segwitRedeemHash(publicKeyHash);\n            const except = crypto_lib_1.base.fromBase58Check(address).slice(1);\n            return bufferEquals(publicKeyHash, except) || bufferEquals(redeemHash, except);\n        }\n    }\n    return bufferEquals(actual, expected);\n}\nexports.verifyWithAddress = verifyWithAddress;\nconst SEGWIT_TYPES = {\n    P2WPKH: 'p2wpkh',\n    P2SH_P2WPKH: 'p2sh(p2wpkh)'\n};\nfunction decodeBech32(address) {\n    const result = crypto_lib_1.base.bech32.decode(address);\n    const data = crypto_lib_1.base.bech32.fromWords(result.words.slice(1));\n    return Buffer.from(data);\n}\nfunction segwitRedeemHash(publicKeyHash) {\n    const redeemScript = Buffer.concat([\n        Buffer.from('0014', 'hex'),\n        publicKeyHash\n    ]);\n    return Buffer.from(crypto_lib_1.base.hash160(redeemScript));\n}\nfunction bufferEquals(a, b) {\n    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n        throw new TypeError('Arguments must be Buffers');\n    }\n    if (a === b) {\n        return true;\n    }\n    if (typeof a.equals === 'function') {\n        return a.equals(b);\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvbWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRywyQkFBMkIsR0FBRyxjQUFjLEdBQUcsWUFBWSxHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUMvSCxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsNkVBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L21lc3NhZ2UuanM/MmUyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyaWZ5V2l0aEFkZHJlc3MgPSBleHBvcnRzLmdldE1QQ1NpZ25lZE1lc3NhZ2UgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnbiA9IGV4cG9ydHMudG9Db21wYWN0ID0gZXhwb3J0cy5tYWdpY0hhc2ggPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmNvbnN0IHR4QnVpbGRfMSA9IHJlcXVpcmUoXCIuL3R4QnVpbGRcIik7XG5jb25zdCBNQUdJQ19CWVRFUyA9IEJ1ZmZlci5mcm9tKCdCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcbicpO1xuZnVuY3Rpb24gdmFyaW50QnVmTnVtKG4pIHtcbiAgICBsZXQgYnVmO1xuICAgIGlmIChuIDwgMjUzKSB7XG4gICAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgYnVmLndyaXRlVUludDgobiwgMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG4gPCAweDEwMDAwKSB7XG4gICAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxICsgMik7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KDI1MywgMCk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQxNkxFKG4sIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmFsbG9jKDEgKyA0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDgoMjU0LCAwKTtcbiAgICAgICAgYnVmLndyaXRlVUludDMyTEUobiwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWYgPSBCdWZmZXIuYWxsb2MoMSArIDgpO1xuICAgICAgICBidWYud3JpdGVVSW50OCgyNTUsIDApO1xuICAgICAgICBidWYud3JpdGVJbnQzMkxFKG4gJiAtMSwgMSk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKE1hdGguZmxvb3IobiAvIDB4MTAwMDAwMDAwKSwgNSk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5mdW5jdGlvbiBtYWdpY0hhc2gobWVzc2FnZSwgbWVzc2FnZVByZWZpeCkge1xuICAgIGNvbnN0IG1lc3NhZ2VQcmVmaXhCdWZmZXIgPSBtZXNzYWdlUHJlZml4ID8gQnVmZmVyLmZyb20obWVzc2FnZVByZWZpeCwgXCJ1dGY4XCIpIDogTUFHSUNfQllURVM7XG4gICAgY29uc3QgcHJlZml4MSA9IHZhcmludEJ1Zk51bShtZXNzYWdlUHJlZml4QnVmZmVyLmxlbmd0aCk7XG4gICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHByZWZpeDIgPSB2YXJpbnRCdWZOdW0obWVzc2FnZUJ1ZmZlci5sZW5ndGgpO1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3ByZWZpeDEsIG1lc3NhZ2VQcmVmaXhCdWZmZXIsIHByZWZpeDIsIG1lc3NhZ2VCdWZmZXJdKTtcbiAgICByZXR1cm4gY3J5cHRvX2xpYl8xLmJhc2UuZG91YmxlU2hhMjU2KGJ1Zik7XG59XG5leHBvcnRzLm1hZ2ljSGFzaCA9IG1hZ2ljSGFzaDtcbmZ1bmN0aW9uIHRvQ29tcGFjdChpLCBzaWduYXR1cmUsIGNvbXByZXNzZWQpIHtcbiAgICBpZiAoIShpID09PSAwIHx8IGkgPT09IDEgfHwgaSA9PT0gMiB8fCBpID09PSAzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2kgbXVzdCBiZSBlcXVhbCB0byAwLCAxLCAyLCBvciAzJyk7XG4gICAgfVxuICAgIGxldCB2YWwgPSBpICsgMjcgKyA0O1xuICAgIGlmICghY29tcHJlc3NlZCkge1xuICAgICAgICB2YWwgPSB2YWwgLSA0O1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbVWludDhBcnJheS5vZih2YWwpLCBVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKV0pO1xufVxuZXhwb3J0cy50b0NvbXBhY3QgPSB0b0NvbXBhY3Q7XG47XG5mdW5jdGlvbiBzaWduKHdpZlByaXZhdGUsIG1lc3NhZ2UsIG5ldHdvcmssIG1lc3NhZ2VQcmVmaXgpIHtcbiAgICBjb25zdCBoYXNoID0gbWFnaWNIYXNoKG1lc3NhZ2UsIG1lc3NhZ2VQcmVmaXgpO1xuICAgIGlmICghd2lmUHJpdmF0ZSkge1xuICAgICAgICByZXR1cm4gY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgoaGFzaCk7XG4gICAgfVxuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KCgwLCB0eEJ1aWxkXzEucHJpdmF0ZUtleUZyb21XSUYpKHdpZlByaXZhdGUsIG5ldHdvcmspKTtcbiAgICBjb25zdCB7IHNpZ25hdHVyZSwgcmVjb3ZlcnkgfSA9IGNyeXB0b19saWJfMS5zaWduVXRpbC5zZWNwMjU2azEuc2lnbihCdWZmZXIuZnJvbShoYXNoKSwgcHJpdmF0ZUtleSk7XG4gICAgcmV0dXJuIGNyeXB0b19saWJfMS5iYXNlLnRvQmFzZTY0KHRvQ29tcGFjdChyZWNvdmVyeSwgc2lnbmF0dXJlLCB0cnVlKSk7XG59XG5leHBvcnRzLnNpZ24gPSBzaWduO1xuZnVuY3Rpb24gdmVyaWZ5KHB1YmxpY0tleSwgbWVzc2FnZSwgc2lnLCBtZXNzYWdlUHJlZml4KSB7XG4gICAgY29uc3QgaGFzaCA9IG1hZ2ljSGFzaChtZXNzYWdlLCBtZXNzYWdlUHJlZml4KTtcbiAgICBjb25zdCBzaWdCeXRlcyA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21CYXNlNjQoc2lnKTtcbiAgICBjb25zdCB2ID0gc2lnQnl0ZXNbMF0gLSAyNyAtIDQ7XG4gICAgY29uc3QgcnMgPSBzaWdCeXRlcy5zbGljZSgxKTtcbiAgICByZXR1cm4gY3J5cHRvX2xpYl8xLnNpZ25VdGlsLnNlY3AyNTZrMS52ZXJpZnkoQnVmZmVyLmZyb20oaGFzaCksIHJzLCB2LCBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHB1YmxpY0tleSkpO1xufVxuZXhwb3J0cy52ZXJpZnkgPSB2ZXJpZnk7XG5mdW5jdGlvbiBnZXRNUENTaWduZWRNZXNzYWdlKGhhc2gsIHNpZywgcHVibGljS2V5KSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChzaWcpO1xuICAgIGNvbnN0IHIgPSBzaWduYXR1cmUuc2xpY2UoMCwgMzIpO1xuICAgIGNvbnN0IHMgPSBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgICBjb25zdCByZWNvdmVyeSA9IGNyeXB0b19saWJfMS5zaWduVXRpbC5zZWNwMjU2azEuZ2V0VihjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KGhhc2gpLCBjcnlwdG9fbGliXzEuYmFzZS50b0hleChyKSwgY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgocyksIGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgocHVibGljS2V5KSk7XG4gICAgcmV0dXJuIGNyeXB0b19saWJfMS5iYXNlLnRvQmFzZTY0KHRvQ29tcGFjdChyZWNvdmVyeSwgc2lnbmF0dXJlLCB0cnVlKSk7XG59XG5leHBvcnRzLmdldE1QQ1NpZ25lZE1lc3NhZ2UgPSBnZXRNUENTaWduZWRNZXNzYWdlO1xuZnVuY3Rpb24gdmVyaWZ5V2l0aEFkZHJlc3MoYWRkcmVzcywgbWVzc2FnZSwgc2lnLCBtZXNzYWdlUHJlZml4KSB7XG4gICAgY29uc3QgaGFzaCA9IG1hZ2ljSGFzaChtZXNzYWdlLCBtZXNzYWdlUHJlZml4KTtcbiAgICBjb25zdCBzaWdCeXRlcyA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21CYXNlNjQoc2lnKTtcbiAgICBjb25zdCBmbGFnQnl0ZSA9IHNpZ0J5dGVzWzBdIC0gMjc7XG4gICAgY29uc3QgcnMgPSBzaWdCeXRlcy5zbGljZSgxKTtcbiAgICBjb25zdCByID0gZmxhZ0J5dGUgJiAzO1xuICAgIGNvbnN0IHNlZ3dpdFR5cGUgPSAhKGZsYWdCeXRlICYgOClcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogIShmbGFnQnl0ZSAmIDQpXG4gICAgICAgICAgICA/IFNFR1dJVF9UWVBFUy5QMlNIX1AyV1BLSFxuICAgICAgICAgICAgOiBTRUdXSVRfVFlQRVMuUDJXUEtIO1xuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAhIShmbGFnQnl0ZSAmIDEyKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG9fbGliXzEuc2lnblV0aWwuc2VjcDI1NmsxLnJlY292ZXIocnMsIHIsIEJ1ZmZlci5mcm9tKGhhc2gpLCBjb21wcmVzc2VkKTtcbiAgICBpZiAocHVibGljS2V5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXlIYXNoID0gQnVmZmVyLmZyb20oY3J5cHRvX2xpYl8xLmJhc2UuaGFzaDE2MChwdWJsaWNLZXkpKTtcbiAgICBsZXQgYWN0dWFsLCBleHBlY3RlZDtcbiAgICBpZiAoc2Vnd2l0VHlwZSkge1xuICAgICAgICBpZiAoc2Vnd2l0VHlwZSA9PT0gU0VHV0lUX1RZUEVTLlAyU0hfUDJXUEtIKSB7XG4gICAgICAgICAgICBhY3R1YWwgPSBzZWd3aXRSZWRlZW1IYXNoKHB1YmxpY0tleUhhc2gpO1xuICAgICAgICAgICAgZXhwZWN0ZWQgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tQmFzZTU4Q2hlY2soYWRkcmVzcykuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3R1YWwgPSBwdWJsaWNLZXlIYXNoO1xuICAgICAgICAgICAgZXhwZWN0ZWQgPSBkZWNvZGVCZWNoMzIoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBleHBlY3RlZCA9IGRlY29kZUJlY2gzMihhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJFcXVhbHMocHVibGljS2V5SGFzaCwgZXhwZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZWRlZW1IYXNoID0gc2Vnd2l0UmVkZWVtSGFzaChwdWJsaWNLZXlIYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4Y2VwdCA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21CYXNlNThDaGVjayhhZGRyZXNzKS5zbGljZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJFcXVhbHMocHVibGljS2V5SGFzaCwgZXhjZXB0KSB8fCBidWZmZXJFcXVhbHMocmVkZWVtSGFzaCwgZXhjZXB0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyRXF1YWxzKGFjdHVhbCwgZXhwZWN0ZWQpO1xufVxuZXhwb3J0cy52ZXJpZnlXaXRoQWRkcmVzcyA9IHZlcmlmeVdpdGhBZGRyZXNzO1xuY29uc3QgU0VHV0lUX1RZUEVTID0ge1xuICAgIFAyV1BLSDogJ3Ayd3BraCcsXG4gICAgUDJTSF9QMldQS0g6ICdwMnNoKHAyd3BraCknXG59O1xuZnVuY3Rpb24gZGVjb2RlQmVjaDMyKGFkZHJlc3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjcnlwdG9fbGliXzEuYmFzZS5iZWNoMzIuZGVjb2RlKGFkZHJlc3MpO1xuICAgIGNvbnN0IGRhdGEgPSBjcnlwdG9fbGliXzEuYmFzZS5iZWNoMzIuZnJvbVdvcmRzKHJlc3VsdC53b3Jkcy5zbGljZSgxKSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpO1xufVxuZnVuY3Rpb24gc2Vnd2l0UmVkZWVtSGFzaChwdWJsaWNLZXlIYXNoKSB7XG4gICAgY29uc3QgcmVkZWVtU2NyaXB0ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIEJ1ZmZlci5mcm9tKCcwMDE0JywgJ2hleCcpLFxuICAgICAgICBwdWJsaWNLZXlIYXNoXG4gICAgXSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNyeXB0b19saWJfMS5iYXNlLmhhc2gxNjAocmVkZWVtU2NyaXB0KSk7XG59XG5mdW5jdGlvbiBidWZmZXJFcXVhbHMoYSwgYikge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpO1xuICAgIH1cbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYS5lcXVhbHMoYik7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/message.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/onekey.js':
    /*!***********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/onekey.js ***!
  \***********************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.oneKeyBuildBtcTx = void 0;\nconst bitcoinjs_lib_1 = __webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js");\nconst bufferutils_1 = __webpack_require__(/*! ./bitcoinjs-lib/bufferutils */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst wallet_1 = __webpack_require__(/*! ./wallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/index.js");\nconst txBuild_1 = __webpack_require__(/*! ./txBuild */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js");\nconst networks_1 = __webpack_require__(/*! ./bitcoinjs-lib/networks */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/networks.js");\nconst addressTypeToOneKeyInputScriptType = {\n    "legacy": "SPENDADDRESS",\n    "segwit_native": "SPENDWITNESS",\n    "segwit_nested": "SPENDP2SHWITNESS",\n    "segwit_taproot": "SPENDTAPROOT",\n};\nconst addressTypeToOneKeyOutputScriptType = {\n    "legacy": "PAYTOADDRESS",\n    "segwit_native": "PAYTOWITNESS",\n    "segwit_nested": "PAYTOP2SHWITNESS",\n    "segwit_taproot": "PAYTOTAPROOT",\n};\nfunction oneKeyBuildBtcTx(txData, network = networks_1.bitcoin) {\n    const tx = (0, wallet_1.convert2UtxoTx)(txData);\n    if (tx.omni) {\n        const coinType = (0, wallet_1.number2Hex)(tx.omni.coinType || 31, 8);\n        const amount = (0, wallet_1.number2Hex)(tx.omni.amount, 16);\n        const omniScript = "6f6d6e69" + "0000" + "0000" + coinType + amount;\n        tx.outputs.push({\n            address: "",\n            amount: 0,\n            omniScript,\n        });\n    }\n    const changeAmount = parseInt((0, txBuild_1.signBtc)(tx, "", network, undefined, true, true));\n    const dustSize = txData.dustSize || 546;\n    if (changeAmount >= dustSize) {\n        tx.outputs.push({\n            address: tx.address,\n            amount: changeAmount,\n            derivationPath: tx.derivationPath,\n            isChange: true,\n        });\n    }\n    const inputs = [];\n    const refTxs = [];\n    tx.inputs.forEach((input) => {\n        const address_n = parseDerivationPath(input.derivationPath);\n        inputs.push({\n            address_n,\n            prev_hash: input.txId,\n            prev_index: input.vOut,\n            amount: input.amount.toString(),\n            script_type: addressTypeToOneKeyInputScriptType[(0, txBuild_1.getAddressType)(input.address, network)],\n        });\n        refTxs.push(parseRefTx(input.nonWitnessUtxo, input.txId));\n    });\n    const outputs = [];\n    tx.outputs.forEach((output) => {\n        if (output.isChange) {\n            outputs.push({\n                address_n: parseDerivationPath(output.derivationPath),\n                amount: output.amount.toString(),\n                script_type: addressTypeToOneKeyOutputScriptType[(0, txBuild_1.getAddressType)(output.address, network)],\n            });\n        }\n        else if (output.omniScript) {\n            outputs.push({\n                amount: "0",\n                op_return_data: output.omniScript,\n                script_type: "PAYTOOPRETURN",\n            });\n        }\n        else {\n            outputs.push({\n                address: output.address,\n                amount: output.amount.toString(),\n                script_type: "PAYTOADDRESS",\n            });\n        }\n    });\n    return {\n        inputs: inputs,\n        outputs: outputs,\n        refTxs: refTxs,\n        coin: "btc",\n    };\n}\nexports.oneKeyBuildBtcTx = oneKeyBuildBtcTx;\nfunction parseRefTx(rawTx, txId) {\n    const transaction = bitcoinjs_lib_1.Transaction.fromHex(rawTx);\n    const refInputs = [];\n    transaction.ins.forEach(input => {\n        refInputs.push({\n            prev_hash: crypto_lib_1.base.toHex((0, bufferutils_1.reverseBuffer)(input.hash)),\n            prev_index: input.index,\n            script_sig: crypto_lib_1.base.toHex(input.script),\n            sequence: input.sequence,\n        });\n    });\n    const refOutputs = [];\n    transaction.outs.forEach(output => {\n        refOutputs.push({\n            amount: output.value,\n            script_pubkey: crypto_lib_1.base.toHex(output.script),\n        });\n    });\n    return {\n        hash: txId,\n        inputs: refInputs,\n        bin_outputs: refOutputs,\n        lock_time: transaction.locktime,\n        version: transaction.version,\n    };\n}\nfunction parseDerivationPath(path) {\n    let splitPath = path.split(\'/\');\n    if (splitPath[0] === \'m\') {\n        splitPath = splitPath.slice(1);\n    }\n    const address_n = [];\n    splitPath.forEach(indexStr => {\n        let index;\n        if (indexStr.slice(-1) === `\'`) {\n            index = harden(parseInt(indexStr.slice(0, -1), 10));\n        }\n        else {\n            index = parseInt(indexStr, 10);\n        }\n        address_n.push(index);\n    });\n    return address_n;\n}\nfunction harden(num) {\n    return 0x80000000 + num;\n}\n//# sourceMappingURL=onekey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvb25la2V5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4Qix3QkFBd0IsbUJBQU8sQ0FBQywrRkFBaUI7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMsaUhBQTZCO0FBQzNELHFCQUFxQixtQkFBTyxDQUFDLG1GQUFxQjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQywyR0FBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvb25la2V5LmpzPzhjZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9uZUtleUJ1aWxkQnRjVHggPSB2b2lkIDA7XG5jb25zdCBiaXRjb2luanNfbGliXzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliXCIpO1xuY29uc3QgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWIvYnVmZmVydXRpbHNcIik7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmNvbnN0IHdhbGxldF8xID0gcmVxdWlyZShcIi4vd2FsbGV0XCIpO1xuY29uc3QgdHhCdWlsZF8xID0gcmVxdWlyZShcIi4vdHhCdWlsZFwiKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL25ldHdvcmtzXCIpO1xuY29uc3QgYWRkcmVzc1R5cGVUb09uZUtleUlucHV0U2NyaXB0VHlwZSA9IHtcbiAgICBcImxlZ2FjeVwiOiBcIlNQRU5EQUREUkVTU1wiLFxuICAgIFwic2Vnd2l0X25hdGl2ZVwiOiBcIlNQRU5EV0lUTkVTU1wiLFxuICAgIFwic2Vnd2l0X25lc3RlZFwiOiBcIlNQRU5EUDJTSFdJVE5FU1NcIixcbiAgICBcInNlZ3dpdF90YXByb290XCI6IFwiU1BFTkRUQVBST09UXCIsXG59O1xuY29uc3QgYWRkcmVzc1R5cGVUb09uZUtleU91dHB1dFNjcmlwdFR5cGUgPSB7XG4gICAgXCJsZWdhY3lcIjogXCJQQVlUT0FERFJFU1NcIixcbiAgICBcInNlZ3dpdF9uYXRpdmVcIjogXCJQQVlUT1dJVE5FU1NcIixcbiAgICBcInNlZ3dpdF9uZXN0ZWRcIjogXCJQQVlUT1AyU0hXSVRORVNTXCIsXG4gICAgXCJzZWd3aXRfdGFwcm9vdFwiOiBcIlBBWVRPVEFQUk9PVFwiLFxufTtcbmZ1bmN0aW9uIG9uZUtleUJ1aWxkQnRjVHgodHhEYXRhLCBuZXR3b3JrID0gbmV0d29ya3NfMS5iaXRjb2luKSB7XG4gICAgY29uc3QgdHggPSAoMCwgd2FsbGV0XzEuY29udmVydDJVdHhvVHgpKHR4RGF0YSk7XG4gICAgaWYgKHR4Lm9tbmkpIHtcbiAgICAgICAgY29uc3QgY29pblR5cGUgPSAoMCwgd2FsbGV0XzEubnVtYmVyMkhleCkodHgub21uaS5jb2luVHlwZSB8fCAzMSwgOCk7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9ICgwLCB3YWxsZXRfMS5udW1iZXIySGV4KSh0eC5vbW5pLmFtb3VudCwgMTYpO1xuICAgICAgICBjb25zdCBvbW5pU2NyaXB0ID0gXCI2ZjZkNmU2OVwiICsgXCIwMDAwXCIgKyBcIjAwMDBcIiArIGNvaW5UeXBlICsgYW1vdW50O1xuICAgICAgICB0eC5vdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgYWRkcmVzczogXCJcIixcbiAgICAgICAgICAgIGFtb3VudDogMCxcbiAgICAgICAgICAgIG9tbmlTY3JpcHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VBbW91bnQgPSBwYXJzZUludCgoMCwgdHhCdWlsZF8xLnNpZ25CdGMpKHR4LCBcIlwiLCBuZXR3b3JrLCB1bmRlZmluZWQsIHRydWUsIHRydWUpKTtcbiAgICBjb25zdCBkdXN0U2l6ZSA9IHR4RGF0YS5kdXN0U2l6ZSB8fCA1NDY7XG4gICAgaWYgKGNoYW5nZUFtb3VudCA+PSBkdXN0U2l6ZSkge1xuICAgICAgICB0eC5vdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgYWRkcmVzczogdHguYWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudDogY2hhbmdlQW1vdW50LFxuICAgICAgICAgICAgZGVyaXZhdGlvblBhdGg6IHR4LmRlcml2YXRpb25QYXRoLFxuICAgICAgICAgICAgaXNDaGFuZ2U6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dHMgPSBbXTtcbiAgICBjb25zdCByZWZUeHMgPSBbXTtcbiAgICB0eC5pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgY29uc3QgYWRkcmVzc19uID0gcGFyc2VEZXJpdmF0aW9uUGF0aChpbnB1dC5kZXJpdmF0aW9uUGF0aCk7XG4gICAgICAgIGlucHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3NfbixcbiAgICAgICAgICAgIHByZXZfaGFzaDogaW5wdXQudHhJZCxcbiAgICAgICAgICAgIHByZXZfaW5kZXg6IGlucHV0LnZPdXQsXG4gICAgICAgICAgICBhbW91bnQ6IGlucHV0LmFtb3VudC50b1N0cmluZygpLFxuICAgICAgICAgICAgc2NyaXB0X3R5cGU6IGFkZHJlc3NUeXBlVG9PbmVLZXlJbnB1dFNjcmlwdFR5cGVbKDAsIHR4QnVpbGRfMS5nZXRBZGRyZXNzVHlwZSkoaW5wdXQuYWRkcmVzcywgbmV0d29yayldLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVmVHhzLnB1c2gocGFyc2VSZWZUeChpbnB1dC5ub25XaXRuZXNzVXR4bywgaW5wdXQudHhJZCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcbiAgICB0eC5vdXRwdXRzLmZvckVhY2goKG91dHB1dCkgPT4ge1xuICAgICAgICBpZiAob3V0cHV0LmlzQ2hhbmdlKSB7XG4gICAgICAgICAgICBvdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGFkZHJlc3NfbjogcGFyc2VEZXJpdmF0aW9uUGF0aChvdXRwdXQuZGVyaXZhdGlvblBhdGgpLFxuICAgICAgICAgICAgICAgIGFtb3VudDogb3V0cHV0LmFtb3VudC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHNjcmlwdF90eXBlOiBhZGRyZXNzVHlwZVRvT25lS2V5T3V0cHV0U2NyaXB0VHlwZVsoMCwgdHhCdWlsZF8xLmdldEFkZHJlc3NUeXBlKShvdXRwdXQuYWRkcmVzcywgbmV0d29yayldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3V0cHV0Lm9tbmlTY3JpcHQpIHtcbiAgICAgICAgICAgIG91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgYW1vdW50OiBcIjBcIixcbiAgICAgICAgICAgICAgICBvcF9yZXR1cm5fZGF0YTogb3V0cHV0Lm9tbmlTY3JpcHQsXG4gICAgICAgICAgICAgICAgc2NyaXB0X3R5cGU6IFwiUEFZVE9PUFJFVFVSTlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IG91dHB1dC5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFtb3VudDogb3V0cHV0LmFtb3VudC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHNjcmlwdF90eXBlOiBcIlBBWVRPQUREUkVTU1wiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dHM6IGlucHV0cyxcbiAgICAgICAgb3V0cHV0czogb3V0cHV0cyxcbiAgICAgICAgcmVmVHhzOiByZWZUeHMsXG4gICAgICAgIGNvaW46IFwiYnRjXCIsXG4gICAgfTtcbn1cbmV4cG9ydHMub25lS2V5QnVpbGRCdGNUeCA9IG9uZUtleUJ1aWxkQnRjVHg7XG5mdW5jdGlvbiBwYXJzZVJlZlR4KHJhd1R4LCB0eElkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uZnJvbUhleChyYXdUeCk7XG4gICAgY29uc3QgcmVmSW5wdXRzID0gW107XG4gICAgdHJhbnNhY3Rpb24uaW5zLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICByZWZJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICBwcmV2X2hhc2g6IGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KCgwLCBidWZmZXJ1dGlsc18xLnJldmVyc2VCdWZmZXIpKGlucHV0Lmhhc2gpKSxcbiAgICAgICAgICAgIHByZXZfaW5kZXg6IGlucHV0LmluZGV4LFxuICAgICAgICAgICAgc2NyaXB0X3NpZzogY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgoaW5wdXQuc2NyaXB0KSxcbiAgICAgICAgICAgIHNlcXVlbmNlOiBpbnB1dC5zZXF1ZW5jZSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVmT3V0cHV0cyA9IFtdO1xuICAgIHRyYW5zYWN0aW9uLm91dHMuZm9yRWFjaChvdXRwdXQgPT4ge1xuICAgICAgICByZWZPdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgYW1vdW50OiBvdXRwdXQudmFsdWUsXG4gICAgICAgICAgICBzY3JpcHRfcHVia2V5OiBjcnlwdG9fbGliXzEuYmFzZS50b0hleChvdXRwdXQuc2NyaXB0KSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaDogdHhJZCxcbiAgICAgICAgaW5wdXRzOiByZWZJbnB1dHMsXG4gICAgICAgIGJpbl9vdXRwdXRzOiByZWZPdXRwdXRzLFxuICAgICAgICBsb2NrX3RpbWU6IHRyYW5zYWN0aW9uLmxvY2t0aW1lLFxuICAgICAgICB2ZXJzaW9uOiB0cmFuc2FjdGlvbi52ZXJzaW9uLFxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZURlcml2YXRpb25QYXRoKHBhdGgpIHtcbiAgICBsZXQgc3BsaXRQYXRoID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIGlmIChzcGxpdFBhdGhbMF0gPT09ICdtJykge1xuICAgICAgICBzcGxpdFBhdGggPSBzcGxpdFBhdGguc2xpY2UoMSk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3NfbiA9IFtdO1xuICAgIHNwbGl0UGF0aC5mb3JFYWNoKGluZGV4U3RyID0+IHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBpZiAoaW5kZXhTdHIuc2xpY2UoLTEpID09PSBgJ2ApIHtcbiAgICAgICAgICAgIGluZGV4ID0gaGFyZGVuKHBhcnNlSW50KGluZGV4U3RyLnNsaWNlKDAsIC0xKSwgMTApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoaW5kZXhTdHIsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzX24ucHVzaChpbmRleCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkZHJlc3Nfbjtcbn1cbmZ1bmN0aW9uIGhhcmRlbihudW0pIHtcbiAgICByZXR1cm4gMHg4MDAwMDAwMCArIG51bTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZWtleS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/onekey.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/psbtSign.js':
    /*!*************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/psbtSign.js ***!
  \*************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.generateMPCSignedPSBT = exports.generateMPCUnsignedPSBT = exports.generateMPCSignedBuyingTx = exports.generateMPCUnsignedBuyingPSBT = exports.generateMPCSignedListingPSBT = exports.generateMPCUnsignedListingPSBT = exports.generateSignedBuyingTx = exports.mergeSignedBuyingPsbt = exports.generateUnsignedBuyingPsbt = exports.generateSignedListingPsbt = exports.generateUnsignedListingPsbt = exports.extractPsbtTransaction = exports.psbtSignImpl = exports.signPsbtWithKeyPathAndScriptPathImpl = exports.signPsbtWithKeyPathAndScriptPath = exports.signPsbtWithKeyPathAndScriptPathBatch = exports.psbtDecode = exports.psbtSign = exports.classicToPsbt = exports.buildPsbt = void 0;\nconst psbt_1 = __webpack_require__(/*! ./bitcoinjs-lib/psbt */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt.js");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst txBuild_1 = __webpack_require__(/*! ./txBuild */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js");\nconst bitcoinjs_lib_1 = __webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js");\nconst taproot = __importStar(__webpack_require__(/*! ./taproot */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/taproot.js"));\nconst bip371_1 = __webpack_require__(/*! ./bitcoinjs-lib/psbt/bip371 */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/bip371.js");\nconst address_1 = __webpack_require__(/*! ./bitcoinjs-lib/address */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/address.js");\nconst bufferutils_1 = __webpack_require__(/*! ./bitcoinjs-lib/bufferutils */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bufferutils.js");\nconst psbtutils_1 = __webpack_require__(/*! ./bitcoinjs-lib/psbt/psbtutils */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt/psbtutils.js");\nconst bscript = __importStar(__webpack_require__(/*! ./bitcoinjs-lib/script */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js"));\nconst crypto_1 = __webpack_require__(/*! ./bitcoinjs-lib/crypto */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js");\nconst crypto_2 = __webpack_require__(/*! crypto */ "crypto");\nconst schnorr = crypto_lib_1.signUtil.schnorr.secp256k1.schnorr;\nconst defaultMaximumFeeRate = 5000;\nfunction buildPsbt(tx, network, maximumFeeRate) {\n    const psbt = classicToPsbt(tx, network, maximumFeeRate);\n    return psbt.toHex();\n}\nexports.buildPsbt = buildPsbt;\nfunction classicToPsbt(tx, network, maximumFeeRate) {\n    const psbt = new psbt_1.Psbt({ network, maximumFeeRate: maximumFeeRate ? maximumFeeRate : defaultMaximumFeeRate });\n    tx.inputs.forEach((input) => {\n        const outputScript = (0, address_1.toOutputScript)(input.address, network);\n        let inputData = {\n            hash: input.txId,\n            index: input.vOut,\n            witnessUtxo: { script: outputScript, value: input.amount },\n        };\n        const addressType = (0, txBuild_1.getAddressType)(input.address, network || bitcoinjs_lib_1.networks.bitcoin);\n        if (input.bip32Derivation) {\n            if (addressType === \'segwit_taproot\') {\n                inputData.tapBip32Derivation = input.bip32Derivation.map((derivation) => {\n                    let pubBuf = crypto_lib_1.base.fromHex(derivation.pubkey);\n                    if (pubBuf.length != 32) {\n                        pubBuf = pubBuf.slice(1);\n                    }\n                    return {\n                        masterFingerprint: crypto_lib_1.base.fromHex(derivation.masterFingerprint),\n                        pubkey: pubBuf,\n                        path: derivation.path,\n                        leafHashes: derivation.leafHashes.map((leaf) => {\n                            return Buffer.from(leaf, \'hex\');\n                        }),\n                    };\n                });\n            }\n            else {\n                inputData.bip32Derivation = input.bip32Derivation.map((derivation) => {\n                    return {\n                        masterFingerprint: crypto_lib_1.base.fromHex(derivation.masterFingerprint),\n                        pubkey: crypto_lib_1.base.fromHex(derivation.pubkey),\n                        path: derivation.path,\n                    };\n                });\n            }\n        }\n        if (addressType === \'legacy\') {\n            inputData.nonWitnessUtxo = crypto_lib_1.base.fromHex(input.nonWitnessUtxo);\n        }\n        else if (addressType === \'segwit_taproot\') {\n            if (input.publicKey) {\n                inputData.tapInternalKey = (0, bip371_1.toXOnly)(crypto_lib_1.base.fromHex(input.publicKey));\n            }\n        }\n        else if (addressType === \'segwit_nested\') {\n            inputData.redeemScript = bitcoinjs_lib_1.payments.p2wpkh({\n                pubkey: Buffer.from(input.publicKey, \'hex\'),\n                network,\n            }).output;\n        }\n        if (input.sighashType) {\n            inputData.sighashType = input.sighashType;\n        }\n        psbt.addInput(inputData);\n    });\n    tx.outputs.forEach((output) => {\n        if (output.omniScript) {\n            psbt.addOutput({ script: crypto_lib_1.base.fromHex(output.omniScript), value: 0 });\n        }\n        else {\n            let outputData = { address: output.address, value: output.amount };\n            if (output.bip32Derivation) {\n                outputData.bip32Derivation = output.bip32Derivation.map((derivation) => {\n                    return {\n                        masterFingerprint: crypto_lib_1.base.fromHex(derivation.masterFingerprint),\n                        pubkey: crypto_lib_1.base.fromHex(derivation.pubkey),\n                        path: derivation.path,\n                    };\n                });\n            }\n            psbt.addOutput(outputData);\n        }\n    });\n    return psbt;\n}\nexports.classicToPsbt = classicToPsbt;\nfunction psbtSign(psbtBase64, privateKey, network, maximumFeeRate) {\n    const psbt = psbt_1.Psbt.fromBase64(psbtBase64, {\n        network,\n        maximumFeeRate: maximumFeeRate ? maximumFeeRate : defaultMaximumFeeRate\n    });\n    psbtSignImpl(psbt, privateKey, network);\n    return psbt.toBase64();\n}\nexports.psbtSign = psbtSign;\nfunction psbtDecode(psbtBase64, network, maximumFeeRate) {\n    try {\n        const psbt = psbt_1.Psbt.fromHex(psbtBase64, {\n            network,\n            maximumFeeRate: maximumFeeRate ? maximumFeeRate : defaultMaximumFeeRate\n        });\n        return psbt.txInputs ? psbt.txInputs.filter(a => !a.hash.equals(Buffer.alloc(32)))\n            .map((a => {\n            return { txId: crypto_lib_1.base.toHex(crypto_lib_1.base.reverseBuffer(a.hash)), vOut: a.index };\n        })) : [];\n    }\n    catch (e) {\n        const psbt = psbt_1.Psbt.fromBase64(psbtBase64, {\n            network,\n            maximumFeeRate: maximumFeeRate ? maximumFeeRate : defaultMaximumFeeRate\n        });\n        return psbt.txInputs ? psbt.txInputs.filter(a => !a.hash.equals(Buffer.alloc(32)))\n            .map((a => {\n            return { txId: crypto_lib_1.base.toHex(crypto_lib_1.base.reverseBuffer(a.hash)), vOut: a.index };\n        })) : [];\n    }\n}\nexports.psbtDecode = psbtDecode;\nfunction signPsbtWithKeyPathAndScriptPathBatch(psbtHexs, privateKey, network, opts) {\n    if (psbtHexs == undefined || psbtHexs.length == 0) {\n        return [];\n    }\n    let res = [];\n    const optsSize = opts == undefined ? 0 : opts.length;\n    let i = 0;\n    for (i = 0; i < psbtHexs.length; i++) {\n        let opt = {};\n        if (i < optsSize && opts) {\n            opt = opts[i];\n        }\n        const signedPsbt = signPsbtWithKeyPathAndScriptPath(psbtHexs[i], privateKey, network, {\n            autoFinalized: opt.autoFinalized,\n            toSignInputs: opt.toSignInputs\n        });\n        res.push(signedPsbt);\n    }\n    return res;\n}\nexports.signPsbtWithKeyPathAndScriptPathBatch = signPsbtWithKeyPathAndScriptPathBatch;\nfunction signPsbtWithKeyPathAndScriptPath(psbtStr, privateKey, network, opts = {}) {\n    const psbt = getPsbtFromString(psbtStr, network);\n    signPsbtWithKeyPathAndScriptPathImpl(psbt, privateKey, network, opts.autoFinalized, opts.toSignInputs);\n    return psbt.toHex();\n}\nexports.signPsbtWithKeyPathAndScriptPath = signPsbtWithKeyPathAndScriptPath;\nfunction signPsbtWithKeyPathAndScriptPathImpl(psbt, privateKey, network, autoFinalized, signInputs) {\n    network = network || bitcoinjs_lib_1.networks.bitcoin;\n    const privKeyHex = (0, txBuild_1.privateKeyFromWIF)(privateKey, network);\n    const signInputMap = new Map();\n    if (signInputs != undefined) {\n        signInputs.map(e => {\n            signInputMap.set(e.index, e);\n        });\n    }\n    const signer = {\n        psbtIndex: 0,\n        needTweak: true,\n        tweakHash: Buffer.alloc(0),\n        toSignInputsMap: signInputMap,\n        publicKey: Buffer.alloc(0),\n        sign(hash) {\n            return (0, txBuild_1.sign)(hash, privKeyHex);\n        },\n        signSchnorr(hash) {\n            let tweakedPrivKey = taproot.taprootTweakPrivKey(crypto_lib_1.base.fromHex(privKeyHex));\n            if (this.toSignInputsMap?.has(this.psbtIndex)) {\n                if (this.toSignInputsMap.get(this.psbtIndex)?.disableTweakSigner) {\n                    return Buffer.from(schnorr.sign(hash, privKeyHex, crypto_lib_1.base.randomBytes(32)));\n                }\n            }\n            if (!this.needTweak) {\n                return Buffer.from(schnorr.sign(hash, privKeyHex, crypto_lib_1.base.randomBytes(32)));\n            }\n            if (this.needTweak && this.tweakHash.length > 0) {\n                tweakedPrivKey = taproot.taprootTweakPrivKey(crypto_lib_1.base.fromHex(privKeyHex), this.tweakHash);\n            }\n            return Buffer.from(schnorr.sign(hash, tweakedPrivKey, crypto_lib_1.base.randomBytes(32)));\n        },\n    };\n    let allowedSighashTypes = [\n        bitcoinjs_lib_1.Transaction.SIGHASH_SINGLE | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY,\n        bitcoinjs_lib_1.Transaction.SIGHASH_ALL,\n        bitcoinjs_lib_1.Transaction.SIGHASH_DEFAULT\n    ];\n    for (let i = 0; i < psbt.inputCount; i++) {\n        if (signInputMap?.size > 0 && !signInputMap?.has(i)) {\n            continue;\n        }\n        signer.psbtIndex = i;\n        const input = psbt.data.inputs[i];\n        if ((0, bip371_1.isTaprootInput)(input)) {\n            if (!input.tapInternalKey) {\n                input.tapInternalKey = (0, bip371_1.toXOnly)((0, txBuild_1.wif2Public)(privateKey, network));\n            }\n            signer.needTweak = true;\n            signer.publicKey = Buffer.from(taproot.taprootTweakPubkey((0, bip371_1.toXOnly)((0, txBuild_1.wif2Public)(privateKey, network)))[0]);\n            if (signInputMap?.has(i)) {\n                if (signInputMap?.get(i)?.disableTweakSigner) {\n                    signer.publicKey = (0, txBuild_1.wif2Public)(privateKey, network);\n                    signer.needTweak = false;\n                }\n            }\n            if (input.tapLeafScript && input.tapLeafScript?.length > 0 && !input.tapMerkleRoot) {\n                input.tapLeafScript.map(e => {\n                    if (e.controlBlock && e.script) {\n                        signer.publicKey = (0, txBuild_1.wif2Public)(privateKey, network);\n                        signer.needTweak = false;\n                    }\n                });\n            }\n            else if (input.tapMerkleRoot) {\n                signer.needTweak = true;\n                signer.tweakHash = input.tapMerkleRoot;\n                signer.publicKey = Buffer.from(taproot.taprootTweakPubkey((0, bip371_1.toXOnly)((0, txBuild_1.wif2Public)(privateKey, network)), input.tapMerkleRoot)[0]);\n            }\n        }\n        else {\n            signer.needTweak = false;\n            signer.tweakHash = Buffer.alloc(0);\n            signer.publicKey = (0, txBuild_1.wif2Public)(privateKey, network);\n        }\n        try {\n            if (signInputMap?.has(i)) {\n                const sighashTypes = signInputMap?.get(i)?.sighashTypes;\n                if (sighashTypes != undefined) {\n                    allowedSighashTypes = sighashTypes;\n                }\n            }\n            psbt.signInput(i, signer, allowedSighashTypes);\n            if (autoFinalized != undefined && !autoFinalized) {\n                continue;\n            }\n            psbt.finalizeInput(i);\n        }\n        catch (e) {\n            if (signInputMap?.size > 0 && signInputMap?.has(i)) {\n                throw e;\n            }\n        }\n    }\n}\nexports.signPsbtWithKeyPathAndScriptPathImpl = signPsbtWithKeyPathAndScriptPathImpl;\nfunction psbtSignImpl(psbt, privateKey, network) {\n    network = network || bitcoinjs_lib_1.networks.bitcoin;\n    const privKeyHex = (0, txBuild_1.privateKeyFromWIF)(privateKey, network);\n    const signer = {\n        publicKey: Buffer.alloc(0),\n        sign(hash) {\n            return (0, txBuild_1.sign)(hash, privKeyHex);\n        },\n        signSchnorr(hash) {\n            const tweakedPrivKey = taproot.taprootTweakPrivKey(crypto_lib_1.base.fromHex(privKeyHex));\n            return Buffer.from(schnorr.sign(hash, tweakedPrivKey, crypto_lib_1.base.randomBytes(32)));\n        },\n    };\n    const allowedSighashTypes = [\n        bitcoinjs_lib_1.Transaction.SIGHASH_SINGLE | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY,\n        bitcoinjs_lib_1.Transaction.SIGHASH_ALL | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY,\n        bitcoinjs_lib_1.Transaction.SIGHASH_ALL,\n        bitcoinjs_lib_1.Transaction.SIGHASH_DEFAULT\n    ];\n    for (let i = 0; i < psbt.inputCount; i++) {\n        if ((0, bip371_1.isTaprootInput)(psbt.data.inputs[i])) {\n            const input = psbt.data.inputs[i];\n            if (!input.tapInternalKey) {\n                input.tapInternalKey = (0, bip371_1.toXOnly)((0, txBuild_1.wif2Public)(privateKey, network));\n            }\n            signer.publicKey = Buffer.from(taproot.taprootTweakPubkey((0, bip371_1.toXOnly)((0, txBuild_1.wif2Public)(privateKey, network)))[0]);\n        }\n        else {\n            signer.publicKey = (0, txBuild_1.wif2Public)(privateKey, network);\n        }\n        try {\n            psbt.signInput(i, signer, allowedSighashTypes);\n        }\n        catch (e) {\n        }\n    }\n}\nexports.psbtSignImpl = psbtSignImpl;\nfunction extractPsbtTransaction(txHex, network, maximumFeeRate) {\n    const psbt = psbt_1.Psbt.fromHex(txHex, {\n        network,\n        maximumFeeRate: maximumFeeRate ? maximumFeeRate : defaultMaximumFeeRate\n    });\n    let extractedTransaction;\n    try {\n        extractedTransaction = psbt.finalizeAllInputs().extractTransaction();\n    }\n    catch (e) {\n        extractedTransaction = psbt.extractTransaction();\n        console.log(e);\n    }\n    return extractedTransaction.toHex();\n}\nexports.extractPsbtTransaction = extractPsbtTransaction;\nfunction generateUnsignedListingPsbt(listingData, network, publicKey) {\n    const script = bitcoinjs_lib_1.address.toOutputScript(listingData.nftAddress, network);\n    if (((0, psbtutils_1.isP2SHScript)(script) || (0, psbtutils_1.isP2TR)(script)) && !publicKey) {\n        throw new Error("Missing publicKey");\n    }\n    const tx = {\n        inputs: [],\n        outputs: [],\n    };\n    let placeholderAddress = "bc1pcyj5mt2q4t4py8jnur8vpxvxxchke4pzy7tdr9yvj3u3kdfgrj6sw3rzmr";\n    if (network === bitcoinjs_lib_1.networks.testnet) {\n        placeholderAddress = "tb1pcyj5mt2q4t4py8jnur8vpxvxxchke4pzy7tdr9yvj3u3kdfgrj6see4dpv";\n    }\n    tx.inputs.push({\n        txId: "0".repeat(64),\n        vOut: 0,\n        amount: 0,\n        address: placeholderAddress,\n    }, {\n        txId: "0".repeat(64),\n        vOut: 1,\n        amount: 0,\n        address: placeholderAddress,\n    });\n    tx.outputs.push({\n        address: placeholderAddress,\n        amount: 0,\n    }, {\n        address: placeholderAddress,\n        amount: 0,\n    });\n    tx.inputs.push({\n        txId: listingData.nftUtxo.txHash,\n        vOut: listingData.nftUtxo.vout,\n        address: listingData.nftAddress,\n        amount: listingData.nftUtxo.coinAmount,\n        publicKey: publicKey,\n        nonWitnessUtxo: listingData.nftUtxo.rawTransation,\n        sighashType: bitcoinjs_lib_1.Transaction.SIGHASH_SINGLE | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY,\n    });\n    tx.outputs.push({\n        address: listingData.receiveBtcAddress,\n        amount: listingData.price,\n    });\n    const psbtHex = buildPsbt(tx, network);\n    return crypto_lib_1.base.toBase64(crypto_lib_1.base.fromHex(psbtHex));\n}\nexports.generateUnsignedListingPsbt = generateUnsignedListingPsbt;\nfunction generateSignedListingPsbt(listingData, privateKey, network) {\n    const publicKey = crypto_lib_1.base.toHex((0, txBuild_1.wif2Public)(privateKey, network));\n    return psbtSign(generateUnsignedListingPsbt(listingData, network, publicKey), privateKey, network);\n}\nexports.generateSignedListingPsbt = generateSignedListingPsbt;\nconst SELLER_INDEX = 2;\nconst DUMMY_AMOUNT = 600;\nconst DUST_OUTPUT_LIMIT = 546;\nfunction generateUnsignedBuyingPsbt(buyingData, network, publicKey) {\n    const tx = {\n        inputs: [],\n        outputs: [],\n        address: buyingData.paymentAndChangeAddress,\n        feePerB: buyingData.feeRate,\n    };\n    buyingData.dummyUtxos.forEach(dummyUtxo => {\n        tx.inputs.push({\n            txId: dummyUtxo.txHash,\n            vOut: dummyUtxo.vout,\n            address: buyingData.paymentAndChangeAddress,\n            amount: dummyUtxo.coinAmount,\n            publicKey: publicKey,\n            nonWitnessUtxo: dummyUtxo.rawTransation,\n        });\n    });\n    tx.outputs.push({\n        address: buyingData.paymentAndChangeAddress,\n        amount: buyingData.dummyUtxos.reduce((sum, dummyUtxo) => sum + dummyUtxo.coinAmount, 0),\n    });\n    const nftOutputs = [];\n    buyingData.sellerPsbts.forEach(sellerPsbt => {\n        const psbt = psbt_1.Psbt.fromBase64(sellerPsbt, { network });\n        const nftInput = psbt.data.globalMap.unsignedTx.tx.ins[SELLER_INDEX];\n        nftOutputs.push(psbt.data.globalMap.unsignedTx.tx.outs[SELLER_INDEX]);\n        let nftUtxo = psbt.data.inputs[SELLER_INDEX].witnessUtxo;\n        if (!nftUtxo) {\n            nftUtxo = bitcoinjs_lib_1.Transaction.fromBuffer(psbt.data.inputs[SELLER_INDEX].nonWitnessUtxo).outs[nftInput.index];\n        }\n        tx.inputs.push({\n            txId: crypto_lib_1.base.toHex((0, bufferutils_1.reverseBuffer)(nftInput.hash)),\n            vOut: nftInput.index,\n            address: bitcoinjs_lib_1.address.fromOutputScript(nftUtxo.script, network),\n            amount: nftUtxo.value,\n            sighashType: bitcoinjs_lib_1.Transaction.SIGHASH_SINGLE | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY,\n        });\n        tx.outputs.push({\n            address: buyingData.receiveNftAddress,\n            amount: nftUtxo.value,\n        });\n    });\n    nftOutputs.forEach(nftOutput => {\n        tx.outputs.push({\n            address: bitcoinjs_lib_1.address.fromOutputScript(nftOutput.script, network),\n            amount: nftOutput.value,\n        });\n    });\n    buyingData.paymentUtxos.forEach(paymentUtxo => {\n        tx.inputs.push({\n            txId: paymentUtxo.txHash,\n            vOut: paymentUtxo.vout,\n            address: buyingData.paymentAndChangeAddress,\n            amount: paymentUtxo.coinAmount,\n            publicKey: publicKey,\n            nonWitnessUtxo: paymentUtxo.rawTransation,\n        });\n    });\n    buyingData.dummyUtxos.forEach(() => {\n        tx.outputs.push({\n            address: buyingData.paymentAndChangeAddress,\n            amount: DUMMY_AMOUNT,\n        });\n    });\n    const changeAmount = parseInt((0, txBuild_1.signBtc)(tx, "", network, undefined, false, true));\n    if (changeAmount >= DUST_OUTPUT_LIMIT) {\n        tx.outputs.push({\n            address: buyingData.paymentAndChangeAddress,\n            amount: changeAmount,\n        });\n    }\n    return crypto_lib_1.base.toBase64(crypto_lib_1.base.fromHex(buildPsbt(tx, network)));\n}\nexports.generateUnsignedBuyingPsbt = generateUnsignedBuyingPsbt;\nfunction mergeSignedBuyingPsbt(signedBuyingPsbt, signedListingPsbts) {\n    const buyerSignedPsbt = psbt_1.Psbt.fromBase64(signedBuyingPsbt);\n    const nftIndex = signedListingPsbts.length + 1;\n    signedListingPsbts.forEach((signedListingPsbt, i) => {\n        const sellerSignedPsbt = psbt_1.Psbt.fromBase64(signedListingPsbt);\n        buyerSignedPsbt.data.globalMap.unsignedTx.tx.ins[nftIndex + i]\n            = sellerSignedPsbt.data.globalMap.unsignedTx.tx.ins[SELLER_INDEX];\n        buyerSignedPsbt.data.inputs[nftIndex + i]\n            = sellerSignedPsbt.data.inputs[SELLER_INDEX];\n    });\n    return buyerSignedPsbt;\n}\nexports.mergeSignedBuyingPsbt = mergeSignedBuyingPsbt;\nfunction generateSignedBuyingTx(buyingData, privateKey, network) {\n    const publicKey = crypto_lib_1.base.toHex((0, txBuild_1.wif2Public)(privateKey, network));\n    const signedBuyingPsbt = psbtSign(generateUnsignedBuyingPsbt(buyingData, network, publicKey), privateKey, network);\n    return extractPsbtTransaction(mergeSignedBuyingPsbt(signedBuyingPsbt, buyingData.sellerPsbts).toHex(), network);\n}\nexports.generateSignedBuyingTx = generateSignedBuyingTx;\nfunction generateMPCUnsignedListingPSBT(psbtBase64, pubKeyHex, network) {\n    const psbt = psbt_1.Psbt.fromBase64(psbtBase64, { network });\n    const publicKey = crypto_lib_1.base.fromHex(pubKeyHex);\n    const sighashTypes = [bitcoinjs_lib_1.Transaction.SIGHASH_SINGLE | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY];\n    let signHashList = [];\n    for (let i = 0; i < psbt.inputCount; i++) {\n        if (i != SELLER_INDEX) {\n            continue;\n        }\n        const { hash, sighashType } = psbt.getHashAndSighashType(i, publicKey, sighashTypes);\n        signHashList.push(crypto_lib_1.base.toHex(hash));\n    }\n    return {\n        psbtBase64: psbtBase64,\n        signHashList: signHashList,\n    };\n}\nexports.generateMPCUnsignedListingPSBT = generateMPCUnsignedListingPSBT;\nfunction generateMPCSignedListingPSBT(psbtBase64, pubKeyHex, signature, network) {\n    const psbt = psbt_1.Psbt.fromBase64(psbtBase64, { network });\n    const publicKey = crypto_lib_1.base.fromHex(pubKeyHex);\n    const partialSig = [\n        {\n            pubkey: publicKey,\n            signature: bscript.signature.encode(crypto_lib_1.base.fromHex(signature), bitcoinjs_lib_1.Transaction.SIGHASH_SINGLE | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY),\n        },\n    ];\n    psbt.data.updateInput(SELLER_INDEX, { partialSig });\n    return psbt.toBase64();\n}\nexports.generateMPCSignedListingPSBT = generateMPCSignedListingPSBT;\nfunction generateMPCUnsignedBuyingPSBT(psbtBase64, pubKeyHex, network, batchSize = 1) {\n    const psbt = psbt_1.Psbt.fromBase64(psbtBase64, { network });\n    const publicKey = crypto_lib_1.base.fromHex(pubKeyHex);\n    const sighashTypes = [bitcoinjs_lib_1.Transaction.SIGHASH_ALL];\n    let signHashList = [];\n    const sellerIndex = batchSize + 1;\n    for (let i = 0; i < psbt.inputCount; i++) {\n        if (i >= sellerIndex && i < sellerIndex + batchSize) {\n            continue;\n        }\n        const { hash, sighashType } = psbt.getHashAndSighashType(i, publicKey, sighashTypes);\n        signHashList.push(crypto_lib_1.base.toHex(hash));\n    }\n    return {\n        psbtBase64: psbtBase64,\n        signHashList: signHashList,\n    };\n}\nexports.generateMPCUnsignedBuyingPSBT = generateMPCUnsignedBuyingPSBT;\nfunction generateMPCSignedBuyingTx(psbtBase64, pubKeyHex, signatureList, network, batchSize = 1) {\n    const psbt = psbt_1.Psbt.fromBase64(psbtBase64, { network });\n    const publicKey = crypto_lib_1.base.fromHex(pubKeyHex);\n    const sellerIndex = batchSize + 1;\n    for (let i = 0; i < psbt.inputCount; i++) {\n        if (i >= sellerIndex && i < sellerIndex + batchSize) {\n            continue;\n        }\n        const partialSig = [\n            {\n                pubkey: publicKey,\n                signature: bscript.signature.encode(crypto_lib_1.base.fromHex(signatureList[i]), bitcoinjs_lib_1.Transaction.SIGHASH_ALL),\n            },\n        ];\n        psbt.data.updateInput(i, { partialSig });\n    }\n    return extractPsbtTransaction(psbt.toHex(), network);\n}\nexports.generateMPCSignedBuyingTx = generateMPCSignedBuyingTx;\nfunction generateMPCUnsignedPSBT(psbtStr, pubKeyHex, network) {\n    const psbt = getPsbtFromString(psbtStr, network);\n    const publicKey = crypto_lib_1.base.fromHex(pubKeyHex);\n    const allowedSighashTypes = [\n        bitcoinjs_lib_1.Transaction.SIGHASH_SINGLE | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY,\n        bitcoinjs_lib_1.Transaction.SIGHASH_SINGLE | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY,\n        bitcoinjs_lib_1.Transaction.SIGHASH_ALL | bitcoinjs_lib_1.Transaction.SIGHASH_ANYONECANPAY,\n        bitcoinjs_lib_1.Transaction.SIGHASH_ALL,\n        bitcoinjs_lib_1.Transaction.SIGHASH_DEFAULT\n    ];\n    ;\n    let signHashList = [];\n    for (let i = 0; i < psbt.inputCount; i++) {\n        try {\n            const { hash, sighashType } = psbt.getHashAndSighashType(i, publicKey, allowedSighashTypes);\n            signHashList.push(crypto_lib_1.base.toHex(hash));\n        }\n        catch (e) {\n            const s = getRandomHash();\n            signHashList.push(s);\n        }\n    }\n    const m = new Map();\n    signHashList.map((e, i) => {\n        let count = m.get(e);\n        count = count == undefined ? 0 : count;\n        if (count != undefined && count >= 1) {\n            signHashList[i] = getRandomHash();\n        }\n        m.set(e, count + 1);\n    });\n    return {\n        psbtStr: psbtStr,\n        signHashList: signHashList,\n    };\n}\nexports.generateMPCUnsignedPSBT = generateMPCUnsignedPSBT;\nfunction getRandomHash() {\n    const h = (0, crypto_1.sha256)((0, crypto_2.randomBytes)(32));\n    const s = crypto_lib_1.base.toHex(h.slice(0, 28));\n    return "ffffffff" + s;\n}\nfunction generateMPCSignedPSBT(psbtStr, pubKeyHex, signatureList, network) {\n    const psbt = getPsbtFromString(psbtStr, network);\n    const publicKey = crypto_lib_1.base.fromHex(pubKeyHex);\n    let sighashType = bitcoinjs_lib_1.Transaction.SIGHASH_ALL;\n    const res = generateMPCUnsignedPSBT(psbtStr, pubKeyHex, network);\n    const signHashList = res.signHashList;\n    for (let i = 0; i < psbt.inputCount; i++) {\n        if (signHashList[i].slice(0, 8) == "ffffffff") {\n            continue;\n        }\n        if (psbt.data.inputs[i].sighashType != undefined) {\n            sighashType = psbt.data.inputs[i].sighashType;\n        }\n        const partialSig = [\n            {\n                pubkey: publicKey,\n                signature: bscript.signature.encode(crypto_lib_1.base.fromHex(signatureList[i]), sighashType),\n            },\n        ];\n        try {\n            psbt.data.updateInput(i, { partialSig });\n        }\n        catch (e) {\n        }\n    }\n    return psbt.toHex();\n}\nexports.generateMPCSignedPSBT = generateMPCSignedPSBT;\nfunction getPsbtFromString(psbtStr, network) {\n    let psbt;\n    if (crypto_lib_1.base.isHexString("0x" + psbtStr)) {\n        psbt = psbt_1.Psbt.fromHex(psbtStr, { network });\n    }\n    else {\n        psbt = psbt_1.Psbt.fromBase64(psbtStr, { network });\n    }\n    return psbt;\n}\n//# sourceMappingURL=psbtSign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvcHNidFNpZ24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLCtCQUErQixHQUFHLGlDQUFpQyxHQUFHLHFDQUFxQyxHQUFHLG9DQUFvQyxHQUFHLHNDQUFzQyxHQUFHLDhCQUE4QixHQUFHLDZCQUE2QixHQUFHLGtDQUFrQyxHQUFHLGlDQUFpQyxHQUFHLG1DQUFtQyxHQUFHLDhCQUE4QixHQUFHLG9CQUFvQixHQUFHLDRDQUE0QyxHQUFHLHdDQUF3QyxHQUFHLDZDQUE2QyxHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLHFCQUFxQixHQUFHLGlCQUFpQjtBQUNqcUIsZUFBZSxtQkFBTyxDQUFDLG1HQUFzQjtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsNkVBQVc7QUFDckMsd0JBQXdCLG1CQUFPLENBQUMsK0ZBQWlCO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLDZFQUFXO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLGlIQUE2QjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQyx5R0FBeUI7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsaUhBQTZCO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLHVIQUFnQztBQUM1RCw2QkFBNkIsbUJBQU8sQ0FBQyx1R0FBd0I7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsdUdBQXdCO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG1DQUFtQyxrRkFBa0Y7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQ0FBMkM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWdFO0FBQzdGO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L3BzYnRTaWduLmpzP2IwYmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVNUENTaWduZWRQU0JUID0gZXhwb3J0cy5nZW5lcmF0ZU1QQ1Vuc2lnbmVkUFNCVCA9IGV4cG9ydHMuZ2VuZXJhdGVNUENTaWduZWRCdXlpbmdUeCA9IGV4cG9ydHMuZ2VuZXJhdGVNUENVbnNpZ25lZEJ1eWluZ1BTQlQgPSBleHBvcnRzLmdlbmVyYXRlTVBDU2lnbmVkTGlzdGluZ1BTQlQgPSBleHBvcnRzLmdlbmVyYXRlTVBDVW5zaWduZWRMaXN0aW5nUFNCVCA9IGV4cG9ydHMuZ2VuZXJhdGVTaWduZWRCdXlpbmdUeCA9IGV4cG9ydHMubWVyZ2VTaWduZWRCdXlpbmdQc2J0ID0gZXhwb3J0cy5nZW5lcmF0ZVVuc2lnbmVkQnV5aW5nUHNidCA9IGV4cG9ydHMuZ2VuZXJhdGVTaWduZWRMaXN0aW5nUHNidCA9IGV4cG9ydHMuZ2VuZXJhdGVVbnNpZ25lZExpc3RpbmdQc2J0ID0gZXhwb3J0cy5leHRyYWN0UHNidFRyYW5zYWN0aW9uID0gZXhwb3J0cy5wc2J0U2lnbkltcGwgPSBleHBvcnRzLnNpZ25Qc2J0V2l0aEtleVBhdGhBbmRTY3JpcHRQYXRoSW1wbCA9IGV4cG9ydHMuc2lnblBzYnRXaXRoS2V5UGF0aEFuZFNjcmlwdFBhdGggPSBleHBvcnRzLnNpZ25Qc2J0V2l0aEtleVBhdGhBbmRTY3JpcHRQYXRoQmF0Y2ggPSBleHBvcnRzLnBzYnREZWNvZGUgPSBleHBvcnRzLnBzYnRTaWduID0gZXhwb3J0cy5jbGFzc2ljVG9Qc2J0ID0gZXhwb3J0cy5idWlsZFBzYnQgPSB2b2lkIDA7XG5jb25zdCBwc2J0XzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL3BzYnRcIik7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmNvbnN0IHR4QnVpbGRfMSA9IHJlcXVpcmUoXCIuL3R4QnVpbGRcIik7XG5jb25zdCBiaXRjb2luanNfbGliXzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliXCIpO1xuY29uc3QgdGFwcm9vdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi90YXByb290XCIpKTtcbmNvbnN0IGJpcDM3MV8xID0gcmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYi9wc2J0L2JpcDM3MVwiKTtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWIvYWRkcmVzc1wiKTtcbmNvbnN0IGJ1ZmZlcnV0aWxzXzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL2J1ZmZlcnV0aWxzXCIpO1xuY29uc3QgcHNidHV0aWxzXzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL3BzYnQvcHNidHV0aWxzXCIpO1xuY29uc3QgYnNjcmlwdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL3NjcmlwdFwiKSk7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWIvY3J5cHRvXCIpO1xuY29uc3QgY3J5cHRvXzIgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3Qgc2Nobm9yciA9IGNyeXB0b19saWJfMS5zaWduVXRpbC5zY2hub3JyLnNlY3AyNTZrMS5zY2hub3JyO1xuY29uc3QgZGVmYXVsdE1heGltdW1GZWVSYXRlID0gNTAwMDtcbmZ1bmN0aW9uIGJ1aWxkUHNidCh0eCwgbmV0d29yaywgbWF4aW11bUZlZVJhdGUpIHtcbiAgICBjb25zdCBwc2J0ID0gY2xhc3NpY1RvUHNidCh0eCwgbmV0d29yaywgbWF4aW11bUZlZVJhdGUpO1xuICAgIHJldHVybiBwc2J0LnRvSGV4KCk7XG59XG5leHBvcnRzLmJ1aWxkUHNidCA9IGJ1aWxkUHNidDtcbmZ1bmN0aW9uIGNsYXNzaWNUb1BzYnQodHgsIG5ldHdvcmssIG1heGltdW1GZWVSYXRlKSB7XG4gICAgY29uc3QgcHNidCA9IG5ldyBwc2J0XzEuUHNidCh7IG5ldHdvcmssIG1heGltdW1GZWVSYXRlOiBtYXhpbXVtRmVlUmF0ZSA/IG1heGltdW1GZWVSYXRlIDogZGVmYXVsdE1heGltdW1GZWVSYXRlIH0pO1xuICAgIHR4LmlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXRTY3JpcHQgPSAoMCwgYWRkcmVzc18xLnRvT3V0cHV0U2NyaXB0KShpbnB1dC5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgICAgbGV0IGlucHV0RGF0YSA9IHtcbiAgICAgICAgICAgIGhhc2g6IGlucHV0LnR4SWQsXG4gICAgICAgICAgICBpbmRleDogaW5wdXQudk91dCxcbiAgICAgICAgICAgIHdpdG5lc3NVdHhvOiB7IHNjcmlwdDogb3V0cHV0U2NyaXB0LCB2YWx1ZTogaW5wdXQuYW1vdW50IH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZHJlc3NUeXBlID0gKDAsIHR4QnVpbGRfMS5nZXRBZGRyZXNzVHlwZSkoaW5wdXQuYWRkcmVzcywgbmV0d29yayB8fCBiaXRjb2luanNfbGliXzEubmV0d29ya3MuYml0Y29pbik7XG4gICAgICAgIGlmIChpbnB1dC5iaXAzMkRlcml2YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gJ3NlZ3dpdF90YXByb290Jykge1xuICAgICAgICAgICAgICAgIGlucHV0RGF0YS50YXBCaXAzMkRlcml2YXRpb24gPSBpbnB1dC5iaXAzMkRlcml2YXRpb24ubWFwKChkZXJpdmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwdWJCdWYgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KGRlcml2YXRpb24ucHVia2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB1YkJ1Zi5sZW5ndGggIT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YkJ1ZiA9IHB1YkJ1Zi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQ6IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoZGVyaXZhdGlvbi5tYXN0ZXJGaW5nZXJwcmludCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IHB1YkJ1ZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGRlcml2YXRpb24ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWZIYXNoZXM6IGRlcml2YXRpb24ubGVhZkhhc2hlcy5tYXAoKGxlYWYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20obGVhZiwgJ2hleCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dERhdGEuYmlwMzJEZXJpdmF0aW9uID0gaW5wdXQuYmlwMzJEZXJpdmF0aW9uLm1hcCgoZGVyaXZhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQ6IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoZGVyaXZhdGlvbi5tYXN0ZXJGaW5nZXJwcmludCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoZGVyaXZhdGlvbi5wdWJrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZGVyaXZhdGlvbi5wYXRoLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgICAgICAgIGlucHV0RGF0YS5ub25XaXRuZXNzVXR4byA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoaW5wdXQubm9uV2l0bmVzc1V0eG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFkZHJlc3NUeXBlID09PSAnc2Vnd2l0X3RhcHJvb3QnKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQucHVibGljS2V5KSB7XG4gICAgICAgICAgICAgICAgaW5wdXREYXRhLnRhcEludGVybmFsS2V5ID0gKDAsIGJpcDM3MV8xLnRvWE9ubHkpKGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoaW5wdXQucHVibGljS2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWRkcmVzc1R5cGUgPT09ICdzZWd3aXRfbmVzdGVkJykge1xuICAgICAgICAgICAgaW5wdXREYXRhLnJlZGVlbVNjcmlwdCA9IGJpdGNvaW5qc19saWJfMS5wYXltZW50cy5wMndwa2goe1xuICAgICAgICAgICAgICAgIHB1YmtleTogQnVmZmVyLmZyb20oaW5wdXQucHVibGljS2V5LCAnaGV4JyksXG4gICAgICAgICAgICAgICAgbmV0d29yayxcbiAgICAgICAgICAgIH0pLm91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuc2lnaGFzaFR5cGUpIHtcbiAgICAgICAgICAgIGlucHV0RGF0YS5zaWdoYXNoVHlwZSA9IGlucHV0LnNpZ2hhc2hUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHBzYnQuYWRkSW5wdXQoaW5wdXREYXRhKTtcbiAgICB9KTtcbiAgICB0eC5vdXRwdXRzLmZvckVhY2goKG91dHB1dCkgPT4ge1xuICAgICAgICBpZiAob3V0cHV0Lm9tbmlTY3JpcHQpIHtcbiAgICAgICAgICAgIHBzYnQuYWRkT3V0cHV0KHsgc2NyaXB0OiBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KG91dHB1dC5vbW5pU2NyaXB0KSwgdmFsdWU6IDAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0RGF0YSA9IHsgYWRkcmVzczogb3V0cHV0LmFkZHJlc3MsIHZhbHVlOiBvdXRwdXQuYW1vdW50IH07XG4gICAgICAgICAgICBpZiAob3V0cHV0LmJpcDMyRGVyaXZhdGlvbikge1xuICAgICAgICAgICAgICAgIG91dHB1dERhdGEuYmlwMzJEZXJpdmF0aW9uID0gb3V0cHV0LmJpcDMyRGVyaXZhdGlvbi5tYXAoKGRlcml2YXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc3RlckZpbmdlcnByaW50OiBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KGRlcml2YXRpb24ubWFzdGVyRmluZ2VycHJpbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KGRlcml2YXRpb24ucHVia2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGRlcml2YXRpb24ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBzYnQuYWRkT3V0cHV0KG91dHB1dERhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBzYnQ7XG59XG5leHBvcnRzLmNsYXNzaWNUb1BzYnQgPSBjbGFzc2ljVG9Qc2J0O1xuZnVuY3Rpb24gcHNidFNpZ24ocHNidEJhc2U2NCwgcHJpdmF0ZUtleSwgbmV0d29yaywgbWF4aW11bUZlZVJhdGUpIHtcbiAgICBjb25zdCBwc2J0ID0gcHNidF8xLlBzYnQuZnJvbUJhc2U2NChwc2J0QmFzZTY0LCB7XG4gICAgICAgIG5ldHdvcmssXG4gICAgICAgIG1heGltdW1GZWVSYXRlOiBtYXhpbXVtRmVlUmF0ZSA/IG1heGltdW1GZWVSYXRlIDogZGVmYXVsdE1heGltdW1GZWVSYXRlXG4gICAgfSk7XG4gICAgcHNidFNpZ25JbXBsKHBzYnQsIHByaXZhdGVLZXksIG5ldHdvcmspO1xuICAgIHJldHVybiBwc2J0LnRvQmFzZTY0KCk7XG59XG5leHBvcnRzLnBzYnRTaWduID0gcHNidFNpZ247XG5mdW5jdGlvbiBwc2J0RGVjb2RlKHBzYnRCYXNlNjQsIG5ldHdvcmssIG1heGltdW1GZWVSYXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHNidCA9IHBzYnRfMS5Qc2J0LmZyb21IZXgocHNidEJhc2U2NCwge1xuICAgICAgICAgICAgbmV0d29yayxcbiAgICAgICAgICAgIG1heGltdW1GZWVSYXRlOiBtYXhpbXVtRmVlUmF0ZSA/IG1heGltdW1GZWVSYXRlIDogZGVmYXVsdE1heGltdW1GZWVSYXRlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHNidC50eElucHV0cyA/IHBzYnQudHhJbnB1dHMuZmlsdGVyKGEgPT4gIWEuaGFzaC5lcXVhbHMoQnVmZmVyLmFsbG9jKDMyKSkpXG4gICAgICAgICAgICAubWFwKChhID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR4SWQ6IGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KGNyeXB0b19saWJfMS5iYXNlLnJldmVyc2VCdWZmZXIoYS5oYXNoKSksIHZPdXQ6IGEuaW5kZXggfTtcbiAgICAgICAgfSkpIDogW107XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IHBzYnQgPSBwc2J0XzEuUHNidC5mcm9tQmFzZTY0KHBzYnRCYXNlNjQsIHtcbiAgICAgICAgICAgIG5ldHdvcmssXG4gICAgICAgICAgICBtYXhpbXVtRmVlUmF0ZTogbWF4aW11bUZlZVJhdGUgPyBtYXhpbXVtRmVlUmF0ZSA6IGRlZmF1bHRNYXhpbXVtRmVlUmF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBzYnQudHhJbnB1dHMgPyBwc2J0LnR4SW5wdXRzLmZpbHRlcihhID0+ICFhLmhhc2guZXF1YWxzKEJ1ZmZlci5hbGxvYygzMikpKVxuICAgICAgICAgICAgLm1hcCgoYSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eElkOiBjcnlwdG9fbGliXzEuYmFzZS50b0hleChjcnlwdG9fbGliXzEuYmFzZS5yZXZlcnNlQnVmZmVyKGEuaGFzaCkpLCB2T3V0OiBhLmluZGV4IH07XG4gICAgICAgIH0pKSA6IFtdO1xuICAgIH1cbn1cbmV4cG9ydHMucHNidERlY29kZSA9IHBzYnREZWNvZGU7XG5mdW5jdGlvbiBzaWduUHNidFdpdGhLZXlQYXRoQW5kU2NyaXB0UGF0aEJhdGNoKHBzYnRIZXhzLCBwcml2YXRlS2V5LCBuZXR3b3JrLCBvcHRzKSB7XG4gICAgaWYgKHBzYnRIZXhzID09IHVuZGVmaW5lZCB8fCBwc2J0SGV4cy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCByZXMgPSBbXTtcbiAgICBjb25zdCBvcHRzU2l6ZSA9IG9wdHMgPT0gdW5kZWZpbmVkID8gMCA6IG9wdHMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHNidEhleHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG9wdCA9IHt9O1xuICAgICAgICBpZiAoaSA8IG9wdHNTaXplICYmIG9wdHMpIHtcbiAgICAgICAgICAgIG9wdCA9IG9wdHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmVkUHNidCA9IHNpZ25Qc2J0V2l0aEtleVBhdGhBbmRTY3JpcHRQYXRoKHBzYnRIZXhzW2ldLCBwcml2YXRlS2V5LCBuZXR3b3JrLCB7XG4gICAgICAgICAgICBhdXRvRmluYWxpemVkOiBvcHQuYXV0b0ZpbmFsaXplZCxcbiAgICAgICAgICAgIHRvU2lnbklucHV0czogb3B0LnRvU2lnbklucHV0c1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLnB1c2goc2lnbmVkUHNidCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLnNpZ25Qc2J0V2l0aEtleVBhdGhBbmRTY3JpcHRQYXRoQmF0Y2ggPSBzaWduUHNidFdpdGhLZXlQYXRoQW5kU2NyaXB0UGF0aEJhdGNoO1xuZnVuY3Rpb24gc2lnblBzYnRXaXRoS2V5UGF0aEFuZFNjcmlwdFBhdGgocHNidFN0ciwgcHJpdmF0ZUtleSwgbmV0d29yaywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgcHNidCA9IGdldFBzYnRGcm9tU3RyaW5nKHBzYnRTdHIsIG5ldHdvcmspO1xuICAgIHNpZ25Qc2J0V2l0aEtleVBhdGhBbmRTY3JpcHRQYXRoSW1wbChwc2J0LCBwcml2YXRlS2V5LCBuZXR3b3JrLCBvcHRzLmF1dG9GaW5hbGl6ZWQsIG9wdHMudG9TaWduSW5wdXRzKTtcbiAgICByZXR1cm4gcHNidC50b0hleCgpO1xufVxuZXhwb3J0cy5zaWduUHNidFdpdGhLZXlQYXRoQW5kU2NyaXB0UGF0aCA9IHNpZ25Qc2J0V2l0aEtleVBhdGhBbmRTY3JpcHRQYXRoO1xuZnVuY3Rpb24gc2lnblBzYnRXaXRoS2V5UGF0aEFuZFNjcmlwdFBhdGhJbXBsKHBzYnQsIHByaXZhdGVLZXksIG5ldHdvcmssIGF1dG9GaW5hbGl6ZWQsIHNpZ25JbnB1dHMpIHtcbiAgICBuZXR3b3JrID0gbmV0d29yayB8fCBiaXRjb2luanNfbGliXzEubmV0d29ya3MuYml0Y29pbjtcbiAgICBjb25zdCBwcml2S2V5SGV4ID0gKDAsIHR4QnVpbGRfMS5wcml2YXRlS2V5RnJvbVdJRikocHJpdmF0ZUtleSwgbmV0d29yayk7XG4gICAgY29uc3Qgc2lnbklucHV0TWFwID0gbmV3IE1hcCgpO1xuICAgIGlmIChzaWduSW5wdXRzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBzaWduSW5wdXRzLm1hcChlID0+IHtcbiAgICAgICAgICAgIHNpZ25JbnB1dE1hcC5zZXQoZS5pbmRleCwgZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXIgPSB7XG4gICAgICAgIHBzYnRJbmRleDogMCxcbiAgICAgICAgbmVlZFR3ZWFrOiB0cnVlLFxuICAgICAgICB0d2Vha0hhc2g6IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgdG9TaWduSW5wdXRzTWFwOiBzaWduSW5wdXRNYXAsXG4gICAgICAgIHB1YmxpY0tleTogQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBzaWduKGhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHhCdWlsZF8xLnNpZ24pKGhhc2gsIHByaXZLZXlIZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzaWduU2Nobm9ycihoYXNoKSB7XG4gICAgICAgICAgICBsZXQgdHdlYWtlZFByaXZLZXkgPSB0YXByb290LnRhcHJvb3RUd2Vha1ByaXZLZXkoY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChwcml2S2V5SGV4KSk7XG4gICAgICAgICAgICBpZiAodGhpcy50b1NpZ25JbnB1dHNNYXA/Lmhhcyh0aGlzLnBzYnRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b1NpZ25JbnB1dHNNYXAuZ2V0KHRoaXMucHNidEluZGV4KT8uZGlzYWJsZVR3ZWFrU2lnbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzY2hub3JyLnNpZ24oaGFzaCwgcHJpdktleUhleCwgY3J5cHRvX2xpYl8xLmJhc2UucmFuZG9tQnl0ZXMoMzIpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm5lZWRUd2Vhaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzY2hub3JyLnNpZ24oaGFzaCwgcHJpdktleUhleCwgY3J5cHRvX2xpYl8xLmJhc2UucmFuZG9tQnl0ZXMoMzIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkVHdlYWsgJiYgdGhpcy50d2Vha0hhc2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHR3ZWFrZWRQcml2S2V5ID0gdGFwcm9vdC50YXByb290VHdlYWtQcml2S2V5KGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgocHJpdktleUhleCksIHRoaXMudHdlYWtIYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzY2hub3JyLnNpZ24oaGFzaCwgdHdlYWtlZFByaXZLZXksIGNyeXB0b19saWJfMS5iYXNlLnJhbmRvbUJ5dGVzKDMyKSkpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgbGV0IGFsbG93ZWRTaWdoYXNoVHlwZXMgPSBbXG4gICAgICAgIGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSB8IGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSxcbiAgICAgICAgYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMLFxuICAgICAgICBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUXG4gICAgXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBzYnQuaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChzaWduSW5wdXRNYXA/LnNpemUgPiAwICYmICFzaWduSW5wdXRNYXA/LmhhcyhpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmVyLnBzYnRJbmRleCA9IGk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcHNidC5kYXRhLmlucHV0c1tpXTtcbiAgICAgICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0LnRhcEludGVybmFsS2V5KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQudGFwSW50ZXJuYWxLZXkgPSAoMCwgYmlwMzcxXzEudG9YT25seSkoKDAsIHR4QnVpbGRfMS53aWYyUHVibGljKShwcml2YXRlS2V5LCBuZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWduZXIubmVlZFR3ZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgIHNpZ25lci5wdWJsaWNLZXkgPSBCdWZmZXIuZnJvbSh0YXByb290LnRhcHJvb3RUd2Vha1B1YmtleSgoMCwgYmlwMzcxXzEudG9YT25seSkoKDAsIHR4QnVpbGRfMS53aWYyUHVibGljKShwcml2YXRlS2V5LCBuZXR3b3JrKSkpWzBdKTtcbiAgICAgICAgICAgIGlmIChzaWduSW5wdXRNYXA/LmhhcyhpKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaWduSW5wdXRNYXA/LmdldChpKT8uZGlzYWJsZVR3ZWFrU2lnbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lci5wdWJsaWNLZXkgPSAoMCwgdHhCdWlsZF8xLndpZjJQdWJsaWMpKHByaXZhdGVLZXksIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICBzaWduZXIubmVlZFR3ZWFrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0LnRhcExlYWZTY3JpcHQgJiYgaW5wdXQudGFwTGVhZlNjcmlwdD8ubGVuZ3RoID4gMCAmJiAhaW5wdXQudGFwTWVya2xlUm9vdCkge1xuICAgICAgICAgICAgICAgIGlucHV0LnRhcExlYWZTY3JpcHQubWFwKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jb250cm9sQmxvY2sgJiYgZS5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lci5wdWJsaWNLZXkgPSAoMCwgdHhCdWlsZF8xLndpZjJQdWJsaWMpKHByaXZhdGVLZXksIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVyLm5lZWRUd2VhayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dC50YXBNZXJrbGVSb290KSB7XG4gICAgICAgICAgICAgICAgc2lnbmVyLm5lZWRUd2VhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2lnbmVyLnR3ZWFrSGFzaCA9IGlucHV0LnRhcE1lcmtsZVJvb3Q7XG4gICAgICAgICAgICAgICAgc2lnbmVyLnB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHRhcHJvb3QudGFwcm9vdFR3ZWFrUHVia2V5KCgwLCBiaXAzNzFfMS50b1hPbmx5KSgoMCwgdHhCdWlsZF8xLndpZjJQdWJsaWMpKHByaXZhdGVLZXksIG5ldHdvcmspKSwgaW5wdXQudGFwTWVya2xlUm9vdClbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2lnbmVyLm5lZWRUd2VhayA9IGZhbHNlO1xuICAgICAgICAgICAgc2lnbmVyLnR3ZWFrSGFzaCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgICAgIHNpZ25lci5wdWJsaWNLZXkgPSAoMCwgdHhCdWlsZF8xLndpZjJQdWJsaWMpKHByaXZhdGVLZXksIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2lnbklucHV0TWFwPy5oYXMoaSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWdoYXNoVHlwZXMgPSBzaWduSW5wdXRNYXA/LmdldChpKT8uc2lnaGFzaFR5cGVzO1xuICAgICAgICAgICAgICAgIGlmIChzaWdoYXNoVHlwZXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRTaWdoYXNoVHlwZXMgPSBzaWdoYXNoVHlwZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHNidC5zaWduSW5wdXQoaSwgc2lnbmVyLCBhbGxvd2VkU2lnaGFzaFR5cGVzKTtcbiAgICAgICAgICAgIGlmIChhdXRvRmluYWxpemVkICE9IHVuZGVmaW5lZCAmJiAhYXV0b0ZpbmFsaXplZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHNidC5maW5hbGl6ZUlucHV0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoc2lnbklucHV0TWFwPy5zaXplID4gMCAmJiBzaWduSW5wdXRNYXA/LmhhcyhpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnNpZ25Qc2J0V2l0aEtleVBhdGhBbmRTY3JpcHRQYXRoSW1wbCA9IHNpZ25Qc2J0V2l0aEtleVBhdGhBbmRTY3JpcHRQYXRoSW1wbDtcbmZ1bmN0aW9uIHBzYnRTaWduSW1wbChwc2J0LCBwcml2YXRlS2V5LCBuZXR3b3JrKSB7XG4gICAgbmV0d29yayA9IG5ldHdvcmsgfHwgYml0Y29pbmpzX2xpYl8xLm5ldHdvcmtzLmJpdGNvaW47XG4gICAgY29uc3QgcHJpdktleUhleCA9ICgwLCB0eEJ1aWxkXzEucHJpdmF0ZUtleUZyb21XSUYpKHByaXZhdGVLZXksIG5ldHdvcmspO1xuICAgIGNvbnN0IHNpZ25lciA9IHtcbiAgICAgICAgcHVibGljS2V5OiBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIHNpZ24oaGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB0eEJ1aWxkXzEuc2lnbikoaGFzaCwgcHJpdktleUhleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25TY2hub3JyKGhhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHR3ZWFrZWRQcml2S2V5ID0gdGFwcm9vdC50YXByb290VHdlYWtQcml2S2V5KGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgocHJpdktleUhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNjaG5vcnIuc2lnbihoYXNoLCB0d2Vha2VkUHJpdktleSwgY3J5cHRvX2xpYl8xLmJhc2UucmFuZG9tQnl0ZXMoMzIpKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCBhbGxvd2VkU2lnaGFzaFR5cGVzID0gW1xuICAgICAgICBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgfCBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVksXG4gICAgICAgIGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCB8IGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSxcbiAgICAgICAgYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMLFxuICAgICAgICBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUXG4gICAgXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBzYnQuaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKHBzYnQuZGF0YS5pbnB1dHNbaV0pKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHBzYnQuZGF0YS5pbnB1dHNbaV07XG4gICAgICAgICAgICBpZiAoIWlucHV0LnRhcEludGVybmFsS2V5KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQudGFwSW50ZXJuYWxLZXkgPSAoMCwgYmlwMzcxXzEudG9YT25seSkoKDAsIHR4QnVpbGRfMS53aWYyUHVibGljKShwcml2YXRlS2V5LCBuZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWduZXIucHVibGljS2V5ID0gQnVmZmVyLmZyb20odGFwcm9vdC50YXByb290VHdlYWtQdWJrZXkoKDAsIGJpcDM3MV8xLnRvWE9ubHkpKCgwLCB0eEJ1aWxkXzEud2lmMlB1YmxpYykocHJpdmF0ZUtleSwgbmV0d29yaykpKVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaWduZXIucHVibGljS2V5ID0gKDAsIHR4QnVpbGRfMS53aWYyUHVibGljKShwcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHNidC5zaWduSW5wdXQoaSwgc2lnbmVyLCBhbGxvd2VkU2lnaGFzaFR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5wc2J0U2lnbkltcGwgPSBwc2J0U2lnbkltcGw7XG5mdW5jdGlvbiBleHRyYWN0UHNidFRyYW5zYWN0aW9uKHR4SGV4LCBuZXR3b3JrLCBtYXhpbXVtRmVlUmF0ZSkge1xuICAgIGNvbnN0IHBzYnQgPSBwc2J0XzEuUHNidC5mcm9tSGV4KHR4SGV4LCB7XG4gICAgICAgIG5ldHdvcmssXG4gICAgICAgIG1heGltdW1GZWVSYXRlOiBtYXhpbXVtRmVlUmF0ZSA/IG1heGltdW1GZWVSYXRlIDogZGVmYXVsdE1heGltdW1GZWVSYXRlXG4gICAgfSk7XG4gICAgbGV0IGV4dHJhY3RlZFRyYW5zYWN0aW9uO1xuICAgIHRyeSB7XG4gICAgICAgIGV4dHJhY3RlZFRyYW5zYWN0aW9uID0gcHNidC5maW5hbGl6ZUFsbElucHV0cygpLmV4dHJhY3RUcmFuc2FjdGlvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBleHRyYWN0ZWRUcmFuc2FjdGlvbiA9IHBzYnQuZXh0cmFjdFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdGVkVHJhbnNhY3Rpb24udG9IZXgoKTtcbn1cbmV4cG9ydHMuZXh0cmFjdFBzYnRUcmFuc2FjdGlvbiA9IGV4dHJhY3RQc2J0VHJhbnNhY3Rpb247XG5mdW5jdGlvbiBnZW5lcmF0ZVVuc2lnbmVkTGlzdGluZ1BzYnQobGlzdGluZ0RhdGEsIG5ldHdvcmssIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNjcmlwdCA9IGJpdGNvaW5qc19saWJfMS5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KGxpc3RpbmdEYXRhLm5mdEFkZHJlc3MsIG5ldHdvcmspO1xuICAgIGlmICgoKDAsIHBzYnR1dGlsc18xLmlzUDJTSFNjcmlwdCkoc2NyaXB0KSB8fCAoMCwgcHNidHV0aWxzXzEuaXNQMlRSKShzY3JpcHQpKSAmJiAhcHVibGljS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcHVibGljS2V5XCIpO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgfTtcbiAgICBsZXQgcGxhY2Vob2xkZXJBZGRyZXNzID0gXCJiYzFwY3lqNW10MnE0dDRweThqbnVyOHZweHZ4eGNoa2U0cHp5N3Rkcjl5dmozdTNrZGZncmo2c3czcnptclwiO1xuICAgIGlmIChuZXR3b3JrID09PSBiaXRjb2luanNfbGliXzEubmV0d29ya3MudGVzdG5ldCkge1xuICAgICAgICBwbGFjZWhvbGRlckFkZHJlc3MgPSBcInRiMXBjeWo1bXQycTR0NHB5OGpudXI4dnB4dnh4Y2hrZTRwenk3dGRyOXl2ajN1M2tkZmdyajZzZWU0ZHB2XCI7XG4gICAgfVxuICAgIHR4LmlucHV0cy5wdXNoKHtcbiAgICAgICAgdHhJZDogXCIwXCIucmVwZWF0KDY0KSxcbiAgICAgICAgdk91dDogMCxcbiAgICAgICAgYW1vdW50OiAwLFxuICAgICAgICBhZGRyZXNzOiBwbGFjZWhvbGRlckFkZHJlc3MsXG4gICAgfSwge1xuICAgICAgICB0eElkOiBcIjBcIi5yZXBlYXQoNjQpLFxuICAgICAgICB2T3V0OiAxLFxuICAgICAgICBhbW91bnQ6IDAsXG4gICAgICAgIGFkZHJlc3M6IHBsYWNlaG9sZGVyQWRkcmVzcyxcbiAgICB9KTtcbiAgICB0eC5vdXRwdXRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzOiBwbGFjZWhvbGRlckFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogMCxcbiAgICB9LCB7XG4gICAgICAgIGFkZHJlc3M6IHBsYWNlaG9sZGVyQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiAwLFxuICAgIH0pO1xuICAgIHR4LmlucHV0cy5wdXNoKHtcbiAgICAgICAgdHhJZDogbGlzdGluZ0RhdGEubmZ0VXR4by50eEhhc2gsXG4gICAgICAgIHZPdXQ6IGxpc3RpbmdEYXRhLm5mdFV0eG8udm91dCxcbiAgICAgICAgYWRkcmVzczogbGlzdGluZ0RhdGEubmZ0QWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBsaXN0aW5nRGF0YS5uZnRVdHhvLmNvaW5BbW91bnQsXG4gICAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgICAgICBub25XaXRuZXNzVXR4bzogbGlzdGluZ0RhdGEubmZ0VXR4by5yYXdUcmFuc2F0aW9uLFxuICAgICAgICBzaWdoYXNoVHlwZTogYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFIHwgYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZLFxuICAgIH0pO1xuICAgIHR4Lm91dHB1dHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3M6IGxpc3RpbmdEYXRhLnJlY2VpdmVCdGNBZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IGxpc3RpbmdEYXRhLnByaWNlLFxuICAgIH0pO1xuICAgIGNvbnN0IHBzYnRIZXggPSBidWlsZFBzYnQodHgsIG5ldHdvcmspO1xuICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS50b0Jhc2U2NChjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHBzYnRIZXgpKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVVbnNpZ25lZExpc3RpbmdQc2J0ID0gZ2VuZXJhdGVVbnNpZ25lZExpc3RpbmdQc2J0O1xuZnVuY3Rpb24gZ2VuZXJhdGVTaWduZWRMaXN0aW5nUHNidChsaXN0aW5nRGF0YSwgcHJpdmF0ZUtleSwgbmV0d29yaykge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KCgwLCB0eEJ1aWxkXzEud2lmMlB1YmxpYykocHJpdmF0ZUtleSwgbmV0d29yaykpO1xuICAgIHJldHVybiBwc2J0U2lnbihnZW5lcmF0ZVVuc2lnbmVkTGlzdGluZ1BzYnQobGlzdGluZ0RhdGEsIG5ldHdvcmssIHB1YmxpY0tleSksIHByaXZhdGVLZXksIG5ldHdvcmspO1xufVxuZXhwb3J0cy5nZW5lcmF0ZVNpZ25lZExpc3RpbmdQc2J0ID0gZ2VuZXJhdGVTaWduZWRMaXN0aW5nUHNidDtcbmNvbnN0IFNFTExFUl9JTkRFWCA9IDI7XG5jb25zdCBEVU1NWV9BTU9VTlQgPSA2MDA7XG5jb25zdCBEVVNUX09VVFBVVF9MSU1JVCA9IDU0NjtcbmZ1bmN0aW9uIGdlbmVyYXRlVW5zaWduZWRCdXlpbmdQc2J0KGJ1eWluZ0RhdGEsIG5ldHdvcmssIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgYWRkcmVzczogYnV5aW5nRGF0YS5wYXltZW50QW5kQ2hhbmdlQWRkcmVzcyxcbiAgICAgICAgZmVlUGVyQjogYnV5aW5nRGF0YS5mZWVSYXRlLFxuICAgIH07XG4gICAgYnV5aW5nRGF0YS5kdW1teVV0eG9zLmZvckVhY2goZHVtbXlVdHhvID0+IHtcbiAgICAgICAgdHguaW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgdHhJZDogZHVtbXlVdHhvLnR4SGFzaCxcbiAgICAgICAgICAgIHZPdXQ6IGR1bW15VXR4by52b3V0LFxuICAgICAgICAgICAgYWRkcmVzczogYnV5aW5nRGF0YS5wYXltZW50QW5kQ2hhbmdlQWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudDogZHVtbXlVdHhvLmNvaW5BbW91bnQsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSxcbiAgICAgICAgICAgIG5vbldpdG5lc3NVdHhvOiBkdW1teVV0eG8ucmF3VHJhbnNhdGlvbixcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdHgub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzczogYnV5aW5nRGF0YS5wYXltZW50QW5kQ2hhbmdlQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBidXlpbmdEYXRhLmR1bW15VXR4b3MucmVkdWNlKChzdW0sIGR1bW15VXR4bykgPT4gc3VtICsgZHVtbXlVdHhvLmNvaW5BbW91bnQsIDApLFxuICAgIH0pO1xuICAgIGNvbnN0IG5mdE91dHB1dHMgPSBbXTtcbiAgICBidXlpbmdEYXRhLnNlbGxlclBzYnRzLmZvckVhY2goc2VsbGVyUHNidCA9PiB7XG4gICAgICAgIGNvbnN0IHBzYnQgPSBwc2J0XzEuUHNidC5mcm9tQmFzZTY0KHNlbGxlclBzYnQsIHsgbmV0d29yayB9KTtcbiAgICAgICAgY29uc3QgbmZ0SW5wdXQgPSBwc2J0LmRhdGEuZ2xvYmFsTWFwLnVuc2lnbmVkVHgudHguaW5zW1NFTExFUl9JTkRFWF07XG4gICAgICAgIG5mdE91dHB1dHMucHVzaChwc2J0LmRhdGEuZ2xvYmFsTWFwLnVuc2lnbmVkVHgudHgub3V0c1tTRUxMRVJfSU5ERVhdKTtcbiAgICAgICAgbGV0IG5mdFV0eG8gPSBwc2J0LmRhdGEuaW5wdXRzW1NFTExFUl9JTkRFWF0ud2l0bmVzc1V0eG87XG4gICAgICAgIGlmICghbmZ0VXR4bykge1xuICAgICAgICAgICAgbmZ0VXR4byA9IGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5mcm9tQnVmZmVyKHBzYnQuZGF0YS5pbnB1dHNbU0VMTEVSX0lOREVYXS5ub25XaXRuZXNzVXR4bykub3V0c1tuZnRJbnB1dC5pbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdHguaW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgdHhJZDogY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgoKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikobmZ0SW5wdXQuaGFzaCkpLFxuICAgICAgICAgICAgdk91dDogbmZ0SW5wdXQuaW5kZXgsXG4gICAgICAgICAgICBhZGRyZXNzOiBiaXRjb2luanNfbGliXzEuYWRkcmVzcy5mcm9tT3V0cHV0U2NyaXB0KG5mdFV0eG8uc2NyaXB0LCBuZXR3b3JrKSxcbiAgICAgICAgICAgIGFtb3VudDogbmZ0VXR4by52YWx1ZSxcbiAgICAgICAgICAgIHNpZ2hhc2hUeXBlOiBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgfCBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVksXG4gICAgICAgIH0pO1xuICAgICAgICB0eC5vdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgYWRkcmVzczogYnV5aW5nRGF0YS5yZWNlaXZlTmZ0QWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudDogbmZ0VXR4by52YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgbmZ0T3V0cHV0cy5mb3JFYWNoKG5mdE91dHB1dCA9PiB7XG4gICAgICAgIHR4Lm91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBiaXRjb2luanNfbGliXzEuYWRkcmVzcy5mcm9tT3V0cHV0U2NyaXB0KG5mdE91dHB1dC5zY3JpcHQsIG5ldHdvcmspLFxuICAgICAgICAgICAgYW1vdW50OiBuZnRPdXRwdXQudmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGJ1eWluZ0RhdGEucGF5bWVudFV0eG9zLmZvckVhY2gocGF5bWVudFV0eG8gPT4ge1xuICAgICAgICB0eC5pbnB1dHMucHVzaCh7XG4gICAgICAgICAgICB0eElkOiBwYXltZW50VXR4by50eEhhc2gsXG4gICAgICAgICAgICB2T3V0OiBwYXltZW50VXR4by52b3V0LFxuICAgICAgICAgICAgYWRkcmVzczogYnV5aW5nRGF0YS5wYXltZW50QW5kQ2hhbmdlQWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudDogcGF5bWVudFV0eG8uY29pbkFtb3VudCxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgICAgICAgICAgbm9uV2l0bmVzc1V0eG86IHBheW1lbnRVdHhvLnJhd1RyYW5zYXRpb24sXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGJ1eWluZ0RhdGEuZHVtbXlVdHhvcy5mb3JFYWNoKCgpID0+IHtcbiAgICAgICAgdHgub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGJ1eWluZ0RhdGEucGF5bWVudEFuZENoYW5nZUFkZHJlc3MsXG4gICAgICAgICAgICBhbW91bnQ6IERVTU1ZX0FNT1VOVCxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlQW1vdW50ID0gcGFyc2VJbnQoKDAsIHR4QnVpbGRfMS5zaWduQnRjKSh0eCwgXCJcIiwgbmV0d29yaywgdW5kZWZpbmVkLCBmYWxzZSwgdHJ1ZSkpO1xuICAgIGlmIChjaGFuZ2VBbW91bnQgPj0gRFVTVF9PVVRQVVRfTElNSVQpIHtcbiAgICAgICAgdHgub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGJ1eWluZ0RhdGEucGF5bWVudEFuZENoYW5nZUFkZHJlc3MsXG4gICAgICAgICAgICBhbW91bnQ6IGNoYW5nZUFtb3VudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS50b0Jhc2U2NChjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KGJ1aWxkUHNidCh0eCwgbmV0d29yaykpKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVVbnNpZ25lZEJ1eWluZ1BzYnQgPSBnZW5lcmF0ZVVuc2lnbmVkQnV5aW5nUHNidDtcbmZ1bmN0aW9uIG1lcmdlU2lnbmVkQnV5aW5nUHNidChzaWduZWRCdXlpbmdQc2J0LCBzaWduZWRMaXN0aW5nUHNidHMpIHtcbiAgICBjb25zdCBidXllclNpZ25lZFBzYnQgPSBwc2J0XzEuUHNidC5mcm9tQmFzZTY0KHNpZ25lZEJ1eWluZ1BzYnQpO1xuICAgIGNvbnN0IG5mdEluZGV4ID0gc2lnbmVkTGlzdGluZ1BzYnRzLmxlbmd0aCArIDE7XG4gICAgc2lnbmVkTGlzdGluZ1BzYnRzLmZvckVhY2goKHNpZ25lZExpc3RpbmdQc2J0LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGxlclNpZ25lZFBzYnQgPSBwc2J0XzEuUHNidC5mcm9tQmFzZTY0KHNpZ25lZExpc3RpbmdQc2J0KTtcbiAgICAgICAgYnV5ZXJTaWduZWRQc2J0LmRhdGEuZ2xvYmFsTWFwLnVuc2lnbmVkVHgudHguaW5zW25mdEluZGV4ICsgaV1cbiAgICAgICAgICAgID0gc2VsbGVyU2lnbmVkUHNidC5kYXRhLmdsb2JhbE1hcC51bnNpZ25lZFR4LnR4Lmluc1tTRUxMRVJfSU5ERVhdO1xuICAgICAgICBidXllclNpZ25lZFBzYnQuZGF0YS5pbnB1dHNbbmZ0SW5kZXggKyBpXVxuICAgICAgICAgICAgPSBzZWxsZXJTaWduZWRQc2J0LmRhdGEuaW5wdXRzW1NFTExFUl9JTkRFWF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1eWVyU2lnbmVkUHNidDtcbn1cbmV4cG9ydHMubWVyZ2VTaWduZWRCdXlpbmdQc2J0ID0gbWVyZ2VTaWduZWRCdXlpbmdQc2J0O1xuZnVuY3Rpb24gZ2VuZXJhdGVTaWduZWRCdXlpbmdUeChidXlpbmdEYXRhLCBwcml2YXRlS2V5LCBuZXR3b3JrKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgoKDAsIHR4QnVpbGRfMS53aWYyUHVibGljKShwcml2YXRlS2V5LCBuZXR3b3JrKSk7XG4gICAgY29uc3Qgc2lnbmVkQnV5aW5nUHNidCA9IHBzYnRTaWduKGdlbmVyYXRlVW5zaWduZWRCdXlpbmdQc2J0KGJ1eWluZ0RhdGEsIG5ldHdvcmssIHB1YmxpY0tleSksIHByaXZhdGVLZXksIG5ldHdvcmspO1xuICAgIHJldHVybiBleHRyYWN0UHNidFRyYW5zYWN0aW9uKG1lcmdlU2lnbmVkQnV5aW5nUHNidChzaWduZWRCdXlpbmdQc2J0LCBidXlpbmdEYXRhLnNlbGxlclBzYnRzKS50b0hleCgpLCBuZXR3b3JrKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVTaWduZWRCdXlpbmdUeCA9IGdlbmVyYXRlU2lnbmVkQnV5aW5nVHg7XG5mdW5jdGlvbiBnZW5lcmF0ZU1QQ1Vuc2lnbmVkTGlzdGluZ1BTQlQocHNidEJhc2U2NCwgcHViS2V5SGV4LCBuZXR3b3JrKSB7XG4gICAgY29uc3QgcHNidCA9IHBzYnRfMS5Qc2J0LmZyb21CYXNlNjQocHNidEJhc2U2NCwgeyBuZXR3b3JrIH0pO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgocHViS2V5SGV4KTtcbiAgICBjb25zdCBzaWdoYXNoVHlwZXMgPSBbYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFIHwgYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZXTtcbiAgICBsZXQgc2lnbkhhc2hMaXN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwc2J0LmlucHV0Q291bnQ7IGkrKykge1xuICAgICAgICBpZiAoaSAhPSBTRUxMRVJfSU5ERVgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgc2lnaGFzaFR5cGUgfSA9IHBzYnQuZ2V0SGFzaEFuZFNpZ2hhc2hUeXBlKGksIHB1YmxpY0tleSwgc2lnaGFzaFR5cGVzKTtcbiAgICAgICAgc2lnbkhhc2hMaXN0LnB1c2goY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgoaGFzaCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwc2J0QmFzZTY0OiBwc2J0QmFzZTY0LFxuICAgICAgICBzaWduSGFzaExpc3Q6IHNpZ25IYXNoTGlzdCxcbiAgICB9O1xufVxuZXhwb3J0cy5nZW5lcmF0ZU1QQ1Vuc2lnbmVkTGlzdGluZ1BTQlQgPSBnZW5lcmF0ZU1QQ1Vuc2lnbmVkTGlzdGluZ1BTQlQ7XG5mdW5jdGlvbiBnZW5lcmF0ZU1QQ1NpZ25lZExpc3RpbmdQU0JUKHBzYnRCYXNlNjQsIHB1YktleUhleCwgc2lnbmF0dXJlLCBuZXR3b3JrKSB7XG4gICAgY29uc3QgcHNidCA9IHBzYnRfMS5Qc2J0LmZyb21CYXNlNjQocHNidEJhc2U2NCwgeyBuZXR3b3JrIH0pO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgocHViS2V5SGV4KTtcbiAgICBjb25zdCBwYXJ0aWFsU2lnID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBwdWJrZXk6IHB1YmxpY0tleSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogYnNjcmlwdC5zaWduYXR1cmUuZW5jb2RlKGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoc2lnbmF0dXJlKSwgYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFIHwgYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSxcbiAgICAgICAgfSxcbiAgICBdO1xuICAgIHBzYnQuZGF0YS51cGRhdGVJbnB1dChTRUxMRVJfSU5ERVgsIHsgcGFydGlhbFNpZyB9KTtcbiAgICByZXR1cm4gcHNidC50b0Jhc2U2NCgpO1xufVxuZXhwb3J0cy5nZW5lcmF0ZU1QQ1NpZ25lZExpc3RpbmdQU0JUID0gZ2VuZXJhdGVNUENTaWduZWRMaXN0aW5nUFNCVDtcbmZ1bmN0aW9uIGdlbmVyYXRlTVBDVW5zaWduZWRCdXlpbmdQU0JUKHBzYnRCYXNlNjQsIHB1YktleUhleCwgbmV0d29yaywgYmF0Y2hTaXplID0gMSkge1xuICAgIGNvbnN0IHBzYnQgPSBwc2J0XzEuUHNidC5mcm9tQmFzZTY0KHBzYnRCYXNlNjQsIHsgbmV0d29yayB9KTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHB1YktleUhleCk7XG4gICAgY29uc3Qgc2lnaGFzaFR5cGVzID0gW2JpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF07XG4gICAgbGV0IHNpZ25IYXNoTGlzdCA9IFtdO1xuICAgIGNvbnN0IHNlbGxlckluZGV4ID0gYmF0Y2hTaXplICsgMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBzYnQuaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChpID49IHNlbGxlckluZGV4ICYmIGkgPCBzZWxsZXJJbmRleCArIGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSB9ID0gcHNidC5nZXRIYXNoQW5kU2lnaGFzaFR5cGUoaSwgcHVibGljS2V5LCBzaWdoYXNoVHlwZXMpO1xuICAgICAgICBzaWduSGFzaExpc3QucHVzaChjcnlwdG9fbGliXzEuYmFzZS50b0hleChoYXNoKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBzYnRCYXNlNjQ6IHBzYnRCYXNlNjQsXG4gICAgICAgIHNpZ25IYXNoTGlzdDogc2lnbkhhc2hMaXN0LFxuICAgIH07XG59XG5leHBvcnRzLmdlbmVyYXRlTVBDVW5zaWduZWRCdXlpbmdQU0JUID0gZ2VuZXJhdGVNUENVbnNpZ25lZEJ1eWluZ1BTQlQ7XG5mdW5jdGlvbiBnZW5lcmF0ZU1QQ1NpZ25lZEJ1eWluZ1R4KHBzYnRCYXNlNjQsIHB1YktleUhleCwgc2lnbmF0dXJlTGlzdCwgbmV0d29yaywgYmF0Y2hTaXplID0gMSkge1xuICAgIGNvbnN0IHBzYnQgPSBwc2J0XzEuUHNidC5mcm9tQmFzZTY0KHBzYnRCYXNlNjQsIHsgbmV0d29yayB9KTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHB1YktleUhleCk7XG4gICAgY29uc3Qgc2VsbGVySW5kZXggPSBiYXRjaFNpemUgKyAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHNidC5pbnB1dENvdW50OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPj0gc2VsbGVySW5kZXggJiYgaSA8IHNlbGxlckluZGV4ICsgYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0aWFsU2lnID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHB1YmtleTogcHVibGljS2V5LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYnNjcmlwdC5zaWduYXR1cmUuZW5jb2RlKGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoc2lnbmF0dXJlTGlzdFtpXSksIGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICBwc2J0LmRhdGEudXBkYXRlSW5wdXQoaSwgeyBwYXJ0aWFsU2lnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdFBzYnRUcmFuc2FjdGlvbihwc2J0LnRvSGV4KCksIG5ldHdvcmspO1xufVxuZXhwb3J0cy5nZW5lcmF0ZU1QQ1NpZ25lZEJ1eWluZ1R4ID0gZ2VuZXJhdGVNUENTaWduZWRCdXlpbmdUeDtcbmZ1bmN0aW9uIGdlbmVyYXRlTVBDVW5zaWduZWRQU0JUKHBzYnRTdHIsIHB1YktleUhleCwgbmV0d29yaykge1xuICAgIGNvbnN0IHBzYnQgPSBnZXRQc2J0RnJvbVN0cmluZyhwc2J0U3RyLCBuZXR3b3JrKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHB1YktleUhleCk7XG4gICAgY29uc3QgYWxsb3dlZFNpZ2hhc2hUeXBlcyA9IFtcbiAgICAgICAgYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFIHwgYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZLFxuICAgICAgICBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgfCBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVksXG4gICAgICAgIGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCB8IGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSxcbiAgICAgICAgYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMLFxuICAgICAgICBiaXRjb2luanNfbGliXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUXG4gICAgXTtcbiAgICA7XG4gICAgbGV0IHNpZ25IYXNoTGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHNidC5pbnB1dENvdW50OyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFzaCwgc2lnaGFzaFR5cGUgfSA9IHBzYnQuZ2V0SGFzaEFuZFNpZ2hhc2hUeXBlKGksIHB1YmxpY0tleSwgYWxsb3dlZFNpZ2hhc2hUeXBlcyk7XG4gICAgICAgICAgICBzaWduSGFzaExpc3QucHVzaChjcnlwdG9fbGliXzEuYmFzZS50b0hleChoYXNoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBnZXRSYW5kb21IYXNoKCk7XG4gICAgICAgICAgICBzaWduSGFzaExpc3QucHVzaChzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtID0gbmV3IE1hcCgpO1xuICAgIHNpZ25IYXNoTGlzdC5tYXAoKGUsIGkpID0+IHtcbiAgICAgICAgbGV0IGNvdW50ID0gbS5nZXQoZSk7XG4gICAgICAgIGNvdW50ID0gY291bnQgPT0gdW5kZWZpbmVkID8gMCA6IGNvdW50O1xuICAgICAgICBpZiAoY291bnQgIT0gdW5kZWZpbmVkICYmIGNvdW50ID49IDEpIHtcbiAgICAgICAgICAgIHNpZ25IYXNoTGlzdFtpXSA9IGdldFJhbmRvbUhhc2goKTtcbiAgICAgICAgfVxuICAgICAgICBtLnNldChlLCBjb3VudCArIDEpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBzYnRTdHI6IHBzYnRTdHIsXG4gICAgICAgIHNpZ25IYXNoTGlzdDogc2lnbkhhc2hMaXN0LFxuICAgIH07XG59XG5leHBvcnRzLmdlbmVyYXRlTVBDVW5zaWduZWRQU0JUID0gZ2VuZXJhdGVNUENVbnNpZ25lZFBTQlQ7XG5mdW5jdGlvbiBnZXRSYW5kb21IYXNoKCkge1xuICAgIGNvbnN0IGggPSAoMCwgY3J5cHRvXzEuc2hhMjU2KSgoMCwgY3J5cHRvXzIucmFuZG9tQnl0ZXMpKDMyKSk7XG4gICAgY29uc3QgcyA9IGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KGguc2xpY2UoMCwgMjgpKTtcbiAgICByZXR1cm4gXCJmZmZmZmZmZlwiICsgcztcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlTVBDU2lnbmVkUFNCVChwc2J0U3RyLCBwdWJLZXlIZXgsIHNpZ25hdHVyZUxpc3QsIG5ldHdvcmspIHtcbiAgICBjb25zdCBwc2J0ID0gZ2V0UHNidEZyb21TdHJpbmcocHNidFN0ciwgbmV0d29yayk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChwdWJLZXlIZXgpO1xuICAgIGxldCBzaWdoYXNoVHlwZSA9IGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTDtcbiAgICBjb25zdCByZXMgPSBnZW5lcmF0ZU1QQ1Vuc2lnbmVkUFNCVChwc2J0U3RyLCBwdWJLZXlIZXgsIG5ldHdvcmspO1xuICAgIGNvbnN0IHNpZ25IYXNoTGlzdCA9IHJlcy5zaWduSGFzaExpc3Q7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwc2J0LmlucHV0Q291bnQ7IGkrKykge1xuICAgICAgICBpZiAoc2lnbkhhc2hMaXN0W2ldLnNsaWNlKDAsIDgpID09IFwiZmZmZmZmZmZcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBzYnQuZGF0YS5pbnB1dHNbaV0uc2lnaGFzaFR5cGUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaWdoYXNoVHlwZSA9IHBzYnQuZGF0YS5pbnB1dHNbaV0uc2lnaGFzaFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydGlhbFNpZyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwdWJrZXk6IHB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGJzY3JpcHQuc2lnbmF0dXJlLmVuY29kZShjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHNpZ25hdHVyZUxpc3RbaV0pLCBzaWdoYXNoVHlwZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHNidC5kYXRhLnVwZGF0ZUlucHV0KGksIHsgcGFydGlhbFNpZyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwc2J0LnRvSGV4KCk7XG59XG5leHBvcnRzLmdlbmVyYXRlTVBDU2lnbmVkUFNCVCA9IGdlbmVyYXRlTVBDU2lnbmVkUFNCVDtcbmZ1bmN0aW9uIGdldFBzYnRGcm9tU3RyaW5nKHBzYnRTdHIsIG5ldHdvcmspIHtcbiAgICBsZXQgcHNidDtcbiAgICBpZiAoY3J5cHRvX2xpYl8xLmJhc2UuaXNIZXhTdHJpbmcoXCIweFwiICsgcHNidFN0cikpIHtcbiAgICAgICAgcHNidCA9IHBzYnRfMS5Qc2J0LmZyb21IZXgocHNidFN0ciwgeyBuZXR3b3JrIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHNidCA9IHBzYnRfMS5Qc2J0LmZyb21CYXNlNjQocHNidFN0ciwgeyBuZXR3b3JrIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHNidDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBzYnRTaWduLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/psbtSign.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/rune.js':
    /*!*********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/rune.js ***!
  \*********************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.buildRuneMainMintOp = exports.buildRuneMainMintData = exports.buildRuneData = exports.encodeToVecV2 = exports.toVarIntV2 = exports.fromVarInt = exports.encodeToVec = exports.toVarInt = void 0;\nconst bscript = __importStar(__webpack_require__(/*! ./bitcoinjs-lib/script */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js"));\nconst ops_1 = __webpack_require__(/*! ./bitcoinjs-lib/ops */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/ops.js");\nconst wallet_1 = __webpack_require__(/*! ./wallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/index.js");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst TAG_BODY = BigInt(0);\nconst TAG_Flags = BigInt(2);\nconst TAG_Rune = BigInt(4);\nconst TAG_Premine = BigInt(6);\nconst TAG_Cap = BigInt(8);\nconst TAG_Amount = BigInt(10);\nconst TAG_HeightStart = BigInt(12);\nconst TAG_HeightEnd = BigInt(14);\nconst TAG_OffsetStart = BigInt(16);\nconst TAG_OffsetEnd = BigInt(118);\nconst TAG_Mint = BigInt(20);\nconst TAG_Pointer = BigInt(22);\nconst TAG_Cenotaph = BigInt(126);\nconst TAG_Divisibility = BigInt(1);\nconst TAG_Spacers = BigInt(3);\nconst TAG_Symbol = BigInt(5);\nconst TAG_Nop = BigInt(127);\nfunction encode(n) {\n    let payload = [];\n    encodeToVec(n, payload);\n    return new Uint8Array(payload);\n}\nexports.toVarInt = encode;\nfunction encodeToVec(n, payload) {\n    let i = 18;\n    const out = new Array(19).fill(0);\n    out[i] = Number(n & BigInt(0x7F));\n    while (n > BigInt(0x7F)) {\n        n = n / BigInt(128) - BigInt(1);\n        i--;\n        out[i] = Number(n & BigInt(0xFF)) | 0x80;\n    }\n    payload.push(...out.slice(i));\n}\nexports.encodeToVec = encodeToVec;\nfunction encodeV2(n) {\n    let payload = [];\n    encodeToVecV2(n, payload);\n    return new Uint8Array(payload);\n}\nexports.toVarIntV2 = encodeV2;\nfunction encodeToVecV2(n, payload) {\n    while (n >> 7n > 0n) {\n        payload.push(Number((n & 0x7fn) | 0x80n));\n        n >>= 7n;\n    }\n    payload.push(Number(n & 0x7fn));\n    return payload;\n}\nexports.encodeToVecV2 = encodeToVecV2;\nfunction decode(buffer) {\n    let n = BigInt(0);\n    let i = 0;\n    while (true) {\n        const b = BigInt(buffer[i]);\n        if (b < BigInt(128)) {\n            return [n + b, i + 1];\n        }\n        n += b - BigInt(127);\n        n = n * BigInt(128);\n        i++;\n        if (i >= buffer.length) {\n            throw new Error("Varint decoding error: buffer overflow");\n        }\n    }\n}\nexports.fromVarInt = decode;\nfunction buildRuneData(isMainnet, edicts) {\n    let payload = [];\n    for (let edict of edicts) {\n        if (typeof edict.amount === "string") {\n            edict.amount = BigInt(edict.amount);\n        }\n    }\n    if (edicts.length > 0) {\n        encodeToVec(TAG_BODY, payload);\n        edicts.sort((a, b) => a.id - b.id);\n        let id = 0;\n        for (const edict of edicts) {\n            encodeToVec(BigInt(edict.id - id), payload);\n            encodeToVec(BigInt(edict.amount), payload);\n            encodeToVec(BigInt(edict.output), payload);\n            id = edict.id;\n        }\n    }\n    let prefix;\n    if (isMainnet) {\n        prefix = \'R\';\n    }\n    else {\n        prefix = \'RUNE_TEST\';\n    }\n    const opReturnScript = bscript.compile([ops_1.OPS.OP_RETURN, Buffer.from(prefix), Buffer.from(payload)]);\n    return opReturnScript;\n}\nexports.buildRuneData = buildRuneData;\nfunction buildRuneMainMintData(isMainnet, edicts, useDefaultOutput, defaultOutput, mint, mintNum) {\n    let payload = [];\n    for (let edict of edicts) {\n        if (typeof edict.amount === "string") {\n            edict.amount = BigInt(edict.amount);\n        }\n    }\n    if ((mint != undefined) && mint && edicts[0].block != undefined) {\n        encodeToVecV2(TAG_Mint, payload);\n        encodeToVecV2(BigInt(edicts[0].block), payload);\n        encodeToVecV2(TAG_Mint, payload);\n        encodeToVecV2(BigInt(edicts[0].id), payload);\n    }\n    if (useDefaultOutput) {\n        encodeToVecV2(TAG_Pointer, payload);\n        encodeToVecV2(BigInt(defaultOutput), payload);\n    }\n    if (edicts.length > 0) {\n        encodeToVecV2(TAG_BODY, payload);\n        edicts.sort((a, b) => {\n            if (a.block === b.block) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return a.block - b.block;\n        });\n        let id = 0;\n        let block = 0;\n        for (const edict of edicts) {\n            encodeToVecV2(BigInt(edict.block - block), payload);\n            encodeToVecV2(BigInt(edict.id - id), payload);\n            encodeToVecV2(BigInt(edict.amount), payload);\n            encodeToVecV2(BigInt(edict.output), payload);\n            id = edict.id;\n            block = edict.block;\n        }\n    }\n    if (payload.length > 80) {\n        throw new Error(JSON.stringify({\n            errCode: wallet_1.ErrCodeOpreturnExceeds,\n            date: {\n                payloadLenth: payload.length\n            }\n        }));\n    }\n    const opReturnScript = bscript.compile([ops_1.OPS.OP_RETURN, ops_1.OPS.OP_13, Buffer.from(payload)]);\n    return opReturnScript;\n}\nexports.buildRuneMainMintData = buildRuneMainMintData;\nfunction buildRuneMainMintOp(id, useDefaultOutput, defaultOutput, mint) {\n    let payload = [];\n    let block = parseInt(id.split(":")[0]);\n    let txindex = parseInt(id.split(":")[1]);\n    if ((mint != undefined) && mint && txindex != undefined) {\n        encodeToVecV2(TAG_Mint, payload);\n        encodeToVecV2(BigInt(block), payload);\n        encodeToVecV2(TAG_Mint, payload);\n        encodeToVecV2(BigInt(txindex), payload);\n    }\n    if (useDefaultOutput) {\n        encodeToVecV2(TAG_Pointer, payload);\n        encodeToVecV2(BigInt(defaultOutput), payload);\n    }\n    if (payload.length > 80) {\n        throw new Error(JSON.stringify({\n            errCode: wallet_1.ErrCodeOpreturnExceeds,\n            date: {\n                payloadLenth: payload.length\n            }\n        }));\n    }\n    const opReturnScript = bscript.compile([ops_1.OPS.OP_RETURN, ops_1.OPS.OP_13, Buffer.from(payload)]);\n    return { address: \'\', amount: 0, omniScript: crypto_lib_1.base.toHex(opReturnScript) };\n}\nexports.buildRuneMainMintOp = buildRuneMainMintOp;\n//# sourceMappingURL=rune.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvcnVuZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsZ0JBQWdCO0FBQzlMLDZCQUE2QixtQkFBTyxDQUFDLHVHQUF3QjtBQUM3RCxjQUFjLG1CQUFPLENBQUMsaUdBQXFCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLGlGQUFVO0FBQ25DLHFCQUFxQixtQkFBTyxDQUFDLG1GQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9ydW5lLmpzP2Q5YjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGRSdW5lTWFpbk1pbnRPcCA9IGV4cG9ydHMuYnVpbGRSdW5lTWFpbk1pbnREYXRhID0gZXhwb3J0cy5idWlsZFJ1bmVEYXRhID0gZXhwb3J0cy5lbmNvZGVUb1ZlY1YyID0gZXhwb3J0cy50b1ZhckludFYyID0gZXhwb3J0cy5mcm9tVmFySW50ID0gZXhwb3J0cy5lbmNvZGVUb1ZlYyA9IGV4cG9ydHMudG9WYXJJbnQgPSB2b2lkIDA7XG5jb25zdCBic2NyaXB0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWIvc2NyaXB0XCIpKTtcbmNvbnN0IG9wc18xID0gcmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYi9vcHNcIik7XG5jb25zdCB3YWxsZXRfMSA9IHJlcXVpcmUoXCIuL3dhbGxldFwiKTtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuY29uc3QgVEFHX0JPRFkgPSBCaWdJbnQoMCk7XG5jb25zdCBUQUdfRmxhZ3MgPSBCaWdJbnQoMik7XG5jb25zdCBUQUdfUnVuZSA9IEJpZ0ludCg0KTtcbmNvbnN0IFRBR19QcmVtaW5lID0gQmlnSW50KDYpO1xuY29uc3QgVEFHX0NhcCA9IEJpZ0ludCg4KTtcbmNvbnN0IFRBR19BbW91bnQgPSBCaWdJbnQoMTApO1xuY29uc3QgVEFHX0hlaWdodFN0YXJ0ID0gQmlnSW50KDEyKTtcbmNvbnN0IFRBR19IZWlnaHRFbmQgPSBCaWdJbnQoMTQpO1xuY29uc3QgVEFHX09mZnNldFN0YXJ0ID0gQmlnSW50KDE2KTtcbmNvbnN0IFRBR19PZmZzZXRFbmQgPSBCaWdJbnQoMTE4KTtcbmNvbnN0IFRBR19NaW50ID0gQmlnSW50KDIwKTtcbmNvbnN0IFRBR19Qb2ludGVyID0gQmlnSW50KDIyKTtcbmNvbnN0IFRBR19DZW5vdGFwaCA9IEJpZ0ludCgxMjYpO1xuY29uc3QgVEFHX0RpdmlzaWJpbGl0eSA9IEJpZ0ludCgxKTtcbmNvbnN0IFRBR19TcGFjZXJzID0gQmlnSW50KDMpO1xuY29uc3QgVEFHX1N5bWJvbCA9IEJpZ0ludCg1KTtcbmNvbnN0IFRBR19Ob3AgPSBCaWdJbnQoMTI3KTtcbmZ1bmN0aW9uIGVuY29kZShuKSB7XG4gICAgbGV0IHBheWxvYWQgPSBbXTtcbiAgICBlbmNvZGVUb1ZlYyhuLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGF5bG9hZCk7XG59XG5leHBvcnRzLnRvVmFySW50ID0gZW5jb2RlO1xuZnVuY3Rpb24gZW5jb2RlVG9WZWMobiwgcGF5bG9hZCkge1xuICAgIGxldCBpID0gMTg7XG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KDE5KS5maWxsKDApO1xuICAgIG91dFtpXSA9IE51bWJlcihuICYgQmlnSW50KDB4N0YpKTtcbiAgICB3aGlsZSAobiA+IEJpZ0ludCgweDdGKSkge1xuICAgICAgICBuID0gbiAvIEJpZ0ludCgxMjgpIC0gQmlnSW50KDEpO1xuICAgICAgICBpLS07XG4gICAgICAgIG91dFtpXSA9IE51bWJlcihuICYgQmlnSW50KDB4RkYpKSB8IDB4ODA7XG4gICAgfVxuICAgIHBheWxvYWQucHVzaCguLi5vdXQuc2xpY2UoaSkpO1xufVxuZXhwb3J0cy5lbmNvZGVUb1ZlYyA9IGVuY29kZVRvVmVjO1xuZnVuY3Rpb24gZW5jb2RlVjIobikge1xuICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgZW5jb2RlVG9WZWNWMihuLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGF5bG9hZCk7XG59XG5leHBvcnRzLnRvVmFySW50VjIgPSBlbmNvZGVWMjtcbmZ1bmN0aW9uIGVuY29kZVRvVmVjVjIobiwgcGF5bG9hZCkge1xuICAgIHdoaWxlIChuID4+IDduID4gMG4pIHtcbiAgICAgICAgcGF5bG9hZC5wdXNoKE51bWJlcigobiAmIDB4N2ZuKSB8IDB4ODBuKSk7XG4gICAgICAgIG4gPj49IDduO1xuICAgIH1cbiAgICBwYXlsb2FkLnB1c2goTnVtYmVyKG4gJiAweDdmbikpO1xuICAgIHJldHVybiBwYXlsb2FkO1xufVxuZXhwb3J0cy5lbmNvZGVUb1ZlY1YyID0gZW5jb2RlVG9WZWNWMjtcbmZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcbiAgICBsZXQgbiA9IEJpZ0ludCgwKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgYiA9IEJpZ0ludChidWZmZXJbaV0pO1xuICAgICAgICBpZiAoYiA8IEJpZ0ludCgxMjgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW24gKyBiLCBpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgbiArPSBiIC0gQmlnSW50KDEyNyk7XG4gICAgICAgIG4gPSBuICogQmlnSW50KDEyOCk7XG4gICAgICAgIGkrKztcbiAgICAgICAgaWYgKGkgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFyaW50IGRlY29kaW5nIGVycm9yOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZyb21WYXJJbnQgPSBkZWNvZGU7XG5mdW5jdGlvbiBidWlsZFJ1bmVEYXRhKGlzTWFpbm5ldCwgZWRpY3RzKSB7XG4gICAgbGV0IHBheWxvYWQgPSBbXTtcbiAgICBmb3IgKGxldCBlZGljdCBvZiBlZGljdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlZGljdC5hbW91bnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGVkaWN0LmFtb3VudCA9IEJpZ0ludChlZGljdC5hbW91bnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlZGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlbmNvZGVUb1ZlYyhUQUdfQk9EWSwgcGF5bG9hZCk7XG4gICAgICAgIGVkaWN0cy5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG4gICAgICAgIGxldCBpZCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZWRpY3Qgb2YgZWRpY3RzKSB7XG4gICAgICAgICAgICBlbmNvZGVUb1ZlYyhCaWdJbnQoZWRpY3QuaWQgLSBpZCksIHBheWxvYWQpO1xuICAgICAgICAgICAgZW5jb2RlVG9WZWMoQmlnSW50KGVkaWN0LmFtb3VudCksIHBheWxvYWQpO1xuICAgICAgICAgICAgZW5jb2RlVG9WZWMoQmlnSW50KGVkaWN0Lm91dHB1dCksIHBheWxvYWQpO1xuICAgICAgICAgICAgaWQgPSBlZGljdC5pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJlZml4O1xuICAgIGlmIChpc01haW5uZXQpIHtcbiAgICAgICAgcHJlZml4ID0gJ1InO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJlZml4ID0gJ1JVTkVfVEVTVCc7XG4gICAgfVxuICAgIGNvbnN0IG9wUmV0dXJuU2NyaXB0ID0gYnNjcmlwdC5jb21waWxlKFtvcHNfMS5PUFMuT1BfUkVUVVJOLCBCdWZmZXIuZnJvbShwcmVmaXgpLCBCdWZmZXIuZnJvbShwYXlsb2FkKV0pO1xuICAgIHJldHVybiBvcFJldHVyblNjcmlwdDtcbn1cbmV4cG9ydHMuYnVpbGRSdW5lRGF0YSA9IGJ1aWxkUnVuZURhdGE7XG5mdW5jdGlvbiBidWlsZFJ1bmVNYWluTWludERhdGEoaXNNYWlubmV0LCBlZGljdHMsIHVzZURlZmF1bHRPdXRwdXQsIGRlZmF1bHRPdXRwdXQsIG1pbnQsIG1pbnROdW0pIHtcbiAgICBsZXQgcGF5bG9hZCA9IFtdO1xuICAgIGZvciAobGV0IGVkaWN0IG9mIGVkaWN0cykge1xuICAgICAgICBpZiAodHlwZW9mIGVkaWN0LmFtb3VudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZWRpY3QuYW1vdW50ID0gQmlnSW50KGVkaWN0LmFtb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChtaW50ICE9IHVuZGVmaW5lZCkgJiYgbWludCAmJiBlZGljdHNbMF0uYmxvY2sgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuY29kZVRvVmVjVjIoVEFHX01pbnQsIHBheWxvYWQpO1xuICAgICAgICBlbmNvZGVUb1ZlY1YyKEJpZ0ludChlZGljdHNbMF0uYmxvY2spLCBwYXlsb2FkKTtcbiAgICAgICAgZW5jb2RlVG9WZWNWMihUQUdfTWludCwgcGF5bG9hZCk7XG4gICAgICAgIGVuY29kZVRvVmVjVjIoQmlnSW50KGVkaWN0c1swXS5pZCksIHBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAodXNlRGVmYXVsdE91dHB1dCkge1xuICAgICAgICBlbmNvZGVUb1ZlY1YyKFRBR19Qb2ludGVyLCBwYXlsb2FkKTtcbiAgICAgICAgZW5jb2RlVG9WZWNWMihCaWdJbnQoZGVmYXVsdE91dHB1dCksIHBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoZWRpY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZW5jb2RlVG9WZWNWMihUQUdfQk9EWSwgcGF5bG9hZCk7XG4gICAgICAgIGVkaWN0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYS5ibG9jayA9PT0gYi5ibG9jaykge1xuICAgICAgICAgICAgICAgIGlmIChhLmlkIDwgYi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhLmlkID4gYi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYS5ibG9jayAtIGIuYmxvY2s7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaWQgPSAwO1xuICAgICAgICBsZXQgYmxvY2sgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGVkaWN0IG9mIGVkaWN0cykge1xuICAgICAgICAgICAgZW5jb2RlVG9WZWNWMihCaWdJbnQoZWRpY3QuYmxvY2sgLSBibG9jayksIHBheWxvYWQpO1xuICAgICAgICAgICAgZW5jb2RlVG9WZWNWMihCaWdJbnQoZWRpY3QuaWQgLSBpZCksIHBheWxvYWQpO1xuICAgICAgICAgICAgZW5jb2RlVG9WZWNWMihCaWdJbnQoZWRpY3QuYW1vdW50KSwgcGF5bG9hZCk7XG4gICAgICAgICAgICBlbmNvZGVUb1ZlY1YyKEJpZ0ludChlZGljdC5vdXRwdXQpLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGlkID0gZWRpY3QuaWQ7XG4gICAgICAgICAgICBibG9jayA9IGVkaWN0LmJsb2NrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXlsb2FkLmxlbmd0aCA+IDgwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBlcnJDb2RlOiB3YWxsZXRfMS5FcnJDb2RlT3ByZXR1cm5FeGNlZWRzLFxuICAgICAgICAgICAgZGF0ZToge1xuICAgICAgICAgICAgICAgIHBheWxvYWRMZW50aDogcGF5bG9hZC5sZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCBvcFJldHVyblNjcmlwdCA9IGJzY3JpcHQuY29tcGlsZShbb3BzXzEuT1BTLk9QX1JFVFVSTiwgb3BzXzEuT1BTLk9QXzEzLCBCdWZmZXIuZnJvbShwYXlsb2FkKV0pO1xuICAgIHJldHVybiBvcFJldHVyblNjcmlwdDtcbn1cbmV4cG9ydHMuYnVpbGRSdW5lTWFpbk1pbnREYXRhID0gYnVpbGRSdW5lTWFpbk1pbnREYXRhO1xuZnVuY3Rpb24gYnVpbGRSdW5lTWFpbk1pbnRPcChpZCwgdXNlRGVmYXVsdE91dHB1dCwgZGVmYXVsdE91dHB1dCwgbWludCkge1xuICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgbGV0IGJsb2NrID0gcGFyc2VJbnQoaWQuc3BsaXQoXCI6XCIpWzBdKTtcbiAgICBsZXQgdHhpbmRleCA9IHBhcnNlSW50KGlkLnNwbGl0KFwiOlwiKVsxXSk7XG4gICAgaWYgKChtaW50ICE9IHVuZGVmaW5lZCkgJiYgbWludCAmJiB0eGluZGV4ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmNvZGVUb1ZlY1YyKFRBR19NaW50LCBwYXlsb2FkKTtcbiAgICAgICAgZW5jb2RlVG9WZWNWMihCaWdJbnQoYmxvY2spLCBwYXlsb2FkKTtcbiAgICAgICAgZW5jb2RlVG9WZWNWMihUQUdfTWludCwgcGF5bG9hZCk7XG4gICAgICAgIGVuY29kZVRvVmVjVjIoQmlnSW50KHR4aW5kZXgpLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKHVzZURlZmF1bHRPdXRwdXQpIHtcbiAgICAgICAgZW5jb2RlVG9WZWNWMihUQUdfUG9pbnRlciwgcGF5bG9hZCk7XG4gICAgICAgIGVuY29kZVRvVmVjVjIoQmlnSW50KGRlZmF1bHRPdXRwdXQpLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKHBheWxvYWQubGVuZ3RoID4gODApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGVyckNvZGU6IHdhbGxldF8xLkVyckNvZGVPcHJldHVybkV4Y2VlZHMsXG4gICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZExlbnRoOiBwYXlsb2FkLmxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IG9wUmV0dXJuU2NyaXB0ID0gYnNjcmlwdC5jb21waWxlKFtvcHNfMS5PUFMuT1BfUkVUVVJOLCBvcHNfMS5PUFMuT1BfMTMsIEJ1ZmZlci5mcm9tKHBheWxvYWQpXSk7XG4gICAgcmV0dXJuIHsgYWRkcmVzczogJycsIGFtb3VudDogMCwgb21uaVNjcmlwdDogY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgob3BSZXR1cm5TY3JpcHQpIH07XG59XG5leHBvcnRzLmJ1aWxkUnVuZU1haW5NaW50T3AgPSBidWlsZFJ1bmVNYWluTWludE9wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVuZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/rune.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/sigcost.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/sigcost.js ***!
  \************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.countAdjustedVsize = exports.convertScriptSigAsm = exports.countScriptSigops = void 0;\nconst ops_1 = __webpack_require__(/*! ./bitcoinjs-lib/ops */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/ops.js\");\nconst txBuild_1 = __webpack_require__(/*! ./txBuild */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js\");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nconst bitcoin = __importStar(__webpack_require__(/*! ./bitcoinjs-lib */ \"(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js\"));\nfunction countScriptSigops(script, isRawScript = false, witness = false) {\n    if (!script?.length) {\n        return 0;\n    }\n    let sigops = 0;\n    sigops += (script.match(/OP_CHECKSIG/g)?.length || 0);\n    if (isRawScript) {\n        sigops += 20 * (script.match(/OP_CHECKMULTISIG/g)?.length || 0);\n    }\n    else {\n        const matches = script.matchAll(/(?:OP_(?:PUSHNUM_)?(\\d+))? OP_CHECKMULTISIG/g);\n        for (const match of matches) {\n            const n = parseInt(match[1]);\n            if (Number.isInteger(n)) {\n                sigops += n;\n            }\n            else {\n                sigops += 20;\n            }\n        }\n    }\n    return witness ? sigops : (sigops * 4);\n}\nexports.countScriptSigops = countScriptSigops;\nfunction convertScriptSigAsm(buf) {\n    if (buf?.length == 0) {\n        return \"\";\n    }\n    const b = [];\n    let i = 0;\n    while (i < buf.length) {\n        const op = buf[i];\n        if (op >= 0x01 && op <= 0x4e) {\n            i++;\n            let push;\n            if (op === 0x4c) {\n                push = buf.readUInt8(i);\n                b.push('OP_PUSHDATA1');\n                i += 1;\n            }\n            else if (op === 0x4d) {\n                push = buf.readUInt16LE(i);\n                b.push('OP_PUSHDATA2');\n                i += 2;\n            }\n            else if (op === 0x4e) {\n                push = buf.readUInt32LE(i);\n                b.push('OP_PUSHDATA4');\n                i += 4;\n            }\n            else {\n                push = op;\n                b.push('OP_PUSHBYTES_' + push);\n            }\n            const data = buf.slice(i, i + push);\n            if (data.length !== push) {\n                break;\n            }\n            b.push(data.toString('hex'));\n            i += data.length;\n        }\n        else {\n            if (op === 0x00) {\n                b.push('OP_0');\n            }\n            else if (op === 0x4f) {\n                b.push('OP_PUSHNUM_NEG1');\n            }\n            else if (op === 0xb1) {\n                b.push('OP_CLTV');\n            }\n            else if (op === 0xb2) {\n                b.push('OP_CSV');\n            }\n            else if (op === 0xba) {\n                b.push('OP_CHECKSIGADD');\n            }\n            else {\n                const opcode = ops_1.REVERSE_OPS[op];\n                if (opcode && op < 0xfd) {\n                    if (/^OP_(\\d+)$/.test(opcode)) {\n                        b.push(opcode.replace(/^OP_(\\d+)$/, 'OP_PUSHNUM_$1'));\n                    }\n                    else {\n                        b.push(opcode);\n                    }\n                }\n                else {\n                    b.push('OP_RETURN_' + op);\n                }\n            }\n            i += 1;\n        }\n    }\n    return b.join(' ');\n}\nexports.convertScriptSigAsm = convertScriptSigAsm;\nfunction countAdjustedVsize(transaction, addresses, net) {\n    if (transaction == undefined || null) {\n        return 0;\n    }\n    if (net == undefined || null) {\n        net = bitcoin.networks.bitcoin;\n    }\n    let sigops = 0;\n    if ((addresses != undefined || null) && (addresses.length == transaction.ins.length)) {\n        transaction.ins.forEach((input, index) => {\n            if (input.script != undefined || null) {\n                sigops += countScriptSigops(convertScriptSigAsm(input.script), true);\n            }\n            if (addresses.length <= index || (addresses[index] == undefined || null) || addresses[index] == '') {\n                return;\n            }\n            const addressType = (0, txBuild_1.getAddressType)(addresses[index], net);\n            switch (true) {\n                case addressType === 'segwit_nested' && input.witness?.length === 2 && input.script && crypto_lib_1.base.toHex(input.script).startsWith('160014'):\n                case addressType === 'segwit_native':\n                    sigops += 1;\n                    break;\n                case addressType === 'segwit_nested' && input.witness?.length && input.script && crypto_lib_1.base.toHex(input.script).startsWith('220020'):\n                case addressType === 'segwit_native':\n                    if (input.witness?.length) {\n                        sigops += countScriptSigops(convertScriptSigAsm(input.witness[input.witness.length - 1]), false, true);\n                    }\n                    break;\n                case addressType === 'segwit_nested':\n                    if (input.script) {\n                        sigops += countScriptSigops(convertScriptSigAsm(input.script));\n                    }\n                    break;\n            }\n        });\n    }\n    for (const output of transaction.outs) {\n        if (output) {\n            sigops += countScriptSigops(convertScriptSigAsm(output.script), true);\n        }\n    }\n    const vsize = transaction.virtualSize();\n    if (vsize > sigops * 5) {\n        return vsize;\n    }\n    return sigops * 5;\n}\nexports.countAdjustedVsize = countAdjustedVsize;\n//# sourceMappingURL=sigcost.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvc2lnY29zdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcseUJBQXlCO0FBQ3BGLGNBQWMsbUJBQU8sQ0FBQyxpR0FBcUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsNkVBQVc7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xELDZCQUE2QixtQkFBTyxDQUFDLCtGQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC9zaWdjb3N0LmpzPzJkMzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY291bnRBZGp1c3RlZFZzaXplID0gZXhwb3J0cy5jb252ZXJ0U2NyaXB0U2lnQXNtID0gZXhwb3J0cy5jb3VudFNjcmlwdFNpZ29wcyA9IHZvaWQgMDtcbmNvbnN0IG9wc18xID0gcmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYi9vcHNcIik7XG5jb25zdCB0eEJ1aWxkXzEgPSByZXF1aXJlKFwiLi90eEJ1aWxkXCIpO1xuY29uc3QgY3J5cHRvX2xpYl8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NyeXB0by1saWJcIik7XG5jb25zdCBiaXRjb2luID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWJcIikpO1xuZnVuY3Rpb24gY291bnRTY3JpcHRTaWdvcHMoc2NyaXB0LCBpc1Jhd1NjcmlwdCA9IGZhbHNlLCB3aXRuZXNzID0gZmFsc2UpIHtcbiAgICBpZiAoIXNjcmlwdD8ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgc2lnb3BzID0gMDtcbiAgICBzaWdvcHMgKz0gKHNjcmlwdC5tYXRjaCgvT1BfQ0hFQ0tTSUcvZyk/Lmxlbmd0aCB8fCAwKTtcbiAgICBpZiAoaXNSYXdTY3JpcHQpIHtcbiAgICAgICAgc2lnb3BzICs9IDIwICogKHNjcmlwdC5tYXRjaCgvT1BfQ0hFQ0tNVUxUSVNJRy9nKT8ubGVuZ3RoIHx8IDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNjcmlwdC5tYXRjaEFsbCgvKD86T1BfKD86UFVTSE5VTV8pPyhcXGQrKSk/IE9QX0NIRUNLTVVMVElTSUcvZyk7XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgICAgICAgICAgc2lnb3BzICs9IG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWdvcHMgKz0gMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdpdG5lc3MgPyBzaWdvcHMgOiAoc2lnb3BzICogNCk7XG59XG5leHBvcnRzLmNvdW50U2NyaXB0U2lnb3BzID0gY291bnRTY3JpcHRTaWdvcHM7XG5mdW5jdGlvbiBjb252ZXJ0U2NyaXB0U2lnQXNtKGJ1Zikge1xuICAgIGlmIChidWY/Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBiID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYnVmLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBvcCA9IGJ1ZltpXTtcbiAgICAgICAgaWYgKG9wID49IDB4MDEgJiYgb3AgPD0gMHg0ZSkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgbGV0IHB1c2g7XG4gICAgICAgICAgICBpZiAob3AgPT09IDB4NGMpIHtcbiAgICAgICAgICAgICAgICBwdXNoID0gYnVmLnJlYWRVSW50OChpKTtcbiAgICAgICAgICAgICAgICBiLnB1c2goJ09QX1BVU0hEQVRBMScpO1xuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wID09PSAweDRkKSB7XG4gICAgICAgICAgICAgICAgcHVzaCA9IGJ1Zi5yZWFkVUludDE2TEUoaSk7XG4gICAgICAgICAgICAgICAgYi5wdXNoKCdPUF9QVVNIREFUQTInKTtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcCA9PT0gMHg0ZSkge1xuICAgICAgICAgICAgICAgIHB1c2ggPSBidWYucmVhZFVJbnQzMkxFKGkpO1xuICAgICAgICAgICAgICAgIGIucHVzaCgnT1BfUFVTSERBVEE0Jyk7XG4gICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVzaCA9IG9wO1xuICAgICAgICAgICAgICAgIGIucHVzaCgnT1BfUFVTSEJZVEVTXycgKyBwdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBidWYuc2xpY2UoaSwgaSArIHB1c2gpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBwdXNoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLnB1c2goZGF0YS50b1N0cmluZygnaGV4JykpO1xuICAgICAgICAgICAgaSArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIGIucHVzaCgnT1BfMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3AgPT09IDB4NGYpIHtcbiAgICAgICAgICAgICAgICBiLnB1c2goJ09QX1BVU0hOVU1fTkVHMScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3AgPT09IDB4YjEpIHtcbiAgICAgICAgICAgICAgICBiLnB1c2goJ09QX0NMVFYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wID09PSAweGIyKSB7XG4gICAgICAgICAgICAgICAgYi5wdXNoKCdPUF9DU1YnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wID09PSAweGJhKSB7XG4gICAgICAgICAgICAgICAgYi5wdXNoKCdPUF9DSEVDS1NJR0FERCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3Bjb2RlID0gb3BzXzEuUkVWRVJTRV9PUFNbb3BdO1xuICAgICAgICAgICAgICAgIGlmIChvcGNvZGUgJiYgb3AgPCAweGZkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvXk9QXyhcXGQrKSQvLnRlc3Qob3Bjb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKG9wY29kZS5yZXBsYWNlKC9eT1BfKFxcZCspJC8sICdPUF9QVVNITlVNXyQxJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKG9wY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGIucHVzaCgnT1BfUkVUVVJOXycgKyBvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiLmpvaW4oJyAnKTtcbn1cbmV4cG9ydHMuY29udmVydFNjcmlwdFNpZ0FzbSA9IGNvbnZlcnRTY3JpcHRTaWdBc207XG5mdW5jdGlvbiBjb3VudEFkanVzdGVkVnNpemUodHJhbnNhY3Rpb24sIGFkZHJlc3NlcywgbmV0KSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uID09IHVuZGVmaW5lZCB8fCBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobmV0ID09IHVuZGVmaW5lZCB8fCBudWxsKSB7XG4gICAgICAgIG5ldCA9IGJpdGNvaW4ubmV0d29ya3MuYml0Y29pbjtcbiAgICB9XG4gICAgbGV0IHNpZ29wcyA9IDA7XG4gICAgaWYgKChhZGRyZXNzZXMgIT0gdW5kZWZpbmVkIHx8IG51bGwpICYmIChhZGRyZXNzZXMubGVuZ3RoID09IHRyYW5zYWN0aW9uLmlucy5sZW5ndGgpKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmlucy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zY3JpcHQgIT0gdW5kZWZpbmVkIHx8IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzaWdvcHMgKz0gY291bnRTY3JpcHRTaWdvcHMoY29udmVydFNjcmlwdFNpZ0FzbShpbnB1dC5zY3JpcHQpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRyZXNzZXMubGVuZ3RoIDw9IGluZGV4IHx8IChhZGRyZXNzZXNbaW5kZXhdID09IHVuZGVmaW5lZCB8fCBudWxsKSB8fCBhZGRyZXNzZXNbaW5kZXhdID09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkcmVzc1R5cGUgPSAoMCwgdHhCdWlsZF8xLmdldEFkZHJlc3NUeXBlKShhZGRyZXNzZXNbaW5kZXhdLCBuZXQpO1xuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBhZGRyZXNzVHlwZSA9PT0gJ3NlZ3dpdF9uZXN0ZWQnICYmIGlucHV0LndpdG5lc3M/Lmxlbmd0aCA9PT0gMiAmJiBpbnB1dC5zY3JpcHQgJiYgY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgoaW5wdXQuc2NyaXB0KS5zdGFydHNXaXRoKCcxNjAwMTQnKTpcbiAgICAgICAgICAgICAgICBjYXNlIGFkZHJlc3NUeXBlID09PSAnc2Vnd2l0X25hdGl2ZSc6XG4gICAgICAgICAgICAgICAgICAgIHNpZ29wcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGFkZHJlc3NUeXBlID09PSAnc2Vnd2l0X25lc3RlZCcgJiYgaW5wdXQud2l0bmVzcz8ubGVuZ3RoICYmIGlucHV0LnNjcmlwdCAmJiBjcnlwdG9fbGliXzEuYmFzZS50b0hleChpbnB1dC5zY3JpcHQpLnN0YXJ0c1dpdGgoJzIyMDAyMCcpOlxuICAgICAgICAgICAgICAgIGNhc2UgYWRkcmVzc1R5cGUgPT09ICdzZWd3aXRfbmF0aXZlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LndpdG5lc3M/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnb3BzICs9IGNvdW50U2NyaXB0U2lnb3BzKGNvbnZlcnRTY3JpcHRTaWdBc20oaW5wdXQud2l0bmVzc1tpbnB1dC53aXRuZXNzLmxlbmd0aCAtIDFdKSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYWRkcmVzc1R5cGUgPT09ICdzZWd3aXRfbmVzdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnb3BzICs9IGNvdW50U2NyaXB0U2lnb3BzKGNvbnZlcnRTY3JpcHRTaWdBc20oaW5wdXQuc2NyaXB0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiB0cmFuc2FjdGlvbi5vdXRzKSB7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgIHNpZ29wcyArPSBjb3VudFNjcmlwdFNpZ29wcyhjb252ZXJ0U2NyaXB0U2lnQXNtKG91dHB1dC5zY3JpcHQpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2c2l6ZSA9IHRyYW5zYWN0aW9uLnZpcnR1YWxTaXplKCk7XG4gICAgaWYgKHZzaXplID4gc2lnb3BzICogNSkge1xuICAgICAgICByZXR1cm4gdnNpemU7XG4gICAgfVxuICAgIHJldHVybiBzaWdvcHMgKiA1O1xufVxuZXhwb3J0cy5jb3VudEFkanVzdGVkVnNpemUgPSBjb3VudEFkanVzdGVkVnNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWdjb3N0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/sigcost.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/src20.js':
    /*!**********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/src20.js ***!
  \**********************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.srcInscribe = exports.SrcInscriptionTool = void 0;\nconst bitcoin = __importStar(__webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js"));\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst taproot = __importStar(__webpack_require__(/*! ./taproot */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/taproot.js"));\nconst bcrypto = __importStar(__webpack_require__(/*! ./bitcoinjs-lib/crypto */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js"));\nconst txBuild_1 = __webpack_require__(/*! ./txBuild */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js");\nconst bitcoinjs_lib_1 = __webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js");\nconst sigcost_1 = __webpack_require__(/*! ./sigcost */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/sigcost.js");\nconst schnorr = crypto_lib_1.signUtil.schnorr.secp256k1.schnorr;\nconst defaultTxVersion = 2;\nconst PART_LEN = 31;\nconst defaultSequenceNum = 0xfffffffd;\nconst defaultRevealOutValue = 7800;\nconst defaultMinChangeValue = 7800;\nconst maxStandardTxWeight = 4000000 / 10;\nclass SrcInscriptionTool {\n    constructor() {\n        this.network = bitcoin.networks.bitcoin;\n        this.revealTxs = [];\n        this.commitTx = new bitcoin.Transaction();\n        this.commitTxPrevOutputFetcher = [];\n        this.revealTxPrevOutputFetcher = [];\n        this.mustCommitTxFee = 0;\n        this.mustRevealTxFees = [];\n        this.commitAddrs = [];\n    }\n    static newSrcInscriptionTool(network, request) {\n        const tool = new SrcInscriptionTool();\n        tool.network = network;\n        const revealOutValue = request.revealOutValue || defaultRevealOutValue;\n        const minChangeValue = request.minChangeValue || defaultMinChangeValue;\n        const insufficient = tool.buildCommitTx(network, request.inscriptionData, revealOutValue, request.commitTxPrevOutputList, request.changeAddress, request.commitFeeRate, minChangeValue);\n        if (insufficient) {\n            return tool;\n        }\n        tool.signCommitTx(request.commitTxPrevOutputList);\n        return tool;\n    }\n    buildCommitTx(network, inscriptionData, revealOutValue, commitTxPrevOutputList, changeAddress, commitFeeRate, minChangeValue) {\n        let prefix = Buffer.from(inscriptionData.contentType);\n        let body = Buffer.from(inscriptionData.body);\n        while (body[body.length - 1] == 0) {\n            body = body.slice(0, body.length - 1);\n        }\n        let l = 2 + prefix.length + body.length;\n        let total = l % 62 == 0 ? l : (l + 62 - l % 62);\n        let bufferWriter = bitcoinjs_lib_1.BufferWriter.withCapacity(total);\n        bufferWriter.writeSlice(Buffer.from([(prefix.length + body.length) / 256, (prefix.length + body.length) % 256]));\n        bufferWriter.writeSlice(prefix);\n        bufferWriter.writeSlice(body);\n        if (total > l) {\n            bufferWriter.writeSlice(Buffer.alloc(total - l));\n        }\n        let data = bufferWriter.end();\n        let buf = crypto_lib_1.base.fromHex(xcp_rc4(commitTxPrevOutputList[0].txId, data.toString("hex")));\n        let totalSenderAmount = 0;\n        let totalRevealPrevOutputValue = 0;\n        const tx = new bitcoin.Transaction();\n        tx.version = defaultTxVersion;\n        totalRevealPrevOutputValue += revealOutValue;\n        tx.addOutput(bitcoin.address.toOutputScript(inscriptionData.revealAddr, network), revealOutValue);\n        while (buf.length) {\n            let buf1 = buf.slice(0, Math.min(PART_LEN, buf.length));\n            let first = buf1.toString("hex");\n            if (first.length < 62) {\n                first = first + \'0\'.repeat(62 - first.length);\n            }\n            buf = buf.slice(buf1.length);\n            let buf2 = buf.slice(0, Math.min(PART_LEN, buf.length));\n            let second = buf2.toString("hex");\n            if (second.length < 62) {\n                second = second + \'0\'.repeat(62 - second.length);\n            }\n            buf = buf.slice(buf1.length);\n            const pubkeys = [\n                \'03\' + first + \'00\',\n                \'02\' + second + \'00\',\n                \'020202020202020202020202020202020202020202020202020202020202020202\',\n            ].map(hex => Buffer.from(hex, \'hex\'));\n            const payment = bitcoin.payments.p2ms({ m: 1, pubkeys });\n            tx.addOutput(payment.output, revealOutValue);\n            totalRevealPrevOutputValue += revealOutValue;\n        }\n        commitTxPrevOutputList.forEach(commitTxPrevOutput => {\n            const hash = crypto_lib_1.base.reverseBuffer(crypto_lib_1.base.fromHex(commitTxPrevOutput.txId));\n            tx.addInput(hash, commitTxPrevOutput.vOut, defaultSequenceNum);\n            this.commitTxPrevOutputFetcher.push(commitTxPrevOutput.amount);\n            totalSenderAmount += commitTxPrevOutput.amount;\n        });\n        const changePkScript = bitcoin.address.toOutputScript(changeAddress, network);\n        tx.addOutput(changePkScript, 0);\n        const txForEstimate = tx.clone();\n        signTx(txForEstimate, commitTxPrevOutputList, this.network);\n        const vsize = (0, sigcost_1.countAdjustedVsize)(txForEstimate, commitTxPrevOutputList.map(a => a.address), network);\n        const fee = Math.floor(vsize * commitFeeRate);\n        const changeAmount = totalSenderAmount - totalRevealPrevOutputValue - fee;\n        if (changeAmount >= minChangeValue) {\n            tx.outs[tx.outs.length - 1].value = changeAmount;\n        }\n        else {\n            tx.outs = tx.outs.slice(0, tx.outs.length - 1);\n            txForEstimate.outs = txForEstimate.outs.slice(0, txForEstimate.outs.length - 1);\n            const vsizeWithoutChange = (0, sigcost_1.countAdjustedVsize)(txForEstimate, commitTxPrevOutputList.map(a => a.address), network);\n            const feeWithoutChange = Math.floor(vsizeWithoutChange * commitFeeRate);\n            if (totalSenderAmount - totalRevealPrevOutputValue - feeWithoutChange < 0) {\n                this.mustCommitTxFee = fee;\n                return true;\n            }\n        }\n        this.commitTx = tx;\n        return false;\n    }\n    signCommitTx(commitTxPrevOutputList) {\n        signTx(this.commitTx, commitTxPrevOutputList, this.network);\n    }\n    calculateFee() {\n        let commitTxFee = 0;\n        this.commitTx.ins.forEach((_, i) => {\n            commitTxFee += this.commitTxPrevOutputFetcher[i];\n        });\n        this.commitTx.outs.forEach(out => {\n            commitTxFee -= out.value;\n        });\n        let revealTxFees = [];\n        this.revealTxs.forEach((revealTx, i) => {\n            let revealTxFee = 0;\n            revealTxFee += this.revealTxPrevOutputFetcher[i];\n            revealTxFee -= revealTx.outs[0].value;\n            revealTxFees.push(revealTxFee);\n        });\n        return {\n            commitTxFee,\n            revealTxFees,\n        };\n    }\n}\nexports.SrcInscriptionTool = SrcInscriptionTool;\nfunction signTx(tx, commitTxPrevOutputList, network) {\n    tx.ins.forEach((input, i) => {\n        const addressType = (0, txBuild_1.getAddressType)(commitTxPrevOutputList[i].address, network);\n        const privateKey = crypto_lib_1.base.fromHex((0, txBuild_1.privateKeyFromWIF)(commitTxPrevOutputList[i].privateKey, network));\n        const privateKeyHex = crypto_lib_1.base.toHex(privateKey);\n        const publicKey = (0, txBuild_1.private2public)(privateKeyHex);\n        if (addressType === \'segwit_taproot\') {\n            const prevOutScripts = commitTxPrevOutputList.map(o => bitcoin.address.toOutputScript(o.address, network));\n            const values = commitTxPrevOutputList.map(o => o.amount);\n            const hash = tx.hashForWitnessV1(i, prevOutScripts, values, bitcoin.Transaction.SIGHASH_DEFAULT);\n            const tweakedPrivKey = taproot.taprootTweakPrivKey(privateKey);\n            const signature = Buffer.from(schnorr.sign(hash, tweakedPrivKey, crypto_lib_1.base.randomBytes(32)));\n            input.witness = [Buffer.from(signature)];\n        }\n        else if (addressType === \'legacy\') {\n            const prevScript = bitcoin.address.toOutputScript(commitTxPrevOutputList[i].address, network);\n            const hash = tx.hashForSignature(i, prevScript, bitcoin.Transaction.SIGHASH_ALL);\n            const signature = (0, txBuild_1.sign)(hash, privateKeyHex);\n            const payment = bitcoin.payments.p2pkh({\n                signature: bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL),\n                pubkey: publicKey,\n            });\n            input.script = payment.input;\n        }\n        else {\n            const pubKeyHash = bcrypto.hash160(publicKey);\n            const prevOutScript = Buffer.of(0x19, 0x76, 0xa9, 0x14, ...pubKeyHash, 0x88, 0xac);\n            const value = commitTxPrevOutputList[i].amount;\n            const hash = tx.hashForWitness(i, prevOutScript, value, bitcoin.Transaction.SIGHASH_ALL);\n            const signature = (0, txBuild_1.sign)(hash, privateKeyHex);\n            input.witness = [\n                bitcoin.script.signature.encode(signature, bitcoin.Transaction.SIGHASH_ALL),\n                publicKey,\n            ];\n            const redeemScript = Buffer.of(0x16, 0, 20, ...pubKeyHash);\n            if (addressType === "segwit_nested") {\n                input.script = redeemScript;\n            }\n        }\n    });\n}\nfunction srcInscribe(network, request) {\n    const tool = SrcInscriptionTool.newSrcInscriptionTool(network, request);\n    if (tool.mustCommitTxFee > 0) {\n        return {\n            commitTx: "",\n            revealTxs: [],\n            commitTxFee: tool.mustCommitTxFee,\n            revealTxFees: tool.mustRevealTxFees,\n            commitAddrs: tool.commitAddrs,\n        };\n    }\n    return {\n        commitTx: tool.commitTx.toHex(),\n        revealTxs: tool.revealTxs.map(revealTx => revealTx.toHex()),\n        ...tool.calculateFee(),\n        commitAddrs: tool.commitAddrs,\n    };\n}\nexports.srcInscribe = srcInscribe;\nfunction rc4(key, str) {\n    var s = [], j = 0, x, res = \'\';\n    for (var i = 0; i < 256; i++) {\n        s[i] = i;\n    }\n    for (i = 0; i < 256; i++) {\n        j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n        x = s[i];\n        s[i] = s[j];\n        s[j] = x;\n    }\n    i = 0;\n    j = 0;\n    for (var y = 0; y < str.length; y++) {\n        i = (i + 1) % 256;\n        j = (j + s[i]) % 256;\n        x = s[i];\n        s[i] = s[j];\n        s[j] = x;\n        res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n    }\n    return res;\n}\nfunction hex2bin(hex) {\n    var bytes = [];\n    var str;\n    for (var i = 0; i < hex.length - 1; i += 2) {\n        var ch = parseInt(hex.substr(i, 2), 16);\n        bytes.push(ch);\n    }\n    str = String.fromCharCode.apply(String, bytes);\n    return str;\n}\nfunction bin2hex(s) {\n    var i, l, o = \'\', n;\n    s += \'\';\n    for (i = 0, l = s.length; i < l; i++) {\n        n = s.charCodeAt(i).toString(16);\n        o += n.length < 2 ? \'0\' + n : n;\n    }\n    return o;\n}\nfunction xcp_rc4(key, datachunk) {\n    return bin2hex(rc4(hex2bin(key), hex2bin(datachunk)));\n}\n//# sourceMappingURL=src20.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvc3JjMjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLDBCQUEwQjtBQUNoRCw2QkFBNkIsbUJBQU8sQ0FBQywrRkFBaUI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xELDZCQUE2QixtQkFBTyxDQUFDLDZFQUFXO0FBQ2hELDZCQUE2QixtQkFBTyxDQUFDLHVHQUF3QjtBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNyQyx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBaUI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsNkVBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxlQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L3NyYzIwLmpzPzI1ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3JjSW5zY3JpYmUgPSBleHBvcnRzLlNyY0luc2NyaXB0aW9uVG9vbCA9IHZvaWQgMDtcbmNvbnN0IGJpdGNvaW4gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYlwiKSk7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmNvbnN0IHRhcHJvb3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdGFwcm9vdFwiKSk7XG5jb25zdCBiY3J5cHRvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWIvY3J5cHRvXCIpKTtcbmNvbnN0IHR4QnVpbGRfMSA9IHJlcXVpcmUoXCIuL3R4QnVpbGRcIik7XG5jb25zdCBiaXRjb2luanNfbGliXzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliXCIpO1xuY29uc3Qgc2lnY29zdF8xID0gcmVxdWlyZShcIi4vc2lnY29zdFwiKTtcbmNvbnN0IHNjaG5vcnIgPSBjcnlwdG9fbGliXzEuc2lnblV0aWwuc2Nobm9yci5zZWNwMjU2azEuc2Nobm9ycjtcbmNvbnN0IGRlZmF1bHRUeFZlcnNpb24gPSAyO1xuY29uc3QgUEFSVF9MRU4gPSAzMTtcbmNvbnN0IGRlZmF1bHRTZXF1ZW5jZU51bSA9IDB4ZmZmZmZmZmQ7XG5jb25zdCBkZWZhdWx0UmV2ZWFsT3V0VmFsdWUgPSA3ODAwO1xuY29uc3QgZGVmYXVsdE1pbkNoYW5nZVZhbHVlID0gNzgwMDtcbmNvbnN0IG1heFN0YW5kYXJkVHhXZWlnaHQgPSA0MDAwMDAwIC8gMTA7XG5jbGFzcyBTcmNJbnNjcmlwdGlvblRvb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm5ldHdvcmsgPSBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW47XG4gICAgICAgIHRoaXMucmV2ZWFsVHhzID0gW107XG4gICAgICAgIHRoaXMuY29tbWl0VHggPSBuZXcgYml0Y29pbi5UcmFuc2FjdGlvbigpO1xuICAgICAgICB0aGlzLmNvbW1pdFR4UHJldk91dHB1dEZldGNoZXIgPSBbXTtcbiAgICAgICAgdGhpcy5yZXZlYWxUeFByZXZPdXRwdXRGZXRjaGVyID0gW107XG4gICAgICAgIHRoaXMubXVzdENvbW1pdFR4RmVlID0gMDtcbiAgICAgICAgdGhpcy5tdXN0UmV2ZWFsVHhGZWVzID0gW107XG4gICAgICAgIHRoaXMuY29tbWl0QWRkcnMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIG5ld1NyY0luc2NyaXB0aW9uVG9vbChuZXR3b3JrLCByZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHRvb2wgPSBuZXcgU3JjSW5zY3JpcHRpb25Ub29sKCk7XG4gICAgICAgIHRvb2wubmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgIGNvbnN0IHJldmVhbE91dFZhbHVlID0gcmVxdWVzdC5yZXZlYWxPdXRWYWx1ZSB8fCBkZWZhdWx0UmV2ZWFsT3V0VmFsdWU7XG4gICAgICAgIGNvbnN0IG1pbkNoYW5nZVZhbHVlID0gcmVxdWVzdC5taW5DaGFuZ2VWYWx1ZSB8fCBkZWZhdWx0TWluQ2hhbmdlVmFsdWU7XG4gICAgICAgIGNvbnN0IGluc3VmZmljaWVudCA9IHRvb2wuYnVpbGRDb21taXRUeChuZXR3b3JrLCByZXF1ZXN0Lmluc2NyaXB0aW9uRGF0YSwgcmV2ZWFsT3V0VmFsdWUsIHJlcXVlc3QuY29tbWl0VHhQcmV2T3V0cHV0TGlzdCwgcmVxdWVzdC5jaGFuZ2VBZGRyZXNzLCByZXF1ZXN0LmNvbW1pdEZlZVJhdGUsIG1pbkNoYW5nZVZhbHVlKTtcbiAgICAgICAgaWYgKGluc3VmZmljaWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbC5zaWduQ29tbWl0VHgocmVxdWVzdC5jb21taXRUeFByZXZPdXRwdXRMaXN0KTtcbiAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgfVxuICAgIGJ1aWxkQ29tbWl0VHgobmV0d29yaywgaW5zY3JpcHRpb25EYXRhLCByZXZlYWxPdXRWYWx1ZSwgY29tbWl0VHhQcmV2T3V0cHV0TGlzdCwgY2hhbmdlQWRkcmVzcywgY29tbWl0RmVlUmF0ZSwgbWluQ2hhbmdlVmFsdWUpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IEJ1ZmZlci5mcm9tKGluc2NyaXB0aW9uRGF0YS5jb250ZW50VHlwZSk7XG4gICAgICAgIGxldCBib2R5ID0gQnVmZmVyLmZyb20oaW5zY3JpcHRpb25EYXRhLmJvZHkpO1xuICAgICAgICB3aGlsZSAoYm9keVtib2R5Lmxlbmd0aCAtIDFdID09IDApIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2R5LnNsaWNlKDAsIGJvZHkubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGwgPSAyICsgcHJlZml4Lmxlbmd0aCArIGJvZHkubGVuZ3RoO1xuICAgICAgICBsZXQgdG90YWwgPSBsICUgNjIgPT0gMCA/IGwgOiAobCArIDYyIC0gbCAlIDYyKTtcbiAgICAgICAgbGV0IGJ1ZmZlcldyaXRlciA9IGJpdGNvaW5qc19saWJfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KHRvdGFsKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UoQnVmZmVyLmZyb20oWyhwcmVmaXgubGVuZ3RoICsgYm9keS5sZW5ndGgpIC8gMjU2LCAocHJlZml4Lmxlbmd0aCArIGJvZHkubGVuZ3RoKSAlIDI1Nl0pKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UocHJlZml4KTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UoYm9keSk7XG4gICAgICAgIGlmICh0b3RhbCA+IGwpIHtcbiAgICAgICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKEJ1ZmZlci5hbGxvYyh0b3RhbCAtIGwpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IGJ1ZmZlcldyaXRlci5lbmQoKTtcbiAgICAgICAgbGV0IGJ1ZiA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoeGNwX3JjNChjb21taXRUeFByZXZPdXRwdXRMaXN0WzBdLnR4SWQsIGRhdGEudG9TdHJpbmcoXCJoZXhcIikpKTtcbiAgICAgICAgbGV0IHRvdGFsU2VuZGVyQW1vdW50ID0gMDtcbiAgICAgICAgbGV0IHRvdGFsUmV2ZWFsUHJldk91dHB1dFZhbHVlID0gMDtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgYml0Y29pbi5UcmFuc2FjdGlvbigpO1xuICAgICAgICB0eC52ZXJzaW9uID0gZGVmYXVsdFR4VmVyc2lvbjtcbiAgICAgICAgdG90YWxSZXZlYWxQcmV2T3V0cHV0VmFsdWUgKz0gcmV2ZWFsT3V0VmFsdWU7XG4gICAgICAgIHR4LmFkZE91dHB1dChiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQoaW5zY3JpcHRpb25EYXRhLnJldmVhbEFkZHIsIG5ldHdvcmspLCByZXZlYWxPdXRWYWx1ZSk7XG4gICAgICAgIHdoaWxlIChidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgYnVmMSA9IGJ1Zi5zbGljZSgwLCBNYXRoLm1pbihQQVJUX0xFTiwgYnVmLmxlbmd0aCkpO1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gYnVmMS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgICAgICAgIGlmIChmaXJzdC5sZW5ndGggPCA2Mikge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmlyc3QgKyAnMCcucmVwZWF0KDYyIC0gZmlyc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZShidWYxLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgYnVmMiA9IGJ1Zi5zbGljZSgwLCBNYXRoLm1pbihQQVJUX0xFTiwgYnVmLmxlbmd0aCkpO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IGJ1ZjIudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICAgICAgICBpZiAoc2Vjb25kLmxlbmd0aCA8IDYyKSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kID0gc2Vjb25kICsgJzAnLnJlcGVhdCg2MiAtIHNlY29uZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmID0gYnVmLnNsaWNlKGJ1ZjEubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHB1YmtleXMgPSBbXG4gICAgICAgICAgICAgICAgJzAzJyArIGZpcnN0ICsgJzAwJyxcbiAgICAgICAgICAgICAgICAnMDInICsgc2Vjb25kICsgJzAwJyxcbiAgICAgICAgICAgICAgICAnMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyJyxcbiAgICAgICAgICAgIF0ubWFwKGhleCA9PiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKSk7XG4gICAgICAgICAgICBjb25zdCBwYXltZW50ID0gYml0Y29pbi5wYXltZW50cy5wMm1zKHsgbTogMSwgcHVia2V5cyB9KTtcbiAgICAgICAgICAgIHR4LmFkZE91dHB1dChwYXltZW50Lm91dHB1dCwgcmV2ZWFsT3V0VmFsdWUpO1xuICAgICAgICAgICAgdG90YWxSZXZlYWxQcmV2T3V0cHV0VmFsdWUgKz0gcmV2ZWFsT3V0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0VHhQcmV2T3V0cHV0TGlzdC5mb3JFYWNoKGNvbW1pdFR4UHJldk91dHB1dCA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvX2xpYl8xLmJhc2UucmV2ZXJzZUJ1ZmZlcihjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KGNvbW1pdFR4UHJldk91dHB1dC50eElkKSk7XG4gICAgICAgICAgICB0eC5hZGRJbnB1dChoYXNoLCBjb21taXRUeFByZXZPdXRwdXQudk91dCwgZGVmYXVsdFNlcXVlbmNlTnVtKTtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0VHhQcmV2T3V0cHV0RmV0Y2hlci5wdXNoKGNvbW1pdFR4UHJldk91dHB1dC5hbW91bnQpO1xuICAgICAgICAgICAgdG90YWxTZW5kZXJBbW91bnQgKz0gY29tbWl0VHhQcmV2T3V0cHV0LmFtb3VudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZVBrU2NyaXB0ID0gYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KGNoYW5nZUFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgICB0eC5hZGRPdXRwdXQoY2hhbmdlUGtTY3JpcHQsIDApO1xuICAgICAgICBjb25zdCB0eEZvckVzdGltYXRlID0gdHguY2xvbmUoKTtcbiAgICAgICAgc2lnblR4KHR4Rm9yRXN0aW1hdGUsIGNvbW1pdFR4UHJldk91dHB1dExpc3QsIHRoaXMubmV0d29yayk7XG4gICAgICAgIGNvbnN0IHZzaXplID0gKDAsIHNpZ2Nvc3RfMS5jb3VudEFkanVzdGVkVnNpemUpKHR4Rm9yRXN0aW1hdGUsIGNvbW1pdFR4UHJldk91dHB1dExpc3QubWFwKGEgPT4gYS5hZGRyZXNzKSwgbmV0d29yayk7XG4gICAgICAgIGNvbnN0IGZlZSA9IE1hdGguZmxvb3IodnNpemUgKiBjb21taXRGZWVSYXRlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlQW1vdW50ID0gdG90YWxTZW5kZXJBbW91bnQgLSB0b3RhbFJldmVhbFByZXZPdXRwdXRWYWx1ZSAtIGZlZTtcbiAgICAgICAgaWYgKGNoYW5nZUFtb3VudCA+PSBtaW5DaGFuZ2VWYWx1ZSkge1xuICAgICAgICAgICAgdHgub3V0c1t0eC5vdXRzLmxlbmd0aCAtIDFdLnZhbHVlID0gY2hhbmdlQW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHgub3V0cyA9IHR4Lm91dHMuc2xpY2UoMCwgdHgub3V0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHR4Rm9yRXN0aW1hdGUub3V0cyA9IHR4Rm9yRXN0aW1hdGUub3V0cy5zbGljZSgwLCB0eEZvckVzdGltYXRlLm91dHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCB2c2l6ZVdpdGhvdXRDaGFuZ2UgPSAoMCwgc2lnY29zdF8xLmNvdW50QWRqdXN0ZWRWc2l6ZSkodHhGb3JFc3RpbWF0ZSwgY29tbWl0VHhQcmV2T3V0cHV0TGlzdC5tYXAoYSA9PiBhLmFkZHJlc3MpLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZVdpdGhvdXRDaGFuZ2UgPSBNYXRoLmZsb29yKHZzaXplV2l0aG91dENoYW5nZSAqIGNvbW1pdEZlZVJhdGUpO1xuICAgICAgICAgICAgaWYgKHRvdGFsU2VuZGVyQW1vdW50IC0gdG90YWxSZXZlYWxQcmV2T3V0cHV0VmFsdWUgLSBmZWVXaXRob3V0Q2hhbmdlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubXVzdENvbW1pdFR4RmVlID0gZmVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWl0VHggPSB0eDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaWduQ29tbWl0VHgoY29tbWl0VHhQcmV2T3V0cHV0TGlzdCkge1xuICAgICAgICBzaWduVHgodGhpcy5jb21taXRUeCwgY29tbWl0VHhQcmV2T3V0cHV0TGlzdCwgdGhpcy5uZXR3b3JrKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlRmVlKCkge1xuICAgICAgICBsZXQgY29tbWl0VHhGZWUgPSAwO1xuICAgICAgICB0aGlzLmNvbW1pdFR4Lmlucy5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgICAgICBjb21taXRUeEZlZSArPSB0aGlzLmNvbW1pdFR4UHJldk91dHB1dEZldGNoZXJbaV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbW1pdFR4Lm91dHMuZm9yRWFjaChvdXQgPT4ge1xuICAgICAgICAgICAgY29tbWl0VHhGZWUgLT0gb3V0LnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJldmVhbFR4RmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnJldmVhbFR4cy5mb3JFYWNoKChyZXZlYWxUeCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJldmVhbFR4RmVlID0gMDtcbiAgICAgICAgICAgIHJldmVhbFR4RmVlICs9IHRoaXMucmV2ZWFsVHhQcmV2T3V0cHV0RmV0Y2hlcltpXTtcbiAgICAgICAgICAgIHJldmVhbFR4RmVlIC09IHJldmVhbFR4Lm91dHNbMF0udmFsdWU7XG4gICAgICAgICAgICByZXZlYWxUeEZlZXMucHVzaChyZXZlYWxUeEZlZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tbWl0VHhGZWUsXG4gICAgICAgICAgICByZXZlYWxUeEZlZXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TcmNJbnNjcmlwdGlvblRvb2wgPSBTcmNJbnNjcmlwdGlvblRvb2w7XG5mdW5jdGlvbiBzaWduVHgodHgsIGNvbW1pdFR4UHJldk91dHB1dExpc3QsIG5ldHdvcmspIHtcbiAgICB0eC5pbnMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgYWRkcmVzc1R5cGUgPSAoMCwgdHhCdWlsZF8xLmdldEFkZHJlc3NUeXBlKShjb21taXRUeFByZXZPdXRwdXRMaXN0W2ldLmFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleCgoMCwgdHhCdWlsZF8xLnByaXZhdGVLZXlGcm9tV0lGKShjb21taXRUeFByZXZPdXRwdXRMaXN0W2ldLnByaXZhdGVLZXksIG5ldHdvcmspKTtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleUhleCA9IGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KHByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgdHhCdWlsZF8xLnByaXZhdGUycHVibGljKShwcml2YXRlS2V5SGV4KTtcbiAgICAgICAgaWYgKGFkZHJlc3NUeXBlID09PSAnc2Vnd2l0X3RhcHJvb3QnKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2T3V0U2NyaXB0cyA9IGNvbW1pdFR4UHJldk91dHB1dExpc3QubWFwKG8gPT4gYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KG8uYWRkcmVzcywgbmV0d29yaykpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gY29tbWl0VHhQcmV2T3V0cHV0TGlzdC5tYXAobyA9PiBvLmFtb3VudCk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gdHguaGFzaEZvcldpdG5lc3NWMShpLCBwcmV2T3V0U2NyaXB0cywgdmFsdWVzLCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCk7XG4gICAgICAgICAgICBjb25zdCB0d2Vha2VkUHJpdktleSA9IHRhcHJvb3QudGFwcm9vdFR3ZWFrUHJpdktleShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNjaG5vcnIuc2lnbihoYXNoLCB0d2Vha2VkUHJpdktleSwgY3J5cHRvX2xpYl8xLmJhc2UucmFuZG9tQnl0ZXMoMzIpKSk7XG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzID0gW0J1ZmZlci5mcm9tKHNpZ25hdHVyZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFkZHJlc3NUeXBlID09PSAnbGVnYWN5Jykge1xuICAgICAgICAgICAgY29uc3QgcHJldlNjcmlwdCA9IGJpdGNvaW4uYWRkcmVzcy50b091dHB1dFNjcmlwdChjb21taXRUeFByZXZPdXRwdXRMaXN0W2ldLmFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHR4Lmhhc2hGb3JTaWduYXR1cmUoaSwgcHJldlNjcmlwdCwgYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSAoMCwgdHhCdWlsZF8xLnNpZ24pKGhhc2gsIHByaXZhdGVLZXlIZXgpO1xuICAgICAgICAgICAgY29uc3QgcGF5bWVudCA9IGJpdGNvaW4ucGF5bWVudHMucDJwa2goe1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpLFxuICAgICAgICAgICAgICAgIHB1YmtleTogcHVibGljS2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dC5zY3JpcHQgPSBwYXltZW50LmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHViS2V5SGFzaCA9IGJjcnlwdG8uaGFzaDE2MChwdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3QgcHJldk91dFNjcmlwdCA9IEJ1ZmZlci5vZigweDE5LCAweDc2LCAweGE5LCAweDE0LCAuLi5wdWJLZXlIYXNoLCAweDg4LCAweGFjKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29tbWl0VHhQcmV2T3V0cHV0TGlzdFtpXS5hbW91bnQ7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gdHguaGFzaEZvcldpdG5lc3MoaSwgcHJldk91dFNjcmlwdCwgdmFsdWUsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gKDAsIHR4QnVpbGRfMS5zaWduKShoYXNoLCBwcml2YXRlS2V5SGV4KTtcbiAgICAgICAgICAgIGlucHV0LndpdG5lc3MgPSBbXG4gICAgICAgICAgICAgICAgYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpLFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCByZWRlZW1TY3JpcHQgPSBCdWZmZXIub2YoMHgxNiwgMCwgMjAsIC4uLnB1YktleUhhc2gpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NUeXBlID09PSBcInNlZ3dpdF9uZXN0ZWRcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LnNjcmlwdCA9IHJlZGVlbVNjcmlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc3JjSW5zY3JpYmUobmV0d29yaywgcmVxdWVzdCkge1xuICAgIGNvbnN0IHRvb2wgPSBTcmNJbnNjcmlwdGlvblRvb2wubmV3U3JjSW5zY3JpcHRpb25Ub29sKG5ldHdvcmssIHJlcXVlc3QpO1xuICAgIGlmICh0b29sLm11c3RDb21taXRUeEZlZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbW1pdFR4OiBcIlwiLFxuICAgICAgICAgICAgcmV2ZWFsVHhzOiBbXSxcbiAgICAgICAgICAgIGNvbW1pdFR4RmVlOiB0b29sLm11c3RDb21taXRUeEZlZSxcbiAgICAgICAgICAgIHJldmVhbFR4RmVlczogdG9vbC5tdXN0UmV2ZWFsVHhGZWVzLFxuICAgICAgICAgICAgY29tbWl0QWRkcnM6IHRvb2wuY29tbWl0QWRkcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFR4OiB0b29sLmNvbW1pdFR4LnRvSGV4KCksXG4gICAgICAgIHJldmVhbFR4czogdG9vbC5yZXZlYWxUeHMubWFwKHJldmVhbFR4ID0+IHJldmVhbFR4LnRvSGV4KCkpLFxuICAgICAgICAuLi50b29sLmNhbGN1bGF0ZUZlZSgpLFxuICAgICAgICBjb21taXRBZGRyczogdG9vbC5jb21taXRBZGRycyxcbiAgICB9O1xufVxuZXhwb3J0cy5zcmNJbnNjcmliZSA9IHNyY0luc2NyaWJlO1xuZnVuY3Rpb24gcmM0KGtleSwgc3RyKSB7XG4gICAgdmFyIHMgPSBbXSwgaiA9IDAsIHgsIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgc1tpXSA9IGk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBqID0gKGogKyBzW2ldICsga2V5LmNoYXJDb2RlQXQoaSAlIGtleS5sZW5ndGgpKSAlIDI1NjtcbiAgICAgICAgeCA9IHNbaV07XG4gICAgICAgIHNbaV0gPSBzW2pdO1xuICAgICAgICBzW2pdID0geDtcbiAgICB9XG4gICAgaSA9IDA7XG4gICAgaiA9IDA7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBzdHIubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgaSA9IChpICsgMSkgJSAyNTY7XG4gICAgICAgIGogPSAoaiArIHNbaV0pICUgMjU2O1xuICAgICAgICB4ID0gc1tpXTtcbiAgICAgICAgc1tpXSA9IHNbal07XG4gICAgICAgIHNbal0gPSB4O1xuICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzdHIuY2hhckNvZGVBdCh5KSBeIHNbKHNbaV0gKyBzW2pdKSAlIDI1Nl0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gaGV4MmJpbihoZXgpIHtcbiAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICB2YXIgc3RyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4Lmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICB2YXIgY2ggPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICAgIGJ5dGVzLnB1c2goY2gpO1xuICAgIH1cbiAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYnl0ZXMpO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBiaW4yaGV4KHMpIHtcbiAgICB2YXIgaSwgbCwgbyA9ICcnLCBuO1xuICAgIHMgKz0gJyc7XG4gICAgZm9yIChpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG4gPSBzLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpO1xuICAgICAgICBvICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICAgIH1cbiAgICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIHhjcF9yYzQoa2V5LCBkYXRhY2h1bmspIHtcbiAgICByZXR1cm4gYmluMmhleChyYzQoaGV4MmJpbihrZXkpLCBoZXgyYmluKGRhdGFjaHVuaykpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNyYzIwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/src20.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/taproot.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/taproot.js ***!
  \************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.taprootTweakPubkey = exports.taprootTweakPrivKey = void 0;\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst secp256k1 = crypto_lib_1.signUtil.schnorr.secp256k1;\nconst schnorr = secp256k1.schnorr;\nconst ProjPoint = secp256k1.secp256k1.ProjectivePoint;\nconst CURVE_ORDER = secp256k1.secp256k1.CURVE.n;\nfunction tapTweak(a, b) {\n    const u = schnorr.utils;\n    const t = u.taggedHash(\'TapTweak\', a, b);\n    const tn = u.bytesToNumberBE(t);\n    if (tn >= CURVE_ORDER)\n        throw new Error(\'tweak higher than curve order\');\n    return tn;\n}\nfunction taprootTweakPrivKey(privKey, merkleRoot = new Uint8Array()) {\n    const u = schnorr.utils;\n    const seckey0 = u.bytesToNumberBE(privKey);\n    const P = ProjPoint.fromPrivateKey(seckey0);\n    const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n    const xP = u.pointToBytes(P);\n    const t = tapTweak(xP, merkleRoot);\n    return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\nexports.taprootTweakPrivKey = taprootTweakPrivKey;\nfunction taprootTweakPubkey(pubKey, h) {\n    if (!h)\n        h = new Uint8Array();\n    const u = schnorr.utils;\n    const t = tapTweak(pubKey, h);\n    const P = u.lift_x(u.bytesToNumberBE(pubKey));\n    const Q = P.add(ProjPoint.fromPrivateKey(t));\n    const parity = Q.hasEvenY() ? 0 : 1;\n    return [u.pointToBytes(Q), parity];\n}\nexports.taprootTweakPubkey = taprootTweakPubkey;\n//# sourceMappingURL=taproot.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvdGFwcm9vdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRywyQkFBMkI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L3RhcHJvb3QuanM/ZDc2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGFwcm9vdFR3ZWFrUHVia2V5ID0gZXhwb3J0cy50YXByb290VHdlYWtQcml2S2V5ID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvX2xpYl8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NyeXB0by1saWJcIik7XG5jb25zdCBzZWNwMjU2azEgPSBjcnlwdG9fbGliXzEuc2lnblV0aWwuc2Nobm9yci5zZWNwMjU2azE7XG5jb25zdCBzY2hub3JyID0gc2VjcDI1NmsxLnNjaG5vcnI7XG5jb25zdCBQcm9qUG9pbnQgPSBzZWNwMjU2azEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IENVUlZFX09SREVSID0gc2VjcDI1NmsxLnNlY3AyNTZrMS5DVVJWRS5uO1xuZnVuY3Rpb24gdGFwVHdlYWsoYSwgYikge1xuICAgIGNvbnN0IHUgPSBzY2hub3JyLnV0aWxzO1xuICAgIGNvbnN0IHQgPSB1LnRhZ2dlZEhhc2goJ1RhcFR3ZWFrJywgYSwgYik7XG4gICAgY29uc3QgdG4gPSB1LmJ5dGVzVG9OdW1iZXJCRSh0KTtcbiAgICBpZiAodG4gPj0gQ1VSVkVfT1JERVIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHdlYWsgaGlnaGVyIHRoYW4gY3VydmUgb3JkZXInKTtcbiAgICByZXR1cm4gdG47XG59XG5mdW5jdGlvbiB0YXByb290VHdlYWtQcml2S2V5KHByaXZLZXksIG1lcmtsZVJvb3QgPSBuZXcgVWludDhBcnJheSgpKSB7XG4gICAgY29uc3QgdSA9IHNjaG5vcnIudXRpbHM7XG4gICAgY29uc3Qgc2Vja2V5MCA9IHUuYnl0ZXNUb051bWJlckJFKHByaXZLZXkpO1xuICAgIGNvbnN0IFAgPSBQcm9qUG9pbnQuZnJvbVByaXZhdGVLZXkoc2Vja2V5MCk7XG4gICAgY29uc3Qgc2Vja2V5ID0gUC5oYXNFdmVuWSgpID8gc2Vja2V5MCA6IHUubW9kKC1zZWNrZXkwLCBDVVJWRV9PUkRFUik7XG4gICAgY29uc3QgeFAgPSB1LnBvaW50VG9CeXRlcyhQKTtcbiAgICBjb25zdCB0ID0gdGFwVHdlYWsoeFAsIG1lcmtsZVJvb3QpO1xuICAgIHJldHVybiB1Lm51bWJlclRvQnl0ZXNCRSh1Lm1vZChzZWNrZXkgKyB0LCBDVVJWRV9PUkRFUiksIDMyKTtcbn1cbmV4cG9ydHMudGFwcm9vdFR3ZWFrUHJpdktleSA9IHRhcHJvb3RUd2Vha1ByaXZLZXk7XG5mdW5jdGlvbiB0YXByb290VHdlYWtQdWJrZXkocHViS2V5LCBoKSB7XG4gICAgaWYgKCFoKVxuICAgICAgICBoID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICBjb25zdCB1ID0gc2Nobm9yci51dGlscztcbiAgICBjb25zdCB0ID0gdGFwVHdlYWsocHViS2V5LCBoKTtcbiAgICBjb25zdCBQID0gdS5saWZ0X3godS5ieXRlc1RvTnVtYmVyQkUocHViS2V5KSk7XG4gICAgY29uc3QgUSA9IFAuYWRkKFByb2pQb2ludC5mcm9tUHJpdmF0ZUtleSh0KSk7XG4gICAgY29uc3QgcGFyaXR5ID0gUS5oYXNFdmVuWSgpID8gMCA6IDE7XG4gICAgcmV0dXJuIFt1LnBvaW50VG9CeXRlcyhRKSwgcGFyaXR5XTtcbn1cbmV4cG9ydHMudGFwcm9vdFR3ZWFrUHVia2V5ID0gdGFwcm9vdFR3ZWFrUHVia2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFwcm9vdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/taproot.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js ***!
  \************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.estimateBchFee = exports.estimateBtcFee = exports.ValidSignedTransaction = exports.getMPCTransaction = exports.calculateBchTxSize = exports.calculateTxSize = exports.signBch = exports.getAddressType = exports.signBtc = exports.TxBuild = exports.private2Wif = exports.wif2Public = exports.sign = exports.private2public = exports.privateKeyFromWIF = exports.Array = void 0;\nconst bitcoin = __importStar(__webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js"));\nconst bitcoinjs_lib_1 = __webpack_require__(/*! ./bitcoinjs-lib */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/index.js");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst wif = __importStar(__webpack_require__(/*! ./wif */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wif.js"));\nconst address_1 = __webpack_require__(/*! ./bitcoinjs-lib/address */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/address.js");\nconst bcrypto = __importStar(__webpack_require__(/*! ./bitcoinjs-lib/crypto */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/crypto.js"));\nconst taproot = __importStar(__webpack_require__(/*! ./taproot */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/taproot.js"));\nconst bscript = __importStar(__webpack_require__(/*! ./bitcoinjs-lib/script */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/script.js"));\nconst ops_1 = __webpack_require__(/*! ./bitcoinjs-lib/ops */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/ops.js");\nconst sigcost_1 = __webpack_require__(/*! ./sigcost */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/sigcost.js");\nconst schnorr = crypto_lib_1.signUtil.schnorr.secp256k1.schnorr;\nexports.Array = crypto_lib_1.typeforce.Array;\nfunction privateKeyFromWIF(wifString, network) {\n    const decoded = wif.decode(wifString);\n    const version = decoded.version;\n    if ((0, exports.Array)(network)) {\n        network = network\n            .filter((x) => {\n            return version === x.wif;\n        })\n            .pop();\n        if (!network)\n            throw new Error(\'Unknown network version\');\n    }\n    else {\n        network = network || bitcoin.networks.bitcoin;\n        if (version !== network.wif)\n            throw new Error(\'Invalid network version\');\n    }\n    return crypto_lib_1.base.toHex(decoded.privateKey);\n}\nexports.privateKeyFromWIF = privateKeyFromWIF;\nfunction private2public(privateKey) {\n    return crypto_lib_1.signUtil.secp256k1.publicKeyCreate(crypto_lib_1.base.fromHex(privateKey), true);\n}\nexports.private2public = private2public;\nfunction sign(hash, privateKey) {\n    const { signature } = crypto_lib_1.signUtil.secp256k1.sign(hash, crypto_lib_1.base.fromHex(privateKey));\n    return Buffer.from(signature);\n}\nexports.sign = sign;\nfunction wif2Public(wif, network) {\n    const privateKey = privateKeyFromWIF(wif, network);\n    return private2public(privateKey);\n}\nexports.wif2Public = wif2Public;\nfunction private2Wif(privateKey, network) {\n    network = network || bitcoin.networks.bitcoin;\n    return wif.encode(network.wif, privateKey, true);\n}\nexports.private2Wif = private2Wif;\nclass TxBuild {\n    constructor(version, network, bitcoinCash, hardware) {\n        this.tx = new bitcoin.Transaction();\n        this.network = bitcoin.networks.bitcoin;\n        if (version) {\n            this.tx.version = version;\n        }\n        else {\n            this.tx.version = 2;\n        }\n        if (network) {\n            this.network = network;\n        }\n        this.inputs = [];\n        this.outputs = [];\n        this.bitcoinCash = bitcoinCash || false;\n        this.hardware = hardware || false;\n    }\n    addInput(txId, index, privateKey, address, script, value, publicKey, sequence) {\n        this.inputs.push({\n            txId: txId,\n            index: index,\n            privateKey: privateKey,\n            address: address,\n            script: script,\n            value: value,\n            publicKey: publicKey,\n            sequence: sequence\n        });\n    }\n    addOutput(address, value, omniScript) {\n        this.outputs.push({\n            address: address, value: value, omniScript: omniScript\n        });\n    }\n    build(hashArray) {\n        const eckeys = [];\n        for (const input of this.inputs) {\n            const hash = crypto_lib_1.base.reverseBuffer(Buffer.from(input.txId, "hex"));\n            this.tx.addInput(hash, input.index, input.sequence);\n            if (input.privateKey) {\n                eckeys.push(privateKeyFromWIF(input.privateKey, this.network));\n            }\n            else {\n                eckeys.push("");\n            }\n        }\n        for (const output of this.outputs) {\n            if (output.omniScript) {\n                this.tx.addOutput(crypto_lib_1.base.fromHex(output.omniScript), 0);\n            }\n            else {\n                const outputScript = bitcoin.address.toOutputScript(output.address, this.network);\n                this.tx.addOutput(outputScript, output.value);\n            }\n        }\n        if (this.hardware) {\n            return this.tx.toHex();\n        }\n        for (let i = 0; i < eckeys.length; i++) {\n            const eckey = eckeys[i];\n            let ecPub;\n            if (eckey) {\n                ecPub = private2public(eckey);\n            }\n            else {\n                if (!this.hardware) {\n                    ecPub = crypto_lib_1.base.fromHex(this.inputs[i].publicKey);\n                }\n            }\n            let hash;\n            let hashType = bitcoin.Transaction.SIGHASH_ALL;\n            if (this.bitcoinCash) {\n                const script = bitcoin.payments.p2pkh({ pubkey: ecPub }).output;\n                hashType = bitcoin.Transaction.SIGHASH_ALL | bitcoin.Transaction.SIGHASH_BITCOINCASHBIP143;\n                const value = this.inputs[i].value || 0;\n                hash = this.tx.hashForCashSignature(i, script, value, hashType);\n                let signature;\n                if (hashArray) {\n                    hashArray.push(crypto_lib_1.base.toHex(hash));\n                    signature = Buffer.alloc(64, 0);\n                }\n                else {\n                    signature = sign(hash, eckey);\n                }\n                const payment = bitcoin.payments.p2pkh({\n                    output: script,\n                    pubkey: ecPub,\n                    signature: bitcoin.script.signature.encode(signature, hashType)\n                });\n                if (payment.input) {\n                    this.tx.ins[i].script = payment.input;\n                }\n            }\n            else {\n                const addressType = getAddressType(this.inputs[i].address, this.network);\n                if (addressType === "legacy") {\n                    const script = bitcoin.payments.p2pkh({ pubkey: ecPub }).output;\n                    hash = this.tx.hashForSignature(i, script, hashType);\n                    let signature;\n                    if (hashArray) {\n                        hashArray.push(crypto_lib_1.base.toHex(hash));\n                        signature = Buffer.alloc(64, 0);\n                    }\n                    else {\n                        signature = sign(hash, eckey);\n                    }\n                    const payment = bitcoin.payments.p2pkh({\n                        output: script,\n                        pubkey: ecPub,\n                        signature: bitcoin.script.signature.encode(signature, hashType)\n                    });\n                    if (payment.input) {\n                        this.tx.ins[i].script = payment.input;\n                    }\n                }\n                else if (addressType === "segwit_taproot") {\n                    const prevOutScripts = this.inputs.map(o => bitcoin.address.toOutputScript(o.address, this.network));\n                    const values = this.inputs.map(o => o.value);\n                    hash = this.tx.hashForWitnessV1(i, prevOutScripts, values, bitcoin.Transaction.SIGHASH_DEFAULT);\n                    let signature;\n                    if (hashArray) {\n                        hashArray.push(crypto_lib_1.base.toHex(hash));\n                        signature = Buffer.alloc(64, 0);\n                    }\n                    else {\n                        const tweakedPrivKey = taproot.taprootTweakPrivKey(crypto_lib_1.base.fromHex(eckey));\n                        signature = Buffer.from(schnorr.sign(hash, tweakedPrivKey, crypto_lib_1.base.randomBytes(32)));\n                    }\n                    this.tx.ins[i].witness = [Buffer.from(signature)];\n                }\n                else {\n                    const pubHash = bcrypto.hash160(ecPub);\n                    const prevOutScript = Buffer.of(0x19, 0x76, 0xa9, 0x14, ...pubHash, 0x88, 0xac);\n                    const value = this.inputs[i].value || 0;\n                    hash = this.tx.hashForWitness(i, prevOutScript, value, hashType);\n                    let signature;\n                    if (hashArray) {\n                        hashArray.push(crypto_lib_1.base.toHex(hash));\n                        signature = Buffer.alloc(64, 0);\n                    }\n                    else {\n                        signature = sign(hash, eckey);\n                    }\n                    this.tx.ins[i].witness = [];\n                    this.tx.ins[i].witness.push(bitcoin.script.signature.encode(signature, hashType));\n                    this.tx.ins[i].witness.push(ecPub);\n                    const redeemScript = Buffer.of(0x16, 0, 20, ...pubHash);\n                    if (addressType !== "segwit_native") {\n                        this.tx.ins[i].script = redeemScript;\n                    }\n                }\n            }\n        }\n        return this.tx.toHex();\n    }\n    virtualSize() {\n        return (0, sigcost_1.countAdjustedVsize)(this.tx, this.inputs.map(a => a.address), this.network || bitcoin.networks.bitcoin);\n    }\n}\nexports.TxBuild = TxBuild;\nfunction signBtc(utxoTx, privateKey, network, hashArray, hardware, changeOnly) {\n    const inputs = utxoTx.inputs;\n    const outputs = utxoTx.outputs;\n    const changeAddress = utxoTx.address;\n    const feePerB = utxoTx.feePerB || 10;\n    const dustSize = utxoTx.dustSize || 546;\n    network = network || bitcoin.networks.bitcoin;\n    if (utxoTx.memo) {\n        let buf = crypto_lib_1.base.isHexString(utxoTx.memo) ? crypto_lib_1.base.fromHex(utxoTx.memo) : Buffer.from(crypto_lib_1.base.toUtf8(utxoTx.memo));\n        if (buf.length > 80) {\n            throw new Error(\'data after op_return is  too long\');\n        }\n    }\n    let fakePrivateKey = privateKey;\n    if (!fakePrivateKey) {\n        fakePrivateKey = private2Wif(crypto_lib_1.base.fromHex("853fd8960ff34838208d662ecd3b9f8cf413e13e0f74f95e554f8089f5058db0"), network);\n    }\n    if (changeOnly) {\n        let { inputAmount, outputAmount, virtualSize } = calculateTxSize(inputs, outputs, changeAddress, fakePrivateKey, network, dustSize, false, utxoTx.memo, utxoTx.memoPos);\n        return (inputAmount - outputAmount - virtualSize * feePerB).toString();\n    }\n    let { inputAmount, outputAmount, virtualSize } = calculateTxSize(inputs, outputs, changeAddress, fakePrivateKey, network, dustSize, false, utxoTx.memo, utxoTx.memoPos);\n    let changeAmount = inputAmount - outputAmount - virtualSize * feePerB;\n    let txBuild = new TxBuild(2, network, false, hardware);\n    for (let i = 0; i < inputs.length; i++) {\n        let input = inputs[i];\n        const inputPrivKey = input.privateKey || privateKey;\n        const inputAddress = input.address || changeAddress;\n        txBuild.addInput(input.txId, input.vOut, inputPrivKey, inputAddress, input.reedScript, input.amount, input.publicKey, input.sequence);\n    }\n    if (utxoTx.memo && utxoTx.memoPos == 0) {\n        txBuild.addOutput(\'\', 0, crypto_lib_1.base.toHex(bscript.compile([ops_1.OPS.OP_RETURN].concat(crypto_lib_1.base.isHexString(utxoTx.memo) ? crypto_lib_1.base.fromHex(utxoTx.memo) : Buffer.from(crypto_lib_1.base.toUtf8(utxoTx.memo))))));\n    }\n    for (let i = 0; i < outputs.length; i++) {\n        let output = outputs[i];\n        txBuild.addOutput(output.address, output.amount, output.omniScript);\n        if (utxoTx.memo && utxoTx.memoPos && txBuild.outputs.length == utxoTx.memoPos) {\n            txBuild.addOutput(\'\', 0, crypto_lib_1.base.toHex(bscript.compile([ops_1.OPS.OP_RETURN].concat(crypto_lib_1.base.isHexString(utxoTx.memo) ? crypto_lib_1.base.fromHex(utxoTx.memo) : Buffer.from(crypto_lib_1.base.toUtf8(utxoTx.memo))))));\n        }\n    }\n    if (changeAmount > dustSize) {\n        txBuild.addOutput(changeAddress, changeAmount);\n        if (utxoTx.memo && utxoTx.memoPos && txBuild.outputs.length == utxoTx.memoPos) {\n            txBuild.addOutput(\'\', 0, crypto_lib_1.base.toHex(bscript.compile([ops_1.OPS.OP_RETURN].concat(crypto_lib_1.base.isHexString(utxoTx.memo) ? crypto_lib_1.base.fromHex(utxoTx.memo) : Buffer.from(crypto_lib_1.base.toUtf8(utxoTx.memo))))));\n        }\n    }\n    if (utxoTx.memo && (utxoTx.memoPos == undefined || utxoTx.memoPos < 0 || utxoTx.memoPos > txBuild.outputs.length)) {\n        txBuild.addOutput(\'\', 0, crypto_lib_1.base.toHex(bscript.compile([ops_1.OPS.OP_RETURN].concat(crypto_lib_1.base.isHexString(utxoTx.memo) ? crypto_lib_1.base.fromHex(utxoTx.memo) : Buffer.from(crypto_lib_1.base.toUtf8(utxoTx.memo))))));\n    }\n    return txBuild.build(hashArray);\n}\nexports.signBtc = signBtc;\nfunction getAddressType(address, network) {\n    let decodeBase58;\n    let decodeBech32;\n    try {\n        decodeBase58 = (0, address_1.fromBase58Check)(address);\n    }\n    catch (e) {\n    }\n    if (decodeBase58) {\n        if (decodeBase58.version === network.pubKeyHash)\n            return "legacy";\n        if (decodeBase58.version === network.scriptHash)\n            return "segwit_nested";\n    }\n    else {\n        try {\n            decodeBech32 = (0, address_1.fromBech32)(address);\n        }\n        catch (e) {\n        }\n        if (decodeBech32) {\n            if (decodeBech32.prefix !== network.bech32)\n                throw new Error(address + \' has an invalid prefix\');\n            if (decodeBech32.version === 0) {\n                return \'segwit_native\';\n            }\n            else if (decodeBech32.version === 1) {\n                return \'segwit_taproot\';\n            }\n        }\n    }\n    return "legacy";\n}\nexports.getAddressType = getAddressType;\nfunction signBch(utxoTx, privateKey, network, hashArray, hardware) {\n    const inputs = utxoTx.inputs;\n    const outputs = utxoTx.outputs;\n    const changeAddress = utxoTx.address;\n    const feePerB = utxoTx.feePerB || 10;\n    const dustSize = utxoTx.dustSize || 546;\n    network = network || bitcoin.networks.bitcoin;\n    let fakePrivateKey = privateKey;\n    if (!fakePrivateKey) {\n        fakePrivateKey = private2Wif(crypto_lib_1.base.fromHex("853fd8960ff34838208d662ecd3b9f8cf413e13e0f74f95e554f8089f5058db0"), network);\n    }\n    let { inputAmount, outputAmount, virtualSize } = calculateBchTxSize(inputs, outputs, changeAddress, fakePrivateKey, network, dustSize);\n    let changeAmount = inputAmount - outputAmount - virtualSize * feePerB;\n    let txBuild = new TxBuild(2, network, true, hardware);\n    for (let i = 0; i < inputs.length; i++) {\n        let input = inputs[i];\n        txBuild.addInput(input.txId, input.vOut, privateKey, changeAddress, undefined, input.amount, input.publicKey, input.sequence);\n    }\n    for (let i = 0; i < outputs.length; i++) {\n        let output = outputs[i];\n        txBuild.addOutput(output.address, output.amount);\n    }\n    if (changeAmount > dustSize) {\n        txBuild.addOutput(changeAddress, changeAmount);\n    }\n    return txBuild.build(hashArray);\n}\nexports.signBch = signBch;\nfunction calculateTxSize(inputs, outputs, changeAddress, privateKey, network, dustSize, hardware, memo, pos) {\n    let preTxBuild = new TxBuild(2, network, false, hardware);\n    let inputAmount = 0;\n    for (let i = 0; i < inputs.length; i++) {\n        let input = inputs[i];\n        const inputPrivKey = input.privateKey || privateKey;\n        const inputAddress = input.address || changeAddress;\n        preTxBuild.addInput(input.txId, input.vOut, inputPrivKey, inputAddress, input.reedScript, input.amount, input.publicKey, input.sequence);\n        inputAmount = inputAmount + (input.amount || 0);\n    }\n    if (memo && pos == 0) {\n        preTxBuild.addOutput(\'\', 0, crypto_lib_1.base.toHex(bscript.compile([ops_1.OPS.OP_RETURN].concat(crypto_lib_1.base.isHexString(memo) ? crypto_lib_1.base.fromHex(memo) : Buffer.from(crypto_lib_1.base.toUtf8(memo))))));\n    }\n    let outputAmount = 0;\n    for (let i = 0; i < outputs.length; i++) {\n        let output = outputs[i];\n        preTxBuild.addOutput(output.address, output.amount, output.omniScript);\n        outputAmount = outputAmount + output.amount;\n        if (memo && pos && preTxBuild.outputs.length == pos) {\n            preTxBuild.addOutput(\'\', 0, crypto_lib_1.base.toHex(bscript.compile([ops_1.OPS.OP_RETURN].concat(crypto_lib_1.base.isHexString(memo) ? crypto_lib_1.base.fromHex(memo) : Buffer.from(crypto_lib_1.base.toUtf8(memo))))));\n        }\n    }\n    if (inputAmount - outputAmount > dustSize) {\n        preTxBuild.addOutput(changeAddress, inputAmount - outputAmount);\n        if (memo && pos && preTxBuild.outputs.length == pos) {\n            preTxBuild.addOutput(\'\', 0, crypto_lib_1.base.toHex(bscript.compile([ops_1.OPS.OP_RETURN].concat(crypto_lib_1.base.isHexString(memo) ? crypto_lib_1.base.fromHex(memo) : Buffer.from(crypto_lib_1.base.toUtf8(memo))))));\n        }\n    }\n    if (memo && (pos == undefined || pos < 0 || pos > preTxBuild.outputs.length)) {\n        preTxBuild.addOutput(\'\', 0, crypto_lib_1.base.toHex(bscript.compile([ops_1.OPS.OP_RETURN].concat(crypto_lib_1.base.isHexString(memo) ? crypto_lib_1.base.fromHex(memo) : Buffer.from(crypto_lib_1.base.toUtf8(memo))))));\n    }\n    let txHex = preTxBuild.build();\n    const virtualSize = preTxBuild.virtualSize();\n    return {\n        inputAmount,\n        outputAmount,\n        virtualSize,\n        txHex\n    };\n}\nexports.calculateTxSize = calculateTxSize;\nfunction calculateBchTxSize(inputs, outputs, changeAddress, privateKey, network, dustSize, hardware) {\n    let preTxBuild = new TxBuild(2, network, true, hardware);\n    let inputAmount = 0;\n    for (let i = 0; i < inputs.length; i++) {\n        let input = inputs[i];\n        preTxBuild.addInput(input.txId, input.vOut, privateKey, changeAddress, undefined, input.amount, input.publicKey, input.sequence);\n        inputAmount = inputAmount + (input.amount || 0);\n    }\n    let outputAmount = 0;\n    for (let i = 0; i < outputs.length; i++) {\n        let output = outputs[i];\n        preTxBuild.addOutput(output.address, output.amount);\n        outputAmount = outputAmount + output.amount;\n    }\n    if (inputAmount - outputAmount > dustSize) {\n        preTxBuild.addOutput(changeAddress, inputAmount - outputAmount);\n    }\n    let txHex = preTxBuild.build();\n    const virtualSize = preTxBuild.tx.virtualSize();\n    return {\n        inputAmount,\n        outputAmount,\n        virtualSize,\n        txHex\n    };\n}\nexports.calculateBchTxSize = calculateBchTxSize;\nfunction getMPCTransaction(raw, sigs, bitcoinCash) {\n    const transaction = bitcoinjs_lib_1.Transaction.fromBuffer(crypto_lib_1.base.fromHex(raw), false);\n    for (let i = 0; i < transaction.ins.length; i++) {\n        const input = transaction.ins[i];\n        const signature = crypto_lib_1.base.fromHex(sigs[i]);\n        let hashType = bitcoin.Transaction.SIGHASH_ALL;\n        if (bitcoinCash) {\n            hashType = bitcoin.Transaction.SIGHASH_ALL | bitcoin.Transaction.SIGHASH_BITCOINCASHBIP143;\n            const payment = bitcoin.payments.p2pkh({\n                input: input.script,\n            });\n            const paymentNew = bitcoin.payments.p2pkh({\n                pubkey: payment.pubkey,\n                signature: bitcoin.script.signature.encode(signature, hashType)\n            });\n            if (paymentNew.input) {\n                input.script = paymentNew.input;\n            }\n        }\n        else {\n            let addressType;\n            if (input.witness.length === 2) {\n                addressType = "segwit_native";\n            }\n            else if (input.witness.length === 1) {\n                addressType = "segwit_taproot";\n            }\n            else if (input.witness.length === 0) {\n                addressType = "legacy";\n            }\n            else {\n                throw Error("unknown witness length");\n            }\n            if (addressType === "legacy") {\n                const payment = bitcoin.payments.p2pkh({\n                    input: input.script,\n                });\n                const paymentNew = bitcoin.payments.p2pkh({\n                    pubkey: payment.pubkey,\n                    signature: bitcoin.script.signature.encode(signature, hashType)\n                });\n                if (paymentNew.input) {\n                    input.script = paymentNew.input;\n                }\n            }\n            else if (addressType === "segwit_taproot") {\n                input.witness = [signature];\n            }\n            else {\n                input.witness[0] = bitcoin.script.signature.encode(signature, hashType);\n            }\n        }\n    }\n    return transaction.toHex();\n}\nexports.getMPCTransaction = getMPCTransaction;\nfunction ValidSignedTransaction(signedTx, utxoInputs, network) {\n    const transaction = bitcoinjs_lib_1.Transaction.fromBuffer(crypto_lib_1.base.fromHex(signedTx), false);\n    if (!utxoInputs) {\n        return transaction;\n    }\n    for (let i = 0; i < transaction.ins.length; i++) {\n        const input = transaction.ins[i];\n        const utxo = utxoInputs[i];\n        let addressType;\n        if (input.witness.length === 2) {\n            addressType = "segwit_native";\n        }\n        else if (input.witness.length === 1) {\n            addressType = "segwit_taproot";\n        }\n        else if (input.witness.length === 0) {\n            addressType = "legacy";\n        }\n        else {\n            throw Error("unknown witness length");\n        }\n        if (addressType === "legacy") {\n            const chunks = bscript.decompile(input.script);\n            const signature = chunks[0];\n            const pubKey = chunks[1];\n            const signatureData = bitcoin.script.signature.decode(signature);\n            const prevOutScript = bitcoin.address.toOutputScript(utxo.address, network);\n            const hash = transaction.hashForSignature(i, prevOutScript, signatureData.hashType);\n            if (!crypto_lib_1.signUtil.secp256k1.verifyWithNoRecovery(hash, signatureData.signature, pubKey)) {\n                throw Error("signature error");\n            }\n        }\n        else if (addressType === "segwit_native") {\n            const signature = input.witness[0];\n            const pubKey = input.witness[1];\n            const signatureData = bitcoin.script.signature.decode(signature);\n            const prevOutScript = Buffer.of(0x19, 0x76, 0xa9, 0x14, ...bcrypto.hash160(pubKey), 0x88, 0xac);\n            const hash = transaction.hashForWitness(i, prevOutScript, utxo.value, signatureData.hashType);\n            if (!crypto_lib_1.signUtil.secp256k1.verifyWithNoRecovery(hash, signatureData.signature, pubKey)) {\n                throw Error("signature error");\n            }\n        }\n        else {\n            const signature = input.witness[0];\n            const prevOutScripts = utxoInputs.map(o => bitcoin.address.toOutputScript(o.address, network));\n            const values = utxoInputs.map(o => o.value);\n            const hash = transaction.hashForWitnessV1(i, prevOutScripts, values, bitcoin.Transaction.SIGHASH_DEFAULT);\n            const tweakedPubKey = taproot.taprootTweakPubkey(crypto_lib_1.base.fromHex(utxo.publicKey).slice(1))[0];\n            if (!schnorr.verify(crypto_lib_1.base.toHex(signature), crypto_lib_1.base.toHex(hash), crypto_lib_1.base.toHex(tweakedPubKey))) {\n                throw Error("signature error");\n            }\n        }\n    }\n    for (let in1 of transaction.ins) {\n        in1.hash = crypto_lib_1.base.reverseBuffer(in1.hash);\n    }\n    return transaction;\n}\nexports.ValidSignedTransaction = ValidSignedTransaction;\nfunction estimateBtcFee(utxoTx, network) {\n    const inputs = utxoTx.inputs;\n    const outputs = utxoTx.outputs;\n    const feePerB = utxoTx.feePerB || 10;\n    const dustSize = utxoTx.dustSize || 546;\n    network = network || bitcoin.networks.bitcoin;\n    const fakePrivateKey = private2Wif(crypto_lib_1.base.fromHex("853fd8960ff34838208d662ecd3b9f8cf413e13e0f74f95e554f8089f5058db0"), network);\n    let { virtualSize } = calculateTxSize(inputs, outputs, utxoTx.address, fakePrivateKey, network, dustSize, false, utxoTx.memo);\n    return virtualSize * feePerB;\n}\nexports.estimateBtcFee = estimateBtcFee;\nfunction estimateBchFee(utxoTx, network) {\n    const inputs = utxoTx.inputs;\n    const outputs = utxoTx.outputs;\n    const feePerB = utxoTx.feePerB || 10;\n    const dustSize = utxoTx.dustSize || 546;\n    network = network || bitcoin.networks.bitcoin;\n    const fakePrivateKey = private2Wif(crypto_lib_1.base.fromHex("853fd8960ff34838208d662ecd3b9f8cf413e13e0f74f95e554f8089f5058db0"), network);\n    let { virtualSize } = calculateBchTxSize(inputs, outputs, utxoTx.address, fakePrivateKey, network, dustSize);\n    return virtualSize * feePerB;\n}\nexports.estimateBchFee = estimateBchFee;\n//# sourceMappingURL=txBuild.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvdHhCdWlsZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsOEJBQThCLEdBQUcseUJBQXlCLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCLEdBQUcsZUFBZSxHQUFHLHNCQUFzQixHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsWUFBWSxHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLGFBQWE7QUFDalgsNkJBQTZCLG1CQUFPLENBQUMsK0ZBQWlCO0FBQ3RELHdCQUF3QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNqRCxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQseUJBQXlCLG1CQUFPLENBQUMscUVBQU87QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMseUdBQXlCO0FBQ25ELDZCQUE2QixtQkFBTyxDQUFDLHVHQUF3QjtBQUM3RCw2QkFBNkIsbUJBQU8sQ0FBQyw2RUFBVztBQUNoRCw2QkFBNkIsbUJBQU8sQ0FBQyx1R0FBd0I7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLGlHQUFxQjtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNyQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxlQUFlO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlDQUF5QztBQUN2RDtBQUNBO0FBQ0EsVUFBVSx5Q0FBeUM7QUFDbkQ7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUNBQXlDO0FBQ25EO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvdHhCdWlsZC5qcz8xNDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVzdGltYXRlQmNoRmVlID0gZXhwb3J0cy5lc3RpbWF0ZUJ0Y0ZlZSA9IGV4cG9ydHMuVmFsaWRTaWduZWRUcmFuc2FjdGlvbiA9IGV4cG9ydHMuZ2V0TVBDVHJhbnNhY3Rpb24gPSBleHBvcnRzLmNhbGN1bGF0ZUJjaFR4U2l6ZSA9IGV4cG9ydHMuY2FsY3VsYXRlVHhTaXplID0gZXhwb3J0cy5zaWduQmNoID0gZXhwb3J0cy5nZXRBZGRyZXNzVHlwZSA9IGV4cG9ydHMuc2lnbkJ0YyA9IGV4cG9ydHMuVHhCdWlsZCA9IGV4cG9ydHMucHJpdmF0ZTJXaWYgPSBleHBvcnRzLndpZjJQdWJsaWMgPSBleHBvcnRzLnNpZ24gPSBleHBvcnRzLnByaXZhdGUycHVibGljID0gZXhwb3J0cy5wcml2YXRlS2V5RnJvbVdJRiA9IGV4cG9ydHMuQXJyYXkgPSB2b2lkIDA7XG5jb25zdCBiaXRjb2luID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWJcIikpO1xuY29uc3QgYml0Y29pbmpzX2xpYl8xID0gcmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYlwiKTtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuY29uc3Qgd2lmID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3dpZlwiKSk7XG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9iaXRjb2luanMtbGliL2FkZHJlc3NcIik7XG5jb25zdCBiY3J5cHRvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWIvY3J5cHRvXCIpKTtcbmNvbnN0IHRhcHJvb3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdGFwcm9vdFwiKSk7XG5jb25zdCBic2NyaXB0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpdGNvaW5qcy1saWIvc2NyaXB0XCIpKTtcbmNvbnN0IG9wc18xID0gcmVxdWlyZShcIi4vYml0Y29pbmpzLWxpYi9vcHNcIik7XG5jb25zdCBzaWdjb3N0XzEgPSByZXF1aXJlKFwiLi9zaWdjb3N0XCIpO1xuY29uc3Qgc2Nobm9yciA9IGNyeXB0b19saWJfMS5zaWduVXRpbC5zY2hub3JyLnNlY3AyNTZrMS5zY2hub3JyO1xuZXhwb3J0cy5BcnJheSA9IGNyeXB0b19saWJfMS50eXBlZm9yY2UuQXJyYXk7XG5mdW5jdGlvbiBwcml2YXRlS2V5RnJvbVdJRih3aWZTdHJpbmcsIG5ldHdvcmspIHtcbiAgICBjb25zdCBkZWNvZGVkID0gd2lmLmRlY29kZSh3aWZTdHJpbmcpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBkZWNvZGVkLnZlcnNpb247XG4gICAgaWYgKCgwLCBleHBvcnRzLkFycmF5KShuZXR3b3JrKSkge1xuICAgICAgICBuZXR3b3JrID0gbmV0d29ya1xuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZlcnNpb24gPT09IHgud2lmO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnBvcCgpO1xuICAgICAgICBpZiAoIW5ldHdvcmspXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbmV0d29yayB2ZXJzaW9uJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuZXR3b3JrID0gbmV0d29yayB8fCBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW47XG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBuZXR3b3JrLndpZilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuZXR3b3JrIHZlcnNpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KGRlY29kZWQucHJpdmF0ZUtleSk7XG59XG5leHBvcnRzLnByaXZhdGVLZXlGcm9tV0lGID0gcHJpdmF0ZUtleUZyb21XSUY7XG5mdW5jdGlvbiBwcml2YXRlMnB1YmxpYyhwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIGNyeXB0b19saWJfMS5zaWduVXRpbC5zZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgocHJpdmF0ZUtleSksIHRydWUpO1xufVxuZXhwb3J0cy5wcml2YXRlMnB1YmxpYyA9IHByaXZhdGUycHVibGljO1xuZnVuY3Rpb24gc2lnbihoYXNoLCBwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IGNyeXB0b19saWJfMS5zaWduVXRpbC5zZWNwMjU2azEuc2lnbihoYXNoLCBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHByaXZhdGVLZXkpKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2lnbmF0dXJlKTtcbn1cbmV4cG9ydHMuc2lnbiA9IHNpZ247XG5mdW5jdGlvbiB3aWYyUHVibGljKHdpZiwgbmV0d29yaykge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBwcml2YXRlS2V5RnJvbVdJRih3aWYsIG5ldHdvcmspO1xuICAgIHJldHVybiBwcml2YXRlMnB1YmxpYyhwcml2YXRlS2V5KTtcbn1cbmV4cG9ydHMud2lmMlB1YmxpYyA9IHdpZjJQdWJsaWM7XG5mdW5jdGlvbiBwcml2YXRlMldpZihwcml2YXRlS2V5LCBuZXR3b3JrKSB7XG4gICAgbmV0d29yayA9IG5ldHdvcmsgfHwgYml0Y29pbi5uZXR3b3Jrcy5iaXRjb2luO1xuICAgIHJldHVybiB3aWYuZW5jb2RlKG5ldHdvcmsud2lmLCBwcml2YXRlS2V5LCB0cnVlKTtcbn1cbmV4cG9ydHMucHJpdmF0ZTJXaWYgPSBwcml2YXRlMldpZjtcbmNsYXNzIFR4QnVpbGQge1xuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24sIG5ldHdvcmssIGJpdGNvaW5DYXNoLCBoYXJkd2FyZSkge1xuICAgICAgICB0aGlzLnR4ID0gbmV3IGJpdGNvaW4uVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrID0gYml0Y29pbi5uZXR3b3Jrcy5iaXRjb2luO1xuICAgICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICAgICAgdGhpcy50eC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHgudmVyc2lvbiA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ldHdvcmspIHtcbiAgICAgICAgICAgIHRoaXMubmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgICAgIHRoaXMuYml0Y29pbkNhc2ggPSBiaXRjb2luQ2FzaCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXJkd2FyZSA9IGhhcmR3YXJlIHx8IGZhbHNlO1xuICAgIH1cbiAgICBhZGRJbnB1dCh0eElkLCBpbmRleCwgcHJpdmF0ZUtleSwgYWRkcmVzcywgc2NyaXB0LCB2YWx1ZSwgcHVibGljS2V5LCBzZXF1ZW5jZSkge1xuICAgICAgICB0aGlzLmlucHV0cy5wdXNoKHtcbiAgICAgICAgICAgIHR4SWQ6IHR4SWQsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIHNjcmlwdDogc2NyaXB0LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXksXG4gICAgICAgICAgICBzZXF1ZW5jZTogc2VxdWVuY2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZE91dHB1dChhZGRyZXNzLCB2YWx1ZSwgb21uaVNjcmlwdCkge1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLCB2YWx1ZTogdmFsdWUsIG9tbmlTY3JpcHQ6IG9tbmlTY3JpcHRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkKGhhc2hBcnJheSkge1xuICAgICAgICBjb25zdCBlY2tleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiB0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGNyeXB0b19saWJfMS5iYXNlLnJldmVyc2VCdWZmZXIoQnVmZmVyLmZyb20oaW5wdXQudHhJZCwgXCJoZXhcIikpO1xuICAgICAgICAgICAgdGhpcy50eC5hZGRJbnB1dChoYXNoLCBpbnB1dC5pbmRleCwgaW5wdXQuc2VxdWVuY2UpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICBlY2tleXMucHVzaChwcml2YXRlS2V5RnJvbVdJRihpbnB1dC5wcml2YXRlS2V5LCB0aGlzLm5ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVja2V5cy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIHRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5vbW5pU2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eC5hZGRPdXRwdXQoY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChvdXRwdXQub21uaVNjcmlwdCksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0U2NyaXB0ID0gYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KG91dHB1dC5hZGRyZXNzLCB0aGlzLm5ldHdvcmspO1xuICAgICAgICAgICAgICAgIHRoaXMudHguYWRkT3V0cHV0KG91dHB1dFNjcmlwdCwgb3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXJkd2FyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHgudG9IZXgoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVja2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWNrZXkgPSBlY2tleXNbaV07XG4gICAgICAgICAgICBsZXQgZWNQdWI7XG4gICAgICAgICAgICBpZiAoZWNrZXkpIHtcbiAgICAgICAgICAgICAgICBlY1B1YiA9IHByaXZhdGUycHVibGljKGVja2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXJkd2FyZSkge1xuICAgICAgICAgICAgICAgICAgICBlY1B1YiA9IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgodGhpcy5pbnB1dHNbaV0ucHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaGFzaDtcbiAgICAgICAgICAgIGxldCBoYXNoVHlwZSA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw7XG4gICAgICAgICAgICBpZiAodGhpcy5iaXRjb2luQ2FzaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGJpdGNvaW4ucGF5bWVudHMucDJwa2goeyBwdWJrZXk6IGVjUHViIH0pLm91dHB1dDtcbiAgICAgICAgICAgICAgICBoYXNoVHlwZSA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwgfCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQklUQ09JTkNBU0hCSVAxNDM7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0c1tpXS52YWx1ZSB8fCAwO1xuICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLnR4Lmhhc2hGb3JDYXNoU2lnbmF0dXJlKGksIHNjcmlwdCwgdmFsdWUsIGhhc2hUeXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgIGlmIChoYXNoQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaEFycmF5LnB1c2goY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgoaGFzaCkpO1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBCdWZmZXIuYWxsb2MoNjQsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gc2lnbihoYXNoLCBlY2tleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBheW1lbnQgPSBiaXRjb2luLnBheW1lbnRzLnAycGtoKHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgICAgIHB1YmtleTogZWNQdWIsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUsIGhhc2hUeXBlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXltZW50LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHguaW5zW2ldLnNjcmlwdCA9IHBheW1lbnQuaW5wdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzc1R5cGUgPSBnZXRBZGRyZXNzVHlwZSh0aGlzLmlucHV0c1tpXS5hZGRyZXNzLCB0aGlzLm5ldHdvcmspO1xuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gXCJsZWdhY3lcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBiaXRjb2luLnBheW1lbnRzLnAycGtoKHsgcHVia2V5OiBlY1B1YiB9KS5vdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLnR4Lmhhc2hGb3JTaWduYXR1cmUoaSwgc2NyaXB0LCBoYXNoVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hBcnJheS5wdXNoKGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KGhhc2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IEJ1ZmZlci5hbGxvYyg2NCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBzaWduKGhhc2gsIGVja2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXltZW50ID0gYml0Y29pbi5wYXltZW50cy5wMnBraCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHNjcmlwdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogZWNQdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGJpdGNvaW4uc2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoc2lnbmF0dXJlLCBoYXNoVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXltZW50LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR4Lmluc1tpXS5zY3JpcHQgPSBwYXltZW50LmlucHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkZHJlc3NUeXBlID09PSBcInNlZ3dpdF90YXByb290XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldk91dFNjcmlwdHMgPSB0aGlzLmlucHV0cy5tYXAobyA9PiBiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQoby5hZGRyZXNzLCB0aGlzLm5ldHdvcmspKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5pbnB1dHMubWFwKG8gPT4gby52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSB0aGlzLnR4Lmhhc2hGb3JXaXRuZXNzVjEoaSwgcHJldk91dFNjcmlwdHMsIHZhbHVlcywgYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoQXJyYXkucHVzaChjcnlwdG9fbGliXzEuYmFzZS50b0hleChoYXNoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBCdWZmZXIuYWxsb2MoNjQsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHdlYWtlZFByaXZLZXkgPSB0YXByb290LnRhcHJvb3RUd2Vha1ByaXZLZXkoY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChlY2tleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2Nobm9yci5zaWduKGhhc2gsIHR3ZWFrZWRQcml2S2V5LCBjcnlwdG9fbGliXzEuYmFzZS5yYW5kb21CeXRlcygzMikpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR4Lmluc1tpXS53aXRuZXNzID0gW0J1ZmZlci5mcm9tKHNpZ25hdHVyZSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHViSGFzaCA9IGJjcnlwdG8uaGFzaDE2MChlY1B1Yik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZPdXRTY3JpcHQgPSBCdWZmZXIub2YoMHgxOSwgMHg3NiwgMHhhOSwgMHgxNCwgLi4ucHViSGFzaCwgMHg4OCwgMHhhYyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnB1dHNbaV0udmFsdWUgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMudHguaGFzaEZvcldpdG5lc3MoaSwgcHJldk91dFNjcmlwdCwgdmFsdWUsIGhhc2hUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2hBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaEFycmF5LnB1c2goY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgoaGFzaCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gQnVmZmVyLmFsbG9jKDY0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IHNpZ24oaGFzaCwgZWNrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHguaW5zW2ldLndpdG5lc3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eC5pbnNbaV0ud2l0bmVzcy5wdXNoKGJpdGNvaW4uc2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoc2lnbmF0dXJlLCBoYXNoVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR4Lmluc1tpXS53aXRuZXNzLnB1c2goZWNQdWIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWRlZW1TY3JpcHQgPSBCdWZmZXIub2YoMHgxNiwgMCwgMjAsIC4uLnB1Ykhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc1R5cGUgIT09IFwic2Vnd2l0X25hdGl2ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR4Lmluc1tpXS5zY3JpcHQgPSByZWRlZW1TY3JpcHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHgudG9IZXgoKTtcbiAgICB9XG4gICAgdmlydHVhbFNpemUoKSB7XG4gICAgICAgIHJldHVybiAoMCwgc2lnY29zdF8xLmNvdW50QWRqdXN0ZWRWc2l6ZSkodGhpcy50eCwgdGhpcy5pbnB1dHMubWFwKGEgPT4gYS5hZGRyZXNzKSwgdGhpcy5uZXR3b3JrIHx8IGJpdGNvaW4ubmV0d29ya3MuYml0Y29pbik7XG4gICAgfVxufVxuZXhwb3J0cy5UeEJ1aWxkID0gVHhCdWlsZDtcbmZ1bmN0aW9uIHNpZ25CdGModXR4b1R4LCBwcml2YXRlS2V5LCBuZXR3b3JrLCBoYXNoQXJyYXksIGhhcmR3YXJlLCBjaGFuZ2VPbmx5KSB7XG4gICAgY29uc3QgaW5wdXRzID0gdXR4b1R4LmlucHV0cztcbiAgICBjb25zdCBvdXRwdXRzID0gdXR4b1R4Lm91dHB1dHM7XG4gICAgY29uc3QgY2hhbmdlQWRkcmVzcyA9IHV0eG9UeC5hZGRyZXNzO1xuICAgIGNvbnN0IGZlZVBlckIgPSB1dHhvVHguZmVlUGVyQiB8fCAxMDtcbiAgICBjb25zdCBkdXN0U2l6ZSA9IHV0eG9UeC5kdXN0U2l6ZSB8fCA1NDY7XG4gICAgbmV0d29yayA9IG5ldHdvcmsgfHwgYml0Y29pbi5uZXR3b3Jrcy5iaXRjb2luO1xuICAgIGlmICh1dHhvVHgubWVtbykge1xuICAgICAgICBsZXQgYnVmID0gY3J5cHRvX2xpYl8xLmJhc2UuaXNIZXhTdHJpbmcodXR4b1R4Lm1lbW8pID8gY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleCh1dHhvVHgubWVtbykgOiBCdWZmZXIuZnJvbShjcnlwdG9fbGliXzEuYmFzZS50b1V0ZjgodXR4b1R4Lm1lbW8pKTtcbiAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPiA4MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIGFmdGVyIG9wX3JldHVybiBpcyAgdG9vIGxvbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZmFrZVByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgIGlmICghZmFrZVByaXZhdGVLZXkpIHtcbiAgICAgICAgZmFrZVByaXZhdGVLZXkgPSBwcml2YXRlMldpZihjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KFwiODUzZmQ4OTYwZmYzNDgzODIwOGQ2NjJlY2QzYjlmOGNmNDEzZTEzZTBmNzRmOTVlNTU0ZjgwODlmNTA1OGRiMFwiKSwgbmV0d29yayk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VPbmx5KSB7XG4gICAgICAgIGxldCB7IGlucHV0QW1vdW50LCBvdXRwdXRBbW91bnQsIHZpcnR1YWxTaXplIH0gPSBjYWxjdWxhdGVUeFNpemUoaW5wdXRzLCBvdXRwdXRzLCBjaGFuZ2VBZGRyZXNzLCBmYWtlUHJpdmF0ZUtleSwgbmV0d29yaywgZHVzdFNpemUsIGZhbHNlLCB1dHhvVHgubWVtbywgdXR4b1R4Lm1lbW9Qb3MpO1xuICAgICAgICByZXR1cm4gKGlucHV0QW1vdW50IC0gb3V0cHV0QW1vdW50IC0gdmlydHVhbFNpemUgKiBmZWVQZXJCKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBsZXQgeyBpbnB1dEFtb3VudCwgb3V0cHV0QW1vdW50LCB2aXJ0dWFsU2l6ZSB9ID0gY2FsY3VsYXRlVHhTaXplKGlucHV0cywgb3V0cHV0cywgY2hhbmdlQWRkcmVzcywgZmFrZVByaXZhdGVLZXksIG5ldHdvcmssIGR1c3RTaXplLCBmYWxzZSwgdXR4b1R4Lm1lbW8sIHV0eG9UeC5tZW1vUG9zKTtcbiAgICBsZXQgY2hhbmdlQW1vdW50ID0gaW5wdXRBbW91bnQgLSBvdXRwdXRBbW91bnQgLSB2aXJ0dWFsU2l6ZSAqIGZlZVBlckI7XG4gICAgbGV0IHR4QnVpbGQgPSBuZXcgVHhCdWlsZCgyLCBuZXR3b3JrLCBmYWxzZSwgaGFyZHdhcmUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpbnB1dCA9IGlucHV0c1tpXTtcbiAgICAgICAgY29uc3QgaW5wdXRQcml2S2V5ID0gaW5wdXQucHJpdmF0ZUtleSB8fCBwcml2YXRlS2V5O1xuICAgICAgICBjb25zdCBpbnB1dEFkZHJlc3MgPSBpbnB1dC5hZGRyZXNzIHx8IGNoYW5nZUFkZHJlc3M7XG4gICAgICAgIHR4QnVpbGQuYWRkSW5wdXQoaW5wdXQudHhJZCwgaW5wdXQudk91dCwgaW5wdXRQcml2S2V5LCBpbnB1dEFkZHJlc3MsIGlucHV0LnJlZWRTY3JpcHQsIGlucHV0LmFtb3VudCwgaW5wdXQucHVibGljS2V5LCBpbnB1dC5zZXF1ZW5jZSk7XG4gICAgfVxuICAgIGlmICh1dHhvVHgubWVtbyAmJiB1dHhvVHgubWVtb1BvcyA9PSAwKSB7XG4gICAgICAgIHR4QnVpbGQuYWRkT3V0cHV0KCcnLCAwLCBjcnlwdG9fbGliXzEuYmFzZS50b0hleChic2NyaXB0LmNvbXBpbGUoW29wc18xLk9QUy5PUF9SRVRVUk5dLmNvbmNhdChjcnlwdG9fbGliXzEuYmFzZS5pc0hleFN0cmluZyh1dHhvVHgubWVtbykgPyBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHV0eG9UeC5tZW1vKSA6IEJ1ZmZlci5mcm9tKGNyeXB0b19saWJfMS5iYXNlLnRvVXRmOCh1dHhvVHgubWVtbykpKSkpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICB0eEJ1aWxkLmFkZE91dHB1dChvdXRwdXQuYWRkcmVzcywgb3V0cHV0LmFtb3VudCwgb3V0cHV0Lm9tbmlTY3JpcHQpO1xuICAgICAgICBpZiAodXR4b1R4Lm1lbW8gJiYgdXR4b1R4Lm1lbW9Qb3MgJiYgdHhCdWlsZC5vdXRwdXRzLmxlbmd0aCA9PSB1dHhvVHgubWVtb1Bvcykge1xuICAgICAgICAgICAgdHhCdWlsZC5hZGRPdXRwdXQoJycsIDAsIGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KGJzY3JpcHQuY29tcGlsZShbb3BzXzEuT1BTLk9QX1JFVFVSTl0uY29uY2F0KGNyeXB0b19saWJfMS5iYXNlLmlzSGV4U3RyaW5nKHV0eG9UeC5tZW1vKSA/IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgodXR4b1R4Lm1lbW8pIDogQnVmZmVyLmZyb20oY3J5cHRvX2xpYl8xLmJhc2UudG9VdGY4KHV0eG9UeC5tZW1vKSkpKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2VBbW91bnQgPiBkdXN0U2l6ZSkge1xuICAgICAgICB0eEJ1aWxkLmFkZE91dHB1dChjaGFuZ2VBZGRyZXNzLCBjaGFuZ2VBbW91bnQpO1xuICAgICAgICBpZiAodXR4b1R4Lm1lbW8gJiYgdXR4b1R4Lm1lbW9Qb3MgJiYgdHhCdWlsZC5vdXRwdXRzLmxlbmd0aCA9PSB1dHhvVHgubWVtb1Bvcykge1xuICAgICAgICAgICAgdHhCdWlsZC5hZGRPdXRwdXQoJycsIDAsIGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KGJzY3JpcHQuY29tcGlsZShbb3BzXzEuT1BTLk9QX1JFVFVSTl0uY29uY2F0KGNyeXB0b19saWJfMS5iYXNlLmlzSGV4U3RyaW5nKHV0eG9UeC5tZW1vKSA/IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgodXR4b1R4Lm1lbW8pIDogQnVmZmVyLmZyb20oY3J5cHRvX2xpYl8xLmJhc2UudG9VdGY4KHV0eG9UeC5tZW1vKSkpKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh1dHhvVHgubWVtbyAmJiAodXR4b1R4Lm1lbW9Qb3MgPT0gdW5kZWZpbmVkIHx8IHV0eG9UeC5tZW1vUG9zIDwgMCB8fCB1dHhvVHgubWVtb1BvcyA+IHR4QnVpbGQub3V0cHV0cy5sZW5ndGgpKSB7XG4gICAgICAgIHR4QnVpbGQuYWRkT3V0cHV0KCcnLCAwLCBjcnlwdG9fbGliXzEuYmFzZS50b0hleChic2NyaXB0LmNvbXBpbGUoW29wc18xLk9QUy5PUF9SRVRVUk5dLmNvbmNhdChjcnlwdG9fbGliXzEuYmFzZS5pc0hleFN0cmluZyh1dHhvVHgubWVtbykgPyBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHV0eG9UeC5tZW1vKSA6IEJ1ZmZlci5mcm9tKGNyeXB0b19saWJfMS5iYXNlLnRvVXRmOCh1dHhvVHgubWVtbykpKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4QnVpbGQuYnVpbGQoaGFzaEFycmF5KTtcbn1cbmV4cG9ydHMuc2lnbkJ0YyA9IHNpZ25CdGM7XG5mdW5jdGlvbiBnZXRBZGRyZXNzVHlwZShhZGRyZXNzLCBuZXR3b3JrKSB7XG4gICAgbGV0IGRlY29kZUJhc2U1ODtcbiAgICBsZXQgZGVjb2RlQmVjaDMyO1xuICAgIHRyeSB7XG4gICAgICAgIGRlY29kZUJhc2U1OCA9ICgwLCBhZGRyZXNzXzEuZnJvbUJhc2U1OENoZWNrKShhZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgaWYgKGRlY29kZUJhc2U1OCkge1xuICAgICAgICBpZiAoZGVjb2RlQmFzZTU4LnZlcnNpb24gPT09IG5ldHdvcmsucHViS2V5SGFzaClcbiAgICAgICAgICAgIHJldHVybiBcImxlZ2FjeVwiO1xuICAgICAgICBpZiAoZGVjb2RlQmFzZTU4LnZlcnNpb24gPT09IG5ldHdvcmsuc2NyaXB0SGFzaClcbiAgICAgICAgICAgIHJldHVybiBcInNlZ3dpdF9uZXN0ZWRcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNvZGVCZWNoMzIgPSAoMCwgYWRkcmVzc18xLmZyb21CZWNoMzIpKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY29kZUJlY2gzMikge1xuICAgICAgICAgICAgaWYgKGRlY29kZUJlY2gzMi5wcmVmaXggIT09IG5ldHdvcmsuYmVjaDMyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhZGRyZXNzICsgJyBoYXMgYW4gaW52YWxpZCBwcmVmaXgnKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVCZWNoMzIudmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc2Vnd2l0X25hdGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWNvZGVCZWNoMzIudmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc2Vnd2l0X3RhcHJvb3QnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcImxlZ2FjeVwiO1xufVxuZXhwb3J0cy5nZXRBZGRyZXNzVHlwZSA9IGdldEFkZHJlc3NUeXBlO1xuZnVuY3Rpb24gc2lnbkJjaCh1dHhvVHgsIHByaXZhdGVLZXksIG5ldHdvcmssIGhhc2hBcnJheSwgaGFyZHdhcmUpIHtcbiAgICBjb25zdCBpbnB1dHMgPSB1dHhvVHguaW5wdXRzO1xuICAgIGNvbnN0IG91dHB1dHMgPSB1dHhvVHgub3V0cHV0cztcbiAgICBjb25zdCBjaGFuZ2VBZGRyZXNzID0gdXR4b1R4LmFkZHJlc3M7XG4gICAgY29uc3QgZmVlUGVyQiA9IHV0eG9UeC5mZWVQZXJCIHx8IDEwO1xuICAgIGNvbnN0IGR1c3RTaXplID0gdXR4b1R4LmR1c3RTaXplIHx8IDU0NjtcbiAgICBuZXR3b3JrID0gbmV0d29yayB8fCBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW47XG4gICAgbGV0IGZha2VQcml2YXRlS2V5ID0gcHJpdmF0ZUtleTtcbiAgICBpZiAoIWZha2VQcml2YXRlS2V5KSB7XG4gICAgICAgIGZha2VQcml2YXRlS2V5ID0gcHJpdmF0ZTJXaWYoY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChcIjg1M2ZkODk2MGZmMzQ4MzgyMDhkNjYyZWNkM2I5ZjhjZjQxM2UxM2UwZjc0Zjk1ZTU1NGY4MDg5ZjUwNThkYjBcIiksIG5ldHdvcmspO1xuICAgIH1cbiAgICBsZXQgeyBpbnB1dEFtb3VudCwgb3V0cHV0QW1vdW50LCB2aXJ0dWFsU2l6ZSB9ID0gY2FsY3VsYXRlQmNoVHhTaXplKGlucHV0cywgb3V0cHV0cywgY2hhbmdlQWRkcmVzcywgZmFrZVByaXZhdGVLZXksIG5ldHdvcmssIGR1c3RTaXplKTtcbiAgICBsZXQgY2hhbmdlQW1vdW50ID0gaW5wdXRBbW91bnQgLSBvdXRwdXRBbW91bnQgLSB2aXJ0dWFsU2l6ZSAqIGZlZVBlckI7XG4gICAgbGV0IHR4QnVpbGQgPSBuZXcgVHhCdWlsZCgyLCBuZXR3b3JrLCB0cnVlLCBoYXJkd2FyZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0ID0gaW5wdXRzW2ldO1xuICAgICAgICB0eEJ1aWxkLmFkZElucHV0KGlucHV0LnR4SWQsIGlucHV0LnZPdXQsIHByaXZhdGVLZXksIGNoYW5nZUFkZHJlc3MsIHVuZGVmaW5lZCwgaW5wdXQuYW1vdW50LCBpbnB1dC5wdWJsaWNLZXksIGlucHV0LnNlcXVlbmNlKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICB0eEJ1aWxkLmFkZE91dHB1dChvdXRwdXQuYWRkcmVzcywgb3V0cHV0LmFtb3VudCk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VBbW91bnQgPiBkdXN0U2l6ZSkge1xuICAgICAgICB0eEJ1aWxkLmFkZE91dHB1dChjaGFuZ2VBZGRyZXNzLCBjaGFuZ2VBbW91bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdHhCdWlsZC5idWlsZChoYXNoQXJyYXkpO1xufVxuZXhwb3J0cy5zaWduQmNoID0gc2lnbkJjaDtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVR4U2l6ZShpbnB1dHMsIG91dHB1dHMsIGNoYW5nZUFkZHJlc3MsIHByaXZhdGVLZXksIG5ldHdvcmssIGR1c3RTaXplLCBoYXJkd2FyZSwgbWVtbywgcG9zKSB7XG4gICAgbGV0IHByZVR4QnVpbGQgPSBuZXcgVHhCdWlsZCgyLCBuZXR3b3JrLCBmYWxzZSwgaGFyZHdhcmUpO1xuICAgIGxldCBpbnB1dEFtb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0ID0gaW5wdXRzW2ldO1xuICAgICAgICBjb25zdCBpbnB1dFByaXZLZXkgPSBpbnB1dC5wcml2YXRlS2V5IHx8IHByaXZhdGVLZXk7XG4gICAgICAgIGNvbnN0IGlucHV0QWRkcmVzcyA9IGlucHV0LmFkZHJlc3MgfHwgY2hhbmdlQWRkcmVzcztcbiAgICAgICAgcHJlVHhCdWlsZC5hZGRJbnB1dChpbnB1dC50eElkLCBpbnB1dC52T3V0LCBpbnB1dFByaXZLZXksIGlucHV0QWRkcmVzcywgaW5wdXQucmVlZFNjcmlwdCwgaW5wdXQuYW1vdW50LCBpbnB1dC5wdWJsaWNLZXksIGlucHV0LnNlcXVlbmNlKTtcbiAgICAgICAgaW5wdXRBbW91bnQgPSBpbnB1dEFtb3VudCArIChpbnB1dC5hbW91bnQgfHwgMCk7XG4gICAgfVxuICAgIGlmIChtZW1vICYmIHBvcyA9PSAwKSB7XG4gICAgICAgIHByZVR4QnVpbGQuYWRkT3V0cHV0KCcnLCAwLCBjcnlwdG9fbGliXzEuYmFzZS50b0hleChic2NyaXB0LmNvbXBpbGUoW29wc18xLk9QUy5PUF9SRVRVUk5dLmNvbmNhdChjcnlwdG9fbGliXzEuYmFzZS5pc0hleFN0cmluZyhtZW1vKSA/IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgobWVtbykgOiBCdWZmZXIuZnJvbShjcnlwdG9fbGliXzEuYmFzZS50b1V0ZjgobWVtbykpKSkpKTtcbiAgICB9XG4gICAgbGV0IG91dHB1dEFtb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICBwcmVUeEJ1aWxkLmFkZE91dHB1dChvdXRwdXQuYWRkcmVzcywgb3V0cHV0LmFtb3VudCwgb3V0cHV0Lm9tbmlTY3JpcHQpO1xuICAgICAgICBvdXRwdXRBbW91bnQgPSBvdXRwdXRBbW91bnQgKyBvdXRwdXQuYW1vdW50O1xuICAgICAgICBpZiAobWVtbyAmJiBwb3MgJiYgcHJlVHhCdWlsZC5vdXRwdXRzLmxlbmd0aCA9PSBwb3MpIHtcbiAgICAgICAgICAgIHByZVR4QnVpbGQuYWRkT3V0cHV0KCcnLCAwLCBjcnlwdG9fbGliXzEuYmFzZS50b0hleChic2NyaXB0LmNvbXBpbGUoW29wc18xLk9QUy5PUF9SRVRVUk5dLmNvbmNhdChjcnlwdG9fbGliXzEuYmFzZS5pc0hleFN0cmluZyhtZW1vKSA/IGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgobWVtbykgOiBCdWZmZXIuZnJvbShjcnlwdG9fbGliXzEuYmFzZS50b1V0ZjgobWVtbykpKSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5wdXRBbW91bnQgLSBvdXRwdXRBbW91bnQgPiBkdXN0U2l6ZSkge1xuICAgICAgICBwcmVUeEJ1aWxkLmFkZE91dHB1dChjaGFuZ2VBZGRyZXNzLCBpbnB1dEFtb3VudCAtIG91dHB1dEFtb3VudCk7XG4gICAgICAgIGlmIChtZW1vICYmIHBvcyAmJiBwcmVUeEJ1aWxkLm91dHB1dHMubGVuZ3RoID09IHBvcykge1xuICAgICAgICAgICAgcHJlVHhCdWlsZC5hZGRPdXRwdXQoJycsIDAsIGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KGJzY3JpcHQuY29tcGlsZShbb3BzXzEuT1BTLk9QX1JFVFVSTl0uY29uY2F0KGNyeXB0b19saWJfMS5iYXNlLmlzSGV4U3RyaW5nKG1lbW8pID8gY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChtZW1vKSA6IEJ1ZmZlci5mcm9tKGNyeXB0b19saWJfMS5iYXNlLnRvVXRmOChtZW1vKSkpKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtZW1vICYmIChwb3MgPT0gdW5kZWZpbmVkIHx8IHBvcyA8IDAgfHwgcG9zID4gcHJlVHhCdWlsZC5vdXRwdXRzLmxlbmd0aCkpIHtcbiAgICAgICAgcHJlVHhCdWlsZC5hZGRPdXRwdXQoJycsIDAsIGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KGJzY3JpcHQuY29tcGlsZShbb3BzXzEuT1BTLk9QX1JFVFVSTl0uY29uY2F0KGNyeXB0b19saWJfMS5iYXNlLmlzSGV4U3RyaW5nKG1lbW8pID8gY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChtZW1vKSA6IEJ1ZmZlci5mcm9tKGNyeXB0b19saWJfMS5iYXNlLnRvVXRmOChtZW1vKSkpKSkpO1xuICAgIH1cbiAgICBsZXQgdHhIZXggPSBwcmVUeEJ1aWxkLmJ1aWxkKCk7XG4gICAgY29uc3QgdmlydHVhbFNpemUgPSBwcmVUeEJ1aWxkLnZpcnR1YWxTaXplKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXRBbW91bnQsXG4gICAgICAgIG91dHB1dEFtb3VudCxcbiAgICAgICAgdmlydHVhbFNpemUsXG4gICAgICAgIHR4SGV4XG4gICAgfTtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlVHhTaXplID0gY2FsY3VsYXRlVHhTaXplO1xuZnVuY3Rpb24gY2FsY3VsYXRlQmNoVHhTaXplKGlucHV0cywgb3V0cHV0cywgY2hhbmdlQWRkcmVzcywgcHJpdmF0ZUtleSwgbmV0d29yaywgZHVzdFNpemUsIGhhcmR3YXJlKSB7XG4gICAgbGV0IHByZVR4QnVpbGQgPSBuZXcgVHhCdWlsZCgyLCBuZXR3b3JrLCB0cnVlLCBoYXJkd2FyZSk7XG4gICAgbGV0IGlucHV0QW1vdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaW5wdXQgPSBpbnB1dHNbaV07XG4gICAgICAgIHByZVR4QnVpbGQuYWRkSW5wdXQoaW5wdXQudHhJZCwgaW5wdXQudk91dCwgcHJpdmF0ZUtleSwgY2hhbmdlQWRkcmVzcywgdW5kZWZpbmVkLCBpbnB1dC5hbW91bnQsIGlucHV0LnB1YmxpY0tleSwgaW5wdXQuc2VxdWVuY2UpO1xuICAgICAgICBpbnB1dEFtb3VudCA9IGlucHV0QW1vdW50ICsgKGlucHV0LmFtb3VudCB8fCAwKTtcbiAgICB9XG4gICAgbGV0IG91dHB1dEFtb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICBwcmVUeEJ1aWxkLmFkZE91dHB1dChvdXRwdXQuYWRkcmVzcywgb3V0cHV0LmFtb3VudCk7XG4gICAgICAgIG91dHB1dEFtb3VudCA9IG91dHB1dEFtb3VudCArIG91dHB1dC5hbW91bnQ7XG4gICAgfVxuICAgIGlmIChpbnB1dEFtb3VudCAtIG91dHB1dEFtb3VudCA+IGR1c3RTaXplKSB7XG4gICAgICAgIHByZVR4QnVpbGQuYWRkT3V0cHV0KGNoYW5nZUFkZHJlc3MsIGlucHV0QW1vdW50IC0gb3V0cHV0QW1vdW50KTtcbiAgICB9XG4gICAgbGV0IHR4SGV4ID0gcHJlVHhCdWlsZC5idWlsZCgpO1xuICAgIGNvbnN0IHZpcnR1YWxTaXplID0gcHJlVHhCdWlsZC50eC52aXJ0dWFsU2l6ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0QW1vdW50LFxuICAgICAgICBvdXRwdXRBbW91bnQsXG4gICAgICAgIHZpcnR1YWxTaXplLFxuICAgICAgICB0eEhleFxuICAgIH07XG59XG5leHBvcnRzLmNhbGN1bGF0ZUJjaFR4U2l6ZSA9IGNhbGN1bGF0ZUJjaFR4U2l6ZTtcbmZ1bmN0aW9uIGdldE1QQ1RyYW5zYWN0aW9uKHJhdywgc2lncywgYml0Y29pbkNhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGJpdGNvaW5qc19saWJfMS5UcmFuc2FjdGlvbi5mcm9tQnVmZmVyKGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgocmF3KSwgZmFsc2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdHJhbnNhY3Rpb24uaW5zW2ldO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHNpZ3NbaV0pO1xuICAgICAgICBsZXQgaGFzaFR5cGUgPSBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMO1xuICAgICAgICBpZiAoYml0Y29pbkNhc2gpIHtcbiAgICAgICAgICAgIGhhc2hUeXBlID0gYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCB8IGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9CSVRDT0lOQ0FTSEJJUDE0MztcbiAgICAgICAgICAgIGNvbnN0IHBheW1lbnQgPSBiaXRjb2luLnBheW1lbnRzLnAycGtoKHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXQuc2NyaXB0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwYXltZW50TmV3ID0gYml0Y29pbi5wYXltZW50cy5wMnBraCh7XG4gICAgICAgICAgICAgICAgcHVia2V5OiBwYXltZW50LnB1YmtleSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGJpdGNvaW4uc2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoc2lnbmF0dXJlLCBoYXNoVHlwZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHBheW1lbnROZXcuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5zY3JpcHQgPSBwYXltZW50TmV3LmlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFkZHJlc3NUeXBlO1xuICAgICAgICAgICAgaWYgKGlucHV0LndpdG5lc3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1R5cGUgPSBcInNlZ3dpdF9uYXRpdmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0LndpdG5lc3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1R5cGUgPSBcInNlZ3dpdF90YXByb290XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dC53aXRuZXNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3NUeXBlID0gXCJsZWdhY3lcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW5rbm93biB3aXRuZXNzIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gXCJsZWdhY3lcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheW1lbnQgPSBiaXRjb2luLnBheW1lbnRzLnAycGtoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0LnNjcmlwdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXltZW50TmV3ID0gYml0Y29pbi5wYXltZW50cy5wMnBraCh7XG4gICAgICAgICAgICAgICAgICAgIHB1YmtleTogcGF5bWVudC5wdWJrZXksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUsIGhhc2hUeXBlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXltZW50TmV3LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnNjcmlwdCA9IHBheW1lbnROZXcuaW5wdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWRkcmVzc1R5cGUgPT09IFwic2Vnd2l0X3RhcHJvb3RcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LndpdG5lc3MgPSBbc2lnbmF0dXJlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0LndpdG5lc3NbMF0gPSBiaXRjb2luLnNjcmlwdC5zaWduYXR1cmUuZW5jb2RlKHNpZ25hdHVyZSwgaGFzaFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvbi50b0hleCgpO1xufVxuZXhwb3J0cy5nZXRNUENUcmFuc2FjdGlvbiA9IGdldE1QQ1RyYW5zYWN0aW9uO1xuZnVuY3Rpb24gVmFsaWRTaWduZWRUcmFuc2FjdGlvbihzaWduZWRUeCwgdXR4b0lucHV0cywgbmV0d29yaykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLmZyb21CdWZmZXIoY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChzaWduZWRUeCksIGZhbHNlKTtcbiAgICBpZiAoIXV0eG9JbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zYWN0aW9uLmlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRyYW5zYWN0aW9uLmluc1tpXTtcbiAgICAgICAgY29uc3QgdXR4byA9IHV0eG9JbnB1dHNbaV07XG4gICAgICAgIGxldCBhZGRyZXNzVHlwZTtcbiAgICAgICAgaWYgKGlucHV0LndpdG5lc3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBhZGRyZXNzVHlwZSA9IFwic2Vnd2l0X25hdGl2ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LndpdG5lc3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBhZGRyZXNzVHlwZSA9IFwic2Vnd2l0X3RhcHJvb3RcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC53aXRuZXNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYWRkcmVzc1R5cGUgPSBcImxlZ2FjeVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bmtub3duIHdpdG5lc3MgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gXCJsZWdhY3lcIikge1xuICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUoaW5wdXQuc2NyaXB0KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGNodW5rc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IGNodW5rc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZURhdGEgPSBiaXRjb2luLnNjcmlwdC5zaWduYXR1cmUuZGVjb2RlKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2T3V0U2NyaXB0ID0gYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KHV0eG8uYWRkcmVzcywgbmV0d29yayk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gdHJhbnNhY3Rpb24uaGFzaEZvclNpZ25hdHVyZShpLCBwcmV2T3V0U2NyaXB0LCBzaWduYXR1cmVEYXRhLmhhc2hUeXBlKTtcbiAgICAgICAgICAgIGlmICghY3J5cHRvX2xpYl8xLnNpZ25VdGlsLnNlY3AyNTZrMS52ZXJpZnlXaXRoTm9SZWNvdmVyeShoYXNoLCBzaWduYXR1cmVEYXRhLnNpZ25hdHVyZSwgcHViS2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwic2lnbmF0dXJlIGVycm9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFkZHJlc3NUeXBlID09PSBcInNlZ3dpdF9uYXRpdmVcIikge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gaW5wdXQud2l0bmVzc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IGlucHV0LndpdG5lc3NbMV07XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmVEYXRhID0gYml0Y29pbi5zY3JpcHQuc2lnbmF0dXJlLmRlY29kZShzaWduYXR1cmUpO1xuICAgICAgICAgICAgY29uc3QgcHJldk91dFNjcmlwdCA9IEJ1ZmZlci5vZigweDE5LCAweDc2LCAweGE5LCAweDE0LCAuLi5iY3J5cHRvLmhhc2gxNjAocHViS2V5KSwgMHg4OCwgMHhhYyk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gdHJhbnNhY3Rpb24uaGFzaEZvcldpdG5lc3MoaSwgcHJldk91dFNjcmlwdCwgdXR4by52YWx1ZSwgc2lnbmF0dXJlRGF0YS5oYXNoVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWNyeXB0b19saWJfMS5zaWduVXRpbC5zZWNwMjU2azEudmVyaWZ5V2l0aE5vUmVjb3ZlcnkoaGFzaCwgc2lnbmF0dXJlRGF0YS5zaWduYXR1cmUsIHB1YktleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInNpZ25hdHVyZSBlcnJvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGlucHV0LndpdG5lc3NbMF07XG4gICAgICAgICAgICBjb25zdCBwcmV2T3V0U2NyaXB0cyA9IHV0eG9JbnB1dHMubWFwKG8gPT4gYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KG8uYWRkcmVzcywgbmV0d29yaykpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdXR4b0lucHV0cy5tYXAobyA9PiBvLnZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB0cmFuc2FjdGlvbi5oYXNoRm9yV2l0bmVzc1YxKGksIHByZXZPdXRTY3JpcHRzLCB2YWx1ZXMsIGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUKTtcbiAgICAgICAgICAgIGNvbnN0IHR3ZWFrZWRQdWJLZXkgPSB0YXByb290LnRhcHJvb3RUd2Vha1B1YmtleShjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHV0eG8ucHVibGljS2V5KS5zbGljZSgxKSlbMF07XG4gICAgICAgICAgICBpZiAoIXNjaG5vcnIudmVyaWZ5KGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KHNpZ25hdHVyZSksIGNyeXB0b19saWJfMS5iYXNlLnRvSGV4KGhhc2gpLCBjcnlwdG9fbGliXzEuYmFzZS50b0hleCh0d2Vha2VkUHViS2V5KSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInNpZ25hdHVyZSBlcnJvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpbjEgb2YgdHJhbnNhY3Rpb24uaW5zKSB7XG4gICAgICAgIGluMS5oYXNoID0gY3J5cHRvX2xpYl8xLmJhc2UucmV2ZXJzZUJ1ZmZlcihpbjEuaGFzaCk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbmV4cG9ydHMuVmFsaWRTaWduZWRUcmFuc2FjdGlvbiA9IFZhbGlkU2lnbmVkVHJhbnNhY3Rpb247XG5mdW5jdGlvbiBlc3RpbWF0ZUJ0Y0ZlZSh1dHhvVHgsIG5ldHdvcmspIHtcbiAgICBjb25zdCBpbnB1dHMgPSB1dHhvVHguaW5wdXRzO1xuICAgIGNvbnN0IG91dHB1dHMgPSB1dHhvVHgub3V0cHV0cztcbiAgICBjb25zdCBmZWVQZXJCID0gdXR4b1R4LmZlZVBlckIgfHwgMTA7XG4gICAgY29uc3QgZHVzdFNpemUgPSB1dHhvVHguZHVzdFNpemUgfHwgNTQ2O1xuICAgIG5ldHdvcmsgPSBuZXR3b3JrIHx8IGJpdGNvaW4ubmV0d29ya3MuYml0Y29pbjtcbiAgICBjb25zdCBmYWtlUHJpdmF0ZUtleSA9IHByaXZhdGUyV2lmKGNyeXB0b19saWJfMS5iYXNlLmZyb21IZXgoXCI4NTNmZDg5NjBmZjM0ODM4MjA4ZDY2MmVjZDNiOWY4Y2Y0MTNlMTNlMGY3NGY5NWU1NTRmODA4OWY1MDU4ZGIwXCIpLCBuZXR3b3JrKTtcbiAgICBsZXQgeyB2aXJ0dWFsU2l6ZSB9ID0gY2FsY3VsYXRlVHhTaXplKGlucHV0cywgb3V0cHV0cywgdXR4b1R4LmFkZHJlc3MsIGZha2VQcml2YXRlS2V5LCBuZXR3b3JrLCBkdXN0U2l6ZSwgZmFsc2UsIHV0eG9UeC5tZW1vKTtcbiAgICByZXR1cm4gdmlydHVhbFNpemUgKiBmZWVQZXJCO1xufVxuZXhwb3J0cy5lc3RpbWF0ZUJ0Y0ZlZSA9IGVzdGltYXRlQnRjRmVlO1xuZnVuY3Rpb24gZXN0aW1hdGVCY2hGZWUodXR4b1R4LCBuZXR3b3JrKSB7XG4gICAgY29uc3QgaW5wdXRzID0gdXR4b1R4LmlucHV0cztcbiAgICBjb25zdCBvdXRwdXRzID0gdXR4b1R4Lm91dHB1dHM7XG4gICAgY29uc3QgZmVlUGVyQiA9IHV0eG9UeC5mZWVQZXJCIHx8IDEwO1xuICAgIGNvbnN0IGR1c3RTaXplID0gdXR4b1R4LmR1c3RTaXplIHx8IDU0NjtcbiAgICBuZXR3b3JrID0gbmV0d29yayB8fCBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW47XG4gICAgY29uc3QgZmFrZVByaXZhdGVLZXkgPSBwcml2YXRlMldpZihjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KFwiODUzZmQ4OTYwZmYzNDgzODIwOGQ2NjJlY2QzYjlmOGNmNDEzZTEzZTBmNzRmOTVlNTU0ZjgwODlmNTA1OGRiMFwiKSwgbmV0d29yayk7XG4gICAgbGV0IHsgdmlydHVhbFNpemUgfSA9IGNhbGN1bGF0ZUJjaFR4U2l6ZShpbnB1dHMsIG91dHB1dHMsIHV0eG9UeC5hZGRyZXNzLCBmYWtlUHJpdmF0ZUtleSwgbmV0d29yaywgZHVzdFNpemUpO1xuICAgIHJldHVybiB2aXJ0dWFsU2l6ZSAqIGZlZVBlckI7XG59XG5leHBvcnRzLmVzdGltYXRlQmNoRmVlID0gZXN0aW1hdGVCY2hGZWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eEJ1aWxkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/txBuild.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/type.js':
    /*!*********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/type.js ***!
  \*********************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3QvdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L3R5cGUuanM/YTg1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/type.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/AtomicalWallet.js':
    /*!**************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/AtomicalWallet.js ***!
  \**************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.AtomicalTestWallet = exports.AtomicalWallet = exports.ErrCodeInvalidInputAsset = exports.ErrCodeAtomicalNotFullyAllocated = exports.ErrCodeSemiColorOuput = exports.ErrCodeMul = exports.ErrCodeUnknownAsset = exports.ErrCodeCommon = exports.ErrCodeVoutDust = exports.ErrCodeAtomicalChangeFail = exports.ErrCodeLessAtomicalAmt = void 0;\nconst coin_base_1 = __webpack_require__(/*! @okxweb3/coin-base */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js");\nconst BtcWallet_1 = __webpack_require__(/*! ./BtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js");\nconst bitcoin = __importStar(__webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js"));\nconst index_1 = __webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js");\nexports.ErrCodeLessAtomicalAmt = 2011400;\nexports.ErrCodeAtomicalChangeFail = 2011401;\nexports.ErrCodeVoutDust = 2011402;\nexports.ErrCodeCommon = 2011403;\nexports.ErrCodeUnknownAsset = 2011404;\nexports.ErrCodeMul = 2011420;\nexports.ErrCodeSemiColorOuput = 2011405;\nexports.ErrCodeAtomicalNotFullyAllocated = 2011406;\nexports.ErrCodeInvalidInputAsset = 2011407;\nclass AtomicalWallet extends BtcWallet_1.BtcWallet {\n    convert2AtomicalTx(paramData) {\n        const clonedParamData = (0, coin_base_1.cloneObject)(paramData);\n        const atomicalInputMap = new Map();\n        const atomicalTypeMap = new Map();\n        const atomicalSendMap = new Map();\n        let txOutput = [];\n        const feePerB = clonedParamData.feePerB || 10;\n        const dustSize = clonedParamData.dustSize || 546;\n        let inputs = clonedParamData.inputs;\n        for (const input of inputs) {\n            let dataArray = input.data;\n            if (dataArray != null && dataArray instanceof Array) {\n                for (const data of dataArray) {\n                    let atomicalId = data["atomicalId"];\n                    let atomicalIdType = data["type"];\n                    let atomicalAmount = Number(data["amount"]);\n                    if (atomicalId == null || atomicalAmount == null || atomicalIdType == null) {\n                        continue;\n                    }\n                    if (atomicalIdType != "FT" && atomicalIdType != "NFT") {\n                        continue;\n                    }\n                    if (atomicalAmount > input.amount) {\n                        throw new Error(JSON.stringify({ errCode: exports.ErrCodeInvalidInputAsset }));\n                    }\n                    if (atomicalTypeMap.get(atomicalId) == null) {\n                        atomicalTypeMap.set(atomicalId, atomicalIdType);\n                    }\n                    let beforeAmount = atomicalInputMap.get(atomicalId);\n                    if (beforeAmount == null) {\n                        atomicalInputMap.set(atomicalId, atomicalAmount);\n                    }\n                    else {\n                        atomicalInputMap.set(atomicalId, beforeAmount + atomicalAmount);\n                    }\n                }\n            }\n            if (Object.keys(atomicalInputMap).length > 1) {\n                throw new Error(JSON.stringify({ errCode: exports.ErrCodeMul }));\n            }\n        }\n        let outputs = clonedParamData.outputs;\n        let notFullyAllocated = 0;\n        for (const output of outputs) {\n            let dataArray = output.data;\n            if (dataArray != null && dataArray instanceof Array) {\n                for (const data of dataArray) {\n                    let atomicalId = data["atomicalId"];\n                    let atomicalAmount = Number(data["amount"]);\n                    let atomicalIdType = data["type"];\n                    if (atomicalIdType == "FT" && atomicalAmount != output.amount && atomicalAmount > dustSize) {\n                        throw new Error(JSON.stringify({ errCode: exports.ErrCodeSemiColorOuput }));\n                    }\n                    if (atomicalId == null || atomicalAmount == null || atomicalIdType == null) {\n                        continue;\n                    }\n                    if (atomicalIdType != "FT" && atomicalIdType != "NFT") {\n                        continue;\n                    }\n                    if (atomicalIdType == "FT" && atomicalAmount != output.amount) {\n                        notFullyAllocated += 1;\n                        if (notFullyAllocated == 2) {\n                            throw new Error(JSON.stringify({ errCode: exports.ErrCodeSemiColorOuput }));\n                        }\n                    }\n                    if (atomicalTypeMap.get(atomicalId) != atomicalIdType) {\n                        throw new Error(JSON.stringify({ errCode: exports.ErrCodeUnknownAsset }));\n                    }\n                    let beforeAmount = atomicalSendMap.get(atomicalId);\n                    if (beforeAmount == null) {\n                        atomicalSendMap.set(atomicalId, atomicalAmount);\n                    }\n                    else {\n                        atomicalSendMap.set(atomicalId, beforeAmount + atomicalAmount);\n                        if (atomicalIdType == "NFT") {\n                            throw new Error(JSON.stringify({ errCode: exports.ErrCodeMul }));\n                        }\n                    }\n                }\n            }\n            if (Object.keys(atomicalSendMap).length > 1) {\n                throw new Error(JSON.stringify({ errCode: exports.ErrCodeMul }));\n            }\n            txOutput.push({\n                amount: output.amount,\n                address: output.address,\n            });\n        }\n        for (const atomicalId of atomicalInputMap.keys()) {\n            let inputAmount = atomicalInputMap.get(atomicalId);\n            let sendAmount = atomicalSendMap.get(atomicalId);\n            if (inputAmount != sendAmount) {\n                throw new Error(JSON.stringify({\n                    errCode: exports.ErrCodeAtomicalNotFullyAllocated,\n                    date: {\n                        atomicalId: atomicalId,\n                        inputAmount: inputAmount,\n                        sendAmount: sendAmount\n                    }\n                }));\n            }\n        }\n        for (const [index, curUtxo] of txOutput.entries()) {\n            if (curUtxo.amount < dustSize) {\n                throw new Error(JSON.stringify({ errCode: exports.ErrCodeVoutDust, vOut: index }));\n            }\n        }\n        return {\n            inputs: clonedParamData.inputs,\n            outputs: txOutput,\n            address: clonedParamData.address,\n            feePerB: feePerB,\n        };\n    }\n    async signTransaction(param) {\n        const network = this.network();\n        let txHex = null;\n        try {\n            const privateKey = param.privateKey;\n            const atomicalTx = this.convert2AtomicalTx(param.data);\n            txHex = (0, index_1.signBtc)(atomicalTx, privateKey, network);\n            return Promise.resolve(txHex);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    async estimateFee(param) {\n        try {\n            const atomicalTx = this.convert2AtomicalTx(param.data);\n            const fee = bitcoin.estimateBtcFee(atomicalTx, this.network());\n            return Promise.resolve(fee);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\nexports.AtomicalWallet = AtomicalWallet;\nclass AtomicalTestWallet extends AtomicalWallet {\n    network() {\n        return bitcoin.networks.testnet;\n    }\n}\nexports.AtomicalTestWallet = AtomicalTestWallet;\n//# sourceMappingURL=AtomicalWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0F0b21pY2FsV2FsbGV0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxnQ0FBZ0MsR0FBRyx3Q0FBd0MsR0FBRyw2QkFBNkIsR0FBRyxrQkFBa0IsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyx1QkFBdUIsR0FBRyxpQ0FBaUMsR0FBRyw4QkFBOEI7QUFDM1Usb0JBQW9CLG1CQUFPLENBQUMsaUZBQW9CO0FBQ2hELG9CQUFvQixtQkFBTyxDQUFDLHdGQUFhO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLDBFQUFVO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFVO0FBQ2xDLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0Isa0JBQWtCO0FBQ2xCLDZCQUE2QjtBQUM3Qix3Q0FBd0M7QUFDeEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyQ0FBMkM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw2QkFBNkI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdDQUF3QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3Q0FBd0M7QUFDckc7QUFDQTtBQUNBO0FBQ0EseURBQXlELHNDQUFzQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDZCQUE2QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDZCQUE2QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsK0NBQStDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0F0b21pY2FsV2FsbGV0LmpzPzk5N2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXRvbWljYWxUZXN0V2FsbGV0ID0gZXhwb3J0cy5BdG9taWNhbFdhbGxldCA9IGV4cG9ydHMuRXJyQ29kZUludmFsaWRJbnB1dEFzc2V0ID0gZXhwb3J0cy5FcnJDb2RlQXRvbWljYWxOb3RGdWxseUFsbG9jYXRlZCA9IGV4cG9ydHMuRXJyQ29kZVNlbWlDb2xvck91cHV0ID0gZXhwb3J0cy5FcnJDb2RlTXVsID0gZXhwb3J0cy5FcnJDb2RlVW5rbm93bkFzc2V0ID0gZXhwb3J0cy5FcnJDb2RlQ29tbW9uID0gZXhwb3J0cy5FcnJDb2RlVm91dER1c3QgPSBleHBvcnRzLkVyckNvZGVBdG9taWNhbENoYW5nZUZhaWwgPSBleHBvcnRzLkVyckNvZGVMZXNzQXRvbWljYWxBbXQgPSB2b2lkIDA7XG5jb25zdCBjb2luX2Jhc2VfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jb2luLWJhc2VcIik7XG5jb25zdCBCdGNXYWxsZXRfMSA9IHJlcXVpcmUoXCIuL0J0Y1dhbGxldFwiKTtcbmNvbnN0IGJpdGNvaW4gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2luZGV4XCIpKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG5leHBvcnRzLkVyckNvZGVMZXNzQXRvbWljYWxBbXQgPSAyMDExNDAwO1xuZXhwb3J0cy5FcnJDb2RlQXRvbWljYWxDaGFuZ2VGYWlsID0gMjAxMTQwMTtcbmV4cG9ydHMuRXJyQ29kZVZvdXREdXN0ID0gMjAxMTQwMjtcbmV4cG9ydHMuRXJyQ29kZUNvbW1vbiA9IDIwMTE0MDM7XG5leHBvcnRzLkVyckNvZGVVbmtub3duQXNzZXQgPSAyMDExNDA0O1xuZXhwb3J0cy5FcnJDb2RlTXVsID0gMjAxMTQyMDtcbmV4cG9ydHMuRXJyQ29kZVNlbWlDb2xvck91cHV0ID0gMjAxMTQwNTtcbmV4cG9ydHMuRXJyQ29kZUF0b21pY2FsTm90RnVsbHlBbGxvY2F0ZWQgPSAyMDExNDA2O1xuZXhwb3J0cy5FcnJDb2RlSW52YWxpZElucHV0QXNzZXQgPSAyMDExNDA3O1xuY2xhc3MgQXRvbWljYWxXYWxsZXQgZXh0ZW5kcyBCdGNXYWxsZXRfMS5CdGNXYWxsZXQge1xuICAgIGNvbnZlcnQyQXRvbWljYWxUeChwYXJhbURhdGEpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkUGFyYW1EYXRhID0gKDAsIGNvaW5fYmFzZV8xLmNsb25lT2JqZWN0KShwYXJhbURhdGEpO1xuICAgICAgICBjb25zdCBhdG9taWNhbElucHV0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBhdG9taWNhbFR5cGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGF0b21pY2FsU2VuZE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IHR4T3V0cHV0ID0gW107XG4gICAgICAgIGNvbnN0IGZlZVBlckIgPSBjbG9uZWRQYXJhbURhdGEuZmVlUGVyQiB8fCAxMDtcbiAgICAgICAgY29uc3QgZHVzdFNpemUgPSBjbG9uZWRQYXJhbURhdGEuZHVzdFNpemUgfHwgNTQ2O1xuICAgICAgICBsZXQgaW5wdXRzID0gY2xvbmVkUGFyYW1EYXRhLmlucHV0cztcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhQXJyYXkgPSBpbnB1dC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGFBcnJheSAhPSBudWxsICYmIGRhdGFBcnJheSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkYXRhIG9mIGRhdGFBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXRvbWljYWxJZCA9IGRhdGFbXCJhdG9taWNhbElkXCJdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXRvbWljYWxJZFR5cGUgPSBkYXRhW1widHlwZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF0b21pY2FsQW1vdW50ID0gTnVtYmVyKGRhdGFbXCJhbW91bnRcIl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbWljYWxJZCA9PSBudWxsIHx8IGF0b21pY2FsQW1vdW50ID09IG51bGwgfHwgYXRvbWljYWxJZFR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0b21pY2FsSWRUeXBlICE9IFwiRlRcIiAmJiBhdG9taWNhbElkVHlwZSAhPSBcIk5GVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbWljYWxBbW91bnQgPiBpbnB1dC5hbW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7IGVyckNvZGU6IGV4cG9ydHMuRXJyQ29kZUludmFsaWRJbnB1dEFzc2V0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbWljYWxUeXBlTWFwLmdldChhdG9taWNhbElkKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdG9taWNhbFR5cGVNYXAuc2V0KGF0b21pY2FsSWQsIGF0b21pY2FsSWRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlQW1vdW50ID0gYXRvbWljYWxJbnB1dE1hcC5nZXQoYXRvbWljYWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVBbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbWljYWxJbnB1dE1hcC5zZXQoYXRvbWljYWxJZCwgYXRvbWljYWxBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbWljYWxJbnB1dE1hcC5zZXQoYXRvbWljYWxJZCwgYmVmb3JlQW1vdW50ICsgYXRvbWljYWxBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0b21pY2FsSW5wdXRNYXApLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoeyBlcnJDb2RlOiBleHBvcnRzLkVyckNvZGVNdWwgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRwdXRzID0gY2xvbmVkUGFyYW1EYXRhLm91dHB1dHM7XG4gICAgICAgIGxldCBub3RGdWxseUFsbG9jYXRlZCA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhQXJyYXkgPSBvdXRwdXQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhQXJyYXkgIT0gbnVsbCAmJiBkYXRhQXJyYXkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGF0YSBvZiBkYXRhQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF0b21pY2FsSWQgPSBkYXRhW1wiYXRvbWljYWxJZFwiXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF0b21pY2FsQW1vdW50ID0gTnVtYmVyKGRhdGFbXCJhbW91bnRcIl0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXRvbWljYWxJZFR5cGUgPSBkYXRhW1widHlwZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0b21pY2FsSWRUeXBlID09IFwiRlRcIiAmJiBhdG9taWNhbEFtb3VudCAhPSBvdXRwdXQuYW1vdW50ICYmIGF0b21pY2FsQW1vdW50ID4gZHVzdFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7IGVyckNvZGU6IGV4cG9ydHMuRXJyQ29kZVNlbWlDb2xvck91cHV0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbWljYWxJZCA9PSBudWxsIHx8IGF0b21pY2FsQW1vdW50ID09IG51bGwgfHwgYXRvbWljYWxJZFR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0b21pY2FsSWRUeXBlICE9IFwiRlRcIiAmJiBhdG9taWNhbElkVHlwZSAhPSBcIk5GVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbWljYWxJZFR5cGUgPT0gXCJGVFwiICYmIGF0b21pY2FsQW1vdW50ICE9IG91dHB1dC5hbW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZ1bGx5QWxsb2NhdGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90RnVsbHlBbGxvY2F0ZWQgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7IGVyckNvZGU6IGV4cG9ydHMuRXJyQ29kZVNlbWlDb2xvck91cHV0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbWljYWxUeXBlTWFwLmdldChhdG9taWNhbElkKSAhPSBhdG9taWNhbElkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHsgZXJyQ29kZTogZXhwb3J0cy5FcnJDb2RlVW5rbm93bkFzc2V0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlQW1vdW50ID0gYXRvbWljYWxTZW5kTWFwLmdldChhdG9taWNhbElkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZUFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdG9taWNhbFNlbmRNYXAuc2V0KGF0b21pY2FsSWQsIGF0b21pY2FsQW1vdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0b21pY2FsU2VuZE1hcC5zZXQoYXRvbWljYWxJZCwgYmVmb3JlQW1vdW50ICsgYXRvbWljYWxBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0b21pY2FsSWRUeXBlID09IFwiTkZUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoeyBlcnJDb2RlOiBleHBvcnRzLkVyckNvZGVNdWwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0b21pY2FsU2VuZE1hcCkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7IGVyckNvZGU6IGV4cG9ydHMuRXJyQ29kZU11bCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eE91dHB1dC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhbW91bnQ6IG91dHB1dC5hbW91bnQsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogb3V0cHV0LmFkZHJlc3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGF0b21pY2FsSWQgb2YgYXRvbWljYWxJbnB1dE1hcC5rZXlzKCkpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dEFtb3VudCA9IGF0b21pY2FsSW5wdXRNYXAuZ2V0KGF0b21pY2FsSWQpO1xuICAgICAgICAgICAgbGV0IHNlbmRBbW91bnQgPSBhdG9taWNhbFNlbmRNYXAuZ2V0KGF0b21pY2FsSWQpO1xuICAgICAgICAgICAgaWYgKGlucHV0QW1vdW50ICE9IHNlbmRBbW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBlcnJDb2RlOiBleHBvcnRzLkVyckNvZGVBdG9taWNhbE5vdEZ1bGx5QWxsb2NhdGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdG9taWNhbElkOiBhdG9taWNhbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRBbW91bnQ6IGlucHV0QW1vdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZEFtb3VudDogc2VuZEFtb3VudFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjdXJVdHhvXSBvZiB0eE91dHB1dC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChjdXJVdHhvLmFtb3VudCA8IGR1c3RTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHsgZXJyQ29kZTogZXhwb3J0cy5FcnJDb2RlVm91dER1c3QsIHZPdXQ6IGluZGV4IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRzOiBjbG9uZWRQYXJhbURhdGEuaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogdHhPdXRwdXQsXG4gICAgICAgICAgICBhZGRyZXNzOiBjbG9uZWRQYXJhbURhdGEuYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZVBlckI6IGZlZVBlckIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbSkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrKCk7XG4gICAgICAgIGxldCB0eEhleCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gcGFyYW0ucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGNvbnN0IGF0b21pY2FsVHggPSB0aGlzLmNvbnZlcnQyQXRvbWljYWxUeChwYXJhbS5kYXRhKTtcbiAgICAgICAgICAgIHR4SGV4ID0gKDAsIGluZGV4XzEuc2lnbkJ0YykoYXRvbWljYWxUeCwgcHJpdmF0ZUtleSwgbmV0d29yayk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHR4SGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlRmVlKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhdG9taWNhbFR4ID0gdGhpcy5jb252ZXJ0MkF0b21pY2FsVHgocGFyYW0uZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBmZWUgPSBiaXRjb2luLmVzdGltYXRlQnRjRmVlKGF0b21pY2FsVHgsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BdG9taWNhbFdhbGxldCA9IEF0b21pY2FsV2FsbGV0O1xuY2xhc3MgQXRvbWljYWxUZXN0V2FsbGV0IGV4dGVuZHMgQXRvbWljYWxXYWxsZXQge1xuICAgIG5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBiaXRjb2luLm5ldHdvcmtzLnRlc3RuZXQ7XG4gICAgfVxufVxuZXhwb3J0cy5BdG9taWNhbFRlc3RXYWxsZXQgPSBBdG9taWNhbFRlc3RXYWxsZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdG9taWNhbFdhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/AtomicalWallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BchWallet.js':
    /*!*********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BchWallet.js ***!
  \*********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BchWallet = void 0;\nconst coin_base_1 = __webpack_require__(/*! @okxweb3/coin-base */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst BtcWallet_1 = __webpack_require__(/*! ./BtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js");\nconst bitcoin = __importStar(__webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js"));\nclass BchWallet extends BtcWallet_1.BtcWallet {\n    async getDerivedPath(param) {\n        return `m/44\'/145\'/0\'/0/${param.index}`;\n    }\n    async getNewAddress(param) {\n        try {\n            let network = this.network();\n            let privateKey = param.privateKey;\n            const publicKey = bitcoin.wif2Public(privateKey, network);\n            const address = bitcoin.GetBitcashP2PkHAddressByPublicKey(publicKey);\n            const addressWithoutPrefix = address.replace("bitcoincash:", "");\n            let data = {\n                address: addressWithoutPrefix || "",\n                publicKey: crypto_lib_1.base.toHex(publicKey)\n            };\n            return Promise.resolve(data);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.NewAddressError);\n        }\n    }\n    async validAddress(param) {\n        let isValid = false;\n        try {\n            let network = this.network();\n            let outputScript = bitcoin.address.toOutputScript(param.address, network);\n            if (outputScript) {\n                isValid = true;\n            }\n        }\n        catch (e) {\n        }\n        if (!isValid) {\n            isValid = bitcoin.ValidateBitcashP2PkHAddress(param.address);\n        }\n        let data = {\n            isValid: isValid,\n            address: param.address\n        };\n        return Promise.resolve(data);\n    }\n    async signTransaction(param) {\n        let txHex = null;\n        try {\n            const privateKey = param.privateKey;\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            utxoTx.outputs.forEach((it) => {\n                if (bitcoin.isCashAddress(it.address)) {\n                    it.address = bitcoin.convert2LegacyAddress(it.address, this.network());\n                }\n            });\n            if (bitcoin.isCashAddress(utxoTx.address)) {\n                utxoTx.address = bitcoin.convert2LegacyAddress(utxoTx.address, this.network());\n            }\n            txHex = bitcoin.signBch(utxoTx, privateKey, this.network());\n            return Promise.resolve(txHex);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignTxError);\n        }\n    }\n    async estimateFee(param) {\n        try {\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            utxoTx.outputs.forEach((it) => {\n                if (bitcoin.isCashAddress(it.address)) {\n                    it.address = bitcoin.convert2LegacyAddress(it.address, this.network());\n                }\n            });\n            if (bitcoin.isCashAddress(utxoTx.address)) {\n                utxoTx.address = bitcoin.convert2LegacyAddress(utxoTx.address, this.network());\n            }\n            const fee = bitcoin.estimateBchFee(utxoTx, this.network());\n            return Promise.resolve(fee);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.EstimateFeeError);\n        }\n    }\n    getMPCRawTransaction(param) {\n        try {\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            utxoTx.outputs.forEach((it) => {\n                if (bitcoin.isCashAddress(it.address)) {\n                    it.address = bitcoin.convert2LegacyAddress(it.address, this.network());\n                }\n            });\n            if (bitcoin.isCashAddress(utxoTx.address)) {\n                utxoTx.address = bitcoin.convert2LegacyAddress(utxoTx.address, this.network());\n            }\n            const hash = [];\n            const hex = bitcoin.signBch(utxoTx, "", this.network(), hash);\n            const data = {\n                raw: hex,\n                hash: hash\n            };\n            return Promise.resolve(data);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetMpcRawTransactionError);\n        }\n    }\n    getAddressByPublicKey(param) {\n        const publicKey = crypto_lib_1.base.fromHex(param.publicKey);\n        const address = bitcoin.GetBitcashP2PkHAddressByPublicKey(publicKey);\n        return Promise.resolve(address.replace("bitcoincash:", ""));\n    }\n    getMPCTransaction(param) {\n        try {\n            const hex = bitcoin.getMPCTransaction(param.raw, param.sigs, true);\n            return Promise.resolve(hex);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetMpcTransactionError);\n        }\n    }\n    getHardWareRawTransaction(param) {\n        try {\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            utxoTx.outputs.forEach((it) => {\n                if (bitcoin.isCashAddress(it.address)) {\n                    it.address = bitcoin.convert2LegacyAddress(it.address, this.network());\n                }\n            });\n            if (bitcoin.isCashAddress(utxoTx.address)) {\n                utxoTx.address = bitcoin.convert2LegacyAddress(utxoTx.address, this.network());\n            }\n            const hex = bitcoin.signBch(utxoTx, "", this.network(), undefined, true);\n            return Promise.resolve(hex);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetHardwareRawTransactionError);\n        }\n    }\n}\nexports.BchWallet = BchWallet;\n//# sourceMappingURL=BchWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0JjaFdhbGxldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFvQjtBQUNoRCxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsd0ZBQWE7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsMEVBQVU7QUFDL0M7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0JjaFdhbGxldC5qcz9kN2M2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJjaFdhbGxldCA9IHZvaWQgMDtcbmNvbnN0IGNvaW5fYmFzZV8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NvaW4tYmFzZVwiKTtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuY29uc3QgQnRjV2FsbGV0XzEgPSByZXF1aXJlKFwiLi9CdGNXYWxsZXRcIik7XG5jb25zdCBiaXRjb2luID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9pbmRleFwiKSk7XG5jbGFzcyBCY2hXYWxsZXQgZXh0ZW5kcyBCdGNXYWxsZXRfMS5CdGNXYWxsZXQge1xuICAgIGFzeW5jIGdldERlcml2ZWRQYXRoKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBgbS80NCcvMTQ1Jy8wJy8wLyR7cGFyYW0uaW5kZXh9YDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmV3QWRkcmVzcyhwYXJhbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcmsoKTtcbiAgICAgICAgICAgIGxldCBwcml2YXRlS2V5ID0gcGFyYW0ucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGJpdGNvaW4ud2lmMlB1YmxpYyhwcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBiaXRjb2luLkdldEJpdGNhc2hQMlBrSEFkZHJlc3NCeVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc1dpdGhvdXRQcmVmaXggPSBhZGRyZXNzLnJlcGxhY2UoXCJiaXRjb2luY2FzaDpcIiwgXCJcIik7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzV2l0aG91dFByZWZpeCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleTogY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgocHVibGljS2V5KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5OZXdBZGRyZXNzRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHZhbGlkQWRkcmVzcyhwYXJhbSkge1xuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcmsoKTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRTY3JpcHQgPSBiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQocGFyYW0uYWRkcmVzcywgbmV0d29yayk7XG4gICAgICAgICAgICBpZiAob3V0cHV0U2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBiaXRjb2luLlZhbGlkYXRlQml0Y2FzaFAyUGtIQWRkcmVzcyhwYXJhbS5hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgICAgICAgICBhZGRyZXNzOiBwYXJhbS5hZGRyZXNzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbSkge1xuICAgICAgICBsZXQgdHhIZXggPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHBhcmFtLnByaXZhdGVLZXk7XG4gICAgICAgICAgICBjb25zdCB1dHhvVHggPSAoMCwgQnRjV2FsbGV0XzEuY29udmVydDJVdHhvVHgpKHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgdXR4b1R4Lm91dHB1dHMuZm9yRWFjaCgoaXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYml0Y29pbi5pc0Nhc2hBZGRyZXNzKGl0LmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LmFkZHJlc3MgPSBiaXRjb2luLmNvbnZlcnQyTGVnYWN5QWRkcmVzcyhpdC5hZGRyZXNzLCB0aGlzLm5ldHdvcmsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYml0Y29pbi5pc0Nhc2hBZGRyZXNzKHV0eG9UeC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHV0eG9UeC5hZGRyZXNzID0gYml0Y29pbi5jb252ZXJ0MkxlZ2FjeUFkZHJlc3ModXR4b1R4LmFkZHJlc3MsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4SGV4ID0gYml0Y29pbi5zaWduQmNoKHV0eG9UeCwgcHJpdmF0ZUtleSwgdGhpcy5uZXR3b3JrKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eEhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVGZWUocGFyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHV0eG9UeCA9ICgwLCBCdGNXYWxsZXRfMS5jb252ZXJ0MlV0eG9UeCkocGFyYW0uZGF0YSk7XG4gICAgICAgICAgICB1dHhvVHgub3V0cHV0cy5mb3JFYWNoKChpdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChiaXRjb2luLmlzQ2FzaEFkZHJlc3MoaXQuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuYWRkcmVzcyA9IGJpdGNvaW4uY29udmVydDJMZWdhY3lBZGRyZXNzKGl0LmFkZHJlc3MsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChiaXRjb2luLmlzQ2FzaEFkZHJlc3ModXR4b1R4LmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgdXR4b1R4LmFkZHJlc3MgPSBiaXRjb2luLmNvbnZlcnQyTGVnYWN5QWRkcmVzcyh1dHhvVHguYWRkcmVzcywgdGhpcy5uZXR3b3JrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmVlID0gYml0Y29pbi5lc3RpbWF0ZUJjaEZlZSh1dHhvVHgsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLkVzdGltYXRlRmVlRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1QQ1Jhd1RyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1dHhvVHggPSAoMCwgQnRjV2FsbGV0XzEuY29udmVydDJVdHhvVHgpKHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgdXR4b1R4Lm91dHB1dHMuZm9yRWFjaCgoaXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYml0Y29pbi5pc0Nhc2hBZGRyZXNzKGl0LmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LmFkZHJlc3MgPSBiaXRjb2luLmNvbnZlcnQyTGVnYWN5QWRkcmVzcyhpdC5hZGRyZXNzLCB0aGlzLm5ldHdvcmsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYml0Y29pbi5pc0Nhc2hBZGRyZXNzKHV0eG9UeC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHV0eG9UeC5hZGRyZXNzID0gYml0Y29pbi5jb252ZXJ0MkxlZ2FjeUFkZHJlc3ModXR4b1R4LmFkZHJlc3MsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IGJpdGNvaW4uc2lnbkJjaCh1dHhvVHgsIFwiXCIsIHRoaXMubmV0d29yaygpLCBoYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgcmF3OiBoZXgsXG4gICAgICAgICAgICAgICAgaGFzaDogaGFzaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5HZXRNcGNSYXdUcmFuc2FjdGlvbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRBZGRyZXNzQnlQdWJsaWNLZXkocGFyYW0pIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvX2xpYl8xLmJhc2UuZnJvbUhleChwYXJhbS5wdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYml0Y29pbi5HZXRCaXRjYXNoUDJQa0hBZGRyZXNzQnlQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhZGRyZXNzLnJlcGxhY2UoXCJiaXRjb2luY2FzaDpcIiwgXCJcIikpO1xuICAgIH1cbiAgICBnZXRNUENUcmFuc2FjdGlvbihwYXJhbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gYml0Y29pbi5nZXRNUENUcmFuc2FjdGlvbihwYXJhbS5yYXcsIHBhcmFtLnNpZ3MsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuR2V0TXBjVHJhbnNhY3Rpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SGFyZFdhcmVSYXdUcmFuc2FjdGlvbihwYXJhbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXR4b1R4ID0gKDAsIEJ0Y1dhbGxldF8xLmNvbnZlcnQyVXR4b1R4KShwYXJhbS5kYXRhKTtcbiAgICAgICAgICAgIHV0eG9UeC5vdXRwdXRzLmZvckVhY2goKGl0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGJpdGNvaW4uaXNDYXNoQWRkcmVzcyhpdC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICBpdC5hZGRyZXNzID0gYml0Y29pbi5jb252ZXJ0MkxlZ2FjeUFkZHJlc3MoaXQuYWRkcmVzcywgdGhpcy5uZXR3b3JrKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGJpdGNvaW4uaXNDYXNoQWRkcmVzcyh1dHhvVHguYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICB1dHhvVHguYWRkcmVzcyA9IGJpdGNvaW4uY29udmVydDJMZWdhY3lBZGRyZXNzKHV0eG9UeC5hZGRyZXNzLCB0aGlzLm5ldHdvcmsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZXggPSBiaXRjb2luLnNpZ25CY2godXR4b1R4LCBcIlwiLCB0aGlzLm5ldHdvcmsoKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLkdldEhhcmR3YXJlUmF3VHJhbnNhY3Rpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJjaFdhbGxldCA9IEJjaFdhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJjaFdhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BchWallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BsvWallet.js':
    /*!*********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BsvWallet.js ***!
  \*********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BsvWallet = void 0;\nconst coin_base_1 = __webpack_require__(/*! @okxweb3/coin-base */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js");\nconst BtcWallet_1 = __webpack_require__(/*! ./BtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js");\nconst bitcoin = __importStar(__webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js"));\nclass BsvWallet extends BtcWallet_1.BtcWallet {\n    async getDerivedPath(param) {\n        return `m/44\'/236\'/0\'/0/${param.index}`;\n    }\n    async signTransaction(param) {\n        let txHex = null;\n        try {\n            const privateKey = param.privateKey;\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            txHex = bitcoin.signBch(utxoTx, privateKey, this.network());\n            return Promise.resolve(txHex);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignTxError);\n        }\n    }\n    async estimateFee(param) {\n        try {\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            const fee = bitcoin.estimateBchFee(utxoTx, this.network());\n            return Promise.resolve(fee);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.EstimateFeeError);\n        }\n    }\n    getMPCRawTransaction(param) {\n        try {\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            const hash = [];\n            const hex = bitcoin.signBch(utxoTx, "", this.network(), hash);\n            const data = {\n                raw: hex,\n                hash: hash\n            };\n            return Promise.resolve(data);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetMpcRawTransactionError);\n        }\n    }\n    getMPCTransaction(param) {\n        try {\n            const hex = bitcoin.getMPCTransaction(param.raw, param.sigs, true);\n            return Promise.resolve(hex);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetMpcTransactionError);\n        }\n    }\n    getHardWareRawTransaction(param) {\n        try {\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            const hex = bitcoin.signBch(utxoTx, "", this.network(), undefined, true);\n            return Promise.resolve(hex);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetHardwareRawTransactionError);\n        }\n    }\n}\nexports.BsvWallet = BsvWallet;\n//# sourceMappingURL=BsvWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0JzdldhbGxldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFvQjtBQUNoRCxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBYTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQywwRUFBVTtBQUMvQztBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC93YWxsZXQvQnN2V2FsbGV0LmpzPzg4Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnN2V2FsbGV0ID0gdm9pZCAwO1xuY29uc3QgY29pbl9iYXNlXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY29pbi1iYXNlXCIpO1xuY29uc3QgQnRjV2FsbGV0XzEgPSByZXF1aXJlKFwiLi9CdGNXYWxsZXRcIik7XG5jb25zdCBiaXRjb2luID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9pbmRleFwiKSk7XG5jbGFzcyBCc3ZXYWxsZXQgZXh0ZW5kcyBCdGNXYWxsZXRfMS5CdGNXYWxsZXQge1xuICAgIGFzeW5jIGdldERlcml2ZWRQYXRoKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBgbS80NCcvMjM2Jy8wJy8wLyR7cGFyYW0uaW5kZXh9YDtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIGxldCB0eEhleCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gcGFyYW0ucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGNvbnN0IHV0eG9UeCA9ICgwLCBCdGNXYWxsZXRfMS5jb252ZXJ0MlV0eG9UeCkocGFyYW0uZGF0YSk7XG4gICAgICAgICAgICB0eEhleCA9IGJpdGNvaW4uc2lnbkJjaCh1dHhvVHgsIHByaXZhdGVLZXksIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHhIZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnblR4RXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlRmVlKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1dHhvVHggPSAoMCwgQnRjV2FsbGV0XzEuY29udmVydDJVdHhvVHgpKHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgY29uc3QgZmVlID0gYml0Y29pbi5lc3RpbWF0ZUJjaEZlZSh1dHhvVHgsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLkVzdGltYXRlRmVlRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1QQ1Jhd1RyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1dHhvVHggPSAoMCwgQnRjV2FsbGV0XzEuY29udmVydDJVdHhvVHgpKHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gYml0Y29pbi5zaWduQmNoKHV0eG9UeCwgXCJcIiwgdGhpcy5uZXR3b3JrKCksIGhhc2gpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICByYXc6IGhleCxcbiAgICAgICAgICAgICAgICBoYXNoOiBoYXNoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLkdldE1wY1Jhd1RyYW5zYWN0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1QQ1RyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBiaXRjb2luLmdldE1QQ1RyYW5zYWN0aW9uKHBhcmFtLnJhdywgcGFyYW0uc2lncywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5HZXRNcGNUcmFuc2FjdGlvbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRIYXJkV2FyZVJhd1RyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1dHhvVHggPSAoMCwgQnRjV2FsbGV0XzEuY29udmVydDJVdHhvVHgpKHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gYml0Y29pbi5zaWduQmNoKHV0eG9UeCwgXCJcIiwgdGhpcy5uZXR3b3JrKCksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5HZXRIYXJkd2FyZVJhd1RyYW5zYWN0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Cc3ZXYWxsZXQgPSBCc3ZXYWxsZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cc3ZXYWxsZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BsvWallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js':
    /*!*********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js ***!
  \*********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.convert2UtxoTx = exports.number2Hex = exports.TBtcWallet = exports.BtcWallet = exports.BITCOIN_MESSAGE_BIP0322_SIMPLE = exports.BITCOIN_MESSAGE_ECDSA = void 0;\nconst coin_base_1 = __webpack_require__(/*! @okxweb3/coin-base */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst bitcoin = __importStar(__webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js"));\nconst index_1 = __webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js");\nconst psbt_1 = __webpack_require__(/*! ../bitcoinjs-lib/psbt */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/psbt.js");\nconst bip0322_1 = __webpack_require__(/*! ../bitcoinjs-lib/bip0322 */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/bitcoinjs-lib/bip0322.js");\nexports.BITCOIN_MESSAGE_ECDSA = 0;\nexports.BITCOIN_MESSAGE_BIP0322_SIMPLE = 1;\nclass BtcWallet extends coin_base_1.BaseWallet {\n    network() {\n        return bitcoin.networks.bitcoin;\n    }\n    async getDerivedPath(param) {\n        if (!param.segwitType) {\n            return `m/44\'/0\'/0\'/0/${param.index}`;\n        }\n        if (param.segwitType == coin_base_1.segwitType.SEGWIT_NESTED) {\n            return `m/84\'/0\'/0\'/0/${param.index}`;\n        }\n        else if (param.segwitType == coin_base_1.segwitType.SEGWIT_NESTED_49) {\n            return `m/49\'/0\'/0\'/0/${param.index}`;\n        }\n        else if (param.segwitType == coin_base_1.segwitType.SEGWIT_NATIVE) {\n            return `m/84\'/0\'/0\'/0/${param.index}`;\n        }\n        else if (param.segwitType == coin_base_1.segwitType.SEGWIT_TAPROOT) {\n            return `m/86\'/0\'/0\'/0/${param.index}`;\n        }\n        else {\n            return Promise.reject(coin_base_1.DerivePathError);\n        }\n    }\n    async validPrivateKey(param) {\n        let isValid;\n        try {\n            const { version } = bitcoin.wif.decode(param.privateKey);\n            isValid = (version === this.network().wif);\n        }\n        catch (e) {\n            isValid = false;\n        }\n        const data = {\n            isValid: isValid,\n            privateKey: param.privateKey\n        };\n        return Promise.resolve(data);\n    }\n    async getNewAddress(param) {\n        try {\n            let network = this.network();\n            let privateKey = param.privateKey;\n            const addressType = param.addressType || "Legacy";\n            const publicKey = bitcoin.wif2Public(privateKey, network);\n            let address;\n            if (addressType === "Legacy") {\n                const result = bitcoin.payments.p2pkh({ pubkey: publicKey, network });\n                address = result.address;\n            }\n            else if (addressType === "segwit_native") {\n                const result = bitcoin.payments.p2wpkh({ pubkey: publicKey, network });\n                address = result.address;\n            }\n            else if (addressType === "segwit_nested") {\n                const result = bitcoin.payments.p2sh({\n                    redeem: bitcoin.payments.p2wpkh({ pubkey: publicKey, network }),\n                });\n                address = result.address;\n            }\n            else if (addressType === "segwit_taproot") {\n                const result = bitcoin.payments.p2tr({ internalPubkey: publicKey.slice(1), network });\n                address = result.address;\n            }\n            let data = {\n                address: address || "",\n                publicKey: crypto_lib_1.base.toHex(addressType === "segwit_taproot" ? publicKey.slice(1) : publicKey),\n                compressedPublicKey: crypto_lib_1.base.toHex(publicKey),\n            };\n            return Promise.resolve(data);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.NewAddressError);\n        }\n    }\n    async validAddress(param) {\n        let isValid = false;\n        let network = this.network();\n        try {\n            let outputScript = bitcoin.address.toOutputScript(param.address, network);\n            if (outputScript) {\n                isValid = true;\n            }\n        }\n        catch (e) {\n        }\n        if (param.addressType) {\n            isValid = param.addressType === bitcoin.getAddressType(param.address, network);\n        }\n        let data = {\n            isValid: isValid,\n            address: param.address\n        };\n        return Promise.resolve(data);\n    }\n    async signTransaction(param) {\n        const type = param.data.type || 0;\n        if (type === bitcoin.BtcXrcTypes.INSCRIBE) {\n            try {\n                return Promise.resolve(bitcoin.inscribe(this.network(), param.data));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT) {\n            try {\n                return Promise.resolve(bitcoin.psbtSign(param.data.psbt, param.privateKey, this.network()));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_DEODE) {\n            try {\n                return Promise.resolve(bitcoin.psbtDecode(param.data.psbt, this.network()));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_MPC_UNSIGNED_LIST) {\n            try {\n                return Promise.resolve(bitcoin.generateMPCUnsignedListingPSBT(param.data.psbt, param.data.publicKey, this.network()));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_MPC_SIGNED_LIST) {\n            try {\n                return Promise.resolve(bitcoin.generateMPCSignedListingPSBT(param.data.psbt, param.data.publicKey, param.data.signature, this.network()));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_MPC_UNSIGNED_BUY) {\n            try {\n                return Promise.resolve(bitcoin.generateMPCUnsignedBuyingPSBT(param.data.psbt, param.data.publicKey, this.network(), param.data.batchSize));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_MPC_SIGNED_BUY) {\n            try {\n                return Promise.resolve(bitcoin.generateMPCSignedBuyingTx(param.data.psbt, param.data.publicKey, param.data.signatureList, this.network(), param.data.batchSize));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_MPC_UNSIGNED) {\n            try {\n                return Promise.resolve(bitcoin.generateMPCUnsignedPSBT(param.data.psbt, param.data.publicKey, this.network()));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_MPC_SIGNED) {\n            try {\n                return Promise.resolve(bitcoin.generateMPCSignedPSBT(param.data.psbt, param.data.publicKey, param.data.signatureList, this.network()));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_KEY_SCRIPT_PATH) {\n            try {\n                return Promise.resolve(bitcoin.signPsbtWithKeyPathAndScriptPath(param.data.psbt, param.privateKey, this.network(), {\n                    autoFinalized: param.data.autoFinalized,\n                    toSignInputs: param.data.toSignInputs\n                }));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_KEY_SCRIPT_PATH_BATCH) {\n            try {\n                return Promise.resolve(bitcoin.signPsbtWithKeyPathAndScriptPathBatch(param.data.psbtHexs, param.privateKey, this.network(), param.data.options));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.SRC20) {\n            try {\n                return Promise.resolve(bitcoin.srcInscribe(this.network(), param.data));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.RUNE) {\n            try {\n                let wallet = new index_1.RuneWallet();\n                if (this.network() === index_1.networks.testnet) {\n                    wallet = new index_1.RuneTestWallet();\n                }\n                return Promise.resolve(wallet.signTransaction(param));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.RUNEMAIN) {\n            try {\n                let wallet = new index_1.RuneMainWallet();\n                if (this.network() === index_1.networks.testnet) {\n                    wallet = new index_1.RuneMainTestWallet();\n                }\n                return Promise.resolve(wallet.signTransaction(param));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.ARC20) {\n            try {\n                let wallet = new index_1.AtomicalWallet();\n                if (this.network() === index_1.networks.testnet) {\n                    wallet = new index_1.AtomicalTestWallet();\n                }\n                return Promise.resolve(wallet.signTransaction(param));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === bitcoin.BtcXrcTypes.PSBT_RUNEMAIN) {\n            try {\n                let wallet = new index_1.RuneMainWallet();\n                if (this.network() === index_1.networks.testnet) {\n                    wallet = new index_1.RuneMainTestWallet();\n                }\n                return Promise.resolve(wallet.buildPsbt(param));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else {\n            let txHex = null;\n            try {\n                const privateKey = param.privateKey;\n                const utxoTx = convert2UtxoTx(param.data);\n                txHex = bitcoin.signBtc(utxoTx, privateKey, this.network());\n                return Promise.resolve(txHex);\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n    }\n    getRandomPrivateKey() {\n        try {\n            let network = this.network();\n            while (true) {\n                const privateKey = crypto_lib_1.base.randomBytes(32);\n                if ((0, coin_base_1.secp256k1SignTest)(privateKey)) {\n                    const wif = bitcoin.private2Wif(privateKey, network);\n                    return Promise.resolve(wif);\n                }\n            }\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GenPrivateKeyError);\n        }\n    }\n    getDerivedPrivateKey(param) {\n        let network = this.network();\n        return crypto_lib_1.bip39.mnemonicToSeed(param.mnemonic)\n            .then(masterSeed => {\n            let childKey = crypto_lib_1.bip32.fromSeed(masterSeed).derivePath(param.hdPath);\n            if (!childKey.privateKey) {\n                return Promise.reject(coin_base_1.GenPrivateKeyError);\n            }\n            const wif = bitcoin.private2Wif(childKey.privateKey, network);\n            return Promise.resolve(wif);\n        }).catch((e) => {\n            return Promise.reject(coin_base_1.GenPrivateKeyError);\n        });\n    }\n    getAddressByPublicKey(param) {\n        try {\n            const network = this.network();\n            const publicKey = crypto_lib_1.base.fromHex(param.publicKey);\n            if (!param.addressType) {\n                const addresses = [];\n                addresses.push({\n                    addressType: "Legacy",\n                    address: bitcoin.payments.p2pkh({ pubkey: publicKey, network }).address,\n                });\n                addresses.push({\n                    addressType: "segwit_nested",\n                    address: bitcoin.payments.p2sh({\n                        redeem: bitcoin.payments.p2wpkh({ pubkey: publicKey, network }),\n                    }).address,\n                });\n                addresses.push({\n                    addressType: "segwit_native",\n                    address: bitcoin.payments.p2wpkh({ pubkey: publicKey, network }).address,\n                });\n                return Promise.resolve(addresses);\n            }\n            else if (param.addressType === \'Legacy\') {\n                return Promise.resolve(bitcoin.payments.p2pkh({ pubkey: publicKey, network }).address);\n            }\n            else if (param.addressType === \'segwit_nested\') {\n                return Promise.resolve(bitcoin.payments.p2sh({\n                    redeem: bitcoin.payments.p2wpkh({ pubkey: publicKey, network }),\n                }).address);\n            }\n            else if (param.addressType === \'segwit_native\') {\n                return Promise.resolve(bitcoin.payments.p2wpkh({ pubkey: publicKey, network }).address);\n            }\n            else if (param.addressType === \'segwit_taproot\') {\n                return Promise.resolve(bitcoin.payments.p2tr({ internalPubkey: publicKey.slice(1), network }).address);\n            }\n        }\n        catch (e) {\n        }\n        return Promise.reject(coin_base_1.NewAddressError);\n    }\n    getMPCRawTransaction(param) {\n        try {\n            const utxoTx = convert2UtxoTx(param.data);\n            const hash = [];\n            const unsignedTx = bitcoin.signBtc(utxoTx, "", this.network(), hash);\n            const data = {\n                raw: unsignedTx,\n                hash: hash,\n            };\n            return Promise.resolve(data);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetMpcRawTransactionError);\n        }\n    }\n    getMPCTransaction(param) {\n        try {\n            const hex = bitcoin.getMPCTransaction(param.raw, param.sigs, false);\n            return Promise.resolve(hex);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetMpcTransactionError);\n        }\n    }\n    async getMPCRawMessage(param) {\n        try {\n            const msgHash = await this.signMessage(param);\n            return Promise.resolve({ hash: msgHash });\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetMpcRawTransactionError);\n        }\n    }\n    async getMPCSignedMessage(param) {\n        try {\n            return Promise.resolve(bitcoin.message.getMPCSignedMessage(param.hash, param.sigs, param.publicKey));\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetMpcTransactionError);\n        }\n    }\n    getHardWareRawTransaction(param) {\n        try {\n            const type = param.data.type || 0;\n            const utxoTx = convert2UtxoTx(param.data);\n            if (type === 2) {\n                const change = bitcoin.signBtc(utxoTx, "", this.network(), undefined, true, true);\n                const dustSize = utxoTx.dustSize || 546;\n                if (parseInt(change) >= dustSize) {\n                    const changeUtxo = {\n                        address: utxoTx.address,\n                        amount: parseInt(change),\n                        bip32Derivation: utxoTx.bip32Derivation\n                    };\n                    utxoTx.outputs.push(changeUtxo);\n                }\n                const hex = bitcoin.buildPsbt(utxoTx, this.network());\n                return Promise.resolve(hex);\n            }\n            else {\n                const hex = bitcoin.signBtc(utxoTx, "", this.network(), undefined, true);\n                return Promise.resolve(hex);\n            }\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetHardwareRawTransactionError);\n        }\n    }\n    async calcTxHash(param) {\n        try {\n            return Promise.resolve(bitcoin.Transaction.fromHex(param.data).getId());\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.CalcTxHashError);\n        }\n    }\n    genPsbtOfBIP322Simple({ message, address }) {\n        return (0, bip0322_1.genPsbtOfBIP322Simple)({ message: message, address: address, network: this.network() });\n    }\n    getSignatureFromPsbtOfBIP322Simple(txEncoded) {\n        let tx = psbt_1.Psbt.fromBase64(txEncoded);\n        try {\n            tx.finalizeAllInputs();\n        }\n        catch (e) {\n        }\n        let signature = (0, bip0322_1.getSignatureFromPsbtOfBIP322Simple)(tx);\n        return Promise.resolve(signature);\n    }\n    signMessage(param) {\n        try {\n            const typedMessage = param.data;\n            let signature;\n            if (typedMessage.type === exports.BITCOIN_MESSAGE_ECDSA) {\n                signature = bitcoin.message.sign(param.privateKey, typedMessage.message, this.network());\n            }\n            else {\n                signature = bitcoin.bip0322.signSimple(typedMessage.message, typedMessage.address, param.privateKey, this.network());\n            }\n            return Promise.resolve(signature);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignMsgError);\n        }\n    }\n    async verifyMessage(param) {\n        try {\n            const typedMessage = param.data;\n            if (typedMessage.type === exports.BITCOIN_MESSAGE_ECDSA) {\n                const ret = bitcoin.message.verify(typedMessage.publicKey, typedMessage.message, param.signature);\n                return Promise.resolve(ret);\n            }\n            else {\n                const ret = bitcoin.bip0322.verifySimple(typedMessage.message, typedMessage.address, param.signature, typedMessage.publicKey, this.network());\n                return Promise.resolve(ret);\n            }\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignMsgError);\n        }\n    }\n    static async extractPsbtTransaction(txHex) {\n        try {\n            return Promise.resolve(bitcoin.extractPsbtTransaction(txHex));\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignMsgError);\n        }\n    }\n    async validSignedTransaction(param) {\n        try {\n            if (param.data) {\n                param.data.forEach((o) => o.value = o.amount);\n            }\n            const tx = bitcoin.ValidSignedTransaction(param.tx, param.data, this.network());\n            return Promise.resolve((0, coin_base_1.jsonStringifyUniform)(tx));\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.validSignedTransactionError);\n        }\n    }\n    async estimateFee(param) {\n        try {\n            const type = param.data.type || 0;\n            if (type === bitcoin.BtcXrcTypes.INSCRIBE) {\n                return Promise.reject(coin_base_1.EstimateFeeError);\n            }\n            else if (type === bitcoin.BtcXrcTypes.PSBT) {\n                return Promise.reject(coin_base_1.EstimateFeeError);\n            }\n            else if (type === bitcoin.BtcXrcTypes.RUNE) {\n                try {\n                    let wallet = new index_1.RuneWallet();\n                    if (this.network() === index_1.networks.testnet) {\n                        wallet = new index_1.RuneTestWallet();\n                    }\n                    return Promise.resolve(wallet.estimateFee(param));\n                }\n                catch (e) {\n                    return Promise.reject(coin_base_1.EstimateFeeError);\n                }\n            }\n            else if (type === bitcoin.BtcXrcTypes.RUNEMAIN) {\n                try {\n                    let wallet = new index_1.RuneMainWallet();\n                    if (this.network() === index_1.networks.testnet) {\n                        wallet = new index_1.RuneMainTestWallet();\n                    }\n                    return Promise.resolve(wallet.estimateFee(param));\n                }\n                catch (e) {\n                    return Promise.reject(coin_base_1.EstimateFeeError);\n                }\n            }\n            else if (type === bitcoin.BtcXrcTypes.ARC20) {\n                try {\n                    let wallet = new index_1.AtomicalWallet();\n                    if (this.network() === index_1.networks.testnet) {\n                        wallet = new index_1.AtomicalTestWallet();\n                    }\n                    return Promise.resolve(wallet.estimateFee(param));\n                }\n                catch (e) {\n                    return Promise.reject(coin_base_1.EstimateFeeError);\n                }\n            }\n            else {\n                const utxoTx = convert2UtxoTx(param.data);\n                const fee = bitcoin.estimateBtcFee(utxoTx, this.network());\n                return Promise.resolve(fee);\n            }\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.EstimateFeeError);\n        }\n    }\n    static async oneKeyBuildBtcTx(txData) {\n        try {\n            return Promise.resolve(bitcoin.oneKeyBuildBtcTx(txData));\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignTxError);\n        }\n    }\n    async buildPsbt(param) {\n        const type = param.data.type || 0;\n        if (type === bitcoin.BtcXrcTypes.RUNEMAIN) {\n            try {\n                let wallet = new index_1.RuneMainWallet();\n                if (this.network() === index_1.networks.testnet) {\n                    wallet = new index_1.RuneMainTestWallet();\n                }\n                return Promise.resolve(wallet.buildPsbt(param));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else {\n            let txHex = null;\n            try {\n                return Promise.resolve(txHex);\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n    }\n}\nexports.BtcWallet = BtcWallet;\nclass TBtcWallet extends BtcWallet {\n    network() {\n        return bitcoin.networks.testnet;\n    }\n}\nexports.TBtcWallet = TBtcWallet;\nfunction number2Hex(n, length) {\n    let s = n.toString(16);\n    const d = length - s.length;\n    if (d > 0) {\n        for (let i = 0; i < d; i++) {\n            s = "0" + s;\n        }\n    }\n    return s;\n}\nexports.number2Hex = number2Hex;\nfunction convert2UtxoTx(utxoTx) {\n    const tx = (0, coin_base_1.cloneObject)(utxoTx);\n    tx.inputs.forEach((it) => {\n        it.amount = (0, coin_base_1.convert2Number)(it.amount);\n    });\n    tx.outputs.forEach((it) => {\n        it.amount = (0, coin_base_1.convert2Number)(it.amount);\n    });\n    if (tx.omni) {\n        tx.omni.amount = (0, coin_base_1.convert2Number)(tx.omni.amount);\n    }\n    if (utxoTx.dustSize) {\n        tx.dustSize = (0, coin_base_1.convert2Number)(utxoTx.dustSize);\n    }\n    return tx;\n}\nexports.convert2UtxoTx = convert2UtxoTx;\n//# sourceMappingURL=BtcWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0J0Y1dhbGxldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsc0NBQXNDLEdBQUcsNkJBQTZCO0FBQzdKLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFvQjtBQUNoRCxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQsNkJBQTZCLG1CQUFPLENBQUMsMEVBQVU7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVU7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLG9HQUF1QjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQywwR0FBMEI7QUFDcEQsNkJBQTZCO0FBQzdCLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDRCQUE0QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNEJBQTRCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDRCQUE0QjtBQUNsRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDZDQUE2QztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw0QkFBNEI7QUFDbEYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw0QkFBNEI7QUFDdEYscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdURBQXVELDRCQUE0QjtBQUNuRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDRCQUE0QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNEJBQTRCO0FBQ2xGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUVBQWlFLDRCQUE0QjtBQUM3RjtBQUNBO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLHNEQUFzRCw2REFBNkQ7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0J0Y1dhbGxldC5qcz9iNmQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnZlcnQyVXR4b1R4ID0gZXhwb3J0cy5udW1iZXIySGV4ID0gZXhwb3J0cy5UQnRjV2FsbGV0ID0gZXhwb3J0cy5CdGNXYWxsZXQgPSBleHBvcnRzLkJJVENPSU5fTUVTU0FHRV9CSVAwMzIyX1NJTVBMRSA9IGV4cG9ydHMuQklUQ09JTl9NRVNTQUdFX0VDRFNBID0gdm9pZCAwO1xuY29uc3QgY29pbl9iYXNlXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY29pbi1iYXNlXCIpO1xuY29uc3QgY3J5cHRvX2xpYl8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NyeXB0by1saWJcIik7XG5jb25zdCBiaXRjb2luID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9pbmRleFwiKSk7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4uL2luZGV4XCIpO1xuY29uc3QgcHNidF8xID0gcmVxdWlyZShcIi4uL2JpdGNvaW5qcy1saWIvcHNidFwiKTtcbmNvbnN0IGJpcDAzMjJfMSA9IHJlcXVpcmUoXCIuLi9iaXRjb2luanMtbGliL2JpcDAzMjJcIik7XG5leHBvcnRzLkJJVENPSU5fTUVTU0FHRV9FQ0RTQSA9IDA7XG5leHBvcnRzLkJJVENPSU5fTUVTU0FHRV9CSVAwMzIyX1NJTVBMRSA9IDE7XG5jbGFzcyBCdGNXYWxsZXQgZXh0ZW5kcyBjb2luX2Jhc2VfMS5CYXNlV2FsbGV0IHtcbiAgICBuZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gYml0Y29pbi5uZXR3b3Jrcy5iaXRjb2luO1xuICAgIH1cbiAgICBhc3luYyBnZXREZXJpdmVkUGF0aChwYXJhbSkge1xuICAgICAgICBpZiAoIXBhcmFtLnNlZ3dpdFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgbS80NCcvMCcvMCcvMC8ke3BhcmFtLmluZGV4fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtLnNlZ3dpdFR5cGUgPT0gY29pbl9iYXNlXzEuc2Vnd2l0VHlwZS5TRUdXSVRfTkVTVEVEKSB7XG4gICAgICAgICAgICByZXR1cm4gYG0vODQnLzAnLzAnLzAvJHtwYXJhbS5pbmRleH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtLnNlZ3dpdFR5cGUgPT0gY29pbl9iYXNlXzEuc2Vnd2l0VHlwZS5TRUdXSVRfTkVTVEVEXzQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gYG0vNDknLzAnLzAnLzAvJHtwYXJhbS5pbmRleH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtLnNlZ3dpdFR5cGUgPT0gY29pbl9iYXNlXzEuc2Vnd2l0VHlwZS5TRUdXSVRfTkFUSVZFKSB7XG4gICAgICAgICAgICByZXR1cm4gYG0vODQnLzAnLzAnLzAvJHtwYXJhbS5pbmRleH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtLnNlZ3dpdFR5cGUgPT0gY29pbl9iYXNlXzEuc2Vnd2l0VHlwZS5TRUdXSVRfVEFQUk9PVCkge1xuICAgICAgICAgICAgcmV0dXJuIGBtLzg2Jy8wJy8wJy8wLyR7cGFyYW0uaW5kZXh9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5EZXJpdmVQYXRoRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHZhbGlkUHJpdmF0ZUtleShwYXJhbSkge1xuICAgICAgICBsZXQgaXNWYWxpZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gYml0Y29pbi53aWYuZGVjb2RlKHBhcmFtLnByaXZhdGVLZXkpO1xuICAgICAgICAgICAgaXNWYWxpZCA9ICh2ZXJzaW9uID09PSB0aGlzLm5ldHdvcmsoKS53aWYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBwYXJhbS5wcml2YXRlS2V5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5ld0FkZHJlc3MocGFyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrKCk7XG4gICAgICAgICAgICBsZXQgcHJpdmF0ZUtleSA9IHBhcmFtLnByaXZhdGVLZXk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzVHlwZSA9IHBhcmFtLmFkZHJlc3NUeXBlIHx8IFwiTGVnYWN5XCI7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBiaXRjb2luLndpZjJQdWJsaWMocHJpdmF0ZUtleSwgbmV0d29yayk7XG4gICAgICAgICAgICBsZXQgYWRkcmVzcztcbiAgICAgICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gXCJMZWdhY3lcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGJpdGNvaW4ucGF5bWVudHMucDJwa2goeyBwdWJrZXk6IHB1YmxpY0tleSwgbmV0d29yayB9KTtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gcmVzdWx0LmFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhZGRyZXNzVHlwZSA9PT0gXCJzZWd3aXRfbmF0aXZlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBiaXRjb2luLnBheW1lbnRzLnAyd3BraCh7IHB1YmtleTogcHVibGljS2V5LCBuZXR3b3JrIH0pO1xuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSByZXN1bHQuYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFkZHJlc3NUeXBlID09PSBcInNlZ3dpdF9uZXN0ZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGJpdGNvaW4ucGF5bWVudHMucDJzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJlZGVlbTogYml0Y29pbi5wYXltZW50cy5wMndwa2goeyBwdWJrZXk6IHB1YmxpY0tleSwgbmV0d29yayB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gcmVzdWx0LmFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhZGRyZXNzVHlwZSA9PT0gXCJzZWd3aXRfdGFwcm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYml0Y29pbi5wYXltZW50cy5wMnRyKHsgaW50ZXJuYWxQdWJrZXk6IHB1YmxpY0tleS5zbGljZSgxKSwgbmV0d29yayB9KTtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gcmVzdWx0LmFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgcHVibGljS2V5OiBjcnlwdG9fbGliXzEuYmFzZS50b0hleChhZGRyZXNzVHlwZSA9PT0gXCJzZWd3aXRfdGFwcm9vdFwiID8gcHVibGljS2V5LnNsaWNlKDEpIDogcHVibGljS2V5KSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2VkUHVibGljS2V5OiBjcnlwdG9fbGliXzEuYmFzZS50b0hleChwdWJsaWNLZXkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5OZXdBZGRyZXNzRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHZhbGlkQWRkcmVzcyhwYXJhbSkge1xuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBsZXQgbmV0d29yayA9IHRoaXMubmV0d29yaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IG91dHB1dFNjcmlwdCA9IGJpdGNvaW4uYWRkcmVzcy50b091dHB1dFNjcmlwdChwYXJhbS5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXRTY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbS5hZGRyZXNzVHlwZSkge1xuICAgICAgICAgICAgaXNWYWxpZCA9IHBhcmFtLmFkZHJlc3NUeXBlID09PSBiaXRjb2luLmdldEFkZHJlc3NUeXBlKHBhcmFtLmFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtLmFkZHJlc3NcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbS5kYXRhLnR5cGUgfHwgMDtcbiAgICAgICAgaWYgKHR5cGUgPT09IGJpdGNvaW4uQnRjWHJjVHlwZXMuSU5TQ1JJQkUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShiaXRjb2luLmluc2NyaWJlKHRoaXMubmV0d29yaygpLCBwYXJhbS5kYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5QU0JUKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYml0Y29pbi5wc2J0U2lnbihwYXJhbS5kYXRhLnBzYnQsIHBhcmFtLnByaXZhdGVLZXksIHRoaXMubmV0d29yaygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5QU0JUX0RFT0RFKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYml0Y29pbi5wc2J0RGVjb2RlKHBhcmFtLmRhdGEucHNidCwgdGhpcy5uZXR3b3JrKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25UeEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBiaXRjb2luLkJ0Y1hyY1R5cGVzLlBTQlRfTVBDX1VOU0lHTkVEX0xJU1QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShiaXRjb2luLmdlbmVyYXRlTVBDVW5zaWduZWRMaXN0aW5nUFNCVChwYXJhbS5kYXRhLnBzYnQsIHBhcmFtLmRhdGEucHVibGljS2V5LCB0aGlzLm5ldHdvcmsoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnblR4RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IGJpdGNvaW4uQnRjWHJjVHlwZXMuUFNCVF9NUENfU0lHTkVEX0xJU1QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShiaXRjb2luLmdlbmVyYXRlTVBDU2lnbmVkTGlzdGluZ1BTQlQocGFyYW0uZGF0YS5wc2J0LCBwYXJhbS5kYXRhLnB1YmxpY0tleSwgcGFyYW0uZGF0YS5zaWduYXR1cmUsIHRoaXMubmV0d29yaygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5QU0JUX01QQ19VTlNJR05FRF9CVVkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShiaXRjb2luLmdlbmVyYXRlTVBDVW5zaWduZWRCdXlpbmdQU0JUKHBhcmFtLmRhdGEucHNidCwgcGFyYW0uZGF0YS5wdWJsaWNLZXksIHRoaXMubmV0d29yaygpLCBwYXJhbS5kYXRhLmJhdGNoU2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnblR4RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IGJpdGNvaW4uQnRjWHJjVHlwZXMuUFNCVF9NUENfU0lHTkVEX0JVWSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJpdGNvaW4uZ2VuZXJhdGVNUENTaWduZWRCdXlpbmdUeChwYXJhbS5kYXRhLnBzYnQsIHBhcmFtLmRhdGEucHVibGljS2V5LCBwYXJhbS5kYXRhLnNpZ25hdHVyZUxpc3QsIHRoaXMubmV0d29yaygpLCBwYXJhbS5kYXRhLmJhdGNoU2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnblR4RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IGJpdGNvaW4uQnRjWHJjVHlwZXMuUFNCVF9NUENfVU5TSUdORUQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShiaXRjb2luLmdlbmVyYXRlTVBDVW5zaWduZWRQU0JUKHBhcmFtLmRhdGEucHNidCwgcGFyYW0uZGF0YS5wdWJsaWNLZXksIHRoaXMubmV0d29yaygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5QU0JUX01QQ19TSUdORUQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShiaXRjb2luLmdlbmVyYXRlTVBDU2lnbmVkUFNCVChwYXJhbS5kYXRhLnBzYnQsIHBhcmFtLmRhdGEucHVibGljS2V5LCBwYXJhbS5kYXRhLnNpZ25hdHVyZUxpc3QsIHRoaXMubmV0d29yaygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5QU0JUX0tFWV9TQ1JJUFRfUEFUSCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJpdGNvaW4uc2lnblBzYnRXaXRoS2V5UGF0aEFuZFNjcmlwdFBhdGgocGFyYW0uZGF0YS5wc2J0LCBwYXJhbS5wcml2YXRlS2V5LCB0aGlzLm5ldHdvcmsoKSwge1xuICAgICAgICAgICAgICAgICAgICBhdXRvRmluYWxpemVkOiBwYXJhbS5kYXRhLmF1dG9GaW5hbGl6ZWQsXG4gICAgICAgICAgICAgICAgICAgIHRvU2lnbklucHV0czogcGFyYW0uZGF0YS50b1NpZ25JbnB1dHNcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5QU0JUX0tFWV9TQ1JJUFRfUEFUSF9CQVRDSCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJpdGNvaW4uc2lnblBzYnRXaXRoS2V5UGF0aEFuZFNjcmlwdFBhdGhCYXRjaChwYXJhbS5kYXRhLnBzYnRIZXhzLCBwYXJhbS5wcml2YXRlS2V5LCB0aGlzLm5ldHdvcmsoKSwgcGFyYW0uZGF0YS5vcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5TUkMyMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJpdGNvaW4uc3JjSW5zY3JpYmUodGhpcy5uZXR3b3JrKCksIHBhcmFtLmRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25UeEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBiaXRjb2luLkJ0Y1hyY1R5cGVzLlJVTkUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHdhbGxldCA9IG5ldyBpbmRleF8xLlJ1bmVXYWxsZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrKCkgPT09IGluZGV4XzEubmV0d29ya3MudGVzdG5ldCkge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSBuZXcgaW5kZXhfMS5SdW5lVGVzdFdhbGxldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHdhbGxldC5zaWduVHJhbnNhY3Rpb24ocGFyYW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25UeEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBiaXRjb2luLkJ0Y1hyY1R5cGVzLlJVTkVNQUlOKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCB3YWxsZXQgPSBuZXcgaW5kZXhfMS5SdW5lTWFpbldhbGxldCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmsoKSA9PT0gaW5kZXhfMS5uZXR3b3Jrcy50ZXN0bmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldCA9IG5ldyBpbmRleF8xLlJ1bmVNYWluVGVzdFdhbGxldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHdhbGxldC5zaWduVHJhbnNhY3Rpb24ocGFyYW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25UeEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBiaXRjb2luLkJ0Y1hyY1R5cGVzLkFSQzIwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCB3YWxsZXQgPSBuZXcgaW5kZXhfMS5BdG9taWNhbFdhbGxldCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmsoKSA9PT0gaW5kZXhfMS5uZXR3b3Jrcy50ZXN0bmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldCA9IG5ldyBpbmRleF8xLkF0b21pY2FsVGVzdFdhbGxldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHdhbGxldC5zaWduVHJhbnNhY3Rpb24ocGFyYW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25UeEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBiaXRjb2luLkJ0Y1hyY1R5cGVzLlBTQlRfUlVORU1BSU4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHdhbGxldCA9IG5ldyBpbmRleF8xLlJ1bmVNYWluV2FsbGV0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV0d29yaygpID09PSBpbmRleF8xLm5ldHdvcmtzLnRlc3RuZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gbmV3IGluZGV4XzEuUnVuZU1haW5UZXN0V2FsbGV0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUod2FsbGV0LmJ1aWxkUHNidChwYXJhbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnblR4RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHR4SGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHBhcmFtLnByaXZhdGVLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXR4b1R4ID0gY29udmVydDJVdHhvVHgocGFyYW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgdHhIZXggPSBiaXRjb2luLnNpZ25CdGModXR4b1R4LCBwcml2YXRlS2V5LCB0aGlzLm5ldHdvcmsoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eEhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmFuZG9tUHJpdmF0ZUtleSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrKCk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBjcnlwdG9fbGliXzEuYmFzZS5yYW5kb21CeXRlcygzMik7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBjb2luX2Jhc2VfMS5zZWNwMjU2azFTaWduVGVzdCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lmID0gYml0Y29pbi5wcml2YXRlMldpZihwcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh3aWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLkdlblByaXZhdGVLZXlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVyaXZlZFByaXZhdGVLZXkocGFyYW0pIHtcbiAgICAgICAgbGV0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcmsoKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19saWJfMS5iaXAzOS5tbmVtb25pY1RvU2VlZChwYXJhbS5tbmVtb25pYylcbiAgICAgICAgICAgIC50aGVuKG1hc3RlclNlZWQgPT4ge1xuICAgICAgICAgICAgbGV0IGNoaWxkS2V5ID0gY3J5cHRvX2xpYl8xLmJpcDMyLmZyb21TZWVkKG1hc3RlclNlZWQpLmRlcml2ZVBhdGgocGFyYW0uaGRQYXRoKTtcbiAgICAgICAgICAgIGlmICghY2hpbGRLZXkucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5HZW5Qcml2YXRlS2V5RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lmID0gYml0Y29pbi5wcml2YXRlMldpZihjaGlsZEtleS5wcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUod2lmKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5HZW5Qcml2YXRlS2V5RXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QWRkcmVzc0J5UHVibGljS2V5KHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG9fbGliXzEuYmFzZS5mcm9tSGV4KHBhcmFtLnB1YmxpY0tleSk7XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmFkZHJlc3NUeXBlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzVHlwZTogXCJMZWdhY3lcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYml0Y29pbi5wYXltZW50cy5wMnBraCh7IHB1YmtleTogcHVibGljS2V5LCBuZXR3b3JrIH0pLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzVHlwZTogXCJzZWd3aXRfbmVzdGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGJpdGNvaW4ucGF5bWVudHMucDJzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWRlZW06IGJpdGNvaW4ucGF5bWVudHMucDJ3cGtoKHsgcHVia2V5OiBwdWJsaWNLZXksIG5ldHdvcmsgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzVHlwZTogXCJzZWd3aXRfbmF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGJpdGNvaW4ucGF5bWVudHMucDJ3cGtoKHsgcHVia2V5OiBwdWJsaWNLZXksIG5ldHdvcmsgfSkuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFkZHJlc3Nlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5hZGRyZXNzVHlwZSA9PT0gJ0xlZ2FjeScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJpdGNvaW4ucGF5bWVudHMucDJwa2goeyBwdWJrZXk6IHB1YmxpY0tleSwgbmV0d29yayB9KS5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmFkZHJlc3NUeXBlID09PSAnc2Vnd2l0X25lc3RlZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJpdGNvaW4ucGF5bWVudHMucDJzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJlZGVlbTogYml0Y29pbi5wYXltZW50cy5wMndwa2goeyBwdWJrZXk6IHB1YmxpY0tleSwgbmV0d29yayB9KSxcbiAgICAgICAgICAgICAgICB9KS5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmFkZHJlc3NUeXBlID09PSAnc2Vnd2l0X25hdGl2ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJpdGNvaW4ucGF5bWVudHMucDJ3cGtoKHsgcHVia2V5OiBwdWJsaWNLZXksIG5ldHdvcmsgfSkuYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5hZGRyZXNzVHlwZSA9PT0gJ3NlZ3dpdF90YXByb290Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYml0Y29pbi5wYXltZW50cy5wMnRyKHsgaW50ZXJuYWxQdWJrZXk6IHB1YmxpY0tleS5zbGljZSgxKSwgbmV0d29yayB9KS5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5OZXdBZGRyZXNzRXJyb3IpO1xuICAgIH1cbiAgICBnZXRNUENSYXdUcmFuc2FjdGlvbihwYXJhbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXR4b1R4ID0gY29udmVydDJVdHhvVHgocGFyYW0uZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gW107XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZFR4ID0gYml0Y29pbi5zaWduQnRjKHV0eG9UeCwgXCJcIiwgdGhpcy5uZXR3b3JrKCksIGhhc2gpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICByYXc6IHVuc2lnbmVkVHgsXG4gICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuR2V0TXBjUmF3VHJhbnNhY3Rpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TVBDVHJhbnNhY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IGJpdGNvaW4uZ2V0TVBDVHJhbnNhY3Rpb24ocGFyYW0ucmF3LCBwYXJhbS5zaWdzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5HZXRNcGNUcmFuc2FjdGlvbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRNUENSYXdNZXNzYWdlKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtc2dIYXNoID0gYXdhaXQgdGhpcy5zaWduTWVzc2FnZShwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgaGFzaDogbXNnSGFzaCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLkdldE1wY1Jhd1RyYW5zYWN0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE1QQ1NpZ25lZE1lc3NhZ2UocGFyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYml0Y29pbi5tZXNzYWdlLmdldE1QQ1NpZ25lZE1lc3NhZ2UocGFyYW0uaGFzaCwgcGFyYW0uc2lncywgcGFyYW0ucHVibGljS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5HZXRNcGNUcmFuc2FjdGlvbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRIYXJkV2FyZVJhd1RyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcGFyYW0uZGF0YS50eXBlIHx8IDA7XG4gICAgICAgICAgICBjb25zdCB1dHhvVHggPSBjb252ZXJ0MlV0eG9UeChwYXJhbS5kYXRhKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gYml0Y29pbi5zaWduQnRjKHV0eG9UeCwgXCJcIiwgdGhpcy5uZXR3b3JrKCksIHVuZGVmaW5lZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVzdFNpemUgPSB1dHhvVHguZHVzdFNpemUgfHwgNTQ2O1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChjaGFuZ2UpID49IGR1c3RTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZVV0eG8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB1dHhvVHguYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogcGFyc2VJbnQoY2hhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpcDMyRGVyaXZhdGlvbjogdXR4b1R4LmJpcDMyRGVyaXZhdGlvblxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB1dHhvVHgub3V0cHV0cy5wdXNoKGNoYW5nZVV0eG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoZXggPSBiaXRjb2luLmJ1aWxkUHNidCh1dHhvVHgsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXggPSBiaXRjb2luLnNpZ25CdGModXR4b1R4LCBcIlwiLCB0aGlzLm5ldHdvcmsoKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5HZXRIYXJkd2FyZVJhd1RyYW5zYWN0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNhbGNUeEhhc2gocGFyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHBhcmFtLmRhdGEpLmdldElkKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuQ2FsY1R4SGFzaEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW5Qc2J0T2ZCSVAzMjJTaW1wbGUoeyBtZXNzYWdlLCBhZGRyZXNzIH0pIHtcbiAgICAgICAgcmV0dXJuICgwLCBiaXAwMzIyXzEuZ2VuUHNidE9mQklQMzIyU2ltcGxlKSh7IG1lc3NhZ2U6IG1lc3NhZ2UsIGFkZHJlc3M6IGFkZHJlc3MsIG5ldHdvcms6IHRoaXMubmV0d29yaygpIH0pO1xuICAgIH1cbiAgICBnZXRTaWduYXR1cmVGcm9tUHNidE9mQklQMzIyU2ltcGxlKHR4RW5jb2RlZCkge1xuICAgICAgICBsZXQgdHggPSBwc2J0XzEuUHNidC5mcm9tQmFzZTY0KHR4RW5jb2RlZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0eC5maW5hbGl6ZUFsbElucHV0cygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9ICgwLCBiaXAwMzIyXzEuZ2V0U2lnbmF0dXJlRnJvbVBzYnRPZkJJUDMyMlNpbXBsZSkodHgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlZE1lc3NhZ2UgPSBwYXJhbS5kYXRhO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZTtcbiAgICAgICAgICAgIGlmICh0eXBlZE1lc3NhZ2UudHlwZSA9PT0gZXhwb3J0cy5CSVRDT0lOX01FU1NBR0VfRUNEU0EpIHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBiaXRjb2luLm1lc3NhZ2Uuc2lnbihwYXJhbS5wcml2YXRlS2V5LCB0eXBlZE1lc3NhZ2UubWVzc2FnZSwgdGhpcy5uZXR3b3JrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gYml0Y29pbi5iaXAwMzIyLnNpZ25TaW1wbGUodHlwZWRNZXNzYWdlLm1lc3NhZ2UsIHR5cGVkTWVzc2FnZS5hZGRyZXNzLCBwYXJhbS5wcml2YXRlS2V5LCB0aGlzLm5ldHdvcmsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduTXNnRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeU1lc3NhZ2UocGFyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkTWVzc2FnZSA9IHBhcmFtLmRhdGE7XG4gICAgICAgICAgICBpZiAodHlwZWRNZXNzYWdlLnR5cGUgPT09IGV4cG9ydHMuQklUQ09JTl9NRVNTQUdFX0VDRFNBKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gYml0Y29pbi5tZXNzYWdlLnZlcmlmeSh0eXBlZE1lc3NhZ2UucHVibGljS2V5LCB0eXBlZE1lc3NhZ2UubWVzc2FnZSwgcGFyYW0uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBiaXRjb2luLmJpcDAzMjIudmVyaWZ5U2ltcGxlKHR5cGVkTWVzc2FnZS5tZXNzYWdlLCB0eXBlZE1lc3NhZ2UuYWRkcmVzcywgcGFyYW0uc2lnbmF0dXJlLCB0eXBlZE1lc3NhZ2UucHVibGljS2V5LCB0aGlzLm5ldHdvcmsoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnbk1zZ0Vycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZXh0cmFjdFBzYnRUcmFuc2FjdGlvbih0eEhleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShiaXRjb2luLmV4dHJhY3RQc2J0VHJhbnNhY3Rpb24odHhIZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25Nc2dFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdmFsaWRTaWduZWRUcmFuc2FjdGlvbihwYXJhbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbS5kYXRhLmZvckVhY2goKG8pID0+IG8udmFsdWUgPSBvLmFtb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eCA9IGJpdGNvaW4uVmFsaWRTaWduZWRUcmFuc2FjdGlvbihwYXJhbS50eCwgcGFyYW0uZGF0YSwgdGhpcy5uZXR3b3JrKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgoMCwgY29pbl9iYXNlXzEuanNvblN0cmluZ2lmeVVuaWZvcm0pKHR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS52YWxpZFNpZ25lZFRyYW5zYWN0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlRmVlKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcGFyYW0uZGF0YS50eXBlIHx8IDA7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5JTlNDUklCRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5Fc3RpbWF0ZUZlZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IGJpdGNvaW4uQnRjWHJjVHlwZXMuUFNCVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5Fc3RpbWF0ZUZlZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IGJpdGNvaW4uQnRjWHJjVHlwZXMuUlVORSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3YWxsZXQgPSBuZXcgaW5kZXhfMS5SdW5lV2FsbGV0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmsoKSA9PT0gaW5kZXhfMS5uZXR3b3Jrcy50ZXN0bmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSBuZXcgaW5kZXhfMS5SdW5lVGVzdFdhbGxldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUod2FsbGV0LmVzdGltYXRlRmVlKHBhcmFtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5Fc3RpbWF0ZUZlZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBiaXRjb2luLkJ0Y1hyY1R5cGVzLlJVTkVNQUlOKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdhbGxldCA9IG5ldyBpbmRleF8xLlJ1bmVNYWluV2FsbGV0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmsoKSA9PT0gaW5kZXhfMS5uZXR3b3Jrcy50ZXN0bmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSBuZXcgaW5kZXhfMS5SdW5lTWFpblRlc3RXYWxsZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHdhbGxldC5lc3RpbWF0ZUZlZShwYXJhbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuRXN0aW1hdGVGZWVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5BUkMyMCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3YWxsZXQgPSBuZXcgaW5kZXhfMS5BdG9taWNhbFdhbGxldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrKCkgPT09IGluZGV4XzEubmV0d29ya3MudGVzdG5ldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gbmV3IGluZGV4XzEuQXRvbWljYWxUZXN0V2FsbGV0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh3YWxsZXQuZXN0aW1hdGVGZWUocGFyYW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLkVzdGltYXRlRmVlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHV0eG9UeCA9IGNvbnZlcnQyVXR4b1R4KHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZlZSA9IGJpdGNvaW4uZXN0aW1hdGVCdGNGZWUodXR4b1R4LCB0aGlzLm5ldHdvcmsoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuRXN0aW1hdGVGZWVFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIG9uZUtleUJ1aWxkQnRjVHgodHhEYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJpdGNvaW4ub25lS2V5QnVpbGRCdGNUeCh0eERhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25UeEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBidWlsZFBzYnQocGFyYW0pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcmFtLmRhdGEudHlwZSB8fCAwO1xuICAgICAgICBpZiAodHlwZSA9PT0gYml0Y29pbi5CdGNYcmNUeXBlcy5SVU5FTUFJTikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgd2FsbGV0ID0gbmV3IGluZGV4XzEuUnVuZU1haW5XYWxsZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrKCkgPT09IGluZGV4XzEubmV0d29ya3MudGVzdG5ldCkge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSBuZXcgaW5kZXhfMS5SdW5lTWFpblRlc3RXYWxsZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh3YWxsZXQuYnVpbGRQc2J0KHBhcmFtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5TaWduVHhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdHhIZXggPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHR4SGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25UeEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQnRjV2FsbGV0ID0gQnRjV2FsbGV0O1xuY2xhc3MgVEJ0Y1dhbGxldCBleHRlbmRzIEJ0Y1dhbGxldCB7XG4gICAgbmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIGJpdGNvaW4ubmV0d29ya3MudGVzdG5ldDtcbiAgICB9XG59XG5leHBvcnRzLlRCdGNXYWxsZXQgPSBUQnRjV2FsbGV0O1xuZnVuY3Rpb24gbnVtYmVyMkhleChuLCBsZW5ndGgpIHtcbiAgICBsZXQgcyA9IG4udG9TdHJpbmcoMTYpO1xuICAgIGNvbnN0IGQgPSBsZW5ndGggLSBzLmxlbmd0aDtcbiAgICBpZiAoZCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBcIjBcIiArIHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5leHBvcnRzLm51bWJlcjJIZXggPSBudW1iZXIySGV4O1xuZnVuY3Rpb24gY29udmVydDJVdHhvVHgodXR4b1R4KSB7XG4gICAgY29uc3QgdHggPSAoMCwgY29pbl9iYXNlXzEuY2xvbmVPYmplY3QpKHV0eG9UeCk7XG4gICAgdHguaW5wdXRzLmZvckVhY2goKGl0KSA9PiB7XG4gICAgICAgIGl0LmFtb3VudCA9ICgwLCBjb2luX2Jhc2VfMS5jb252ZXJ0Mk51bWJlcikoaXQuYW1vdW50KTtcbiAgICB9KTtcbiAgICB0eC5vdXRwdXRzLmZvckVhY2goKGl0KSA9PiB7XG4gICAgICAgIGl0LmFtb3VudCA9ICgwLCBjb2luX2Jhc2VfMS5jb252ZXJ0Mk51bWJlcikoaXQuYW1vdW50KTtcbiAgICB9KTtcbiAgICBpZiAodHgub21uaSkge1xuICAgICAgICB0eC5vbW5pLmFtb3VudCA9ICgwLCBjb2luX2Jhc2VfMS5jb252ZXJ0Mk51bWJlcikodHgub21uaS5hbW91bnQpO1xuICAgIH1cbiAgICBpZiAodXR4b1R4LmR1c3RTaXplKSB7XG4gICAgICAgIHR4LmR1c3RTaXplID0gKDAsIGNvaW5fYmFzZV8xLmNvbnZlcnQyTnVtYmVyKSh1dHhvVHguZHVzdFNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG59XG5leHBvcnRzLmNvbnZlcnQyVXR4b1R4ID0gY29udmVydDJVdHhvVHg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdGNXYWxsZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/DogeWallet.js':
    /*!**********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/DogeWallet.js ***!
  \**********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.DogeWallet = exports.dogeCoin = void 0;\nconst bitcoin = __importStar(__webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js"));\nconst coin_base_1 = __webpack_require__(/*! @okxweb3/coin-base */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js");\nconst BtcWallet_1 = __webpack_require__(/*! ./BtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js");\nexports.dogeCoin = {\n    messagePrefix: \'Dogecoin Signed Message:\\n\',\n    bech32: \'bc\',\n    bip32: {\n        public: 49990397,\n        private: 49988504,\n    },\n    pubKeyHash: 30,\n    scriptHash: 22,\n    wif: 158,\n};\nclass DogeWallet extends BtcWallet_1.BtcWallet {\n    network() {\n        return exports.dogeCoin;\n    }\n    async signTransaction(param) {\n        const type = param.data.type || 0;\n        if (type === 1) {\n            try {\n                return Promise.resolve(bitcoin.dogInscribe(exports.dogeCoin, param.data));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else if (type === 2) {\n            try {\n                return Promise.resolve(bitcoin.psbtSign(param.data.psbt, param.privateKey, this.network(), param.data.maximumFeeRate ? param.data.maximumFeeRate : 100000));\n            }\n            catch (e) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n        }\n        else {\n            return super.signTransaction(param);\n        }\n    }\n    signMessage(param) {\n        try {\n            const typedMessage = param.data;\n            let signature = bitcoin.message.sign(param.privateKey, typedMessage.message, this.network(), exports.dogeCoin.messagePrefix);\n            return Promise.resolve(signature);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignMsgError);\n        }\n    }\n    async verifyMessage(param) {\n        try {\n            const typedMessage = param.data;\n            const ret = bitcoin.message.verify(typedMessage.publicKey, typedMessage.message, param.signature, exports.dogeCoin.messagePrefix);\n            return Promise.resolve(ret);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignMsgError);\n        }\n    }\n}\nexports.DogeWallet = DogeWallet;\n//# sourceMappingURL=DogeWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0RvZ2VXYWxsZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGdCQUFnQjtBQUNyQyw2QkFBNkIsbUJBQU8sQ0FBQywwRUFBVTtBQUMvQyxvQkFBb0IsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsd0ZBQWE7QUFDekMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0RvZ2VXYWxsZXQuanM/NDQwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Eb2dlV2FsbGV0ID0gZXhwb3J0cy5kb2dlQ29pbiA9IHZvaWQgMDtcbmNvbnN0IGJpdGNvaW4gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2luZGV4XCIpKTtcbmNvbnN0IGNvaW5fYmFzZV8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NvaW4tYmFzZVwiKTtcbmNvbnN0IEJ0Y1dhbGxldF8xID0gcmVxdWlyZShcIi4vQnRjV2FsbGV0XCIpO1xuZXhwb3J0cy5kb2dlQ29pbiA9IHtcbiAgICBtZXNzYWdlUHJlZml4OiAnRG9nZWNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgICBiZWNoMzI6ICdiYycsXG4gICAgYmlwMzI6IHtcbiAgICAgICAgcHVibGljOiA0OTk5MDM5NyxcbiAgICAgICAgcHJpdmF0ZTogNDk5ODg1MDQsXG4gICAgfSxcbiAgICBwdWJLZXlIYXNoOiAzMCxcbiAgICBzY3JpcHRIYXNoOiAyMixcbiAgICB3aWY6IDE1OCxcbn07XG5jbGFzcyBEb2dlV2FsbGV0IGV4dGVuZHMgQnRjV2FsbGV0XzEuQnRjV2FsbGV0IHtcbiAgICBuZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5kb2dlQ29pbjtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbS5kYXRhLnR5cGUgfHwgMDtcbiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShiaXRjb2luLmRvZ0luc2NyaWJlKGV4cG9ydHMuZG9nZUNvaW4sIHBhcmFtLmRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25UeEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYml0Y29pbi5wc2J0U2lnbihwYXJhbS5kYXRhLnBzYnQsIHBhcmFtLnByaXZhdGVLZXksIHRoaXMubmV0d29yaygpLCBwYXJhbS5kYXRhLm1heGltdW1GZWVSYXRlID8gcGFyYW0uZGF0YS5tYXhpbXVtRmVlUmF0ZSA6IDEwMDAwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnblR4RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnNpZ25UcmFuc2FjdGlvbihwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UocGFyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkTWVzc2FnZSA9IHBhcmFtLmRhdGE7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gYml0Y29pbi5tZXNzYWdlLnNpZ24ocGFyYW0ucHJpdmF0ZUtleSwgdHlwZWRNZXNzYWdlLm1lc3NhZ2UsIHRoaXMubmV0d29yaygpLCBleHBvcnRzLmRvZ2VDb2luLm1lc3NhZ2VQcmVmaXgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnbk1zZ0Vycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB2ZXJpZnlNZXNzYWdlKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlZE1lc3NhZ2UgPSBwYXJhbS5kYXRhO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gYml0Y29pbi5tZXNzYWdlLnZlcmlmeSh0eXBlZE1lc3NhZ2UucHVibGljS2V5LCB0eXBlZE1lc3NhZ2UubWVzc2FnZSwgcGFyYW0uc2lnbmF0dXJlLCBleHBvcnRzLmRvZ2VDb2luLm1lc3NhZ2VQcmVmaXgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnbk1zZ0Vycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRG9nZVdhbGxldCA9IERvZ2VXYWxsZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Eb2dlV2FsbGV0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/DogeWallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/LtcWallet.js':
    /*!*********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/LtcWallet.js ***!
  \*********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.LtcWallet = exports.litecoin = void 0;\nconst coin_base_1 = __webpack_require__(/*! @okxweb3/coin-base */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js");\nconst BtcWallet_1 = __webpack_require__(/*! ./BtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js");\nconst bitcoin = __importStar(__webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js"));\nexports.litecoin = {\n    messagePrefix: \'Litecoin Signed Message:\\n\',\n    bech32: \'ltc\',\n    bip32: {\n        public: 0x019da462,\n        private: 0x019d9cfe,\n    },\n    pubKeyHash: 0x30,\n    scriptHash: 0x32,\n    wif: 0xb0,\n};\nclass LtcWallet extends BtcWallet_1.BtcWallet {\n    network() {\n        return exports.litecoin;\n    }\n    async getDerivedPath(param) {\n        if (!param.segwitType) {\n            return `m/44\'/2\'/0\'/0/${param.index}`;\n        }\n        if (param.segwitType == coin_base_1.segwitType.SEGWIT_NESTED) {\n            return `m/84\'/2\'/0\'/0/${param.index}`;\n        }\n        else if (param.segwitType == coin_base_1.segwitType.SEGWIT_NESTED_49) {\n            return `m/49\'/2\'/0\'/0/${param.index}`;\n        }\n        else if (param.segwitType == coin_base_1.segwitType.SEGWIT_NATIVE) {\n            return `m/84\'/2\'/0\'/0/${param.index}`;\n        }\n        else {\n            return Promise.reject(coin_base_1.DerivePathError);\n        }\n    }\n    signMessage(param) {\n        try {\n            const typedMessage = param.data;\n            let signature = bitcoin.message.sign(param.privateKey, typedMessage.message, this.network(), exports.litecoin.messagePrefix);\n            return Promise.resolve(signature);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignMsgError);\n        }\n    }\n    async verifyMessage(param) {\n        try {\n            const typedMessage = param.data;\n            const ret = bitcoin.message.verify(typedMessage.publicKey, typedMessage.message, param.signature, exports.litecoin.messagePrefix);\n            return Promise.resolve(ret);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignMsgError);\n        }\n    }\n}\nexports.LtcWallet = LtcWallet;\n//# sourceMappingURL=LtcWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L0x0Y1dhbGxldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsZ0JBQWdCO0FBQ3BDLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFvQjtBQUNoRCxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBYTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQywwRUFBVTtBQUMvQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC93YWxsZXQvTHRjV2FsbGV0LmpzP2QwOGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTHRjV2FsbGV0ID0gZXhwb3J0cy5saXRlY29pbiA9IHZvaWQgMDtcbmNvbnN0IGNvaW5fYmFzZV8xID0gcmVxdWlyZShcIkBva3h3ZWIzL2NvaW4tYmFzZVwiKTtcbmNvbnN0IEJ0Y1dhbGxldF8xID0gcmVxdWlyZShcIi4vQnRjV2FsbGV0XCIpO1xuY29uc3QgYml0Y29pbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vaW5kZXhcIikpO1xuZXhwb3J0cy5saXRlY29pbiA9IHtcbiAgICBtZXNzYWdlUHJlZml4OiAnTGl0ZWNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgICBiZWNoMzI6ICdsdGMnLFxuICAgIGJpcDMyOiB7XG4gICAgICAgIHB1YmxpYzogMHgwMTlkYTQ2MixcbiAgICAgICAgcHJpdmF0ZTogMHgwMTlkOWNmZSxcbiAgICB9LFxuICAgIHB1YktleUhhc2g6IDB4MzAsXG4gICAgc2NyaXB0SGFzaDogMHgzMixcbiAgICB3aWY6IDB4YjAsXG59O1xuY2xhc3MgTHRjV2FsbGV0IGV4dGVuZHMgQnRjV2FsbGV0XzEuQnRjV2FsbGV0IHtcbiAgICBuZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5saXRlY29pbjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGVyaXZlZFBhdGgocGFyYW0pIHtcbiAgICAgICAgaWYgKCFwYXJhbS5zZWd3aXRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gYG0vNDQnLzInLzAnLzAvJHtwYXJhbS5pbmRleH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbS5zZWd3aXRUeXBlID09IGNvaW5fYmFzZV8xLnNlZ3dpdFR5cGUuU0VHV0lUX05FU1RFRCkge1xuICAgICAgICAgICAgcmV0dXJuIGBtLzg0Jy8yJy8wJy8wLyR7cGFyYW0uaW5kZXh9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbS5zZWd3aXRUeXBlID09IGNvaW5fYmFzZV8xLnNlZ3dpdFR5cGUuU0VHV0lUX05FU1RFRF80OSkge1xuICAgICAgICAgICAgcmV0dXJuIGBtLzQ5Jy8yJy8wJy8wLyR7cGFyYW0uaW5kZXh9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbS5zZWd3aXRUeXBlID09IGNvaW5fYmFzZV8xLnNlZ3dpdFR5cGUuU0VHV0lUX05BVElWRSkge1xuICAgICAgICAgICAgcmV0dXJuIGBtLzg0Jy8yJy8wJy8wLyR7cGFyYW0uaW5kZXh9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5EZXJpdmVQYXRoRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlZE1lc3NhZ2UgPSBwYXJhbS5kYXRhO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IGJpdGNvaW4ubWVzc2FnZS5zaWduKHBhcmFtLnByaXZhdGVLZXksIHR5cGVkTWVzc2FnZS5tZXNzYWdlLCB0aGlzLm5ldHdvcmsoKSwgZXhwb3J0cy5saXRlY29pbi5tZXNzYWdlUHJlZml4KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25Nc2dFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5TWVzc2FnZShwYXJhbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHlwZWRNZXNzYWdlID0gcGFyYW0uZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGJpdGNvaW4ubWVzc2FnZS52ZXJpZnkodHlwZWRNZXNzYWdlLnB1YmxpY0tleSwgdHlwZWRNZXNzYWdlLm1lc3NhZ2UsIHBhcmFtLnNpZ25hdHVyZSwgZXhwb3J0cy5saXRlY29pbi5tZXNzYWdlUHJlZml4KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25Nc2dFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkx0Y1dhbGxldCA9IEx0Y1dhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUx0Y1dhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/LtcWallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/RuneMainWallet.js':
    /*!**************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/RuneMainWallet.js ***!
  \**************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.RuneMainTestWallet = exports.RuneMainWallet = exports.ErrCodeMultipleRuneId = exports.ErrCodeRuneIdNotStandard = exports.ErrCodeOpreturnExceeds = exports.ErrCodeLessRunesMainAmt = void 0;\nconst coin_base_1 = __webpack_require__(/*! @okxweb3/coin-base */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js");\nconst BtcWallet_1 = __webpack_require__(/*! ./BtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js");\nconst bitcoin = __importStar(__webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js"));\nconst index_1 = __webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js");\nconst rune_1 = __webpack_require__(/*! ../rune */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/rune.js");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nexports.ErrCodeLessRunesMainAmt = 2010300;\nexports.ErrCodeOpreturnExceeds = 2010301;\nexports.ErrCodeRuneIdNotStandard = 2010302;\nexports.ErrCodeMultipleRuneId = 2010303;\nclass RuneMainWallet extends BtcWallet_1.BtcWallet {\n    convert2RuneTx(paramData) {\n        const clonedParamData = (0, coin_base_1.cloneObject)(paramData);\n        if (clonedParamData.runeData.useDefaultOutput == true && clonedParamData.runeData.defaultOutput == undefined) {\n            clonedParamData.runeData.defaultOutput = 0;\n        }\n        if (clonedParamData.runeData.mint == true && clonedParamData.runeData.mintNum == undefined) {\n            clonedParamData.runeData.mintNUm = 1;\n        }\n        for (let input of clonedParamData.inputs) {\n            let dataArray = input.data;\n            if (dataArray != null && dataArray instanceof Array) {\n                for (let data of dataArray) {\n                    if (typeof data["amount"] === "string") {\n                        if (clonedParamData.runeData.mint) {\n                            data["amount"] = BigInt(1);\n                        }\n                        else {\n                            data["amount"] = BigInt(data["amount"]);\n                        }\n                    }\n                }\n            }\n        }\n        for (let output of clonedParamData.outputs) {\n            let dataArray = output.data;\n            if (dataArray != null && dataArray instanceof Array) {\n                for (let data of dataArray) {\n                    if (typeof data["amount"] === "string") {\n                        if (clonedParamData.runeData.mint) {\n                            data["amount"] = BigInt(1);\n                        }\n                        else {\n                            data["amount"] = BigInt(data["amount"]);\n                        }\n                    }\n                }\n            }\n        }\n        let inputs = clonedParamData.inputs;\n        const runeInputMap = new Map();\n        for (const input of inputs) {\n            let dataArray = input.data;\n            if (dataArray != null && dataArray instanceof Array) {\n                for (const data of dataArray) {\n                    let runeId = data["id"];\n                    let runeAmount = BigInt(1);\n                    if (!clonedParamData.runeData.mint) {\n                        runeAmount = BigInt(data["amount"]);\n                    }\n                    if (runeId == null || runeAmount == null) {\n                        continue;\n                    }\n                    if (runeId.split(":").length <= 1) {\n                        throw new Error(JSON.stringify({ errCode: exports.ErrCodeRuneIdNotStandard, date: { runeId: runeId } }));\n                    }\n                    let beforeAmount = runeInputMap.get(runeId);\n                    if (beforeAmount == null) {\n                        runeInputMap.set(runeId, runeAmount);\n                    }\n                    else {\n                        runeInputMap.set(runeId, (BigInt(beforeAmount) + BigInt(runeAmount)));\n                    }\n                }\n            }\n        }\n        if (runeInputMap.size > 1) {\n            throw new Error(JSON.stringify({ errCode: exports.ErrCodeMultipleRuneId, date: { runeInputMapSize: runeInputMap.size } }));\n        }\n        let outputs = clonedParamData.outputs;\n        const runeSendMap = new Map();\n        for (const output of outputs) {\n            let data = output.data;\n            if (data != null) {\n                let runeId = data["id"];\n                let runeAmount = BigInt(1);\n                if (!clonedParamData.runeData.mint) {\n                    runeAmount = BigInt(data["amount"]);\n                }\n                if (runeId == null || runeAmount == null) {\n                    continue;\n                }\n                let beforeAmount = runeSendMap.get(runeId);\n                if (beforeAmount == null) {\n                    runeSendMap.set(runeId, runeAmount);\n                }\n                else {\n                    runeSendMap.set(runeId, (BigInt(beforeAmount) + BigInt(runeAmount)));\n                }\n            }\n        }\n        let isRuneChange = false;\n        for (const id of runeInputMap.keys()) {\n            let inputAmount = runeInputMap.get(id);\n            let sendAmount = runeSendMap.get(id);\n            if ((inputAmount != null && sendAmount != null && inputAmount > sendAmount) || (inputAmount != null && sendAmount == null)) {\n                if (clonedParamData.runeData.useDefaultOutput == false) {\n                    isRuneChange = true;\n                }\n            }\n        }\n        let outputIndex = 0;\n        let updateOutputs = [];\n        if (isRuneChange) {\n            let runeChange = {\n                address: clonedParamData.address,\n                amount: 546\n            };\n            updateOutputs.push(runeChange);\n            outputIndex++;\n        }\n        const typedEdicts = [];\n        for (const output of outputs) {\n            let data = output.data;\n            if (data != null) {\n                let runeId = data["id"];\n                let runeAmount = BigInt(1);\n                if (!clonedParamData.runeData.mint) {\n                    runeAmount = BigInt(data["amount"]);\n                }\n                if (runeId == null || runeAmount == null) {\n                    continue;\n                }\n                const typedEdict = {\n                    block: parseInt(runeId.split(":")[0]),\n                    id: parseInt(runeId.split(":")[1]),\n                    amount: BigInt(runeAmount),\n                    output: outputIndex,\n                };\n                typedEdicts.push(typedEdict);\n            }\n            output.data = null;\n            updateOutputs.push(output);\n            outputIndex++;\n        }\n        if (clonedParamData.runeData.useDefaultOutput == true && clonedParamData.runeData.defaultOutput > updateOutputs.length - 1) {\n            throw new Error(JSON.stringify({\n                errCode: exports.ErrCodeLessRunesMainAmt,\n                date: {\n                    defaultOutput: clonedParamData.runeData.defaultOutput,\n                    ouputLenth: updateOutputs.length\n                }\n            }));\n        }\n        return {\n            inputs: clonedParamData.inputs,\n            outputs: updateOutputs,\n            address: clonedParamData.address,\n            feePerB: clonedParamData.feePerB,\n            runeData: {\n                edicts: typedEdicts,\n                etching: clonedParamData.runeData.etching,\n                burn: clonedParamData.runeData.burn,\n                defaultOutput: clonedParamData.runeData.defaultOutput,\n                mint: clonedParamData.runeData.mint,\n                mintNum: clonedParamData.runeData.mintNum,\n            },\n        };\n    }\n    getMockMinRuneTx(paramData, curRuneInfo) {\n        const clonedParamData = (0, coin_base_1.cloneObject)(paramData);\n        const typedEdicts = [];\n        const typedEdict = {\n            block: parseInt(curRuneInfo.id.split(":")[0]),\n            id: parseInt(curRuneInfo.id.split(":")[1]),\n            amount: BigInt(1),\n            output: 0,\n        };\n        typedEdicts.push(typedEdict);\n        return {\n            inputs: [{\n                    txId: clonedParamData.inputs[0].txId,\n                    vOut: 0,\n                    amount: 600,\n                    data: [curRuneInfo]\n                }],\n            outputs: [{\n                    address: clonedParamData.address,\n                    amount: 546,\n                    data: curRuneInfo\n                }],\n            address: clonedParamData.address,\n            feePerB: clonedParamData.feePerB,\n            runeData: {\n                edicts: typedEdicts,\n                etching: clonedParamData.runeData.etching,\n                burn: clonedParamData.runeData.burn,\n                defaultOutput: clonedParamData.runeData.defaultOutput,\n                mint: clonedParamData.runeData.mint,\n                mintNum: clonedParamData.runeData.mintNum,\n            },\n        };\n    }\n    getMinRuneTx(paramData, curRuneInfo, curInput, curOutput) {\n        const clonedParamData = (0, coin_base_1.cloneObject)(paramData);\n        return {\n            inputs: [curInput],\n            outputs: [curOutput],\n            address: clonedParamData.address,\n            feePerB: clonedParamData.feePerB,\n            RuneData: clonedParamData.runeData,\n        };\n    }\n    async signTransaction(param) {\n        const network = this.network();\n        let txHex = null;\n        if (param.data.runeData.mintNum == undefined || param.data.runeData.mintNum <= 1) {\n            try {\n                const privateKey = param.privateKey;\n                if (!param.data.runeData) {\n                    return Promise.reject("missing runeData");\n                }\n                const runeTx = this.convert2RuneTx(param.data);\n                const opReturnOutput = this.getRuneMainOpReturnOutput(network, runeTx.runeData);\n                runeTx.outputs.push(opReturnOutput);\n                txHex = (0, index_1.signBtc)(runeTx, privateKey, network);\n                return Promise.resolve(txHex);\n            }\n            catch (e) {\n                return Promise.reject(e);\n            }\n        }\n        else if (param.data.runeData.mint && !param.data.runeData.serialMint) {\n            try {\n                let txHexs = [];\n                const privateKey = param.privateKey;\n                if (!param.data.runeData) {\n                    return Promise.reject("missing runeData");\n                }\n                let mintData = {\n                    id: param.data.outputs[0].data.id,\n                    amount: param.data.outputs[0].data.amount,\n                    mintNum: param.data.runeData.mintNum,\n                };\n                let baseMintTx = this.getMockMinRuneTx(param.data, mintData);\n                const opMintReturnOutput = this.getRuneMainOpReturnOutput(network, baseMintTx.runeData);\n                baseMintTx.outputs.push(opMintReturnOutput);\n                txHex = (0, index_1.signBtc)(baseMintTx, privateKey, network);\n                const baseMintfee = bitcoin.estimateBtcFee(baseMintTx, this.network()) + 546;\n                const runeTx = this.convert2RuneTx(param.data);\n                let batchMintStatNum = runeTx.outputs.length;\n                for (let i = 0; i < mintData.mintNum - 1; i++) {\n                    runeTx.outputs.push({\n                        address: param.data.address,\n                        amount: baseMintfee,\n                    });\n                }\n                const opReturnOutput = this.getRuneMainOpReturnOutput(network, runeTx.runeData);\n                runeTx.outputs.push(opReturnOutput);\n                txHex = (0, index_1.signBtc)(runeTx, privateKey, network);\n                const parentTxId = index_1.Transaction.fromHex(txHex).getId();\n                txHexs.push(txHex);\n                for (let i = 0; i < mintData.mintNum - 1; i++) {\n                    let curInput = {\n                        txId: parentTxId,\n                        vOut: batchMintStatNum,\n                        address: param.data.address,\n                        amount: baseMintfee,\n                        data: [mintData]\n                    };\n                    let curOutput = {\n                        address: param.data.address,\n                        amount: 546\n                    };\n                    batchMintStatNum += 1;\n                    let curSubTx = this.getMinRuneTx(param.data, mintData, curInput, curOutput);\n                    curSubTx.outputs.push(opReturnOutput);\n                    let curSubTxHex = (0, index_1.signBtc)(curSubTx, privateKey, network);\n                    txHexs.push(curSubTxHex);\n                }\n                return Promise.resolve(txHexs);\n            }\n            catch (e) {\n                return Promise.reject(e);\n            }\n        }\n        else {\n            try {\n                let txHexs = [];\n                const privateKey = param.privateKey;\n                if (!param.data.runeData) {\n                    return Promise.reject("missing runeData");\n                }\n                let mintData = {\n                    id: param.data.outputs[0].data.id,\n                    amount: 1,\n                    mintNum: param.data.runeData.mintNum,\n                };\n                let baseMintTx = this.getMockMinRuneTx(param.data, mintData);\n                const opMintReturnOutput = (0, rune_1.buildRuneMainMintOp)(mintData.id, false, 0, true);\n                baseMintTx.outputs.push(opMintReturnOutput);\n                const baseMintfee = bitcoin.estimateBtcFee(baseMintTx, this.network());\n                let curAmount = (mintData.mintNum - 1) * baseMintfee + 546;\n                const runeTx = this.convert2RuneTxSerialMint(param.data, curAmount);\n                runeTx.outputs.push(opMintReturnOutput);\n                txHex = (0, index_1.signBtc)(runeTx, privateKey, network);\n                let parentTxId = index_1.Transaction.fromHex(txHex).getId();\n                txHexs.push(txHex);\n                for (let i = 1; i < mintData.mintNum; i++) {\n                    let curInput = {\n                        txId: parentTxId,\n                        vOut: 0,\n                        address: param.data.address,\n                        amount: curAmount\n                    };\n                    curAmount = curAmount - baseMintfee;\n                    let curOutput = {\n                        address: param.data.address,\n                        amount: curAmount\n                    };\n                    let curSubTx = this.getMinRuneTx(param.data, mintData, curInput, curOutput);\n                    curSubTx.outputs.push(opMintReturnOutput);\n                    let curSubTxHex = (0, index_1.signBtc)(curSubTx, privateKey, network);\n                    parentTxId = index_1.Transaction.fromHex(curSubTxHex).getId();\n                    txHexs.push(curSubTxHex);\n                }\n                return txHexs;\n            }\n            catch (e) {\n                return Promise.reject(e);\n            }\n        }\n    }\n    getRuneMainOpReturnOutput(network, runeData) {\n        let isMainnet = false;\n        if (index_1.networks.bitcoin === network) {\n            isMainnet = true;\n        }\n        if (runeData.useDefaultOutput == undefined) {\n            runeData.useDefaultOutput = false;\n        }\n        if (runeData.defaultOutput == undefined) {\n            runeData.defaultOutput = 0;\n        }\n        if (runeData.mint == undefined) {\n            runeData.mint = false;\n        }\n        if (runeData.mintNum == undefined) {\n            runeData.mintNum = 0;\n        }\n        const opReturnScript = (0, rune_1.buildRuneMainMintData)(isMainnet, runeData.edicts, runeData.useDefaultOutput, runeData.defaultOutput, runeData.mint, runeData.mintNum);\n        return { address: \'\', amount: 0, omniScript: crypto_lib_1.base.toHex(opReturnScript) };\n    }\n    async estimateFee(param) {\n        try {\n            const network = this.network();\n            if (!param.data.runeData) {\n                return Promise.reject("missing runeData");\n            }\n            const runeTx = this.convert2RuneTx(param.data);\n            const opReturnOutput = this.getRuneMainOpReturnOutput(this.network(), runeTx.runeData);\n            runeTx.outputs.push(opReturnOutput);\n            let mintData = {\n                id: param.data.outputs[0].data.id,\n                amount: param.data.outputs[0].data.amount,\n                mintNum: param.data.runeData.mintNum,\n            };\n            let batchMintStatNum = runeTx.outputs.length;\n            for (let i = 0; i < mintData.mintNum - 1; i++) {\n                runeTx.outputs.push({\n                    address: param.data.address,\n                    amount: 8000,\n                });\n            }\n            const fee = bitcoin.estimateBtcFee(runeTx, this.network());\n            if (param.data.runeData.mintNum == undefined || param.data.runeData.mintNum <= 1) {\n                return Promise.resolve(fee);\n            }\n            else if (param.data.runeData.mint && !param.data.runeData.serialMint) {\n                let fees = [];\n                fees.push(fee);\n                let mintData = {\n                    id: param.data.outputs[0].data.id,\n                    amount: param.data.outputs[0].data.amount,\n                    mintNum: param.data.runeData.mintNum,\n                };\n                let baseMintTx = this.getMockMinRuneTx(param.data, mintData);\n                const opMintReturnOutput = this.getRuneMainOpReturnOutput(this.network(), baseMintTx.runeData);\n                baseMintTx.outputs.push(opMintReturnOutput);\n                const baseMintfee = bitcoin.estimateBtcFee(baseMintTx, this.network());\n                for (let i = 0; i < param.data.runeData.mintNum - 1; i++) {\n                    fees.push(baseMintfee);\n                }\n                return Promise.resolve(fees);\n            }\n            else if (param.data.runeData.mint && param.data.runeData.serialMint) {\n                let fees = [];\n                if (!param.data.runeData) {\n                    return Promise.reject("missing runeData");\n                }\n                let mintData = {\n                    id: param.data.outputs[0].data.id,\n                    amount: 1,\n                    mintNum: param.data.runeData.mintNum,\n                };\n                let baseMintTx = this.getMockMinRuneTx(param.data, mintData);\n                const opMintReturnOutput = (0, rune_1.buildRuneMainMintOp)(mintData.id, false, 0, true);\n                baseMintTx.outputs.push(opMintReturnOutput);\n                const baseMintfee = bitcoin.estimateBtcFee(baseMintTx, this.network());\n                let curAmount = (mintData.mintNum - 1) * baseMintfee + 546;\n                const runeTx = this.convert2RuneTxSerialMint(param.data, curAmount);\n                runeTx.outputs.push(opMintReturnOutput);\n                let fee = bitcoin.estimateBtcFee(runeTx, network);\n                fees.push(fee);\n                for (let i = 1; i < mintData.mintNum; i++) {\n                    fees.push(baseMintfee);\n                }\n                return Promise.resolve(fees);\n            }\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    convert2RuneTxSerialMint(paramData, outputAmount) {\n        const clonedParamData = (0, coin_base_1.cloneObject)(paramData);\n        let curOutputs = [{\n                address: clonedParamData.address,\n                amount: outputAmount\n            }];\n        return {\n            inputs: clonedParamData.inputs,\n            outputs: curOutputs,\n            address: clonedParamData.address,\n            feePerB: clonedParamData.feePerB,\n            runeData: {\n                edicts: clonedParamData.runeData.edicts,\n                etching: clonedParamData.runeData.etching,\n                burn: clonedParamData.runeData.burn,\n                defaultOutput: clonedParamData.runeData.defaultOutput,\n                mint: clonedParamData.runeData.mint,\n                mintNum: clonedParamData.runeData.mintNum,\n            },\n        };\n    }\n    convert2RuneTxPsbt(paramData) {\n        const clonedParamData = (0, coin_base_1.cloneObject)(paramData);\n        return {\n            inputs: clonedParamData.inputs,\n            outputs: clonedParamData.outputs,\n            address: clonedParamData.address,\n            feePerB: clonedParamData.feePerB,\n            runeData: {\n                edicts: clonedParamData.runeData.edicts,\n                etching: clonedParamData.runeData.etching,\n                burn: clonedParamData.runeData.burn,\n                defaultOutput: clonedParamData.runeData.defaultOutput,\n                mint: clonedParamData.runeData.mint,\n                mintNum: clonedParamData.runeData.mintNum,\n            },\n        };\n    }\n    async buildPsbt(param) {\n        const network = this.network();\n        let txHex = null;\n        try {\n            const privateKey = param.privateKey;\n            if (!param.data.runeData) {\n                return Promise.reject("missing runeData");\n            }\n            const runeTx = this.convert2RuneTxPsbt(param.data);\n            const opReturnOutput = this.getRuneMainOpReturnOutput(network, runeTx.runeData);\n            runeTx.outputs.push(opReturnOutput);\n            let fakeAddr = "KwdkfXMV2wxDVDMPPuFZsio3NeCskAUd4N2U4PriTgpj2MqAGmmc";\n            if (runeTx.dustSize == undefined) {\n                runeTx.dustSize = 546;\n            }\n            let { inputAmount, outputAmount, virtualSize } = (0, index_1.calculateTxSize)(runeTx.inputs, runeTx.outputs, runeTx.address, fakeAddr, network, runeTx.dustSize);\n            let changeAmount = inputAmount - outputAmount - virtualSize * runeTx.feePerB;\n            if (changeAmount > runeTx.dustSize) {\n                runeTx.outputs.push({ address: runeTx.address, amount: changeAmount });\n            }\n            const txHex = (0, index_1.buildPsbt)(runeTx, network);\n            const res = [txHex, changeAmount];\n            return Promise.resolve(res);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\nexports.RuneMainWallet = RuneMainWallet;\nclass RuneMainTestWallet extends RuneMainWallet {\n    network() {\n        return bitcoin.networks.testnet;\n    }\n}\nexports.RuneMainTestWallet = RuneMainTestWallet;\n//# sourceMappingURL=RuneMainWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L1J1bmVNYWluV2FsbGV0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyw2QkFBNkIsR0FBRyxnQ0FBZ0MsR0FBRyw4QkFBOEIsR0FBRywrQkFBK0I7QUFDekwsb0JBQW9CLG1CQUFPLENBQUMsaUZBQW9CO0FBQ2hELG9CQUFvQixtQkFBTyxDQUFDLHdGQUFhO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLDBFQUFVO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFVO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyx3RUFBUztBQUNoQyxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDbEQsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxtREFBbUQsa0JBQWtCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnREFBZ0QsdUNBQXVDO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQSxzQ0FBc0MsK0NBQStDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC93YWxsZXQvUnVuZU1haW5XYWxsZXQuanM/OTllNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5lTWFpblRlc3RXYWxsZXQgPSBleHBvcnRzLlJ1bmVNYWluV2FsbGV0ID0gZXhwb3J0cy5FcnJDb2RlTXVsdGlwbGVSdW5lSWQgPSBleHBvcnRzLkVyckNvZGVSdW5lSWROb3RTdGFuZGFyZCA9IGV4cG9ydHMuRXJyQ29kZU9wcmV0dXJuRXhjZWVkcyA9IGV4cG9ydHMuRXJyQ29kZUxlc3NSdW5lc01haW5BbXQgPSB2b2lkIDA7XG5jb25zdCBjb2luX2Jhc2VfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jb2luLWJhc2VcIik7XG5jb25zdCBCdGNXYWxsZXRfMSA9IHJlcXVpcmUoXCIuL0J0Y1dhbGxldFwiKTtcbmNvbnN0IGJpdGNvaW4gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2luZGV4XCIpKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG5jb25zdCBydW5lXzEgPSByZXF1aXJlKFwiLi4vcnVuZVwiKTtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuZXhwb3J0cy5FcnJDb2RlTGVzc1J1bmVzTWFpbkFtdCA9IDIwMTAzMDA7XG5leHBvcnRzLkVyckNvZGVPcHJldHVybkV4Y2VlZHMgPSAyMDEwMzAxO1xuZXhwb3J0cy5FcnJDb2RlUnVuZUlkTm90U3RhbmRhcmQgPSAyMDEwMzAyO1xuZXhwb3J0cy5FcnJDb2RlTXVsdGlwbGVSdW5lSWQgPSAyMDEwMzAzO1xuY2xhc3MgUnVuZU1haW5XYWxsZXQgZXh0ZW5kcyBCdGNXYWxsZXRfMS5CdGNXYWxsZXQge1xuICAgIGNvbnZlcnQyUnVuZVR4KHBhcmFtRGF0YSkge1xuICAgICAgICBjb25zdCBjbG9uZWRQYXJhbURhdGEgPSAoMCwgY29pbl9iYXNlXzEuY2xvbmVPYmplY3QpKHBhcmFtRGF0YSk7XG4gICAgICAgIGlmIChjbG9uZWRQYXJhbURhdGEucnVuZURhdGEudXNlRGVmYXVsdE91dHB1dCA9PSB0cnVlICYmIGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5kZWZhdWx0T3V0cHV0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmRlZmF1bHRPdXRwdXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9uZWRQYXJhbURhdGEucnVuZURhdGEubWludCA9PSB0cnVlICYmIGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5taW50TnVtID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLm1pbnROVW0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGlucHV0IG9mIGNsb25lZFBhcmFtRGF0YS5pbnB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhQXJyYXkgPSBpbnB1dC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGFBcnJheSAhPSBudWxsICYmIGRhdGFBcnJheSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZGF0YSBvZiBkYXRhQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW1wiYW1vdW50XCJdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLm1pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW1wiYW1vdW50XCJdID0gQmlnSW50KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtcImFtb3VudFwiXSA9IEJpZ0ludChkYXRhW1wiYW1vdW50XCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvdXRwdXQgb2YgY2xvbmVkUGFyYW1EYXRhLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhQXJyYXkgPSBvdXRwdXQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhQXJyYXkgIT0gbnVsbCAmJiBkYXRhQXJyYXkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGRhdGEgb2YgZGF0YUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtcImFtb3VudFwiXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5taW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtcImFtb3VudFwiXSA9IEJpZ0ludCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbXCJhbW91bnRcIl0gPSBCaWdJbnQoZGF0YVtcImFtb3VudFwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlucHV0cyA9IGNsb25lZFBhcmFtRGF0YS5pbnB1dHM7XG4gICAgICAgIGNvbnN0IHJ1bmVJbnB1dE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhQXJyYXkgPSBpbnB1dC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGFBcnJheSAhPSBudWxsICYmIGRhdGFBcnJheSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkYXRhIG9mIGRhdGFBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcnVuZUlkID0gZGF0YVtcImlkXCJdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcnVuZUFtb3VudCA9IEJpZ0ludCgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9uZWRQYXJhbURhdGEucnVuZURhdGEubWludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVuZUFtb3VudCA9IEJpZ0ludChkYXRhW1wiYW1vdW50XCJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocnVuZUlkID09IG51bGwgfHwgcnVuZUFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocnVuZUlkLnNwbGl0KFwiOlwiKS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHsgZXJyQ29kZTogZXhwb3J0cy5FcnJDb2RlUnVuZUlkTm90U3RhbmRhcmQsIGRhdGU6IHsgcnVuZUlkOiBydW5lSWQgfSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZUFtb3VudCA9IHJ1bmVJbnB1dE1hcC5nZXQocnVuZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZUFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5lSW5wdXRNYXAuc2V0KHJ1bmVJZCwgcnVuZUFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5lSW5wdXRNYXAuc2V0KHJ1bmVJZCwgKEJpZ0ludChiZWZvcmVBbW91bnQpICsgQmlnSW50KHJ1bmVBbW91bnQpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bmVJbnB1dE1hcC5zaXplID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHsgZXJyQ29kZTogZXhwb3J0cy5FcnJDb2RlTXVsdGlwbGVSdW5lSWQsIGRhdGU6IHsgcnVuZUlucHV0TWFwU2l6ZTogcnVuZUlucHV0TWFwLnNpemUgfSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dHMgPSBjbG9uZWRQYXJhbURhdGEub3V0cHV0cztcbiAgICAgICAgY29uc3QgcnVuZVNlbmRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gb3V0cHV0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bmVJZCA9IGRhdGFbXCJpZFwiXTtcbiAgICAgICAgICAgICAgICBsZXQgcnVuZUFtb3VudCA9IEJpZ0ludCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5taW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bmVBbW91bnQgPSBCaWdJbnQoZGF0YVtcImFtb3VudFwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5lSWQgPT0gbnVsbCB8fCBydW5lQW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiZWZvcmVBbW91bnQgPSBydW5lU2VuZE1hcC5nZXQocnVuZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlQW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuZVNlbmRNYXAuc2V0KHJ1bmVJZCwgcnVuZUFtb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBydW5lU2VuZE1hcC5zZXQocnVuZUlkLCAoQmlnSW50KGJlZm9yZUFtb3VudCkgKyBCaWdJbnQocnVuZUFtb3VudCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzUnVuZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHJ1bmVJbnB1dE1hcC5rZXlzKCkpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dEFtb3VudCA9IHJ1bmVJbnB1dE1hcC5nZXQoaWQpO1xuICAgICAgICAgICAgbGV0IHNlbmRBbW91bnQgPSBydW5lU2VuZE1hcC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKChpbnB1dEFtb3VudCAhPSBudWxsICYmIHNlbmRBbW91bnQgIT0gbnVsbCAmJiBpbnB1dEFtb3VudCA+IHNlbmRBbW91bnQpIHx8IChpbnB1dEFtb3VudCAhPSBudWxsICYmIHNlbmRBbW91bnQgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLnVzZURlZmF1bHRPdXRwdXQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNSdW5lQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHVwZGF0ZU91dHB1dHMgPSBbXTtcbiAgICAgICAgaWYgKGlzUnVuZUNoYW5nZSkge1xuICAgICAgICAgICAgbGV0IHJ1bmVDaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogY2xvbmVkUGFyYW1EYXRhLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYW1vdW50OiA1NDZcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1cGRhdGVPdXRwdXRzLnB1c2gocnVuZUNoYW5nZSk7XG4gICAgICAgICAgICBvdXRwdXRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVkRWRpY3RzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gb3V0cHV0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bmVJZCA9IGRhdGFbXCJpZFwiXTtcbiAgICAgICAgICAgICAgICBsZXQgcnVuZUFtb3VudCA9IEJpZ0ludCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5taW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bmVBbW91bnQgPSBCaWdJbnQoZGF0YVtcImFtb3VudFwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5lSWQgPT0gbnVsbCB8fCBydW5lQW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkRWRpY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBwYXJzZUludChydW5lSWQuc3BsaXQoXCI6XCIpWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcnNlSW50KHJ1bmVJZC5zcGxpdChcIjpcIilbMV0pLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IEJpZ0ludChydW5lQW1vdW50KSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXRJbmRleCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHR5cGVkRWRpY3RzLnB1c2godHlwZWRFZGljdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB1cGRhdGVPdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS51c2VEZWZhdWx0T3V0cHV0ID09IHRydWUgJiYgY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmRlZmF1bHRPdXRwdXQgPiB1cGRhdGVPdXRwdXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZXJyQ29kZTogZXhwb3J0cy5FcnJDb2RlTGVzc1J1bmVzTWFpbkFtdCxcbiAgICAgICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPdXRwdXQ6IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5kZWZhdWx0T3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICBvdXB1dExlbnRoOiB1cGRhdGVPdXRwdXRzLmxlbmd0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRzOiBjbG9uZWRQYXJhbURhdGEuaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogdXBkYXRlT3V0cHV0cyxcbiAgICAgICAgICAgIGFkZHJlc3M6IGNsb25lZFBhcmFtRGF0YS5hZGRyZXNzLFxuICAgICAgICAgICAgZmVlUGVyQjogY2xvbmVkUGFyYW1EYXRhLmZlZVBlckIsXG4gICAgICAgICAgICBydW5lRGF0YToge1xuICAgICAgICAgICAgICAgIGVkaWN0czogdHlwZWRFZGljdHMsXG4gICAgICAgICAgICAgICAgZXRjaGluZzogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmV0Y2hpbmcsXG4gICAgICAgICAgICAgICAgYnVybjogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmJ1cm4sXG4gICAgICAgICAgICAgICAgZGVmYXVsdE91dHB1dDogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmRlZmF1bHRPdXRwdXQsXG4gICAgICAgICAgICAgICAgbWludDogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLm1pbnQsXG4gICAgICAgICAgICAgICAgbWludE51bTogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLm1pbnROdW0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRNb2NrTWluUnVuZVR4KHBhcmFtRGF0YSwgY3VyUnVuZUluZm8pIHtcbiAgICAgICAgY29uc3QgY2xvbmVkUGFyYW1EYXRhID0gKDAsIGNvaW5fYmFzZV8xLmNsb25lT2JqZWN0KShwYXJhbURhdGEpO1xuICAgICAgICBjb25zdCB0eXBlZEVkaWN0cyA9IFtdO1xuICAgICAgICBjb25zdCB0eXBlZEVkaWN0ID0ge1xuICAgICAgICAgICAgYmxvY2s6IHBhcnNlSW50KGN1clJ1bmVJbmZvLmlkLnNwbGl0KFwiOlwiKVswXSksXG4gICAgICAgICAgICBpZDogcGFyc2VJbnQoY3VyUnVuZUluZm8uaWQuc3BsaXQoXCI6XCIpWzFdKSxcbiAgICAgICAgICAgIGFtb3VudDogQmlnSW50KDEpLFxuICAgICAgICAgICAgb3V0cHV0OiAwLFxuICAgICAgICB9O1xuICAgICAgICB0eXBlZEVkaWN0cy5wdXNoKHR5cGVkRWRpY3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eElkOiBjbG9uZWRQYXJhbURhdGEuaW5wdXRzWzBdLnR4SWQsXG4gICAgICAgICAgICAgICAgICAgIHZPdXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogNjAwLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbY3VyUnVuZUluZm9dXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBvdXRwdXRzOiBbe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBjbG9uZWRQYXJhbURhdGEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiA1NDYsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN1clJ1bmVJbmZvXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBhZGRyZXNzOiBjbG9uZWRQYXJhbURhdGEuYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZVBlckI6IGNsb25lZFBhcmFtRGF0YS5mZWVQZXJCLFxuICAgICAgICAgICAgcnVuZURhdGE6IHtcbiAgICAgICAgICAgICAgICBlZGljdHM6IHR5cGVkRWRpY3RzLFxuICAgICAgICAgICAgICAgIGV0Y2hpbmc6IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5ldGNoaW5nLFxuICAgICAgICAgICAgICAgIGJ1cm46IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5idXJuLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRPdXRwdXQ6IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5kZWZhdWx0T3V0cHV0LFxuICAgICAgICAgICAgICAgIG1pbnQ6IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5taW50LFxuICAgICAgICAgICAgICAgIG1pbnROdW06IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5taW50TnVtLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0TWluUnVuZVR4KHBhcmFtRGF0YSwgY3VyUnVuZUluZm8sIGN1cklucHV0LCBjdXJPdXRwdXQpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkUGFyYW1EYXRhID0gKDAsIGNvaW5fYmFzZV8xLmNsb25lT2JqZWN0KShwYXJhbURhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRzOiBbY3VySW5wdXRdLFxuICAgICAgICAgICAgb3V0cHV0czogW2N1ck91dHB1dF0sXG4gICAgICAgICAgICBhZGRyZXNzOiBjbG9uZWRQYXJhbURhdGEuYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZVBlckI6IGNsb25lZFBhcmFtRGF0YS5mZWVQZXJCLFxuICAgICAgICAgICAgUnVuZURhdGE6IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcmsoKTtcbiAgICAgICAgbGV0IHR4SGV4ID0gbnVsbDtcbiAgICAgICAgaWYgKHBhcmFtLmRhdGEucnVuZURhdGEubWludE51bSA9PSB1bmRlZmluZWQgfHwgcGFyYW0uZGF0YS5ydW5lRGF0YS5taW50TnVtIDw9IDEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHBhcmFtLnByaXZhdGVLZXk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5kYXRhLnJ1bmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIm1pc3NpbmcgcnVuZURhdGFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bmVUeCA9IHRoaXMuY29udmVydDJSdW5lVHgocGFyYW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BSZXR1cm5PdXRwdXQgPSB0aGlzLmdldFJ1bmVNYWluT3BSZXR1cm5PdXRwdXQobmV0d29yaywgcnVuZVR4LnJ1bmVEYXRhKTtcbiAgICAgICAgICAgICAgICBydW5lVHgub3V0cHV0cy5wdXNoKG9wUmV0dXJuT3V0cHV0KTtcbiAgICAgICAgICAgICAgICB0eEhleCA9ICgwLCBpbmRleF8xLnNpZ25CdGMpKHJ1bmVUeCwgcHJpdmF0ZUtleSwgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eEhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbS5kYXRhLnJ1bmVEYXRhLm1pbnQgJiYgIXBhcmFtLmRhdGEucnVuZURhdGEuc2VyaWFsTWludCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgdHhIZXhzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHBhcmFtLnByaXZhdGVLZXk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5kYXRhLnJ1bmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIm1pc3NpbmcgcnVuZURhdGFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtaW50RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmFtLmRhdGEub3V0cHV0c1swXS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHBhcmFtLmRhdGEub3V0cHV0c1swXS5kYXRhLmFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgbWludE51bTogcGFyYW0uZGF0YS5ydW5lRGF0YS5taW50TnVtLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbGV0IGJhc2VNaW50VHggPSB0aGlzLmdldE1vY2tNaW5SdW5lVHgocGFyYW0uZGF0YSwgbWludERhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wTWludFJldHVybk91dHB1dCA9IHRoaXMuZ2V0UnVuZU1haW5PcFJldHVybk91dHB1dChuZXR3b3JrLCBiYXNlTWludFR4LnJ1bmVEYXRhKTtcbiAgICAgICAgICAgICAgICBiYXNlTWludFR4Lm91dHB1dHMucHVzaChvcE1pbnRSZXR1cm5PdXRwdXQpO1xuICAgICAgICAgICAgICAgIHR4SGV4ID0gKDAsIGluZGV4XzEuc2lnbkJ0YykoYmFzZU1pbnRUeCwgcHJpdmF0ZUtleSwgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZU1pbnRmZWUgPSBiaXRjb2luLmVzdGltYXRlQnRjRmVlKGJhc2VNaW50VHgsIHRoaXMubmV0d29yaygpKSArIDU0NjtcbiAgICAgICAgICAgICAgICBjb25zdCBydW5lVHggPSB0aGlzLmNvbnZlcnQyUnVuZVR4KHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgICAgIGxldCBiYXRjaE1pbnRTdGF0TnVtID0gcnVuZVR4Lm91dHB1dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWludERhdGEubWludE51bSAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBydW5lVHgub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtLmRhdGEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogYmFzZU1pbnRmZWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvcFJldHVybk91dHB1dCA9IHRoaXMuZ2V0UnVuZU1haW5PcFJldHVybk91dHB1dChuZXR3b3JrLCBydW5lVHgucnVuZURhdGEpO1xuICAgICAgICAgICAgICAgIHJ1bmVUeC5vdXRwdXRzLnB1c2gob3BSZXR1cm5PdXRwdXQpO1xuICAgICAgICAgICAgICAgIHR4SGV4ID0gKDAsIGluZGV4XzEuc2lnbkJ0YykocnVuZVR4LCBwcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUeElkID0gaW5kZXhfMS5UcmFuc2FjdGlvbi5mcm9tSGV4KHR4SGV4KS5nZXRJZCgpO1xuICAgICAgICAgICAgICAgIHR4SGV4cy5wdXNoKHR4SGV4KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbnREYXRhLm1pbnROdW0gLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cklucHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHhJZDogcGFyZW50VHhJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZPdXQ6IGJhdGNoTWludFN0YXROdW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbS5kYXRhLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IGJhc2VNaW50ZmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW21pbnREYXRhXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyT3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW0uZGF0YS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiA1NDZcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hNaW50U3RhdE51bSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyU3ViVHggPSB0aGlzLmdldE1pblJ1bmVUeChwYXJhbS5kYXRhLCBtaW50RGF0YSwgY3VySW5wdXQsIGN1ck91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGN1clN1YlR4Lm91dHB1dHMucHVzaChvcFJldHVybk91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJTdWJUeEhleCA9ICgwLCBpbmRleF8xLnNpZ25CdGMpKGN1clN1YlR4LCBwcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgdHhIZXhzLnB1c2goY3VyU3ViVHhIZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHR4SGV4cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHR4SGV4cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBwYXJhbS5wcml2YXRlS2V5O1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW0uZGF0YS5ydW5lRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJtaXNzaW5nIHJ1bmVEYXRhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWludERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJhbS5kYXRhLm91dHB1dHNbMF0uZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICBtaW50TnVtOiBwYXJhbS5kYXRhLnJ1bmVEYXRhLm1pbnROdW0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZU1pbnRUeCA9IHRoaXMuZ2V0TW9ja01pblJ1bmVUeChwYXJhbS5kYXRhLCBtaW50RGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BNaW50UmV0dXJuT3V0cHV0ID0gKDAsIHJ1bmVfMS5idWlsZFJ1bmVNYWluTWludE9wKShtaW50RGF0YS5pZCwgZmFsc2UsIDAsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJhc2VNaW50VHgub3V0cHV0cy5wdXNoKG9wTWludFJldHVybk91dHB1dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZU1pbnRmZWUgPSBiaXRjb2luLmVzdGltYXRlQnRjRmVlKGJhc2VNaW50VHgsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgICAgICBsZXQgY3VyQW1vdW50ID0gKG1pbnREYXRhLm1pbnROdW0gLSAxKSAqIGJhc2VNaW50ZmVlICsgNTQ2O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bmVUeCA9IHRoaXMuY29udmVydDJSdW5lVHhTZXJpYWxNaW50KHBhcmFtLmRhdGEsIGN1ckFtb3VudCk7XG4gICAgICAgICAgICAgICAgcnVuZVR4Lm91dHB1dHMucHVzaChvcE1pbnRSZXR1cm5PdXRwdXQpO1xuICAgICAgICAgICAgICAgIHR4SGV4ID0gKDAsIGluZGV4XzEuc2lnbkJ0YykocnVuZVR4LCBwcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50VHhJZCA9IGluZGV4XzEuVHJhbnNhY3Rpb24uZnJvbUhleCh0eEhleCkuZ2V0SWQoKTtcbiAgICAgICAgICAgICAgICB0eEhleHMucHVzaCh0eEhleCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtaW50RGF0YS5taW50TnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cklucHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHhJZDogcGFyZW50VHhJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZPdXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbS5kYXRhLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IGN1ckFtb3VudFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJBbW91bnQgPSBjdXJBbW91bnQgLSBiYXNlTWludGZlZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1ck91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtLmRhdGEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogY3VyQW1vdW50XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJTdWJUeCA9IHRoaXMuZ2V0TWluUnVuZVR4KHBhcmFtLmRhdGEsIG1pbnREYXRhLCBjdXJJbnB1dCwgY3VyT3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyU3ViVHgub3V0cHV0cy5wdXNoKG9wTWludFJldHVybk91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJTdWJUeEhleCA9ICgwLCBpbmRleF8xLnNpZ25CdGMpKGN1clN1YlR4LCBwcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHhJZCA9IGluZGV4XzEuVHJhbnNhY3Rpb24uZnJvbUhleChjdXJTdWJUeEhleCkuZ2V0SWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdHhIZXhzLnB1c2goY3VyU3ViVHhIZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHhIZXhzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UnVuZU1haW5PcFJldHVybk91dHB1dChuZXR3b3JrLCBydW5lRGF0YSkge1xuICAgICAgICBsZXQgaXNNYWlubmV0ID0gZmFsc2U7XG4gICAgICAgIGlmIChpbmRleF8xLm5ldHdvcmtzLmJpdGNvaW4gPT09IG5ldHdvcmspIHtcbiAgICAgICAgICAgIGlzTWFpbm5ldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bmVEYXRhLnVzZURlZmF1bHRPdXRwdXQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5lRGF0YS51c2VEZWZhdWx0T3V0cHV0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bmVEYXRhLmRlZmF1bHRPdXRwdXQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5lRGF0YS5kZWZhdWx0T3V0cHV0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuZURhdGEubWludCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bmVEYXRhLm1pbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuZURhdGEubWludE51bSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bmVEYXRhLm1pbnROdW0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wUmV0dXJuU2NyaXB0ID0gKDAsIHJ1bmVfMS5idWlsZFJ1bmVNYWluTWludERhdGEpKGlzTWFpbm5ldCwgcnVuZURhdGEuZWRpY3RzLCBydW5lRGF0YS51c2VEZWZhdWx0T3V0cHV0LCBydW5lRGF0YS5kZWZhdWx0T3V0cHV0LCBydW5lRGF0YS5taW50LCBydW5lRGF0YS5taW50TnVtKTtcbiAgICAgICAgcmV0dXJuIHsgYWRkcmVzczogJycsIGFtb3VudDogMCwgb21uaVNjcmlwdDogY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgob3BSZXR1cm5TY3JpcHQpIH07XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlRmVlKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmRhdGEucnVuZURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJtaXNzaW5nIHJ1bmVEYXRhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcnVuZVR4ID0gdGhpcy5jb252ZXJ0MlJ1bmVUeChwYXJhbS5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IG9wUmV0dXJuT3V0cHV0ID0gdGhpcy5nZXRSdW5lTWFpbk9wUmV0dXJuT3V0cHV0KHRoaXMubmV0d29yaygpLCBydW5lVHgucnVuZURhdGEpO1xuICAgICAgICAgICAgcnVuZVR4Lm91dHB1dHMucHVzaChvcFJldHVybk91dHB1dCk7XG4gICAgICAgICAgICBsZXQgbWludERhdGEgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtLmRhdGEub3V0cHV0c1swXS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgIGFtb3VudDogcGFyYW0uZGF0YS5vdXRwdXRzWzBdLmRhdGEuYW1vdW50LFxuICAgICAgICAgICAgICAgIG1pbnROdW06IHBhcmFtLmRhdGEucnVuZURhdGEubWludE51bSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYmF0Y2hNaW50U3RhdE51bSA9IHJ1bmVUeC5vdXRwdXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWludERhdGEubWludE51bSAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHJ1bmVUeC5vdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbS5kYXRhLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogODAwMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZlZSA9IGJpdGNvaW4uZXN0aW1hdGVCdGNGZWUocnVuZVR4LCB0aGlzLm5ldHdvcmsoKSk7XG4gICAgICAgICAgICBpZiAocGFyYW0uZGF0YS5ydW5lRGF0YS5taW50TnVtID09IHVuZGVmaW5lZCB8fCBwYXJhbS5kYXRhLnJ1bmVEYXRhLm1pbnROdW0gPD0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmRhdGEucnVuZURhdGEubWludCAmJiAhcGFyYW0uZGF0YS5ydW5lRGF0YS5zZXJpYWxNaW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZlZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmZWVzLnB1c2goZmVlKTtcbiAgICAgICAgICAgICAgICBsZXQgbWludERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJhbS5kYXRhLm91dHB1dHNbMF0uZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBwYXJhbS5kYXRhLm91dHB1dHNbMF0uZGF0YS5hbW91bnQsXG4gICAgICAgICAgICAgICAgICAgIG1pbnROdW06IHBhcmFtLmRhdGEucnVuZURhdGEubWludE51bSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBiYXNlTWludFR4ID0gdGhpcy5nZXRNb2NrTWluUnVuZVR4KHBhcmFtLmRhdGEsIG1pbnREYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcE1pbnRSZXR1cm5PdXRwdXQgPSB0aGlzLmdldFJ1bmVNYWluT3BSZXR1cm5PdXRwdXQodGhpcy5uZXR3b3JrKCksIGJhc2VNaW50VHgucnVuZURhdGEpO1xuICAgICAgICAgICAgICAgIGJhc2VNaW50VHgub3V0cHV0cy5wdXNoKG9wTWludFJldHVybk91dHB1dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZU1pbnRmZWUgPSBiaXRjb2luLmVzdGltYXRlQnRjRmVlKGJhc2VNaW50VHgsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmRhdGEucnVuZURhdGEubWludE51bSAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmZWVzLnB1c2goYmFzZU1pbnRmZWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZlZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uZGF0YS5ydW5lRGF0YS5taW50ICYmIHBhcmFtLmRhdGEucnVuZURhdGEuc2VyaWFsTWludCkge1xuICAgICAgICAgICAgICAgIGxldCBmZWVzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5kYXRhLnJ1bmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIm1pc3NpbmcgcnVuZURhdGFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtaW50RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmFtLmRhdGEub3V0cHV0c1swXS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIG1pbnROdW06IHBhcmFtLmRhdGEucnVuZURhdGEubWludE51bSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBiYXNlTWludFR4ID0gdGhpcy5nZXRNb2NrTWluUnVuZVR4KHBhcmFtLmRhdGEsIG1pbnREYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcE1pbnRSZXR1cm5PdXRwdXQgPSAoMCwgcnVuZV8xLmJ1aWxkUnVuZU1haW5NaW50T3ApKG1pbnREYXRhLmlkLCBmYWxzZSwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYmFzZU1pbnRUeC5vdXRwdXRzLnB1c2gob3BNaW50UmV0dXJuT3V0cHV0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlTWludGZlZSA9IGJpdGNvaW4uZXN0aW1hdGVCdGNGZWUoYmFzZU1pbnRUeCwgdGhpcy5uZXR3b3JrKCkpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJBbW91bnQgPSAobWludERhdGEubWludE51bSAtIDEpICogYmFzZU1pbnRmZWUgKyA1NDY7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVuZVR4ID0gdGhpcy5jb252ZXJ0MlJ1bmVUeFNlcmlhbE1pbnQocGFyYW0uZGF0YSwgY3VyQW1vdW50KTtcbiAgICAgICAgICAgICAgICBydW5lVHgub3V0cHV0cy5wdXNoKG9wTWludFJldHVybk91dHB1dCk7XG4gICAgICAgICAgICAgICAgbGV0IGZlZSA9IGJpdGNvaW4uZXN0aW1hdGVCdGNGZWUocnVuZVR4LCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBmZWVzLnB1c2goZmVlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1pbnREYXRhLm1pbnROdW07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmZWVzLnB1c2goYmFzZU1pbnRmZWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZlZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udmVydDJSdW5lVHhTZXJpYWxNaW50KHBhcmFtRGF0YSwgb3V0cHV0QW1vdW50KSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFBhcmFtRGF0YSA9ICgwLCBjb2luX2Jhc2VfMS5jbG9uZU9iamVjdCkocGFyYW1EYXRhKTtcbiAgICAgICAgbGV0IGN1ck91dHB1dHMgPSBbe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNsb25lZFBhcmFtRGF0YS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFtb3VudDogb3V0cHV0QW1vdW50XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0czogY2xvbmVkUGFyYW1EYXRhLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IGN1ck91dHB1dHMsXG4gICAgICAgICAgICBhZGRyZXNzOiBjbG9uZWRQYXJhbURhdGEuYWRkcmVzcyxcbiAgICAgICAgICAgIGZlZVBlckI6IGNsb25lZFBhcmFtRGF0YS5mZWVQZXJCLFxuICAgICAgICAgICAgcnVuZURhdGE6IHtcbiAgICAgICAgICAgICAgICBlZGljdHM6IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5lZGljdHMsXG4gICAgICAgICAgICAgICAgZXRjaGluZzogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmV0Y2hpbmcsXG4gICAgICAgICAgICAgICAgYnVybjogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmJ1cm4sXG4gICAgICAgICAgICAgICAgZGVmYXVsdE91dHB1dDogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmRlZmF1bHRPdXRwdXQsXG4gICAgICAgICAgICAgICAgbWludDogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLm1pbnQsXG4gICAgICAgICAgICAgICAgbWludE51bTogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLm1pbnROdW0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb252ZXJ0MlJ1bmVUeFBzYnQocGFyYW1EYXRhKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFBhcmFtRGF0YSA9ICgwLCBjb2luX2Jhc2VfMS5jbG9uZU9iamVjdCkocGFyYW1EYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0czogY2xvbmVkUGFyYW1EYXRhLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IGNsb25lZFBhcmFtRGF0YS5vdXRwdXRzLFxuICAgICAgICAgICAgYWRkcmVzczogY2xvbmVkUGFyYW1EYXRhLmFkZHJlc3MsXG4gICAgICAgICAgICBmZWVQZXJCOiBjbG9uZWRQYXJhbURhdGEuZmVlUGVyQixcbiAgICAgICAgICAgIHJ1bmVEYXRhOiB7XG4gICAgICAgICAgICAgICAgZWRpY3RzOiBjbG9uZWRQYXJhbURhdGEucnVuZURhdGEuZWRpY3RzLFxuICAgICAgICAgICAgICAgIGV0Y2hpbmc6IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5ldGNoaW5nLFxuICAgICAgICAgICAgICAgIGJ1cm46IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5idXJuLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRPdXRwdXQ6IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5kZWZhdWx0T3V0cHV0LFxuICAgICAgICAgICAgICAgIG1pbnQ6IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5taW50LFxuICAgICAgICAgICAgICAgIG1pbnROdW06IGNsb25lZFBhcmFtRGF0YS5ydW5lRGF0YS5taW50TnVtLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRQc2J0KHBhcmFtKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcmsoKTtcbiAgICAgICAgbGV0IHR4SGV4ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBwYXJhbS5wcml2YXRlS2V5O1xuICAgICAgICAgICAgaWYgKCFwYXJhbS5kYXRhLnJ1bmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwibWlzc2luZyBydW5lRGF0YVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJ1bmVUeCA9IHRoaXMuY29udmVydDJSdW5lVHhQc2J0KHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgY29uc3Qgb3BSZXR1cm5PdXRwdXQgPSB0aGlzLmdldFJ1bmVNYWluT3BSZXR1cm5PdXRwdXQobmV0d29yaywgcnVuZVR4LnJ1bmVEYXRhKTtcbiAgICAgICAgICAgIHJ1bmVUeC5vdXRwdXRzLnB1c2gob3BSZXR1cm5PdXRwdXQpO1xuICAgICAgICAgICAgbGV0IGZha2VBZGRyID0gXCJLd2RrZlhNVjJ3eERWRE1QUHVGWnNpbzNOZUNza0FVZDROMlU0UHJpVGdwajJNcUFHbW1jXCI7XG4gICAgICAgICAgICBpZiAocnVuZVR4LmR1c3RTaXplID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJ1bmVUeC5kdXN0U2l6ZSA9IDU0NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB7IGlucHV0QW1vdW50LCBvdXRwdXRBbW91bnQsIHZpcnR1YWxTaXplIH0gPSAoMCwgaW5kZXhfMS5jYWxjdWxhdGVUeFNpemUpKHJ1bmVUeC5pbnB1dHMsIHJ1bmVUeC5vdXRwdXRzLCBydW5lVHguYWRkcmVzcywgZmFrZUFkZHIsIG5ldHdvcmssIHJ1bmVUeC5kdXN0U2l6ZSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlQW1vdW50ID0gaW5wdXRBbW91bnQgLSBvdXRwdXRBbW91bnQgLSB2aXJ0dWFsU2l6ZSAqIHJ1bmVUeC5mZWVQZXJCO1xuICAgICAgICAgICAgaWYgKGNoYW5nZUFtb3VudCA+IHJ1bmVUeC5kdXN0U2l6ZSkge1xuICAgICAgICAgICAgICAgIHJ1bmVUeC5vdXRwdXRzLnB1c2goeyBhZGRyZXNzOiBydW5lVHguYWRkcmVzcywgYW1vdW50OiBjaGFuZ2VBbW91bnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eEhleCA9ICgwLCBpbmRleF8xLmJ1aWxkUHNidCkocnVuZVR4LCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IFt0eEhleCwgY2hhbmdlQW1vdW50XTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SdW5lTWFpbldhbGxldCA9IFJ1bmVNYWluV2FsbGV0O1xuY2xhc3MgUnVuZU1haW5UZXN0V2FsbGV0IGV4dGVuZHMgUnVuZU1haW5XYWxsZXQge1xuICAgIG5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBiaXRjb2luLm5ldHdvcmtzLnRlc3RuZXQ7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5lTWFpblRlc3RXYWxsZXQgPSBSdW5lTWFpblRlc3RXYWxsZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SdW5lTWFpbldhbGxldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/RuneMainWallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/RuneWallet.js':
    /*!**********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/RuneWallet.js ***!
  \**********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.RuneTestWallet = exports.RuneWallet = void 0;\nconst coin_base_1 = __webpack_require__(/*! @okxweb3/coin-base */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js");\nconst BtcWallet_1 = __webpack_require__(/*! ./BtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js");\nconst bitcoin = __importStar(__webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js"));\nconst index_1 = __webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js");\nconst rune_1 = __webpack_require__(/*! ../rune */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/rune.js");\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nclass RuneWallet extends BtcWallet_1.BtcWallet {\n    convert2RuneTx(paramData) {\n        const clonedParamData = (0, coin_base_1.cloneObject)(paramData);\n        for (let input of clonedParamData.inputs) {\n            let dataArray = input.data;\n            if (dataArray != null && dataArray instanceof Array) {\n                for (let data of dataArray) {\n                    if (typeof data["amount"] === "string") {\n                        data["amount"] = BigInt(data["amount"]);\n                    }\n                }\n            }\n        }\n        for (let output of clonedParamData.outputs) {\n            let dataArray = output.data;\n            if (dataArray != null && dataArray instanceof Array) {\n                for (let data of dataArray) {\n                    if (typeof data["amount"] === "string") {\n                        data["amount"] = BigInt(data["amount"]);\n                    }\n                }\n            }\n        }\n        let inputs = clonedParamData.inputs;\n        const runeInputMap = new Map();\n        for (const input of inputs) {\n            let dataArray = input.data;\n            if (dataArray != null && dataArray instanceof Array) {\n                for (const data of dataArray) {\n                    let runeId = data["id"];\n                    let runeAmount = BigInt(data["amount"]);\n                    if (runeId == null || runeAmount == null) {\n                        continue;\n                    }\n                    let beforeAmount = runeInputMap.get(runeId);\n                    if (beforeAmount == null) {\n                        runeInputMap.set(runeId, runeAmount);\n                    }\n                    else {\n                        runeInputMap.set(runeId, (BigInt(beforeAmount) + BigInt(runeAmount)));\n                    }\n                }\n            }\n        }\n        let outputs = clonedParamData.outputs;\n        const runeSendMap = new Map();\n        for (const output of outputs) {\n            let data = output.data;\n            if (data != null) {\n                let runeId = data["id"];\n                let runeAmount = BigInt(data["amount"]);\n                if (runeId == null || runeAmount == null) {\n                    continue;\n                }\n                let beforeAmount = runeSendMap.get(runeId);\n                if (beforeAmount == null) {\n                    runeSendMap.set(runeId, runeAmount);\n                }\n                else {\n                    runeSendMap.set(runeId, (BigInt(beforeAmount) + BigInt(runeAmount)));\n                }\n            }\n        }\n        let isRuneChange = false;\n        for (const id of runeInputMap.keys()) {\n            let inputAmount = runeInputMap.get(id);\n            let sendAmount = runeSendMap.get(id);\n            if ((inputAmount != null && sendAmount != null && inputAmount > sendAmount) || (inputAmount != null && sendAmount == null)) {\n                isRuneChange = true;\n            }\n            isRuneChange = true;\n        }\n        let outputIndex = 0;\n        let updateOutputs = [];\n        if (isRuneChange) {\n            let runeChange = {\n                address: clonedParamData.address,\n                amount: 546\n            };\n            updateOutputs.push(runeChange);\n            outputIndex++;\n        }\n        const typedEdicts = [];\n        for (const output of outputs) {\n            let data = output.data;\n            if (data != null) {\n                let runeId = data["id"];\n                let runeAmount = BigInt(data["amount"]);\n                if (runeId == null || runeAmount == null) {\n                    continue;\n                }\n                const typedEdict = {\n                    id: parseInt(\'0x\' + runeId),\n                    amount: BigInt(runeAmount),\n                    output: outputIndex,\n                };\n                typedEdicts.push(typedEdict);\n            }\n            output.data = null;\n            updateOutputs.push(output);\n            outputIndex++;\n        }\n        return {\n            inputs: clonedParamData.inputs,\n            outputs: updateOutputs,\n            address: clonedParamData.address,\n            feePerB: clonedParamData.feePerB,\n            runeData: {\n                edicts: typedEdicts,\n                etching: clonedParamData.runeData.etching,\n                burn: clonedParamData.runeData.burn\n            },\n        };\n    }\n    async signTransaction(param) {\n        const network = this.network();\n        let txHex = null;\n        try {\n            const privateKey = param.privateKey;\n            if (!param.data.runeData) {\n                return Promise.reject("missing runeData");\n            }\n            const runeTx = this.convert2RuneTx(param.data);\n            const opReturnOutput = this.getOpReturnOutput(network, runeTx.runeData);\n            runeTx.outputs.push(opReturnOutput);\n            txHex = (0, index_1.signBtc)(runeTx, privateKey, network);\n            return Promise.resolve(txHex);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    getOpReturnOutput(network, runeData) {\n        let isMainnet = false;\n        if (index_1.networks.bitcoin === network) {\n            isMainnet = true;\n        }\n        if (runeData.edicts == undefined) {\n            runeData.edicts = [];\n        }\n        const opReturnScript = (0, rune_1.buildRuneData)(isMainnet, runeData.edicts);\n        const opReturnOutput = { address: \'\', amount: 0, omniScript: crypto_lib_1.base.toHex(opReturnScript) };\n        return opReturnOutput;\n    }\n    async estimateFee(param) {\n        try {\n            if (!param.data.runeData) {\n                return Promise.reject("missing runeData");\n            }\n            const runeTx = this.convert2RuneTx(param.data);\n            const opReturnOutput = this.getOpReturnOutput(this.network(), runeTx.runeData);\n            runeTx.outputs.push(opReturnOutput);\n            const fee = bitcoin.estimateBtcFee(runeTx, this.network());\n            return Promise.resolve(fee);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\nexports.RuneWallet = RuneWallet;\nclass RuneTestWallet extends RuneWallet {\n    network() {\n        return bitcoin.networks.testnet;\n    }\n}\nexports.RuneTestWallet = RuneTestWallet;\n//# sourceMappingURL=RuneWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L1J1bmVXYWxsZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLGtCQUFrQjtBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsd0ZBQWE7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsMEVBQVU7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVU7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLHdFQUFTO0FBQ2hDLHFCQUFxQixtQkFBTyxDQUFDLG1GQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L3dhbGxldC9SdW5lV2FsbGV0LmpzPzZhNzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUnVuZVRlc3RXYWxsZXQgPSBleHBvcnRzLlJ1bmVXYWxsZXQgPSB2b2lkIDA7XG5jb25zdCBjb2luX2Jhc2VfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jb2luLWJhc2VcIik7XG5jb25zdCBCdGNXYWxsZXRfMSA9IHJlcXVpcmUoXCIuL0J0Y1dhbGxldFwiKTtcbmNvbnN0IGJpdGNvaW4gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2luZGV4XCIpKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG5jb25zdCBydW5lXzEgPSByZXF1aXJlKFwiLi4vcnVuZVwiKTtcbmNvbnN0IGNyeXB0b19saWJfMSA9IHJlcXVpcmUoXCJAb2t4d2ViMy9jcnlwdG8tbGliXCIpO1xuY2xhc3MgUnVuZVdhbGxldCBleHRlbmRzIEJ0Y1dhbGxldF8xLkJ0Y1dhbGxldCB7XG4gICAgY29udmVydDJSdW5lVHgocGFyYW1EYXRhKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFBhcmFtRGF0YSA9ICgwLCBjb2luX2Jhc2VfMS5jbG9uZU9iamVjdCkocGFyYW1EYXRhKTtcbiAgICAgICAgZm9yIChsZXQgaW5wdXQgb2YgY2xvbmVkUGFyYW1EYXRhLmlucHV0cykge1xuICAgICAgICAgICAgbGV0IGRhdGFBcnJheSA9IGlucHV0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YUFycmF5ICE9IG51bGwgJiYgZGF0YUFycmF5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkYXRhIG9mIGRhdGFBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbXCJhbW91bnRcIl0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbXCJhbW91bnRcIl0gPSBCaWdJbnQoZGF0YVtcImFtb3VudFwiXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgb3V0cHV0IG9mIGNsb25lZFBhcmFtRGF0YS5vdXRwdXRzKSB7XG4gICAgICAgICAgICBsZXQgZGF0YUFycmF5ID0gb3V0cHV0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YUFycmF5ICE9IG51bGwgJiYgZGF0YUFycmF5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkYXRhIG9mIGRhdGFBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbXCJhbW91bnRcIl0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbXCJhbW91bnRcIl0gPSBCaWdJbnQoZGF0YVtcImFtb3VudFwiXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlucHV0cyA9IGNsb25lZFBhcmFtRGF0YS5pbnB1dHM7XG4gICAgICAgIGNvbnN0IHJ1bmVJbnB1dE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhQXJyYXkgPSBpbnB1dC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGFBcnJheSAhPSBudWxsICYmIGRhdGFBcnJheSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkYXRhIG9mIGRhdGFBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcnVuZUlkID0gZGF0YVtcImlkXCJdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcnVuZUFtb3VudCA9IEJpZ0ludChkYXRhW1wiYW1vdW50XCJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bmVJZCA9PSBudWxsIHx8IHJ1bmVBbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZUFtb3VudCA9IHJ1bmVJbnB1dE1hcC5nZXQocnVuZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZUFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5lSW5wdXRNYXAuc2V0KHJ1bmVJZCwgcnVuZUFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5lSW5wdXRNYXAuc2V0KHJ1bmVJZCwgKEJpZ0ludChiZWZvcmVBbW91bnQpICsgQmlnSW50KHJ1bmVBbW91bnQpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dHMgPSBjbG9uZWRQYXJhbURhdGEub3V0cHV0cztcbiAgICAgICAgY29uc3QgcnVuZVNlbmRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gb3V0cHV0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bmVJZCA9IGRhdGFbXCJpZFwiXTtcbiAgICAgICAgICAgICAgICBsZXQgcnVuZUFtb3VudCA9IEJpZ0ludChkYXRhW1wiYW1vdW50XCJdKTtcbiAgICAgICAgICAgICAgICBpZiAocnVuZUlkID09IG51bGwgfHwgcnVuZUFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlQW1vdW50ID0gcnVuZVNlbmRNYXAuZ2V0KHJ1bmVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZUFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bmVTZW5kTWFwLnNldChydW5lSWQsIHJ1bmVBbW91bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuZVNlbmRNYXAuc2V0KHJ1bmVJZCwgKEJpZ0ludChiZWZvcmVBbW91bnQpICsgQmlnSW50KHJ1bmVBbW91bnQpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpc1J1bmVDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBydW5lSW5wdXRNYXAua2V5cygpKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRBbW91bnQgPSBydW5lSW5wdXRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGxldCBzZW5kQW1vdW50ID0gcnVuZVNlbmRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmICgoaW5wdXRBbW91bnQgIT0gbnVsbCAmJiBzZW5kQW1vdW50ICE9IG51bGwgJiYgaW5wdXRBbW91bnQgPiBzZW5kQW1vdW50KSB8fCAoaW5wdXRBbW91bnQgIT0gbnVsbCAmJiBzZW5kQW1vdW50ID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgaXNSdW5lQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUnVuZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHVwZGF0ZU91dHB1dHMgPSBbXTtcbiAgICAgICAgaWYgKGlzUnVuZUNoYW5nZSkge1xuICAgICAgICAgICAgbGV0IHJ1bmVDaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogY2xvbmVkUGFyYW1EYXRhLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYW1vdW50OiA1NDZcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1cGRhdGVPdXRwdXRzLnB1c2gocnVuZUNoYW5nZSk7XG4gICAgICAgICAgICBvdXRwdXRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVkRWRpY3RzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gb3V0cHV0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bmVJZCA9IGRhdGFbXCJpZFwiXTtcbiAgICAgICAgICAgICAgICBsZXQgcnVuZUFtb3VudCA9IEJpZ0ludChkYXRhW1wiYW1vdW50XCJdKTtcbiAgICAgICAgICAgICAgICBpZiAocnVuZUlkID09IG51bGwgfHwgcnVuZUFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEVkaWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogcGFyc2VJbnQoJzB4JyArIHJ1bmVJZCksXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogQmlnSW50KHJ1bmVBbW91bnQpLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dEluZGV4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHlwZWRFZGljdHMucHVzaCh0eXBlZEVkaWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dC5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgIHVwZGF0ZU91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRzOiBjbG9uZWRQYXJhbURhdGEuaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogdXBkYXRlT3V0cHV0cyxcbiAgICAgICAgICAgIGFkZHJlc3M6IGNsb25lZFBhcmFtRGF0YS5hZGRyZXNzLFxuICAgICAgICAgICAgZmVlUGVyQjogY2xvbmVkUGFyYW1EYXRhLmZlZVBlckIsXG4gICAgICAgICAgICBydW5lRGF0YToge1xuICAgICAgICAgICAgICAgIGVkaWN0czogdHlwZWRFZGljdHMsXG4gICAgICAgICAgICAgICAgZXRjaGluZzogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmV0Y2hpbmcsXG4gICAgICAgICAgICAgICAgYnVybjogY2xvbmVkUGFyYW1EYXRhLnJ1bmVEYXRhLmJ1cm5cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbSkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrKCk7XG4gICAgICAgIGxldCB0eEhleCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gcGFyYW0ucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGlmICghcGFyYW0uZGF0YS5ydW5lRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIm1pc3NpbmcgcnVuZURhdGFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydW5lVHggPSB0aGlzLmNvbnZlcnQyUnVuZVR4KHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgY29uc3Qgb3BSZXR1cm5PdXRwdXQgPSB0aGlzLmdldE9wUmV0dXJuT3V0cHV0KG5ldHdvcmssIHJ1bmVUeC5ydW5lRGF0YSk7XG4gICAgICAgICAgICBydW5lVHgub3V0cHV0cy5wdXNoKG9wUmV0dXJuT3V0cHV0KTtcbiAgICAgICAgICAgIHR4SGV4ID0gKDAsIGluZGV4XzEuc2lnbkJ0YykocnVuZVR4LCBwcml2YXRlS2V5LCBuZXR3b3JrKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHhIZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0T3BSZXR1cm5PdXRwdXQobmV0d29yaywgcnVuZURhdGEpIHtcbiAgICAgICAgbGV0IGlzTWFpbm5ldCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5kZXhfMS5uZXR3b3Jrcy5iaXRjb2luID09PSBuZXR3b3JrKSB7XG4gICAgICAgICAgICBpc01haW5uZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5lRGF0YS5lZGljdHMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5lRGF0YS5lZGljdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcFJldHVyblNjcmlwdCA9ICgwLCBydW5lXzEuYnVpbGRSdW5lRGF0YSkoaXNNYWlubmV0LCBydW5lRGF0YS5lZGljdHMpO1xuICAgICAgICBjb25zdCBvcFJldHVybk91dHB1dCA9IHsgYWRkcmVzczogJycsIGFtb3VudDogMCwgb21uaVNjcmlwdDogY3J5cHRvX2xpYl8xLmJhc2UudG9IZXgob3BSZXR1cm5TY3JpcHQpIH07XG4gICAgICAgIHJldHVybiBvcFJldHVybk91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVGZWUocGFyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghcGFyYW0uZGF0YS5ydW5lRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIm1pc3NpbmcgcnVuZURhdGFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydW5lVHggPSB0aGlzLmNvbnZlcnQyUnVuZVR4KHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgY29uc3Qgb3BSZXR1cm5PdXRwdXQgPSB0aGlzLmdldE9wUmV0dXJuT3V0cHV0KHRoaXMubmV0d29yaygpLCBydW5lVHgucnVuZURhdGEpO1xuICAgICAgICAgICAgcnVuZVR4Lm91dHB1dHMucHVzaChvcFJldHVybk91dHB1dCk7XG4gICAgICAgICAgICBjb25zdCBmZWUgPSBiaXRjb2luLmVzdGltYXRlQnRjRmVlKHJ1bmVUeCwgdGhpcy5uZXR3b3JrKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmZWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJ1bmVXYWxsZXQgPSBSdW5lV2FsbGV0O1xuY2xhc3MgUnVuZVRlc3RXYWxsZXQgZXh0ZW5kcyBSdW5lV2FsbGV0IHtcbiAgICBuZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gYml0Y29pbi5uZXR3b3Jrcy50ZXN0bmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuUnVuZVRlc3RXYWxsZXQgPSBSdW5lVGVzdFdhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJ1bmVXYWxsZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/RuneWallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/UsdtWallet.js':
    /*!**********************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/UsdtWallet.js ***!
  \**********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.UsdtTestWallet = exports.UsdtWallet = void 0;\nconst coin_base_1 = __webpack_require__(/*! @okxweb3/coin-base */ "(ssr)/./node_modules/@okxweb3/coin-base/dist/index.js");\nconst BtcWallet_1 = __webpack_require__(/*! ./BtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js");\nconst bitcoin = __importStar(__webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/index.js"));\nclass UsdtWallet extends BtcWallet_1.BtcWallet {\n    async signTransaction(param) {\n        let txHex = null;\n        try {\n            const privateKey = param.privateKey;\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            if (!utxoTx.omni) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n            const coinType = (0, BtcWallet_1.number2Hex)(utxoTx.omni.coinType || 31, 8);\n            const amount = (0, BtcWallet_1.number2Hex)(utxoTx.omni.amount, 16);\n            const script = "6a146f6d6e69" + "0000" + "0000" + coinType + amount;\n            const extraOutput = { address: "", amount: 0, omniScript: script };\n            utxoTx.outputs.push(extraOutput);\n            txHex = bitcoin.signBtc(utxoTx, privateKey, this.network());\n            return Promise.resolve(txHex);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.SignTxError);\n        }\n    }\n    async estimateFee(param) {\n        try {\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            if (!utxoTx.omni) {\n                return Promise.reject(coin_base_1.EstimateFeeError);\n            }\n            const coinType = (0, BtcWallet_1.number2Hex)(utxoTx.omni.coinType || 31, 8);\n            const amount = (0, BtcWallet_1.number2Hex)(utxoTx.omni.amount, 16);\n            const script = "6a146f6d6e69" + "0000" + "0000" + coinType + amount;\n            const extraOutput = { address: "", amount: 0, omniScript: script };\n            utxoTx.outputs.push(extraOutput);\n            const fee = bitcoin.estimateBtcFee(utxoTx, this.network());\n            return Promise.resolve(fee);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.EstimateFeeError);\n        }\n    }\n    getHardWareRawTransaction(param) {\n        try {\n            const type = param.data.type || 0;\n            const utxoTx = (0, BtcWallet_1.convert2UtxoTx)(param.data);\n            if (!utxoTx.omni) {\n                return Promise.reject(coin_base_1.SignTxError);\n            }\n            const coinType = (0, BtcWallet_1.number2Hex)(utxoTx.omni.coinType || 31, 8);\n            const amount = (0, BtcWallet_1.number2Hex)(utxoTx.omni.amount, 16);\n            const script = "6a146f6d6e69" + "0000" + "0000" + coinType + amount;\n            const extraOutput = { address: "", amount: 0, omniScript: script };\n            utxoTx.outputs.push(extraOutput);\n            let txHex;\n            if (type === 2) {\n                const change = bitcoin.signBtc(utxoTx, "", this.network(), undefined, true, true);\n                const changeUtxo = {\n                    address: utxoTx.address,\n                    amount: parseInt(change),\n                    bip32Derivation: utxoTx.bip32Derivation\n                };\n                utxoTx.outputs.push(changeUtxo);\n                txHex = bitcoin.buildPsbt(utxoTx, this.network());\n            }\n            else {\n                txHex = bitcoin.signBtc(utxoTx, "", this.network(), undefined, true);\n            }\n            return Promise.resolve(txHex);\n        }\n        catch (e) {\n            return Promise.reject(coin_base_1.GetHardwareRawTransactionError);\n        }\n    }\n}\nexports.UsdtWallet = UsdtWallet;\nclass UsdtTestWallet extends UsdtWallet {\n    network() {\n        return bitcoin.networks.testnet;\n    }\n}\nexports.UsdtTestWallet = UsdtTestWallet;\n//# sourceMappingURL=UsdtWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L1VzZHRXYWxsZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLGtCQUFrQjtBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyxpRkFBb0I7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsd0ZBQWE7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsMEVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC93YWxsZXQvVXNkdFdhbGxldC5qcz83ZWQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVzZHRUZXN0V2FsbGV0ID0gZXhwb3J0cy5Vc2R0V2FsbGV0ID0gdm9pZCAwO1xuY29uc3QgY29pbl9iYXNlXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY29pbi1iYXNlXCIpO1xuY29uc3QgQnRjV2FsbGV0XzEgPSByZXF1aXJlKFwiLi9CdGNXYWxsZXRcIik7XG5jb25zdCBiaXRjb2luID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9pbmRleFwiKSk7XG5jbGFzcyBVc2R0V2FsbGV0IGV4dGVuZHMgQnRjV2FsbGV0XzEuQnRjV2FsbGV0IHtcbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgbGV0IHR4SGV4ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBwYXJhbS5wcml2YXRlS2V5O1xuICAgICAgICAgICAgY29uc3QgdXR4b1R4ID0gKDAsIEJ0Y1dhbGxldF8xLmNvbnZlcnQyVXR4b1R4KShwYXJhbS5kYXRhKTtcbiAgICAgICAgICAgIGlmICghdXR4b1R4Lm9tbmkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnblR4RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29pblR5cGUgPSAoMCwgQnRjV2FsbGV0XzEubnVtYmVyMkhleCkodXR4b1R4Lm9tbmkuY29pblR5cGUgfHwgMzEsIDgpO1xuICAgICAgICAgICAgY29uc3QgYW1vdW50ID0gKDAsIEJ0Y1dhbGxldF8xLm51bWJlcjJIZXgpKHV0eG9UeC5vbW5pLmFtb3VudCwgMTYpO1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gXCI2YTE0NmY2ZDZlNjlcIiArIFwiMDAwMFwiICsgXCIwMDAwXCIgKyBjb2luVHlwZSArIGFtb3VudDtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhT3V0cHV0ID0geyBhZGRyZXNzOiBcIlwiLCBhbW91bnQ6IDAsIG9tbmlTY3JpcHQ6IHNjcmlwdCB9O1xuICAgICAgICAgICAgdXR4b1R4Lm91dHB1dHMucHVzaChleHRyYU91dHB1dCk7XG4gICAgICAgICAgICB0eEhleCA9IGJpdGNvaW4uc2lnbkJ0Yyh1dHhvVHgsIHByaXZhdGVLZXksIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHhIZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29pbl9iYXNlXzEuU2lnblR4RXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlRmVlKHBhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1dHhvVHggPSAoMCwgQnRjV2FsbGV0XzEuY29udmVydDJVdHhvVHgpKHBhcmFtLmRhdGEpO1xuICAgICAgICAgICAgaWYgKCF1dHhvVHgub21uaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb2luX2Jhc2VfMS5Fc3RpbWF0ZUZlZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvaW5UeXBlID0gKDAsIEJ0Y1dhbGxldF8xLm51bWJlcjJIZXgpKHV0eG9UeC5vbW5pLmNvaW5UeXBlIHx8IDMxLCA4KTtcbiAgICAgICAgICAgIGNvbnN0IGFtb3VudCA9ICgwLCBCdGNXYWxsZXRfMS5udW1iZXIySGV4KSh1dHhvVHgub21uaS5hbW91bnQsIDE2KTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IFwiNmExNDZmNmQ2ZTY5XCIgKyBcIjAwMDBcIiArIFwiMDAwMFwiICsgY29pblR5cGUgKyBhbW91bnQ7XG4gICAgICAgICAgICBjb25zdCBleHRyYU91dHB1dCA9IHsgYWRkcmVzczogXCJcIiwgYW1vdW50OiAwLCBvbW5pU2NyaXB0OiBzY3JpcHQgfTtcbiAgICAgICAgICAgIHV0eG9UeC5vdXRwdXRzLnB1c2goZXh0cmFPdXRwdXQpO1xuICAgICAgICAgICAgY29uc3QgZmVlID0gYml0Y29pbi5lc3RpbWF0ZUJ0Y0ZlZSh1dHhvVHgsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLkVzdGltYXRlRmVlRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEhhcmRXYXJlUmF3VHJhbnNhY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbS5kYXRhLnR5cGUgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHV0eG9UeCA9ICgwLCBCdGNXYWxsZXRfMS5jb252ZXJ0MlV0eG9UeCkocGFyYW0uZGF0YSk7XG4gICAgICAgICAgICBpZiAoIXV0eG9UeC5vbW5pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLlNpZ25UeEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvaW5UeXBlID0gKDAsIEJ0Y1dhbGxldF8xLm51bWJlcjJIZXgpKHV0eG9UeC5vbW5pLmNvaW5UeXBlIHx8IDMxLCA4KTtcbiAgICAgICAgICAgIGNvbnN0IGFtb3VudCA9ICgwLCBCdGNXYWxsZXRfMS5udW1iZXIySGV4KSh1dHhvVHgub21uaS5hbW91bnQsIDE2KTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IFwiNmExNDZmNmQ2ZTY5XCIgKyBcIjAwMDBcIiArIFwiMDAwMFwiICsgY29pblR5cGUgKyBhbW91bnQ7XG4gICAgICAgICAgICBjb25zdCBleHRyYU91dHB1dCA9IHsgYWRkcmVzczogXCJcIiwgYW1vdW50OiAwLCBvbW5pU2NyaXB0OiBzY3JpcHQgfTtcbiAgICAgICAgICAgIHV0eG9UeC5vdXRwdXRzLnB1c2goZXh0cmFPdXRwdXQpO1xuICAgICAgICAgICAgbGV0IHR4SGV4O1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBiaXRjb2luLnNpZ25CdGModXR4b1R4LCBcIlwiLCB0aGlzLm5ldHdvcmsoKSwgdW5kZWZpbmVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VVdHhvID0ge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB1dHhvVHguYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBwYXJzZUludChjaGFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICBiaXAzMkRlcml2YXRpb246IHV0eG9UeC5iaXAzMkRlcml2YXRpb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHV0eG9UeC5vdXRwdXRzLnB1c2goY2hhbmdlVXR4byk7XG4gICAgICAgICAgICAgICAgdHhIZXggPSBiaXRjb2luLmJ1aWxkUHNidCh1dHhvVHgsIHRoaXMubmV0d29yaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR4SGV4ID0gYml0Y29pbi5zaWduQnRjKHV0eG9UeCwgXCJcIiwgdGhpcy5uZXR3b3JrKCksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHR4SGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvaW5fYmFzZV8xLkdldEhhcmR3YXJlUmF3VHJhbnNhY3Rpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlVzZHRXYWxsZXQgPSBVc2R0V2FsbGV0O1xuY2xhc3MgVXNkdFRlc3RXYWxsZXQgZXh0ZW5kcyBVc2R0V2FsbGV0IHtcbiAgICBuZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gYml0Y29pbi5uZXR3b3Jrcy50ZXN0bmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuVXNkdFRlc3RXYWxsZXQgPSBVc2R0VGVzdFdhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVzZHRXYWxsZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/UsdtWallet.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/index.js':
    /*!*****************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wallet/index.js ***!
  \*****************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./BtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BtcWallet.js"), exports);\n__exportStar(__webpack_require__(/*! ./BchWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BchWallet.js"), exports);\n__exportStar(__webpack_require__(/*! ./BsvWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/BsvWallet.js"), exports);\n__exportStar(__webpack_require__(/*! ./DogeWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/DogeWallet.js"), exports);\n__exportStar(__webpack_require__(/*! ./LtcWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/LtcWallet.js"), exports);\n__exportStar(__webpack_require__(/*! ./UsdtWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/UsdtWallet.js"), exports);\n__exportStar(__webpack_require__(/*! ./RuneWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/RuneWallet.js"), exports);\n__exportStar(__webpack_require__(/*! ./RuneMainWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/RuneMainWallet.js"), exports);\n__exportStar(__webpack_require__(/*! ./AtomicalWallet */ "(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/AtomicalWallet.js"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2FsbGV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx3RkFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsd0ZBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLHdGQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQywwRkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsd0ZBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDBGQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQywwRkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsa0dBQWtCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxrR0FBa0I7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jb2luLWJpdGNvaW4vZGlzdC93YWxsZXQvaW5kZXguanM/ZjAxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0J0Y1dhbGxldFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQmNoV2FsbGV0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Cc3ZXYWxsZXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0RvZ2VXYWxsZXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0x0Y1dhbGxldFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVXNkdFdhbGxldFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUnVuZVdhbGxldFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUnVuZU1haW5XYWxsZXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0F0b21pY2FsV2FsbGV0XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wallet/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wif.js':
    /*!********************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/dist/wif.js ***!
  \********************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = exports.encodeRaw = exports.decodeRaw = void 0;\nconst crypto_lib_1 = __webpack_require__(/*! @okxweb3/crypto-lib */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\");\nfunction decodeRaw(buffer, version) {\n    if (version !== undefined && buffer[0] !== version)\n        throw new Error('Invalid network version');\n    if (buffer.length === 33) {\n        return {\n            version: buffer[0],\n            privateKey: buffer.slice(1, 33),\n            compressed: false\n        };\n    }\n    if (buffer.length !== 34)\n        throw new Error('Invalid WIF length');\n    if (buffer[33] !== 0x01)\n        throw new Error('Invalid compression flag');\n    return {\n        version: buffer[0],\n        privateKey: buffer.slice(1, 33),\n        compressed: true\n    };\n}\nexports.decodeRaw = decodeRaw;\nfunction encodeRaw(version, privateKey, compressed) {\n    const result = Buffer.alloc(compressed ? 34 : 33);\n    result.writeUInt8(version, 0);\n    privateKey.copy(result, 1);\n    if (compressed) {\n        result[33] = 0x01;\n    }\n    return result;\n}\nexports.encodeRaw = encodeRaw;\nfunction decode(str, version) {\n    return decodeRaw(crypto_lib_1.base.fromBase58Check(str), version);\n}\nexports.decode = decode;\nfunction encode(version, privateKey, compressed) {\n    if (typeof version === 'number')\n        return crypto_lib_1.base.toBase58Check(encodeRaw(version, privateKey, compressed));\n    return crypto_lib_1.base.toBase58Check(encodeRaw(version.version, version.privateKey, version.compressed));\n}\nexports.encode = encode;\n//# sourceMappingURL=wif.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL2Rpc3Qvd2lmLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ3ZFLHFCQUFxQixtQkFBTyxDQUFDLG1GQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NvaW4tYml0Y29pbi9kaXN0L3dpZi5qcz81MGRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlUmF3ID0gZXhwb3J0cy5kZWNvZGVSYXcgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fbGliXzEgPSByZXF1aXJlKFwiQG9reHdlYjMvY3J5cHRvLWxpYlwiKTtcbmZ1bmN0aW9uIGRlY29kZVJhdyhidWZmZXIsIHZlcnNpb24pIHtcbiAgICBpZiAodmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmIGJ1ZmZlclswXSAhPT0gdmVyc2lvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5ldHdvcmsgdmVyc2lvbicpO1xuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAzMykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogYnVmZmVyWzBdLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogYnVmZmVyLnNsaWNlKDEsIDMzKSxcbiAgICAgICAgICAgIGNvbXByZXNzZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChidWZmZXIubGVuZ3RoICE9PSAzNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdJRiBsZW5ndGgnKTtcbiAgICBpZiAoYnVmZmVyWzMzXSAhPT0gMHgwMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGZsYWcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiBidWZmZXJbMF0sXG4gICAgICAgIHByaXZhdGVLZXk6IGJ1ZmZlci5zbGljZSgxLCAzMyksXG4gICAgICAgIGNvbXByZXNzZWQ6IHRydWVcbiAgICB9O1xufVxuZXhwb3J0cy5kZWNvZGVSYXcgPSBkZWNvZGVSYXc7XG5mdW5jdGlvbiBlbmNvZGVSYXcodmVyc2lvbiwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhjb21wcmVzc2VkID8gMzQgOiAzMyk7XG4gICAgcmVzdWx0LndyaXRlVUludDgodmVyc2lvbiwgMCk7XG4gICAgcHJpdmF0ZUtleS5jb3B5KHJlc3VsdCwgMSk7XG4gICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgcmVzdWx0WzMzXSA9IDB4MDE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmVuY29kZVJhdyA9IGVuY29kZVJhdztcbmZ1bmN0aW9uIGRlY29kZShzdHIsIHZlcnNpb24pIHtcbiAgICByZXR1cm4gZGVjb2RlUmF3KGNyeXB0b19saWJfMS5iYXNlLmZyb21CYXNlNThDaGVjayhzdHIpLCB2ZXJzaW9uKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHZlcnNpb24sIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gY3J5cHRvX2xpYl8xLmJhc2UudG9CYXNlNThDaGVjayhlbmNvZGVSYXcodmVyc2lvbiwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkpO1xuICAgIHJldHVybiBjcnlwdG9fbGliXzEuYmFzZS50b0Jhc2U1OENoZWNrKGVuY29kZVJhdyh2ZXJzaW9uLnZlcnNpb24sIHZlcnNpb24ucHJpdmF0ZUtleSwgdmVyc2lvbi5jb21wcmVzc2VkKSk7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/dist/wif.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/coin-bitcoin/node_modules/big-integer/BigInteger.js':
    /*!***********************************************************************************!*\
  !*** ./node_modules/@okxweb3/coin-bitcoin/node_modules/big-integer/BigInteger.js ***!
  \***********************************************************************************/
    /***/ (module, exports, __webpack_require__) => {
      eval(
        '/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = (function (undefined) {\r\n    "use strict";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        LOG_MAX_INT = Math.log(MAX_INT);\r\n\r\n    function Integer(v, radix) {\r\n        if (typeof v === "undefined") return Integer[0];\r\n        if (typeof radix !== "undefined") return +radix === 10 ? parseValue(v) : parseBase(v, radix);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn\'t reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle\'s library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === "number") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === "number") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt\'s library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error("Cannot divide by zero");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === "number") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === "number") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === "number") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        var value = n.value;\r\n        if (value === 0) return false;\r\n        if (value === 1) return true;\r\n        if (value === 2) return this.isEven();\r\n        return this.mod(n).equals(Integer[0]);\r\n    };\r\n    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don\'t know if it\'s prime: let the other functions figure it out\r\n    }\r\n    \r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next : for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;    \r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n// Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if(bits <= 64)\r\n            return millerRabinTest(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);\r\n        var logN = Math.log(2) * bits;\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2)));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.equals(bigInt.zero)) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.equals(1)) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return ((typeof n === "number" || typeof n === "string") && +Math.abs(n) <= BASE) ||\r\n            (n instanceof BigInteger && n.value.length <= 1);\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (n) {\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + " is too large for shifting.");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (n) {\r\n        var remQuo;\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + " is too large for shifting.");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two\'s complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two\'s complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = Math.min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(Math.random() * range));\r\n        var length = range.value.length - 1;\r\n        var result = [], restricted = true;\r\n        for (var i = length; i >= 0; i--) {\r\n            var top = restricted ? range.value[i] : BASE;\r\n            var digit = truncate(Math.random() * top);\r\n            result.unshift(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        result = arrayToSmall(result);\r\n        return low.add(typeof result === "number" ? new SmallInteger(result) : new BigInteger(result, false));\r\n    }\r\n    var parseBase = function (text, base) {\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        for (var i = 0; i < length; i++) {\r\n            var c = text[i].toLowerCase();\r\n            if (c === "-") continue;\r\n            if (/[a-z0-9]/.test(c)) {\r\n                if (/[0-9]/.test(c) && +c >= absBase) {\r\n                    if (c === "1" && absBase === 1) continue;\r\n                    throw new Error(c + " is not a valid digit in base " + base + ".");\r\n                } else if (c.charCodeAt(0) - 87 >= absBase) {\r\n                    throw new Error(c + " is not a valid digit in base " + base + ".");\r\n                }\r\n            }\r\n        }\r\n        if (2 <= base && base <= 36) {\r\n            if (length <= LOG_MAX_INT / Math.log(base)) {\r\n                var result = parseInt(text, base);\r\n                if (isNaN(result)) {\r\n                    throw new Error(c + " is not a valid digit in base " + base + ".");\r\n                }\r\n                return new SmallInteger(parseInt(text, base));\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === "-";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i].toLowerCase(),\r\n                charCode = c.charCodeAt(0);\r\n            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));\r\n            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));\r\n            else if (c === "<") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== ">");\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + " is not a valid character");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit) {\r\n        if (digit <= 35) {\r\n            return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(digit);\r\n        }\r\n        return "<" + digit + ">";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error("Cannot convert nonzero numbers to base 0.");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(+n - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.equals(1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(+n))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? "-" : "") + arr.value.map(stringify).join(\'\');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? "-" : "";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix);\r\n        return String(this.value);\r\n    };\r\n    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return new SmallInteger(x);\r\n            throw new Error("Invalid integer: " + v);\r\n        }\r\n        var sign = v[0] === "-";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === "+") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(".");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");\r\n            text += (new Array(exp + 1)).join("0");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error("Invalid integer: " + v);\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + " is not an integer.");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === "number") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === "string") {\r\n            return parseStringValue(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = new SmallInteger(i);\r\n        if (i > 0) Integer[-i] = new SmallInteger(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif ( true && module.hasOwnProperty("exports")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n        return bigInt;\r\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL25vZGVfbW9kdWxlcy9iaWctaW50ZWdlci9CaWdJbnRlZ2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxlQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUJBQXFCLElBQUk7QUFDeEU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSSxLQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBMEM7QUFDOUMsSUFBSSxpQ0FBc0IsRUFBRSxtQ0FBRTtBQUM5QjtBQUNBLEtBQUs7QUFBQSxrR0FBQztBQUNOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY29pbi1iaXRjb2luL25vZGVfbW9kdWxlcy9iaWctaW50ZWdlci9CaWdJbnRlZ2VyLmpzP2QwMzYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJpZ0ludCA9IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgQkFTRSA9IDFlNyxcclxuICAgICAgICBMT0dfQkFTRSA9IDcsXHJcbiAgICAgICAgTUFYX0lOVCA9IDkwMDcxOTkyNTQ3NDA5OTIsXHJcbiAgICAgICAgTUFYX0lOVF9BUlIgPSBzbWFsbFRvQXJyYXkoTUFYX0lOVCksXHJcbiAgICAgICAgTE9HX01BWF9JTlQgPSBNYXRoLmxvZyhNQVhfSU5UKTtcclxuXHJcbiAgICBmdW5jdGlvbiBJbnRlZ2VyKHYsIHJhZGl4KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICBpZiAodHlwZW9mIHJhZGl4ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gK3JhZGl4ID09PSAxMCA/IHBhcnNlVmFsdWUodikgOiBwYXJzZUJhc2UodiwgcmFkaXgpO1xyXG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHYpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEJpZ0ludGVnZXIodmFsdWUsIHNpZ24pIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zaWduID0gc2lnbjtcclxuICAgICAgICB0aGlzLmlzU21hbGwgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlZ2VyLnByb3RvdHlwZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gU21hbGxJbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2lnbiA9IHZhbHVlIDwgMDtcclxuICAgICAgICB0aGlzLmlzU21hbGwgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzUHJlY2lzZShuKSB7XHJcbiAgICAgICAgcmV0dXJuIC1NQVhfSU5UIDwgbiAmJiBuIDwgTUFYX0lOVDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbWFsbFRvQXJyYXkobikgeyAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBkb2Vzbid0IHJlZmVyZW5jZSBCQVNFLCBuZWVkIHRvIGNoYW5nZSB0aGlzIGZ1bmN0aW9uIGlmIEJBU0UgY2hhbmdlc1xyXG4gICAgICAgIGlmIChuIDwgMWU3KVxyXG4gICAgICAgICAgICByZXR1cm4gW25dO1xyXG4gICAgICAgIGlmIChuIDwgMWUxNClcclxuICAgICAgICAgICAgcmV0dXJuIFtuICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTcpXTtcclxuICAgICAgICByZXR1cm4gW24gJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlNykgJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlMTQpXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcnJheVRvU21hbGwoYXJyKSB7IC8vIElmIEJBU0UgY2hhbmdlcyB0aGlzIGZ1bmN0aW9uIG1heSBuZWVkIHRvIGNoYW5nZVxyXG4gICAgICAgIHRyaW0oYXJyKTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoIDwgNCAmJiBjb21wYXJlQWJzKGFyciwgTUFYX0lOVF9BUlIpIDwgMCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGFyclswXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGFyclswXSArIGFyclsxXSAqIEJBU0U7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gYXJyWzBdICsgKGFyclsxXSArIGFyclsyXSAqIEJBU0UpICogQkFTRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyaW0odikge1xyXG4gICAgICAgIHZhciBpID0gdi5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKHZbLS1pXSA9PT0gMCk7XHJcbiAgICAgICAgdi5sZW5ndGggPSBpICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpIHsgLy8gZnVuY3Rpb24gc2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gWWFmZmxlJ3MgbGlicmFyeSBodHRwczovL2dpdGh1Yi5jb20vWWFmZmxlL0JpZ0ludGVnZXJcclxuICAgICAgICB2YXIgeCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIHZhciBpID0gLTE7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB4W2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUobikge1xyXG4gICAgICAgIGlmIChuID4gMCkgcmV0dXJuIE1hdGguZmxvb3Iobik7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChuKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGQoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEubGVuZ3RoID49IGIubGVuZ3RoXHJcbiAgICAgICAgdmFyIGxfYSA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBsX2IgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsX2EpLFxyXG4gICAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBzdW0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxfYjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gKyBiW2ldICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gc3VtID49IGJhc2UgPyAxIDogMDtcclxuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsX2EpIHtcclxuICAgICAgICAgICAgc3VtID0gYVtpXSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IHN1bSA9PT0gYmFzZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICByW2krK10gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYXJyeSA+IDApIHIucHVzaChjYXJyeSk7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkQW55KGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggPj0gYi5sZW5ndGgpIHJldHVybiBhZGQoYSwgYik7XHJcbiAgICAgICAgcmV0dXJuIGFkZChiLCBhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTbWFsbChhLCBjYXJyeSkgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGNhcnJ5IGlzIG51bWJlciB3aXRoIDAgPD0gY2FycnkgPCBNQVhfSU5UXHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHN1bSwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gLSBiYXNlICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihzdW0gLyBiYXNlKTtcclxuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICAgICAgY2FycnkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xyXG4gICAgICAgICAgICByW2krK10gPSBjYXJyeSAlIGJhc2U7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYSwgTWF0aC5hYnMoYikpLCB0aGlzLnNpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkQW55KGEsIGIpLCB0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBsdXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UoYSArIGIpKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhICsgYik7XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoTWF0aC5hYnMoYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYiwgTWF0aC5hYnMoYSkpLCBhIDwgMCk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wbHVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEgPj0gYlxyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkoYV9sKSxcclxuICAgICAgICAgICAgYm9ycm93ID0gMCxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGksIGRpZmZlcmVuY2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93IC0gYltpXTtcclxuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlICs9IGJhc2U7XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IGJfbDsgaSA8IGFfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93O1xyXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA8IDApIGRpZmZlcmVuY2UgKz0gYmFzZTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByW2krK10gPSBkaWZmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoOyBpIDwgYV9sOyBpKyspIHtcclxuICAgICAgICAgICAgcltpXSA9IGFbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3RBbnkoYSwgYiwgc2lnbikge1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICBpZiAoY29tcGFyZUFicyhhLCBiKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gc3VidHJhY3QoYSwgYik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBzdWJ0cmFjdChiLCBhKTtcclxuICAgICAgICAgICAgc2lnbiA9ICFzaWduO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZSA9IGFycmF5VG9TbWFsbCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAoc2lnbikgdmFsdWUgPSAtdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHZhbHVlLCBzaWduKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdFNtYWxsKGEsIGIsIHNpZ24pIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBiIGlzIG51bWJlciB3aXRoIDAgPD0gYiA8IE1BWF9JTlRcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxyXG4gICAgICAgICAgICBjYXJyeSA9IC1iLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgaSwgZGlmZmVyZW5jZTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihkaWZmZXJlbmNlIC8gYmFzZSk7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgJT0gYmFzZTtcclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2UgPCAwID8gZGlmZmVyZW5jZSArIGJhc2UgOiBkaWZmZXJlbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByID0gYXJyYXlUb1NtYWxsKHIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgciA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAoc2lnbikgciA9IC1yO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihyKTtcclxuICAgICAgICB9IHJldHVybiBuZXcgQmlnSW50ZWdlcihyLCBzaWduKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24gIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbClcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwoYSwgTWF0aC5hYnMoYiksIHRoaXMuc2lnbik7XHJcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0QW55KGEsIGIsIHRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWludXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmIChhIDwgMCAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChuLm5lZ2F0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYSAtIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbChiLCBNYXRoLmFicyhhKSwgYSA+PSAwKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm1pbnVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMudmFsdWUsICF0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzaWduID0gdGhpcy5zaWduO1xyXG4gICAgICAgIHZhciBzbWFsbCA9IG5ldyBTbWFsbEludGVnZXIoLXRoaXMudmFsdWUpO1xyXG4gICAgICAgIHNtYWxsLnNpZ24gPSAhc2lnbjtcclxuICAgICAgICByZXR1cm4gc21hbGw7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKE1hdGguYWJzKHRoaXMudmFsdWUpKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlMb25nKGEsIGIpIHtcclxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICBsID0gYV9sICsgYl9sLFxyXG4gICAgICAgICAgICByID0gY3JlYXRlQXJyYXkobCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBwcm9kdWN0LCBjYXJyeSwgaSwgYV9pLCBiX2o7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFfbDsgKytpKSB7XHJcbiAgICAgICAgICAgIGFfaSA9IGFbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYl9sOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGJfaiA9IGJbal07XHJcbiAgICAgICAgICAgICAgICBwcm9kdWN0ID0gYV9pICogYl9qICsgcltpICsgal07XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcltpICsgal0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgICAgICAgICAgcltpICsgaiArIDFdICs9IGNhcnJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlTbWFsbChhLCBiKSB7IC8vIGFzc3VtZXMgYSBpcyBhcnJheSwgYiBpcyBudW1iZXIgd2l0aCB8YnwgPCBCQVNFXHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgICAgcHJvZHVjdCwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHByb2R1Y3QgPSBhW2ldICogYiArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xyXG4gICAgICAgICAgICByW2ldID0gcHJvZHVjdCAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xyXG4gICAgICAgICAgICByW2krK10gPSBjYXJyeSAlIGJhc2U7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzaGlmdExlZnQoeCwgbikge1xyXG4gICAgICAgIHZhciByID0gW107XHJcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHIucHVzaCgwKTtcclxuICAgICAgICByZXR1cm4gci5jb25jYXQoeCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlLYXJhdHN1YmEoeCwgeSkge1xyXG4gICAgICAgIHZhciBuID0gTWF0aC5tYXgoeC5sZW5ndGgsIHkubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgaWYgKG4gPD0gMzApIHJldHVybiBtdWx0aXBseUxvbmcoeCwgeSk7XHJcbiAgICAgICAgbiA9IE1hdGguY2VpbChuIC8gMik7XHJcblxyXG4gICAgICAgIHZhciBiID0geC5zbGljZShuKSxcclxuICAgICAgICAgICAgYSA9IHguc2xpY2UoMCwgbiksXHJcbiAgICAgICAgICAgIGQgPSB5LnNsaWNlKG4pLFxyXG4gICAgICAgICAgICBjID0geS5zbGljZSgwLCBuKTtcclxuXHJcbiAgICAgICAgdmFyIGFjID0gbXVsdGlwbHlLYXJhdHN1YmEoYSwgYyksXHJcbiAgICAgICAgICAgIGJkID0gbXVsdGlwbHlLYXJhdHN1YmEoYiwgZCksXHJcbiAgICAgICAgICAgIGFiY2QgPSBtdWx0aXBseUthcmF0c3ViYShhZGRBbnkoYSwgYiksIGFkZEFueShjLCBkKSk7XHJcblxyXG4gICAgICAgIHZhciBwcm9kdWN0ID0gYWRkQW55KGFkZEFueShhYywgc2hpZnRMZWZ0KHN1YnRyYWN0KHN1YnRyYWN0KGFiY2QsIGFjKSwgYmQpLCBuKSksIHNoaWZ0TGVmdChiZCwgMiAqIG4pKTtcclxuICAgICAgICB0cmltKHByb2R1Y3QpO1xyXG4gICAgICAgIHJldHVybiBwcm9kdWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIGEgc3VyZmFjZSBmaXQgb2YgYSBncmFwaCBwbG90dGluZyB0aGUgcGVyZm9ybWFuY2UgZGlmZmVyZW5jZVxyXG4gICAgLy8gYmV0d2VlbiBsb25nIG11bHRpcGxpY2F0aW9uIGFuZCBrYXJhdHN1YmEgbXVsdGlwbGljYXRpb24gdmVyc3VzIHRoZSBsZW5ndGhzIG9mIHRoZSB0d28gYXJyYXlzLlxyXG4gICAgZnVuY3Rpb24gdXNlS2FyYXRzdWJhKGwxLCBsMikge1xyXG4gICAgICAgIHJldHVybiAtMC4wMTIgKiBsMSAtIDAuMDEyICogbDIgKyAwLjAwMDAxNSAqIGwxICogbDIgPiAwO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZSxcclxuICAgICAgICAgICAgc2lnbiA9IHRoaXMuc2lnbiAhPT0gbi5zaWduLFxyXG4gICAgICAgICAgICBhYnM7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgICAgIGlmIChiID09PSAxKSByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgaWYgKGIgPT09IC0xKSByZXR1cm4gdGhpcy5uZWdhdGUoKTtcclxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMoYik7XHJcbiAgICAgICAgICAgIGlmIChhYnMgPCBCQVNFKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlTbWFsbChhLCBhYnMpLCBzaWduKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gc21hbGxUb0FycmF5KGFicyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1c2VLYXJhdHN1YmEoYS5sZW5ndGgsIGIubGVuZ3RoKSkgLy8gS2FyYXRzdWJhIGlzIG9ubHkgZmFzdGVyIGZvciBjZXJ0YWluIGFycmF5IHNpemVzXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUthcmF0c3ViYShhLCBiKSwgc2lnbik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5TG9uZyhhLCBiKSwgc2lnbik7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRpbWVzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlTbWFsbEFuZEFycmF5KGEsIGIsIHNpZ24pIHsgLy8gYSA+PSAwXHJcbiAgICAgICAgaWYgKGEgPCBCQVNFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseVNtYWxsKGIsIGEpLCBzaWduKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5TG9uZyhiLCBzbWFsbFRvQXJyYXkoYSkpLCBzaWduKTtcclxuICAgIH1cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgaWYgKGlzUHJlY2lzZShhLnZhbHVlICogdGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYS52YWx1ZSAqIHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLCBzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpLCB0aGlzLnNpZ24gIT09IGEuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgaWYgKGEudmFsdWUgPT09IDApIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgIGlmIChhLnZhbHVlID09PSAxKSByZXR1cm4gdGhpcztcclxuICAgICAgICBpZiAoYS52YWx1ZSA9PT0gLTEpIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xyXG4gICAgICAgIHJldHVybiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoTWF0aC5hYnMoYS52YWx1ZSksIHRoaXMudmFsdWUsIHRoaXMuc2lnbiAhPT0gYS5zaWduKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VWYWx1ZSh2KS5fbXVsdGlwbHlCeVNtYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudGltZXMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNxdWFyZShhKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmFzc2VydCgyICogQkFTRSAqIEJBU0UgPCBNQVhfSU5UKTtcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gY3JlYXRlQXJyYXkobCArIGwpLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgcHJvZHVjdCwgY2FycnksIGksIGFfaSwgYV9qO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgYV9pID0gYVtpXTtcclxuICAgICAgICAgICAgY2FycnkgPSAwIC0gYV9pICogYV9pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYV9qID0gYVtqXTtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3QgPSAyICogKGFfaSAqIGFfaikgKyByW2kgKyBqXSArIGNhcnJ5O1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHByb2R1Y3QgLyBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHJbaSArIGpdID0gcHJvZHVjdCAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW2kgKyBsXSA9IGNhcnJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmltKHIpO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoc3F1YXJlKHRoaXMudmFsdWUpLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUgKiB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmIChpc1ByZWNpc2UodmFsdWUpKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHNxdWFyZShzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpKSwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBkaXZNb2QxKGEsIGIpIHsgLy8gTGVmdCBvdmVyIGZyb20gcHJldmlvdXMgdmVyc2lvbi4gUGVyZm9ybXMgZmFzdGVyIHRoYW4gZGl2TW9kMiBvbiBzbWFsbGVyIGlucHV0IHNpemVzLlxyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICByZXN1bHQgPSBjcmVhdGVBcnJheShiLmxlbmd0aCksXHJcbiAgICAgICAgICAgIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCA9IGJbYl9sIC0gMV0sXHJcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb25cclxuICAgICAgICAgICAgbGFtYmRhID0gTWF0aC5jZWlsKGJhc2UgLyAoMiAqIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCkpLFxyXG4gICAgICAgICAgICByZW1haW5kZXIgPSBtdWx0aXBseVNtYWxsKGEsIGxhbWJkYSksXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBtdWx0aXBseVNtYWxsKGIsIGxhbWJkYSksXHJcbiAgICAgICAgICAgIHF1b3RpZW50RGlnaXQsIHNoaWZ0LCBjYXJyeSwgYm9ycm93LCBpLCBsLCBxO1xyXG4gICAgICAgIGlmIChyZW1haW5kZXIubGVuZ3RoIDw9IGFfbCkgcmVtYWluZGVyLnB1c2goMCk7XHJcbiAgICAgICAgZGl2aXNvci5wdXNoKDApO1xyXG4gICAgICAgIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCA9IGRpdmlzb3JbYl9sIC0gMV07XHJcbiAgICAgICAgZm9yIChzaGlmdCA9IGFfbCAtIGJfbDsgc2hpZnQgPj0gMDsgc2hpZnQtLSkge1xyXG4gICAgICAgICAgICBxdW90aWVudERpZ2l0ID0gYmFzZSAtIDE7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5kZXJbc2hpZnQgKyBiX2xdICE9PSBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpIHtcclxuICAgICAgICAgICAgICAgIHF1b3RpZW50RGlnaXQgPSBNYXRoLmZsb29yKChyZW1haW5kZXJbc2hpZnQgKyBiX2xdICogYmFzZSArIHJlbWFpbmRlcltzaGlmdCArIGJfbCAtIDFdKSAvIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcXVvdGllbnREaWdpdCA8PSBiYXNlIC0gMVxyXG4gICAgICAgICAgICBjYXJyeSA9IDA7XHJcbiAgICAgICAgICAgIGJvcnJvdyA9IDA7XHJcbiAgICAgICAgICAgIGwgPSBkaXZpc29yLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2FycnkgKz0gcXVvdGllbnREaWdpdCAqIGRpdmlzb3JbaV07XHJcbiAgICAgICAgICAgICAgICBxID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgYm9ycm93ICs9IHJlbWFpbmRlcltzaGlmdCArIGldIC0gKGNhcnJ5IC0gcSAqIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSBxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvcnJvdyA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGJvcnJvdyArIGJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9ycm93ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gYm9ycm93O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcnJvdyA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKGJvcnJvdyAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcXVvdGllbnREaWdpdCAtPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ICs9IHJlbWFpbmRlcltzaGlmdCArIGldIC0gYmFzZSArIGRpdmlzb3JbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcnJ5IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGNhcnJ5ICsgYmFzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gY2Fycnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgKz0gY2Fycnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0W3NoaWZ0XSA9IHF1b3RpZW50RGlnaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRlbm9ybWFsaXphdGlvblxyXG4gICAgICAgIHJlbWFpbmRlciA9IGRpdk1vZFNtYWxsKHJlbWFpbmRlciwgbGFtYmRhKVswXTtcclxuICAgICAgICByZXR1cm4gW2FycmF5VG9TbWFsbChyZXN1bHQpLCBhcnJheVRvU21hbGwocmVtYWluZGVyKV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kMihhLCBiKSB7IC8vIEltcGxlbWVudGF0aW9uIGlkZWEgc2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gU2lsZW50IE1hdHQncyBsaWJyYXJ5IGh0dHA6Ly9zaWxlbnRtYXR0LmNvbS9iaWdpbnRlZ2VyL1xyXG4gICAgICAgIC8vIFBlcmZvcm1zIGZhc3RlciB0aGFuIGRpdk1vZDEgb24gbGFyZ2VyIGlucHV0IHNpemVzLlxyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBwYXJ0ID0gW10sXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBndWVzcywgeGxlbiwgaGlnaHgsIGhpZ2h5LCBjaGVjaztcclxuICAgICAgICB3aGlsZSAoYV9sKSB7XHJcbiAgICAgICAgICAgIHBhcnQudW5zaGlmdChhWy0tYV9sXSk7XHJcbiAgICAgICAgICAgIHRyaW0ocGFydCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJlQWJzKHBhcnQsIGIpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goMCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4bGVuID0gcGFydC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGhpZ2h4ID0gcGFydFt4bGVuIC0gMV0gKiBiYXNlICsgcGFydFt4bGVuIC0gMl07XHJcbiAgICAgICAgICAgIGhpZ2h5ID0gYltiX2wgLSAxXSAqIGJhc2UgKyBiW2JfbCAtIDJdO1xyXG4gICAgICAgICAgICBpZiAoeGxlbiA+IGJfbCkge1xyXG4gICAgICAgICAgICAgICAgaGlnaHggPSAoaGlnaHggKyAxKSAqIGJhc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3Vlc3MgPSBNYXRoLmNlaWwoaGlnaHggLyBoaWdoeSk7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrID0gbXVsdGlwbHlTbWFsbChiLCBndWVzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZUFicyhjaGVjaywgcGFydCkgPD0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBndWVzcy0tO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChndWVzcyk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGd1ZXNzKTtcclxuICAgICAgICAgICAgcGFydCA9IHN1YnRyYWN0KHBhcnQsIGNoZWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnJldmVyc2UoKTtcclxuICAgICAgICByZXR1cm4gW2FycmF5VG9TbWFsbChyZXN1bHQpLCBhcnJheVRvU21hbGwocGFydCldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpdk1vZFNtYWxsKHZhbHVlLCBsYW1iZGEpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxyXG4gICAgICAgICAgICBxdW90aWVudCA9IGNyZWF0ZUFycmF5KGxlbmd0aCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBpLCBxLCByZW1haW5kZXIsIGRpdmlzb3I7XHJcbiAgICAgICAgcmVtYWluZGVyID0gMDtcclxuICAgICAgICBmb3IgKGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICBkaXZpc29yID0gcmVtYWluZGVyICogYmFzZSArIHZhbHVlW2ldO1xyXG4gICAgICAgICAgICBxID0gdHJ1bmNhdGUoZGl2aXNvciAvIGxhbWJkYSk7XHJcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IGRpdmlzb3IgLSBxICogbGFtYmRhO1xyXG4gICAgICAgICAgICBxdW90aWVudFtpXSA9IHEgfCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3F1b3RpZW50LCByZW1haW5kZXIgfCAwXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXZNb2RBbnkoc2VsZiwgdikge1xyXG4gICAgICAgIHZhciB2YWx1ZSwgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIGEgPSBzZWxmLnZhbHVlLCBiID0gbi52YWx1ZTtcclxuICAgICAgICB2YXIgcXVvdGllbnQ7XHJcbiAgICAgICAgaWYgKGIgPT09IDApIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXZpZGUgYnkgemVyb1wiKTtcclxuICAgICAgICBpZiAoc2VsZi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFNtYWxsSW50ZWdlcih0cnVuY2F0ZShhIC8gYikpLCBuZXcgU21hbGxJbnRlZ2VyKGEgJSBiKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtJbnRlZ2VyWzBdLCBzZWxmXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMSkgcmV0dXJuIFtzZWxmLCBJbnRlZ2VyWzBdXTtcclxuICAgICAgICAgICAgaWYgKGIgPT0gLTEpIHJldHVybiBbc2VsZi5uZWdhdGUoKSwgSW50ZWdlclswXV07XHJcbiAgICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyhiKTtcclxuICAgICAgICAgICAgaWYgKGFicyA8IEJBU0UpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGl2TW9kU21hbGwoYSwgYWJzKTtcclxuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gYXJyYXlUb1NtYWxsKHZhbHVlWzBdKTtcclxuICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSB2YWx1ZVsxXTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNpZ24pIHJlbWFpbmRlciA9IC1yZW1haW5kZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1b3RpZW50ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc2lnbiAhPT0gbi5zaWduKSBxdW90aWVudCA9IC1xdW90aWVudDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBTbWFsbEludGVnZXIocXVvdGllbnQpLCBuZXcgU21hbGxJbnRlZ2VyKHJlbWFpbmRlcildO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgQmlnSW50ZWdlcihxdW90aWVudCwgc2VsZi5zaWduICE9PSBuLnNpZ24pLCBuZXcgU21hbGxJbnRlZ2VyKHJlbWFpbmRlcildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoYWJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbXBhcmlzb24gPSBjb21wYXJlQWJzKGEsIGIpO1xyXG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSAtMSkgcmV0dXJuIFtJbnRlZ2VyWzBdLCBzZWxmXTtcclxuICAgICAgICBpZiAoY29tcGFyaXNvbiA9PT0gMCkgcmV0dXJuIFtJbnRlZ2VyW3NlbGYuc2lnbiA9PT0gbi5zaWduID8gMSA6IC0xXSwgSW50ZWdlclswXV07XHJcblxyXG4gICAgICAgIC8vIGRpdk1vZDEgaXMgZmFzdGVyIG9uIHNtYWxsZXIgaW5wdXQgc2l6ZXNcclxuICAgICAgICBpZiAoYS5sZW5ndGggKyBiLmxlbmd0aCA8PSAyMDApXHJcbiAgICAgICAgICAgIHZhbHVlID0gZGl2TW9kMShhLCBiKTtcclxuICAgICAgICBlbHNlIHZhbHVlID0gZGl2TW9kMihhLCBiKTtcclxuXHJcbiAgICAgICAgcXVvdGllbnQgPSB2YWx1ZVswXTtcclxuICAgICAgICB2YXIgcVNpZ24gPSBzZWxmLnNpZ24gIT09IG4uc2lnbixcclxuICAgICAgICAgICAgbW9kID0gdmFsdWVbMV0sXHJcbiAgICAgICAgICAgIG1TaWduID0gc2VsZi5zaWduO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcXVvdGllbnQgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKHFTaWduKSBxdW90aWVudCA9IC1xdW90aWVudDtcclxuICAgICAgICAgICAgcXVvdGllbnQgPSBuZXcgU21hbGxJbnRlZ2VyKHF1b3RpZW50KTtcclxuICAgICAgICB9IGVsc2UgcXVvdGllbnQgPSBuZXcgQmlnSW50ZWdlcihxdW90aWVudCwgcVNpZ24pO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbW9kID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChtU2lnbikgbW9kID0gLW1vZDtcclxuICAgICAgICAgICAgbW9kID0gbmV3IFNtYWxsSW50ZWdlcihtb2QpO1xyXG4gICAgICAgIH0gZWxzZSBtb2QgPSBuZXcgQmlnSW50ZWdlcihtb2QsIG1TaWduKTtcclxuICAgICAgICByZXR1cm4gW3F1b3RpZW50LCBtb2RdO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRpdk1vZEFueSh0aGlzLCB2KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBxdW90aWVudDogcmVzdWx0WzBdLFxyXG4gICAgICAgICAgICByZW1haW5kZXI6IHJlc3VsdFsxXVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2Q7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gZGl2TW9kQW55KHRoaXMsIHYpWzBdO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUub3ZlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gQmlnSW50ZWdlci5wcm90b3R5cGUub3ZlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBkaXZNb2RBbnkodGhpcywgdilbMV07XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm1vZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlLFxyXG4gICAgICAgICAgICB2YWx1ZSwgeCwgeTtcclxuICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIEludGVnZXJbMV07XHJcbiAgICAgICAgaWYgKGEgPT09IDApIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgIGlmIChhID09PSAxKSByZXR1cm4gSW50ZWdlclsxXTtcclxuICAgICAgICBpZiAoYSA9PT0gLTEpIHJldHVybiBuLmlzRXZlbigpID8gSW50ZWdlclsxXSA6IEludGVnZXJbLTFdO1xyXG4gICAgICAgIGlmIChuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbi5pc1NtYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZXhwb25lbnQgXCIgKyBuLnRvU3RyaW5nKCkgKyBcIiBpcyB0b28gbGFyZ2UuXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgaWYgKGlzUHJlY2lzZSh2YWx1ZSA9IE1hdGgucG93KGEsIGIpKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHggPSB0aGlzO1xyXG4gICAgICAgIHkgPSBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChiICYgMSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICAgICAgICAtLWI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGIgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBiIC89IDI7XHJcbiAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnBvdyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdztcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBmdW5jdGlvbiAoZXhwLCBtb2QpIHtcclxuICAgICAgICBleHAgPSBwYXJzZVZhbHVlKGV4cCk7XHJcbiAgICAgICAgbW9kID0gcGFyc2VWYWx1ZShtb2QpO1xyXG4gICAgICAgIGlmIChtb2QuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0YWtlIG1vZFBvdyB3aXRoIG1vZHVsdXMgMFwiKTtcclxuICAgICAgICB2YXIgciA9IEludGVnZXJbMV0sXHJcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLm1vZChtb2QpO1xyXG4gICAgICAgIHdoaWxlIChleHAuaXNQb3NpdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlLmlzWmVybygpKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICAgICAgaWYgKGV4cC5pc09kZCgpKSByID0gci5tdWx0aXBseShiYXNlKS5tb2QobW9kKTtcclxuICAgICAgICAgICAgZXhwID0gZXhwLmRpdmlkZSgyKTtcclxuICAgICAgICAgICAgYmFzZSA9IGJhc2Uuc3F1YXJlKCkubW9kKG1vZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBYnMoYSwgYikge1xyXG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHJldHVybiAxO1xyXG4gICAgICAgIHJldHVybiBjb21wYXJlQWJzKGEsIGIpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gTWF0aC5hYnModGhpcy52YWx1ZSksXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgYiA9IE1hdGguYWJzKGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBhYm91dCBjb21wYXJpc29uIHdpdGggSW5maW5pdHk6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BldGVyb2xzb24vQmlnSW50ZWdlci5qcy9pc3N1ZXMvNjFcclxuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuLnNpZ24gPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbiA/IC0xIDogMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBYnMoYSwgYikgKiAodGhpcy5zaWduID8gLTEgOiAxKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHYgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYgPT09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSA8IDAgPyAxIDogLTE7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpID09PSAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSAhPT0gMDtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5lcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubmVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPiAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3QgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmdyZWF0ZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ndCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXI7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpIDwgMDtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmx0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3NlcjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPj0gMDtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmdlcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ2VxID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpIDw9IDA7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZVswXSAmIDEpID09PSAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWVbMF0gJiAxKSA9PT0gMTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09PSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5zaWduO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbjtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnZhbHVlKSA9PT0gMTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gMDtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUgPT09IDApIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodmFsdWUgPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMikgcmV0dXJuIHRoaXMuaXNFdmVuKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kKG4pLmVxdWFscyhJbnRlZ2VyWzBdKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5O1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzQmFzaWNQcmltZSh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSB2LmFicygpO1xyXG4gICAgICAgIGlmIChuLmlzVW5pdCgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKG4uZXF1YWxzKDIpIHx8IG4uZXF1YWxzKDMpIHx8IG4uZXF1YWxzKDUpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAobi5pc0V2ZW4oKSB8fCBuLmlzRGl2aXNpYmxlQnkoMykgfHwgbi5pc0RpdmlzaWJsZUJ5KDUpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKG4ubGVzc2VyKDQ5KSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBpZiBpdCdzIHByaW1lOiBsZXQgdGhlIG90aGVyIGZ1bmN0aW9ucyBmaWd1cmUgaXQgb3V0XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIG1pbGxlclJhYmluVGVzdChuLCBhKSB7XHJcbiAgICAgICAgdmFyIG5QcmV2ID0gbi5wcmV2KCksXHJcbiAgICAgICAgICAgIGIgPSBuUHJldixcclxuICAgICAgICAgICAgciA9IDAsXHJcbiAgICAgICAgICAgIGQsIHQsIGksIHg7XHJcbiAgICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIGIgPSBiLmRpdmlkZSgyKSwgcisrO1xyXG4gICAgICAgIG5leHQgOiBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobi5sZXNzZXIoYVtpXSkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB4ID0gYmlnSW50KGFbaV0pLm1vZFBvdyhiLCBuKTtcclxuICAgICAgICAgICAgaWYgKHguZXF1YWxzKEludGVnZXJbMV0pIHx8IHguZXF1YWxzKG5QcmV2KSkgY29udGludWU7XHJcbiAgICAgICAgICAgIGZvciAoZCA9IHIgLSAxOyBkICE9IDA7IGQtLSkge1xyXG4gICAgICAgICAgICAgICAgeCA9IHguc3F1YXJlKCkubW9kKG4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHguaXNVbml0KCkpIHJldHVybiBmYWxzZTsgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoeC5lcXVhbHMoblByZXYpKSBjb250aW51ZSBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBcclxuLy8gU2V0IFwic3RyaWN0XCIgdG8gdHJ1ZSB0byBmb3JjZSBHUkgtc3VwcG9ydGVkIGxvd2VyIGJvdW5kIG9mIDIqbG9nKE4pXjJcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJpbWUgPSBmdW5jdGlvbiAoc3RyaWN0KSB7XHJcbiAgICAgICAgdmFyIGlzUHJpbWUgPSBpc0Jhc2ljUHJpbWUodGhpcyk7XHJcbiAgICAgICAgaWYgKGlzUHJpbWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzUHJpbWU7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLmFicygpO1xyXG4gICAgICAgIHZhciBiaXRzID0gbi5iaXRMZW5ndGgoKTtcclxuICAgICAgICBpZihiaXRzIDw9IDY0KVxyXG4gICAgICAgICAgICByZXR1cm4gbWlsbGVyUmFiaW5UZXN0KG4sIFsyLCAzMjUsIDkzNzUsIDI4MTc4LCA0NTA3NzUsIDk3ODA1MDQsIDE3OTUyNjUwMjJdKTtcclxuICAgICAgICB2YXIgbG9nTiA9IE1hdGgubG9nKDIpICogYml0cztcclxuICAgICAgICB2YXIgdCA9IE1hdGguY2VpbCgoc3RyaWN0ID09PSB0cnVlKSA/ICgyICogTWF0aC5wb3cobG9nTiwgMikpIDogbG9nTik7XHJcbiAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBpID0gMDsgaSA8IHQ7IGkrKykge1xyXG4gICAgICAgICAgICBhLnB1c2goYmlnSW50KGkgKyAyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgYSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBmdW5jdGlvbiAoaXRlcmF0aW9ucykge1xyXG4gICAgICAgIHZhciBpc1ByaW1lID0gaXNCYXNpY1ByaW1lKHRoaXMpO1xyXG4gICAgICAgIGlmIChpc1ByaW1lICE9PSB1bmRlZmluZWQpIHJldHVybiBpc1ByaW1lO1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5hYnMoKTtcclxuICAgICAgICB2YXIgdCA9IGl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCA/IDUgOiBpdGVyYXRpb25zO1xyXG4gICAgICAgIGZvciAodmFyIGEgPSBbXSwgaSA9IDA7IGkgPCB0OyBpKyspIHtcclxuICAgICAgICAgICAgYS5wdXNoKGJpZ0ludC5yYW5kQmV0d2VlbigyLCBuLm1pbnVzKDIpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgYSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWU7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB2YXIgdCA9IGJpZ0ludC56ZXJvLCBuZXdUID0gYmlnSW50Lm9uZSwgciA9IHBhcnNlVmFsdWUobiksIG5ld1IgPSB0aGlzLmFicygpLCBxLCBsYXN0VCwgbGFzdFI7XHJcbiAgICAgICAgd2hpbGUgKCFuZXdSLmVxdWFscyhiaWdJbnQuemVybykpIHtcclxuICAgICAgICAgICAgcSA9IHIuZGl2aWRlKG5ld1IpO1xyXG4gICAgICAgICAgICBsYXN0VCA9IHQ7XHJcbiAgICAgICAgICAgIGxhc3RSID0gcjtcclxuICAgICAgICAgICAgdCA9IG5ld1Q7XHJcbiAgICAgICAgICAgIHIgPSBuZXdSO1xyXG4gICAgICAgICAgICBuZXdUID0gbGFzdFQuc3VidHJhY3QocS5tdWx0aXBseShuZXdUKSk7XHJcbiAgICAgICAgICAgIG5ld1IgPSBsYXN0Ui5zdWJ0cmFjdChxLm11bHRpcGx5KG5ld1IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyLmVxdWFscygxKSkgdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSArIFwiIGFuZCBcIiArIG4udG9TdHJpbmcoKSArIFwiIGFyZSBub3QgY28tcHJpbWVcIik7XHJcbiAgICAgICAgaWYgKHQuY29tcGFyZSgwKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdCA9IHQuYWRkKG4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHQubmVnYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm1vZEludiA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwgMSwgdGhpcy5zaWduKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKHZhbHVlLCAxKSwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUgKyAxIDwgTUFYX0lOVCkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUgKyAxKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoTUFYX0lOVF9BUlIsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKHZhbHVlLCAxKSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKHZhbHVlLCAxLCB0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSAtIDEgPiAtTUFYX0lOVCkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUgLSAxKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoTUFYX0lOVF9BUlIsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcG93ZXJzT2ZUd28gPSBbMV07XHJcbiAgICB3aGlsZSAoMiAqIHBvd2Vyc09mVHdvW3Bvd2Vyc09mVHdvLmxlbmd0aCAtIDFdIDw9IEJBU0UpIHBvd2Vyc09mVHdvLnB1c2goMiAqIHBvd2Vyc09mVHdvW3Bvd2Vyc09mVHdvLmxlbmd0aCAtIDFdKTtcclxuICAgIHZhciBwb3dlcnMyTGVuZ3RoID0gcG93ZXJzT2ZUd28ubGVuZ3RoLCBoaWdoZXN0UG93ZXIyID0gcG93ZXJzT2ZUd29bcG93ZXJzMkxlbmd0aCAtIDFdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNoaWZ0X2lzU21hbGwobikge1xyXG4gICAgICAgIHJldHVybiAoKHR5cGVvZiBuID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBuID09PSBcInN0cmluZ1wiKSAmJiArTWF0aC5hYnMobikgPD0gQkFTRSkgfHxcclxuICAgICAgICAgICAgKG4gaW5zdGFuY2VvZiBCaWdJbnRlZ2VyICYmIG4udmFsdWUubGVuZ3RoIDw9IDEpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgaWYgKCFzaGlmdF9pc1NtYWxsKG4pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihTdHJpbmcobikgKyBcIiBpcyB0b28gbGFyZ2UgZm9yIHNoaWZ0aW5nLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbiA9ICtuO1xyXG4gICAgICAgIGlmIChuIDwgMCkgcmV0dXJuIHRoaXMuc2hpZnRSaWdodCgtbik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5pc1plcm8oKSkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB3aGlsZSAobiA+PSBwb3dlcnMyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgbiAtPSBwb3dlcnMyTGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tdWx0aXBseShwb3dlcnNPZlR3b1tuXSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdmFyIHJlbVF1bztcclxuICAgICAgICBpZiAoIXNoaWZ0X2lzU21hbGwobikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFN0cmluZyhuKSArIFwiIGlzIHRvbyBsYXJnZSBmb3Igc2hpZnRpbmcuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gK247XHJcbiAgICAgICAgaWYgKG4gPCAwKSByZXR1cm4gdGhpcy5zaGlmdExlZnQoLW4pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChuID49IHBvd2VyczJMZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5pc1plcm8oKSB8fCAocmVzdWx0LmlzTmVnYXRpdmUoKSAmJiByZXN1bHQuaXNVbml0KCkpKSByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICByZW1RdW8gPSBkaXZNb2RBbnkocmVzdWx0LCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XHJcbiAgICAgICAgICAgIG4gLT0gcG93ZXJzMkxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbVF1byA9IGRpdk1vZEFueShyZXN1bHQsIHBvd2Vyc09mVHdvW25dKTtcclxuICAgICAgICByZXR1cm4gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbiAgICBmdW5jdGlvbiBiaXR3aXNlKHgsIHksIGZuKSB7XHJcbiAgICAgICAgeSA9IHBhcnNlVmFsdWUoeSk7XHJcbiAgICAgICAgdmFyIHhTaWduID0geC5pc05lZ2F0aXZlKCksIHlTaWduID0geS5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgdmFyIHhSZW0gPSB4U2lnbiA/IHgubm90KCkgOiB4LFxyXG4gICAgICAgICAgICB5UmVtID0geVNpZ24gPyB5Lm5vdCgpIDogeTtcclxuICAgICAgICB2YXIgeERpZ2l0ID0gMCwgeURpZ2l0ID0gMDtcclxuICAgICAgICB2YXIgeERpdk1vZCA9IG51bGwsIHlEaXZNb2QgPSBudWxsO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICB3aGlsZSAoIXhSZW0uaXNaZXJvKCkgfHwgIXlSZW0uaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgeERpdk1vZCA9IGRpdk1vZEFueSh4UmVtLCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgeERpZ2l0ID0geERpdk1vZFsxXS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmICh4U2lnbikge1xyXG4gICAgICAgICAgICAgICAgeERpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB4RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeURpdk1vZCA9IGRpdk1vZEFueSh5UmVtLCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgeURpZ2l0ID0geURpdk1vZFsxXS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmICh5U2lnbikge1xyXG4gICAgICAgICAgICAgICAgeURpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB5RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeFJlbSA9IHhEaXZNb2RbMF07XHJcbiAgICAgICAgICAgIHlSZW0gPSB5RGl2TW9kWzBdO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChmbih4RGlnaXQsIHlEaWdpdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3VtID0gZm4oeFNpZ24gPyAxIDogMCwgeVNpZ24gPyAxIDogMCkgIT09IDAgPyBiaWdJbnQoLTEpIDogYmlnSW50KDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgc3VtID0gc3VtLm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpLmFkZChiaWdJbnQocmVzdWx0W2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLnByZXYoKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5vdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYgYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQ7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIHwgYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm9yO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgcmV0dXJuIGJpdHdpc2UodGhpcywgbiwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgXiBiOyB9KTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnhvciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnhvcjtcclxuXHJcbiAgICB2YXIgTE9CTUFTS19JID0gMSA8PCAzMCwgTE9CTUFTS19CSSA9IChCQVNFICYgLUJBU0UpICogKEJBU0UgJiAtQkFTRSkgfCBMT0JNQVNLX0k7XHJcbiAgICBmdW5jdGlvbiByb3VnaExPQihuKSB7IC8vIGdldCBsb3dlc3RPbmVCaXQgKHJvdWdoKVxyXG4gICAgICAgIC8vIFNtYWxsSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMzApXHJcbiAgICAgICAgLy8gQmlnSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMTQpIFtCQVNFPTFlN11cclxuICAgICAgICB2YXIgdiA9IG4udmFsdWUsIHggPSB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiA/IHYgfCBMT0JNQVNLX0kgOiB2WzBdICsgdlsxXSAqIEJBU0UgfCBMT0JNQVNLX0JJO1xyXG4gICAgICAgIHJldHVybiB4ICYgLXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW50ZWdlckxvZ2FyaXRobSh2YWx1ZSwgYmFzZSkge1xyXG4gICAgICAgIGlmIChiYXNlLmNvbXBhcmVUbyh2YWx1ZSkgPD0gMCkge1xyXG4gICAgICAgICAgICB2YXIgdG1wID0gaW50ZWdlckxvZ2FyaXRobSh2YWx1ZSwgYmFzZS5zcXVhcmUoYmFzZSkpO1xyXG4gICAgICAgICAgICB2YXIgcCA9IHRtcC5wO1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRtcC5lO1xyXG4gICAgICAgICAgICB2YXIgdCA9IHAubXVsdGlwbHkoYmFzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0LmNvbXBhcmVUbyh2YWx1ZSkgPD0gMCA/IHsgcDogdCwgZTogZSAqIDIgKyAxIH0gOiB7IHA6IHAsIGU6IGUgKiAyIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHA6IGJpZ0ludCgxKSwgZTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKG4uY29tcGFyZVRvKGJpZ0ludCgwKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLm5lZ2F0ZSgpLnN1YnRyYWN0KGJpZ0ludCgxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmNvbXBhcmVUbyhiaWdJbnQoMCkpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaWdJbnQoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiaWdJbnQoaW50ZWdlckxvZ2FyaXRobShuLCBiaWdJbnQoMikpLmUpLmFkZChiaWdJbnQoMSkpO1xyXG4gICAgfVxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGg7XHJcblxyXG4gICAgZnVuY3Rpb24gbWF4KGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICByZXR1cm4gYS5ncmVhdGVyKGIpID8gYSA6IGI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtaW4oYSwgYikge1xyXG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpO1xyXG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpO1xyXG4gICAgICAgIHJldHVybiBhLmxlc3NlcihiKSA/IGEgOiBiO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2NkKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcclxuICAgICAgICBpZiAoYS5lcXVhbHMoYikpIHJldHVybiBhO1xyXG4gICAgICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYjtcclxuICAgICAgICBpZiAoYi5pc1plcm8oKSkgcmV0dXJuIGE7XHJcbiAgICAgICAgdmFyIGMgPSBJbnRlZ2VyWzFdLCBkLCB0O1xyXG4gICAgICAgIHdoaWxlIChhLmlzRXZlbigpICYmIGIuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgZCA9IE1hdGgubWluKHJvdWdoTE9CKGEpLCByb3VnaExPQihiKSk7XHJcbiAgICAgICAgICAgIGEgPSBhLmRpdmlkZShkKTtcclxuICAgICAgICAgICAgYiA9IGIuZGl2aWRlKGQpO1xyXG4gICAgICAgICAgICBjID0gYy5tdWx0aXBseShkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgYSA9IGEuZGl2aWRlKHJvdWdoTE9CKGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGIuZGl2aWRlKHJvdWdoTE9CKGIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYS5ncmVhdGVyKGIpKSB7XHJcbiAgICAgICAgICAgICAgICB0ID0gYjsgYiA9IGE7IGEgPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBiLnN1YnRyYWN0KGEpO1xyXG4gICAgICAgIH0gd2hpbGUgKCFiLmlzWmVybygpKTtcclxuICAgICAgICByZXR1cm4gYy5pc1VuaXQoKSA/IGEgOiBhLm11bHRpcGx5KGMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGNtKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcclxuICAgICAgICByZXR1cm4gYS5kaXZpZGUoZ2NkKGEsIGIpKS5tdWx0aXBseShiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmRCZXR3ZWVuKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICB2YXIgbG93ID0gbWluKGEsIGIpLCBoaWdoID0gbWF4KGEsIGIpO1xyXG4gICAgICAgIHZhciByYW5nZSA9IGhpZ2guc3VidHJhY3QobG93KS5hZGQoMSk7XHJcbiAgICAgICAgaWYgKHJhbmdlLmlzU21hbGwpIHJldHVybiBsb3cuYWRkKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKSk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHJhbmdlLnZhbHVlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCByZXN0cmljdGVkID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gcmVzdHJpY3RlZCA/IHJhbmdlLnZhbHVlW2ldIDogQkFTRTtcclxuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gdHJ1bmNhdGUoTWF0aC5yYW5kb20oKSAqIHRvcCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KGRpZ2l0KTtcclxuICAgICAgICAgICAgaWYgKGRpZ2l0IDwgdG9wKSByZXN0cmljdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCA9IGFycmF5VG9TbWFsbChyZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiBsb3cuYWRkKHR5cGVvZiByZXN1bHQgPT09IFwibnVtYmVyXCIgPyBuZXcgU21hbGxJbnRlZ2VyKHJlc3VsdCkgOiBuZXcgQmlnSW50ZWdlcihyZXN1bHQsIGZhbHNlKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyc2VCYXNlID0gZnVuY3Rpb24gKHRleHQsIGJhc2UpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGFic0Jhc2UgPSBNYXRoLmFicyhiYXNlKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGV4dFtpXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gXCItXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoL1thLXowLTldLy50ZXN0KGMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoL1swLTldLy50ZXN0KGMpICYmICtjID49IGFic0Jhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCIxXCIgJiYgYWJzQmFzZSA9PT0gMSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiICsgYmFzZSArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYy5jaGFyQ29kZUF0KDApIC0gODcgPj0gYWJzQmFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjICsgXCIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW4gYmFzZSBcIiArIGJhc2UgKyBcIi5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKDIgPD0gYmFzZSAmJiBiYXNlIDw9IDM2KSB7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPD0gTE9HX01BWF9JTlQgLyBNYXRoLmxvZyhiYXNlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYyArIFwiIGlzIG5vdCBhIHZhbGlkIGRpZ2l0IGluIGJhc2UgXCIgKyBiYXNlICsgXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIocGFyc2VJbnQodGV4dCwgYmFzZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJhc2UgPSBwYXJzZVZhbHVlKGJhc2UpO1xyXG4gICAgICAgIHZhciBkaWdpdHMgPSBbXTtcclxuICAgICAgICB2YXIgaXNOZWdhdGl2ZSA9IHRleHRbMF0gPT09IFwiLVwiO1xyXG4gICAgICAgIGZvciAoaSA9IGlzTmVnYXRpdmUgPyAxIDogMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0W2ldLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgaWYgKDQ4IDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDU3KSBkaWdpdHMucHVzaChwYXJzZVZhbHVlKGMpKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoOTcgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMTIyKSBkaWdpdHMucHVzaChwYXJzZVZhbHVlKGMuY2hhckNvZGVBdCgwKSAtIDg3KSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPFwiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgZG8geyBpKys7IH0gd2hpbGUgKHRleHRbaV0gIT09IFwiPlwiKTtcclxuICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKHBhcnNlVmFsdWUodGV4dC5zbGljZShzdGFydCArIDEsIGkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYyArIFwiIGlzIG5vdCBhIHZhbGlkIGNoYXJhY3RlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMsIGJhc2UsIGlzTmVnYXRpdmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IEludGVnZXJbMF0sIHBvdyA9IEludGVnZXJbMV0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hZGQoZGlnaXRzW2ldLnRpbWVzKHBvdykpO1xyXG4gICAgICAgICAgICBwb3cgPSBwb3cudGltZXMoYmFzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc05lZ2F0aXZlID8gdmFsLm5lZ2F0ZSgpIDogdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShkaWdpdCkge1xyXG4gICAgICAgIGlmIChkaWdpdCA8PSAzNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoZGlnaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCI8XCIgKyBkaWdpdCArIFwiPlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvQmFzZShuLCBiYXNlKSB7XHJcbiAgICAgICAgYmFzZSA9IGJpZ0ludChiYXNlKTtcclxuICAgICAgICBpZiAoYmFzZS5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIHsgdmFsdWU6IFswXSwgaXNOZWdhdGl2ZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbm9uemVybyBudW1iZXJzIHRvIGJhc2UgMC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiYXNlLmVxdWFscygtMSkpIHtcclxuICAgICAgICAgICAgaWYgKG4uaXNaZXJvKCkpIHJldHVybiB7IHZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtdLmNvbmNhdC5hcHBseShbXSwgQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoLW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLCBbMSwgMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBBcnJheS5hcHBseShudWxsLCBBcnJheSgrbiAtIDEpKVxyXG4gICAgICAgICAgICAgICAgLm1hcChBcnJheS5wcm90b3R5cGUudmFsdWVPZiwgWzAsIDFdKTtcclxuICAgICAgICAgICAgYXJyLnVuc2hpZnQoWzFdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBbXS5jb25jYXQuYXBwbHkoW10sIGFyciksXHJcbiAgICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5lZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSAmJiBiYXNlLmlzUG9zaXRpdmUoKSkge1xyXG4gICAgICAgICAgICBuZWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBuID0gbi5hYnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJhc2UuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4geyB2YWx1ZTogWzBdLCBpc05lZ2F0aXZlOiBmYWxzZSB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBBcnJheS5hcHBseShudWxsLCBBcnJheSgrbikpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsIDEpLFxyXG4gICAgICAgICAgICAgICAgaXNOZWdhdGl2ZTogbmVnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXQgPSBbXTtcclxuICAgICAgICB2YXIgbGVmdCA9IG4sIGRpdm1vZDtcclxuICAgICAgICB3aGlsZSAobGVmdC5pc05lZ2F0aXZlKCkgfHwgbGVmdC5jb21wYXJlQWJzKGJhc2UpID49IDApIHtcclxuICAgICAgICAgICAgZGl2bW9kID0gbGVmdC5kaXZtb2QoYmFzZSk7XHJcbiAgICAgICAgICAgIGxlZnQgPSBkaXZtb2QucXVvdGllbnQ7XHJcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IGRpdm1vZC5yZW1haW5kZXI7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdC5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIGRpZ2l0ID0gYmFzZS5taW51cyhkaWdpdCkuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0LnB1c2goZGlnaXQudG9KU051bWJlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0LnB1c2gobGVmdC50b0pTTnVtYmVyKCkpO1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvdXQucmV2ZXJzZSgpLCBpc05lZ2F0aXZlOiBuZWcgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0Jhc2VTdHJpbmcobiwgYmFzZSkge1xyXG4gICAgICAgIHZhciBhcnIgPSB0b0Jhc2UobiwgYmFzZSk7XHJcbiAgICAgICAgcmV0dXJuIChhcnIuaXNOZWdhdGl2ZSA/IFwiLVwiIDogXCJcIikgKyBhcnIudmFsdWUubWFwKHN0cmluZ2lmeSkuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChyYWRpeCkge1xyXG4gICAgICAgIHJldHVybiB0b0Jhc2UodGhpcywgcmFkaXgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcclxuICAgICAgICBpZiAocmFkaXggIT09IDEwKSByZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMsIHJhZGl4KTtcclxuICAgICAgICB2YXIgdiA9IHRoaXMudmFsdWUsIGwgPSB2Lmxlbmd0aCwgc3RyID0gU3RyaW5nKHZbLS1sXSksIHplcm9zID0gXCIwMDAwMDAwXCIsIGRpZ2l0O1xyXG4gICAgICAgIHdoaWxlICgtLWwgPj0gMCkge1xyXG4gICAgICAgICAgICBkaWdpdCA9IFN0cmluZyh2W2xdKTtcclxuICAgICAgICAgICAgc3RyICs9IHplcm9zLnNsaWNlKGRpZ2l0Lmxlbmd0aCkgKyBkaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpZ24gPSB0aGlzLnNpZ24gPyBcIi1cIiA6IFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIHNpZ24gKyBzdHI7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcclxuICAgICAgICBpZiAocmFkaXggIT0gMTApIHJldHVybiB0b0Jhc2VTdHJpbmcodGhpcywgcmFkaXgpO1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9KU09OID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nKCk7IH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLnRvU3RyaW5nKCksIDEwKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0pTTnVtYmVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZjtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTTnVtYmVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO1xyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nVmFsdWUodikge1xyXG4gICAgICAgIGlmIChpc1ByZWNpc2UoK3YpKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gK3Y7XHJcbiAgICAgICAgICAgIGlmICh4ID09PSB0cnVuY2F0ZSh4KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHgpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgdik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaWduID0gdlswXSA9PT0gXCItXCI7XHJcbiAgICAgICAgaWYgKHNpZ24pIHYgPSB2LnNsaWNlKDEpO1xyXG4gICAgICAgIHZhciBzcGxpdCA9IHYuc3BsaXQoL2UvaSk7XHJcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIgKyBzcGxpdC5qb2luKFwiZVwiKSk7XHJcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICB2YXIgZXhwID0gc3BsaXRbMV07XHJcbiAgICAgICAgICAgIGlmIChleHBbMF0gPT09IFwiK1wiKSBleHAgPSBleHAuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIGV4cCA9ICtleHA7XHJcbiAgICAgICAgICAgIGlmIChleHAgIT09IHRydW5jYXRlKGV4cCkgfHwgIWlzUHJlY2lzZShleHApKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgZXhwICsgXCIgaXMgbm90IGEgdmFsaWQgZXhwb25lbnQuXCIpO1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHNwbGl0WzBdO1xyXG4gICAgICAgICAgICB2YXIgZGVjaW1hbFBsYWNlID0gdGV4dC5pbmRleE9mKFwiLlwiKTtcclxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQbGFjZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBleHAgLT0gdGV4dC5sZW5ndGggLSBkZWNpbWFsUGxhY2UgLSAxO1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgZGVjaW1hbFBsYWNlKSArIHRleHQuc2xpY2UoZGVjaW1hbFBsYWNlICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV4cCA8IDApIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbmNsdWRlIG5lZ2F0aXZlIGV4cG9uZW50IHBhcnQgZm9yIGludGVnZXJzXCIpO1xyXG4gICAgICAgICAgICB0ZXh0ICs9IChuZXcgQXJyYXkoZXhwICsgMSkpLmpvaW4oXCIwXCIpO1xyXG4gICAgICAgICAgICB2ID0gdGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzVmFsaWQgPSAvXihbMC05XVswLTldKikkLy50ZXN0KHYpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHYpO1xyXG4gICAgICAgIHZhciByID0gW10sIG1heCA9IHYubGVuZ3RoLCBsID0gTE9HX0JBU0UsIG1pbiA9IG1heCAtIGw7XHJcbiAgICAgICAgd2hpbGUgKG1heCA+IDApIHtcclxuICAgICAgICAgICAgci5wdXNoKCt2LnNsaWNlKG1pbiwgbWF4KSk7XHJcbiAgICAgICAgICAgIG1pbiAtPSBsO1xyXG4gICAgICAgICAgICBpZiAobWluIDwgMCkgbWluID0gMDtcclxuICAgICAgICAgICAgbWF4IC09IGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlTnVtYmVyVmFsdWUodikge1xyXG4gICAgICAgIGlmIChpc1ByZWNpc2UodikpIHtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHRydW5jYXRlKHYpKSB0aHJvdyBuZXcgRXJyb3IodiArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlclZhbHVlKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfVxyXG4gICAgLy8gUHJlLWRlZmluZSBudW1iZXJzIGluIHJhbmdlIFstOTk5LDk5OV1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XHJcbiAgICAgICAgSW50ZWdlcltpXSA9IG5ldyBTbWFsbEludGVnZXIoaSk7XHJcbiAgICAgICAgaWYgKGkgPiAwKSBJbnRlZ2VyWy1pXSA9IG5ldyBTbWFsbEludGVnZXIoLWkpO1xyXG4gICAgfVxyXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuICAgIEludGVnZXIub25lID0gSW50ZWdlclsxXTtcclxuICAgIEludGVnZXIuemVybyA9IEludGVnZXJbMF07XHJcbiAgICBJbnRlZ2VyLm1pbnVzT25lID0gSW50ZWdlclstMV07XHJcbiAgICBJbnRlZ2VyLm1heCA9IG1heDtcclxuICAgIEludGVnZXIubWluID0gbWluO1xyXG4gICAgSW50ZWdlci5nY2QgPSBnY2Q7XHJcbiAgICBJbnRlZ2VyLmxjbSA9IGxjbTtcclxuICAgIEludGVnZXIuaXNJbnN0YW5jZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgQmlnSW50ZWdlciB8fCB4IGluc3RhbmNlb2YgU21hbGxJbnRlZ2VyOyB9O1xyXG4gICAgSW50ZWdlci5yYW5kQmV0d2VlbiA9IHJhbmRCZXR3ZWVuO1xyXG5cclxuICAgIEludGVnZXIuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLm1hcChwYXJzZVZhbHVlKSwgcGFyc2VWYWx1ZShiYXNlIHx8IDEwKSwgaXNOZWdhdGl2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBJbnRlZ2VyO1xyXG59KSgpO1xyXG5cclxuLy8gTm9kZS5qcyBjaGVja1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuaGFzT3duUHJvcGVydHkoXCJleHBvcnRzXCIpKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpZ0ludDtcclxufVxyXG5cclxuLy9hbWQgY2hlY2tcclxuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoXCJiaWctaW50ZWdlclwiLCBbXSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBiaWdJbnQ7XHJcbiAgICB9KTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/coin-bitcoin/node_modules/big-integer/BigInteger.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/abi.js':
    /*!**********************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/abi/abi.js ***!
  \**********************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nconst utils = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/util.js\");\nconst base = __webpack_require__(/*! ../base */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/index.js\");\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nconst { isHexString, stripHexPrefix, padToEven } = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/internal.js\");\nconst { intToBuffer, addHexPrefix, bufferToHex } = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/bytes.js\");\nvar ABI = function () {\n};\nfunction elementaryName(name) {\n    if (name.startsWith('int[')) {\n        return 'int256' + name.slice(3);\n    }\n    else if (name === 'int') {\n        return 'int256';\n    }\n    else if (name.startsWith('uint[')) {\n        return 'uint256' + name.slice(4);\n    }\n    else if (name === 'uint') {\n        return 'uint256';\n    }\n    else if (name.startsWith('fixed[')) {\n        return 'fixed128x128' + name.slice(5);\n    }\n    else if (name === 'fixed') {\n        return 'fixed128x128';\n    }\n    else if (name.startsWith('ufixed[')) {\n        return 'ufixed128x128' + name.slice(6);\n    }\n    else if (name === 'ufixed') {\n        return 'ufixed128x128';\n    }\n    return name;\n}\nfunction toBuffer(v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === 'string') {\n        if (!isHexString(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');\n    }\n    if (typeof v === 'number') {\n        return intToBuffer(v);\n    }\n    if (typeof v === 'bigint') {\n        if (v < BigInt(0)) {\n            throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);\n        }\n        let n = v.toString(16);\n        if (n.length % 2)\n            n = '0' + n;\n        return Buffer.from(n, 'hex');\n    }\n    if (v.toArray) {\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error('invalid type');\n}\nfunction normalize(input) {\n    if (!input) {\n        return undefined;\n    }\n    if (typeof input === 'number') {\n        if (input < 0) {\n            return '0x';\n        }\n        const buffer = toBuffer(input);\n        input = bufferToHex(buffer);\n    }\n    if (typeof input !== 'string') {\n        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n        msg += ` received ${typeof input}: ${input}`;\n        throw new Error(msg);\n    }\n    return addHexPrefix(input.toLowerCase());\n}\nABI.eventID = function (name, types) {\n    var sig = name + '(' + types.map(elementaryName).join(',') + ')';\n    return base.keccak256(Buffer.from(sig));\n};\nABI.methodID = function (name, types) {\n    return ABI.eventID(name, types).slice(0, 4);\n};\nfunction parseTypeN(type) {\n    return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10);\n}\nfunction parseTypeNxM(type) {\n    var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type);\n    return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];\n}\nfunction parseTypeArray(type) {\n    var tmp = type.match(/(.*)\\[(.*?)\\]$/);\n    if (tmp) {\n        return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);\n    }\n    return null;\n}\nfunction parseNumber(arg) {\n    var type = typeof arg;\n    if (type === 'string') {\n        if (base.isHexPrefixed(arg)) {\n            return new BN(base.stripHexPrefix(arg), 16);\n        }\n        else {\n            return new BN(arg, 10);\n        }\n    }\n    else if (type === 'number') {\n        return new BN(arg);\n    }\n    else if (arg.toArray) {\n        return arg;\n    }\n    else {\n        throw new Error('Argument is not a number');\n    }\n}\nfunction parseSignature(sig) {\n    var tmp = /^(\\w+)\\((.*)\\)$/.exec(sig);\n    if (tmp.length !== 3) {\n        throw new Error('Invalid method signature');\n    }\n    var args = /^(.+)\\):\\((.+)$/.exec(tmp[2]);\n    if (args !== null && args.length === 3) {\n        return {\n            method: tmp[1],\n            args: args[1].split(','),\n            retargs: args[2].split(',')\n        };\n    }\n    else {\n        var params = tmp[2].split(',');\n        if (params.length === 1 && params[0] === '') {\n            params = [];\n        }\n        return {\n            method: tmp[1],\n            args: params\n        };\n    }\n}\nfunction encodeSingle(type, arg) {\n    var size, num, ret, i;\n    if (type === 'address') {\n        return encodeSingle('uint160', parseNumber(arg));\n    }\n    else if (type === 'bool') {\n        return encodeSingle('uint8', arg ? 1 : 0);\n    }\n    else if (type === 'string') {\n        return encodeSingle('bytes', Buffer.from(arg, 'utf8'));\n    }\n    else if (isArray(type)) {\n        if (typeof arg.length === 'undefined') {\n            throw new Error('Not an array?');\n        }\n        size = parseTypeArray(type);\n        if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n            throw new Error('Elements exceed array size: ' + size);\n        }\n        ret = [];\n        type = type.slice(0, type.lastIndexOf('['));\n        if (typeof arg === 'string') {\n            arg = JSON.parse(arg);\n        }\n        for (i in arg) {\n            ret.push(encodeSingle(type, arg[i]));\n        }\n        if (size === 'dynamic') {\n            var length = encodeSingle('uint256', arg.length);\n            ret.unshift(length);\n        }\n        return Buffer.concat(ret);\n    }\n    else if (type === 'bytes') {\n        arg = Buffer.from(arg);\n        ret = Buffer.concat([encodeSingle('uint256', arg.length), arg]);\n        if ((arg.length % 32) !== 0) {\n            ret = Buffer.concat([ret, utils.zeros(32 - (arg.length % 32))]);\n        }\n        return ret;\n    }\n    else if (type.startsWith('bytes')) {\n        size = parseTypeN(type);\n        if (size < 1 || size > 32) {\n            throw new Error('Invalid bytes<N> width: ' + size);\n        }\n        return utils.setLengthRight(arg, 32);\n    }\n    else if (type.startsWith('uint')) {\n        size = parseTypeN(type);\n        if ((size % 8) || (size < 8) || (size > 256)) {\n            throw new Error('Invalid uint<N> width: ' + size);\n        }\n        num = parseNumber(arg);\n        if (num.bitLength() > size) {\n            throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n        }\n        if (num < 0) {\n            throw new Error('Supplied uint is negative');\n        }\n        return num.toArrayLike(Buffer, 'be', 32);\n    }\n    else if (type.startsWith('int')) {\n        size = parseTypeN(type);\n        if ((size % 8) || (size < 8) || (size > 256)) {\n            throw new Error('Invalid int<N> width: ' + size);\n        }\n        num = parseNumber(arg);\n        if (num.bitLength() > size) {\n            throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n        }\n        return num.toTwos(256).toArrayLike(Buffer, 'be', 32);\n    }\n    else if (type.startsWith('ufixed')) {\n        size = parseTypeNxM(type);\n        num = parseNumber(arg);\n        if (num < 0) {\n            throw new Error('Supplied ufixed is negative');\n        }\n        return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))));\n    }\n    else if (type.startsWith('fixed')) {\n        size = parseTypeNxM(type);\n        return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));\n    }\n    throw new Error('Unsupported or invalid type: ' + type);\n}\nfunction decodeSingle(parsedType, data, offset) {\n    if (typeof parsedType === 'string') {\n        parsedType = parseType(parsedType);\n    }\n    var size, num, ret, i;\n    if (parsedType.name === 'address') {\n        return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, 'be', 20).toString('hex');\n    }\n    else if (parsedType.name === 'bool') {\n        return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString();\n    }\n    else if (parsedType.name === 'string') {\n        var bytes = decodeSingle(parsedType.rawType, data, offset);\n        return Buffer.from(bytes, 'utf8').toString();\n    }\n    else if (parsedType.isArray) {\n        ret = [];\n        size = parsedType.size;\n        if (parsedType.size === 'dynamic') {\n            offset = decodeSingle('uint256', data, offset).toNumber();\n            size = decodeSingle('uint256', data, offset).toNumber();\n            offset = offset + 32;\n        }\n        for (i = 0; i < size; i++) {\n            var decoded = decodeSingle(parsedType.subArray, data, offset);\n            ret.push(decoded);\n            offset += parsedType.subArray.memoryUsage;\n        }\n        return ret;\n    }\n    else if (parsedType.name === 'bytes') {\n        offset = decodeSingle('uint256', data, offset).toNumber();\n        size = decodeSingle('uint256', data, offset).toNumber();\n        return data.slice(offset + 32, offset + 32 + size);\n    }\n    else if (parsedType.name.startsWith('bytes')) {\n        return data.slice(offset, offset + parsedType.size);\n    }\n    else if (parsedType.name.startsWith('uint')) {\n        num = new BN(data.slice(offset, offset + 32), 16, 'be');\n        if (num.bitLength() > parsedType.size) {\n            throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());\n        }\n        return num;\n    }\n    else if (parsedType.name.startsWith('int')) {\n        num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256);\n        if (num.bitLength() > parsedType.size) {\n            throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());\n        }\n        return num;\n    }\n    else if (parsedType.name.startsWith('ufixed')) {\n        size = new BN(2).pow(new BN(parsedType.size[1]));\n        num = decodeSingle('uint256', data, offset);\n        if (!num.mod(size).isZero()) {\n            throw new Error('Decimals not supported yet');\n        }\n        return num.div(size);\n    }\n    else if (parsedType.name.startsWith('fixed')) {\n        size = new BN(2).pow(new BN(parsedType.size[1]));\n        num = decodeSingle('int256', data, offset);\n        if (!num.mod(size).isZero()) {\n            throw new Error('Decimals not supported yet');\n        }\n        return num.div(size);\n    }\n    throw new Error('Unsupported or invalid type: ' + parsedType.name);\n}\nfunction parseType(type) {\n    var size;\n    var ret;\n    if (isArray(type)) {\n        size = parseTypeArray(type);\n        var subArray = type.slice(0, type.lastIndexOf('['));\n        subArray = parseType(subArray);\n        ret = {\n            isArray: true,\n            name: type,\n            size: size,\n            memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,\n            subArray: subArray\n        };\n        return ret;\n    }\n    else {\n        var rawType;\n        switch (type) {\n            case 'address':\n                rawType = 'uint160';\n                break;\n            case 'bool':\n                rawType = 'uint8';\n                break;\n            case 'string':\n                rawType = 'bytes';\n                break;\n        }\n        ret = {\n            rawType: rawType,\n            name: type,\n            memoryUsage: 32\n        };\n        if ((type.startsWith('bytes') && type !== 'bytes') || type.startsWith('uint') || type.startsWith('int')) {\n            ret.size = parseTypeN(type);\n        }\n        else if (type.startsWith('ufixed') || type.startsWith('fixed')) {\n            ret.size = parseTypeNxM(type);\n        }\n        if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {\n            throw new Error('Invalid bytes<N> width: ' + ret.size);\n        }\n        if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {\n            throw new Error('Invalid int/uint<N> width: ' + ret.size);\n        }\n        return ret;\n    }\n}\nfunction isDynamic(type) {\n    return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic');\n}\nfunction isArray(type) {\n    return type.lastIndexOf(']') === type.length - 1;\n}\nABI.rawEncode = function (types, values) {\n    var output = [];\n    var data = [];\n    var headLength = 0;\n    types.forEach(function (type) {\n        if (isArray(type)) {\n            var size = parseTypeArray(type);\n            if (size !== 'dynamic') {\n                headLength += 32 * size;\n            }\n            else {\n                headLength += 32;\n            }\n        }\n        else {\n            headLength += 32;\n        }\n    });\n    for (var i = 0; i < types.length; i++) {\n        var type = elementaryName(types[i]);\n        var value = values[i];\n        var cur = encodeSingle(type, value);\n        if (isDynamic(type)) {\n            output.push(encodeSingle('uint256', headLength));\n            data.push(cur);\n            headLength += cur.length;\n        }\n        else {\n            output.push(cur);\n        }\n    }\n    return Buffer.concat(output.concat(data));\n};\nABI.rawDecode = function (types, data) {\n    var ret = [];\n    data = Buffer.from(data);\n    var offset = 0;\n    for (var i = 0; i < types.length; i++) {\n        var type = elementaryName(types[i]);\n        var parsed = parseType(type, data, offset);\n        var decoded = decodeSingle(parsed, data, offset);\n        offset += parsed.memoryUsage;\n        ret.push(decoded);\n    }\n    return ret;\n};\nABI.simpleEncode = function (method) {\n    var args = Array.prototype.slice.call(arguments).slice(1);\n    var sig = parseSignature(method);\n    if (args.length !== sig.args.length) {\n        throw new Error('Argument count mismatch');\n    }\n    return Buffer.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);\n};\nABI.simpleDecode = function (method, data) {\n    var sig = parseSignature(method);\n    if (!sig.retargs) {\n        throw new Error('No return values in method');\n    }\n    return ABI.rawDecode(sig.retargs, data);\n};\nfunction stringify(type, value) {\n    if (type.startsWith('address') || type.startsWith('bytes')) {\n        return '0x' + value.toString('hex');\n    }\n    else {\n        return value.toString();\n    }\n}\nABI.stringify = function (types, values) {\n    var ret = [];\n    for (var i in types) {\n        var type = types[i];\n        var value = values[i];\n        if (/^[^\\[]+\\[.*\\]$/.test(type)) {\n            value = value.map(function (item) {\n                return stringify(type, item);\n            }).join(', ');\n        }\n        else {\n            value = stringify(type, value);\n        }\n        ret.push(value);\n    }\n    return ret;\n};\nABI.solidityHexValue = function (type, value, bitsize) {\n    var size, num;\n    if (isArray(type)) {\n        var subType = type.replace(/\\[.*?\\]/, '');\n        if (!isArray(subType)) {\n            var arraySize = parseTypeArray(type);\n            if (arraySize !== 'dynamic' && arraySize !== 0 && value.length > arraySize) {\n                throw new Error('Elements exceed array size: ' + arraySize);\n            }\n        }\n        var arrayValues = value.map(function (v) {\n            return ABI.solidityHexValue(subType, v, 256);\n        });\n        return Buffer.concat(arrayValues);\n    }\n    else if (type === 'bytes') {\n        return value;\n    }\n    else if (type === 'string') {\n        return Buffer.from(value, 'utf8');\n    }\n    else if (type === 'bool') {\n        bitsize = bitsize || 8;\n        var padding = Array((bitsize) / 4).join('0');\n        return Buffer.from(value ? padding + '1' : padding + '0', 'hex');\n    }\n    else if (type === 'address') {\n        var bytesize = 20;\n        if (bitsize) {\n            bytesize = bitsize / 8;\n        }\n        return utils.setLengthLeft(toBuffer(value), bytesize);\n    }\n    else if (type.startsWith('bytes')) {\n        size = parseTypeN(type);\n        if (size < 1 || size > 32) {\n            throw new Error('Invalid bytes<N> width: ' + size);\n        }\n        if (typeof value === 'number') {\n            value = normalize(value);\n        }\n        return utils.setLengthRight(toBuffer(value), size);\n    }\n    else if (type.startsWith('uint')) {\n        size = parseTypeN(type);\n        if ((size % 8) || (size < 8) || (size > 256)) {\n            throw new Error('Invalid uint<N> width: ' + size);\n        }\n        num = parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n        }\n        bitsize = bitsize || size;\n        return num.toArrayLike(Buffer, 'be', bitsize / 8);\n    }\n    else if (type.startsWith('int')) {\n        size = parseTypeN(type);\n        if ((size % 8) || (size < 8) || (size > 256)) {\n            throw new Error('Invalid int<N> width: ' + size);\n        }\n        num = parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n        }\n        bitsize = bitsize || size;\n        return num.toTwos(size).toArrayLike(Buffer, 'be', bitsize / 8);\n    }\n    else {\n        throw new Error('Unsupported or invalid type: ' + type);\n    }\n};\nABI.solidityPack = function (types, values) {\n    if (types.length !== values.length) {\n        throw new Error('Number of types are not matching the values');\n    }\n    var ret = [];\n    for (var i = 0; i < types.length; i++) {\n        var type = elementaryName(types[i]);\n        var value = values[i];\n        ret.push(ABI.solidityHexValue(type, value, null));\n    }\n    return Buffer.concat(ret);\n};\nABI.soliditySHA3 = function (types, values) {\n    return base.keccak256(ABI.solidityPack(types, values));\n};\nABI.soliditySHA256 = function (types, values) {\n    return base.sha256(ABI.solidityPack(types, values));\n};\nABI.solidityRIPEMD160 = function (types, values) {\n    return base.ripemd160(ABI.solidityPack(types, values), true);\n};\nfunction isNumeric(c) {\n    return (c >= '0') && (c <= '9');\n}\nABI.fromSerpent = function (sig) {\n    var ret = [];\n    for (var i = 0; i < sig.length; i++) {\n        var type = sig[i];\n        if (type === 's') {\n            ret.push('bytes');\n        }\n        else if (type === 'b') {\n            var tmp = 'bytes';\n            var j = i + 1;\n            while ((j < sig.length) && isNumeric(sig[j])) {\n                tmp += sig[j] - '0';\n                j++;\n            }\n            i = j - 1;\n            ret.push(tmp);\n        }\n        else if (type === 'i') {\n            ret.push('int256');\n        }\n        else if (type === 'a') {\n            ret.push('int256[]');\n        }\n        else {\n            throw new Error('Unsupported or invalid type: ' + type);\n        }\n    }\n    return ret;\n};\nABI.toSerpent = function (types) {\n    var ret = [];\n    for (var i = 0; i < types.length; i++) {\n        var type = types[i];\n        if (type === 'bytes') {\n            ret.push('s');\n        }\n        else if (type.startsWith('bytes')) {\n            ret.push('b' + parseTypeN(type));\n        }\n        else if (type === 'int256') {\n            ret.push('i');\n        }\n        else if (type === 'int256[]') {\n            ret.push('a');\n        }\n        else {\n            throw new Error('Unsupported or invalid type: ' + type);\n        }\n    }\n    return ret.join('');\n};\nmodule.exports = ABI;\n//# sourceMappingURL=abi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9hYmkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixjQUFjLG1CQUFPLENBQUMseUVBQVE7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDRFQUFTO0FBQzlCLFNBQVMsbUJBQU8sQ0FBQywwREFBYztBQUMvQixRQUFRLHlDQUF5QyxFQUFFLG1CQUFPLENBQUMsaUZBQVk7QUFDdkUsUUFBUSx5Q0FBeUMsRUFBRSxtQkFBTyxDQUFDLDJFQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSUFBMEksRUFBRTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWEsSUFBSSxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9hYmkuanM/OWYyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzL2xpYi9ibicpO1xuY29uc3QgeyBpc0hleFN0cmluZywgc3RyaXBIZXhQcmVmaXgsIHBhZFRvRXZlbiB9ID0gcmVxdWlyZSgnLi9pbnRlcm5hbCcpO1xuY29uc3QgeyBpbnRUb0J1ZmZlciwgYWRkSGV4UHJlZml4LCBidWZmZXJUb0hleCB9ID0gcmVxdWlyZSgnLi9ieXRlcycpO1xudmFyIEFCSSA9IGZ1bmN0aW9uICgpIHtcbn07XG5mdW5jdGlvbiBlbGVtZW50YXJ5TmFtZShuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaW50WycpKSB7XG4gICAgICAgIHJldHVybiAnaW50MjU2JyArIG5hbWUuc2xpY2UoMyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpbnQnKSB7XG4gICAgICAgIHJldHVybiAnaW50MjU2JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1aW50WycpKSB7XG4gICAgICAgIHJldHVybiAndWludDI1NicgKyBuYW1lLnNsaWNlKDQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAndWludCcpIHtcbiAgICAgICAgcmV0dXJuICd1aW50MjU2JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaXhlZFsnKSkge1xuICAgICAgICByZXR1cm4gJ2ZpeGVkMTI4eDEyOCcgKyBuYW1lLnNsaWNlKDUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnZml4ZWQnKSB7XG4gICAgICAgIHJldHVybiAnZml4ZWQxMjh4MTI4JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1Zml4ZWRbJykpIHtcbiAgICAgICAgcmV0dXJuICd1Zml4ZWQxMjh4MTI4JyArIG5hbWUuc2xpY2UoNik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICd1Zml4ZWQnKSB7XG4gICAgICAgIHJldHVybiAndWZpeGVkMTI4eDEyOCc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gdG9CdWZmZXIodikge1xuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikgfHwgdiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlci4gdG9CdWZmZXIgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBhbmQgdGhpcyBzdHJpbmcgd2FzIGdpdmVuOiAke3Z9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaW50VG9CdWZmZXIodik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgaWYgKHYgPCBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgbmVnYXRpdmUgYmlnaW50IHRvIGJ1ZmZlci4gR2l2ZW46ICR7dn1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbiA9IHYudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAobi5sZW5ndGggJSAyKVxuICAgICAgICAgICAgbiA9ICcwJyArIG47XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShuLCAnaGV4Jyk7XG4gICAgfVxuICAgIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9XG4gICAgaWYgKHYudG9CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9CdWZmZXIoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemUoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbnB1dCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRvQnVmZmVyKGlucHV0KTtcbiAgICAgICAgaW5wdXQgPSBidWZmZXJUb0hleChidWZmZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBsZXQgbXNnID0gJ2V0aC1zaWctdXRpbC5ub3JtYWxpemUoKSByZXF1aXJlcyBoZXggc3RyaW5nIG9yIGludGVnZXIgaW5wdXQuJztcbiAgICAgICAgbXNnICs9IGAgcmVjZWl2ZWQgJHt0eXBlb2YgaW5wdXR9OiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkSGV4UHJlZml4KGlucHV0LnRvTG93ZXJDYXNlKCkpO1xufVxuQUJJLmV2ZW50SUQgPSBmdW5jdGlvbiAobmFtZSwgdHlwZXMpIHtcbiAgICB2YXIgc2lnID0gbmFtZSArICcoJyArIHR5cGVzLm1hcChlbGVtZW50YXJ5TmFtZSkuam9pbignLCcpICsgJyknO1xuICAgIHJldHVybiBiYXNlLmtlY2NhazI1NihCdWZmZXIuZnJvbShzaWcpKTtcbn07XG5BQkkubWV0aG9kSUQgPSBmdW5jdGlvbiAobmFtZSwgdHlwZXMpIHtcbiAgICByZXR1cm4gQUJJLmV2ZW50SUQobmFtZSwgdHlwZXMpLnNsaWNlKDAsIDQpO1xufTtcbmZ1bmN0aW9uIHBhcnNlVHlwZU4odHlwZSkge1xuICAgIHJldHVybiBwYXJzZUludCgvXlxcRCsoXFxkKykkLy5leGVjKHR5cGUpWzFdLCAxMCk7XG59XG5mdW5jdGlvbiBwYXJzZVR5cGVOeE0odHlwZSkge1xuICAgIHZhciB0bXAgPSAvXlxcRCsoXFxkKyl4KFxcZCspJC8uZXhlYyh0eXBlKTtcbiAgICByZXR1cm4gW3BhcnNlSW50KHRtcFsxXSwgMTApLCBwYXJzZUludCh0bXBbMl0sIDEwKV07XG59XG5mdW5jdGlvbiBwYXJzZVR5cGVBcnJheSh0eXBlKSB7XG4gICAgdmFyIHRtcCA9IHR5cGUubWF0Y2goLyguKilcXFsoLio/KVxcXSQvKTtcbiAgICBpZiAodG1wKSB7XG4gICAgICAgIHJldHVybiB0bXBbMl0gPT09ICcnID8gJ2R5bmFtaWMnIDogcGFyc2VJbnQodG1wWzJdLCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VOdW1iZXIoYXJnKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoYmFzZS5pc0hleFByZWZpeGVkKGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQk4oYmFzZS5zdHJpcEhleFByZWZpeChhcmcpLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJOKGFyZywgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuZXcgQk4oYXJnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnLnRvQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgaXMgbm90IGEgbnVtYmVyJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VTaWduYXR1cmUoc2lnKSB7XG4gICAgdmFyIHRtcCA9IC9eKFxcdyspXFwoKC4qKVxcKSQvLmV4ZWMoc2lnKTtcbiAgICBpZiAodG1wLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIHNpZ25hdHVyZScpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IC9eKC4rKVxcKTpcXCgoLispJC8uZXhlYyh0bXBbMl0pO1xuICAgIGlmIChhcmdzICE9PSBudWxsICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRob2Q6IHRtcFsxXSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NbMV0uc3BsaXQoJywnKSxcbiAgICAgICAgICAgIHJldGFyZ3M6IGFyZ3NbMl0uc3BsaXQoJywnKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRtcFsyXS5zcGxpdCgnLCcpO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0aG9kOiB0bXBbMV0sXG4gICAgICAgICAgICBhcmdzOiBwYXJhbXNcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmNvZGVTaW5nbGUodHlwZSwgYXJnKSB7XG4gICAgdmFyIHNpemUsIG51bSwgcmV0LCBpO1xuICAgIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVNpbmdsZSgndWludDE2MCcsIHBhcnNlTnVtYmVyKGFyZykpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVNpbmdsZSgndWludDgnLCBhcmcgPyAxIDogMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ2J5dGVzJywgQnVmZmVyLmZyb20oYXJnLCAndXRmOCcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZy5sZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbiBhcnJheT8nKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplID0gcGFyc2VUeXBlQXJyYXkodHlwZSk7XG4gICAgICAgIGlmIChzaXplICE9PSAnZHluYW1pYycgJiYgc2l6ZSAhPT0gMCAmJiBhcmcubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50cyBleGNlZWQgYXJyYXkgc2l6ZTogJyArIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IFtdO1xuICAgICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpO1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFyZyA9IEpTT04ucGFyc2UoYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgaW4gYXJnKSB7XG4gICAgICAgICAgICByZXQucHVzaChlbmNvZGVTaW5nbGUodHlwZSwgYXJnW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpemUgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGVuY29kZVNpbmdsZSgndWludDI1NicsIGFyZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0LnVuc2hpZnQobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChyZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgIGFyZyA9IEJ1ZmZlci5mcm9tKGFyZyk7XG4gICAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQoW2VuY29kZVNpbmdsZSgndWludDI1NicsIGFyZy5sZW5ndGgpLCBhcmddKTtcbiAgICAgICAgaWYgKChhcmcubGVuZ3RoICUgMzIpICE9PSAwKSB7XG4gICAgICAgICAgICByZXQgPSBCdWZmZXIuY29uY2F0KFtyZXQsIHV0aWxzLnplcm9zKDMyIC0gKGFyZy5sZW5ndGggJSAzMikpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpO1xuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXM8Tj4gd2lkdGg6ICcgKyBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuc2V0TGVuZ3RoUmlnaHQoYXJnLCAzMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSB7XG4gICAgICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpO1xuICAgICAgICBpZiAoKHNpemUgJSA4KSB8fCAoc2l6ZSA8IDgpIHx8IChzaXplID4gMjU2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVpbnQ8Tj4gd2lkdGg6ICcgKyBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSBwYXJzZU51bWJlcihhcmcpO1xuICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50IGV4Y2VlZHMgd2lkdGg6ICcgKyBzaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50IGlzIG5lZ2F0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKTtcbiAgICAgICAgaWYgKChzaXplICUgOCkgfHwgKHNpemUgPCA4KSB8fCAoc2l6ZSA+IDI1NikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnQ8Tj4gd2lkdGg6ICcgKyBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSBwYXJzZU51bWJlcihhcmcpO1xuICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCBpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW0udG9Ud29zKDI1NikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWZpeGVkJykpIHtcbiAgICAgICAgc2l6ZSA9IHBhcnNlVHlwZU54TSh0eXBlKTtcbiAgICAgICAgbnVtID0gcGFyc2VOdW1iZXIoYXJnKTtcbiAgICAgICAgaWYgKG51bSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWZpeGVkIGlzIG5lZ2F0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVNpbmdsZSgndWludDI1NicsIG51bS5tdWwobmV3IEJOKDIpLnBvdyhuZXcgQk4oc2l6ZVsxXSkpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnZml4ZWQnKSkge1xuICAgICAgICBzaXplID0gcGFyc2VUeXBlTnhNKHR5cGUpO1xuICAgICAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCdpbnQyNTYnLCBwYXJzZU51bWJlcihhcmcpLm11bChuZXcgQk4oMikucG93KG5ldyBCTihzaXplWzFdKSkpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVNpbmdsZShwYXJzZWRUeXBlLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHBhcnNlZFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnNlZFR5cGUgPSBwYXJzZVR5cGUocGFyc2VkVHlwZSk7XG4gICAgfVxuICAgIHZhciBzaXplLCBudW0sIHJldCwgaTtcbiAgICBpZiAocGFyc2VkVHlwZS5uYW1lID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVNpbmdsZShwYXJzZWRUeXBlLnJhd1R5cGUsIGRhdGEsIG9mZnNldCkudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAyMCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gZGVjb2RlU2luZ2xlKHBhcnNlZFR5cGUucmF3VHlwZSwgZGF0YSwgb2Zmc2V0KS50b1N0cmluZygpID09PSBuZXcgQk4oMSkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgYnl0ZXMgPSBkZWNvZGVTaW5nbGUocGFyc2VkVHlwZS5yYXdUeXBlLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMsICd1dGY4JykudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyc2VkVHlwZS5pc0FycmF5KSB7XG4gICAgICAgIHJldCA9IFtdO1xuICAgICAgICBzaXplID0gcGFyc2VkVHlwZS5zaXplO1xuICAgICAgICBpZiAocGFyc2VkVHlwZS5zaXplID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRlY29kZVNpbmdsZSgndWludDI1NicsIGRhdGEsIG9mZnNldCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIHNpemUgPSBkZWNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBkYXRhLCBvZmZzZXQpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyAzMjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVjb2RlZCA9IGRlY29kZVNpbmdsZShwYXJzZWRUeXBlLnN1YkFycmF5LCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmV0LnB1c2goZGVjb2RlZCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcGFyc2VkVHlwZS5zdWJBcnJheS5tZW1vcnlVc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUgPT09ICdieXRlcycpIHtcbiAgICAgICAgb2Zmc2V0ID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KS50b051bWJlcigpO1xuICAgICAgICBzaXplID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KS50b051bWJlcigpO1xuICAgICAgICByZXR1cm4gZGF0YS5zbGljZShvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBzaXplKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBwYXJzZWRUeXBlLnNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUuc3RhcnRzV2l0aCgndWludCcpKSB7XG4gICAgICAgIG51bSA9IG5ldyBCTihkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMzIpLCAxNiwgJ2JlJyk7XG4gICAgICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBwYXJzZWRUeXBlLnNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlZCBpbnQgZXhjZWVkcyB3aWR0aDogJyArIHBhcnNlZFR5cGUuc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgICAgIG51bSA9IG5ldyBCTihkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMzIpLCAxNiwgJ2JlJykuZnJvbVR3b3MoMjU2KTtcbiAgICAgICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHBhcnNlZFR5cGUuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHBhcnNlZFR5cGUuc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ3VmaXhlZCcpKSB7XG4gICAgICAgIHNpemUgPSBuZXcgQk4oMikucG93KG5ldyBCTihwYXJzZWRUeXBlLnNpemVbMV0pKTtcbiAgICAgICAgbnVtID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCFudW0ubW9kKHNpemUpLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2ltYWxzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bS5kaXYoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcnNlZFR5cGUubmFtZS5zdGFydHNXaXRoKCdmaXhlZCcpKSB7XG4gICAgICAgIHNpemUgPSBuZXcgQk4oMikucG93KG5ldyBCTihwYXJzZWRUeXBlLnNpemVbMV0pKTtcbiAgICAgICAgbnVtID0gZGVjb2RlU2luZ2xlKCdpbnQyNTYnLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZiAoIW51bS5tb2Qoc2l6ZSkuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjaW1hbHMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtLmRpdihzaXplKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyBwYXJzZWRUeXBlLm5hbWUpO1xufVxuZnVuY3Rpb24gcGFyc2VUeXBlKHR5cGUpIHtcbiAgICB2YXIgc2l6ZTtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHNpemUgPSBwYXJzZVR5cGVBcnJheSh0eXBlKTtcbiAgICAgICAgdmFyIHN1YkFycmF5ID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpO1xuICAgICAgICBzdWJBcnJheSA9IHBhcnNlVHlwZShzdWJBcnJheSk7XG4gICAgICAgIHJldCA9IHtcbiAgICAgICAgICAgIGlzQXJyYXk6IHRydWUsXG4gICAgICAgICAgICBuYW1lOiB0eXBlLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIG1lbW9yeVVzYWdlOiBzaXplID09PSAnZHluYW1pYycgPyAzMiA6IHN1YkFycmF5Lm1lbW9yeVVzYWdlICogc2l6ZSxcbiAgICAgICAgICAgIHN1YkFycmF5OiBzdWJBcnJheVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJhd1R5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICAgICAgICAgICAgcmF3VHlwZSA9ICd1aW50MTYwJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgICAgICAgIHJhd1R5cGUgPSAndWludDgnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByYXdUeXBlID0gJ2J5dGVzJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXQgPSB7XG4gICAgICAgICAgICByYXdUeXBlOiByYXdUeXBlLFxuICAgICAgICAgICAgbmFtZTogdHlwZSxcbiAgICAgICAgICAgIG1lbW9yeVVzYWdlOiAzMlxuICAgICAgICB9O1xuICAgICAgICBpZiAoKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSAmJiB0eXBlICE9PSAnYnl0ZXMnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgICAgICAgICByZXQuc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCd1Zml4ZWQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2ZpeGVkJykpIHtcbiAgICAgICAgICAgIHJldC5zaXplID0gcGFyc2VUeXBlTnhNKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykgJiYgdHlwZSAhPT0gJ2J5dGVzJyAmJiAocmV0LnNpemUgPCAxIHx8IHJldC5zaXplID4gMzIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXM8Tj4gd2lkdGg6ICcgKyByZXQuc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSAmJiAocmV0LnNpemUgJSA4IHx8IHJldC5zaXplIDwgOCB8fCByZXQuc2l6ZSA+IDI1NikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnQvdWludDxOPiB3aWR0aDogJyArIHJldC5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRHluYW1pYyh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSAnc3RyaW5nJykgfHwgKHR5cGUgPT09ICdieXRlcycpIHx8IChwYXJzZVR5cGVBcnJheSh0eXBlKSA9PT0gJ2R5bmFtaWMnKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodHlwZSkge1xuICAgIHJldHVybiB0eXBlLmxhc3RJbmRleE9mKCddJykgPT09IHR5cGUubGVuZ3RoIC0gMTtcbn1cbkFCSS5yYXdFbmNvZGUgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIHZhciBoZWFkTGVuZ3RoID0gMDtcbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpO1xuICAgICAgICAgICAgaWYgKHNpemUgIT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICAgIGhlYWRMZW5ndGggKz0gMzIgKiBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZExlbmd0aCArPSAzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRMZW5ndGggKz0gMzI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gZWxlbWVudGFyeU5hbWUodHlwZXNbaV0pO1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIHZhciBjdXIgPSBlbmNvZGVTaW5nbGUodHlwZSwgdmFsdWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKHR5cGUpKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBoZWFkTGVuZ3RoKSk7XG4gICAgICAgICAgICBkYXRhLnB1c2goY3VyKTtcbiAgICAgICAgICAgIGhlYWRMZW5ndGggKz0gY3VyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGN1cik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0cHV0LmNvbmNhdChkYXRhKSk7XG59O1xuQUJJLnJhd0RlY29kZSA9IGZ1bmN0aW9uICh0eXBlcywgZGF0YSkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnRhcnlOYW1lKHR5cGVzW2ldKTtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlVHlwZSh0eXBlLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICB2YXIgZGVjb2RlZCA9IGRlY29kZVNpbmdsZShwYXJzZWQsIGRhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBwYXJzZWQubWVtb3J5VXNhZ2U7XG4gICAgICAgIHJldC5wdXNoKGRlY29kZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcbkFCSS5zaW1wbGVFbmNvZGUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLnNsaWNlKDEpO1xuICAgIHZhciBzaWcgPSBwYXJzZVNpZ25hdHVyZShtZXRob2QpO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gc2lnLmFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgY291bnQgbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW0FCSS5tZXRob2RJRChzaWcubWV0aG9kLCBzaWcuYXJncyksIEFCSS5yYXdFbmNvZGUoc2lnLmFyZ3MsIGFyZ3MpXSk7XG59O1xuQUJJLnNpbXBsZURlY29kZSA9IGZ1bmN0aW9uIChtZXRob2QsIGRhdGEpIHtcbiAgICB2YXIgc2lnID0gcGFyc2VTaWduYXR1cmUobWV0aG9kKTtcbiAgICBpZiAoIXNpZy5yZXRhcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmV0dXJuIHZhbHVlcyBpbiBtZXRob2QnKTtcbiAgICB9XG4gICAgcmV0dXJuIEFCSS5yYXdEZWNvZGUoc2lnLnJldGFyZ3MsIGRhdGEpO1xufTtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2FkZHJlc3MnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyB2YWx1ZS50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG59XG5BQkkuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSBpbiB0eXBlcykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGlmICgvXlteXFxbXStcXFsuKlxcXSQvLnRlc3QodHlwZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh0eXBlLCBpdGVtKTtcbiAgICAgICAgICAgIH0pLmpvaW4oJywgJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ2lmeSh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcbkFCSS5zb2xpZGl0eUhleFZhbHVlID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlLCBiaXRzaXplKSB7XG4gICAgdmFyIHNpemUsIG51bTtcbiAgICBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB2YXIgc3ViVHlwZSA9IHR5cGUucmVwbGFjZSgvXFxbLio/XFxdLywgJycpO1xuICAgICAgICBpZiAoIWlzQXJyYXkoc3ViVHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBhcnJheVNpemUgPSBwYXJzZVR5cGVBcnJheSh0eXBlKTtcbiAgICAgICAgICAgIGlmIChhcnJheVNpemUgIT09ICdkeW5hbWljJyAmJiBhcnJheVNpemUgIT09IDAgJiYgdmFsdWUubGVuZ3RoID4gYXJyYXlTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50cyBleGNlZWQgYXJyYXkgc2l6ZTogJyArIGFycmF5U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFycmF5VmFsdWVzID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gQUJJLnNvbGlkaXR5SGV4VmFsdWUoc3ViVHlwZSwgdiwgMjU2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGFycmF5VmFsdWVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIGJpdHNpemUgPSBiaXRzaXplIHx8IDg7XG4gICAgICAgIHZhciBwYWRkaW5nID0gQXJyYXkoKGJpdHNpemUpIC8gNCkuam9pbignMCcpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUgPyBwYWRkaW5nICsgJzEnIDogcGFkZGluZyArICcwJywgJ2hleCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgdmFyIGJ5dGVzaXplID0gMjA7XG4gICAgICAgIGlmIChiaXRzaXplKSB7XG4gICAgICAgICAgICBieXRlc2l6ZSA9IGJpdHNpemUgLyA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5zZXRMZW5ndGhMZWZ0KHRvQnVmZmVyKHZhbHVlKSwgYnl0ZXNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSk7XG4gICAgICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlczxOPiB3aWR0aDogJyArIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLnNldExlbmd0aFJpZ2h0KHRvQnVmZmVyKHZhbHVlKSwgc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSB7XG4gICAgICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpO1xuICAgICAgICBpZiAoKHNpemUgJSA4KSB8fCAoc2l6ZSA8IDgpIHx8IChzaXplID4gMjU2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVpbnQ8Tj4gd2lkdGg6ICcgKyBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSBwYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGJpdHNpemUgPSBiaXRzaXplIHx8IHNpemU7XG4gICAgICAgIHJldHVybiBudW0udG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCBiaXRzaXplIC8gOCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSk7XG4gICAgICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50PE4+IHdpZHRoOiAnICsgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtID0gcGFyc2VOdW1iZXIodmFsdWUpO1xuICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCBpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGJpdHNpemUgPSBiaXRzaXplIHx8IHNpemU7XG4gICAgICAgIHJldHVybiBudW0udG9Ud29zKHNpemUpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgYml0c2l6ZSAvIDgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG59O1xuQUJJLnNvbGlkaXR5UGFjayA9IGZ1bmN0aW9uICh0eXBlcywgdmFsdWVzKSB7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiB0eXBlcyBhcmUgbm90IG1hdGNoaW5nIHRoZSB2YWx1ZXMnKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50YXJ5TmFtZSh0eXBlc1tpXSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmV0LnB1c2goQUJJLnNvbGlkaXR5SGV4VmFsdWUodHlwZSwgdmFsdWUsIG51bGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KTtcbn07XG5BQkkuc29saWRpdHlTSEEzID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gYmFzZS5rZWNjYWsyNTYoQUJJLnNvbGlkaXR5UGFjayh0eXBlcywgdmFsdWVzKSk7XG59O1xuQUJJLnNvbGlkaXR5U0hBMjU2ID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gYmFzZS5zaGEyNTYoQUJJLnNvbGlkaXR5UGFjayh0eXBlcywgdmFsdWVzKSk7XG59O1xuQUJJLnNvbGlkaXR5UklQRU1EMTYwID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gYmFzZS5yaXBlbWQxNjAoQUJJLnNvbGlkaXR5UGFjayh0eXBlcywgdmFsdWVzKSwgdHJ1ZSk7XG59O1xuZnVuY3Rpb24gaXNOdW1lcmljKGMpIHtcbiAgICByZXR1cm4gKGMgPj0gJzAnKSAmJiAoYyA8PSAnOScpO1xufVxuQUJJLmZyb21TZXJwZW50ID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHNpZ1tpXTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzJykge1xuICAgICAgICAgICAgcmV0LnB1c2goJ2J5dGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2InKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gJ2J5dGVzJztcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoKGogPCBzaWcubGVuZ3RoKSAmJiBpc051bWVyaWMoc2lnW2pdKSkge1xuICAgICAgICAgICAgICAgIHRtcCArPSBzaWdbal0gLSAnMCc7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IGogLSAxO1xuICAgICAgICAgICAgcmV0LnB1c2godG1wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnaScpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKCdpbnQyNTYnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYScpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKCdpbnQyNTZbXScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcbkFCSS50b1NlcnBlbnQgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICAgICAgcmV0LnB1c2goJ3MnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKCdiJyArIHBhcnNlVHlwZU4odHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdpbnQyNTYnKSB7XG4gICAgICAgICAgICByZXQucHVzaCgnaScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdpbnQyNTZbXScpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKCdhJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignJyk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBQkk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/abi.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/bytes.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/abi/bytes.js ***!
  \************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/helpers.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/internal.js\");\nconst intToHex = function (i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\nconst intToBuffer = function (i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');\n};\nexports.intToBuffer = intToBuffer;\nconst zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\nconst setLength = function (msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    }\n    else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\nconst setLengthLeft = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\nconst setLengthRight = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\nconst stripZeros = function (a) {\n    let first = a[0];\n    while (a.length > 0 && first.toString() === '0') {\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\nconst unpadBuffer = function (a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\nconst unpadArray = function (a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\nconst unpadHexString = function (a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return ('0x' + stripZeros(a));\n};\nexports.unpadHexString = unpadHexString;\nconst toBuffer = function (v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === 'string') {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');\n    }\n    if (typeof v === 'number') {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (typeof v === 'bigint') {\n        if (v < BigInt(0)) {\n            throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);\n        }\n        let n = v.toString(16);\n        if (n.length % 2)\n            n = '0' + n;\n        return Buffer.from(n, 'hex');\n    }\n    if (v.toArray) {\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error('invalid type');\n};\nexports.toBuffer = toBuffer;\nconst bufferToHex = function (buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return '0x' + buf.toString('hex');\n};\nexports.bufferToHex = bufferToHex;\nfunction bufferToBigInt(buf) {\n    const hex = (0, exports.bufferToHex)(buf);\n    if (hex === '0x') {\n        return BigInt(0);\n    }\n    return BigInt(hex);\n}\nexports.bufferToBigInt = bufferToBigInt;\nfunction bigIntToBuffer(num) {\n    return (0, exports.toBuffer)('0x' + num.toString(16));\n}\nexports.bigIntToBuffer = bigIntToBuffer;\nconst bufferToInt = function (buf) {\n    const res = Number(bufferToBigInt(buf));\n    if (!Number.isSafeInteger(res))\n        throw new Error('Number exceeds 53 bits');\n    return res;\n};\nexports.bufferToInt = bufferToInt;\nconst fromSigned = function (num) {\n    return BigInt.asIntN(256, bufferToBigInt(num));\n};\nexports.fromSigned = fromSigned;\nconst toUnsigned = function (num) {\n    return bigIntToBuffer(BigInt.asUintN(256, num));\n};\nexports.toUnsigned = toUnsigned;\nconst addHexPrefix = function (str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;\n};\nexports.addHexPrefix = addHexPrefix;\nfunction short(buffer, maxLength = 50) {\n    const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString('hex') : buffer;\n    if (bufferStr.length <= maxLength) {\n        return bufferStr;\n    }\n    return bufferStr.slice(0, maxLength) + '';\n}\nexports.short = short;\nconst toUtf8 = function (hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error('Invalid non-even hex string input for toUtf8() provided');\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, ''), 'hex');\n    return bufferVal.toString('utf8');\n};\nexports.toUtf8 = toUtf8;\nconst baToJSON = function (ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString('hex')}`;\n    }\n    else if (ba instanceof Array) {\n        const array = [];\n        for (let i = 0; i < ba.length; i++) {\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\nconst validateNoLeadingZeroes = function (values) {\n    for (const [k, v] of Object.entries(values)) {\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString('hex')}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a) => arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr ?? []);\n    }\n    return arr.map((a) => bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr;\nconst bigIntToHex = (num) => {\n    return '0x' + num.toString(16);\n};\nexports.bigIntToHex = bigIntToHex;\nfunction bigIntToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)(bigIntToBuffer(value));\n}\nexports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;\nfunction intToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));\n}\nexports.intToUnpaddedBuffer = intToUnpaddedBuffer;\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRywrQkFBK0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0I7QUFDcGpCLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFZO0FBQ3ZDO0FBQ0E7QUFDQSw2REFBNkQsRUFBRTtBQUMvRDtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLEVBQUU7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRyx3Q0FBd0Msa0JBQWtCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9ieXRlcy5qcz84NmY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnRUb1VucGFkZGVkQnVmZmVyID0gZXhwb3J0cy5iaWdJbnRUb1VucGFkZGVkQnVmZmVyID0gZXhwb3J0cy5iaWdJbnRUb0hleCA9IGV4cG9ydHMuYnVmQXJyVG9BcnIgPSBleHBvcnRzLmFyclRvQnVmQXJyID0gZXhwb3J0cy52YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGV4cG9ydHMuYmFUb0pTT04gPSBleHBvcnRzLnRvVXRmOCA9IGV4cG9ydHMuc2hvcnQgPSBleHBvcnRzLmFkZEhleFByZWZpeCA9IGV4cG9ydHMudG9VbnNpZ25lZCA9IGV4cG9ydHMuZnJvbVNpZ25lZCA9IGV4cG9ydHMuYnVmZmVyVG9JbnQgPSBleHBvcnRzLmJpZ0ludFRvQnVmZmVyID0gZXhwb3J0cy5idWZmZXJUb0JpZ0ludCA9IGV4cG9ydHMuYnVmZmVyVG9IZXggPSBleHBvcnRzLnRvQnVmZmVyID0gZXhwb3J0cy51bnBhZEhleFN0cmluZyA9IGV4cG9ydHMudW5wYWRBcnJheSA9IGV4cG9ydHMudW5wYWRCdWZmZXIgPSBleHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy56ZXJvcyA9IGV4cG9ydHMuaW50VG9CdWZmZXIgPSBleHBvcnRzLmludFRvSGV4ID0gdm9pZCAwO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbmNvbnN0IGludFRvSGV4ID0gZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGkpIHx8IGkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgYW4gaW52YWxpZCBpbnRlZ2VyIHR5cGU6ICR7aX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aS50b1N0cmluZygxNil9YDtcbn07XG5leHBvcnRzLmludFRvSGV4ID0gaW50VG9IZXg7XG5jb25zdCBpbnRUb0J1ZmZlciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgY29uc3QgaGV4ID0gKDAsIGV4cG9ydHMuaW50VG9IZXgpKGkpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5wYWRUb0V2ZW4pKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn07XG5leHBvcnRzLmludFRvQnVmZmVyID0gaW50VG9CdWZmZXI7XG5jb25zdCB6ZXJvcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuZXhwb3J0cy56ZXJvcyA9IHplcm9zO1xuY29uc3Qgc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICAgIGNvbnN0IGJ1ZiA9ICgwLCBleHBvcnRzLnplcm9zKShsZW5ndGgpO1xuICAgIGlmIChyaWdodCkge1xuICAgICAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gICAgfVxufTtcbmNvbnN0IHNldExlbmd0aExlZnQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShtc2cpO1xuICAgIHJldHVybiBzZXRMZW5ndGgobXNnLCBsZW5ndGgsIGZhbHNlKTtcbn07XG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBzZXRMZW5ndGhMZWZ0O1xuY29uc3Qgc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShtc2cpO1xuICAgIHJldHVybiBzZXRMZW5ndGgobXNnLCBsZW5ndGgsIHRydWUpO1xufTtcbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBzZXRMZW5ndGhSaWdodDtcbmNvbnN0IHN0cmlwWmVyb3MgPSBmdW5jdGlvbiAoYSkge1xuICAgIGxldCBmaXJzdCA9IGFbMF07XG4gICAgd2hpbGUgKGEubGVuZ3RoID4gMCAmJiBmaXJzdC50b1N0cmluZygpID09PSAnMCcpIHtcbiAgICAgICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgICAgIGZpcnN0ID0gYVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuY29uc3QgdW5wYWRCdWZmZXIgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGEpO1xuICAgIHJldHVybiBzdHJpcFplcm9zKGEpO1xufTtcbmV4cG9ydHMudW5wYWRCdWZmZXIgPSB1bnBhZEJ1ZmZlcjtcbmNvbnN0IHVucGFkQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheSkoYSk7XG4gICAgcmV0dXJuIHN0cmlwWmVyb3MoYSk7XG59O1xuZXhwb3J0cy51bnBhZEFycmF5ID0gdW5wYWRBcnJheTtcbmNvbnN0IHVucGFkSGV4U3RyaW5nID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzSGV4U3RyaW5nKShhKTtcbiAgICBhID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGEpO1xuICAgIHJldHVybiAoJzB4JyArIHN0cmlwWmVyb3MoYSkpO1xufTtcbmV4cG9ydHMudW5wYWRIZXhTdHJpbmcgPSB1bnBhZEhleFN0cmluZztcbmNvbnN0IHRvQnVmZmVyID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHYpIHx8IHYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoISgwLCBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nKSh2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29udmVydCBzdHJpbmcgdG8gYnVmZmVyLiB0b0J1ZmZlciBvbmx5IHN1cHBvcnRzIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzIGFuZCB0aGlzIHN0cmluZyB3YXMgZ2l2ZW46ICR7dn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGludGVybmFsXzEucGFkVG9FdmVuKSgoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkodikpLCAnaGV4Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmludFRvQnVmZmVyKSh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICBpZiAodiA8IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29udmVydCBuZWdhdGl2ZSBiaWdpbnQgdG8gYnVmZmVyLiBHaXZlbjogJHt2fWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gdi50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChuLmxlbmd0aCAlIDIpXG4gICAgICAgICAgICBuID0gJzAnICsgbjtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG4sICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHYudG9BcnJheSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgIH1cbiAgICBpZiAodi50b0J1ZmZlcikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odi50b0J1ZmZlcigpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbn07XG5leHBvcnRzLnRvQnVmZmVyID0gdG9CdWZmZXI7XG5jb25zdCBidWZmZXJUb0hleCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBidWYgPSAoMCwgZXhwb3J0cy50b0J1ZmZlcikoYnVmKTtcbiAgICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG59O1xuZXhwb3J0cy5idWZmZXJUb0hleCA9IGJ1ZmZlclRvSGV4O1xuZnVuY3Rpb24gYnVmZmVyVG9CaWdJbnQoYnVmKSB7XG4gICAgY29uc3QgaGV4ID0gKDAsIGV4cG9ydHMuYnVmZmVyVG9IZXgpKGJ1Zik7XG4gICAgaWYgKGhleCA9PT0gJzB4Jykge1xuICAgICAgICByZXR1cm4gQmlnSW50KDApO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KGhleCk7XG59XG5leHBvcnRzLmJ1ZmZlclRvQmlnSW50ID0gYnVmZmVyVG9CaWdJbnQ7XG5mdW5jdGlvbiBiaWdJbnRUb0J1ZmZlcihudW0pIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMudG9CdWZmZXIpKCcweCcgKyBudW0udG9TdHJpbmcoMTYpKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CdWZmZXIgPSBiaWdJbnRUb0J1ZmZlcjtcbmNvbnN0IGJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIGNvbnN0IHJlcyA9IE51bWJlcihidWZmZXJUb0JpZ0ludChidWYpKTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIGV4Y2VlZHMgNTMgYml0cycpO1xuICAgIHJldHVybiByZXM7XG59O1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGJ1ZmZlclRvSW50O1xuY29uc3QgZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gQmlnSW50LmFzSW50TigyNTYsIGJ1ZmZlclRvQmlnSW50KG51bSkpO1xufTtcbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZyb21TaWduZWQ7XG5jb25zdCB0b1Vuc2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBiaWdJbnRUb0J1ZmZlcihCaWdJbnQuYXNVaW50TigyNTYsIG51bSkpO1xufTtcbmV4cG9ydHMudG9VbnNpZ25lZCA9IHRvVW5zaWduZWQ7XG5jb25zdCBhZGRIZXhQcmVmaXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW50ZXJuYWxfMS5pc0hleFByZWZpeGVkKShzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcbn07XG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGFkZEhleFByZWZpeDtcbmZ1bmN0aW9uIHNob3J0KGJ1ZmZlciwgbWF4TGVuZ3RoID0gNTApIHtcbiAgICBjb25zdCBidWZmZXJTdHIgPSBCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSA/IGJ1ZmZlci50b1N0cmluZygnaGV4JykgOiBidWZmZXI7XG4gICAgaWYgKGJ1ZmZlclN0ci5sZW5ndGggPD0gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJTdHI7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJTdHIuc2xpY2UoMCwgbWF4TGVuZ3RoKSArICfigKYnO1xufVxuZXhwb3J0cy5zaG9ydCA9IHNob3J0O1xuY29uc3QgdG9VdGY4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIGNvbnN0IHplcm9zUmVnZXhwID0gL14oMDApK3woMDApKyQvZztcbiAgICBoZXggPSAoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoaGV4KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5vbi1ldmVuIGhleCBzdHJpbmcgaW5wdXQgZm9yIHRvVXRmOCgpIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlclZhbCA9IEJ1ZmZlci5mcm9tKGhleC5yZXBsYWNlKHplcm9zUmVnZXhwLCAnJyksICdoZXgnKTtcbiAgICByZXR1cm4gYnVmZmVyVmFsLnRvU3RyaW5nKCd1dGY4Jyk7XG59O1xuZXhwb3J0cy50b1V0ZjggPSB0b1V0Zjg7XG5jb25zdCBiYVRvSlNPTiA9IGZ1bmN0aW9uIChiYSkge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYmEpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2JhLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChiYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5LnB1c2goKDAsIGV4cG9ydHMuYmFUb0pTT04pKGJhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn07XG5leHBvcnRzLmJhVG9KU09OID0gYmFUb0pTT047XG5jb25zdCB2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgdi5sZW5ndGggPiAwICYmIHZbMF0gPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrfSBjYW5ub3QgaGF2ZSBsZWFkaW5nIHplcm9lcywgcmVjZWl2ZWQ6ICR7di50b1N0cmluZygnaGV4Jyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy52YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IHZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzO1xuZnVuY3Rpb24gYXJyVG9CdWZBcnIoYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG4gICAgfVxuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBhcnJUb0J1ZkFycihhKSk7XG59XG5leHBvcnRzLmFyclRvQnVmQXJyID0gYXJyVG9CdWZBcnI7XG5mdW5jdGlvbiBidWZBcnJUb0FycihhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFyciA/PyBbXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBidWZBcnJUb0FycihhKSk7XG59XG5leHBvcnRzLmJ1ZkFyclRvQXJyID0gYnVmQXJyVG9BcnI7XG5jb25zdCBiaWdJbnRUb0hleCA9IChudW0pID0+IHtcbiAgICByZXR1cm4gJzB4JyArIG51bS50b1N0cmluZygxNik7XG59O1xuZXhwb3J0cy5iaWdJbnRUb0hleCA9IGJpZ0ludFRvSGV4O1xuZnVuY3Rpb24gYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy51bnBhZEJ1ZmZlcikoYmlnSW50VG9CdWZmZXIodmFsdWUpKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlciA9IGJpZ0ludFRvVW5wYWRkZWRCdWZmZXI7XG5mdW5jdGlvbiBpbnRUb1VucGFkZGVkQnVmZmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnVucGFkQnVmZmVyKSgoMCwgZXhwb3J0cy5pbnRUb0J1ZmZlcikodmFsdWUpKTtcbn1cbmV4cG9ydHMuaW50VG9VbnBhZGRlZEJ1ZmZlciA9IGludFRvVW5wYWRkZWRCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/bytes.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/helpers.js':
    /*!**************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/abi/helpers.js ***!
  \**************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = __webpack_require__(/*! ./internal */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/internal.js");\nconst assertIsHexString = function (input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\nconst assertIsBuffer = function (input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\nconst assertIsArray = function (input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\nconst assertIsString = function (input) {\n    if (typeof input !== \'string\') {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString;\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QjtBQUNuRyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBWTtBQUN2QztBQUNBO0FBQ0Esd0ZBQXdGLE1BQU07QUFDOUY7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx1RUFBdUUsTUFBTTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLDhFQUE4RSxNQUFNO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esd0VBQXdFLE1BQU07QUFDOUU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9oZWxwZXJzLmpzP2Q0ODUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydElzU3RyaW5nID0gZXhwb3J0cy5hc3NlcnRJc0FycmF5ID0gZXhwb3J0cy5hc3NlcnRJc0J1ZmZlciA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5jb25zdCBhc3NlcnRJc0hleFN0cmluZyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKGlucHV0KSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG5jb25zdCBhc3NlcnRJc0J1ZmZlciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBCdWZmZXIgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc0J1ZmZlciA9IGFzc2VydElzQnVmZmVyO1xuY29uc3QgYXNzZXJ0SXNBcnJheSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgbnVtYmVyIGFycmF5cyBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzQXJyYXkgPSBhc3NlcnRJc0FycmF5O1xuY29uc3QgYXNzZXJ0SXNTdHJpbmcgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBzdHJpbmdzIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNTdHJpbmcgPSBhc3NlcnRJc1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/helpers.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/index.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/abi/index.js ***!
  \************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SoliditySHA3 = exports.RawEncode = exports.ABI = void 0;\nconst ABI = __webpack_require__(/*! ./abi.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/abi.js");\nexports.ABI = ABI;\nfunction RawEncode(types, values) {\n    return ABI.rawEncode(types, values);\n}\nexports.RawEncode = RawEncode;\nfunction SoliditySHA3(types, values) {\n    return ABI.soliditySHA3(types, values);\n}\nexports.SoliditySHA3 = SoliditySHA3;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRyxXQUFXO0FBQ3RELFlBQVksbUJBQU8sQ0FBQywwRUFBVTtBQUM5QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9hYmkvaW5kZXguanM/MGExZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29saWRpdHlTSEEzID0gZXhwb3J0cy5SYXdFbmNvZGUgPSBleHBvcnRzLkFCSSA9IHZvaWQgMDtcbmNvbnN0IEFCSSA9IHJlcXVpcmUoXCIuL2FiaS5qc1wiKTtcbmV4cG9ydHMuQUJJID0gQUJJO1xuZnVuY3Rpb24gUmF3RW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gQUJJLnJhd0VuY29kZSh0eXBlcywgdmFsdWVzKTtcbn1cbmV4cG9ydHMuUmF3RW5jb2RlID0gUmF3RW5jb2RlO1xuZnVuY3Rpb24gU29saWRpdHlTSEEzKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gQUJJLnNvbGlkaXR5U0hBMyh0eXBlcywgdmFsdWVzKTtcbn1cbmV4cG9ydHMuU29saWRpdHlTSEEzID0gU29saWRpdHlTSEEzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/internal.js':
    /*!***************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/abi/internal.js ***!
  \***************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\nfunction isHexPrefixed(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === '0' && str[1] === 'x';\n}\nexports.isHexPrefixed = isHexPrefixed;\nconst stripHexPrefix = (str) => {\n    if (typeof str !== 'string')\n        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\nfunction padToEven(value) {\n    let a = value;\n    if (typeof a !== 'string') {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2)\n        a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\nfunction getBinarySize(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);\n    }\n    return Buffer.byteLength(str, 'utf8');\n}\nexports.getBinarySize = getBinarySize;\nfunction arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some === true ? 'some' : 'every']((value) => superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\nfunction toAscii(hex) {\n    let str = '';\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === '0x')\n        i = 2;\n    for (; i < l; i += 2) {\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\nfunction fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, 'utf8');\n    return `0x${padToEven(str.toString('hex')).replace(/^0+|0+$/g, '')}`;\n}\nexports.fromUtf8 = fromUtf8;\nfunction fromAscii(stringValue) {\n    let hex = '';\n    for (let i = 0; i < stringValue.length; i++) {\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\nfunction getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== 'string') {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for (let i = 0; i < params.length; i++) {\n        let value = params[i][key];\n        if (allowEmpty === true && !value) {\n            value = '';\n        }\n        else if (typeof value !== 'string') {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\nfunction isHexString(value, length) {\n    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/))\n        return false;\n    if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length)\n        return false;\n    return true;\n}\nexports.isHexString = isHexString;\n//# sourceMappingURL=internal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9pbnRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQjtBQUN4TjtBQUNBO0FBQ0Esc0ZBQXNGLFdBQVc7QUFDakc7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrRkFBa0YsV0FBVztBQUM3RjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQSxnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx5RkFBeUYsV0FBVztBQUNwRztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDJHQUEyRyxnQkFBZ0I7QUFDM0g7QUFDQTtBQUNBLHlHQUF5RyxjQUFjO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUF1RDtBQUN2RTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0Esa0NBQWtDLEVBQUU7QUFDcEM7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdUZBQXVGLGNBQWM7QUFDckc7QUFDQTtBQUNBLHlGQUF5RixjQUFjO0FBQ3ZHO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsYUFBYTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9pbnRlcm5hbC5qcz80ZjE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuZ2V0S2V5cyA9IGV4cG9ydHMuZnJvbUFzY2lpID0gZXhwb3J0cy5mcm9tVXRmOCA9IGV4cG9ydHMudG9Bc2NpaSA9IGV4cG9ydHMuYXJyYXlDb250YWluc0FycmF5ID0gZXhwb3J0cy5nZXRCaW5hcnlTaXplID0gZXhwb3J0cy5wYWRUb0V2ZW4gPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gZXhwb3J0cy5pc0hleFByZWZpeGVkID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbaXNIZXhQcmVmaXhlZF0gaW5wdXQgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCB0eXBlICR7dHlwZW9mIHN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0clswXSA9PT0gJzAnICYmIHN0clsxXSA9PT0gJ3gnO1xufVxuZXhwb3J0cy5pc0hleFByZWZpeGVkID0gaXNIZXhQcmVmaXhlZDtcbmNvbnN0IHN0cmlwSGV4UHJlZml4ID0gKHN0cikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbc3RyaXBIZXhQcmVmaXhdIGlucHV0IG11c3QgYmUgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59O1xuZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IHN0cmlwSGV4UHJlZml4O1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gICAgbGV0IGEgPSB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW3BhZFRvRXZlbl0gdmFsdWUgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCAke3R5cGVvZiBhfWApO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggJSAyKVxuICAgICAgICBhID0gYDAke2F9YDtcbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydHMucGFkVG9FdmVuID0gcGFkVG9FdmVuO1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbZ2V0QmluYXJ5U2l6ZV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0IHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIHN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cbmV4cG9ydHMuZ2V0QmluYXJ5U2l6ZSA9IGdldEJpbmFyeVNpemU7XG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFthcnJheUNvbnRhaW5zQXJyYXldIG1ldGhvZCByZXF1aXJlcyBpbnB1dCAnc3VwZXJzZXQnIHRvIGJlIGFuIGFycmF5LCBnb3QgdHlwZSAnJHt0eXBlb2Ygc3VwZXJzZXR9J2ApO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2FycmF5Q29udGFpbnNBcnJheV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0ICdzdWJzZXQnIHRvIGJlIGFuIGFycmF5LCBnb3QgdHlwZSAnJHt0eXBlb2Ygc3Vic2V0fSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNldFtzb21lID09PSB0cnVlID8gJ3NvbWUnIDogJ2V2ZXJ5J10oKHZhbHVlKSA9PiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwKTtcbn1cbmV4cG9ydHMuYXJyYXlDb250YWluc0FycmF5ID0gYXJyYXlDb250YWluc0FycmF5O1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKVxuICAgICAgICBpID0gMjtcbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMudG9Bc2NpaSA9IHRvQXNjaWk7XG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICAgIGNvbnN0IHN0ciA9IEJ1ZmZlci5mcm9tKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuICAgIHJldHVybiBgMHgke3BhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKX1gO1xufVxuZXhwb3J0cy5mcm9tVXRmOCA9IGZyb21VdGY4O1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGNvbnN0IG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/IGAwJHtufWAgOiBuO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXh9YDtcbn1cbmV4cG9ydHMuZnJvbUFzY2lpID0gZnJvbUFzY2lpO1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dldEtleXNdIG1ldGhvZCBleHBlY3RzIGlucHV0ICdwYXJhbXMnIHRvIGJlIGFuIGFycmF5LCBnb3QgJHt0eXBlb2YgcGFyYW1zfWApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbZ2V0S2V5c10gbWV0aG9kIGV4cGVjdHMgaW5wdXQgJ2tleScgdG8gYmUgdHlwZSAnc3RyaW5nJywgZ290ICR7dHlwZW9mIHBhcmFtc31gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2ldW2tleV07XG4gICAgICAgIGlmIChhbGxvd0VtcHR5ID09PSB0cnVlICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWJpIC0gZXhwZWN0ZWQgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRLZXlzID0gZ2V0S2V5cztcbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJiBsZW5ndGggPiAwICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/internal.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/rlp.js':
    /*!**********************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/abi/rlp.js ***!
  \**********************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stripHexPrefix = exports.isHexPrefixed = exports.getLength = exports.decode = exports.encode = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nfunction encode(input) {\n    if (Array.isArray(input)) {\n        const output = [];\n        for (let i = 0; i < input.length; i++) {\n            output.push(encode(input[i]));\n        }\n        const buf = Buffer.concat(output);\n        return Buffer.concat([encodeLength(buf.length, 192), buf]);\n    }\n    else {\n        const inputBuf = toBuffer(input);\n        return inputBuf.length === 1 && inputBuf[0] < 128\n            ? inputBuf\n            : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);\n    }\n}\nexports.encode = encode;\nfunction safeParseInt(v, base) {\n    if (v[0] === '0' && v[1] === '0') {\n        throw new Error('invalid RLP: extra zeros');\n    }\n    return parseInt(v, base);\n}\nfunction encodeLength(len, offset) {\n    if (len < 56) {\n        return Buffer.from([len + offset]);\n    }\n    else {\n        const hexLength = intToHex(len);\n        const lLength = hexLength.length / 2;\n        const firstByte = intToHex(offset + 55 + lLength);\n        return Buffer.from(firstByte + hexLength, 'hex');\n    }\n}\nfunction decode(input, stream = false) {\n    if (!input || input.length === 0) {\n        return Buffer.from([]);\n    }\n    const inputBuffer = toBuffer(input);\n    const decoded = _decode(inputBuffer);\n    if (stream) {\n        return decoded;\n    }\n    if (decoded.remainder.length !== 0) {\n        throw new Error('invalid remainder');\n    }\n    return decoded.data;\n}\nexports.decode = decode;\nfunction getLength(input) {\n    if (!input || input.length === 0) {\n        return Buffer.from([]);\n    }\n    const inputBuffer = toBuffer(input);\n    const firstByte = inputBuffer[0];\n    if (firstByte <= 0x7f) {\n        return inputBuffer.length;\n    }\n    else if (firstByte <= 0xb7) {\n        return firstByte - 0x7f;\n    }\n    else if (firstByte <= 0xbf) {\n        return firstByte - 0xb6;\n    }\n    else if (firstByte <= 0xf7) {\n        return firstByte - 0xbf;\n    }\n    else {\n        const llength = firstByte - 0xf6;\n        const length = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);\n        return llength + length;\n    }\n}\nexports.getLength = getLength;\nfunction _decode(input) {\n    let length, llength, data, innerRemainder, d;\n    const decoded = [];\n    const firstByte = input[0];\n    if (firstByte <= 0x7f) {\n        return {\n            data: input.slice(0, 1),\n            remainder: input.slice(1),\n        };\n    }\n    else if (firstByte <= 0xb7) {\n        length = firstByte - 0x7f;\n        if (firstByte === 0x80) {\n            data = Buffer.from([]);\n        }\n        else {\n            data = input.slice(1, length);\n        }\n        if (length === 2 && data[0] < 0x80) {\n            throw new Error('invalid rlp encoding: byte must be less 0x80');\n        }\n        return {\n            data: data,\n            remainder: input.slice(length),\n        };\n    }\n    else if (firstByte <= 0xbf) {\n        llength = firstByte - 0xb6;\n        if (input.length - 1 < llength) {\n            throw new Error('invalid RLP: not enough bytes for string length');\n        }\n        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);\n        if (length <= 55) {\n            throw new Error('invalid RLP: expected string length to be greater than 55');\n        }\n        data = input.slice(llength, length + llength);\n        if (data.length < length) {\n            throw new Error('invalid RLP: not enough bytes for string');\n        }\n        return {\n            data: data,\n            remainder: input.slice(length + llength),\n        };\n    }\n    else if (firstByte <= 0xf7) {\n        length = firstByte - 0xbf;\n        innerRemainder = input.slice(1, length);\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(length),\n        };\n    }\n    else {\n        llength = firstByte - 0xf6;\n        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);\n        const totalLength = llength + length;\n        if (totalLength > input.length) {\n            throw new Error('invalid rlp: total length is larger than the data');\n        }\n        innerRemainder = input.slice(llength, totalLength);\n        if (innerRemainder.length === 0) {\n            throw new Error('invalid rlp, List has a invalid length');\n        }\n        while (innerRemainder.length) {\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(totalLength),\n        };\n    }\n}\nfunction isHexPrefixed(str) {\n    return str.slice(0, 2) === '0x';\n}\nexports.isHexPrefixed = isHexPrefixed;\nfunction stripHexPrefix(str) {\n    return isHexPrefixed(str) ? str.slice(2) : str;\n}\nexports.stripHexPrefix = stripHexPrefix;\nfunction intToHex(integer) {\n    if (integer < 0) {\n        throw new Error('Invalid integer as argument, must be unsigned!');\n    }\n    const hex = integer.toString(16);\n    return hex.length % 2 ? `0${hex}` : hex;\n}\nfunction padToEven(a) {\n    return a.length % 2 ? `0${a}` : a;\n}\nfunction intToBuffer(integer) {\n    const hex = intToHex(integer);\n    return Buffer.from(hex, 'hex');\n}\nfunction toBuffer(v) {\n    if (!Buffer.isBuffer(v)) {\n        if (typeof v === 'string') {\n            if (isHexPrefixed(v)) {\n                return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');\n            }\n            else {\n                return Buffer.from(v);\n            }\n        }\n        else if (typeof v === 'number' || typeof v === 'bigint') {\n            if (!v) {\n                return Buffer.from([]);\n            }\n            else {\n                return intToBuffer(v);\n            }\n        }\n        else if (v === null || v === undefined) {\n            return Buffer.from([]);\n        }\n        else if (v instanceof Uint8Array) {\n            return Buffer.from(v);\n        }\n        else if (bn_js_1.default.isBN(v)) {\n            return Buffer.from(v.toArray());\n        }\n        else {\n            throw new Error('invalid type');\n        }\n    }\n    return v;\n}\n//# sourceMappingURL=rlp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9ybHAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUNwRyxnQ0FBZ0MsbUJBQU8sQ0FBQyxtREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS9ybHAuanM/M2U1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBleHBvcnRzLmlzSGV4UHJlZml4ZWQgPSBleHBvcnRzLmdldExlbmd0aCA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGVuY29kZShpbnB1dFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5jb25jYXQob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2VuY29kZUxlbmd0aChidWYubGVuZ3RoLCAxOTIpLCBidWZdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGlucHV0QnVmID0gdG9CdWZmZXIoaW5wdXQpO1xuICAgICAgICByZXR1cm4gaW5wdXRCdWYubGVuZ3RoID09PSAxICYmIGlucHV0QnVmWzBdIDwgMTI4XG4gICAgICAgICAgICA/IGlucHV0QnVmXG4gICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQoW2VuY29kZUxlbmd0aChpbnB1dEJ1Zi5sZW5ndGgsIDEyOCksIGlucHV0QnVmXSk7XG4gICAgfVxufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5mdW5jdGlvbiBzYWZlUGFyc2VJbnQodiwgYmFzZSkge1xuICAgIGlmICh2WzBdID09PSAnMCcgJiYgdlsxXSA9PT0gJzAnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4dHJhIHplcm9zJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2LCBiYXNlKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUxlbmd0aChsZW4sIG9mZnNldCkge1xuICAgIGlmIChsZW4gPCA1Nikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW2xlbiArIG9mZnNldF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgaGV4TGVuZ3RoID0gaW50VG9IZXgobGVuKTtcbiAgICAgICAgY29uc3QgbExlbmd0aCA9IGhleExlbmd0aC5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBpbnRUb0hleChvZmZzZXQgKyA1NSArIGxMZW5ndGgpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZmlyc3RCeXRlICsgaGV4TGVuZ3RoLCAnaGV4Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBzdHJlYW0gPSBmYWxzZSkge1xuICAgIGlmICghaW5wdXQgfHwgaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShbXSk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0QnVmZmVyID0gdG9CdWZmZXIoaW5wdXQpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGlucHV0QnVmZmVyKTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH1cbiAgICBpZiAoZGVjb2RlZC5yZW1haW5kZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZW1haW5kZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQuZGF0YTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZ2V0TGVuZ3RoKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRCdWZmZXIgPSB0b0J1ZmZlcihpbnB1dCk7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gaW5wdXRCdWZmZXJbMF07XG4gICAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBpbnB1dEJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgICAgIHJldHVybiBmaXJzdEJ5dGUgLSAweDdmO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xuICAgICAgICByZXR1cm4gZmlyc3RCeXRlIC0gMHhiNjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4YmY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhmNjtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0QnVmZmVyLnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICByZXR1cm4gbGxlbmd0aCArIGxlbmd0aDtcbiAgICB9XG59XG5leHBvcnRzLmdldExlbmd0aCA9IGdldExlbmd0aDtcbmZ1bmN0aW9uIF9kZWNvZGUoaW5wdXQpIHtcbiAgICBsZXQgbGVuZ3RoLCBsbGVuZ3RoLCBkYXRhLCBpbm5lclJlbWFpbmRlciwgZDtcbiAgICBjb25zdCBkZWNvZGVkID0gW107XG4gICAgY29uc3QgZmlyc3RCeXRlID0gaW5wdXRbMF07XG4gICAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5zbGljZSgwLCAxKSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UoMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4N2Y7XG4gICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDB4ODApIHtcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gaW5wdXQuc2xpY2UoMSwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSAyICYmIGRhdGFbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmxwIGVuY29kaW5nOiBieXRlIG11c3QgYmUgbGVzcyAweDgwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XG4gICAgICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGI2O1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIC0gMSA8IGxsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IG5vdCBlbm91Z2ggYnl0ZXMgZm9yIHN0cmluZyBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBzYWZlUGFyc2VJbnQoaW5wdXQuc2xpY2UoMSwgbGxlbmd0aCkudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgICAgIGlmIChsZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4cGVjdGVkIHN0cmluZyBsZW5ndGggdG8gYmUgZ3JlYXRlciB0aGFuIDU1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKGxsZW5ndGgsIGxlbmd0aCArIGxsZW5ndGgpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IG5vdCBlbm91Z2ggYnl0ZXMgZm9yIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGggKyBsbGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiZjtcbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBpbnB1dC5zbGljZSgxLCBsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhmNjtcbiAgICAgICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IGxsZW5ndGggKyBsZW5ndGg7XG4gICAgICAgIGlmICh0b3RhbExlbmd0aCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJscDogdG90YWwgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIHRoZSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBpbnB1dC5zbGljZShsbGVuZ3RoLCB0b3RhbExlbmd0aCk7XG4gICAgICAgIGlmIChpbm5lclJlbWFpbmRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBybHAsIExpc3QgaGFzIGEgaW52YWxpZCBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKHRvdGFsTGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgMikgPT09ICcweCc7XG59XG5leHBvcnRzLmlzSGV4UHJlZml4ZWQgPSBpc0hleFByZWZpeGVkO1xuZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gICAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbmV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBzdHJpcEhleFByZWZpeDtcbmZ1bmN0aW9uIGludFRvSGV4KGludGVnZXIpIHtcbiAgICBpZiAoaW50ZWdlciA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgYXMgYXJndW1lbnQsIG11c3QgYmUgdW5zaWduZWQhJyk7XG4gICAgfVxuICAgIGNvbnN0IGhleCA9IGludGVnZXIudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmZ1bmN0aW9uIHBhZFRvRXZlbihhKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoICUgMiA/IGAwJHthfWAgOiBhO1xufVxuZnVuY3Rpb24gaW50VG9CdWZmZXIoaW50ZWdlcikge1xuICAgIGNvbnN0IGhleCA9IGludFRvSGV4KGludGVnZXIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbn1cbmZ1bmN0aW9uIHRvQnVmZmVyKHYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhQcmVmaXhlZCh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRUb0J1ZmZlcih2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJuX2pzXzEuZGVmYXVsdC5pc0JOKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/rlp.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/util.js':
    /*!***********************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/abi/util.js ***!
  \***********************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.unpadBuffer = exports.stripZeros = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.assertIsBuffer = void 0;\nconst assertIsBuffer = function (input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\nconst zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\nconst setLength = function (msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    }\n    else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\nconst setLengthLeft = function (msg, length) {\n    if (!Buffer.isBuffer(msg)) {\n        msg = Buffer.from(msg);\n    }\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\nconst setLengthRight = function (msg, length) {\n    if (!Buffer.isBuffer(msg)) {\n        msg = Buffer.from(msg);\n    }\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\nconst stripZeros = function (a) {\n    let first = a[0];\n    while (a.length > 0 && first.toString() === \'0\') {\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\nexports.stripZeros = stripZeros;\nconst unpadBuffer = function (a) {\n    if (!Buffer.isBuffer(a)) {\n        a = Buffer.from(a);\n    }\n    return (0, exports.stripZeros)(a);\n};\nexports.unpadBuffer = unpadBuffer;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2FiaS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGFBQWEsR0FBRyxzQkFBc0I7QUFDbEk7QUFDQTtBQUNBLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvYWJpL3V0aWwuanM/OTkzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5wYWRCdWZmZXIgPSBleHBvcnRzLnN0cmlwWmVyb3MgPSBleHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy56ZXJvcyA9IGV4cG9ydHMuYXNzZXJ0SXNCdWZmZXIgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRJc0J1ZmZlciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBCdWZmZXIgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc0J1ZmZlciA9IGFzc2VydElzQnVmZmVyO1xuY29uc3QgemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcbmV4cG9ydHMuemVyb3MgPSB6ZXJvcztcbmNvbnN0IHNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgICBjb25zdCBidWYgPSAoMCwgZXhwb3J0cy56ZXJvcykobGVuZ3RoKTtcbiAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICAgIH1cbn07XG5jb25zdCBzZXRMZW5ndGhMZWZ0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobXNnKSkge1xuICAgICAgICBtc2cgPSBCdWZmZXIuZnJvbShtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCBmYWxzZSk7XG59O1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gc2V0TGVuZ3RoTGVmdDtcbmNvbnN0IHNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobXNnKSkge1xuICAgICAgICBtc2cgPSBCdWZmZXIuZnJvbShtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gc2V0TGVuZ3RoUmlnaHQ7XG5jb25zdCBzdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgICBsZXQgZmlyc3QgPSBhWzBdO1xuICAgIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgICAgICBmaXJzdCA9IGFbMF07XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbmV4cG9ydHMuc3RyaXBaZXJvcyA9IHN0cmlwWmVyb3M7XG5jb25zdCB1bnBhZEJ1ZmZlciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkpIHtcbiAgICAgICAgYSA9IEJ1ZmZlci5mcm9tKGEpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuc3RyaXBaZXJvcykoYSk7XG59O1xuZXhwb3J0cy51bnBhZEJ1ZmZlciA9IHVucGFkQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/util.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/base58.js':
    /*!**************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/base58.js ***!
  \**************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.base58 = exports.fromBase58 = exports.toBase58 = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@scure/base/index.js");\nObject.defineProperty(exports, "base58", ({ enumerable: true, get: function () { return base_1.base58; } }));\nfunction toBase58(data) {\n    const a = Buffer.from(data);\n    return base_1.base58.encode(Uint8Array.from(a));\n}\nexports.toBase58 = toBase58;\nfunction fromBase58(data) {\n    return base_1.base58.decode(data);\n}\nexports.fromBase58 = fromBase58;\n//# sourceMappingURL=base58.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvYmFzZTU4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0I7QUFDdEQsZUFBZSxtQkFBTyxDQUFDLCtGQUFhO0FBQ3BDLDBDQUF5QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvYmFzZS9iYXNlNTguanM/ODU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTU4ID0gZXhwb3J0cy5mcm9tQmFzZTU4ID0gZXhwb3J0cy50b0Jhc2U1OCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJhc2U1OFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV8xLmJhc2U1ODsgfSB9KTtcbmZ1bmN0aW9uIHRvQmFzZTU4KGRhdGEpIHtcbiAgICBjb25zdCBhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgcmV0dXJuIGJhc2VfMS5iYXNlNTguZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShhKSk7XG59XG5leHBvcnRzLnRvQmFzZTU4ID0gdG9CYXNlNTg7XG5mdW5jdGlvbiBmcm9tQmFzZTU4KGRhdGEpIHtcbiAgICByZXR1cm4gYmFzZV8xLmJhc2U1OC5kZWNvZGUoZGF0YSk7XG59XG5leHBvcnRzLmZyb21CYXNlNTggPSBmcm9tQmFzZTU4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTU4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/base58.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/base58Check.js':
    /*!*******************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/base58Check.js ***!
  \*******************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.fromBase58Check = exports.toBase58Check = void 0;\nconst hash_1 = __webpack_require__(/*! ./hash */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hash.js");\nconst createHash = __webpack_require__(/*! create-hash */ "(ssr)/./node_modules/create-hash/index.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@scure/base/index.js");\nfunction toBase58Check(data) {\n    const bytesCoder = (0, base_1.base58check)(hash_1.sha256);\n    return bytesCoder.encode(Buffer.from(data));\n}\nexports.toBase58Check = toBase58Check;\nfunction fromBase58Check(data) {\n    const bytesCoder = (0, base_1.base58check)(hash_1.sha256);\n    return Buffer.from(bytesCoder.decode(data));\n}\nexports.fromBase58Check = fromBase58Check;\n//# sourceMappingURL=base58Check.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvYmFzZTU4Q2hlY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcscUJBQXFCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQywwRUFBUTtBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN4QyxlQUFlLG1CQUFPLENBQUMsK0ZBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvYmFzZS9iYXNlNThDaGVjay5qcz85NzY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tQmFzZTU4Q2hlY2sgPSBleHBvcnRzLnRvQmFzZTU4Q2hlY2sgPSB2b2lkIDA7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuY29uc3QgY3JlYXRlSGFzaCA9IHJlcXVpcmUoXCJjcmVhdGUtaGFzaFwiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbmZ1bmN0aW9uIHRvQmFzZTU4Q2hlY2soZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzQ29kZXIgPSAoMCwgYmFzZV8xLmJhc2U1OGNoZWNrKShoYXNoXzEuc2hhMjU2KTtcbiAgICByZXR1cm4gYnl0ZXNDb2Rlci5lbmNvZGUoQnVmZmVyLmZyb20oZGF0YSkpO1xufVxuZXhwb3J0cy50b0Jhc2U1OENoZWNrID0gdG9CYXNlNThDaGVjaztcbmZ1bmN0aW9uIGZyb21CYXNlNThDaGVjayhkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXNDb2RlciA9ICgwLCBiYXNlXzEuYmFzZTU4Y2hlY2spKGhhc2hfMS5zaGEyNTYpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlc0NvZGVyLmRlY29kZShkYXRhKSk7XG59XG5leHBvcnRzLmZyb21CYXNlNThDaGVjayA9IGZyb21CYXNlNThDaGVjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U1OENoZWNrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/base58Check.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/base64.js':
    /*!**************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/base64.js ***!
  \**************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.fromBase64 = exports.toBase64 = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@scure/base/index.js");\nfunction toBase64(data) {\n    const a = Buffer.from(data);\n    return base_1.base64.encode(Uint8Array.from(a));\n}\nexports.toBase64 = toBase64;\nfunction fromBase64(data) {\n    return base_1.base64.decode(data);\n}\nexports.fromBase64 = fromBase64;\n//# sourceMappingURL=base64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvYmFzZTY0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGdCQUFnQjtBQUNyQyxlQUFlLG1CQUFPLENBQUMsK0ZBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvYmFzZTY0LmpzPzM4YTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21CYXNlNjQgPSBleHBvcnRzLnRvQmFzZTY0ID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuZnVuY3Rpb24gdG9CYXNlNjQoZGF0YSkge1xuICAgIGNvbnN0IGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICByZXR1cm4gYmFzZV8xLmJhc2U2NC5lbmNvZGUoVWludDhBcnJheS5mcm9tKGEpKTtcbn1cbmV4cG9ydHMudG9CYXNlNjQgPSB0b0Jhc2U2NDtcbmZ1bmN0aW9uIGZyb21CYXNlNjQoZGF0YSkge1xuICAgIHJldHVybiBiYXNlXzEuYmFzZTY0LmRlY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuZnJvbUJhc2U2NCA9IGZyb21CYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/base64.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/bech32.js':
    /*!**************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/bech32.js ***!
  \**************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.fromBech32 = exports.toBech32 = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@scure/base/index.js");\nfunction toBech32(prefix, data, limit) {\n    const a = Buffer.from(data);\n    const bit5 = base_1.bech32.toWords(Uint8Array.from(a));\n    return base_1.bech32.encode(prefix, bit5, limit);\n}\nexports.toBech32 = toBech32;\nfunction fromBech32(data, limit) {\n    const d = base_1.bech32.decode(data, limit);\n    const bit8 = base_1.bech32.fromWords(d.words);\n    return [d.prefix, Buffer.from(bit8)];\n}\nexports.fromBech32 = fromBech32;\n//# sourceMappingURL=bech32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvYmVjaDMyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGdCQUFnQjtBQUNyQyxlQUFlLG1CQUFPLENBQUMsK0ZBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvYmVjaDMyLmpzPzVmNGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21CZWNoMzIgPSBleHBvcnRzLnRvQmVjaDMyID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuZnVuY3Rpb24gdG9CZWNoMzIocHJlZml4LCBkYXRhLCBsaW1pdCkge1xuICAgIGNvbnN0IGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICBjb25zdCBiaXQ1ID0gYmFzZV8xLmJlY2gzMi50b1dvcmRzKFVpbnQ4QXJyYXkuZnJvbShhKSk7XG4gICAgcmV0dXJuIGJhc2VfMS5iZWNoMzIuZW5jb2RlKHByZWZpeCwgYml0NSwgbGltaXQpO1xufVxuZXhwb3J0cy50b0JlY2gzMiA9IHRvQmVjaDMyO1xuZnVuY3Rpb24gZnJvbUJlY2gzMihkYXRhLCBsaW1pdCkge1xuICAgIGNvbnN0IGQgPSBiYXNlXzEuYmVjaDMyLmRlY29kZShkYXRhLCBsaW1pdCk7XG4gICAgY29uc3QgYml0OCA9IGJhc2VfMS5iZWNoMzIuZnJvbVdvcmRzKGQud29yZHMpO1xuICAgIHJldHVybiBbZC5wcmVmaXgsIEJ1ZmZlci5mcm9tKGJpdDgpXTtcbn1cbmV4cG9ydHMuZnJvbUJlY2gzMiA9IGZyb21CZWNoMzI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWNoMzIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/bech32.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/bignumber-plus.js':
    /*!**********************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/bignumber-plus.js ***!
  \**********************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.string2BigNumber = exports.bigNumber2String = exports.fromBigIntHex = exports.toBigIntHex = void 0;\nconst index_1 = __webpack_require__(/*! ../index */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js");\nconst precondtion_1 = __webpack_require__(/*! ./precondtion */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/precondtion.js");\nconst toBigIntHex = (value) => {\n    let hexStr = value.integerValue().toString(16);\n    hexStr = \'0x\' + hexStr;\n    return hexStr;\n};\nexports.toBigIntHex = toBigIntHex;\nconst fromBigIntHex = (value) => {\n    (0, precondtion_1.check)(value && value.startsWith(\'0x\'), `Invalid hex string. value: ${value}`);\n    return new index_1.BigNumber(value).integerValue();\n};\nexports.fromBigIntHex = fromBigIntHex;\nconst bigNumber2String = (value, base) => {\n    return value.integerValue().toString(base);\n};\nexports.bigNumber2String = bigNumber2String;\nconst string2BigNumber = (n, base) => {\n    return new index_1.BigNumber(n, base);\n};\nexports.string2BigNumber = string2BigNumber;\n//# sourceMappingURL=bignumber-plus.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvYmlnbnVtYmVyLXBsdXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CO0FBQ2pHLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFVO0FBQ2xDLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSw0RkFBNEYsTUFBTTtBQUNsRztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvYmFzZS9iaWdudW1iZXItcGx1cy5qcz9iODhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmcyQmlnTnVtYmVyID0gZXhwb3J0cy5iaWdOdW1iZXIyU3RyaW5nID0gZXhwb3J0cy5mcm9tQmlnSW50SGV4ID0gZXhwb3J0cy50b0JpZ0ludEhleCA9IHZvaWQgMDtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vaW5kZXhcIik7XG5jb25zdCBwcmVjb25kdGlvbl8xID0gcmVxdWlyZShcIi4vcHJlY29uZHRpb25cIik7XG5jb25zdCB0b0JpZ0ludEhleCA9ICh2YWx1ZSkgPT4ge1xuICAgIGxldCBoZXhTdHIgPSB2YWx1ZS5pbnRlZ2VyVmFsdWUoKS50b1N0cmluZygxNik7XG4gICAgaGV4U3RyID0gJzB4JyArIGhleFN0cjtcbiAgICByZXR1cm4gaGV4U3RyO1xufTtcbmV4cG9ydHMudG9CaWdJbnRIZXggPSB0b0JpZ0ludEhleDtcbmNvbnN0IGZyb21CaWdJbnRIZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgcHJlY29uZHRpb25fMS5jaGVjaykodmFsdWUgJiYgdmFsdWUuc3RhcnRzV2l0aCgnMHgnKSwgYEludmFsaWQgaGV4IHN0cmluZy4gdmFsdWU6ICR7dmFsdWV9YCk7XG4gICAgcmV0dXJuIG5ldyBpbmRleF8xLkJpZ051bWJlcih2YWx1ZSkuaW50ZWdlclZhbHVlKCk7XG59O1xuZXhwb3J0cy5mcm9tQmlnSW50SGV4ID0gZnJvbUJpZ0ludEhleDtcbmNvbnN0IGJpZ051bWJlcjJTdHJpbmcgPSAodmFsdWUsIGJhc2UpID0+IHtcbiAgICByZXR1cm4gdmFsdWUuaW50ZWdlclZhbHVlKCkudG9TdHJpbmcoYmFzZSk7XG59O1xuZXhwb3J0cy5iaWdOdW1iZXIyU3RyaW5nID0gYmlnTnVtYmVyMlN0cmluZztcbmNvbnN0IHN0cmluZzJCaWdOdW1iZXIgPSAobiwgYmFzZSkgPT4ge1xuICAgIHJldHVybiBuZXcgaW5kZXhfMS5CaWdOdW1iZXIobiwgYmFzZSk7XG59O1xuZXhwb3J0cy5zdHJpbmcyQmlnTnVtYmVyID0gc3RyaW5nMkJpZ051bWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZ251bWJlci1wbHVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/bignumber-plus.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hash.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/hash.js ***!
  \************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.sha3_512 = exports.sha3_256 = exports.ripemd160 = exports.sha512 = exports.sha256 = exports.blake2 = exports.keccak256 = exports.keccak = exports.hash160 = exports.doubleSha256 = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha256.js");\nObject.defineProperty(exports, "sha256", ({ enumerable: true, get: function () { return sha256_1.sha256; } }));\nconst sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha512.js");\nObject.defineProperty(exports, "sha512", ({ enumerable: true, get: function () { return sha512_1.sha512; } }));\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/ripemd160.js");\nObject.defineProperty(exports, "ripemd160", ({ enumerable: true, get: function () { return ripemd160_1.ripemd160; } }));\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha3.js");\nObject.defineProperty(exports, "sha3_256", ({ enumerable: true, get: function () { return sha3_1.sha3_256; } }));\nObject.defineProperty(exports, "sha3_512", ({ enumerable: true, get: function () { return sha3_1.sha3_512; } }));\nconst blake2b_1 = __webpack_require__(/*! @noble/hashes/blake2b */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2b.js");\nfunction doubleSha256(data) {\n    const t = (0, sha256_1.sha256)(data);\n    return (0, sha256_1.sha256)(t);\n}\nexports.doubleSha256 = doubleSha256;\nfunction hash160(data) {\n    const t = (0, sha256_1.sha256)(data);\n    return (0, ripemd160_1.ripemd160)(t);\n}\nexports.hash160 = hash160;\nconst keccak = function (a, bits = 256) {\n    const b = Buffer.from(a);\n    switch (bits) {\n        case 224: {\n            return Buffer.from((0, sha3_1.keccak_224)(b));\n        }\n        case 256: {\n            return Buffer.from((0, sha3_1.keccak_256)(b));\n        }\n        case 384: {\n            return Buffer.from((0, sha3_1.keccak_384)(b));\n        }\n        case 512: {\n            return Buffer.from((0, sha3_1.keccak_512)(b));\n        }\n        default: {\n            throw new Error(`Invald algorithm: keccak${bits}`);\n        }\n    }\n};\nexports.keccak = keccak;\nconst keccak256 = function (a) {\n    return (0, exports.keccak)(a);\n};\nexports.keccak256 = keccak256;\nfunction blake2(data, bitLength, key) {\n    const byteLength = Math.ceil(bitLength / 8);\n    return (0, blake2b_1.blake2b)(data, { dkLen: byteLength, key: key });\n}\nexports.blake2 = blake2;\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvaGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLG9CQUFvQjtBQUN4TCxpQkFBaUIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDL0MsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLGlCQUFpQixtQkFBTyxDQUFDLDJHQUFzQjtBQUMvQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsb0JBQW9CLG1CQUFPLENBQUMsaUhBQXlCO0FBQ3JELDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxlQUFlLG1CQUFPLENBQUMsdUdBQW9CO0FBQzNDLDRDQUEyQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM5Ryw0Q0FBMkMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDOUcsa0JBQWtCLG1CQUFPLENBQUMsNkdBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMENBQTBDLDZCQUE2QjtBQUN2RTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9iYXNlL2hhc2guanM/OWY3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhM181MTIgPSBleHBvcnRzLnNoYTNfMjU2ID0gZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5ibGFrZTIgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrID0gZXhwb3J0cy5oYXNoMTYwID0gZXhwb3J0cy5kb3VibGVTaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMjU2XzEuc2hhMjU2OyB9IH0pO1xuY29uc3Qgc2hhNTEyXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGE1MTJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGE1MTJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYTUxMl8xLnNoYTUxMjsgfSB9KTtcbmNvbnN0IHJpcGVtZDE2MF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvcmlwZW1kMTYwXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmlwZW1kMTYwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByaXBlbWQxNjBfMS5yaXBlbWQxNjA7IH0gfSk7XG5jb25zdCBzaGEzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhM18yNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYTNfMS5zaGEzXzI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTNfNTEyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGEzXzEuc2hhM181MTI7IH0gfSk7XG5jb25zdCBibGFrZTJiXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCIpO1xuZnVuY3Rpb24gZG91YmxlU2hhMjU2KGRhdGEpIHtcbiAgICBjb25zdCB0ID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoZGF0YSk7XG4gICAgcmV0dXJuICgwLCBzaGEyNTZfMS5zaGEyNTYpKHQpO1xufVxuZXhwb3J0cy5kb3VibGVTaGEyNTYgPSBkb3VibGVTaGEyNTY7XG5mdW5jdGlvbiBoYXNoMTYwKGRhdGEpIHtcbiAgICBjb25zdCB0ID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoZGF0YSk7XG4gICAgcmV0dXJuICgwLCByaXBlbWQxNjBfMS5yaXBlbWQxNjApKHQpO1xufVxuZXhwb3J0cy5oYXNoMTYwID0gaGFzaDE2MDtcbmNvbnN0IGtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzID0gMjU2KSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKGEpO1xuICAgIHN3aXRjaCAoYml0cykge1xuICAgICAgICBjYXNlIDIyNDoge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBzaGEzXzEua2VjY2FrXzIyNCkoYikpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjU2OiB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHNoYTNfMS5rZWNjYWtfMjU2KShiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzODQ6IHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgc2hhM18xLmtlY2Nha18zODQpKGIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDUxMjoge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBzaGEzXzEua2VjY2FrXzUxMikoYikpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxkIGFsZ29yaXRobToga2VjY2FrJHtiaXRzfWApO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMua2VjY2FrID0ga2VjY2FrO1xuY29uc3Qga2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKShhKTtcbn07XG5leHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1NjtcbmZ1bmN0aW9uIGJsYWtlMihkYXRhLCBiaXRMZW5ndGgsIGtleSkge1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuICgwLCBibGFrZTJiXzEuYmxha2UyYikoZGF0YSwgeyBka0xlbjogYnl0ZUxlbmd0aCwga2V5OiBrZXkgfSk7XG59XG5leHBvcnRzLmJsYWtlMiA9IGJsYWtlMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hash.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/helper.js':
    /*!**************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/helper.js ***!
  \**************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.validateHexString = exports.isHexString = void 0;\nfunction isHexString(value, length) {\n    if (!value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    return !(length && value.length !== 2 + 2 * length);\n}\nexports.isHexString = isHexString;\nfunction validateHexString(value) {\n    if (!value) {\n        return false;\n    }\n    const hexStr = value.toLowerCase().startsWith("0x") ? value.substring(2).toLowerCase() : value.toLowerCase();\n    if (hexStr.length === 0 || hexStr.length % 2 !== 0) {\n        return false;\n    }\n    if (!hexStr.match(/^[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    return true;\n}\nexports.validateHexString = validateHexString;\n//# sourceMappingURL=helper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvaGVscGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvYmFzZS9oZWxwZXIuanM/OGIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVIZXhTdHJpbmcgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICghdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbmZ1bmN0aW9uIHZhbGlkYXRlSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhleFN0ciA9IHZhbHVlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcIjB4XCIpID8gdmFsdWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChoZXhTdHIubGVuZ3RoID09PSAwIHx8IGhleFN0ci5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFoZXhTdHIubWF0Y2goL15bMC05QS1GYS1mXSokLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMudmFsaWRhdGVIZXhTdHJpbmcgPSB2YWxpZGF0ZUhleFN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/helper.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hex.js':
    /*!***********************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/hex.js ***!
  \***********************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.isHexPrefixed = exports.stripHexPrefix = exports.fromHex = exports.toHex = void 0;\nfunction toHex(data, addPrefix = false) {\n    const buffer = Buffer.from(data);\n    return addPrefix ? "0x" + buffer.toString("hex") : buffer.toString("hex");\n}\nexports.toHex = toHex;\nfunction fromHex(data) {\n    if (data.startsWith("0x")) {\n        data = data.substring(2);\n    }\n    return Buffer.from(data, "hex");\n}\nexports.fromHex = fromHex;\nfunction stripHexPrefix(hex) {\n    if (hex.startsWith("0x")) {\n        return hex.substring(2);\n    }\n    return hex;\n}\nexports.stripHexPrefix = stripHexPrefix;\nfunction isHexPrefixed(hex) {\n    return hex.startsWith("0x");\n}\nexports.isHexPrefixed = isHexPrefixed;\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvaGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLGVBQWUsR0FBRyxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvaGV4LmpzPzc5ODciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSGV4UHJlZml4ZWQgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gZXhwb3J0cy5mcm9tSGV4ID0gZXhwb3J0cy50b0hleCA9IHZvaWQgMDtcbmZ1bmN0aW9uIHRvSGV4KGRhdGEsIGFkZFByZWZpeCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgcmV0dXJuIGFkZFByZWZpeCA/IFwiMHhcIiArIGJ1ZmZlci50b1N0cmluZyhcImhleFwiKSA6IGJ1ZmZlci50b1N0cmluZyhcImhleFwiKTtcbn1cbmV4cG9ydHMudG9IZXggPSB0b0hleDtcbmZ1bmN0aW9uIGZyb21IZXgoZGF0YSkge1xuICAgIGlmIChkYXRhLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICBkYXRhID0gZGF0YS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhLCBcImhleFwiKTtcbn1cbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5mdW5jdGlvbiBzdHJpcEhleFByZWZpeChoZXgpIHtcbiAgICBpZiAoaGV4LnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICByZXR1cm4gaGV4LnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBzdHJpcEhleFByZWZpeDtcbmZ1bmN0aW9uIGlzSGV4UHJlZml4ZWQoaGV4KSB7XG4gICAgcmV0dXJuIGhleC5zdGFydHNXaXRoKFwiMHhcIik7XG59XG5leHBvcnRzLmlzSGV4UHJlZml4ZWQgPSBpc0hleFByZWZpeGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hex.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hmac.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/hmac.js ***!
  \************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.hmacSHA512 = exports.hmacSHA256 = void 0;\nconst hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/hmac.js");\nconst hash_1 = __webpack_require__(/*! ./hash */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hash.js");\nfunction hmacSHA256(key, buffer) {\n    return Buffer.from((0, hmac_1.hmac)(hash_1.sha256, key, buffer));\n}\nexports.hmacSHA256 = hmacSHA256;\nfunction hmacSHA512(key, buffer) {\n    return Buffer.from((0, hmac_1.hmac)(hash_1.sha512, key, buffer));\n}\nexports.hmacSHA512 = hmacSHA512;\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLHVHQUFvQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsMEVBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9iYXNlL2htYWMuanM/YjUxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaG1hY1NIQTUxMiA9IGV4cG9ydHMuaG1hY1NIQTI1NiA9IHZvaWQgMDtcbmNvbnN0IGhtYWNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2htYWNcIik7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuZnVuY3Rpb24gaG1hY1NIQTI1NihrZXksIGJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaG1hY18xLmhtYWMpKGhhc2hfMS5zaGEyNTYsIGtleSwgYnVmZmVyKSk7XG59XG5leHBvcnRzLmhtYWNTSEEyNTYgPSBobWFjU0hBMjU2O1xuZnVuY3Rpb24gaG1hY1NIQTUxMihrZXksIGJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaG1hY18xLmhtYWMpKGhhc2hfMS5zaGE1MTIsIGtleSwgYnVmZmVyKSk7XG59XG5leHBvcnRzLmhtYWNTSEE1MTIgPSBobWFjU0hBNTEyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hmac.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/index.js':
    /*!*************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/index.js ***!
  \*************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.randomBytes = exports.concatBytes = exports.reverseBuffer = exports.md5 = exports.rlp = void 0;\n__exportStar(__webpack_require__(/*! ./base58 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/base58.js"), exports);\n__exportStar(__webpack_require__(/*! ./base58Check */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/base58Check.js"), exports);\n__exportStar(__webpack_require__(/*! ./bech32 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/bech32.js"), exports);\n__exportStar(__webpack_require__(/*! ./hex */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hex.js"), exports);\n__exportStar(__webpack_require__(/*! ./base64 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/base64.js"), exports);\n__exportStar(__webpack_require__(/*! ./hash */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hash.js"), exports);\n__exportStar(__webpack_require__(/*! ./hmac */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hmac.js"), exports);\n__exportStar(__webpack_require__(/*! ./utf8 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/utf8.js"), exports);\n__exportStar(__webpack_require__(/*! ./bignumber-plus */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/bignumber-plus.js"), exports);\n__exportStar(__webpack_require__(/*! ./precondtion */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/precondtion.js"), exports);\nexports.rlp = __importStar(__webpack_require__(/*! ../abi/rlp */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/rlp.js"));\n__exportStar(__webpack_require__(/*! ./helper */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/helper.js"), exports);\nexports.md5 = __importStar(__webpack_require__(/*! ./md5 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/md5.js"));\n__exportStar(__webpack_require__(/*! @scure/base */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@scure/base/index.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/sha256 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha256.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/hmac */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/hmac.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/ripemd160 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/ripemd160.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/sha512 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha512.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/sha3 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha3.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/blake2b */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2b.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/blake2s */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2s.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/pbkdf2 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/pbkdf2.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/scrypt */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/scrypt.js"), exports);\n__exportStar(__webpack_require__(/*! @noble/hashes/blake3 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake3.js"), exports);\nconst utils = __importStar(__webpack_require__(/*! @noble/hashes/utils */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js"));\nconst _randomBytes = __webpack_require__(/*! randombytes */ "(ssr)/./node_modules/randombytes/index.js");\nfunction reverseBuffer(buffer) {\n    if (buffer.length < 1)\n        return buffer;\n    let j = buffer.length - 1;\n    let tmp = 0;\n    for (let i = 0; i < buffer.length / 2; i++) {\n        tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n        j--;\n    }\n    return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction concatBytes(b1, b2) {\n    return utils.concatBytes(Uint8Array.from(b1), Uint8Array.from(b2));\n}\nexports.concatBytes = concatBytes;\nfunction randomBytes(length) {\n    return _randomBytes(length);\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLFdBQVcsR0FBRyxXQUFXO0FBQzdGLGFBQWEsbUJBQU8sQ0FBQyw4RUFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsd0ZBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDhFQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyx3RUFBTztBQUM1QixhQUFhLG1CQUFPLENBQUMsOEVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLDBFQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQywwRUFBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMsMEVBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDhGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsd0ZBQWU7QUFDcEMsV0FBVyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBWTtBQUMvQyxhQUFhLG1CQUFPLENBQUMsOEVBQVU7QUFDL0IsV0FBVyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBTztBQUMxQyxhQUFhLG1CQUFPLENBQUMsK0ZBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDJHQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsdUdBQW9CO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxpSEFBeUI7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLDJHQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsdUdBQW9CO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyw2R0FBdUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLDZHQUF1QjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDJHQUFzQjtBQUMzQywyQkFBMkIsbUJBQU8sQ0FBQyx5R0FBcUI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMsOERBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9iYXNlL2luZGV4LmpzPzA4MmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMucmV2ZXJzZUJ1ZmZlciA9IGV4cG9ydHMubWQ1ID0gZXhwb3J0cy5ybHAgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZTU4XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlNThDaGVja1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmVjaDMyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZXhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2U2NFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG1hY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXRmOFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmlnbnVtYmVyLXBsdXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ByZWNvbmR0aW9uXCIpLCBleHBvcnRzKTtcbmV4cG9ydHMucmxwID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9hYmkvcmxwXCIpKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJcIiksIGV4cG9ydHMpO1xuZXhwb3J0cy5tZDUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbWQ1XCIpKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiQHNjdXJlL2Jhc2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIkBub2JsZS9oYXNoZXMvaG1hY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIkBub2JsZS9oYXNoZXMvcmlwZW1kMTYwXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGE1MTJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2JsYWtlMmJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2JsYWtlMnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3Bia2RmMlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2NyeXB0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9ibGFrZTNcIiksIGV4cG9ydHMpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIikpO1xuY29uc3QgX3JhbmRvbUJ5dGVzID0gcmVxdWlyZShcInJhbmRvbWJ5dGVzXCIpO1xuZnVuY3Rpb24gcmV2ZXJzZUJ1ZmZlcihidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDEpXG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgbGV0IGogPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgICBsZXQgdG1wID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdG1wID0gYnVmZmVyW2ldO1xuICAgICAgICBidWZmZXJbaV0gPSBidWZmZXJbal07XG4gICAgICAgIGJ1ZmZlcltqXSA9IHRtcDtcbiAgICAgICAgai0tO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5yZXZlcnNlQnVmZmVyID0gcmV2ZXJzZUJ1ZmZlcjtcbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKGIxLCBiMikge1xuICAgIHJldHVybiB1dGlscy5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oYjEpLCBVaW50OEFycmF5LmZyb20oYjIpKTtcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGxlbmd0aCkge1xuICAgIHJldHVybiBfcmFuZG9tQnl0ZXMobGVuZ3RoKTtcbn1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/md5.js':
    /*!***********************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/md5.js ***!
  \***********************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = void 0;\nfunction encode(inputString) {\n    var hc = '0123456789abcdef';\n    function rh(n) {\n        var j, s = '';\n        for (j = 0; j <= 3; j++)\n            s += hc.charAt((n >> (j * 8 + 4)) & 0x0f) + hc.charAt((n >> (j * 8)) & 0x0f);\n        return s;\n    }\n    function ad(x, y) {\n        var l = (x & 0xffff) + (y & 0xffff);\n        var m = (x >> 16) + (y >> 16) + (l >> 16);\n        return (m << 16) | (l & 0xffff);\n    }\n    function rl(n, c) {\n        return (n << c) | (n >>> (32 - c));\n    }\n    function cm(q, a, b, x, s, t) {\n        return ad(rl(ad(ad(a, q), ad(x, t)), s), b);\n    }\n    function ff(a, b, c, d, x, s, t) {\n        return cm((b & c) | (~b & d), a, b, x, s, t);\n    }\n    function gg(a, b, c, d, x, s, t) {\n        return cm((b & d) | (c & ~d), a, b, x, s, t);\n    }\n    function hh(a, b, c, d, x, s, t) {\n        return cm(b ^ c ^ d, a, b, x, s, t);\n    }\n    function ii(a, b, c, d, x, s, t) {\n        return cm(c ^ (b | ~d), a, b, x, s, t);\n    }\n    function sb(x) {\n        var i;\n        var nblk = ((x.length + 8) >> 6) + 1;\n        var blks = new Array(nblk * 16);\n        for (i = 0; i < nblk * 16; i++)\n            blks[i] = 0;\n        for (i = 0; i < x.length; i++)\n            blks[i >> 2] |= x.charCodeAt(i) << ((i % 4) * 8);\n        blks[i >> 2] |= 0x80 << ((i % 4) * 8);\n        blks[nblk * 16 - 2] = x.length * 8;\n        return blks;\n    }\n    var i, x = sb('' + inputString), a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, olda, oldb, oldc, oldd;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = ff(a, b, c, d, x[i + 0], 7, -680876936);\n        d = ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = gg(b, c, d, a, x[i + 0], 20, -373897302);\n        a = gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = hh(d, a, b, c, x[i + 0], 11, -358537222);\n        c = hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = ii(a, b, c, d, x[i + 0], 6, -198630844);\n        d = ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = ad(a, olda);\n        b = ad(b, oldb);\n        c = ad(c, oldc);\n        d = ad(d, oldd);\n    }\n    return rh(a) + rh(b) + rh(c) + rh(d);\n}\nexports.encode = encode;\n//# sourceMappingURL=md5.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvbWQ1LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvbWQ1LmpzPzY1Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVuY29kZShpbnB1dFN0cmluZykge1xuICAgIHZhciBoYyA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcbiAgICBmdW5jdGlvbiByaChuKSB7XG4gICAgICAgIHZhciBqLCBzID0gJyc7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPD0gMzsgaisrKVxuICAgICAgICAgICAgcyArPSBoYy5jaGFyQXQoKG4gPj4gKGogKiA4ICsgNCkpICYgMHgwZikgKyBoYy5jaGFyQXQoKG4gPj4gKGogKiA4KSkgJiAweDBmKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkKHgsIHkpIHtcbiAgICAgICAgdmFyIGwgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gICAgICAgIHZhciBtID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGwgPj4gMTYpO1xuICAgICAgICByZXR1cm4gKG0gPDwgMTYpIHwgKGwgJiAweGZmZmYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBybChuLCBjKSB7XG4gICAgICAgIHJldHVybiAobiA8PCBjKSB8IChuID4+PiAoMzIgLSBjKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNtKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIGFkKHJsKGFkKGFkKGEsIHEpLCBhZCh4LCB0KSksIHMpLCBiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gY20oKGIgJiBjKSB8ICh+YiAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gY20oKGIgJiBkKSB8IChjICYgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gY20oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gY20oYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2IoeCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG5ibGsgPSAoKHgubGVuZ3RoICsgOCkgPj4gNikgKyAxO1xuICAgICAgICB2YXIgYmxrcyA9IG5ldyBBcnJheShuYmxrICogMTYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmJsayAqIDE2OyBpKyspXG4gICAgICAgICAgICBibGtzW2ldID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBibGtzW2kgPj4gMl0gfD0geC5jaGFyQ29kZUF0KGkpIDw8ICgoaSAlIDQpICogOCk7XG4gICAgICAgIGJsa3NbaSA+PiAyXSB8PSAweDgwIDw8ICgoaSAlIDQpICogOCk7XG4gICAgICAgIGJsa3NbbmJsayAqIDE2IC0gMl0gPSB4Lmxlbmd0aCAqIDg7XG4gICAgICAgIHJldHVybiBibGtzO1xuICAgIH1cbiAgICB2YXIgaSwgeCA9IHNiKCcnICsgaW5wdXRTdHJpbmcpLCBhID0gMTczMjU4NDE5MywgYiA9IC0yNzE3MzM4NzksIGMgPSAtMTczMjU4NDE5NCwgZCA9IDI3MTczMzg3OCwgb2xkYSwgb2xkYiwgb2xkYywgb2xkZDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgb2xkYSA9IGE7XG4gICAgICAgIG9sZGIgPSBiO1xuICAgICAgICBvbGRjID0gYztcbiAgICAgICAgb2xkZCA9IGQ7XG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCB4W2kgKyAwXSwgNywgLTY4MDg3NjkzNik7XG4gICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpO1xuICAgICAgICBiID0gZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpO1xuICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNik7XG4gICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCB4W2kgKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIHhbaSArIDE0XSwgOSwgLTEwMTk4MDM2OTApO1xuICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIHhbaSArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcbiAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywgeFtpICsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KTtcbiAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKTtcbiAgICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCB4W2kgKyAwXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgICAgICBhID0gaWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSk7XG4gICAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KTtcbiAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KTtcbiAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG4gICAgICAgIGEgPSBhZChhLCBvbGRhKTtcbiAgICAgICAgYiA9IGFkKGIsIG9sZGIpO1xuICAgICAgICBjID0gYWQoYywgb2xkYyk7XG4gICAgICAgIGQgPSBhZChkLCBvbGRkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJoKGEpICsgcmgoYikgKyByaChjKSArIHJoKGQpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZDUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/md5.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/precondtion.js':
    /*!*******************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/precondtion.js ***!
  \*******************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkIsUndefined = exports.checkIsDefined = exports.check = void 0;\nconst check = (statement, orError) => {\n    if (!statement) {\n        orError = orError ? orError : 'Invalid statement';\n        orError = orError instanceof Error ? orError : new Error(orError);\n        throw orError;\n    }\n};\nexports.check = check;\nconst checkIsDefined = (something, orError) => {\n    check(typeof something !== 'undefined', orError || 'Expect defined but actually undefined');\n    return something;\n};\nexports.checkIsDefined = checkIsDefined;\nconst checkIsUndefined = (something, orError) => {\n    check(typeof something === 'undefined', orError || `Expect undefined but actually ${something}`);\n};\nexports.checkIsUndefined = checkIsUndefined;\n//# sourceMappingURL=precondtion.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvcHJlY29uZHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdGQUF3RixVQUFVO0FBQ2xHO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvcHJlY29uZHRpb24uanM/OTU5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tJc1VuZGVmaW5lZCA9IGV4cG9ydHMuY2hlY2tJc0RlZmluZWQgPSBleHBvcnRzLmNoZWNrID0gdm9pZCAwO1xuY29uc3QgY2hlY2sgPSAoc3RhdGVtZW50LCBvckVycm9yKSA9PiB7XG4gICAgaWYgKCFzdGF0ZW1lbnQpIHtcbiAgICAgICAgb3JFcnJvciA9IG9yRXJyb3IgPyBvckVycm9yIDogJ0ludmFsaWQgc3RhdGVtZW50JztcbiAgICAgICAgb3JFcnJvciA9IG9yRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IG9yRXJyb3IgOiBuZXcgRXJyb3Iob3JFcnJvcik7XG4gICAgICAgIHRocm93IG9yRXJyb3I7XG4gICAgfVxufTtcbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmNvbnN0IGNoZWNrSXNEZWZpbmVkID0gKHNvbWV0aGluZywgb3JFcnJvcikgPT4ge1xuICAgIGNoZWNrKHR5cGVvZiBzb21ldGhpbmcgIT09ICd1bmRlZmluZWQnLCBvckVycm9yIHx8ICdFeHBlY3QgZGVmaW5lZCBidXQgYWN0dWFsbHkgdW5kZWZpbmVkJyk7XG4gICAgcmV0dXJuIHNvbWV0aGluZztcbn07XG5leHBvcnRzLmNoZWNrSXNEZWZpbmVkID0gY2hlY2tJc0RlZmluZWQ7XG5jb25zdCBjaGVja0lzVW5kZWZpbmVkID0gKHNvbWV0aGluZywgb3JFcnJvcikgPT4ge1xuICAgIGNoZWNrKHR5cGVvZiBzb21ldGhpbmcgPT09ICd1bmRlZmluZWQnLCBvckVycm9yIHx8IGBFeHBlY3QgdW5kZWZpbmVkIGJ1dCBhY3R1YWxseSAke3NvbWV0aGluZ31gKTtcbn07XG5leHBvcnRzLmNoZWNrSXNVbmRlZmluZWQgPSBjaGVja0lzVW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlY29uZHRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/precondtion.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/utf8.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/base/utf8.js ***!
  \************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.fromUtf8 = exports.toUtf8 = void 0;\nfunction toUtf8(str) {\n    return new TextEncoder().encode(str);\n}\nexports.toUtf8 = toUtf8;\nfunction fromUtf8(data) {\n    return new TextDecoder("utf-8", { fatal: true }).decode(data);\n}\nexports.fromUtf8 = fromUtf8;\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvdXRmOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2Jhc2UvdXRmOC5qcz80ODQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tVXRmOCA9IGV4cG9ydHMudG9VdGY4ID0gdm9pZCAwO1xuZnVuY3Rpb24gdG9VdGY4KHN0cikge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydHMudG9VdGY4ID0gdG9VdGY4O1xuZnVuY3Rpb24gZnJvbVV0ZjgoZGF0YSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7IGZhdGFsOiB0cnVlIH0pLmRlY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuZnJvbVV0ZjggPSBmcm9tVXRmODtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/utf8.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip32/api.js':
    /*!************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/bip32/api.js ***!
  \************************************************************/
    /***/ (module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst elliptic_1 = __webpack_require__(/*! ../elliptic */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/index.js\");\nconst secp256k1 = new elliptic_1.ec(\"secp256k1\");\nconst curve = secp256k1.curve;\nconst BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nfunction loadCompressedPublicKey(first, xbuf) {\n    let x = new BN(xbuf);\n    if (x.cmp(curve.p) >= 0)\n        return null;\n    x = x.toRed(curve.red);\n    let y = x.redSqr().redIMul(x).redIAdd(curve.b).redSqrt();\n    if ((first === 0x03) !== y.isOdd())\n        y = y.redNeg();\n    return secp256k1.keyPair({ pub: { x: x, y: y } });\n}\nfunction loadUncompressedPublicKey(first, xbuf, ybuf) {\n    let x = new BN(xbuf);\n    let y = new BN(ybuf);\n    if (x.cmp(curve.p) >= 0 || y.cmp(curve.p) >= 0)\n        return null;\n    x = x.toRed(curve.red);\n    y = y.toRed(curve.red);\n    if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07))\n        return null;\n    const x3 = x.redSqr().redIMul(x);\n    if (!y.redSqr().redISub(x3.redIAdd(curve.b)).isZero())\n        return null;\n    return secp256k1.keyPair({ pub: { x: x, y: y } });\n}\nfunction loadPublicKey(pubkey) {\n    const first = pubkey[0];\n    switch (first) {\n        case 0x02:\n        case 0x03:\n            if (pubkey.length !== 33)\n                return null;\n            return loadCompressedPublicKey(first, pubkey.subarray(1, 33));\n        case 0x04:\n        case 0x06:\n        case 0x07:\n            if (pubkey.length !== 65)\n                return null;\n            return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));\n        default:\n            return null;\n    }\n}\nmodule.exports = {\n    contextRandomize() {\n        return 0;\n    },\n    privateKeyVerify(seckey) {\n        const bn = new BN(seckey);\n        return bn.cmp(curve.n) < 0 && !bn.isZero();\n    },\n    privateKeyNegate(seckey) {\n        const bn = new BN(seckey);\n        return Buffer.from(curve.n.sub(bn).umod(curve.n).toArray('be', 32));\n    },\n    privateKeyTweakAdd(seckey, tweak) {\n        const bn = new BN(tweak);\n        if (bn.cmp(curve.n) >= 0)\n            return null;\n        bn.iadd(new BN(seckey));\n        if (bn.cmp(curve.n) >= 0)\n            bn.isub(curve.n);\n        if (bn.isZero())\n            return null;\n        return Buffer.from(bn.toArray('be', 32));\n    },\n    privateKeyTweakMul(seckey, tweak) {\n        let bn = new BN(tweak);\n        if (bn.cmp(curve.n) >= 0 || bn.isZero())\n            return 1;\n        bn.imul(new BN(seckey));\n        if (bn.cmp(curve.n) >= 0)\n            bn = bn.umod(curve.n);\n        return Buffer.from(bn.toArray('be', 32));\n    },\n    publicKeyVerify(pubkey) {\n        const pair = loadPublicKey(pubkey);\n        if (pair == null) {\n            return null;\n        }\n        return pair.validate().result;\n    },\n    publicKeyCreate(seckey, compress) {\n        const bn = new BN(seckey);\n        if (bn.cmp(curve.n) >= 0 || bn.isZero())\n            return null;\n        const point = secp256k1.keyFromPrivate(seckey, null).getPublic();\n        return Buffer.from(point.encode(null, compress));\n    },\n    publicKeyConvert(pubKey, compress) {\n        const pair = loadPublicKey(pubKey);\n        const point = pair.getPublic();\n        return Buffer.from(point.encode(null, compress));\n    },\n    publicKeyNegate(pubKey, compress) {\n        const pair = loadPublicKey(pubKey);\n        if (pair === null)\n            return 1;\n        const point = pair.getPublic();\n        point.y = point.y.redNeg();\n        return Buffer.from(point.encode(null, compress));\n    },\n    publicKeyCombine(pubKeys, compress) {\n        const pairs = new Array(pubKeys.length);\n        for (let i = 0; i < pubKeys.length; ++i) {\n            pairs[i] = loadPublicKey(pubKeys[i]);\n            if (pairs[i] === null)\n                return null;\n        }\n        let point = pairs[0].getPublic();\n        for (let i = 1; i < pairs.length; ++i)\n            point = point.add(pairs[i].pub);\n        if (point.isInfinity())\n            return null;\n        return Buffer.from(point.encode(null, compress));\n    },\n    publicKeyTweakAdd(pubKeys, tweak, compress) {\n        const pair = loadPublicKey(pubKeys);\n        if (pair === null)\n            return null;\n        const t = new BN(tweak);\n        if (t.cmp(curve.n) >= 0)\n            return null;\n        const point = pair.getPublic().add(curve.g.mul(tweak));\n        if (point.isInfinity())\n            return null;\n        return Buffer.from(point.encode(null, compress));\n    },\n    publicKeyTweakMul(pubkey, tweak, compress) {\n        const pair = loadPublicKey(pubkey);\n        if (pair === null)\n            return null;\n        const t = new BN(tweak);\n        if (t.cmp(curve.n) >= 0 || t.isZero())\n            return null;\n        const point = pair.getPublic().mul(tweak);\n        return Buffer.from(point.encode(null, compress));\n    },\n    signatureNormalize(sig) {\n        const r = new BN(sig.subarray(0, 32));\n        const s = new BN(sig.subarray(32, 64));\n        if (r.cmp(curve.n) >= 0 || s.cmp(curve.n) >= 0)\n            return null;\n        if (s.cmp(secp256k1.nh) === 1) {\n            sig.set(curve.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32);\n        }\n        return 0;\n    },\n    signatureExport(obj, sig) {\n        const sigR = sig.subarray(0, 32);\n        const sigS = sig.subarray(32, 64);\n        if (new BN(sigR).cmp(curve.n) >= 0)\n            return 1;\n        if (new BN(sigS).cmp(curve.n) >= 0)\n            return 1;\n        const { output } = obj;\n        let r = output.subarray(4, 4 + 33);\n        r[0] = 0x00;\n        r.set(sigR, 1);\n        let lenR = 33;\n        let posR = 0;\n        for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR)\n            ;\n        r = r.subarray(posR);\n        if (r[0] & 0x80)\n            return 1;\n        if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80))\n            return 1;\n        let s = output.subarray(6 + 33, 6 + 33 + 33);\n        s[0] = 0x00;\n        s.set(sigS, 1);\n        let lenS = 33;\n        let posS = 0;\n        for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS)\n            ;\n        s = s.subarray(posS);\n        if (s[0] & 0x80)\n            return 1;\n        if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80))\n            return 1;\n        obj.outputlen = 6 + lenR + lenS;\n        output[0] = 0x30;\n        output[1] = obj.outputlen - 2;\n        output[2] = 0x02;\n        output[3] = r.length;\n        output.set(r, 4);\n        output[4 + lenR] = 0x02;\n        output[5 + lenR] = s.length;\n        output.set(s, 6 + lenR);\n        return 0;\n    },\n    signatureImport(output, sig) {\n        if (sig.length < 8)\n            return 1;\n        if (sig.length > 72)\n            return 1;\n        if (sig[0] !== 0x30)\n            return 1;\n        if (sig[1] !== sig.length - 2)\n            return 1;\n        if (sig[2] !== 0x02)\n            return 1;\n        const lenR = sig[3];\n        if (lenR === 0)\n            return 1;\n        if (5 + lenR >= sig.length)\n            return 1;\n        if (sig[4 + lenR] !== 0x02)\n            return 1;\n        const lenS = sig[5 + lenR];\n        if (lenS === 0)\n            return 1;\n        if ((6 + lenR + lenS) !== sig.length)\n            return 1;\n        if (sig[4] & 0x80)\n            return 1;\n        if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80))\n            return 1;\n        if (sig[lenR + 6] & 0x80)\n            return 1;\n        if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80))\n            return 1;\n        let sigR = sig.subarray(4, 4 + lenR);\n        if (sigR.length === 33 && sigR[0] === 0x00)\n            sigR = sigR.subarray(1);\n        if (sigR.length > 32)\n            return 1;\n        let sigS = sig.subarray(6 + lenR);\n        if (sigS.length === 33 && sigS[0] === 0x00)\n            sigS = sigS.slice(1);\n        if (sigS.length > 32)\n            throw new Error('S length is too long');\n        let r = new BN(sigR);\n        if (r.cmp(curve.n) >= 0)\n            r = new BN(0);\n        let s = new BN(sig.subarray(6 + lenR));\n        if (s.cmp(curve.n) >= 0)\n            s = new BN(0);\n        output.set(r.toArrayLike(Uint8Array, 'be', 32), 0);\n        output.set(s.toArrayLike(Uint8Array, 'be', 32), 32);\n        return 0;\n    },\n    ecdsaSign(message, seckey) {\n        const d = new BN(seckey);\n        if (d.cmp(curve.n) >= 0 || d.isZero())\n            return null;\n        return secp256k1.sign(message, seckey, { canonical: true }).toBytes();\n    },\n    ecdsaVerify(sig, msg32, pubkey) {\n        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };\n        const sigr = new BN(sigObj.r);\n        const sigs = new BN(sigObj.s);\n        if (sigr.cmp(curve.n) >= 0 || sigs.cmp(curve.n) >= 0)\n            return 1;\n        if (sigs.cmp(secp256k1.nh) === 1 || sigr.isZero() || sigs.isZero())\n            return 3;\n        const pair = loadPublicKey(pubkey);\n        if (pair === null)\n            return 2;\n        const point = pair.getPublic();\n        return secp256k1.verify(msg32, sigObj, point);\n    },\n    ecdsaRecover(sig, recid, msg32, compress) {\n        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };\n        const sigr = new BN(sigObj.r);\n        const sigs = new BN(sigObj.s);\n        if (sigr.cmp(curve.n) >= 0 || sigs.cmp(curve.n) >= 0)\n            return 1;\n        if (sigr.isZero() || sigs.isZero())\n            return 2;\n        let point;\n        try {\n            point = secp256k1.recoverPubKey(msg32, sigObj, recid, null);\n        }\n        catch (err) {\n            return 2;\n        }\n        return Buffer.from(point.encode(null, compress));\n    },\n    ecdh(output, pubKey, seckey, data, hashfn, xbuf, ybuf) {\n        const pair = loadPublicKey(pubKey);\n        if (pair === null)\n            return 1;\n        const scalar = new BN(seckey);\n        if (scalar.cmp(curve.n) >= 0 || scalar.isZero())\n            return 2;\n        const point = pair.getPublic().mul(scalar);\n        if (hashfn === undefined) {\n            const data = point.encode(null, true);\n            const sha256 = secp256k1.hash().update(data).digest();\n            for (let i = 0; i < 32; ++i)\n                output[i] = sha256[i];\n        }\n        else {\n            if (!xbuf)\n                xbuf = new Uint8Array(32);\n            const x = point.getX().toArray('be', 32);\n            for (let i = 0; i < 32; ++i)\n                xbuf[i] = x[i];\n            if (!ybuf)\n                ybuf = new Uint8Array(32);\n            const y = point.getY().toArray('be', 32);\n            for (let i = 0; i < 32; ++i)\n                ybuf[i] = y[i];\n            const hash = hashfn(xbuf, ybuf, data);\n            const isValid = hash instanceof Uint8Array && hash.length === output.length;\n            if (!isValid)\n                return 2;\n            output.set(hash);\n        }\n        return 0;\n    }\n};\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2JpcDMyL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBYTtBQUN4QztBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLDBEQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBdUQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQXVEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFLEtBQUs7QUFDTDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9iaXAzMi9hcGkuanM/ZjI5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGVsbGlwdGljXzEgPSByZXF1aXJlKFwiLi4vZWxsaXB0aWNcIik7XG5jb25zdCBzZWNwMjU2azEgPSBuZXcgZWxsaXB0aWNfMS5lYyhcInNlY3AyNTZrMVwiKTtcbmNvbnN0IGN1cnZlID0gc2VjcDI1NmsxLmN1cnZlO1xuY29uc3QgQk4gPSByZXF1aXJlKFwiYm4uanMvbGliL2JuXCIpO1xuZnVuY3Rpb24gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkoZmlyc3QsIHhidWYpIHtcbiAgICBsZXQgeCA9IG5ldyBCTih4YnVmKTtcbiAgICBpZiAoeC5jbXAoY3VydmUucCkgPj0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgeCA9IHgudG9SZWQoY3VydmUucmVkKTtcbiAgICBsZXQgeSA9IHgucmVkU3FyKCkucmVkSU11bCh4KS5yZWRJQWRkKGN1cnZlLmIpLnJlZFNxcnQoKTtcbiAgICBpZiAoKGZpcnN0ID09PSAweDAzKSAhPT0geS5pc09kZCgpKVxuICAgICAgICB5ID0geS5yZWROZWcoKTtcbiAgICByZXR1cm4gc2VjcDI1NmsxLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pO1xufVxuZnVuY3Rpb24gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgeGJ1ZiwgeWJ1Zikge1xuICAgIGxldCB4ID0gbmV3IEJOKHhidWYpO1xuICAgIGxldCB5ID0gbmV3IEJOKHlidWYpO1xuICAgIGlmICh4LmNtcChjdXJ2ZS5wKSA+PSAwIHx8IHkuY21wKGN1cnZlLnApID49IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHggPSB4LnRvUmVkKGN1cnZlLnJlZCk7XG4gICAgeSA9IHkudG9SZWQoY3VydmUucmVkKTtcbiAgICBpZiAoKGZpcnN0ID09PSAweDA2IHx8IGZpcnN0ID09PSAweDA3KSAmJiB5LmlzT2RkKCkgIT09IChmaXJzdCA9PT0gMHgwNykpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHgzID0geC5yZWRTcXIoKS5yZWRJTXVsKHgpO1xuICAgIGlmICgheS5yZWRTcXIoKS5yZWRJU3ViKHgzLnJlZElBZGQoY3VydmUuYikpLmlzWmVybygpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gc2VjcDI1NmsxLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pO1xufVxuZnVuY3Rpb24gbG9hZFB1YmxpY0tleShwdWJrZXkpIHtcbiAgICBjb25zdCBmaXJzdCA9IHB1YmtleVswXTtcbiAgICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgICAgIGNhc2UgMHgwMjpcbiAgICAgICAgY2FzZSAweDAzOlxuICAgICAgICAgICAgaWYgKHB1YmtleS5sZW5ndGggIT09IDMzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRDb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBwdWJrZXkuc3ViYXJyYXkoMSwgMzMpKTtcbiAgICAgICAgY2FzZSAweDA0OlxuICAgICAgICBjYXNlIDB4MDY6XG4gICAgICAgIGNhc2UgMHgwNzpcbiAgICAgICAgICAgIGlmIChwdWJrZXkubGVuZ3RoICE9PSA2NSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBwdWJrZXkuc3ViYXJyYXkoMSwgMzMpLCBwdWJrZXkuc3ViYXJyYXkoMzMsIDY1KSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb250ZXh0UmFuZG9taXplKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHByaXZhdGVLZXlWZXJpZnkoc2Vja2V5KSB7XG4gICAgICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSk7XG4gICAgICAgIHJldHVybiBibi5jbXAoY3VydmUubikgPCAwICYmICFibi5pc1plcm8oKTtcbiAgICB9LFxuICAgIHByaXZhdGVLZXlOZWdhdGUoc2Vja2V5KSB7XG4gICAgICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShjdXJ2ZS5uLnN1YihibikudW1vZChjdXJ2ZS5uKS50b0FycmF5KCdiZScsIDMyKSk7XG4gICAgfSxcbiAgICBwcml2YXRlS2V5VHdlYWtBZGQoc2Vja2V5LCB0d2Vhaykge1xuICAgICAgICBjb25zdCBibiA9IG5ldyBCTih0d2Vhayk7XG4gICAgICAgIGlmIChibi5jbXAoY3VydmUubikgPj0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBibi5pYWRkKG5ldyBCTihzZWNrZXkpKTtcbiAgICAgICAgaWYgKGJuLmNtcChjdXJ2ZS5uKSA+PSAwKVxuICAgICAgICAgICAgYm4uaXN1YihjdXJ2ZS5uKTtcbiAgICAgICAgaWYgKGJuLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShibi50b0FycmF5KCdiZScsIDMyKSk7XG4gICAgfSxcbiAgICBwcml2YXRlS2V5VHdlYWtNdWwoc2Vja2V5LCB0d2Vhaykge1xuICAgICAgICBsZXQgYm4gPSBuZXcgQk4odHdlYWspO1xuICAgICAgICBpZiAoYm4uY21wKGN1cnZlLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgYm4uaW11bChuZXcgQk4oc2Vja2V5KSk7XG4gICAgICAgIGlmIChibi5jbXAoY3VydmUubikgPj0gMClcbiAgICAgICAgICAgIGJuID0gYm4udW1vZChjdXJ2ZS5uKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJuLnRvQXJyYXkoJ2JlJywgMzIpKTtcbiAgICB9LFxuICAgIHB1YmxpY0tleVZlcmlmeShwdWJrZXkpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KTtcbiAgICAgICAgaWYgKHBhaXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhaXIudmFsaWRhdGUoKS5yZXN1bHQ7XG4gICAgfSxcbiAgICBwdWJsaWNLZXlDcmVhdGUoc2Vja2V5LCBjb21wcmVzcykge1xuICAgICAgICBjb25zdCBibiA9IG5ldyBCTihzZWNrZXkpO1xuICAgICAgICBpZiAoYm4uY21wKGN1cnZlLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azEua2V5RnJvbVByaXZhdGUoc2Vja2V5LCBudWxsKS5nZXRQdWJsaWMoKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvaW50LmVuY29kZShudWxsLCBjb21wcmVzcykpO1xuICAgIH0sXG4gICAgcHVibGljS2V5Q29udmVydChwdWJLZXksIGNvbXByZXNzKSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YktleSk7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvaW50LmVuY29kZShudWxsLCBjb21wcmVzcykpO1xuICAgIH0sXG4gICAgcHVibGljS2V5TmVnYXRlKHB1YktleSwgY29tcHJlc3MpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHViS2V5KTtcbiAgICAgICAgaWYgKHBhaXIgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpO1xuICAgICAgICBwb2ludC55ID0gcG9pbnQueS5yZWROZWcoKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvaW50LmVuY29kZShudWxsLCBjb21wcmVzcykpO1xuICAgIH0sXG4gICAgcHVibGljS2V5Q29tYmluZShwdWJLZXlzLCBjb21wcmVzcykge1xuICAgICAgICBjb25zdCBwYWlycyA9IG5ldyBBcnJheShwdWJLZXlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHViS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcGFpcnNbaV0gPSBsb2FkUHVibGljS2V5KHB1YktleXNbaV0pO1xuICAgICAgICAgICAgaWYgKHBhaXJzW2ldID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb2ludCA9IHBhaXJzWzBdLmdldFB1YmxpYygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhaXJzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgcG9pbnQgPSBwb2ludC5hZGQocGFpcnNbaV0ucHViKTtcbiAgICAgICAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKG51bGwsIGNvbXByZXNzKSk7XG4gICAgfSxcbiAgICBwdWJsaWNLZXlUd2Vha0FkZChwdWJLZXlzLCB0d2VhaywgY29tcHJlc3MpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHViS2V5cyk7XG4gICAgICAgIGlmIChwYWlyID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHQgPSBuZXcgQk4odHdlYWspO1xuICAgICAgICBpZiAodC5jbXAoY3VydmUubikgPj0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKCkuYWRkKGN1cnZlLmcubXVsKHR3ZWFrKSk7XG4gICAgICAgIGlmIChwb2ludC5pc0luZmluaXR5KCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvaW50LmVuY29kZShudWxsLCBjb21wcmVzcykpO1xuICAgIH0sXG4gICAgcHVibGljS2V5VHdlYWtNdWwocHVia2V5LCB0d2VhaywgY29tcHJlc3MpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KTtcbiAgICAgICAgaWYgKHBhaXIgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBCTih0d2Vhayk7XG4gICAgICAgIGlmICh0LmNtcChjdXJ2ZS5uKSA+PSAwIHx8IHQuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLm11bCh0d2Vhayk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShwb2ludC5lbmNvZGUobnVsbCwgY29tcHJlc3MpKTtcbiAgICB9LFxuICAgIHNpZ25hdHVyZU5vcm1hbGl6ZShzaWcpIHtcbiAgICAgICAgY29uc3QgciA9IG5ldyBCTihzaWcuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBCTihzaWcuc3ViYXJyYXkoMzIsIDY0KSk7XG4gICAgICAgIGlmIChyLmNtcChjdXJ2ZS5uKSA+PSAwIHx8IHMuY21wKGN1cnZlLm4pID49IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHMuY21wKHNlY3AyNTZrMS5uaCkgPT09IDEpIHtcbiAgICAgICAgICAgIHNpZy5zZXQoY3VydmUubi5zdWIocykudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBzaWduYXR1cmVFeHBvcnQob2JqLCBzaWcpIHtcbiAgICAgICAgY29uc3Qgc2lnUiA9IHNpZy5zdWJhcnJheSgwLCAzMik7XG4gICAgICAgIGNvbnN0IHNpZ1MgPSBzaWcuc3ViYXJyYXkoMzIsIDY0KTtcbiAgICAgICAgaWYgKG5ldyBCTihzaWdSKS5jbXAoY3VydmUubikgPj0gMClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAobmV3IEJOKHNpZ1MpLmNtcChjdXJ2ZS5uKSA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNvbnN0IHsgb3V0cHV0IH0gPSBvYmo7XG4gICAgICAgIGxldCByID0gb3V0cHV0LnN1YmFycmF5KDQsIDQgKyAzMyk7XG4gICAgICAgIHJbMF0gPSAweDAwO1xuICAgICAgICByLnNldChzaWdSLCAxKTtcbiAgICAgICAgbGV0IGxlblIgPSAzMztcbiAgICAgICAgbGV0IHBvc1IgPSAwO1xuICAgICAgICBmb3IgKDsgbGVuUiA+IDEgJiYgcltwb3NSXSA9PT0gMHgwMCAmJiAhKHJbcG9zUiArIDFdICYgMHg4MCk7IC0tbGVuUiwgKytwb3NSKVxuICAgICAgICAgICAgO1xuICAgICAgICByID0gci5zdWJhcnJheShwb3NSKTtcbiAgICAgICAgaWYgKHJbMF0gJiAweDgwKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChsZW5SID4gMSAmJiAoclswXSA9PT0gMHgwMCkgJiYgIShyWzFdICYgMHg4MCkpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgbGV0IHMgPSBvdXRwdXQuc3ViYXJyYXkoNiArIDMzLCA2ICsgMzMgKyAzMyk7XG4gICAgICAgIHNbMF0gPSAweDAwO1xuICAgICAgICBzLnNldChzaWdTLCAxKTtcbiAgICAgICAgbGV0IGxlblMgPSAzMztcbiAgICAgICAgbGV0IHBvc1MgPSAwO1xuICAgICAgICBmb3IgKDsgbGVuUyA+IDEgJiYgc1twb3NTXSA9PT0gMHgwMCAmJiAhKHNbcG9zUyArIDFdICYgMHg4MCk7IC0tbGVuUywgKytwb3NTKVxuICAgICAgICAgICAgO1xuICAgICAgICBzID0gcy5zdWJhcnJheShwb3NTKTtcbiAgICAgICAgaWYgKHNbMF0gJiAweDgwKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChsZW5TID4gMSAmJiAoc1swXSA9PT0gMHgwMCkgJiYgIShzWzFdICYgMHg4MCkpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgb2JqLm91dHB1dGxlbiA9IDYgKyBsZW5SICsgbGVuUztcbiAgICAgICAgb3V0cHV0WzBdID0gMHgzMDtcbiAgICAgICAgb3V0cHV0WzFdID0gb2JqLm91dHB1dGxlbiAtIDI7XG4gICAgICAgIG91dHB1dFsyXSA9IDB4MDI7XG4gICAgICAgIG91dHB1dFszXSA9IHIubGVuZ3RoO1xuICAgICAgICBvdXRwdXQuc2V0KHIsIDQpO1xuICAgICAgICBvdXRwdXRbNCArIGxlblJdID0gMHgwMjtcbiAgICAgICAgb3V0cHV0WzUgKyBsZW5SXSA9IHMubGVuZ3RoO1xuICAgICAgICBvdXRwdXQuc2V0KHMsIDYgKyBsZW5SKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBzaWduYXR1cmVJbXBvcnQob3V0cHV0LCBzaWcpIHtcbiAgICAgICAgaWYgKHNpZy5sZW5ndGggPCA4KVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChzaWcubGVuZ3RoID4gNzIpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKHNpZ1swXSAhPT0gMHgzMClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoc2lnWzFdICE9PSBzaWcubGVuZ3RoIC0gMilcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoc2lnWzJdICE9PSAweDAyKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNvbnN0IGxlblIgPSBzaWdbM107XG4gICAgICAgIGlmIChsZW5SID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmICg1ICsgbGVuUiA+PSBzaWcubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChzaWdbNCArIGxlblJdICE9PSAweDAyKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNvbnN0IGxlblMgPSBzaWdbNSArIGxlblJdO1xuICAgICAgICBpZiAobGVuUyA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoKDYgKyBsZW5SICsgbGVuUykgIT09IHNpZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKHNpZ1s0XSAmIDB4ODApXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGxlblIgPiAxICYmIChzaWdbNF0gPT09IDB4MDApICYmICEoc2lnWzVdICYgMHg4MCkpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKHNpZ1tsZW5SICsgNl0gJiAweDgwKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChsZW5TID4gMSAmJiAoc2lnW2xlblIgKyA2XSA9PT0gMHgwMCkgJiYgIShzaWdbbGVuUiArIDddICYgMHg4MCkpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgbGV0IHNpZ1IgPSBzaWcuc3ViYXJyYXkoNCwgNCArIGxlblIpO1xuICAgICAgICBpZiAoc2lnUi5sZW5ndGggPT09IDMzICYmIHNpZ1JbMF0gPT09IDB4MDApXG4gICAgICAgICAgICBzaWdSID0gc2lnUi5zdWJhcnJheSgxKTtcbiAgICAgICAgaWYgKHNpZ1IubGVuZ3RoID4gMzIpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgbGV0IHNpZ1MgPSBzaWcuc3ViYXJyYXkoNiArIGxlblIpO1xuICAgICAgICBpZiAoc2lnUy5sZW5ndGggPT09IDMzICYmIHNpZ1NbMF0gPT09IDB4MDApXG4gICAgICAgICAgICBzaWdTID0gc2lnUy5zbGljZSgxKTtcbiAgICAgICAgaWYgKHNpZ1MubGVuZ3RoID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHRvbyBsb25nJyk7XG4gICAgICAgIGxldCByID0gbmV3IEJOKHNpZ1IpO1xuICAgICAgICBpZiAoci5jbXAoY3VydmUubikgPj0gMClcbiAgICAgICAgICAgIHIgPSBuZXcgQk4oMCk7XG4gICAgICAgIGxldCBzID0gbmV3IEJOKHNpZy5zdWJhcnJheSg2ICsgbGVuUikpO1xuICAgICAgICBpZiAocy5jbXAoY3VydmUubikgPj0gMClcbiAgICAgICAgICAgIHMgPSBuZXcgQk4oMCk7XG4gICAgICAgIG91dHB1dC5zZXQoci50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDApO1xuICAgICAgICBvdXRwdXQuc2V0KHMudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAzMik7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZWNkc2FTaWduKG1lc3NhZ2UsIHNlY2tleSkge1xuICAgICAgICBjb25zdCBkID0gbmV3IEJOKHNlY2tleSk7XG4gICAgICAgIGlmIChkLmNtcChjdXJ2ZS5uKSA+PSAwIHx8IGQuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHNlY3AyNTZrMS5zaWduKG1lc3NhZ2UsIHNlY2tleSwgeyBjYW5vbmljYWw6IHRydWUgfSkudG9CeXRlcygpO1xuICAgIH0sXG4gICAgZWNkc2FWZXJpZnkoc2lnLCBtc2czMiwgcHVia2V5KSB7XG4gICAgICAgIGNvbnN0IHNpZ09iaiA9IHsgcjogc2lnLnN1YmFycmF5KDAsIDMyKSwgczogc2lnLnN1YmFycmF5KDMyLCA2NCkgfTtcbiAgICAgICAgY29uc3Qgc2lnciA9IG5ldyBCTihzaWdPYmoucik7XG4gICAgICAgIGNvbnN0IHNpZ3MgPSBuZXcgQk4oc2lnT2JqLnMpO1xuICAgICAgICBpZiAoc2lnci5jbXAoY3VydmUubikgPj0gMCB8fCBzaWdzLmNtcChjdXJ2ZS5uKSA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChzaWdzLmNtcChzZWNwMjU2azEubmgpID09PSAxIHx8IHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpO1xuICAgICAgICBpZiAocGFpciA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKCk7XG4gICAgICAgIHJldHVybiBzZWNwMjU2azEudmVyaWZ5KG1zZzMyLCBzaWdPYmosIHBvaW50KTtcbiAgICB9LFxuICAgIGVjZHNhUmVjb3ZlcihzaWcsIHJlY2lkLCBtc2czMiwgY29tcHJlc3MpIHtcbiAgICAgICAgY29uc3Qgc2lnT2JqID0geyByOiBzaWcuc2xpY2UoMCwgMzIpLCBzOiBzaWcuc2xpY2UoMzIsIDY0KSB9O1xuICAgICAgICBjb25zdCBzaWdyID0gbmV3IEJOKHNpZ09iai5yKTtcbiAgICAgICAgY29uc3Qgc2lncyA9IG5ldyBCTihzaWdPYmoucyk7XG4gICAgICAgIGlmIChzaWdyLmNtcChjdXJ2ZS5uKSA+PSAwIHx8IHNpZ3MuY21wKGN1cnZlLm4pID49IDApXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBsZXQgcG9pbnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwb2ludCA9IHNlY3AyNTZrMS5yZWNvdmVyUHViS2V5KG1zZzMyLCBzaWdPYmosIHJlY2lkLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKG51bGwsIGNvbXByZXNzKSk7XG4gICAgfSxcbiAgICBlY2RoKG91dHB1dCwgcHViS2V5LCBzZWNrZXksIGRhdGEsIGhhc2hmbiwgeGJ1ZiwgeWJ1Zikge1xuICAgICAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJLZXkpO1xuICAgICAgICBpZiAocGFpciA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjb25zdCBzY2FsYXIgPSBuZXcgQk4oc2Vja2V5KTtcbiAgICAgICAgaWYgKHNjYWxhci5jbXAoY3VydmUubikgPj0gMCB8fCBzY2FsYXIuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLm11bChzY2FsYXIpO1xuICAgICAgICBpZiAoaGFzaGZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwb2ludC5lbmNvZGUobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBzaGEyNTYgPSBzZWNwMjU2azEuaGFzaCgpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSlcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBzaGEyNTZbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXhidWYpXG4gICAgICAgICAgICAgICAgeGJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBwb2ludC5nZXRYKCkudG9BcnJheSgnYmUnLCAzMik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpXG4gICAgICAgICAgICAgICAgeGJ1ZltpXSA9IHhbaV07XG4gICAgICAgICAgICBpZiAoIXlidWYpXG4gICAgICAgICAgICAgICAgeWJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnYmUnLCAzMik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpXG4gICAgICAgICAgICAgICAgeWJ1ZltpXSA9IHlbaV07XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gaGFzaGZuKHhidWYsIHlidWYsIGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGhhc2gubGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgb3V0cHV0LnNldChoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip32/api.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip32/bip32.js':
    /*!**************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/bip32/bip32.js ***!
  \**************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromSeed = exports.fromPublicKey = exports.fromPrivateKey = exports.fromBase58 = exports.tinySecp256k1Interface = void 0;\nconst base = __importStar(__webpack_require__(/*! ../base */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/index.js\"));\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@scure/base/index.js\");\nconst hash_1 = __webpack_require__(/*! ../base/hash */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/hash.js\");\nconst bytesCoder = (0, base_1.base58check)(hash_1.sha256);\nconst api = __webpack_require__(/*! ./api */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip32/api.js\");\nconst typeforce = __webpack_require__(/*! typeforce */ \"(ssr)/./node_modules/typeforce/index.js\");\nconst wif = __webpack_require__(/*! wif */ \"(ssr)/./node_modules/wif/index.js\");\nfunction createApi(secp256k1) {\n    return {\n        isPoint: (p) => secp256k1.publicKeyVerify(p),\n        isPrivate: (d) => secp256k1.privateKeyVerify(d),\n        pointAddScalar: (p, tweak, compress) => secp256k1.publicKeyTweakAdd(p, tweak, compress),\n        pointFromScalar: (d, compress) => secp256k1.publicKeyCreate(d, compress),\n        privateAdd: (d, tweak) => secp256k1.privateKeyTweakAdd(new Uint8Array(d), tweak),\n        sign: (h, d) => secp256k1.ecdsaSign(h, d),\n        verify: (h, Q, signature) => secp256k1.ecdsaVerify(signature, h, Q),\n    };\n}\nfunction createTinySecp256k1Interface(secp256k1) {\n    return {\n        isPoint: (p) => secp256k1.publicKeyVerify(p),\n        pointCompress: (p, compressed) => Uint8Array.from(secp256k1.publicKeyConvert(p, compressed != null ? compressed : true)),\n        isPrivate: (d) => secp256k1.privateKeyVerify(d),\n        pointFromScalar: (d, compressed) => {\n            const r = secp256k1.publicKeyCreate(d, compressed != null ? compressed : true);\n            if (r == null) {\n                return null;\n            }\n            return Uint8Array.from(r);\n        },\n        sign: (h, d, e) => Uint8Array.from(secp256k1.ecdsaSign(h, d)),\n        verify: (h, Q, signature, strict) => secp256k1.ecdsaVerify(signature, h, Q),\n    };\n}\nconst ecc = createApi(api);\nexports.tinySecp256k1Interface = createTinySecp256k1Interface(api);\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n    wif: typeforce.UInt8,\n    bip32: {\n        public: typeforce.UInt32,\n        private: typeforce.UInt32,\n    },\n});\nconst BITCOIN = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n    return (typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null);\n}\nfunction UInt31(value) {\n    return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n        this.__D = __D;\n        this.__Q = __Q;\n        this.chainCode = chainCode;\n        this.network = network;\n        this.__DEPTH = __DEPTH;\n        this.__INDEX = __INDEX;\n        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n        typeforce(NETWORK_TYPE, network);\n        this.lowR = false;\n    }\n    get depth() {\n        return this.__DEPTH;\n    }\n    get index() {\n        return this.__INDEX;\n    }\n    get parentFingerprint() {\n        return this.__PARENT_FINGERPRINT;\n    }\n    get publicKey() {\n        if (this.__Q === undefined)\n            this.__Q = Buffer.from(ecc.pointFromScalar(this.__D, true));\n        return this.__Q;\n    }\n    get privateKey() {\n        return this.__D;\n    }\n    get identifier() {\n        return Buffer.from(base.hash160(this.publicKey));\n    }\n    get fingerprint() {\n        return this.identifier.slice(0, 4);\n    }\n    get compressed() {\n        return true;\n    }\n    isNeutered() {\n        return this.__D === undefined;\n    }\n    neutered() {\n        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n    toBase58() {\n        const network = this.network;\n        const version = !this.isNeutered()\n            ? network.bip32.private\n            : network.bip32.public;\n        const buffer = Buffer.allocUnsafe(78);\n        buffer.writeUInt32BE(version, 0);\n        buffer.writeUInt8(this.depth, 4);\n        buffer.writeUInt32BE(this.parentFingerprint, 5);\n        buffer.writeUInt32BE(this.index, 9);\n        this.chainCode.copy(buffer, 13);\n        if (!this.isNeutered()) {\n            buffer.writeUInt8(0, 45);\n            this.privateKey.copy(buffer, 46);\n        }\n        else {\n            this.publicKey.copy(buffer, 45);\n        }\n        return bytesCoder.encode(buffer);\n    }\n    toWIF() {\n        if (!this.privateKey)\n            throw new TypeError('Missing private key');\n        return wif.encode(this.network.wif, this.privateKey, true);\n    }\n    derive(index) {\n        typeforce(typeforce.UInt32, index);\n        const isHardened = index >= HIGHEST_BIT;\n        const data = Buffer.allocUnsafe(37);\n        if (isHardened) {\n            if (this.isNeutered())\n                throw new TypeError('Missing private key for hardened child key');\n            data[0] = 0x00;\n            this.privateKey.copy(data, 1);\n            data.writeUInt32BE(index, 33);\n        }\n        else {\n            this.publicKey.copy(data, 0);\n            data.writeUInt32BE(index, 33);\n        }\n        const I = base.hmacSHA512(this.chainCode, data);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        if (!ecc.isPrivate(IL))\n            return this.derive(index + 1);\n        let hd;\n        if (!this.isNeutered()) {\n            const ki = ecc.privateAdd(this.privateKey, IL);\n            if (ki == null)\n                return this.derive(index + 1);\n            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        else {\n            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n            if (Ki === null)\n                return this.derive(index + 1);\n            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        return hd;\n    }\n    deriveHardened(index) {\n        typeforce(UInt31, index);\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        typeforce(BIP32Path, path);\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this.parentFingerprint)\n                throw new TypeError('Expected master, got child');\n            splitPath = splitPath.slice(1);\n        }\n        return splitPath.reduce((prevHd, indexStr) => {\n            let index;\n            if (indexStr.slice(-1) === `'`) {\n                index = parseInt(indexStr.slice(0, -1), 10);\n                return prevHd.deriveHardened(index);\n            }\n            else {\n                index = parseInt(indexStr, 10);\n                return prevHd.derive(index);\n            }\n        }, this);\n    }\n    sign(hash) {\n        if (!this.privateKey)\n            throw new Error('Missing private key');\n        return ecc.sign(hash, this.privateKey);\n    }\n    verify(hash, signature) {\n        return ecc.verify(hash, this.publicKey, signature);\n    }\n}\nfunction fromBase58(inString, network) {\n    const buffer = Buffer.from(bytesCoder.decode(inString));\n    if (buffer.length !== 78)\n        throw new TypeError('Invalid buffer length');\n    network = network || BITCOIN;\n    const version = buffer.readUInt32BE(0);\n    if (version !== network.bip32.private && version !== network.bip32.public)\n        throw new TypeError('Invalid network version');\n    const depth = buffer[4];\n    const parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new TypeError('Invalid parent fingerprint');\n    }\n    const index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new TypeError('Invalid index');\n    const chainCode = buffer.slice(13, 45);\n    let hd;\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new TypeError('Invalid private key');\n        const k = buffer.slice(46, 78);\n        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n    }\n    else {\n        const X = buffer.slice(45, 78);\n        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n    }\n    return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n    return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        privateKey: UINT256_TYPE,\n        chainCode: UINT256_TYPE,\n    }, { privateKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPrivate(privateKey))\n        throw new TypeError('Private key not in range [1, n)');\n    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n    return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        publicKey: typeforce.BufferN(33),\n        chainCode: UINT256_TYPE,\n    }, { publicKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPoint(publicKey))\n        throw new TypeError('Point is not on the curve');\n    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n    typeforce(typeforce.Buffer, seed);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    network = network || BITCOIN;\n    const I = base.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;\n//# sourceMappingURL=bip32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2JpcDMyL2JpcDMyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyw4QkFBOEI7QUFDdkgsMEJBQTBCLG1CQUFPLENBQUMsNEVBQVM7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLCtGQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxnRkFBYztBQUNyQztBQUNBLFlBQVksbUJBQU8sQ0FBQyx5RUFBTztBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQywwREFBVztBQUNyQyxZQUFZLG1CQUFPLENBQUMsOENBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUksdUJBQXVCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUksc0JBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvYmlwMzIvYmlwMzIuanM/NTFlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tU2VlZCA9IGV4cG9ydHMuZnJvbVB1YmxpY0tleSA9IGV4cG9ydHMuZnJvbVByaXZhdGVLZXkgPSBleHBvcnRzLmZyb21CYXNlNTggPSBleHBvcnRzLnRpbnlTZWNwMjU2azFJbnRlcmZhY2UgPSB2b2lkIDA7XG5jb25zdCBiYXNlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9iYXNlXCIpKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuLi9iYXNlL2hhc2hcIik7XG5jb25zdCBieXRlc0NvZGVyID0gKDAsIGJhc2VfMS5iYXNlNThjaGVjaykoaGFzaF8xLnNoYTI1Nik7XG5jb25zdCBhcGkgPSByZXF1aXJlKCcuL2FwaScpO1xuY29uc3QgdHlwZWZvcmNlID0gcmVxdWlyZSgndHlwZWZvcmNlJyk7XG5jb25zdCB3aWYgPSByZXF1aXJlKCd3aWYnKTtcbmZ1bmN0aW9uIGNyZWF0ZUFwaShzZWNwMjU2azEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc1BvaW50OiAocCkgPT4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwKSxcbiAgICAgICAgaXNQcml2YXRlOiAoZCkgPT4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoZCksXG4gICAgICAgIHBvaW50QWRkU2NhbGFyOiAocCwgdHdlYWssIGNvbXByZXNzKSA9PiBzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQocCwgdHdlYWssIGNvbXByZXNzKSxcbiAgICAgICAgcG9pbnRGcm9tU2NhbGFyOiAoZCwgY29tcHJlc3MpID0+IHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUoZCwgY29tcHJlc3MpLFxuICAgICAgICBwcml2YXRlQWRkOiAoZCwgdHdlYWspID0+IHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQobmV3IFVpbnQ4QXJyYXkoZCksIHR3ZWFrKSxcbiAgICAgICAgc2lnbjogKGgsIGQpID0+IHNlY3AyNTZrMS5lY2RzYVNpZ24oaCwgZCksXG4gICAgICAgIHZlcmlmeTogKGgsIFEsIHNpZ25hdHVyZSkgPT4gc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KHNpZ25hdHVyZSwgaCwgUSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpbnlTZWNwMjU2azFJbnRlcmZhY2Uoc2VjcDI1NmsxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQb2ludDogKHApID0+IHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocCksXG4gICAgICAgIHBvaW50Q29tcHJlc3M6IChwLCBjb21wcmVzc2VkKSA9PiBVaW50OEFycmF5LmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocCwgY29tcHJlc3NlZCAhPSBudWxsID8gY29tcHJlc3NlZCA6IHRydWUpKSxcbiAgICAgICAgaXNQcml2YXRlOiAoZCkgPT4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoZCksXG4gICAgICAgIHBvaW50RnJvbVNjYWxhcjogKGQsIGNvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKGQsIGNvbXByZXNzZWQgIT0gbnVsbCA/IGNvbXByZXNzZWQgOiB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocik7XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ246IChoLCBkLCBlKSA9PiBVaW50OEFycmF5LmZyb20oc2VjcDI1NmsxLmVjZHNhU2lnbihoLCBkKSksXG4gICAgICAgIHZlcmlmeTogKGgsIFEsIHNpZ25hdHVyZSwgc3RyaWN0KSA9PiBzZWNwMjU2azEuZWNkc2FWZXJpZnkoc2lnbmF0dXJlLCBoLCBRKSxcbiAgICB9O1xufVxuY29uc3QgZWNjID0gY3JlYXRlQXBpKGFwaSk7XG5leHBvcnRzLnRpbnlTZWNwMjU2azFJbnRlcmZhY2UgPSBjcmVhdGVUaW55U2VjcDI1NmsxSW50ZXJmYWNlKGFwaSk7XG5jb25zdCBVSU5UMjU2X1RZUEUgPSB0eXBlZm9yY2UuQnVmZmVyTigzMik7XG5jb25zdCBORVRXT1JLX1RZUEUgPSB0eXBlZm9yY2UuY29tcGlsZSh7XG4gICAgd2lmOiB0eXBlZm9yY2UuVUludDgsXG4gICAgYmlwMzI6IHtcbiAgICAgICAgcHVibGljOiB0eXBlZm9yY2UuVUludDMyLFxuICAgICAgICBwcml2YXRlOiB0eXBlZm9yY2UuVUludDMyLFxuICAgIH0sXG59KTtcbmNvbnN0IEJJVENPSU4gPSB7XG4gICAgbWVzc2FnZVByZWZpeDogJ1xceDE4Qml0Y29pbiBTaWduZWQgTWVzc2FnZTpcXG4nLFxuICAgIGJlY2gzMjogJ2JjJyxcbiAgICBiaXAzMjoge1xuICAgICAgICBwdWJsaWM6IDB4MDQ4OGIyMWUsXG4gICAgICAgIHByaXZhdGU6IDB4MDQ4OGFkZTQsXG4gICAgfSxcbiAgICBwdWJLZXlIYXNoOiAweDAwLFxuICAgIHNjcmlwdEhhc2g6IDB4MDUsXG4gICAgd2lmOiAweDgwLFxufTtcbmNvbnN0IEhJR0hFU1RfQklUID0gMHg4MDAwMDAwMDtcbmNvbnN0IFVJTlQzMV9NQVggPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuZnVuY3Rpb24gQklQMzJQYXRoKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlZm9yY2UuU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5tYXRjaCgvXihtXFwvKT8oXFxkKyc/XFwvKSpcXGQrJz8kLykgIT09IG51bGwpO1xufVxuZnVuY3Rpb24gVUludDMxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVmb3JjZS5VSW50MzIodmFsdWUpICYmIHZhbHVlIDw9IFVJTlQzMV9NQVg7XG59XG5jbGFzcyBCSVAzMiB7XG4gICAgY29uc3RydWN0b3IoX19ELCBfX1EsIGNoYWluQ29kZSwgbmV0d29yaywgX19ERVBUSCA9IDAsIF9fSU5ERVggPSAwLCBfX1BBUkVOVF9GSU5HRVJQUklOVCA9IDB4MDAwMDAwMDApIHtcbiAgICAgICAgdGhpcy5fX0QgPSBfX0Q7XG4gICAgICAgIHRoaXMuX19RID0gX19RO1xuICAgICAgICB0aGlzLmNoYWluQ29kZSA9IGNoYWluQ29kZTtcbiAgICAgICAgdGhpcy5uZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgdGhpcy5fX0RFUFRIID0gX19ERVBUSDtcbiAgICAgICAgdGhpcy5fX0lOREVYID0gX19JTkRFWDtcbiAgICAgICAgdGhpcy5fX1BBUkVOVF9GSU5HRVJQUklOVCA9IF9fUEFSRU5UX0ZJTkdFUlBSSU5UO1xuICAgICAgICB0eXBlZm9yY2UoTkVUV09SS19UWVBFLCBuZXR3b3JrKTtcbiAgICAgICAgdGhpcy5sb3dSID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19ERVBUSDtcbiAgICB9XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX0lOREVYO1xuICAgIH1cbiAgICBnZXQgcGFyZW50RmluZ2VycHJpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fUEFSRU5UX0ZJTkdFUlBSSU5UO1xuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICBpZiAodGhpcy5fX1EgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuX19RID0gQnVmZmVyLmZyb20oZWNjLnBvaW50RnJvbVNjYWxhcih0aGlzLl9fRCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fX1E7XG4gICAgfVxuICAgIGdldCBwcml2YXRlS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX0Q7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYmFzZS5oYXNoMTYwKHRoaXMucHVibGljS2V5KSk7XG4gICAgfVxuICAgIGdldCBmaW5nZXJwcmludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpZmllci5zbGljZSgwLCA0KTtcbiAgICB9XG4gICAgZ2V0IGNvbXByZXNzZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc05ldXRlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX0QgPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbmV1dGVyZWQoKSB7XG4gICAgICAgIHJldHVybiBmcm9tUHVibGljS2V5TG9jYWwodGhpcy5wdWJsaWNLZXksIHRoaXMuY2hhaW5Db2RlLCB0aGlzLm5ldHdvcmssIHRoaXMuZGVwdGgsIHRoaXMuaW5kZXgsIHRoaXMucGFyZW50RmluZ2VycHJpbnQpO1xuICAgIH1cbiAgICB0b0Jhc2U1OCgpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IHRoaXMubmV0d29yaztcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICF0aGlzLmlzTmV1dGVyZWQoKVxuICAgICAgICAgICAgPyBuZXR3b3JrLmJpcDMyLnByaXZhdGVcbiAgICAgICAgICAgIDogbmV0d29yay5iaXAzMi5wdWJsaWM7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg3OCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZlcnNpb24sIDApO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OCh0aGlzLmRlcHRoLCA0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5wYXJlbnRGaW5nZXJwcmludCwgNSk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHRoaXMuaW5kZXgsIDkpO1xuICAgICAgICB0aGlzLmNoYWluQ29kZS5jb3B5KGJ1ZmZlciwgMTMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNOZXV0ZXJlZCgpKSB7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVVSW50OCgwLCA0NSk7XG4gICAgICAgICAgICB0aGlzLnByaXZhdGVLZXkuY29weShidWZmZXIsIDQ2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVibGljS2V5LmNvcHkoYnVmZmVyLCA0NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzQ29kZXIuZW5jb2RlKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRvV0lGKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJpdmF0ZUtleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgcmV0dXJuIHdpZi5lbmNvZGUodGhpcy5uZXR3b3JrLndpZiwgdGhpcy5wcml2YXRlS2V5LCB0cnVlKTtcbiAgICB9XG4gICAgZGVyaXZlKGluZGV4KSB7XG4gICAgICAgIHR5cGVmb3JjZSh0eXBlZm9yY2UuVUludDMyLCBpbmRleCk7XG4gICAgICAgIGNvbnN0IGlzSGFyZGVuZWQgPSBpbmRleCA+PSBISUdIRVNUX0JJVDtcbiAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzNyk7XG4gICAgICAgIGlmIChpc0hhcmRlbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc05ldXRlcmVkKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBwcml2YXRlIGtleSBmb3IgaGFyZGVuZWQgY2hpbGQga2V5Jyk7XG4gICAgICAgICAgICBkYXRhWzBdID0gMHgwMDtcbiAgICAgICAgICAgIHRoaXMucHJpdmF0ZUtleS5jb3B5KGRhdGEsIDEpO1xuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkJFKGluZGV4LCAzMyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleS5jb3B5KGRhdGEsIDApO1xuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkJFKGluZGV4LCAzMyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgSSA9IGJhc2UuaG1hY1NIQTUxMih0aGlzLmNoYWluQ29kZSwgZGF0YSk7XG4gICAgICAgIGNvbnN0IElMID0gSS5zbGljZSgwLCAzMik7XG4gICAgICAgIGNvbnN0IElSID0gSS5zbGljZSgzMik7XG4gICAgICAgIGlmICghZWNjLmlzUHJpdmF0ZShJTCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxKTtcbiAgICAgICAgbGV0IGhkO1xuICAgICAgICBpZiAoIXRoaXMuaXNOZXV0ZXJlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBraSA9IGVjYy5wcml2YXRlQWRkKHRoaXMucHJpdmF0ZUtleSwgSUwpO1xuICAgICAgICAgICAgaWYgKGtpID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgMSk7XG4gICAgICAgICAgICBoZCA9IGZyb21Qcml2YXRlS2V5TG9jYWwoa2ksIElSLCB0aGlzLm5ldHdvcmssIHRoaXMuZGVwdGggKyAxLCBpbmRleCwgdGhpcy5maW5nZXJwcmludC5yZWFkVUludDMyQkUoMCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgS2kgPSBlY2MucG9pbnRBZGRTY2FsYXIodGhpcy5wdWJsaWNLZXksIElMLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChLaSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGhkID0gZnJvbVB1YmxpY0tleUxvY2FsKEtpLCBJUiwgdGhpcy5uZXR3b3JrLCB0aGlzLmRlcHRoICsgMSwgaW5kZXgsIHRoaXMuZmluZ2VycHJpbnQucmVhZFVJbnQzMkJFKDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGQ7XG4gICAgfVxuICAgIGRlcml2ZUhhcmRlbmVkKGluZGV4KSB7XG4gICAgICAgIHR5cGVmb3JjZShVSW50MzEsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgSElHSEVTVF9CSVQpO1xuICAgIH1cbiAgICBkZXJpdmVQYXRoKHBhdGgpIHtcbiAgICAgICAgdHlwZWZvcmNlKEJJUDMyUGF0aCwgcGF0aCk7XG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChzcGxpdFBhdGhbMF0gPT09ICdtJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbWFzdGVyLCBnb3QgY2hpbGQnKTtcbiAgICAgICAgICAgIHNwbGl0UGF0aCA9IHNwbGl0UGF0aC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRQYXRoLnJlZHVjZSgocHJldkhkLCBpbmRleFN0cikgPT4ge1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgaWYgKGluZGV4U3RyLnNsaWNlKC0xKSA9PT0gYCdgKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChpbmRleFN0ci5zbGljZSgwLCAtMSksIDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhkLmRlcml2ZUhhcmRlbmVkKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoaW5kZXhTdHIsIDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhkLmRlcml2ZShpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBzaWduKGhhc2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgcmV0dXJuIGVjYy5zaWduKGhhc2gsIHRoaXMucHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIHZlcmlmeShoYXNoLCBzaWduYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIGVjYy52ZXJpZnkoaGFzaCwgdGhpcy5wdWJsaWNLZXksIHNpZ25hdHVyZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbUJhc2U1OChpblN0cmluZywgbmV0d29yaykge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ5dGVzQ29kZXIuZGVjb2RlKGluU3RyaW5nKSk7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IDc4KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGJ1ZmZlciBsZW5ndGgnKTtcbiAgICBuZXR3b3JrID0gbmV0d29yayB8fCBCSVRDT0lOO1xuICAgIGNvbnN0IHZlcnNpb24gPSBidWZmZXIucmVhZFVJbnQzMkJFKDApO1xuICAgIGlmICh2ZXJzaW9uICE9PSBuZXR3b3JrLmJpcDMyLnByaXZhdGUgJiYgdmVyc2lvbiAhPT0gbmV0d29yay5iaXAzMi5wdWJsaWMpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbmV0d29yayB2ZXJzaW9uJyk7XG4gICAgY29uc3QgZGVwdGggPSBidWZmZXJbNF07XG4gICAgY29uc3QgcGFyZW50RmluZ2VycHJpbnQgPSBidWZmZXIucmVhZFVJbnQzMkJFKDUpO1xuICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICBpZiAocGFyZW50RmluZ2VycHJpbnQgIT09IDB4MDAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhcmVudCBmaW5nZXJwcmludCcpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGJ1ZmZlci5yZWFkVUludDMyQkUoOSk7XG4gICAgaWYgKGRlcHRoID09PSAwICYmIGluZGV4ICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGluZGV4Jyk7XG4gICAgY29uc3QgY2hhaW5Db2RlID0gYnVmZmVyLnNsaWNlKDEzLCA0NSk7XG4gICAgbGV0IGhkO1xuICAgIGlmICh2ZXJzaW9uID09PSBuZXR3b3JrLmJpcDMyLnByaXZhdGUpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5yZWFkVUludDgoNDUpICE9PSAweDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcml2YXRlIGtleScpO1xuICAgICAgICBjb25zdCBrID0gYnVmZmVyLnNsaWNlKDQ2LCA3OCk7XG4gICAgICAgIGhkID0gZnJvbVByaXZhdGVLZXlMb2NhbChrLCBjaGFpbkNvZGUsIG5ldHdvcmssIGRlcHRoLCBpbmRleCwgcGFyZW50RmluZ2VycHJpbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgWCA9IGJ1ZmZlci5zbGljZSg0NSwgNzgpO1xuICAgICAgICBoZCA9IGZyb21QdWJsaWNLZXlMb2NhbChYLCBjaGFpbkNvZGUsIG5ldHdvcmssIGRlcHRoLCBpbmRleCwgcGFyZW50RmluZ2VycHJpbnQpO1xuICAgIH1cbiAgICByZXR1cm4gaGQ7XG59XG5leHBvcnRzLmZyb21CYXNlNTggPSBmcm9tQmFzZTU4O1xuZnVuY3Rpb24gZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSwgY2hhaW5Db2RlLCBuZXR3b3JrKSB7XG4gICAgcmV0dXJuIGZyb21Qcml2YXRlS2V5TG9jYWwocHJpdmF0ZUtleSwgY2hhaW5Db2RlLCBuZXR3b3JrKTtcbn1cbmV4cG9ydHMuZnJvbVByaXZhdGVLZXkgPSBmcm9tUHJpdmF0ZUtleTtcbmZ1bmN0aW9uIGZyb21Qcml2YXRlS2V5TG9jYWwocHJpdmF0ZUtleSwgY2hhaW5Db2RlLCBuZXR3b3JrLCBkZXB0aCwgaW5kZXgsIHBhcmVudEZpbmdlcnByaW50KSB7XG4gICAgdHlwZWZvcmNlKHtcbiAgICAgICAgcHJpdmF0ZUtleTogVUlOVDI1Nl9UWVBFLFxuICAgICAgICBjaGFpbkNvZGU6IFVJTlQyNTZfVFlQRSxcbiAgICB9LCB7IHByaXZhdGVLZXksIGNoYWluQ29kZSB9KTtcbiAgICBuZXR3b3JrID0gbmV0d29yayB8fCBCSVRDT0lOO1xuICAgIGlmICghZWNjLmlzUHJpdmF0ZShwcml2YXRlS2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJpdmF0ZSBrZXkgbm90IGluIHJhbmdlIFsxLCBuKScpO1xuICAgIHJldHVybiBuZXcgQklQMzIocHJpdmF0ZUtleSwgdW5kZWZpbmVkLCBjaGFpbkNvZGUsIG5ldHdvcmssIGRlcHRoLCBpbmRleCwgcGFyZW50RmluZ2VycHJpbnQpO1xufVxuZnVuY3Rpb24gZnJvbVB1YmxpY0tleShwdWJsaWNLZXksIGNoYWluQ29kZSwgbmV0d29yaykge1xuICAgIHJldHVybiBmcm9tUHVibGljS2V5TG9jYWwocHVibGljS2V5LCBjaGFpbkNvZGUsIG5ldHdvcmspO1xufVxuZXhwb3J0cy5mcm9tUHVibGljS2V5ID0gZnJvbVB1YmxpY0tleTtcbmZ1bmN0aW9uIGZyb21QdWJsaWNLZXlMb2NhbChwdWJsaWNLZXksIGNoYWluQ29kZSwgbmV0d29yaywgZGVwdGgsIGluZGV4LCBwYXJlbnRGaW5nZXJwcmludCkge1xuICAgIHR5cGVmb3JjZSh7XG4gICAgICAgIHB1YmxpY0tleTogdHlwZWZvcmNlLkJ1ZmZlck4oMzMpLFxuICAgICAgICBjaGFpbkNvZGU6IFVJTlQyNTZfVFlQRSxcbiAgICB9LCB7IHB1YmxpY0tleSwgY2hhaW5Db2RlIH0pO1xuICAgIG5ldHdvcmsgPSBuZXR3b3JrIHx8IEJJVENPSU47XG4gICAgaWYgKCFlY2MuaXNQb2ludChwdWJsaWNLZXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQb2ludCBpcyBub3Qgb24gdGhlIGN1cnZlJyk7XG4gICAgcmV0dXJuIG5ldyBCSVAzMih1bmRlZmluZWQsIHB1YmxpY0tleSwgY2hhaW5Db2RlLCBuZXR3b3JrLCBkZXB0aCwgaW5kZXgsIHBhcmVudEZpbmdlcnByaW50KTtcbn1cbmZ1bmN0aW9uIGZyb21TZWVkKHNlZWQsIG5ldHdvcmspIHtcbiAgICB0eXBlZm9yY2UodHlwZWZvcmNlLkJ1ZmZlciwgc2VlZCk7XG4gICAgaWYgKHNlZWQubGVuZ3RoIDwgMTYpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NlZWQgc2hvdWxkIGJlIGF0IGxlYXN0IDEyOCBiaXRzJyk7XG4gICAgaWYgKHNlZWQubGVuZ3RoID4gNjQpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NlZWQgc2hvdWxkIGJlIGF0IG1vc3QgNTEyIGJpdHMnKTtcbiAgICBuZXR3b3JrID0gbmV0d29yayB8fCBCSVRDT0lOO1xuICAgIGNvbnN0IEkgPSBiYXNlLmhtYWNTSEE1MTIoQnVmZmVyLmZyb20oJ0JpdGNvaW4gc2VlZCcsICd1dGY4JyksIHNlZWQpO1xuICAgIGNvbnN0IElMID0gSS5zbGljZSgwLCAzMik7XG4gICAgY29uc3QgSVIgPSBJLnNsaWNlKDMyKTtcbiAgICByZXR1cm4gZnJvbVByaXZhdGVLZXkoSUwsIElSLCBuZXR3b3JrKTtcbn1cbmV4cG9ydHMuZnJvbVNlZWQgPSBmcm9tU2VlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpcDMyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip32/bip32.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip32/index.js':
    /*!**************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/bip32/index.js ***!
  \**************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.fromPrivateKey = exports.fromPublicKey = exports.fromBase58 = exports.fromSeed = exports.tinySecp256k1Interface = void 0;\nvar bip32_1 = __webpack_require__(/*! ./bip32 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip32/bip32.js");\nObject.defineProperty(exports, "tinySecp256k1Interface", ({ enumerable: true, get: function () { return bip32_1.tinySecp256k1Interface; } }));\nObject.defineProperty(exports, "fromSeed", ({ enumerable: true, get: function () { return bip32_1.fromSeed; } }));\nObject.defineProperty(exports, "fromBase58", ({ enumerable: true, get: function () { return bip32_1.fromBase58; } }));\nObject.defineProperty(exports, "fromPublicKey", ({ enumerable: true, get: function () { return bip32_1.fromPublicKey; } }));\nObject.defineProperty(exports, "fromPrivateKey", ({ enumerable: true, get: function () { return bip32_1.fromPrivateKey; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2JpcDMyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLDhCQUE4QjtBQUN2SCxjQUFjLG1CQUFPLENBQUMsNkVBQVM7QUFDL0IsMERBQXlELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQzNJLDRDQUEyQyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUMvRyw4Q0FBNkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbkgsaURBQWdELEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3pILGtEQUFpRCxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUMzSCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9iaXAzMi9pbmRleC5qcz9iNWVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tUHJpdmF0ZUtleSA9IGV4cG9ydHMuZnJvbVB1YmxpY0tleSA9IGV4cG9ydHMuZnJvbUJhc2U1OCA9IGV4cG9ydHMuZnJvbVNlZWQgPSBleHBvcnRzLnRpbnlTZWNwMjU2azFJbnRlcmZhY2UgPSB2b2lkIDA7XG52YXIgYmlwMzJfMSA9IHJlcXVpcmUoXCIuL2JpcDMyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidGlueVNlY3AyNTZrMUludGVyZmFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlwMzJfMS50aW55U2VjcDI1NmsxSW50ZXJmYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbVNlZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpcDMyXzEuZnJvbVNlZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tQmFzZTU4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaXAzMl8xLmZyb21CYXNlNTg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tUHVibGljS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaXAzMl8xLmZyb21QdWJsaWNLZXk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tUHJpdmF0ZUtleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlwMzJfMS5mcm9tUHJpdmF0ZUtleTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip32/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip39/_wordlists.js':
    /*!*******************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/bip39/_wordlists.js ***!
  \*******************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports._default = exports.wordlists = void 0;\nconst wordlists = {};\nexports.wordlists = wordlists;\nlet _default;\nexports._default = _default;\ntry {\n    exports._default = _default = __webpack_require__(/*! ./wordlists/english.json */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip39/wordlists/english.json");\n    wordlists.english = _default;\n    wordlists.EN = _default;\n}\ncatch (err) { }\n//# sourceMappingURL=_wordlists.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2JpcDM5L193b3JkbGlzdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsaUJBQWlCO0FBQ3BDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsSUFBSSxnQkFBZ0IsY0FBYyxtQkFBTyxDQUFDLDRHQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2JpcDM5L193b3JkbGlzdHMuanM/YjA2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX2RlZmF1bHQgPSBleHBvcnRzLndvcmRsaXN0cyA9IHZvaWQgMDtcbmNvbnN0IHdvcmRsaXN0cyA9IHt9O1xuZXhwb3J0cy53b3JkbGlzdHMgPSB3b3JkbGlzdHM7XG5sZXQgX2RlZmF1bHQ7XG5leHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQ7XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2VuZ2xpc2guanNvbicpO1xuICAgIHdvcmRsaXN0cy5lbmdsaXNoID0gX2RlZmF1bHQ7XG4gICAgd29yZGxpc3RzLkVOID0gX2RlZmF1bHQ7XG59XG5jYXRjaCAoZXJyKSB7IH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV93b3JkbGlzdHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip39/_wordlists.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip39/index.js':
    /*!**************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/bip39/index.js ***!
  \**************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wordlists = exports.getDefaultWordlist = exports.setDefaultWordlist = exports.validateMnemonic = exports.generateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.mnemonicToSeed = exports.mnemonicToSeedSync = void 0;\nconst base_1 = __webpack_require__(/*! ../base */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/index.js\");\nconst pbkdf2_1 = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/pbkdf2.js\");\nconst _wordlists_1 = __webpack_require__(/*! ./_wordlists */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip39/_wordlists.js\");\nconst sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha512.js\");\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' +\n    'Please pass a 2048 word array explicitly.';\nfunction pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {\n    const derivedKey = (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, password, saltMixin, { c: iterations, dkLen: keylen });\n    return Promise.resolve(Buffer.from(derivedKey));\n}\nfunction normalize(str) {\n    return (str || '').normalize('NFKD');\n}\nfunction lpad(str, padString, length) {\n    while (str.length < length) {\n        str = padString + str;\n    }\n    return str;\n}\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = (0, base_1.sha256)(entropyBuffer);\n    return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\nfunction salt(password) {\n    return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n    const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n    const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n    const n = (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, mnemonicBuffer, saltBuffer, { c: 2048, dkLen: 64 });\n    return Buffer.from(n);\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n    return Promise.resolve().then(() => {\n        const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n        const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n        return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n    });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    const words = normalize(mnemonic).split(' ');\n    if (words.length % 3 !== 0) {\n        throw new Error(INVALID_MNEMONIC);\n    }\n    const bits = words\n        .map((word) => {\n        const index = wordlist.indexOf(word);\n        if (index === -1) {\n            throw new Error(INVALID_MNEMONIC);\n        }\n        return lpad(index.toString(2), '0', 11);\n    })\n        .join('');\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n    if (entropyBytes.length < 16) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    if (entropyBytes.length > 32) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    if (entropyBytes.length % 4 !== 0) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const entropy = Buffer.from(entropyBytes);\n    const newChecksum = deriveChecksumBits(entropy);\n    if (newChecksum !== checksumBits) {\n        throw new Error(INVALID_CHECKSUM);\n    }\n    return entropy.toString('hex');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n    if (!Buffer.isBuffer(entropy)) {\n        entropy = Buffer.from(entropy, 'hex');\n    }\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    if (entropy.length < 16) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    if (entropy.length > 32) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    if (entropy.length % 4 !== 0) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    const entropyBits = bytesToBinary(Array.from(entropy));\n    const checksumBits = deriveChecksumBits(entropy);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = chunks.map((binary) => {\n        const index = binaryToByte(binary);\n        return wordlist[index];\n    });\n    return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093'\n        ? words.join('\\u3000')\n        : words.join(' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n    strength = strength || 128;\n    if (strength % 32 !== 0) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    rng = rng || base_1.randomBytes;\n    return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.validateMnemonic = validateMnemonic;\nfunction setDefaultWordlist(language) {\n    const result = _wordlists_1.wordlists[language];\n    if (result) {\n        DEFAULT_WORDLIST = result;\n    }\n    else {\n        throw new Error('Could not find wordlist for language \"' + language + '\"');\n    }\n}\nexports.setDefaultWordlist = setDefaultWordlist;\nfunction getDefaultWordlist() {\n    if (!DEFAULT_WORDLIST) {\n        throw new Error('No Default Wordlist set');\n    }\n    return Object.keys(_wordlists_1.wordlists).filter((lang) => {\n        if (lang === 'JA' || lang === 'EN') {\n            return false;\n        }\n        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n    })[0];\n}\nexports.getDefaultWordlist = getDefaultWordlist;\nvar _wordlists_2 = __webpack_require__(/*! ./_wordlists */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip39/_wordlists.js\");\nObject.defineProperty(exports, \"wordlists\", ({ enumerable: true, get: function () { return _wordlists_2.wordlists; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2JpcDM5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLDBCQUEwQjtBQUMvTyxlQUFlLG1CQUFPLENBQUMsNEVBQVM7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsMkdBQXNCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFjO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLDJHQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw4QkFBOEI7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixvQkFBb0I7QUFDdEc7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFjO0FBQ3pDLDZDQUE0QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN0SCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9iaXAzOS9pbmRleC5qcz9jMWVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53b3JkbGlzdHMgPSBleHBvcnRzLmdldERlZmF1bHRXb3JkbGlzdCA9IGV4cG9ydHMuc2V0RGVmYXVsdFdvcmRsaXN0ID0gZXhwb3J0cy52YWxpZGF0ZU1uZW1vbmljID0gZXhwb3J0cy5nZW5lcmF0ZU1uZW1vbmljID0gZXhwb3J0cy5lbnRyb3B5VG9NbmVtb25pYyA9IGV4cG9ydHMubW5lbW9uaWNUb0VudHJvcHkgPSBleHBvcnRzLm1uZW1vbmljVG9TZWVkID0gZXhwb3J0cy5tbmVtb25pY1RvU2VlZFN5bmMgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbmNvbnN0IHBia2RmMl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvcGJrZGYyXCIpO1xuY29uc3QgX3dvcmRsaXN0c18xID0gcmVxdWlyZShcIi4vX3dvcmRsaXN0c1wiKTtcbmNvbnN0IHNoYTUxMl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhNTEyXCIpO1xubGV0IERFRkFVTFRfV09SRExJU1QgPSBfd29yZGxpc3RzXzEuX2RlZmF1bHQ7XG5jb25zdCBJTlZBTElEX01ORU1PTklDID0gJ0ludmFsaWQgbW5lbW9uaWMnO1xuY29uc3QgSU5WQUxJRF9FTlRST1BZID0gJ0ludmFsaWQgZW50cm9weSc7XG5jb25zdCBJTlZBTElEX0NIRUNLU1VNID0gJ0ludmFsaWQgbW5lbW9uaWMgY2hlY2tzdW0nO1xuY29uc3QgV09SRExJU1RfUkVRVUlSRUQgPSAnQSB3b3JkbGlzdCBpcyByZXF1aXJlZCBidXQgYSBkZWZhdWx0IGNvdWxkIG5vdCBiZSBmb3VuZC5cXG4nICtcbiAgICAnUGxlYXNlIHBhc3MgYSAyMDQ4IHdvcmQgYXJyYXkgZXhwbGljaXRseS4nO1xuZnVuY3Rpb24gcGJrZGYyUHJvbWlzZShwYXNzd29yZCwgc2FsdE1peGluLCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCkge1xuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSAoMCwgcGJrZGYyXzEucGJrZGYyKShzaGE1MTJfMS5zaGE1MTIsIHBhc3N3b3JkLCBzYWx0TWl4aW4sIHsgYzogaXRlcmF0aW9ucywgZGtMZW46IGtleWxlbiB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEJ1ZmZlci5mcm9tKGRlcml2ZWRLZXkpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gKHN0ciB8fCAnJykubm9ybWFsaXplKCdORktEJyk7XG59XG5mdW5jdGlvbiBscGFkKHN0ciwgcGFkU3RyaW5nLCBsZW5ndGgpIHtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICBzdHIgPSBwYWRTdHJpbmcgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBiaW5hcnlUb0J5dGUoYmluKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGJpbiwgMik7XG59XG5mdW5jdGlvbiBieXRlc1RvQmluYXJ5KGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJ5dGVzLm1hcCgoeCkgPT4gbHBhZCh4LnRvU3RyaW5nKDIpLCAnMCcsIDgpKS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGRlcml2ZUNoZWNrc3VtQml0cyhlbnRyb3B5QnVmZmVyKSB7XG4gICAgY29uc3QgRU5UID0gZW50cm9weUJ1ZmZlci5sZW5ndGggKiA4O1xuICAgIGNvbnN0IENTID0gRU5UIC8gMzI7XG4gICAgY29uc3QgaGFzaCA9ICgwLCBiYXNlXzEuc2hhMjU2KShlbnRyb3B5QnVmZmVyKTtcbiAgICByZXR1cm4gYnl0ZXNUb0JpbmFyeShBcnJheS5mcm9tKGhhc2gpKS5zbGljZSgwLCBDUyk7XG59XG5mdW5jdGlvbiBzYWx0KHBhc3N3b3JkKSB7XG4gICAgcmV0dXJuICdtbmVtb25pYycgKyAocGFzc3dvcmQgfHwgJycpO1xufVxuZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWRTeW5jKG1uZW1vbmljLCBwYXNzd29yZCkge1xuICAgIGNvbnN0IG1uZW1vbmljQnVmZmVyID0gQnVmZmVyLmZyb20obm9ybWFsaXplKG1uZW1vbmljKSwgJ3V0ZjgnKTtcbiAgICBjb25zdCBzYWx0QnVmZmVyID0gQnVmZmVyLmZyb20oc2FsdChub3JtYWxpemUocGFzc3dvcmQpKSwgJ3V0ZjgnKTtcbiAgICBjb25zdCBuID0gKDAsIHBia2RmMl8xLnBia2RmMikoc2hhNTEyXzEuc2hhNTEyLCBtbmVtb25pY0J1ZmZlciwgc2FsdEJ1ZmZlciwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG4pO1xufVxuZXhwb3J0cy5tbmVtb25pY1RvU2VlZFN5bmMgPSBtbmVtb25pY1RvU2VlZFN5bmM7XG5mdW5jdGlvbiBtbmVtb25pY1RvU2VlZChtbmVtb25pYywgcGFzc3dvcmQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQnVmZmVyID0gQnVmZmVyLmZyb20obm9ybWFsaXplKG1uZW1vbmljKSwgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3Qgc2FsdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNhbHQobm9ybWFsaXplKHBhc3N3b3JkKSksICd1dGY4Jyk7XG4gICAgICAgIHJldHVybiBwYmtkZjJQcm9taXNlKG1uZW1vbmljQnVmZmVyLCBzYWx0QnVmZmVyLCAyMDQ4LCA2NCwgJ3NoYTUxMicpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5tbmVtb25pY1RvU2VlZCA9IG1uZW1vbmljVG9TZWVkO1xuZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgd29yZGxpc3QgPSB3b3JkbGlzdCB8fCBERUZBVUxUX1dPUkRMSVNUO1xuICAgIGlmICghd29yZGxpc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFdPUkRMSVNUX1JFUVVJUkVEKTtcbiAgICB9XG4gICAgY29uc3Qgd29yZHMgPSBub3JtYWxpemUobW5lbW9uaWMpLnNwbGl0KCcgJyk7XG4gICAgaWYgKHdvcmRzLmxlbmd0aCAlIDMgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfTU5FTU9OSUMpO1xuICAgIH1cbiAgICBjb25zdCBiaXRzID0gd29yZHNcbiAgICAgICAgLm1hcCgod29yZCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHdvcmRsaXN0LmluZGV4T2Yod29yZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX01ORU1PTklDKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbHBhZChpbmRleC50b1N0cmluZygyKSwgJzAnLCAxMSk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgIGNvbnN0IGRpdmlkZXJJbmRleCA9IE1hdGguZmxvb3IoYml0cy5sZW5ndGggLyAzMykgKiAzMjtcbiAgICBjb25zdCBlbnRyb3B5Qml0cyA9IGJpdHMuc2xpY2UoMCwgZGl2aWRlckluZGV4KTtcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSBiaXRzLnNsaWNlKGRpdmlkZXJJbmRleCk7XG4gICAgY29uc3QgZW50cm9weUJ5dGVzID0gZW50cm9weUJpdHMubWF0Y2goLyguezEsOH0pL2cpLm1hcChiaW5hcnlUb0J5dGUpO1xuICAgIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgfVxuICAgIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgfVxuICAgIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICB9XG4gICAgY29uc3QgZW50cm9weSA9IEJ1ZmZlci5mcm9tKGVudHJvcHlCeXRlcyk7XG4gICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBkZXJpdmVDaGVja3N1bUJpdHMoZW50cm9weSk7XG4gICAgaWYgKG5ld0NoZWNrc3VtICE9PSBjaGVja3N1bUJpdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfQ0hFQ0tTVU0pO1xuICAgIH1cbiAgICByZXR1cm4gZW50cm9weS50b1N0cmluZygnaGV4Jyk7XG59XG5leHBvcnRzLm1uZW1vbmljVG9FbnRyb3B5ID0gbW5lbW9uaWNUb0VudHJvcHk7XG5mdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGVudHJvcHkpKSB7XG4gICAgICAgIGVudHJvcHkgPSBCdWZmZXIuZnJvbShlbnRyb3B5LCAnaGV4Jyk7XG4gICAgfVxuICAgIHdvcmRsaXN0ID0gd29yZGxpc3QgfHwgREVGQVVMVF9XT1JETElTVDtcbiAgICBpZiAoIXdvcmRsaXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihXT1JETElTVF9SRVFVSVJFRCk7XG4gICAgfVxuICAgIGlmIChlbnRyb3B5Lmxlbmd0aCA8IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICB9XG4gICAgaWYgKGVudHJvcHkubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihJTlZBTElEX0VOVFJPUFkpO1xuICAgIH1cbiAgICBpZiAoZW50cm9weS5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICB9XG4gICAgY29uc3QgZW50cm9weUJpdHMgPSBieXRlc1RvQmluYXJ5KEFycmF5LmZyb20oZW50cm9weSkpO1xuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IGRlcml2ZUNoZWNrc3VtQml0cyhlbnRyb3B5KTtcbiAgICBjb25zdCBiaXRzID0gZW50cm9weUJpdHMgKyBjaGVja3N1bUJpdHM7XG4gICAgY29uc3QgY2h1bmtzID0gYml0cy5tYXRjaCgvKC57MSwxMX0pL2cpO1xuICAgIGNvbnN0IHdvcmRzID0gY2h1bmtzLm1hcCgoYmluYXJ5KSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYmluYXJ5VG9CeXRlKGJpbmFyeSk7XG4gICAgICAgIHJldHVybiB3b3JkbGlzdFtpbmRleF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHdvcmRsaXN0WzBdID09PSAnXFx1MzA0MlxcdTMwNDRcXHUzMDUzXFx1MzA0ZlxcdTMwNTdcXHUzMDkzJ1xuICAgICAgICA/IHdvcmRzLmpvaW4oJ1xcdTMwMDAnKVxuICAgICAgICA6IHdvcmRzLmpvaW4oJyAnKTtcbn1cbmV4cG9ydHMuZW50cm9weVRvTW5lbW9uaWMgPSBlbnRyb3B5VG9NbmVtb25pYztcbmZ1bmN0aW9uIGdlbmVyYXRlTW5lbW9uaWMoc3RyZW5ndGgsIHJuZywgd29yZGxpc3QpIHtcbiAgICBzdHJlbmd0aCA9IHN0cmVuZ3RoIHx8IDEyODtcbiAgICBpZiAoc3RyZW5ndGggJSAzMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgfVxuICAgIHJuZyA9IHJuZyB8fCBiYXNlXzEucmFuZG9tQnl0ZXM7XG4gICAgcmV0dXJuIGVudHJvcHlUb01uZW1vbmljKHJuZyhzdHJlbmd0aCAvIDgpLCB3b3JkbGlzdCk7XG59XG5leHBvcnRzLmdlbmVyYXRlTW5lbW9uaWMgPSBnZW5lcmF0ZU1uZW1vbmljO1xuZnVuY3Rpb24gdmFsaWRhdGVNbmVtb25pYyhtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICB0cnkge1xuICAgICAgICBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy52YWxpZGF0ZU1uZW1vbmljID0gdmFsaWRhdGVNbmVtb25pYztcbmZ1bmN0aW9uIHNldERlZmF1bHRXb3JkbGlzdChsYW5ndWFnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IF93b3JkbGlzdHNfMS53b3JkbGlzdHNbbGFuZ3VhZ2VdO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgREVGQVVMVF9XT1JETElTVCA9IHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgd29yZGxpc3QgZm9yIGxhbmd1YWdlIFwiJyArIGxhbmd1YWdlICsgJ1wiJyk7XG4gICAgfVxufVxuZXhwb3J0cy5zZXREZWZhdWx0V29yZGxpc3QgPSBzZXREZWZhdWx0V29yZGxpc3Q7XG5mdW5jdGlvbiBnZXREZWZhdWx0V29yZGxpc3QoKSB7XG4gICAgaWYgKCFERUZBVUxUX1dPUkRMSVNUKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gRGVmYXVsdCBXb3JkbGlzdCBzZXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKF93b3JkbGlzdHNfMS53b3JkbGlzdHMpLmZpbHRlcigobGFuZykgPT4ge1xuICAgICAgICBpZiAobGFuZyA9PT0gJ0pBJyB8fCBsYW5nID09PSAnRU4nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF93b3JkbGlzdHNfMS53b3JkbGlzdHNbbGFuZ10uZXZlcnkoKHdvcmQsIGluZGV4KSA9PiB3b3JkID09PSBERUZBVUxUX1dPUkRMSVNUW2luZGV4XSk7XG4gICAgfSlbMF07XG59XG5leHBvcnRzLmdldERlZmF1bHRXb3JkbGlzdCA9IGdldERlZmF1bHRXb3JkbGlzdDtcbnZhciBfd29yZGxpc3RzXzIgPSByZXF1aXJlKFwiLi9fd29yZGxpc3RzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid29yZGxpc3RzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfd29yZGxpc3RzXzIud29yZGxpc3RzOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip39/index.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/base.js':
    /*!**********************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/base.js ***!
  \**********************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\nfunction BaseCurve(type, conf) {\n    this.type = type;\n    this.p = new BN(conf.p, 16);\n    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n    this.zero = new BN(0).toRed(this.red);\n    this.one = new BN(1).toRed(this.red);\n    this.two = new BN(2).toRed(this.red);\n    this.n = conf.n && new BN(conf.n, 16);\n    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n    this._wnafT1 = new Array(4);\n    this._wnafT2 = new Array(4);\n    this._wnafT3 = new Array(4);\n    this._wnafT4 = new Array(4);\n    this._bitLength = this.n ? this.n.bitLength() : 0;\n    var adjustCount = this.n && this.p.div(this.n);\n    if (!adjustCount || adjustCount.cmpn(100) > 0) {\n        this.redN = null;\n    }\n    else {\n        this._maxwellTrick = true;\n        this.redN = this.n.toRed(this.red);\n    }\n}\nmodule.exports = BaseCurve;\nBaseCurve.prototype.point = function point() {\n    throw new Error('Not implemented');\n};\nBaseCurve.prototype.validate = function validate() {\n    throw new Error('Not implemented');\n};\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n    assert(p.precomputed);\n    var doubles = p._getDoubles();\n    var naf = getNAF(k, 1, this._bitLength);\n    var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n    I /= 3;\n    var repr = [];\n    var j;\n    var nafW;\n    for (j = 0; j < naf.length; j += doubles.step) {\n        nafW = 0;\n        for (var l = j + doubles.step - 1; l >= j; l--)\n            nafW = (nafW << 1) + naf[l];\n        repr.push(nafW);\n    }\n    var a = this.jpoint(null, null, null);\n    var b = this.jpoint(null, null, null);\n    for (var i = I; i > 0; i--) {\n        for (j = 0; j < repr.length; j++) {\n            nafW = repr[j];\n            if (nafW === i)\n                b = b.mixedAdd(doubles.points[j]);\n            else if (nafW === -i)\n                b = b.mixedAdd(doubles.points[j].neg());\n        }\n        a = a.add(b);\n    }\n    return a.toP();\n};\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n    var w = 4;\n    var nafPoints = p._getNAFPoints(w);\n    w = nafPoints.wnd;\n    var wnd = nafPoints.points;\n    var naf = getNAF(k, w, this._bitLength);\n    var acc = this.jpoint(null, null, null);\n    for (var i = naf.length - 1; i >= 0; i--) {\n        for (var l = 0; i >= 0 && naf[i] === 0; i--)\n            l++;\n        if (i >= 0)\n            l++;\n        acc = acc.dblp(l);\n        if (i < 0)\n            break;\n        var z = naf[i];\n        assert(z !== 0);\n        if (p.type === 'affine') {\n            if (z > 0)\n                acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n            else\n                acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n        }\n        else {\n            if (z > 0)\n                acc = acc.add(wnd[(z - 1) >> 1]);\n            else\n                acc = acc.add(wnd[(-z - 1) >> 1].neg());\n        }\n    }\n    return p.type === 'affine' ? acc.toP() : acc;\n};\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {\n    var wndWidth = this._wnafT1;\n    var wnd = this._wnafT2;\n    var naf = this._wnafT3;\n    var max = 0;\n    var i;\n    var j;\n    var p;\n    for (i = 0; i < len; i++) {\n        p = points[i];\n        var nafPoints = p._getNAFPoints(defW);\n        wndWidth[i] = nafPoints.wnd;\n        wnd[i] = nafPoints.points;\n    }\n    for (i = len - 1; i >= 1; i -= 2) {\n        var a = i - 1;\n        var b = i;\n        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n            max = Math.max(naf[a].length, max);\n            max = Math.max(naf[b].length, max);\n            continue;\n        }\n        var comb = [\n            points[a],\n            null,\n            null,\n            points[b],\n        ];\n        if (points[a].y.cmp(points[b].y) === 0) {\n            comb[1] = points[a].add(points[b]);\n            comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n        }\n        else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n            comb[1] = points[a].toJ().mixedAdd(points[b]);\n            comb[2] = points[a].add(points[b].neg());\n        }\n        else {\n            comb[1] = points[a].toJ().mixedAdd(points[b]);\n            comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n        }\n        var index = [\n            -3,\n            -1,\n            -5,\n            -7,\n            0,\n            7,\n            5,\n            1,\n            3,\n        ];\n        var jsf = getJSF(coeffs[a], coeffs[b]);\n        max = Math.max(jsf[0].length, max);\n        naf[a] = new Array(max);\n        naf[b] = new Array(max);\n        for (j = 0; j < max; j++) {\n            var ja = jsf[0][j] | 0;\n            var jb = jsf[1][j] | 0;\n            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n            naf[b][j] = 0;\n            wnd[a] = comb;\n        }\n    }\n    var acc = this.jpoint(null, null, null);\n    var tmp = this._wnafT4;\n    for (i = max; i >= 0; i--) {\n        var k = 0;\n        while (i >= 0) {\n            var zero = true;\n            for (j = 0; j < len; j++) {\n                tmp[j] = naf[j][i] | 0;\n                if (tmp[j] !== 0)\n                    zero = false;\n            }\n            if (!zero)\n                break;\n            k++;\n            i--;\n        }\n        if (i >= 0)\n            k++;\n        acc = acc.dblp(k);\n        if (i < 0)\n            break;\n        for (j = 0; j < len; j++) {\n            var z = tmp[j];\n            p;\n            if (z === 0)\n                continue;\n            else if (z > 0)\n                p = wnd[j][(z - 1) >> 1];\n            else if (z < 0)\n                p = wnd[j][(-z - 1) >> 1].neg();\n            if (p.type === 'affine')\n                acc = acc.mixedAdd(p);\n            else\n                acc = acc.add(p);\n        }\n    }\n    for (i = 0; i < len; i++)\n        wnd[i] = null;\n    if (jacobianResult)\n        return acc;\n    else\n        return acc.toP();\n};\nfunction BasePoint(curve, type) {\n    this.curve = curve;\n    this.type = type;\n    this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\nBasePoint.prototype.eq = function eq() {\n    throw new Error('Not implemented');\n};\nBasePoint.prototype.validate = function validate() {\n    return this.curve.validate(this);\n};\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n    bytes = utils.toArray(bytes, enc);\n    var len = this.p.byteLength();\n    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n        bytes.length - 1 === 2 * len) {\n        if (bytes[0] === 0x06)\n            assert(bytes[bytes.length - 1] % 2 === 0);\n        else if (bytes[0] === 0x07)\n            assert(bytes[bytes.length - 1] % 2 === 1);\n        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));\n        return res;\n    }\n    else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n        bytes.length - 1 === len) {\n        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n    }\n    throw new Error('Unknown point format');\n};\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n    return this.encode(enc, true);\n};\nBasePoint.prototype._encode = function _encode(compact) {\n    var len = this.curve.p.byteLength();\n    var x = this.getX().toArray('be', len);\n    if (compact)\n        return [this.getY().isEven() ? 0x02 : 0x03].concat(x);\n    return [0x04].concat(x, this.getY().toArray('be', len));\n};\nBasePoint.prototype.encode = function encode(enc, compact) {\n    return utils.encode(this._encode(compact), enc);\n};\nBasePoint.prototype.precompute = function precompute(power) {\n    if (this.precomputed)\n        return this;\n    var precomputed = {\n        doubles: null,\n        naf: null,\n        beta: null,\n    };\n    precomputed.naf = this._getNAFPoints(8);\n    precomputed.doubles = this._getDoubles(4, power);\n    precomputed.beta = this._getBeta();\n    this.precomputed = precomputed;\n    return this;\n};\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n    if (!this.precomputed)\n        return false;\n    var doubles = this.precomputed.doubles;\n    if (!doubles)\n        return false;\n    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n    if (this.precomputed && this.precomputed.doubles)\n        return this.precomputed.doubles;\n    var doubles = [this];\n    var acc = this;\n    for (var i = 0; i < power; i += step) {\n        for (var j = 0; j < step; j++)\n            acc = acc.dbl();\n        doubles.push(acc);\n    }\n    return {\n        step: step,\n        points: doubles,\n    };\n};\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n    if (this.precomputed && this.precomputed.naf)\n        return this.precomputed.naf;\n    var res = [this];\n    var max = (1 << wnd) - 1;\n    var dbl = max === 1 ? null : this.dbl();\n    for (var i = 1; i < max; i++)\n        res[i] = res[i - 1].add(dbl);\n    return {\n        wnd: wnd,\n        points: res,\n    };\n};\nBasePoint.prototype._getBeta = function _getBeta() {\n    return null;\n};\nBasePoint.prototype.dblp = function dblp(k) {\n    var r = this;\n    for (var i = 0; i < k; i++)\n        r = r.dbl();\n    return r;\n};\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2N1cnZlL2Jhc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixZQUFZLG1CQUFPLENBQUMsaUZBQVU7QUFDOUIsU0FBUyxtQkFBTyxDQUFDLDBEQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekMsd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0Isd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9lbGxpcHRpYy9jdXJ2ZS9iYXNlLmpzP2YxMGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMvbGliL2JuJyk7XG52YXIgZ2V0TkFGID0gdXRpbHMuZ2V0TkFGO1xudmFyIGdldEpTRiA9IHV0aWxzLmdldEpTRjtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wID0gbmV3IEJOKGNvbmYucCwgMTYpO1xuICAgIHRoaXMucmVkID0gY29uZi5wcmltZSA/IEJOLnJlZChjb25mLnByaW1lKSA6IEJOLm1vbnQodGhpcy5wKTtcbiAgICB0aGlzLnplcm8gPSBuZXcgQk4oMCkudG9SZWQodGhpcy5yZWQpO1xuICAgIHRoaXMub25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMucmVkKTtcbiAgICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG4gICAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBCTihjb25mLm4sIDE2KTtcbiAgICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcbiAgICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gICAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICAgIHRoaXMuX3duYWZUMyA9IG5ldyBBcnJheSg0KTtcbiAgICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG4gICAgdGhpcy5fYml0TGVuZ3RoID0gdGhpcy5uID8gdGhpcy5uLmJpdExlbmd0aCgpIDogMDtcbiAgICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICAgIGlmICghYWRqdXN0Q291bnQgfHwgYWRqdXN0Q291bnQuY21wbigxMDApID4gMCkge1xuICAgICAgICB0aGlzLnJlZE4gPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fbWF4d2VsbFRyaWNrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VDdXJ2ZTtcbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgICBhc3NlcnQocC5wcmVjb21wdXRlZCk7XG4gICAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG4gICAgdmFyIG5hZiA9IGdldE5BRihrLCAxLCB0aGlzLl9iaXRMZW5ndGgpO1xuICAgIHZhciBJID0gKDEgPDwgKGRvdWJsZXMuc3RlcCArIDEpKSAtIChkb3VibGVzLnN0ZXAgJSAyID09PSAwID8gMiA6IDEpO1xuICAgIEkgLz0gMztcbiAgICB2YXIgcmVwciA9IFtdO1xuICAgIHZhciBqO1xuICAgIHZhciBuYWZXO1xuICAgIGZvciAoaiA9IDA7IGogPCBuYWYubGVuZ3RoOyBqICs9IGRvdWJsZXMuc3RlcCkge1xuICAgICAgICBuYWZXID0gMDtcbiAgICAgICAgZm9yICh2YXIgbCA9IGogKyBkb3VibGVzLnN0ZXAgLSAxOyBsID49IGo7IGwtLSlcbiAgICAgICAgICAgIG5hZlcgPSAobmFmVyA8PCAxKSArIG5hZltsXTtcbiAgICAgICAgcmVwci5wdXNoKG5hZlcpO1xuICAgIH1cbiAgICB2YXIgYSA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IEk7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG5hZlcgPSByZXByW2pdO1xuICAgICAgICAgICAgaWYgKG5hZlcgPT09IGkpXG4gICAgICAgICAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0pO1xuICAgICAgICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG4gICAgICAgICAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0ubmVnKCkpO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLmFkZChiKTtcbiAgICB9XG4gICAgcmV0dXJuIGEudG9QKCk7XG59O1xuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uIF93bmFmTXVsKHAsIGspIHtcbiAgICB2YXIgdyA9IDQ7XG4gICAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyh3KTtcbiAgICB3ID0gbmFmUG9pbnRzLnduZDtcbiAgICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcbiAgICB2YXIgbmFmID0gZ2V0TkFGKGssIHcsIHRoaXMuX2JpdExlbmd0aCk7XG4gICAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGkgPj0gMCAmJiBuYWZbaV0gPT09IDA7IGktLSlcbiAgICAgICAgICAgIGwrKztcbiAgICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgICAgIGwrKztcbiAgICAgICAgYWNjID0gYWNjLmRibHAobCk7XG4gICAgICAgIGlmIChpIDwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB2YXIgeiA9IG5hZltpXTtcbiAgICAgICAgYXNzZXJ0KHogIT09IDApO1xuICAgICAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuICAgICAgICAgICAgaWYgKHogPiAwKVxuICAgICAgICAgICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoeiA+IDApXG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xufTtcbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWxBZGQgPSBmdW5jdGlvbiBfd25hZk11bEFkZChkZWZXLCBwb2ludHMsIGNvZWZmcywgbGVuLCBqYWNvYmlhblJlc3VsdCkge1xuICAgIHZhciB3bmRXaWR0aCA9IHRoaXMuX3duYWZUMTtcbiAgICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICAgIHZhciBuYWYgPSB0aGlzLl93bmFmVDM7XG4gICAgdmFyIG1heCA9IDA7XG4gICAgdmFyIGk7XG4gICAgdmFyIGo7XG4gICAgdmFyIHA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG4gICAgICAgIHduZFdpZHRoW2ldID0gbmFmUG9pbnRzLnduZDtcbiAgICAgICAgd25kW2ldID0gbmFmUG9pbnRzLnBvaW50cztcbiAgICB9XG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAxOyBpIC09IDIpIHtcbiAgICAgICAgdmFyIGEgPSBpIC0gMTtcbiAgICAgICAgdmFyIGIgPSBpO1xuICAgICAgICBpZiAod25kV2lkdGhbYV0gIT09IDEgfHwgd25kV2lkdGhbYl0gIT09IDEpIHtcbiAgICAgICAgICAgIG5hZlthXSA9IGdldE5BRihjb2VmZnNbYV0sIHduZFdpZHRoW2FdLCB0aGlzLl9iaXRMZW5ndGgpO1xuICAgICAgICAgICAgbmFmW2JdID0gZ2V0TkFGKGNvZWZmc1tiXSwgd25kV2lkdGhbYl0sIHRoaXMuX2JpdExlbmd0aCk7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChuYWZbYV0ubGVuZ3RoLCBtYXgpO1xuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2JdLmxlbmd0aCwgbWF4KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21iID0gW1xuICAgICAgICAgICAgcG9pbnRzW2FdLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwb2ludHNbYl0sXG4gICAgICAgIF07XG4gICAgICAgIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpID09PSAwKSB7XG4gICAgICAgICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuICAgICAgICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueS5yZWROZWcoKSkgPT09IDApIHtcbiAgICAgICAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgICAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICAgICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gW1xuICAgICAgICAgICAgLTMsXG4gICAgICAgICAgICAtMSxcbiAgICAgICAgICAgIC01LFxuICAgICAgICAgICAgLTcsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgNyxcbiAgICAgICAgICAgIDUsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMyxcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGpzZiA9IGdldEpTRihjb2VmZnNbYV0sIGNvZWZmc1tiXSk7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgICAgIG5hZlthXSA9IG5ldyBBcnJheShtYXgpO1xuICAgICAgICBuYWZbYl0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG1heDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuICAgICAgICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcbiAgICAgICAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcbiAgICAgICAgICAgIG5hZltiXVtqXSA9IDA7XG4gICAgICAgICAgICB3bmRbYV0gPSBjb21iO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuICAgIGZvciAoaSA9IG1heDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgemVybyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0bXBbal0gPSBuYWZbal1baV0gfCAwO1xuICAgICAgICAgICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHplcm8gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghemVybylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgaysrO1xuICAgICAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgdmFyIHogPSB0bXBbal07XG4gICAgICAgICAgICBwO1xuICAgICAgICAgICAgaWYgKHogPT09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICh6ID4gMClcbiAgICAgICAgICAgICAgICBwID0gd25kW2pdWyh6IC0gMSkgPj4gMV07XG4gICAgICAgICAgICBlbHNlIGlmICh6IDwgMClcbiAgICAgICAgICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICB3bmRbaV0gPSBudWxsO1xuICAgIGlmIChqYWNvYmlhblJlc3VsdClcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBhY2MudG9QKCk7XG59O1xuZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG4gICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG59XG5CYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuQmFzZVBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuQmFzZVBvaW50LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xufTtcbkJhc2VDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcywgZW5jKSB7XG4gICAgYnl0ZXMgPSB1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpO1xuICAgIHZhciBsZW4gPSB0aGlzLnAuYnl0ZUxlbmd0aCgpO1xuICAgIGlmICgoYnl0ZXNbMF0gPT09IDB4MDQgfHwgYnl0ZXNbMF0gPT09IDB4MDYgfHwgYnl0ZXNbMF0gPT09IDB4MDcpICYmXG4gICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IDIgKiBsZW4pIHtcbiAgICAgICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuICAgICAgICAgICAgYXNzZXJ0KGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMCk7XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVzWzBdID09PSAweDA3KVxuICAgICAgICAgICAgYXNzZXJ0KGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLnBvaW50KGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLCBieXRlcy5zbGljZSgxICsgbGVuLCAxICsgMiAqIGxlbikpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG4gICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEZyb21YKGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLCBieXRlc1swXSA9PT0gMHgwMyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2ludCBmb3JtYXQnKTtcbn07XG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuICAgIHJldHVybiB0aGlzLmVuY29kZShlbmMsIHRydWUpO1xufTtcbkJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuICAgIHZhciBsZW4gPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciB4ID0gdGhpcy5nZXRYKCkudG9BcnJheSgnYmUnLCBsZW4pO1xuICAgIGlmIChjb21wYWN0KVxuICAgICAgICByZXR1cm4gW3RoaXMuZ2V0WSgpLmlzRXZlbigpID8gMHgwMiA6IDB4MDNdLmNvbmNhdCh4KTtcbiAgICByZXR1cm4gWzB4MDRdLmNvbmNhdCh4LCB0aGlzLmdldFkoKS50b0FycmF5KCdiZScsIGxlbikpO1xufTtcbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGVuYywgY29tcGFjdCkge1xuICAgIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xufTtcbkJhc2VQb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUocG93ZXIpIHtcbiAgICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHByZWNvbXB1dGVkID0ge1xuICAgICAgICBkb3VibGVzOiBudWxsLFxuICAgICAgICBuYWY6IG51bGwsXG4gICAgICAgIGJldGE6IG51bGwsXG4gICAgfTtcbiAgICBwcmVjb21wdXRlZC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCk7XG4gICAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuICAgIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG4gICAgdGhpcy5wcmVjb21wdXRlZCA9IHByZWNvbXB1dGVkO1xuICAgIHJldHVybiB0aGlzO1xufTtcbkJhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXMgPSBmdW5jdGlvbiBfaGFzRG91YmxlcyhrKSB7XG4gICAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGRvdWJsZXMgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gICAgaWYgKCFkb3VibGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aCA+PSBNYXRoLmNlaWwoKGsuYml0TGVuZ3RoKCkgKyAxKSAvIGRvdWJsZXMuc3RlcCk7XG59O1xuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAsIHBvd2VyKSB7XG4gICAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuICAgIHZhciBkb3VibGVzID0gW3RoaXNdO1xuICAgIHZhciBhY2MgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gc3RlcCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXA7IGorKylcbiAgICAgICAgICAgIGFjYyA9IGFjYy5kYmwoKTtcbiAgICAgICAgZG91Ymxlcy5wdXNoKGFjYyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgIHBvaW50czogZG91YmxlcyxcbiAgICB9O1xufTtcbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldE5BRlBvaW50cyA9IGZ1bmN0aW9uIF9nZXROQUZQb2ludHMod25kKSB7XG4gICAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5uYWYpXG4gICAgICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLm5hZjtcbiAgICB2YXIgcmVzID0gW3RoaXNdO1xuICAgIHZhciBtYXggPSAoMSA8PCB3bmQpIC0gMTtcbiAgICB2YXIgZGJsID0gbWF4ID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICAgICAgcmVzW2ldID0gcmVzW2kgLSAxXS5hZGQoZGJsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3bmQ6IHduZCxcbiAgICAgICAgcG9pbnRzOiByZXMsXG4gICAgfTtcbn07XG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuQmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuICAgICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/base.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/edwards.js':
    /*!*************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/edwards.js ***!
  \*************************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/base.js\");\nvar assert = utils.assert;\nfunction EdwardsCurve(conf) {\n    this.twisted = (conf.a | 0) !== 1;\n    this.mOneA = this.twisted && (conf.a | 0) === -1;\n    this.extended = this.mOneA;\n    Base.call(this, 'edwards', conf);\n    this.a = new BN(conf.a, 16).umod(this.red.m);\n    this.a = this.a.toRed(this.red);\n    this.c = new BN(conf.c, 16).toRed(this.red);\n    this.c2 = this.c.redSqr();\n    this.d = new BN(conf.d, 16).toRed(this.red);\n    this.dd = this.d.redAdd(this.d);\n    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);\n    this.oneC = (conf.c | 0) === 1;\n}\ninherits(EdwardsCurve, Base);\nmodule.exports = EdwardsCurve;\nEdwardsCurve.prototype._mulA = function _mulA(num) {\n    if (this.mOneA)\n        return num.redNeg();\n    else\n        return this.a.redMul(num);\n};\nEdwardsCurve.prototype._mulC = function _mulC(num) {\n    if (this.oneC)\n        return num;\n    else\n        return this.c.redMul(num);\n};\nEdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {\n    return this.point(x, y, z, t);\n};\nEdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {\n    x = new BN(x, 16);\n    if (!x.red)\n        x = x.toRed(this.red);\n    var x2 = x.redSqr();\n    var rhs = this.c2.redSub(this.a.redMul(x2));\n    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));\n    var y2 = rhs.redMul(lhs.redInvm());\n    var y = y2.redSqrt();\n    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n        throw new Error('invalid point');\n    var isOdd = y.fromRed().isOdd();\n    if (odd && !isOdd || !odd && isOdd)\n        y = y.redNeg();\n    return this.point(x, y);\n};\nEdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {\n    y = new BN(y, 16);\n    if (!y.red)\n        y = y.toRed(this.red);\n    var y2 = y.redSqr();\n    var lhs = y2.redSub(this.c2);\n    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);\n    var x2 = lhs.redMul(rhs.redInvm());\n    if (x2.cmp(this.zero) === 0) {\n        if (odd)\n            throw new Error('invalid point');\n        else\n            return this.point(this.zero, y);\n    }\n    var x = x2.redSqrt();\n    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)\n        throw new Error('invalid point');\n    if (x.fromRed().isOdd() !== odd)\n        x = x.redNeg();\n    return this.point(x, y);\n};\nEdwardsCurve.prototype.validate = function validate(point) {\n    if (point.isInfinity())\n        return true;\n    point.normalize();\n    var x2 = point.x.redSqr();\n    var y2 = point.y.redSqr();\n    var lhs = x2.redMul(this.a).redAdd(y2);\n    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));\n    return lhs.cmp(rhs) === 0;\n};\nfunction Point(curve, x, y, z, t) {\n    Base.BasePoint.call(this, curve, 'projective');\n    if (x === null && y === null && z === null) {\n        this.x = this.curve.zero;\n        this.y = this.curve.one;\n        this.z = this.curve.one;\n        this.t = this.curve.zero;\n        this.zOne = true;\n    }\n    else {\n        this.x = new BN(x, 16);\n        this.y = new BN(y, 16);\n        this.z = z ? new BN(z, 16) : this.curve.one;\n        this.t = t && new BN(t, 16);\n        if (!this.x.red)\n            this.x = this.x.toRed(this.curve.red);\n        if (!this.y.red)\n            this.y = this.y.toRed(this.curve.red);\n        if (!this.z.red)\n            this.z = this.z.toRed(this.curve.red);\n        if (this.t && !this.t.red)\n            this.t = this.t.toRed(this.curve.red);\n        this.zOne = this.z === this.curve.one;\n        if (this.curve.extended && !this.t) {\n            this.t = this.x.redMul(this.y);\n            if (!this.zOne)\n                this.t = this.t.redMul(this.z.redInvm());\n        }\n    }\n}\ninherits(Point, Base.BasePoint);\nEdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\n    return Point.fromJSON(this, obj);\n};\nEdwardsCurve.prototype.point = function point(x, y, z, t) {\n    return new Point(this, x, y, z, t);\n};\nPoint.fromJSON = function fromJSON(curve, obj) {\n    return new Point(curve, obj[0], obj[1], obj[2]);\n};\nPoint.prototype.inspect = function inspect() {\n    if (this.isInfinity())\n        return '<EC Point Infinity>';\n    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n        ' y: ' + this.y.fromRed().toString(16, 2) +\n        ' z: ' + this.z.fromRed().toString(16, 2) + '>';\n};\nPoint.prototype.isInfinity = function isInfinity() {\n    return this.x.cmpn(0) === 0 &&\n        (this.y.cmp(this.z) === 0 ||\n            (this.zOne && this.y.cmp(this.curve.c) === 0));\n};\nPoint.prototype._extDbl = function _extDbl() {\n    var a = this.x.redSqr();\n    var b = this.y.redSqr();\n    var c = this.z.redSqr();\n    c = c.redIAdd(c);\n    var d = this.curve._mulA(a);\n    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);\n    var g = d.redAdd(b);\n    var f = g.redSub(c);\n    var h = d.redSub(b);\n    var nx = e.redMul(f);\n    var ny = g.redMul(h);\n    var nt = e.redMul(h);\n    var nz = f.redMul(g);\n    return this.curve.point(nx, ny, nz, nt);\n};\nPoint.prototype._projDbl = function _projDbl() {\n    var b = this.x.redAdd(this.y).redSqr();\n    var c = this.x.redSqr();\n    var d = this.y.redSqr();\n    var nx;\n    var ny;\n    var nz;\n    var e;\n    var h;\n    var j;\n    if (this.curve.twisted) {\n        e = this.curve._mulA(c);\n        var f = e.redAdd(d);\n        if (this.zOne) {\n            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));\n            ny = f.redMul(e.redSub(d));\n            nz = f.redSqr().redSub(f).redSub(f);\n        }\n        else {\n            h = this.z.redSqr();\n            j = f.redSub(h).redISub(h);\n            nx = b.redSub(c).redISub(d).redMul(j);\n            ny = f.redMul(e.redSub(d));\n            nz = f.redMul(j);\n        }\n    }\n    else {\n        e = c.redAdd(d);\n        h = this.curve._mulC(this.z).redSqr();\n        j = e.redSub(h).redSub(h);\n        nx = this.curve._mulC(b.redISub(e)).redMul(j);\n        ny = this.curve._mulC(e).redMul(c.redISub(d));\n        nz = e.redMul(j);\n    }\n    return this.curve.point(nx, ny, nz);\n};\nPoint.prototype.dbl = function dbl() {\n    if (this.isInfinity())\n        return this;\n    if (this.curve.extended)\n        return this._extDbl();\n    else\n        return this._projDbl();\n};\nPoint.prototype._extAdd = function _extAdd(p) {\n    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));\n    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));\n    var c = this.t.redMul(this.curve.dd).redMul(p.t);\n    var d = this.z.redMul(p.z.redAdd(p.z));\n    var e = b.redSub(a);\n    var f = d.redSub(c);\n    var g = d.redAdd(c);\n    var h = b.redAdd(a);\n    var nx = e.redMul(f);\n    var ny = g.redMul(h);\n    var nt = e.redMul(h);\n    var nz = f.redMul(g);\n    return this.curve.point(nx, ny, nz, nt);\n};\nPoint.prototype._projAdd = function _projAdd(p) {\n    var a = this.z.redMul(p.z);\n    var b = a.redSqr();\n    var c = this.x.redMul(p.x);\n    var d = this.y.redMul(p.y);\n    var e = this.curve.d.redMul(c).redMul(d);\n    var f = b.redSub(e);\n    var g = b.redAdd(e);\n    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);\n    var nx = a.redMul(f).redMul(tmp);\n    var ny;\n    var nz;\n    if (this.curve.twisted) {\n        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));\n        nz = f.redMul(g);\n    }\n    else {\n        ny = a.redMul(g).redMul(d.redSub(c));\n        nz = this.curve._mulC(f).redMul(g);\n    }\n    return this.curve.point(nx, ny, nz);\n};\nPoint.prototype.add = function add(p) {\n    if (this.isInfinity())\n        return p;\n    if (p.isInfinity())\n        return this;\n    if (this.curve.extended)\n        return this._extAdd(p);\n    else\n        return this._projAdd(p);\n};\nPoint.prototype.mul = function mul(k) {\n    if (this._hasDoubles(k))\n        return this.curve._fixedNafMul(this, k);\n    else\n        return this.curve._wnafMul(this, k);\n};\nPoint.prototype.mulAdd = function mulAdd(k1, p, k2) {\n    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);\n};\nPoint.prototype.jmulAdd = function jmulAdd(k1, p, k2) {\n    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);\n};\nPoint.prototype.normalize = function normalize() {\n    if (this.zOne)\n        return this;\n    var zi = this.z.redInvm();\n    this.x = this.x.redMul(zi);\n    this.y = this.y.redMul(zi);\n    if (this.t)\n        this.t = this.t.redMul(zi);\n    this.z = this.curve.one;\n    this.zOne = true;\n    return this;\n};\nPoint.prototype.neg = function neg() {\n    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());\n};\nPoint.prototype.getX = function getX() {\n    this.normalize();\n    return this.x.fromRed();\n};\nPoint.prototype.getY = function getY() {\n    this.normalize();\n    return this.y.fromRed();\n};\nPoint.prototype.eq = function eq(other) {\n    return this === other ||\n        this.getX().cmp(other.getX()) === 0 &&\n            this.getY().cmp(other.getY()) === 0;\n};\nPoint.prototype.eqXToP = function eqXToP(x) {\n    var rx = x.toRed(this.curve.red).redMul(this.z);\n    if (this.x.cmp(rx) === 0)\n        return true;\n    var xc = x.clone();\n    var t = this.curve.redN.redMul(this.z);\n    for (;;) {\n        xc.iadd(this.curve.n);\n        if (xc.cmp(this.curve.p) >= 0)\n            return false;\n        rx.redIAdd(t);\n        if (this.x.cmp(rx) === 0)\n            return true;\n    }\n};\nPoint.prototype.toP = Point.prototype.normalize;\nPoint.prototype.mixedAdd = Point.prototype.add;\n//# sourceMappingURL=edwards.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2N1cnZlL2Vkd2FyZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixZQUFZLG1CQUFPLENBQUMsaUZBQVU7QUFDOUIsU0FBUyxtQkFBTyxDQUFDLDBEQUFjO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQywyREFBVTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsb0ZBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2N1cnZlL2Vkd2FyZHMuanM/NGQ1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMvbGliL2JuJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5mdW5jdGlvbiBFZHdhcmRzQ3VydmUoY29uZikge1xuICAgIHRoaXMudHdpc3RlZCA9IChjb25mLmEgfCAwKSAhPT0gMTtcbiAgICB0aGlzLm1PbmVBID0gdGhpcy50d2lzdGVkICYmIChjb25mLmEgfCAwKSA9PT0gLTE7XG4gICAgdGhpcy5leHRlbmRlZCA9IHRoaXMubU9uZUE7XG4gICAgQmFzZS5jYWxsKHRoaXMsICdlZHdhcmRzJywgY29uZik7XG4gICAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnVtb2QodGhpcy5yZWQubSk7XG4gICAgdGhpcy5hID0gdGhpcy5hLnRvUmVkKHRoaXMucmVkKTtcbiAgICB0aGlzLmMgPSBuZXcgQk4oY29uZi5jLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICAgIHRoaXMuYzIgPSB0aGlzLmMucmVkU3FyKCk7XG4gICAgdGhpcy5kID0gbmV3IEJOKGNvbmYuZCwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgICB0aGlzLmRkID0gdGhpcy5kLnJlZEFkZCh0aGlzLmQpO1xuICAgIGFzc2VydCghdGhpcy50d2lzdGVkIHx8IHRoaXMuYy5mcm9tUmVkKCkuY21wbigxKSA9PT0gMCk7XG4gICAgdGhpcy5vbmVDID0gKGNvbmYuYyB8IDApID09PSAxO1xufVxuaW5oZXJpdHMoRWR3YXJkc0N1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gRWR3YXJkc0N1cnZlO1xuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQSA9IGZ1bmN0aW9uIF9tdWxBKG51bSkge1xuICAgIGlmICh0aGlzLm1PbmVBKVxuICAgICAgICByZXR1cm4gbnVtLnJlZE5lZygpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRoaXMuYS5yZWRNdWwobnVtKTtcbn07XG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxDID0gZnVuY3Rpb24gX211bEMobnVtKSB7XG4gICAgaWYgKHRoaXMub25lQylcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLmMucmVkTXVsKG51bSk7XG59O1xuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeiwgdCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50KHgsIHksIHosIHQpO1xufTtcbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gICAgeCA9IG5ldyBCTih4LCAxNik7XG4gICAgaWYgKCF4LnJlZClcbiAgICAgICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuICAgIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gICAgdmFyIHJocyA9IHRoaXMuYzIucmVkU3ViKHRoaXMuYS5yZWRNdWwoeDIpKTtcbiAgICB2YXIgbGhzID0gdGhpcy5vbmUucmVkU3ViKHRoaXMuYzIucmVkTXVsKHRoaXMuZCkucmVkTXVsKHgyKSk7XG4gICAgdmFyIHkyID0gcmhzLnJlZE11bChsaHMucmVkSW52bSgpKTtcbiAgICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgICBpZiAoeS5yZWRTcXIoKS5yZWRTdWIoeTIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcbiAgICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICAgIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgICAgIHkgPSB5LnJlZE5lZygpO1xuICAgIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWSA9IGZ1bmN0aW9uIHBvaW50RnJvbVkoeSwgb2RkKSB7XG4gICAgeSA9IG5ldyBCTih5LCAxNik7XG4gICAgaWYgKCF5LnJlZClcbiAgICAgICAgeSA9IHkudG9SZWQodGhpcy5yZWQpO1xuICAgIHZhciB5MiA9IHkucmVkU3FyKCk7XG4gICAgdmFyIGxocyA9IHkyLnJlZFN1Yih0aGlzLmMyKTtcbiAgICB2YXIgcmhzID0geTIucmVkTXVsKHRoaXMuZCkucmVkTXVsKHRoaXMuYzIpLnJlZFN1Yih0aGlzLmEpO1xuICAgIHZhciB4MiA9IGxocy5yZWRNdWwocmhzLnJlZEludm0oKSk7XG4gICAgaWYgKHgyLmNtcCh0aGlzLnplcm8pID09PSAwKSB7XG4gICAgICAgIGlmIChvZGQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9pbnQodGhpcy56ZXJvLCB5KTtcbiAgICB9XG4gICAgdmFyIHggPSB4Mi5yZWRTcXJ0KCk7XG4gICAgaWYgKHgucmVkU3FyKCkucmVkU3ViKHgyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG4gICAgaWYgKHguZnJvbVJlZCgpLmlzT2RkKCkgIT09IG9kZClcbiAgICAgICAgeCA9IHgucmVkTmVnKCk7XG4gICAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gICAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcG9pbnQubm9ybWFsaXplKCk7XG4gICAgdmFyIHgyID0gcG9pbnQueC5yZWRTcXIoKTtcbiAgICB2YXIgeTIgPSBwb2ludC55LnJlZFNxcigpO1xuICAgIHZhciBsaHMgPSB4Mi5yZWRNdWwodGhpcy5hKS5yZWRBZGQoeTIpO1xuICAgIHZhciByaHMgPSB0aGlzLmMyLnJlZE11bCh0aGlzLm9uZS5yZWRBZGQodGhpcy5kLnJlZE11bCh4MikucmVkTXVsKHkyKSkpO1xuICAgIHJldHVybiBsaHMuY21wKHJocykgPT09IDA7XG59O1xuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHksIHosIHQpIHtcbiAgICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICAgIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnggPSB0aGlzLmN1cnZlLnplcm87XG4gICAgICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgICAgICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgICAgICAgdGhpcy50ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgICAgICB0aGlzLnpPbmUgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICAgICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICAgICAgdGhpcy56ID0geiA/IG5ldyBCTih6LCAxNikgOiB0aGlzLmN1cnZlLm9uZTtcbiAgICAgICAgdGhpcy50ID0gdCAmJiBuZXcgQk4odCwgMTYpO1xuICAgICAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgICAgICBpZiAoIXRoaXMueS5yZWQpXG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgICAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICAgICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgICAgICBpZiAodGhpcy50ICYmICF0aGlzLnQucmVkKVxuICAgICAgICAgICAgdGhpcy50ID0gdGhpcy50LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICAgICAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcbiAgICAgICAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQgJiYgIXRoaXMudCkge1xuICAgICAgICAgICAgdGhpcy50ID0gdGhpcy54LnJlZE11bCh0aGlzLnkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnpPbmUpXG4gICAgICAgICAgICAgICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaikge1xuICAgIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCB6LCB0KSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCB6LCB0KTtcbn07XG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmopIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSwgb2JqWzJdKTtcbn07XG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgICAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICAgIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnguY21wbigwKSA9PT0gMCAmJlxuICAgICAgICAodGhpcy55LmNtcCh0aGlzLnopID09PSAwIHx8XG4gICAgICAgICAgICAodGhpcy56T25lICYmIHRoaXMueS5jbXAodGhpcy5jdXJ2ZS5jKSA9PT0gMCkpO1xufTtcblBvaW50LnByb3RvdHlwZS5fZXh0RGJsID0gZnVuY3Rpb24gX2V4dERibCgpIHtcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICBjID0gYy5yZWRJQWRkKGMpO1xuICAgIHZhciBkID0gdGhpcy5jdXJ2ZS5fbXVsQShhKTtcbiAgICB2YXIgZSA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYik7XG4gICAgdmFyIGcgPSBkLnJlZEFkZChiKTtcbiAgICB2YXIgZiA9IGcucmVkU3ViKGMpO1xuICAgIHZhciBoID0gZC5yZWRTdWIoYik7XG4gICAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gICAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gICAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gICAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueiwgbnQpO1xufTtcblBvaW50LnByb3RvdHlwZS5fcHJvakRibCA9IGZ1bmN0aW9uIF9wcm9qRGJsKCkge1xuICAgIHZhciBiID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZFNxcigpO1xuICAgIHZhciBjID0gdGhpcy54LnJlZFNxcigpO1xuICAgIHZhciBkID0gdGhpcy55LnJlZFNxcigpO1xuICAgIHZhciBueDtcbiAgICB2YXIgbnk7XG4gICAgdmFyIG56O1xuICAgIHZhciBlO1xuICAgIHZhciBoO1xuICAgIHZhciBqO1xuICAgIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAgICAgZSA9IHRoaXMuY3VydmUuX211bEEoYyk7XG4gICAgICAgIHZhciBmID0gZS5yZWRBZGQoZCk7XG4gICAgICAgIGlmICh0aGlzLnpPbmUpIHtcbiAgICAgICAgICAgIG54ID0gYi5yZWRTdWIoYykucmVkU3ViKGQpLnJlZE11bChmLnJlZFN1Yih0aGlzLmN1cnZlLnR3bykpO1xuICAgICAgICAgICAgbnkgPSBmLnJlZE11bChlLnJlZFN1YihkKSk7XG4gICAgICAgICAgICBueiA9IGYucmVkU3FyKCkucmVkU3ViKGYpLnJlZFN1YihmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGggPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgICAgICAgICBqID0gZi5yZWRTdWIoaCkucmVkSVN1YihoKTtcbiAgICAgICAgICAgIG54ID0gYi5yZWRTdWIoYykucmVkSVN1YihkKS5yZWRNdWwoaik7XG4gICAgICAgICAgICBueSA9IGYucmVkTXVsKGUucmVkU3ViKGQpKTtcbiAgICAgICAgICAgIG56ID0gZi5yZWRNdWwoaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGUgPSBjLnJlZEFkZChkKTtcbiAgICAgICAgaCA9IHRoaXMuY3VydmUuX211bEModGhpcy56KS5yZWRTcXIoKTtcbiAgICAgICAgaiA9IGUucmVkU3ViKGgpLnJlZFN1YihoKTtcbiAgICAgICAgbnggPSB0aGlzLmN1cnZlLl9tdWxDKGIucmVkSVN1YihlKSkucmVkTXVsKGopO1xuICAgICAgICBueSA9IHRoaXMuY3VydmUuX211bEMoZSkucmVkTXVsKGMucmVkSVN1YihkKSk7XG4gICAgICAgIG56ID0gZS5yZWRNdWwoaik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnopO1xufTtcblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gICAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dERibCgpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2pEYmwoKTtcbn07XG5Qb2ludC5wcm90b3R5cGUuX2V4dEFkZCA9IGZ1bmN0aW9uIF9leHRBZGQocCkge1xuICAgIHZhciBhID0gdGhpcy55LnJlZFN1Yih0aGlzLngpLnJlZE11bChwLnkucmVkU3ViKHAueCkpO1xuICAgIHZhciBiID0gdGhpcy55LnJlZEFkZCh0aGlzLngpLnJlZE11bChwLnkucmVkQWRkKHAueCkpO1xuICAgIHZhciBjID0gdGhpcy50LnJlZE11bCh0aGlzLmN1cnZlLmRkKS5yZWRNdWwocC50KTtcbiAgICB2YXIgZCA9IHRoaXMuei5yZWRNdWwocC56LnJlZEFkZChwLnopKTtcbiAgICB2YXIgZSA9IGIucmVkU3ViKGEpO1xuICAgIHZhciBmID0gZC5yZWRTdWIoYyk7XG4gICAgdmFyIGcgPSBkLnJlZEFkZChjKTtcbiAgICB2YXIgaCA9IGIucmVkQWRkKGEpO1xuICAgIHZhciBueCA9IGUucmVkTXVsKGYpO1xuICAgIHZhciBueSA9IGcucmVkTXVsKGgpO1xuICAgIHZhciBudCA9IGUucmVkTXVsKGgpO1xuICAgIHZhciBueiA9IGYucmVkTXVsKGcpO1xuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5Qb2ludC5wcm90b3R5cGUuX3Byb2pBZGQgPSBmdW5jdGlvbiBfcHJvakFkZChwKSB7XG4gICAgdmFyIGEgPSB0aGlzLnoucmVkTXVsKHAueik7XG4gICAgdmFyIGIgPSBhLnJlZFNxcigpO1xuICAgIHZhciBjID0gdGhpcy54LnJlZE11bChwLngpO1xuICAgIHZhciBkID0gdGhpcy55LnJlZE11bChwLnkpO1xuICAgIHZhciBlID0gdGhpcy5jdXJ2ZS5kLnJlZE11bChjKS5yZWRNdWwoZCk7XG4gICAgdmFyIGYgPSBiLnJlZFN1YihlKTtcbiAgICB2YXIgZyA9IGIucmVkQWRkKGUpO1xuICAgIHZhciB0bXAgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkTXVsKHAueC5yZWRBZGQocC55KSkucmVkSVN1YihjKS5yZWRJU3ViKGQpO1xuICAgIHZhciBueCA9IGEucmVkTXVsKGYpLnJlZE11bCh0bXApO1xuICAgIHZhciBueTtcbiAgICB2YXIgbno7XG4gICAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgICAgICBueSA9IGEucmVkTXVsKGcpLnJlZE11bChkLnJlZFN1Yih0aGlzLmN1cnZlLl9tdWxBKGMpKSk7XG4gICAgICAgIG56ID0gZi5yZWRNdWwoZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBueSA9IGEucmVkTXVsKGcpLnJlZE11bChkLnJlZFN1YihjKSk7XG4gICAgICAgIG56ID0gdGhpcy5jdXJ2ZS5fbXVsQyhmKS5yZWRNdWwoZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnopO1xufTtcblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dEFkZChwKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9qQWRkKHApO1xufTtcblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICAgIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwLCBrMikge1xuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIFt0aGlzLCBwXSwgW2sxLCBrMl0sIDIsIGZhbHNlKTtcbn07XG5Qb2ludC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uIGptdWxBZGQoazEsIHAsIGsyKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgW3RoaXMsIHBdLCBbazEsIGsyXSwgMiwgdHJ1ZSk7XG59O1xuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICBpZiAodGhpcy56T25lKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB2YXIgemkgPSB0aGlzLnoucmVkSW52bSgpO1xuICAgIHRoaXMueCA9IHRoaXMueC5yZWRNdWwoemkpO1xuICAgIHRoaXMueSA9IHRoaXMueS5yZWRNdWwoemkpO1xuICAgIGlmICh0aGlzLnQpXG4gICAgICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwoemkpO1xuICAgIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMuek9uZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTmVnKCksIHRoaXMueSwgdGhpcy56LCB0aGlzLnQgJiYgdGhpcy50LnJlZE5lZygpKTtcbn07XG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gICAgdGhpcy5ub3JtYWxpemUoKTtcbiAgICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gICAgdGhpcy5ub3JtYWxpemUoKTtcbiAgICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fFxuICAgICAgICB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5nZXRZKCkuY21wKG90aGVyLmdldFkoKSkgPT09IDA7XG59O1xuUG9pbnQucHJvdG90eXBlLmVxWFRvUCA9IGZ1bmN0aW9uIGVxWFRvUCh4KSB7XG4gICAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHRoaXMueik7XG4gICAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gICAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHRoaXMueik7XG4gICAgZm9yICg7Oykge1xuICAgICAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByeC5yZWRJQWRkKHQpO1xuICAgICAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuUG9pbnQucHJvdG90eXBlLnRvUCA9IFBvaW50LnByb3RvdHlwZS5ub3JtYWxpemU7XG5Qb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBQb2ludC5wcm90b3R5cGUuYWRkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWR3YXJkcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/edwards.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/index.js':
    /*!***********************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/index.js ***!
  \***********************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nvar curve = exports;\ncurve.base = __webpack_require__(/*! ./base */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/base.js");\ncurve.short = __webpack_require__(/*! ./short */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/short.js");\ncurve.mont = __webpack_require__(/*! ./mont */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/mont.js");\ncurve.edwards = __webpack_require__(/*! ./edwards */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/edwards.js");\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2N1cnZlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0ZBQVE7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLHNGQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxvRkFBUTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBVztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9lbGxpcHRpYy9jdXJ2ZS9pbmRleC5qcz9lYThmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBjdXJ2ZSA9IGV4cG9ydHM7XG5jdXJ2ZS5iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jdXJ2ZS5zaG9ydCA9IHJlcXVpcmUoJy4vc2hvcnQnKTtcbmN1cnZlLm1vbnQgPSByZXF1aXJlKCcuL21vbnQnKTtcbmN1cnZlLmVkd2FyZHMgPSByZXF1aXJlKCcuL2Vkd2FyZHMnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/mont.js':
    /*!**********************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/mont.js ***!
  \**********************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/base.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nfunction MontCurve(conf) {\n    Base.call(this, 'mont', conf);\n    this.a = new BN(conf.a, 16).toRed(this.red);\n    this.b = new BN(conf.b, 16).toRed(this.red);\n    this.i4 = new BN(4).toRed(this.red).redInvm();\n    this.two = new BN(2).toRed(this.red);\n    this.a24 = this.i4.redMul(this.a.redAdd(this.two));\n}\ninherits(MontCurve, Base);\nmodule.exports = MontCurve;\nMontCurve.prototype.validate = function validate(point) {\n    var x = point.normalize().x;\n    var x2 = x.redSqr();\n    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);\n    var y = rhs.redSqrt();\n    return y.redSqr().cmp(rhs) === 0;\n};\nfunction Point(curve, x, z) {\n    Base.BasePoint.call(this, curve, 'projective');\n    if (x === null && z === null) {\n        this.x = this.curve.one;\n        this.z = this.curve.zero;\n    }\n    else {\n        this.x = new BN(x, 16);\n        this.z = new BN(z, 16);\n        if (!this.x.red)\n            this.x = this.x.toRed(this.curve.red);\n        if (!this.z.red)\n            this.z = this.z.toRed(this.curve.red);\n    }\n}\ninherits(Point, Base.BasePoint);\nMontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n    return this.point(utils.toArray(bytes, enc), 1);\n};\nMontCurve.prototype.point = function point(x, z) {\n    return new Point(this, x, z);\n};\nMontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\n    return Point.fromJSON(this, obj);\n};\nPoint.prototype.precompute = function precompute() {\n};\nPoint.prototype._encode = function _encode() {\n    return this.getX().toArray('be', this.curve.p.byteLength());\n};\nPoint.fromJSON = function fromJSON(curve, obj) {\n    return new Point(curve, obj[0], obj[1] || curve.one);\n};\nPoint.prototype.inspect = function inspect() {\n    if (this.isInfinity())\n        return '<EC Point Infinity>';\n    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n        ' z: ' + this.z.fromRed().toString(16, 2) + '>';\n};\nPoint.prototype.isInfinity = function isInfinity() {\n    return this.z.cmpn(0) === 0;\n};\nPoint.prototype.dbl = function dbl() {\n    var a = this.x.redAdd(this.z);\n    var aa = a.redSqr();\n    var b = this.x.redSub(this.z);\n    var bb = b.redSqr();\n    var c = aa.redSub(bb);\n    var nx = aa.redMul(bb);\n    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));\n    return this.curve.point(nx, nz);\n};\nPoint.prototype.add = function add() {\n    throw new Error('Not supported on Montgomery curve');\n};\nPoint.prototype.diffAdd = function diffAdd(p, diff) {\n    var a = this.x.redAdd(this.z);\n    var b = this.x.redSub(this.z);\n    var c = p.x.redAdd(p.z);\n    var d = p.x.redSub(p.z);\n    var da = d.redMul(a);\n    var cb = c.redMul(b);\n    var nx = diff.z.redMul(da.redAdd(cb).redSqr());\n    var nz = diff.x.redMul(da.redISub(cb).redSqr());\n    return this.curve.point(nx, nz);\n};\nPoint.prototype.mul = function mul(k) {\n    var t = k.clone();\n    var a = this;\n    var b = this.curve.point(null, null);\n    var c = this;\n    for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))\n        bits.push(t.andln(1));\n    for (var i = bits.length - 1; i >= 0; i--) {\n        if (bits[i] === 0) {\n            a = a.diffAdd(b, c);\n            b = b.dbl();\n        }\n        else {\n            b = a.diffAdd(b, c);\n            a = a.dbl();\n        }\n    }\n    return b;\n};\nPoint.prototype.mulAdd = function mulAdd() {\n    throw new Error('Not supported on Montgomery curve');\n};\nPoint.prototype.jumlAdd = function jumlAdd() {\n    throw new Error('Not supported on Montgomery curve');\n};\nPoint.prototype.eq = function eq(other) {\n    return this.getX().cmp(other.getX()) === 0;\n};\nPoint.prototype.normalize = function normalize() {\n    this.x = this.x.redMul(this.z.redInvm());\n    this.z = this.curve.one;\n    return this;\n};\nPoint.prototype.getX = function getX() {\n    this.normalize();\n    return this.x.fromRed();\n};\n//# sourceMappingURL=mont.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2N1cnZlL21vbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixTQUFTLG1CQUFPLENBQUMsMERBQWM7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLDJEQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxvRkFBUTtBQUMzQixZQUFZLG1CQUFPLENBQUMsaUZBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2N1cnZlL21vbnQuanM/NGU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcy9saWIvYm4nKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmZ1bmN0aW9uIE1vbnRDdXJ2ZShjb25mKSB7XG4gICAgQmFzZS5jYWxsKHRoaXMsICdtb250JywgY29uZik7XG4gICAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICAgIHRoaXMuaTQgPSBuZXcgQk4oNCkudG9SZWQodGhpcy5yZWQpLnJlZEludm0oKTtcbiAgICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG4gICAgdGhpcy5hMjQgPSB0aGlzLmk0LnJlZE11bCh0aGlzLmEucmVkQWRkKHRoaXMudHdvKSk7XG59XG5pbmhlcml0cyhNb250Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBNb250Q3VydmU7XG5Nb250Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgICB2YXIgeCA9IHBvaW50Lm5vcm1hbGl6ZSgpLng7XG4gICAgdmFyIHgyID0geC5yZWRTcXIoKTtcbiAgICB2YXIgcmhzID0geDIucmVkTXVsKHgpLnJlZEFkZCh4Mi5yZWRNdWwodGhpcy5hKSkucmVkQWRkKHgpO1xuICAgIHZhciB5ID0gcmhzLnJlZFNxcnQoKTtcbiAgICByZXR1cm4geS5yZWRTcXIoKS5jbXAocmhzKSA9PT0gMDtcbn07XG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeikge1xuICAgIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gICAgaWYgKHggPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICAgICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICAgICAgdGhpcy56ID0gbmV3IEJOKHosIDE2KTtcbiAgICAgICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICAgICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuTW9udEN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludCh1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpLCAxKTtcbn07XG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeikge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeik7XG59O1xuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqKTtcbn07XG5Qb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG59O1xuUG9pbnQucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBfZW5jb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCkpO1xufTtcblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICAgIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdIHx8IGN1cnZlLm9uZSk7XG59O1xuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICAgICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gICAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gICAgdmFyIGFhID0gYS5yZWRTcXIoKTtcbiAgICB2YXIgYiA9IHRoaXMueC5yZWRTdWIodGhpcy56KTtcbiAgICB2YXIgYmIgPSBiLnJlZFNxcigpO1xuICAgIHZhciBjID0gYWEucmVkU3ViKGJiKTtcbiAgICB2YXIgbnggPSBhYS5yZWRNdWwoYmIpO1xuICAgIHZhciBueiA9IGMucmVkTXVsKGJiLnJlZEFkZCh0aGlzLmN1cnZlLmEyNC5yZWRNdWwoYykpKTtcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnopO1xufTtcblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5Qb2ludC5wcm90b3R5cGUuZGlmZkFkZCA9IGZ1bmN0aW9uIGRpZmZBZGQocCwgZGlmZikge1xuICAgIHZhciBhID0gdGhpcy54LnJlZEFkZCh0aGlzLnopO1xuICAgIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAgIHZhciBjID0gcC54LnJlZEFkZChwLnopO1xuICAgIHZhciBkID0gcC54LnJlZFN1YihwLnopO1xuICAgIHZhciBkYSA9IGQucmVkTXVsKGEpO1xuICAgIHZhciBjYiA9IGMucmVkTXVsKGIpO1xuICAgIHZhciBueCA9IGRpZmYuei5yZWRNdWwoZGEucmVkQWRkKGNiKS5yZWRTcXIoKSk7XG4gICAgdmFyIG56ID0gZGlmZi54LnJlZE11bChkYS5yZWRJU3ViKGNiKS5yZWRTcXIoKSk7XG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgICB2YXIgdCA9IGsuY2xvbmUoKTtcbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuICAgIHZhciBjID0gdGhpcztcbiAgICBmb3IgKHZhciBiaXRzID0gW107IHQuY21wbigwKSAhPT0gMDsgdC5pdXNocm4oMSkpXG4gICAgICAgIGJpdHMucHVzaCh0LmFuZGxuKDEpKTtcbiAgICBmb3IgKHZhciBpID0gYml0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoYml0c1tpXSA9PT0gMCkge1xuICAgICAgICAgICAgYSA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgICAgICAgIGIgPSBiLmRibCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYiA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgICAgICAgIGEgPSBhLmRibCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiO1xufTtcblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5Qb2ludC5wcm90b3R5cGUuanVtbEFkZCA9IGZ1bmN0aW9uIGp1bWxBZGQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMDtcbn07XG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICAgIHRoaXMueCA9IHRoaXMueC5yZWRNdWwodGhpcy56LnJlZEludm0oKSk7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICAgIHRoaXMubm9ybWFsaXplKCk7XG4gICAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9udC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/mont.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/short.js':
    /*!***********************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/short.js ***!
  \***********************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/base.js\");\nvar assert = utils.assert;\nfunction ShortCurve(conf) {\n    Base.call(this, 'short', conf);\n    this.a = new BN(conf.a, 16).toRed(this.red);\n    this.b = new BN(conf.b, 16).toRed(this.red);\n    this.tinv = this.two.redInvm();\n    this.zeroA = this.a.fromRed().cmpn(0) === 0;\n    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n    this.endo = this._getEndomorphism(conf);\n    this._endoWnafT1 = new Array(4);\n    this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n        return;\n    var beta;\n    var lambda;\n    if (conf.beta) {\n        beta = new BN(conf.beta, 16).toRed(this.red);\n    }\n    else {\n        var betas = this._getEndoRoots(this.p);\n        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n        beta = beta.toRed(this.red);\n    }\n    if (conf.lambda) {\n        lambda = new BN(conf.lambda, 16);\n    }\n    else {\n        var lambdas = this._getEndoRoots(this.n);\n        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n            lambda = lambdas[0];\n        }\n        else {\n            lambda = lambdas[1];\n            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n        }\n    }\n    var basis;\n    if (conf.basis) {\n        basis = conf.basis.map(function (vec) {\n            return {\n                a: new BN(vec.a, 16),\n                b: new BN(vec.b, 16),\n            };\n        });\n    }\n    else {\n        basis = this._getEndoBasis(lambda);\n    }\n    return {\n        beta: beta,\n        lambda: lambda,\n        basis: basis,\n    };\n};\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n    var red = num === this.p ? this.red : BN.mont(num);\n    var tinv = new BN(2).toRed(red).redInvm();\n    var ntinv = tinv.redNeg();\n    var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n    var l1 = ntinv.redAdd(s).fromRed();\n    var l2 = ntinv.redSub(s).fromRed();\n    return [l1, l2];\n};\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n    var u = lambda;\n    var v = this.n.clone();\n    var x1 = new BN(1);\n    var y1 = new BN(0);\n    var x2 = new BN(0);\n    var y2 = new BN(1);\n    var a0;\n    var b0;\n    var a1;\n    var b1;\n    var a2;\n    var b2;\n    var prevR;\n    var i = 0;\n    var r;\n    var x;\n    while (u.cmpn(0) !== 0) {\n        var q = v.div(u);\n        r = v.sub(q.mul(u));\n        x = x2.sub(q.mul(x1));\n        var y = y2.sub(q.mul(y1));\n        if (!a1 && r.cmp(aprxSqrt) < 0) {\n            a0 = prevR.neg();\n            b0 = x1;\n            a1 = r.neg();\n            b1 = x;\n        }\n        else if (a1 && ++i === 2) {\n            break;\n        }\n        prevR = r;\n        v = u;\n        u = r;\n        x2 = x1;\n        x1 = x;\n        y2 = y1;\n        y1 = y;\n    }\n    a2 = r.neg();\n    b2 = x;\n    var len1 = a1.sqr().add(b1.sqr());\n    var len2 = a2.sqr().add(b2.sqr());\n    if (len2.cmp(len1) >= 0) {\n        a2 = a0;\n        b2 = b0;\n    }\n    if (a1.negative) {\n        a1 = a1.neg();\n        b1 = b1.neg();\n    }\n    if (a2.negative) {\n        a2 = a2.neg();\n        b2 = b2.neg();\n    }\n    return [\n        { a: a1, b: b1 },\n        { a: a2, b: b2 },\n    ];\n};\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n    var basis = this.endo.basis;\n    var v1 = basis[0];\n    var v2 = basis[1];\n    var c1 = v2.b.mul(k).divRound(this.n);\n    var c2 = v1.b.neg().mul(k).divRound(this.n);\n    var p1 = c1.mul(v1.a);\n    var p2 = c2.mul(v2.a);\n    var q1 = c1.mul(v1.b);\n    var q2 = c2.mul(v2.b);\n    var k1 = k.sub(p1).sub(p2);\n    var k2 = q1.add(q2).neg();\n    return { k1: k1, k2: k2 };\n};\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n    x = new BN(x, 16);\n    if (!x.red)\n        x = x.toRed(this.red);\n    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n    var y = y2.redSqrt();\n    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n        throw new Error('invalid point');\n    var isOdd = y.fromRed().isOdd();\n    if (odd && !isOdd || !odd && isOdd)\n        y = y.redNeg();\n    return this.point(x, y);\n};\nShortCurve.prototype.validate = function validate(point) {\n    if (point.inf)\n        return true;\n    var x = point.x;\n    var y = point.y;\n    var ax = this.a.redMul(x);\n    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n    return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n        var npoints = this._endoWnafT1;\n        var ncoeffs = this._endoWnafT2;\n        for (var i = 0; i < points.length; i++) {\n            var split = this._endoSplit(coeffs[i]);\n            var p = points[i];\n            var beta = p._getBeta();\n            if (split.k1.negative) {\n                split.k1.ineg();\n                p = p.neg(true);\n            }\n            if (split.k2.negative) {\n                split.k2.ineg();\n                beta = beta.neg(true);\n            }\n            npoints[i * 2] = p;\n            npoints[i * 2 + 1] = beta;\n            ncoeffs[i * 2] = split.k1;\n            ncoeffs[i * 2 + 1] = split.k2;\n        }\n        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n        for (var j = 0; j < i * 2; j++) {\n            npoints[j] = null;\n            ncoeffs[j] = null;\n        }\n        return res;\n    };\nfunction Point(curve, x, y, isRed) {\n    Base.BasePoint.call(this, curve, 'affine');\n    if (x === null && y === null) {\n        this.x = null;\n        this.y = null;\n        this.inf = true;\n    }\n    else {\n        this.x = new BN(x, 16);\n        this.y = new BN(y, 16);\n        if (isRed) {\n            this.x.forceRed(this.curve.red);\n            this.y.forceRed(this.curve.red);\n        }\n        if (!this.x.red)\n            this.x = this.x.toRed(this.curve.red);\n        if (!this.y.red)\n            this.y = this.y.toRed(this.curve.red);\n        this.inf = false;\n    }\n}\ninherits(Point, Base.BasePoint);\nShortCurve.prototype.point = function point(x, y, isRed) {\n    return new Point(this, x, y, isRed);\n};\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n    return Point.fromJSON(this, obj, red);\n};\nPoint.prototype._getBeta = function _getBeta() {\n    if (!this.curve.endo)\n        return;\n    var pre = this.precomputed;\n    if (pre && pre.beta)\n        return pre.beta;\n    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n    if (pre) {\n        var curve = this.curve;\n        var endoMul = function (p) {\n            return curve.point(p.x.redMul(curve.endo.beta), p.y);\n        };\n        pre.beta = beta;\n        beta.precomputed = {\n            beta: null,\n            naf: pre.naf && {\n                wnd: pre.naf.wnd,\n                points: pre.naf.points.map(endoMul),\n            },\n            doubles: pre.doubles && {\n                step: pre.doubles.step,\n                points: pre.doubles.points.map(endoMul),\n            },\n        };\n    }\n    return beta;\n};\nPoint.prototype.toJSON = function toJSON() {\n    if (!this.precomputed)\n        return [this.x, this.y];\n    return [this.x, this.y, this.precomputed && {\n            doubles: this.precomputed.doubles && {\n                step: this.precomputed.doubles.step,\n                points: this.precomputed.doubles.points.slice(1),\n            },\n            naf: this.precomputed.naf && {\n                wnd: this.precomputed.naf.wnd,\n                points: this.precomputed.naf.points.slice(1),\n            },\n        }];\n};\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n    if (typeof obj === 'string')\n        obj = JSON.parse(obj);\n    var res = curve.point(obj[0], obj[1], red);\n    if (!obj[2])\n        return res;\n    function obj2point(obj) {\n        return curve.point(obj[0], obj[1], red);\n    }\n    var pre = obj[2];\n    res.precomputed = {\n        beta: null,\n        doubles: pre.doubles && {\n            step: pre.doubles.step,\n            points: [res].concat(pre.doubles.points.map(obj2point)),\n        },\n        naf: pre.naf && {\n            wnd: pre.naf.wnd,\n            points: [res].concat(pre.naf.points.map(obj2point)),\n        },\n    };\n    return res;\n};\nPoint.prototype.inspect = function inspect() {\n    if (this.isInfinity())\n        return '<EC Point Infinity>';\n    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n        ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\nPoint.prototype.isInfinity = function isInfinity() {\n    return this.inf;\n};\nPoint.prototype.add = function add(p) {\n    if (this.inf)\n        return p;\n    if (p.inf)\n        return this;\n    if (this.eq(p))\n        return this.dbl();\n    if (this.neg().eq(p))\n        return this.curve.point(null, null);\n    if (this.x.cmp(p.x) === 0)\n        return this.curve.point(null, null);\n    var c = this.y.redSub(p.y);\n    if (c.cmpn(0) !== 0)\n        c = c.redMul(this.x.redSub(p.x).redInvm());\n    var nx = c.redSqr().redISub(this.x).redISub(p.x);\n    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n};\nPoint.prototype.dbl = function dbl() {\n    if (this.inf)\n        return this;\n    var ys1 = this.y.redAdd(this.y);\n    if (ys1.cmpn(0) === 0)\n        return this.curve.point(null, null);\n    var a = this.curve.a;\n    var x2 = this.x.redSqr();\n    var dyinv = ys1.redInvm();\n    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n    var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n};\nPoint.prototype.getX = function getX() {\n    return this.x.fromRed();\n};\nPoint.prototype.getY = function getY() {\n    return this.y.fromRed();\n};\nPoint.prototype.mul = function mul(k) {\n    k = new BN(k, 16);\n    if (this.isInfinity())\n        return this;\n    else if (this._hasDoubles(k))\n        return this.curve._fixedNafMul(this, k);\n    else if (this.curve.endo)\n        return this.curve._endoWnafMulAdd([this], [k]);\n    else\n        return this.curve._wnafMul(this, k);\n};\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n    var points = [this, p2];\n    var coeffs = [k1, k2];\n    if (this.curve.endo)\n        return this.curve._endoWnafMulAdd(points, coeffs);\n    else\n        return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n    var points = [this, p2];\n    var coeffs = [k1, k2];\n    if (this.curve.endo)\n        return this.curve._endoWnafMulAdd(points, coeffs, true);\n    else\n        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\nPoint.prototype.eq = function eq(p) {\n    return this === p ||\n        this.inf === p.inf &&\n            (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\nPoint.prototype.neg = function neg(_precompute) {\n    if (this.inf)\n        return this;\n    var res = this.curve.point(this.x, this.y.redNeg());\n    if (_precompute && this.precomputed) {\n        var pre = this.precomputed;\n        var negate = function (p) {\n            return p.neg();\n        };\n        res.precomputed = {\n            naf: pre.naf && {\n                wnd: pre.naf.wnd,\n                points: pre.naf.points.map(negate),\n            },\n            doubles: pre.doubles && {\n                step: pre.doubles.step,\n                points: pre.doubles.points.map(negate),\n            },\n        };\n    }\n    return res;\n};\nPoint.prototype.toJ = function toJ() {\n    if (this.inf)\n        return this.curve.jpoint(null, null, null);\n    var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n    return res;\n};\nfunction JPoint(curve, x, y, z) {\n    Base.BasePoint.call(this, curve, 'jacobian');\n    if (x === null && y === null && z === null) {\n        this.x = this.curve.one;\n        this.y = this.curve.one;\n        this.z = new BN(0);\n    }\n    else {\n        this.x = new BN(x, 16);\n        this.y = new BN(y, 16);\n        this.z = new BN(z, 16);\n    }\n    if (!this.x.red)\n        this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n        this.y = this.y.toRed(this.curve.red);\n    if (!this.z.red)\n        this.z = this.z.toRed(this.curve.red);\n    this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n    return new JPoint(this, x, y, z);\n};\nJPoint.prototype.toP = function toP() {\n    if (this.isInfinity())\n        return this.curve.point(null, null);\n    var zinv = this.z.redInvm();\n    var zinv2 = zinv.redSqr();\n    var ax = this.x.redMul(zinv2);\n    var ay = this.y.redMul(zinv2).redMul(zinv);\n    return this.curve.point(ax, ay);\n};\nJPoint.prototype.neg = function neg() {\n    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\nJPoint.prototype.add = function add(p) {\n    if (this.isInfinity())\n        return p;\n    if (p.isInfinity())\n        return this;\n    var pz2 = p.z.redSqr();\n    var z2 = this.z.redSqr();\n    var u1 = this.x.redMul(pz2);\n    var u2 = p.x.redMul(z2);\n    var s1 = this.y.redMul(pz2.redMul(p.z));\n    var s2 = p.y.redMul(z2.redMul(this.z));\n    var h = u1.redSub(u2);\n    var r = s1.redSub(s2);\n    if (h.cmpn(0) === 0) {\n        if (r.cmpn(0) !== 0)\n            return this.curve.jpoint(null, null, null);\n        else\n            return this.dbl();\n    }\n    var h2 = h.redSqr();\n    var h3 = h2.redMul(h);\n    var v = u1.redMul(h2);\n    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n    var nz = this.z.redMul(p.z).redMul(h);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n    if (this.isInfinity())\n        return p.toJ();\n    if (p.isInfinity())\n        return this;\n    var z2 = this.z.redSqr();\n    var u1 = this.x;\n    var u2 = p.x.redMul(z2);\n    var s1 = this.y;\n    var s2 = p.y.redMul(z2).redMul(this.z);\n    var h = u1.redSub(u2);\n    var r = s1.redSub(s2);\n    if (h.cmpn(0) === 0) {\n        if (r.cmpn(0) !== 0)\n            return this.curve.jpoint(null, null, null);\n        else\n            return this.dbl();\n    }\n    var h2 = h.redSqr();\n    var h3 = h2.redMul(h);\n    var v = u1.redMul(h2);\n    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n    var nz = this.z.redMul(h);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.dblp = function dblp(pow) {\n    if (pow === 0)\n        return this;\n    if (this.isInfinity())\n        return this;\n    if (!pow)\n        return this.dbl();\n    var i;\n    if (this.curve.zeroA || this.curve.threeA) {\n        var r = this;\n        for (i = 0; i < pow; i++)\n            r = r.dbl();\n        return r;\n    }\n    var a = this.curve.a;\n    var tinv = this.curve.tinv;\n    var jx = this.x;\n    var jy = this.y;\n    var jz = this.z;\n    var jz4 = jz.redSqr().redSqr();\n    var jyd = jy.redAdd(jy);\n    for (i = 0; i < pow; i++) {\n        var jx2 = jx.redSqr();\n        var jyd2 = jyd.redSqr();\n        var jyd4 = jyd2.redSqr();\n        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n        var t1 = jx.redMul(jyd2);\n        var nx = c.redSqr().redISub(t1.redAdd(t1));\n        var t2 = t1.redISub(nx);\n        var dny = c.redMul(t2);\n        dny = dny.redIAdd(dny).redISub(jyd4);\n        var nz = jyd.redMul(jz);\n        if (i + 1 < pow)\n            jz4 = jz4.redMul(jyd4);\n        jx = nx;\n        jz = nz;\n        jyd = dny;\n    }\n    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\nJPoint.prototype.dbl = function dbl() {\n    if (this.isInfinity())\n        return this;\n    if (this.curve.zeroA)\n        return this._zeroDbl();\n    else if (this.curve.threeA)\n        return this._threeDbl();\n    else\n        return this._dbl();\n};\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n    var nx;\n    var ny;\n    var nz;\n    if (this.zOne) {\n        var xx = this.x.redSqr();\n        var yy = this.y.redSqr();\n        var yyyy = yy.redSqr();\n        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        var m = xx.redAdd(xx).redIAdd(xx);\n        var t = m.redSqr().redISub(s).redISub(s);\n        var yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        nx = t;\n        ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n        nz = this.y.redAdd(this.y);\n    }\n    else {\n        var a = this.x.redSqr();\n        var b = this.y.redSqr();\n        var c = b.redSqr();\n        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n        d = d.redIAdd(d);\n        var e = a.redAdd(a).redIAdd(a);\n        var f = e.redSqr();\n        var c8 = c.redIAdd(c);\n        c8 = c8.redIAdd(c8);\n        c8 = c8.redIAdd(c8);\n        nx = f.redISub(d).redISub(d);\n        ny = e.redMul(d.redISub(nx)).redISub(c8);\n        nz = this.y.redMul(this.z);\n        nz = nz.redIAdd(nz);\n    }\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype._threeDbl = function _threeDbl() {\n    var nx;\n    var ny;\n    var nz;\n    if (this.zOne) {\n        var xx = this.x.redSqr();\n        var yy = this.y.redSqr();\n        var yyyy = yy.redSqr();\n        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n        var t = m.redSqr().redISub(s).redISub(s);\n        nx = t;\n        var yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n        nz = this.y.redAdd(this.y);\n    }\n    else {\n        var delta = this.z.redSqr();\n        var gamma = this.y.redSqr();\n        var beta = this.x.redMul(gamma);\n        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n        alpha = alpha.redAdd(alpha).redIAdd(alpha);\n        var beta4 = beta.redIAdd(beta);\n        beta4 = beta4.redIAdd(beta4);\n        var beta8 = beta4.redAdd(beta4);\n        nx = alpha.redSqr().redISub(beta8);\n        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n        var ggamma8 = gamma.redSqr();\n        ggamma8 = ggamma8.redIAdd(ggamma8);\n        ggamma8 = ggamma8.redIAdd(ggamma8);\n        ggamma8 = ggamma8.redIAdd(ggamma8);\n        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n    }\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype._dbl = function _dbl() {\n    var a = this.curve.a;\n    var jx = this.x;\n    var jy = this.y;\n    var jz = this.z;\n    var jz4 = jz.redSqr().redSqr();\n    var jx2 = jx.redSqr();\n    var jy2 = jy.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n    var jxd4 = jx.redAdd(jx);\n    jxd4 = jxd4.redIAdd(jxd4);\n    var t1 = jxd4.redMul(jy2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var jyd8 = jy2.redSqr();\n    jyd8 = jyd8.redIAdd(jyd8);\n    jyd8 = jyd8.redIAdd(jyd8);\n    jyd8 = jyd8.redIAdd(jyd8);\n    var ny = c.redMul(t2).redISub(jyd8);\n    var nz = jy.redAdd(jy).redMul(jz);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.trpl = function trpl() {\n    if (!this.curve.zeroA)\n        return this.dbl().add(this);\n    var xx = this.x.redSqr();\n    var yy = this.y.redSqr();\n    var zz = this.z.redSqr();\n    var yyyy = yy.redSqr();\n    var m = xx.redAdd(xx).redIAdd(xx);\n    var mm = m.redSqr();\n    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    e = e.redIAdd(e);\n    e = e.redAdd(e).redIAdd(e);\n    e = e.redISub(mm);\n    var ee = e.redSqr();\n    var t = yyyy.redIAdd(yyyy);\n    t = t.redIAdd(t);\n    t = t.redIAdd(t);\n    t = t.redIAdd(t);\n    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n    var yyu4 = yy.redMul(u);\n    yyu4 = yyu4.redIAdd(yyu4);\n    yyu4 = yyu4.redIAdd(yyu4);\n    var nx = this.x.redMul(ee).redISub(yyu4);\n    nx = nx.redIAdd(nx);\n    nx = nx.redIAdd(nx);\n    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n    ny = ny.redIAdd(ny);\n    ny = ny.redIAdd(ny);\n    ny = ny.redIAdd(ny);\n    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.mul = function mul(k, kbase) {\n    k = new BN(k, kbase);\n    return this.curve._wnafMul(this, k);\n};\nJPoint.prototype.eq = function eq(p) {\n    if (p.type === 'affine')\n        return this.eq(p.toJ());\n    if (this === p)\n        return true;\n    var z2 = this.z.redSqr();\n    var pz2 = p.z.redSqr();\n    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n        return false;\n    var z3 = z2.redMul(this.z);\n    var pz3 = pz2.redMul(p.z);\n    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\nJPoint.prototype.eqXToP = function eqXToP(x) {\n    var zs = this.z.redSqr();\n    var rx = x.toRed(this.curve.red).redMul(zs);\n    if (this.x.cmp(rx) === 0)\n        return true;\n    var xc = x.clone();\n    var t = this.curve.redN.redMul(zs);\n    for (;;) {\n        xc.iadd(this.curve.n);\n        if (xc.cmp(this.curve.p) >= 0)\n            return false;\n        rx.redIAdd(t);\n        if (this.x.cmp(rx) === 0)\n            return true;\n    }\n};\nJPoint.prototype.inspect = function inspect() {\n    if (this.isInfinity())\n        return '<EC JPoint Infinity>';\n    return '<EC JPoint x: ' + this.x.toString(16, 2) +\n        ' y: ' + this.y.toString(16, 2) +\n        ' z: ' + this.z.toString(16, 2) + '>';\n};\nJPoint.prototype.isInfinity = function isInfinity() {\n    return this.z.cmpn(0) === 0;\n};\n//# sourceMappingURL=short.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2N1cnZlL3Nob3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsWUFBWSxtQkFBTyxDQUFDLGlGQUFVO0FBQzlCLFNBQVMsbUJBQU8sQ0FBQywwREFBYztBQUMvQixlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLG9GQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9lbGxpcHRpYy9jdXJ2ZS9zaG9ydC5qcz82YzFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcy9saWIvYm4nKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbmZ1bmN0aW9uIFNob3J0Q3VydmUoY29uZikge1xuICAgIEJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcbiAgICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICAgIHRoaXMuYiA9IG5ldyBCTihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gICAgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpO1xuICAgIHRoaXMuemVyb0EgPSB0aGlzLmEuZnJvbVJlZCgpLmNtcG4oMCkgPT09IDA7XG4gICAgdGhpcy50aHJlZUEgPSB0aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpID09PSAwO1xuICAgIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTtcbiAgICB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpO1xuICAgIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG59XG5pbmhlcml0cyhTaG9ydEN1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gU2hvcnRDdXJ2ZTtcblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcbiAgICBpZiAoIXRoaXMuemVyb0EgfHwgIXRoaXMuZyB8fCAhdGhpcy5uIHx8IHRoaXMucC5tb2RuKDMpICE9PSAxKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGJldGE7XG4gICAgdmFyIGxhbWJkYTtcbiAgICBpZiAoY29uZi5iZXRhKSB7XG4gICAgICAgIGJldGEgPSBuZXcgQk4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGJldGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7XG4gICAgICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG4gICAgICAgIGJldGEgPSBiZXRhLnRvUmVkKHRoaXMucmVkKTtcbiAgICB9XG4gICAgaWYgKGNvbmYubGFtYmRhKSB7XG4gICAgICAgIGxhbWJkYSA9IG5ldyBCTihjb25mLmxhbWJkYSwgMTYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcbiAgICAgICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuICAgICAgICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMV07XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5nLm11bChsYW1iZGEpLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBiYXNpcztcbiAgICBpZiAoY29uZi5iYXNpcykge1xuICAgICAgICBiYXNpcyA9IGNvbmYuYmFzaXMubWFwKGZ1bmN0aW9uICh2ZWMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYTogbmV3IEJOKHZlYy5hLCAxNiksXG4gICAgICAgICAgICAgICAgYjogbmV3IEJOKHZlYy5iLCAxNiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJhc2lzID0gdGhpcy5fZ2V0RW5kb0Jhc2lzKGxhbWJkYSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGJldGE6IGJldGEsXG4gICAgICAgIGxhbWJkYTogbGFtYmRhLFxuICAgICAgICBiYXNpczogYmFzaXMsXG4gICAgfTtcbn07XG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgICB2YXIgcmVkID0gbnVtID09PSB0aGlzLnAgPyB0aGlzLnJlZCA6IEJOLm1vbnQobnVtKTtcbiAgICB2YXIgdGludiA9IG5ldyBCTigyKS50b1JlZChyZWQpLnJlZEludm0oKTtcbiAgICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuICAgIHZhciBzID0gbmV3IEJOKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcbiAgICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICAgIHZhciBsMiA9IG50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7XG4gICAgcmV0dXJuIFtsMSwgbDJdO1xufTtcblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAgIHZhciBhcHJ4U3FydCA9IHRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKSAvIDIpKTtcbiAgICB2YXIgdSA9IGxhbWJkYTtcbiAgICB2YXIgdiA9IHRoaXMubi5jbG9uZSgpO1xuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeTEgPSBuZXcgQk4oMCk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuICAgIHZhciB5MiA9IG5ldyBCTigxKTtcbiAgICB2YXIgYTA7XG4gICAgdmFyIGIwO1xuICAgIHZhciBhMTtcbiAgICB2YXIgYjE7XG4gICAgdmFyIGEyO1xuICAgIHZhciBiMjtcbiAgICB2YXIgcHJldlI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByO1xuICAgIHZhciB4O1xuICAgIHdoaWxlICh1LmNtcG4oMCkgIT09IDApIHtcbiAgICAgICAgdmFyIHEgPSB2LmRpdih1KTtcbiAgICAgICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICAgICAgeCA9IHgyLnN1YihxLm11bCh4MSkpO1xuICAgICAgICB2YXIgeSA9IHkyLnN1YihxLm11bCh5MSkpO1xuICAgICAgICBpZiAoIWExICYmIHIuY21wKGFwcnhTcXJ0KSA8IDApIHtcbiAgICAgICAgICAgIGEwID0gcHJldlIubmVnKCk7XG4gICAgICAgICAgICBiMCA9IHgxO1xuICAgICAgICAgICAgYTEgPSByLm5lZygpO1xuICAgICAgICAgICAgYjEgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGExICYmICsraSA9PT0gMikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlIgPSByO1xuICAgICAgICB2ID0gdTtcbiAgICAgICAgdSA9IHI7XG4gICAgICAgIHgyID0geDE7XG4gICAgICAgIHgxID0geDtcbiAgICAgICAgeTIgPSB5MTtcbiAgICAgICAgeTEgPSB5O1xuICAgIH1cbiAgICBhMiA9IHIubmVnKCk7XG4gICAgYjIgPSB4O1xuICAgIHZhciBsZW4xID0gYTEuc3FyKCkuYWRkKGIxLnNxcigpKTtcbiAgICB2YXIgbGVuMiA9IGEyLnNxcigpLmFkZChiMi5zcXIoKSk7XG4gICAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICAgICAgYTIgPSBhMDtcbiAgICAgICAgYjIgPSBiMDtcbiAgICB9XG4gICAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgICAgIGExID0gYTEubmVnKCk7XG4gICAgICAgIGIxID0gYjEubmVnKCk7XG4gICAgfVxuICAgIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgICAgICBhMiA9IGEyLm5lZygpO1xuICAgICAgICBiMiA9IGIyLm5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB7IGE6IGExLCBiOiBiMSB9LFxuICAgICAgICB7IGE6IGEyLCBiOiBiMiB9LFxuICAgIF07XG59O1xuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICAgIHZhciBiYXNpcyA9IHRoaXMuZW5kby5iYXNpcztcbiAgICB2YXIgdjEgPSBiYXNpc1swXTtcbiAgICB2YXIgdjIgPSBiYXNpc1sxXTtcbiAgICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICAgIHZhciBjMiA9IHYxLmIubmVnKCkubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG4gICAgdmFyIHAxID0gYzEubXVsKHYxLmEpO1xuICAgIHZhciBwMiA9IGMyLm11bCh2Mi5hKTtcbiAgICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gICAgdmFyIHEyID0gYzIubXVsKHYyLmIpO1xuICAgIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICAgIHZhciBrMiA9IHExLmFkZChxMikubmVnKCk7XG4gICAgcmV0dXJuIHsgazE6IGsxLCBrMjogazIgfTtcbn07XG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgICB4ID0gbmV3IEJOKHgsIDE2KTtcbiAgICBpZiAoIXgucmVkKVxuICAgICAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG4gICAgdmFyIHkyID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZCh4LnJlZE11bCh0aGlzLmEpKS5yZWRJQWRkKHRoaXMuYik7XG4gICAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gICAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG4gICAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgICAgICB5ID0geS5yZWROZWcoKTtcbiAgICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5TaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gICAgaWYgKHBvaW50LmluZilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdmFyIHggPSBwb2ludC54O1xuICAgIHZhciB5ID0gcG9pbnQueTtcbiAgICB2YXIgYXggPSB0aGlzLmEucmVkTXVsKHgpO1xuICAgIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gICAgcmV0dXJuIHkucmVkU3FyKCkucmVkSVN1YihyaHMpLmNtcG4oMCkgPT09IDA7XG59O1xuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gICAgICAgIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcbiAgICAgICAgdmFyIG5jb2VmZnMgPSB0aGlzLl9lbmRvV25hZlQyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNwbGl0ID0gdGhpcy5fZW5kb1NwbGl0KGNvZWZmc1tpXSk7XG4gICAgICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuICAgICAgICAgICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgc3BsaXQuazEuaW5lZygpO1xuICAgICAgICAgICAgICAgIHAgPSBwLm5lZyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGxpdC5rMi5uZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHNwbGl0LmsyLmluZWcoKTtcbiAgICAgICAgICAgICAgICBiZXRhID0gYmV0YS5uZWcodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBucG9pbnRzW2kgKiAyXSA9IHA7XG4gICAgICAgICAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuICAgICAgICAgICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcbiAgICAgICAgICAgIG5jb2VmZnNbaSAqIDIgKyAxXSA9IHNwbGl0LmsyO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSB0aGlzLl93bmFmTXVsQWRkKDEsIG5wb2ludHMsIG5jb2VmZnMsIGkgKiAyLCBqYWNvYmlhblJlc3VsdCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuICAgICAgICAgICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgICAgICAgICBuY29lZmZzW2pdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnYWZmaW5lJyk7XG4gICAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnggPSBudWxsO1xuICAgICAgICB0aGlzLnkgPSBudWxsO1xuICAgICAgICB0aGlzLmluZiA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgICAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgICAgICBpZiAoaXNSZWQpIHtcbiAgICAgICAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICAgICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICAgIHRoaXMuaW5mID0gZmFsc2U7XG4gICAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgaXNSZWQpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcbn07XG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmosIHJlZCkge1xuICAgIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG59O1xuUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gICAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgICBpZiAocHJlICYmIHByZS5iZXRhKVxuICAgICAgICByZXR1cm4gcHJlLmJldGE7XG4gICAgdmFyIGJldGEgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWRNdWwodGhpcy5jdXJ2ZS5lbmRvLmJldGEpLCB0aGlzLnkpO1xuICAgIGlmIChwcmUpIHtcbiAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5jdXJ2ZTtcbiAgICAgICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJlLmJldGEgPSBiZXRhO1xuICAgICAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuICAgICAgICAgICAgYmV0YTogbnVsbCxcbiAgICAgICAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgICAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChlbmRvTXVsKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgICAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYmV0YTtcbn07XG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICAgICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueV07XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgICAgICAgICBkb3VibGVzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMgJiYge1xuICAgICAgICAgICAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgICAgICAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcbiAgICAgICAgICAgICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgICAgICAgICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQubmFmLnBvaW50cy5zbGljZSgxKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1dO1xufTtcblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuICAgICAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gICAgdmFyIHJlcyA9IGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICAgIGlmICghb2JqWzJdKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIGZ1bmN0aW9uIG9iajJwb2ludChvYmopIHtcbiAgICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICAgIH1cbiAgICB2YXIgcHJlID0gb2JqWzJdO1xuICAgIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICAgICAgYmV0YTogbnVsbCxcbiAgICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgICAgIHBvaW50czogW3Jlc10uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSksXG4gICAgICAgIH0sXG4gICAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICAgICAgcG9pbnRzOiBbcmVzXS5jb25jYXQocHJlLm5hZi5wb2ludHMubWFwKG9iajJwb2ludCkpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbn07XG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgICAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICAgIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmY7XG59O1xuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gICAgaWYgKHRoaXMuaW5mKVxuICAgICAgICByZXR1cm4gcDtcbiAgICBpZiAocC5pbmYpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLmVxKHApKVxuICAgICAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgICBpZiAodGhpcy5uZWcoKS5lcShwKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG4gICAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG4gICAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG4gICAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICAgICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuICAgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcbiAgICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgICBpZiAodGhpcy5pbmYpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gICAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcbiAgICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcbiAgICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG4gICAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcbiAgICB2YXIgYyA9IHgyLnJlZEFkZCh4MikucmVkSUFkZCh4MikucmVkSUFkZChhKS5yZWRNdWwoZHlpbnYpO1xuICAgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpO1xuICAgIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gICAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICAgIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICAgIGsgPSBuZXcgQk4oaywgMTYpO1xuICAgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgZWxzZSBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICAgIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFt0aGlzXSwgW2tdKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAyLCBrMikge1xuICAgIHZhciBwb2ludHMgPSBbdGhpcywgcDJdO1xuICAgIHZhciBjb2VmZnMgPSBbazEsIGsyXTtcbiAgICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIpO1xufTtcblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcDIsIGsyKSB7XG4gICAgdmFyIHBvaW50cyA9IFt0aGlzLCBwMl07XG4gICAgdmFyIGNvZWZmcyA9IFtrMSwgazJdO1xuICAgIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgdHJ1ZSk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMiwgdHJ1ZSk7XG59O1xuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICAgIHJldHVybiB0aGlzID09PSBwIHx8XG4gICAgICAgIHRoaXMuaW5mID09PSBwLmluZiAmJlxuICAgICAgICAgICAgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAocC54KSA9PT0gMCAmJiB0aGlzLnkuY21wKHAueSkgPT09IDApO1xufTtcblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpIHtcbiAgICBpZiAodGhpcy5pbmYpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIHZhciByZXMgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcbiAgICBpZiAoX3ByZWNvbXB1dGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgICAgICAgdmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICByZXR1cm4gcC5uZWcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgICAgICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICAgICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICAgICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblBvaW50LnByb3RvdHlwZS50b0ogPSBmdW5jdGlvbiB0b0ooKSB7XG4gICAgaWYgKHRoaXMuaW5mKVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgdmFyIHJlcyA9IHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LCB0aGlzLmN1cnZlLm9uZSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBKUG9pbnQoY3VydmUsIHgsIHksIHopIHtcbiAgICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnamFjb2JpYW4nKTtcbiAgICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgICAgICB0aGlzLnogPSBuZXcgQk4oMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgICAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgICAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy56LnJlZClcbiAgICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxuaW5oZXJpdHMoSlBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5TaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuICAgIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcbkpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuICAgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG4gICAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuICAgIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gICAgdmFyIGF4ID0gdGhpcy54LnJlZE11bCh6aW52Mik7XG4gICAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG59O1xuSlBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xufTtcbkpQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgICAgIHJldHVybiBwO1xuICAgIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICAgIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuICAgIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcbiAgICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcbiAgICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gICAgdmFyIHIgPSBzMS5yZWRTdWIoczIpO1xuICAgIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICAgICAgaWYgKHIuY21wbigwKSAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gICAgfVxuICAgIHZhciBoMiA9IGgucmVkU3FyKCk7XG4gICAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICAgIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcbiAgICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuICAgIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcbkpQb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBmdW5jdGlvbiBtaXhlZEFkZChwKSB7XG4gICAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgICAgICByZXR1cm4gcC50b0ooKTtcbiAgICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICB2YXIgdTEgPSB0aGlzLng7XG4gICAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gICAgdmFyIHMxID0gdGhpcy55O1xuICAgIHZhciBzMiA9IHAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopO1xuICAgIHZhciBoID0gdTEucmVkU3ViKHUyKTtcbiAgICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gICAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgICAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgICB9XG4gICAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gICAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpO1xuICAgIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuICAgIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gICAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuSlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcbiAgICBpZiAocG93ID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmICghcG93KVxuICAgICAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgICB2YXIgaTtcbiAgICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuICAgICAgICB2YXIgciA9IHRoaXM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3c7IGkrKylcbiAgICAgICAgICAgIHIgPSByLmRibCgpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gICAgdmFyIHRpbnYgPSB0aGlzLmN1cnZlLnRpbnY7XG4gICAgdmFyIGp4ID0gdGhpcy54O1xuICAgIHZhciBqeSA9IHRoaXMueTtcbiAgICB2YXIganogPSB0aGlzLno7XG4gICAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuICAgIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwb3c7IGkrKykge1xuICAgICAgICB2YXIgangyID0gangucmVkU3FyKCk7XG4gICAgICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgICAgICB2YXIganlkNCA9IGp5ZDIucmVkU3FyKCk7XG4gICAgICAgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuICAgICAgICB2YXIgdDEgPSBqeC5yZWRNdWwoanlkMik7XG4gICAgICAgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgICAgICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgICAgIHZhciBkbnkgPSBjLnJlZE11bCh0Mik7XG4gICAgICAgIGRueSA9IGRueS5yZWRJQWRkKGRueSkucmVkSVN1YihqeWQ0KTtcbiAgICAgICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgICAgIGlmIChpICsgMSA8IHBvdylcbiAgICAgICAgICAgIGp6NCA9IGp6NC5yZWRNdWwoanlkNCk7XG4gICAgICAgIGp4ID0gbng7XG4gICAgICAgIGp6ID0gbno7XG4gICAgICAgIGp5ZCA9IGRueTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGp4LCBqeWQucmVkTXVsKHRpbnYpLCBqeik7XG59O1xuSlBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gICAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgICBlbHNlIGlmICh0aGlzLmN1cnZlLnRocmVlQSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuSlBvaW50LnByb3RvdHlwZS5femVyb0RibCA9IGZ1bmN0aW9uIF96ZXJvRGJsKCkge1xuICAgIHZhciBueDtcbiAgICB2YXIgbnk7XG4gICAgdmFyIG56O1xuICAgIGlmICh0aGlzLnpPbmUpIHtcbiAgICAgICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgICAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICAgICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAgICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgICAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgICAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgICAgIG54ID0gdDtcbiAgICAgICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgICAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAgICAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAgICAgdmFyIGMgPSBiLnJlZFNxcigpO1xuICAgICAgICB2YXIgZCA9IHRoaXMueC5yZWRBZGQoYikucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGMpO1xuICAgICAgICBkID0gZC5yZWRJQWRkKGQpO1xuICAgICAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgICAgIHZhciBmID0gZS5yZWRTcXIoKTtcbiAgICAgICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgICAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuICAgICAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuICAgICAgICBueCA9IGYucmVkSVN1YihkKS5yZWRJU3ViKGQpO1xuICAgICAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpO1xuICAgICAgICBueiA9IHRoaXMueS5yZWRNdWwodGhpcy56KTtcbiAgICAgICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICAgIHZhciBueDtcbiAgICB2YXIgbnk7XG4gICAgdmFyIG56O1xuICAgIGlmICh0aGlzLnpPbmUpIHtcbiAgICAgICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgICAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICAgICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAgICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAgICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcbiAgICAgICAgbnggPSB0O1xuICAgICAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAgICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgICAgIHZhciBnYW1tYSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAgICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAgICAgdmFyIGFscGhhID0gdGhpcy54LnJlZFN1YihkZWx0YSkucmVkTXVsKHRoaXMueC5yZWRBZGQoZGVsdGEpKTtcbiAgICAgICAgYWxwaGEgPSBhbHBoYS5yZWRBZGQoYWxwaGEpLnJlZElBZGQoYWxwaGEpO1xuICAgICAgICB2YXIgYmV0YTQgPSBiZXRhLnJlZElBZGQoYmV0YSk7XG4gICAgICAgIGJldGE0ID0gYmV0YTQucmVkSUFkZChiZXRhNCk7XG4gICAgICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgICAgIG54ID0gYWxwaGEucmVkU3FyKCkucmVkSVN1YihiZXRhOCk7XG4gICAgICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgICAgICB2YXIgZ2dhbW1hOCA9IGdhbW1hLnJlZFNxcigpO1xuICAgICAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgICAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgICAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgICAgICBueSA9IGFscGhhLnJlZE11bChiZXRhNC5yZWRJU3ViKG54KSkucmVkSVN1YihnZ2FtbWE4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcbkpQb2ludC5wcm90b3R5cGUuX2RibCA9IGZ1bmN0aW9uIF9kYmwoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gICAgdmFyIGp4ID0gdGhpcy54O1xuICAgIHZhciBqeSA9IHRoaXMueTtcbiAgICB2YXIganogPSB0aGlzLno7XG4gICAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuICAgIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgICB2YXIgankyID0gankucmVkU3FyKCk7XG4gICAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG4gICAgdmFyIGp4ZDQgPSBqeC5yZWRBZGQoangpO1xuICAgIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gICAgdmFyIHQxID0ganhkNC5yZWRNdWwoankyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gICAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAgICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICAgIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gICAgdmFyIG55ID0gYy5yZWRNdWwodDIpLnJlZElTdWIoanlkOCk7XG4gICAgdmFyIG56ID0gankucmVkQWRkKGp5KS5yZWRNdWwoanopO1xuICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5KUG9pbnQucHJvdG90eXBlLnRycGwgPSBmdW5jdGlvbiB0cnBsKCkge1xuICAgIGlmICghdGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZGJsKCkuYWRkKHRoaXMpO1xuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgdmFyIHp6ID0gdGhpcy56LnJlZFNxcigpO1xuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gICAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIGUgPSBlLnJlZElBZGQoZSk7XG4gICAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gICAgZSA9IGUucmVkSVN1YihtbSk7XG4gICAgdmFyIGVlID0gZS5yZWRTcXIoKTtcbiAgICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB0ID0gdC5yZWRJQWRkKHQpO1xuICAgIHQgPSB0LnJlZElBZGQodCk7XG4gICAgdCA9IHQucmVkSUFkZCh0KTtcbiAgICB2YXIgdSA9IG0ucmVkSUFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKG1tKS5yZWRJU3ViKGVlKS5yZWRJU3ViKHQpO1xuICAgIHZhciB5eXU0ID0geXkucmVkTXVsKHUpO1xuICAgIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gICAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgICB2YXIgbnggPSB0aGlzLngucmVkTXVsKGVlKS5yZWRJU3ViKHl5dTQpO1xuICAgIG54ID0gbngucmVkSUFkZChueCk7XG4gICAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgICBueSA9IG55LnJlZElBZGQobnkpO1xuICAgIG55ID0gbnkucmVkSUFkZChueSk7XG4gICAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5KUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrLCBrYmFzZSkge1xuICAgIGsgPSBuZXcgQk4oaywga2Jhc2UpO1xuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcbkpQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgICAgIHJldHVybiB0aGlzLmVxKHAudG9KKCkpO1xuICAgIGlmICh0aGlzID09PSBwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgICBpZiAodGhpcy54LnJlZE11bChwejIpLnJlZElTdWIocC54LnJlZE11bCh6MikpLmNtcG4oMCkgIT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgICB2YXIgcHozID0gcHoyLnJlZE11bChwLnopO1xuICAgIHJldHVybiB0aGlzLnkucmVkTXVsKHB6MykucmVkSVN1YihwLnkucmVkTXVsKHozKSkuY21wbigwKSA9PT0gMDtcbn07XG5KUG9pbnQucHJvdG90eXBlLmVxWFRvUCA9IGZ1bmN0aW9uIGVxWFRvUCh4KSB7XG4gICAgdmFyIHpzID0gdGhpcy56LnJlZFNxcigpO1xuICAgIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh6cyk7XG4gICAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gICAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHpzKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIHhjLmlhZGQodGhpcy5jdXJ2ZS5uKTtcbiAgICAgICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJ4LnJlZElBZGQodCk7XG4gICAgICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICAgICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gICAgcmV0dXJuICc8RUMgSlBvaW50IHg6ICcgKyB0aGlzLngudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICAgJyB5OiAnICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuSlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hvcnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/short.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curves.js':
    /*!******************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/curves.js ***!
  \******************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar curves = exports;\nvar hash = __webpack_require__(/*! hash.js */ \"(ssr)/./node_modules/hash.js/lib/hash.js\");\nvar curve = __webpack_require__(/*! ./curve */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nvar assert = utils.assert;\nfunction PresetCurve(options) {\n    if (options.type === 'short')\n        this.curve = new curve.short(options);\n    else if (options.type === 'edwards')\n        this.curve = new curve.edwards(options);\n    else\n        this.curve = new curve.mont(options);\n    this.g = this.curve.g;\n    this.n = this.curve.n;\n    this.hash = options.hash;\n    assert(this.g.validate(), 'Invalid curve');\n    assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\nfunction defineCurve(name, options) {\n    Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            var curve = new PresetCurve(options);\n            Object.defineProperty(curves, name, {\n                configurable: true,\n                enumerable: true,\n                value: curve,\n            });\n            return curve;\n        },\n    });\n}\ndefineCurve('p192', {\n    type: 'short',\n    prime: 'p192',\n    p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n    b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n    n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n    hash: hash.sha256,\n    gRed: false,\n    g: [\n        '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n        '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n    ],\n});\ndefineCurve('p224', {\n    type: 'short',\n    prime: 'p224',\n    p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n    b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n    n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n    hash: hash.sha256,\n    gRed: false,\n    g: [\n        'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n        'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n    ],\n});\ndefineCurve('p256', {\n    type: 'short',\n    prime: null,\n    p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n    a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n    b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n    n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n    hash: hash.sha256,\n    gRed: false,\n    g: [\n        '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n        '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n    ],\n});\ndefineCurve('p384', {\n    type: 'short',\n    prime: null,\n    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n        'fffffffe ffffffff 00000000 00000000 ffffffff',\n    a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n        'fffffffe ffffffff 00000000 00000000 fffffffc',\n    b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n        '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n    n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n        'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n    hash: hash.sha384,\n    gRed: false,\n    g: [\n        'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n            '5502f25d bf55296c 3a545e38 72760ab7',\n        '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n            '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n    ],\n});\ndefineCurve('p521', {\n    type: 'short',\n    prime: null,\n    p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n        'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n        'ffffffff ffffffff ffffffff ffffffff ffffffff',\n    a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n        'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n        'ffffffff ffffffff ffffffff ffffffff fffffffc',\n    b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n        '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n        '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n    n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n        'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n        'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n    hash: hash.sha512,\n    gRed: false,\n    g: [\n        '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n            '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n            'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n        '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n            '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n            '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n    ],\n});\ndefineCurve('curve25519', {\n    type: 'mont',\n    prime: 'p25519',\n    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n    a: '76d06',\n    b: '1',\n    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n    hash: hash.sha256,\n    gRed: false,\n    g: [\n        '9',\n    ],\n});\ndefineCurve('ed25519', {\n    type: 'edwards',\n    prime: 'p25519',\n    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n    a: '-1',\n    c: '1',\n    d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n    hash: hash.sha256,\n    gRed: false,\n    g: [\n        '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n        '6666666666666666666666666666666666666666666666666666666666666658',\n    ],\n});\nvar pre;\ntry {\n    pre = __webpack_require__(/*! ./precomputed/secp256k1 */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/precomputed/secp256k1.js\");\n}\ncatch (e) {\n    pre = undefined;\n}\ndefineCurve('secp256k1', {\n    type: 'short',\n    prime: 'k256',\n    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n    a: '0',\n    b: '7',\n    n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n    h: '1',\n    hash: hash.sha256,\n    beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n    lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n    basis: [\n        {\n            a: '3086d221a7d46bcde86c90e49284eb15',\n            b: '-e4437ed6010e88286f547fa90abfe4c3',\n        },\n        {\n            a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n            b: '3086d221a7d46bcde86c90e49284eb15',\n        },\n    ],\n    gRed: false,\n    g: [\n        '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n        '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n        pre,\n    ],\n});\n//# sourceMappingURL=curves.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2N1cnZlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHlEQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxzRkFBUztBQUM3QixZQUFZLG1CQUFPLENBQUMsZ0ZBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxnSEFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2N1cnZlcy5qcz8yY2QwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBjdXJ2ZXMgPSBleHBvcnRzO1xudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuZnVuY3Rpb24gUHJlc2V0Q3VydmUob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmUuc2hvcnQob3B0aW9ucyk7XG4gICAgZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSAnZWR3YXJkcycpXG4gICAgICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmUuZWR3YXJkcyhvcHRpb25zKTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmUubW9udChvcHRpb25zKTtcbiAgICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gICAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICAgIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcbiAgICBhc3NlcnQodGhpcy5nLnZhbGlkYXRlKCksICdJbnZhbGlkIGN1cnZlJyk7XG4gICAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5mdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLCBvcHRpb25zKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN1cnZlID0gbmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJ2ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnZlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZGVmaW5lQ3VydmUoJ3AxOTInLCB7XG4gICAgdHlwZTogJ3Nob3J0JyxcbiAgICBwcmltZTogJ3AxOTInLFxuICAgIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicsXG4gICAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgICBiOiAnNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjEnLFxuICAgIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMScsXG4gICAgaGFzaDogaGFzaC5zaGEyNTYsXG4gICAgZ1JlZDogZmFsc2UsXG4gICAgZzogW1xuICAgICAgICAnMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTInLFxuICAgICAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnLFxuICAgIF0sXG59KTtcbmRlZmluZUN1cnZlKCdwMjI0Jywge1xuICAgIHR5cGU6ICdzaG9ydCcsXG4gICAgcHJpbWU6ICdwMjI0JyxcbiAgICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnLFxuICAgIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG4gICAgYjogJ2I0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0JyxcbiAgICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZjE2YTIgZTBiOGYwM2UgMTNkZDI5NDUgNWM1YzJhM2QnLFxuICAgIGhhc2g6IGhhc2guc2hhMjU2LFxuICAgIGdSZWQ6IGZhbHNlLFxuICAgIGc6IFtcbiAgICAgICAgJ2I3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxJyxcbiAgICAgICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0JyxcbiAgICBdLFxufSk7XG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgICB0eXBlOiAnc2hvcnQnLFxuICAgIHByaW1lOiBudWxsLFxuICAgIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gICAgYTogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgICBiOiAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGInLFxuICAgIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gICAgaGFzaDogaGFzaC5zaGEyNTYsXG4gICAgZ1JlZDogZmFsc2UsXG4gICAgZzogW1xuICAgICAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTYnLFxuICAgICAgICAnNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYgMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjUnLFxuICAgIF0sXG59KTtcbmRlZmluZUN1cnZlKCdwMzg0Jywge1xuICAgIHR5cGU6ICdzaG9ydCcsXG4gICAgcHJpbWU6IG51bGwsXG4gICAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYnLFxuICAgIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcbiAgICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG4gICAgICAgICc1MDEzODc1YSBjNjU2Mzk4ZCA4YTJlZDE5ZCAyYTg1YzhlZCBkM2VjMmFlZicsXG4gICAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxICcgK1xuICAgICAgICAnZjQzNzJkZGYgNTgxYTBkYjIgNDhiMGE3N2EgZWNlYzE5NmEgY2NjNTI5NzMnLFxuICAgIGhhc2g6IGhhc2guc2hhMzg0LFxuICAgIGdSZWQ6IGZhbHNlLFxuICAgIGc6IFtcbiAgICAgICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4ICcgK1xuICAgICAgICAgICAgJzU1MDJmMjVkIGJmNTUyOTZjIDNhNTQ1ZTM4IDcyNzYwYWI3JyxcbiAgICAgICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwICcgK1xuICAgICAgICAgICAgJzBhNjBiMWNlIDFkN2U4MTlkIDdhNDMxZDdjIDkwZWEwZTVmJyxcbiAgICBdLFxufSk7XG5kZWZpbmVDdXJ2ZSgncDUyMScsIHtcbiAgICB0eXBlOiAnc2hvcnQnLFxuICAgIHByaW1lOiBudWxsLFxuICAgIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICAgIGE6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICAgIGI6ICcwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiAnICtcbiAgICAgICAgJzk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkICcgK1xuICAgICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuICAgIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4ICcgK1xuICAgICAgICAnZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknLFxuICAgIGhhc2g6IGhhc2guc2hhNTEyLFxuICAgIGdSZWQ6IGZhbHNlLFxuICAgIGc6IFtcbiAgICAgICAgJzAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5ICcgK1xuICAgICAgICAgICAgJzA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3ICcgK1xuICAgICAgICAgICAgJ2EyZmZhOGRlIDMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2JyxcbiAgICAgICAgJzAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5ICcgK1xuICAgICAgICAgICAgJzU3OWI0NDY4IDE3YWZiZDE3IDI3M2U2NjJjIDk3ZWU3Mjk5IDVlZjQyNjQwIGM1NTBiOTAxICcgK1xuICAgICAgICAgICAgJzNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJyxcbiAgICBdLFxufSk7XG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgICB0eXBlOiAnbW9udCcsXG4gICAgcHJpbWU6ICdwMjU1MTknLFxuICAgIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgICBhOiAnNzZkMDYnLFxuICAgIGI6ICcxJyxcbiAgICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gICAgaGFzaDogaGFzaC5zaGEyNTYsXG4gICAgZ1JlZDogZmFsc2UsXG4gICAgZzogW1xuICAgICAgICAnOScsXG4gICAgXSxcbn0pO1xuZGVmaW5lQ3VydmUoJ2VkMjU1MTknLCB7XG4gICAgdHlwZTogJ2Vkd2FyZHMnLFxuICAgIHByaW1lOiAncDI1NTE5JyxcbiAgICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gICAgYTogJy0xJyxcbiAgICBjOiAnMScsXG4gICAgZDogJzUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTMnLFxuICAgIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgICBnUmVkOiBmYWxzZSxcbiAgICBnOiBbXG4gICAgICAgICcyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhJyxcbiAgICAgICAgJzY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnLFxuICAgIF0sXG59KTtcbnZhciBwcmU7XG50cnkge1xuICAgIHByZSA9IHJlcXVpcmUoJy4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxJyk7XG59XG5jYXRjaCAoZSkge1xuICAgIHByZSA9IHVuZGVmaW5lZDtcbn1cbmRlZmluZUN1cnZlKCdzZWNwMjU2azEnLCB7XG4gICAgdHlwZTogJ3Nob3J0JyxcbiAgICBwcmltZTogJ2syNTYnLFxuICAgIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicsXG4gICAgYTogJzAnLFxuICAgIGI6ICc3JyxcbiAgICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDEnLFxuICAgIGg6ICcxJyxcbiAgICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgICBiZXRhOiAnN2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScsXG4gICAgbGFtYmRhOiAnNTM2M2FkNGNjMDVjMzBlMGE1MjYxYzAyODgxMjY0NWExMjJlMjJlYTIwODE2Njc4ZGYwMjk2N2MxYjIzYmQ3MicsXG4gICAgYmFzaXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgYTogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICAgICAgICAgIGI6ICctZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBhOiAnMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyxcbiAgICAgICAgICAgIGI6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBnUmVkOiBmYWxzZSxcbiAgICBnOiBbXG4gICAgICAgICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICAgICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuICAgICAgICBwcmUsXG4gICAgXSxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curves.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/index.js':
    /*!********************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/index.js ***!
  \********************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar HmacDRBG = __webpack_require__(/*! hmac-drbg */ \"(ssr)/./node_modules/hmac-drbg/lib/hmac-drbg.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nvar curves = __webpack_require__(/*! ../curves */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curves.js\");\nvar rand = __webpack_require__(/*! brorand */ \"(ssr)/./node_modules/brorand/index.js\");\nvar assert = utils.assert;\nvar KeyPair = __webpack_require__(/*! ./key */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/key.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/signature.js\");\nfunction EC(options) {\n    if (!(this instanceof EC))\n        return new EC(options);\n    if (typeof options === 'string') {\n        assert(Object.prototype.hasOwnProperty.call(curves, options), 'Unknown curve ' + options);\n        options = curves[options];\n    }\n    if (options instanceof curves.PresetCurve)\n        options = { curve: options };\n    this.curve = options.curve.curve;\n    this.n = this.curve.n;\n    this.nh = this.n.ushrn(1);\n    this.g = this.curve.g;\n    this.g = options.curve.g;\n    this.g.precompute(options.curve.n.bitLength() + 1);\n    this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\nEC.prototype.keyPair = function keyPair(options) {\n    return new KeyPair(this, options);\n};\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n    return KeyPair.fromPrivate(this, priv, enc);\n};\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n    return KeyPair.fromPublic(this, pub, enc);\n};\nEC.prototype.genKeyPair = function genKeyPair(options) {\n    if (!options)\n        options = {};\n    var drbg = new HmacDRBG({\n        hash: this.hash,\n        pers: options.pers,\n        persEnc: options.persEnc || 'utf8',\n        entropy: options.entropy || rand(this.hash.hmacStrength),\n        entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n        nonce: this.n.toArray(),\n    });\n    var bytes = this.n.byteLength();\n    var ns2 = this.n.sub(new BN(2));\n    for (;;) {\n        var priv = new BN(drbg.generate(bytes));\n        if (priv.cmp(ns2) > 0)\n            continue;\n        priv.iaddn(1);\n        return this.keyFromPrivate(priv);\n    }\n};\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n    var delta = msg.byteLength() * 8 - this.n.bitLength();\n    if (delta > 0)\n        msg = msg.ushrn(delta);\n    if (!truncOnly && msg.cmp(this.n) >= 0)\n        return msg.sub(this.n);\n    else\n        return msg;\n};\nEC.prototype.sign = function sign(msg, key, enc, options) {\n    if (typeof enc === 'object') {\n        options = enc;\n        enc = null;\n    }\n    if (!options)\n        options = {};\n    key = this.keyFromPrivate(key, enc);\n    msg = this._truncateToN(new BN(msg, 16));\n    var bytes = this.n.byteLength();\n    var bkey = key.getPrivate().toArray('be', bytes);\n    var nonce = msg.toArray('be', bytes);\n    var drbg = new HmacDRBG({\n        hash: this.hash,\n        entropy: bkey,\n        nonce: nonce,\n        pers: options.pers,\n        persEnc: options.persEnc || 'utf8',\n    });\n    var ns1 = this.n.sub(new BN(1));\n    for (var iter = 0;; iter++) {\n        var k = options.k ?\n            options.k(iter) :\n            new BN(drbg.generate(this.n.byteLength()));\n        k = this._truncateToN(k, true);\n        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n            continue;\n        var kp = this.g.mul(k);\n        if (kp.isInfinity())\n            continue;\n        var kpX = kp.getX();\n        var r = kpX.umod(this.n);\n        if (r.cmpn(0) === 0)\n            continue;\n        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n        s = s.umod(this.n);\n        if (s.cmpn(0) === 0)\n            continue;\n        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n            (kpX.cmp(r) !== 0 ? 2 : 0);\n        if (options.canonical && s.cmp(this.nh) > 0) {\n            s = this.n.sub(s);\n            recoveryParam ^= 1;\n        }\n        return new Signature(this.curve, { r: r, s: s, recoveryParam: recoveryParam });\n    }\n};\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n    msg = this._truncateToN(new BN(msg, 16));\n    key = this.keyFromPublic(key, enc);\n    signature = new Signature(this.curve, signature, 'hex');\n    var r = signature.r;\n    var s = signature.s;\n    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n        return false;\n    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n        return false;\n    var sinv = s.invm(this.n);\n    var u1 = sinv.mul(msg).umod(this.n);\n    var u2 = sinv.mul(r).umod(this.n);\n    var p;\n    if (!this.curve._maxwellTrick) {\n        p = this.g.mulAdd(u1, key.getPublic(), u2);\n        if (p.isInfinity())\n            return false;\n        return p.getX().umod(this.n).cmp(r) === 0;\n    }\n    p = this.g.jmulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n        return false;\n    return p.eqXToP(r);\n};\nEC.prototype.recoverPubKey = function (msg, signature, j, enc) {\n    assert((3 & j) === j, 'The recovery param is more than two bits');\n    signature = new Signature(this.curve, signature, enc);\n    var n = this.n;\n    var e = new BN(msg);\n    var r = signature.r;\n    var s = signature.s;\n    var isYOdd = j & 1;\n    var isSecondKey = j >> 1;\n    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n        throw new Error('Unable to find sencond key candinate');\n    if (isSecondKey)\n        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n    else\n        r = this.curve.pointFromX(r, isYOdd);\n    var rInv = signature.r.invm(n);\n    var s1 = n.sub(e).mul(rInv).umod(n);\n    var s2 = s.mul(rInv).umod(n);\n    return this.g.mulAdd(s1, r, s2);\n};\nEC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {\n    signature = new Signature(this.curve, signature, enc);\n    if (signature.recoveryParam !== null)\n        return signature.recoveryParam;\n    for (var i = 0; i < 4; i++) {\n        var Qprime;\n        try {\n            Qprime = this.recoverPubKey(e, signature, i);\n        }\n        catch (e) {\n            continue;\n        }\n        if (Qprime.eq(Q))\n            return i;\n    }\n    throw new Error('Unable to find valid recovery factor');\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2VjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsU0FBUyxtQkFBTyxDQUFDLDBEQUFjO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxrRUFBVztBQUNsQyxZQUFZLG1CQUFPLENBQUMsaUZBQVU7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLG1GQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxzREFBUztBQUM1QjtBQUNBLGNBQWMsbUJBQU8sQ0FBQywrRUFBTztBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQywyRkFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQ0FBMEM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvZWxsaXB0aWMvZWMvaW5kZXguanM/ODU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcy9saWIvYm4nKTtcbnZhciBIbWFjRFJCRyA9IHJlcXVpcmUoJ2htYWMtZHJiZycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuLi9jdXJ2ZXMnKTtcbnZhciByYW5kID0gcmVxdWlyZSgnYnJvcmFuZCcpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuZnVuY3Rpb24gRUMob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQykpXG4gICAgICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBhc3NlcnQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnZlcywgb3B0aW9ucyksICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucyA9IGN1cnZlc1tvcHRpb25zXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBjdXJ2ZXMuUHJlc2V0Q3VydmUpXG4gICAgICAgIG9wdGlvbnMgPSB7IGN1cnZlOiBvcHRpb25zIH07XG4gICAgdGhpcy5jdXJ2ZSA9IG9wdGlvbnMuY3VydmUuY3VydmU7XG4gICAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICAgIHRoaXMubmggPSB0aGlzLm4udXNocm4oMSk7XG4gICAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuICAgIHRoaXMuZyA9IG9wdGlvbnMuY3VydmUuZztcbiAgICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcbiAgICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFQztcbkVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBLZXlQYWlyKHRoaXMsIG9wdGlvbnMpO1xufTtcbkVDLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGtleUZyb21Qcml2YXRlKHByaXYsIGVuYykge1xuICAgIHJldHVybiBLZXlQYWlyLmZyb21Qcml2YXRlKHRoaXMsIHByaXYsIGVuYyk7XG59O1xuRUMucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1YiwgZW5jKSB7XG4gICAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG59O1xuRUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgZHJiZyA9IG5ldyBIbWFjRFJCRyh7XG4gICAgICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICAgICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgICAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICAgICAgICBlbnRyb3B5OiBvcHRpb25zLmVudHJvcHkgfHwgcmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxcbiAgICAgICAgZW50cm9weUVuYzogb3B0aW9ucy5lbnRyb3B5ICYmIG9wdGlvbnMuZW50cm9weUVuYyB8fCAndXRmOCcsXG4gICAgICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpLFxuICAgIH0pO1xuICAgIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIG5zMiA9IHRoaXMubi5zdWIobmV3IEJOKDIpKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciBwcml2ID0gbmV3IEJOKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtcbiAgICAgICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHByaXYuaWFkZG4oMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICAgIH1cbn07XG5FQy5wcm90b3R5cGUuX3RydW5jYXRlVG9OID0gZnVuY3Rpb24gX3RydW5jYXRlVG9OKG1zZywgdHJ1bmNPbmx5KSB7XG4gICAgdmFyIGRlbHRhID0gbXNnLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gICAgaWYgKGRlbHRhID4gMClcbiAgICAgICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcbiAgICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcbiAgICAgICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBtc2c7XG59O1xuRUMucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywga2V5LCBlbmMsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IGVuYztcbiAgICAgICAgZW5jID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgICBvcHRpb25zID0ge307XG4gICAga2V5ID0gdGhpcy5rZXlGcm9tUHJpdmF0ZShrZXksIGVuYyk7XG4gICAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICAgIHZhciBia2V5ID0ga2V5LmdldFByaXZhdGUoKS50b0FycmF5KCdiZScsIGJ5dGVzKTtcbiAgICB2YXIgbm9uY2UgPSBtc2cudG9BcnJheSgnYmUnLCBieXRlcyk7XG4gICAgdmFyIGRyYmcgPSBuZXcgSG1hY0RSQkcoe1xuICAgICAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgICAgIGVudHJvcHk6IGJrZXksXG4gICAgICAgIG5vbmNlOiBub25jZSxcbiAgICAgICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgICAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICAgIH0pO1xuICAgIHZhciBuczEgPSB0aGlzLm4uc3ViKG5ldyBCTigxKSk7XG4gICAgZm9yICh2YXIgaXRlciA9IDA7OyBpdGVyKyspIHtcbiAgICAgICAgdmFyIGsgPSBvcHRpb25zLmsgP1xuICAgICAgICAgICAgb3B0aW9ucy5rKGl0ZXIpIDpcbiAgICAgICAgICAgIG5ldyBCTihkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtcbiAgICAgICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuICAgICAgICBpZiAoay5jbXBuKDEpIDw9IDAgfHwgay5jbXAobnMxKSA+PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG4gICAgICAgIGlmIChrcC5pc0luZmluaXR5KCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcbiAgICAgICAgdmFyIHIgPSBrcFgudW1vZCh0aGlzLm4pO1xuICAgICAgICBpZiAoci5jbXBuKDApID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBzID0gay5pbnZtKHRoaXMubikubXVsKHIubXVsKGtleS5nZXRQcml2YXRlKCkpLmlhZGQobXNnKSk7XG4gICAgICAgIHMgPSBzLnVtb2QodGhpcy5uKTtcbiAgICAgICAgaWYgKHMuY21wbigwKSA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IChrcC5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8XG4gICAgICAgICAgICAoa3BYLmNtcChyKSAhPT0gMCA/IDIgOiAwKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMCkge1xuICAgICAgICAgICAgcyA9IHRoaXMubi5zdWIocyk7XG4gICAgICAgICAgICByZWNvdmVyeVBhcmFtIF49IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5jdXJ2ZSwgeyByOiByLCBzOiBzLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuICAgIH1cbn07XG5FQy5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlLCBrZXksIGVuYykge1xuICAgIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG4gICAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcbiAgICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHRoaXMuY3VydmUsIHNpZ25hdHVyZSwgJ2hleCcpO1xuICAgIHZhciByID0gc2lnbmF0dXJlLnI7XG4gICAgdmFyIHMgPSBzaWduYXR1cmUucztcbiAgICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuICAgIHZhciB1MSA9IHNpbnYubXVsKG1zZykudW1vZCh0aGlzLm4pO1xuICAgIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcbiAgICB2YXIgcDtcbiAgICBpZiAoIXRoaXMuY3VydmUuX21heHdlbGxUcmljaykge1xuICAgICAgICBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgICAgIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG4gICAgfVxuICAgIHAgPSB0aGlzLmcuam11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHAuZXFYVG9QKHIpO1xufTtcbkVDLnByb3RvdHlwZS5yZWNvdmVyUHViS2V5ID0gZnVuY3Rpb24gKG1zZywgc2lnbmF0dXJlLCBqLCBlbmMpIHtcbiAgICBhc3NlcnQoKDMgJiBqKSA9PT0gaiwgJ1RoZSByZWNvdmVyeSBwYXJhbSBpcyBtb3JlIHRoYW4gdHdvIGJpdHMnKTtcbiAgICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHRoaXMuY3VydmUsIHNpZ25hdHVyZSwgZW5jKTtcbiAgICB2YXIgbiA9IHRoaXMubjtcbiAgICB2YXIgZSA9IG5ldyBCTihtc2cpO1xuICAgIHZhciByID0gc2lnbmF0dXJlLnI7XG4gICAgdmFyIHMgPSBzaWduYXR1cmUucztcbiAgICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gICAgdmFyIGlzU2Vjb25kS2V5ID0gaiA+PiAxO1xuICAgIGlmIChyLmNtcCh0aGlzLmN1cnZlLnAudW1vZCh0aGlzLmN1cnZlLm4pKSA+PSAwICYmIGlzU2Vjb25kS2V5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZScpO1xuICAgIGlmIChpc1NlY29uZEtleSlcbiAgICAgICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICAgIGVsc2VcbiAgICAgICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuICAgIHZhciBySW52ID0gc2lnbmF0dXJlLnIuaW52bShuKTtcbiAgICB2YXIgczEgPSBuLnN1YihlKS5tdWwockludikudW1vZChuKTtcbiAgICB2YXIgczIgPSBzLm11bChySW52KS51bW9kKG4pO1xuICAgIHJldHVybiB0aGlzLmcubXVsQWRkKHMxLCByLCBzMik7XG59O1xuRUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbiAoZSwgc2lnbmF0dXJlLCBRLCBlbmMpIHtcbiAgICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHRoaXMuY3VydmUsIHNpZ25hdHVyZSwgZW5jKTtcbiAgICBpZiAoc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0gIT09IG51bGwpXG4gICAgICAgIHJldHVybiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICB2YXIgUXByaW1lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUXByaW1lID0gdGhpcy5yZWNvdmVyUHViS2V5KGUsIHNpZ25hdHVyZSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChRcHJpbWUuZXEoUSkpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/index.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/key.js':
    /*!******************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/key.js ***!
  \******************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nvar assert = utils.assert;\nfunction KeyPair(ec, options) {\n    this.ec = ec;\n    this.priv = null;\n    this.pub = null;\n    if (options.priv)\n        this._importPrivate(options.priv, options.privEnc);\n    if (options.pub)\n        this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n    if (pub instanceof KeyPair)\n        return pub;\n    return new KeyPair(ec, {\n        pub: pub,\n        pubEnc: enc,\n    });\n};\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n    if (priv instanceof KeyPair)\n        return priv;\n    return new KeyPair(ec, {\n        priv: priv,\n        privEnc: enc,\n    });\n};\nKeyPair.prototype.validate = function validate() {\n    var pub = this.getPublic();\n    if (pub.isInfinity())\n        return { result: false, reason: 'Invalid public key' };\n    if (!pub.validate())\n        return { result: false, reason: 'Public key is not a point' };\n    if (!pub.mul(this.ec.curve.n).isInfinity())\n        return { result: false, reason: 'Public key * N != O' };\n    return { result: true, reason: null };\n};\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n    if (typeof compact === 'string') {\n        enc = compact;\n        compact = null;\n    }\n    if (!this.pub)\n        this.pub = this.ec.g.mul(this.priv);\n    if (!enc)\n        return this.pub;\n    return this.pub.encode(enc, compact);\n};\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n    if (enc === 'hex')\n        return this.priv.toString(16, 2);\n    else\n        return this.priv;\n};\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n    this.priv = new BN(key, enc || 16);\n    this.priv = this.priv.umod(this.ec.curve.n);\n};\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n    if (key.x || key.y) {\n        if (this.ec.curve.type === 'mont') {\n            assert(key.x, 'Need x coordinate');\n        }\n        else if (this.ec.curve.type === 'short' ||\n            this.ec.curve.type === 'edwards') {\n            assert(key.x && key.y, 'Need both x and y coordinate');\n        }\n        this.pub = this.ec.curve.point(key.x, key.y);\n        return;\n    }\n    this.pub = this.ec.curve.decodePoint(key, enc);\n};\nKeyPair.prototype.derive = function derive(pub) {\n    if (!pub.validate()) {\n        assert(pub.validate(), 'public point not validated');\n    }\n    return pub.mul(this.priv).getX();\n};\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n    return this.ec.sign(msg, this, enc, options);\n};\nKeyPair.prototype.verify = function verify(msg, signature) {\n    return this.ec.verify(msg, signature, this);\n};\nKeyPair.prototype.inspect = function inspect() {\n    return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n        ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n//# sourceMappingURL=key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2VjL2tleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFNBQVMsbUJBQU8sQ0FBQywwREFBYztBQUMvQixZQUFZLG1CQUFPLENBQUMsaUZBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9lbGxpcHRpYy9lYy9rZXkuanM/MWEwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcy9saWIvYm4nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuZnVuY3Rpb24gS2V5UGFpcihlYywgb3B0aW9ucykge1xuICAgIHRoaXMuZWMgPSBlYztcbiAgICB0aGlzLnByaXYgPSBudWxsO1xuICAgIHRoaXMucHViID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5wcml2KVxuICAgICAgICB0aGlzLl9pbXBvcnRQcml2YXRlKG9wdGlvbnMucHJpdiwgb3B0aW9ucy5wcml2RW5jKTtcbiAgICBpZiAob3B0aW9ucy5wdWIpXG4gICAgICAgIHRoaXMuX2ltcG9ydFB1YmxpYyhvcHRpb25zLnB1Yiwgb3B0aW9ucy5wdWJFbmMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcbiAgICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICAgICAgcmV0dXJuIHB1YjtcbiAgICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICAgICAgcHViOiBwdWIsXG4gICAgICAgIHB1YkVuYzogZW5jLFxuICAgIH0pO1xufTtcbktleVBhaXIuZnJvbVByaXZhdGUgPSBmdW5jdGlvbiBmcm9tUHJpdmF0ZShlYywgcHJpdiwgZW5jKSB7XG4gICAgaWYgKHByaXYgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgICAgICByZXR1cm4gcHJpdjtcbiAgICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICAgICAgcHJpdjogcHJpdixcbiAgICAgICAgcHJpdkVuYzogZW5jLFxuICAgIH0pO1xufTtcbktleVBhaXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gICAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG4gICAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ0ludmFsaWQgcHVibGljIGtleScgfTtcbiAgICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50JyB9O1xuICAgIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSAqIE4gIT0gTycgfTtcbiAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIHJlYXNvbjogbnVsbCB9O1xufTtcbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LCBlbmMpIHtcbiAgICBpZiAodHlwZW9mIGNvbXBhY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgICAgIGNvbXBhY3QgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucHViKVxuICAgICAgICB0aGlzLnB1YiA9IHRoaXMuZWMuZy5tdWwodGhpcy5wcml2KTtcbiAgICBpZiAoIWVuYylcbiAgICAgICAgcmV0dXJuIHRoaXMucHViO1xuICAgIHJldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLCBjb21wYWN0KTtcbn07XG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgICBpZiAoZW5jID09PSAnaGV4JylcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQcml2YXRlID0gZnVuY3Rpb24gX2ltcG9ydFByaXZhdGUoa2V5LCBlbmMpIHtcbiAgICB0aGlzLnByaXYgPSBuZXcgQk4oa2V5LCBlbmMgfHwgMTYpO1xuICAgIHRoaXMucHJpdiA9IHRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubik7XG59O1xuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcbiAgICBpZiAoa2V5LnggfHwga2V5LnkpIHtcbiAgICAgICAgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ21vbnQnKSB7XG4gICAgICAgICAgICBhc3NlcnQoa2V5LngsICdOZWVkIHggY29vcmRpbmF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcbiAgICAgICAgICAgIGFzc2VydChrZXkueCAmJiBrZXkueSwgJ05lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUuZGVjb2RlUG9pbnQoa2V5LCBlbmMpO1xufTtcbktleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcbiAgICBpZiAoIXB1Yi52YWxpZGF0ZSgpKSB7XG4gICAgICAgIGFzc2VydChwdWIudmFsaWRhdGUoKSwgJ3B1YmxpYyBwb2ludCBub3QgdmFsaWRhdGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xufTtcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZWMuc2lnbihtc2csIHRoaXMsIGVuYywgb3B0aW9ucyk7XG59O1xuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWMudmVyaWZ5KG1zZywgc2lnbmF0dXJlLCB0aGlzKTtcbn07XG5LZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gJzxLZXkgcHJpdjogJyArICh0aGlzLnByaXYgJiYgdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKSkgK1xuICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/key.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/signature.js':
    /*!************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/signature.js ***!
  \************************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nvar assert = utils.assert;\nfunction Signature(curve, options, enc) {\n    if (options instanceof Signature)\n        return options;\n    if (this._importDER(options, enc))\n        return;\n    assert(options.r && options.s, 'Signature without r or s');\n    this.r = new BN(options.r, 16);\n    this.s = new BN(options.s, 16);\n    if (options.recoveryParam === undefined)\n        this.recoveryParam = null;\n    else\n        this.recoveryParam = options.recoveryParam;\n    this.curve = curve;\n    this.byteLength = this.curve.n.byteLength();\n}\nmodule.exports = Signature;\nfunction Position() {\n    this.place = 0;\n}\nfunction getLength(buf, p) {\n    var initial = buf[p.place++];\n    if (!(initial & 0x80)) {\n        return initial;\n    }\n    var octetLen = initial & 0xf;\n    if (octetLen === 0 || octetLen > 4) {\n        return false;\n    }\n    var val = 0;\n    for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n        val <<= 8;\n        val |= buf[off];\n        val >>>= 0;\n    }\n    if (val <= 0x7f) {\n        return false;\n    }\n    p.place = off;\n    return val;\n}\nfunction rmPadding(buf) {\n    var i = 0;\n    var len = buf.length - 1;\n    while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n        i++;\n    }\n    if (i === 0) {\n        return buf;\n    }\n    return buf.slice(i);\n}\nSignature.prototype._importDER = function _importDER(data, enc) {\n    data = utils.toArray(data, enc);\n    var p = new Position();\n    if (data[p.place++] !== 0x30) {\n        return false;\n    }\n    var len = getLength(data, p);\n    if (len === false) {\n        return false;\n    }\n    if ((len + p.place) !== data.length) {\n        return false;\n    }\n    if (data[p.place++] !== 0x02) {\n        return false;\n    }\n    var rlen = getLength(data, p);\n    if (rlen === false) {\n        return false;\n    }\n    var r = data.slice(p.place, rlen + p.place);\n    p.place += rlen;\n    if (data[p.place++] !== 0x02) {\n        return false;\n    }\n    var slen = getLength(data, p);\n    if (slen === false) {\n        return false;\n    }\n    if (data.length !== slen + p.place) {\n        return false;\n    }\n    var s = data.slice(p.place, slen + p.place);\n    if (r[0] === 0) {\n        if (r[1] & 0x80) {\n            r = r.slice(1);\n        }\n        else {\n            return false;\n        }\n    }\n    if (s[0] === 0) {\n        if (s[1] & 0x80) {\n            s = s.slice(1);\n        }\n        else {\n            return false;\n        }\n    }\n    this.r = new BN(r);\n    this.s = new BN(s);\n    this.recoveryParam = null;\n    return true;\n};\nfunction constructLength(arr, len) {\n    if (len < 0x80) {\n        arr.push(len);\n        return;\n    }\n    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n    arr.push(octets | 0x80);\n    while (--octets) {\n        arr.push((len >>> (octets << 3)) & 0xff);\n    }\n    arr.push(len);\n}\nSignature.prototype.toDER = function toDER(enc) {\n    var r = this.r.toArray();\n    var s = this.s.toArray();\n    if (r[0] & 0x80)\n        r = [0].concat(r);\n    if (s[0] & 0x80)\n        s = [0].concat(s);\n    r = rmPadding(r);\n    s = rmPadding(s);\n    while (!s[0] && !(s[1] & 0x80)) {\n        s = s.slice(1);\n    }\n    var arr = [0x02];\n    constructLength(arr, r.length);\n    arr = arr.concat(r);\n    arr.push(0x02);\n    constructLength(arr, s.length);\n    var backHalf = arr.concat(s);\n    var res = [0x30];\n    constructLength(res, backHalf.length);\n    res = res.concat(backHalf);\n    return utils.encode(res, enc);\n};\nSignature.prototype.toBytes = function toBytes() {\n    const r = this.r.toArray('be', this.byteLength);\n    const s = this.s.toArray('be', this.byteLength);\n    return r.concat(s);\n};\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2VjL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFNBQVMsbUJBQU8sQ0FBQywwREFBYztBQUMvQixZQUFZLG1CQUFPLENBQUMsaUZBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9lbGxpcHRpYy9lYy9zaWduYXR1cmUuanM/MjZkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcy9saWIvYm4nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuZnVuY3Rpb24gU2lnbmF0dXJlKGN1cnZlLCBvcHRpb25zLCBlbmMpIHtcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIFNpZ25hdHVyZSlcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgaWYgKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLCBlbmMpKVxuICAgICAgICByZXR1cm47XG4gICAgYXNzZXJ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcbiAgICB0aGlzLnIgPSBuZXcgQk4ob3B0aW9ucy5yLCAxNik7XG4gICAgdGhpcy5zID0gbmV3IEJOKG9wdGlvbnMucywgMTYpO1xuICAgIGlmIChvcHRpb25zLnJlY292ZXJ5UGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG9wdGlvbnMucmVjb3ZlcnlQYXJhbTtcbiAgICB0aGlzLmN1cnZlID0gY3VydmU7XG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gdGhpcy5jdXJ2ZS5uLmJ5dGVMZW5ndGgoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gICAgdGhpcy5wbGFjZSA9IDA7XG59XG5mdW5jdGlvbiBnZXRMZW5ndGgoYnVmLCBwKSB7XG4gICAgdmFyIGluaXRpYWwgPSBidWZbcC5wbGFjZSsrXTtcbiAgICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWw7XG4gICAgfVxuICAgIHZhciBvY3RldExlbiA9IGluaXRpYWwgJiAweGY7XG4gICAgaWYgKG9jdGV0TGVuID09PSAwIHx8IG9jdGV0TGVuID4gNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBvZmYgPSBwLnBsYWNlOyBpIDwgb2N0ZXRMZW47IGkrKywgb2ZmKyspIHtcbiAgICAgICAgdmFsIDw8PSA4O1xuICAgICAgICB2YWwgfD0gYnVmW29mZl07XG4gICAgICAgIHZhbCA+Pj49IDA7XG4gICAgfVxuICAgIGlmICh2YWwgPD0gMHg3Zikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHAucGxhY2UgPSBvZmY7XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuICAgIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gYnVmLnNsaWNlKGkpO1xufVxuU2lnbmF0dXJlLnByb3RvdHlwZS5faW1wb3J0REVSID0gZnVuY3Rpb24gX2ltcG9ydERFUihkYXRhLCBlbmMpIHtcbiAgICBkYXRhID0gdXRpbHMudG9BcnJheShkYXRhLCBlbmMpO1xuICAgIHZhciBwID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gICAgaWYgKGxlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKGxlbiArIHAucGxhY2UpICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcmxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgICBpZiAocmxlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgciA9IGRhdGEuc2xpY2UocC5wbGFjZSwgcmxlbiArIHAucGxhY2UpO1xuICAgIHAucGxhY2UgKz0gcmxlbjtcbiAgICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHNsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gICAgaWYgKHNsZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRhdGEubGVuZ3RoICE9PSBzbGVuICsgcC5wbGFjZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBzID0gZGF0YS5zbGljZShwLnBsYWNlLCBzbGVuICsgcC5wbGFjZSk7XG4gICAgaWYgKHJbMF0gPT09IDApIHtcbiAgICAgICAgaWYgKHJbMV0gJiAweDgwKSB7XG4gICAgICAgICAgICByID0gci5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc1swXSA9PT0gMCkge1xuICAgICAgICBpZiAoc1sxXSAmIDB4ODApIHtcbiAgICAgICAgICAgIHMgPSBzLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuciA9IG5ldyBCTihyKTtcbiAgICB0aGlzLnMgPSBuZXcgQk4ocyk7XG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuIDwgMHg4MCkge1xuICAgICAgICBhcnIucHVzaChsZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvY3RldHMgPSAxICsgKE1hdGgubG9nKGxlbikgLyBNYXRoLkxOMiA+Pj4gMyk7XG4gICAgYXJyLnB1c2gob2N0ZXRzIHwgMHg4MCk7XG4gICAgd2hpbGUgKC0tb2N0ZXRzKSB7XG4gICAgICAgIGFyci5wdXNoKChsZW4gPj4+IChvY3RldHMgPDwgMykpICYgMHhmZik7XG4gICAgfVxuICAgIGFyci5wdXNoKGxlbik7XG59XG5TaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24gdG9ERVIoZW5jKSB7XG4gICAgdmFyIHIgPSB0aGlzLnIudG9BcnJheSgpO1xuICAgIHZhciBzID0gdGhpcy5zLnRvQXJyYXkoKTtcbiAgICBpZiAoclswXSAmIDB4ODApXG4gICAgICAgIHIgPSBbMF0uY29uY2F0KHIpO1xuICAgIGlmIChzWzBdICYgMHg4MClcbiAgICAgICAgcyA9IFswXS5jb25jYXQocyk7XG4gICAgciA9IHJtUGFkZGluZyhyKTtcbiAgICBzID0gcm1QYWRkaW5nKHMpO1xuICAgIHdoaWxlICghc1swXSAmJiAhKHNbMV0gJiAweDgwKSkge1xuICAgICAgICBzID0gcy5zbGljZSgxKTtcbiAgICB9XG4gICAgdmFyIGFyciA9IFsweDAyXTtcbiAgICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCByLmxlbmd0aCk7XG4gICAgYXJyID0gYXJyLmNvbmNhdChyKTtcbiAgICBhcnIucHVzaCgweDAyKTtcbiAgICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBzLmxlbmd0aCk7XG4gICAgdmFyIGJhY2tIYWxmID0gYXJyLmNvbmNhdChzKTtcbiAgICB2YXIgcmVzID0gWzB4MzBdO1xuICAgIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG4gICAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG4gICAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuU2lnbmF0dXJlLnByb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcygpIHtcbiAgICBjb25zdCByID0gdGhpcy5yLnRvQXJyYXkoJ2JlJywgdGhpcy5ieXRlTGVuZ3RoKTtcbiAgICBjb25zdCBzID0gdGhpcy5zLnRvQXJyYXkoJ2JlJywgdGhpcy5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gci5jb25jYXQocyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/signature.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/index.js':
    /*!***********************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/index.js ***!
  \***********************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nvar hash = __webpack_require__(/*! hash.js */ "(ssr)/./node_modules/hash.js/lib/hash.js");\nvar curves = __webpack_require__(/*! ../curves */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curves.js");\nvar utils = __webpack_require__(/*! ../utils */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js");\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar KeyPair = __webpack_require__(/*! ./key */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/key.js");\nvar Signature = __webpack_require__(/*! ./signature */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/signature.js");\nfunction EDDSA(curve) {\n    assert(curve === \'ed25519\', \'only tested with ed25519 so far\');\n    if (!(this instanceof EDDSA))\n        return new EDDSA(curve);\n    curve = curves[curve].curve;\n    this.curve = curve;\n    this.g = curve.g;\n    this.g.precompute(curve.n.bitLength() + 1);\n    this.pointClass = curve.point().constructor;\n    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\n    this.hash = hash.sha512;\n}\nmodule.exports = EDDSA;\nEDDSA.prototype.sign = function sign(message, secret) {\n    message = parseBytes(message);\n    var key = this.keyFromSecret(secret);\n    var r = this.hashInt(key.messagePrefix(), message);\n    var R = this.g.mul(r);\n    var Rencoded = this.encodePoint(R);\n    var s_ = this.hashInt(Rencoded, key.pubBytes(), message)\n        .mul(key.priv());\n    var S = r.add(s_).umod(this.curve.n);\n    return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });\n};\nEDDSA.prototype.verify = function verify(message, sig, pub) {\n    message = parseBytes(message);\n    sig = this.makeSignature(sig);\n    var key = this.keyFromPublic(pub);\n    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n    var SG = this.g.mul(sig.S());\n    var RplusAh = sig.R().add(key.pub().mul(h));\n    return RplusAh.eq(SG);\n};\nEDDSA.prototype.hashInt = function hashInt() {\n    var hash = this.hash();\n    for (var i = 0; i < arguments.length; i++)\n        hash.update(arguments[i]);\n    return utils.intFromLE(hash.digest()).umod(this.curve.n);\n};\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n    return KeyPair.fromPublic(this, pub);\n};\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n    return KeyPair.fromSecret(this, secret);\n};\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\n    if (sig instanceof Signature)\n        return sig;\n    return new Signature(this, sig);\n};\nEDDSA.prototype.encodePoint = function encodePoint(point) {\n    var enc = point.getY().toArray(\'le\', this.encodingLength);\n    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n    return enc;\n};\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\n    bytes = utils.parseBytes(bytes);\n    var lastIx = bytes.length - 1;\n    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n    var y = utils.intFromLE(normed);\n    return this.curve.pointFromY(y, xIsOdd);\n};\nEDDSA.prototype.encodeInt = function encodeInt(num) {\n    return num.toArray(\'le\', this.encodingLength);\n};\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\n    return utils.intFromLE(bytes);\n};\nEDDSA.prototype.isPoint = function isPoint(val) {\n    return val instanceof this.pointClass;\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2VkZHNhL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLHlEQUFTO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyxtRkFBVztBQUNoQyxZQUFZLG1CQUFPLENBQUMsaUZBQVU7QUFDOUI7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxrRkFBTztBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9lbGxpcHRpYy9lZGRzYS9pbmRleC5qcz9hYmQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGN1cnZlcyA9IHJlcXVpcmUoJy4uL2N1cnZlcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG52YXIgS2V5UGFpciA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbmZ1bmN0aW9uIEVERFNBKGN1cnZlKSB7XG4gICAgYXNzZXJ0KGN1cnZlID09PSAnZWQyNTUxOScsICdvbmx5IHRlc3RlZCB3aXRoIGVkMjU1MTkgc28gZmFyJyk7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVERFNBKSlcbiAgICAgICAgcmV0dXJuIG5ldyBFRERTQShjdXJ2ZSk7XG4gICAgY3VydmUgPSBjdXJ2ZXNbY3VydmVdLmN1cnZlO1xuICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICB0aGlzLmcgPSBjdXJ2ZS5nO1xuICAgIHRoaXMuZy5wcmVjb21wdXRlKGN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcbiAgICB0aGlzLnBvaW50Q2xhc3MgPSBjdXJ2ZS5wb2ludCgpLmNvbnN0cnVjdG9yO1xuICAgIHRoaXMuZW5jb2RpbmdMZW5ndGggPSBNYXRoLmNlaWwoY3VydmUubi5iaXRMZW5ndGgoKSAvIDgpO1xuICAgIHRoaXMuaGFzaCA9IGhhc2guc2hhNTEyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFRERTQTtcbkVERFNBLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBzZWNyZXQpIHtcbiAgICBtZXNzYWdlID0gcGFyc2VCeXRlcyhtZXNzYWdlKTtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tU2VjcmV0KHNlY3JldCk7XG4gICAgdmFyIHIgPSB0aGlzLmhhc2hJbnQoa2V5Lm1lc3NhZ2VQcmVmaXgoKSwgbWVzc2FnZSk7XG4gICAgdmFyIFIgPSB0aGlzLmcubXVsKHIpO1xuICAgIHZhciBSZW5jb2RlZCA9IHRoaXMuZW5jb2RlUG9pbnQoUik7XG4gICAgdmFyIHNfID0gdGhpcy5oYXNoSW50KFJlbmNvZGVkLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSlcbiAgICAgICAgLm11bChrZXkucHJpdigpKTtcbiAgICB2YXIgUyA9IHIuYWRkKHNfKS51bW9kKHRoaXMuY3VydmUubik7XG4gICAgcmV0dXJuIHRoaXMubWFrZVNpZ25hdHVyZSh7IFI6IFIsIFM6IFMsIFJlbmNvZGVkOiBSZW5jb2RlZCB9KTtcbn07XG5FRERTQS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZywgcHViKSB7XG4gICAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gICAgc2lnID0gdGhpcy5tYWtlU2lnbmF0dXJlKHNpZyk7XG4gICAgdmFyIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhwdWIpO1xuICAgIHZhciBoID0gdGhpcy5oYXNoSW50KHNpZy5SZW5jb2RlZCgpLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSk7XG4gICAgdmFyIFNHID0gdGhpcy5nLm11bChzaWcuUygpKTtcbiAgICB2YXIgUnBsdXNBaCA9IHNpZy5SKCkuYWRkKGtleS5wdWIoKS5tdWwoaCkpO1xuICAgIHJldHVybiBScGx1c0FoLmVxKFNHKTtcbn07XG5FRERTQS5wcm90b3R5cGUuaGFzaEludCA9IGZ1bmN0aW9uIGhhc2hJbnQoKSB7XG4gICAgdmFyIGhhc2ggPSB0aGlzLmhhc2goKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgaGFzaC51cGRhdGUoYXJndW1lbnRzW2ldKTtcbiAgICByZXR1cm4gdXRpbHMuaW50RnJvbUxFKGhhc2guZGlnZXN0KCkpLnVtb2QodGhpcy5jdXJ2ZS5uKTtcbn07XG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViKSB7XG4gICAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIpO1xufTtcbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tU2VjcmV0ID0gZnVuY3Rpb24ga2V5RnJvbVNlY3JldChzZWNyZXQpIHtcbiAgICByZXR1cm4gS2V5UGFpci5mcm9tU2VjcmV0KHRoaXMsIHNlY3JldCk7XG59O1xuRUREU0EucHJvdG90eXBlLm1ha2VTaWduYXR1cmUgPSBmdW5jdGlvbiBtYWtlU2lnbmF0dXJlKHNpZykge1xuICAgIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgICAgIHJldHVybiBzaWc7XG4gICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcywgc2lnKTtcbn07XG5FRERTQS5wcm90b3R5cGUuZW5jb2RlUG9pbnQgPSBmdW5jdGlvbiBlbmNvZGVQb2ludChwb2ludCkge1xuICAgIHZhciBlbmMgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbiAgICBlbmNbdGhpcy5lbmNvZGluZ0xlbmd0aCAtIDFdIHw9IHBvaW50LmdldFgoKS5pc09kZCgpID8gMHg4MCA6IDA7XG4gICAgcmV0dXJuIGVuYztcbn07XG5FRERTQS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcykge1xuICAgIGJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcyhieXRlcyk7XG4gICAgdmFyIGxhc3RJeCA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5vcm1lZCA9IGJ5dGVzLnNsaWNlKDAsIGxhc3RJeCkuY29uY2F0KGJ5dGVzW2xhc3RJeF0gJiB+MHg4MCk7XG4gICAgdmFyIHhJc09kZCA9IChieXRlc1tsYXN0SXhdICYgMHg4MCkgIT09IDA7XG4gICAgdmFyIHkgPSB1dGlscy5pbnRGcm9tTEUobm9ybWVkKTtcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludEZyb21ZKHksIHhJc09kZCk7XG59O1xuRUREU0EucHJvdG90eXBlLmVuY29kZUludCA9IGZ1bmN0aW9uIGVuY29kZUludChudW0pIHtcbiAgICByZXR1cm4gbnVtLnRvQXJyYXkoJ2xlJywgdGhpcy5lbmNvZGluZ0xlbmd0aCk7XG59O1xuRUREU0EucHJvdG90eXBlLmRlY29kZUludCA9IGZ1bmN0aW9uIGRlY29kZUludChieXRlcykge1xuICAgIHJldHVybiB1dGlscy5pbnRGcm9tTEUoYnl0ZXMpO1xufTtcbkVERFNBLnByb3RvdHlwZS5pc1BvaW50ID0gZnVuY3Rpb24gaXNQb2ludCh2YWwpIHtcbiAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgdGhpcy5wb2ludENsYXNzO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/key.js':
    /*!*********************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/key.js ***!
  \*********************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar cachedProperty = utils.cachedProperty;\nfunction KeyPair(eddsa, params) {\n    this.eddsa = eddsa;\n    this._secret = parseBytes(params.secret);\n    if (eddsa.isPoint(params.pub))\n        this._pub = params.pub;\n    else\n        this._pubBytes = parseBytes(params.pub);\n}\nKeyPair.fromPublic = function fromPublic(eddsa, pub) {\n    if (pub instanceof KeyPair)\n        return pub;\n    return new KeyPair(eddsa, { pub: pub });\n};\nKeyPair.fromSecret = function fromSecret(eddsa, secret) {\n    if (secret instanceof KeyPair)\n        return secret;\n    return new KeyPair(eddsa, { secret: secret });\n};\nKeyPair.prototype.secret = function secret() {\n    return this._secret;\n};\ncachedProperty(KeyPair, 'pubBytes', function pubBytes() {\n    return this.eddsa.encodePoint(this.pub());\n});\ncachedProperty(KeyPair, 'pub', function pub() {\n    if (this._pubBytes)\n        return this.eddsa.decodePoint(this._pubBytes);\n    return this.eddsa.g.mul(this.priv());\n});\ncachedProperty(KeyPair, 'privBytes', function privBytes() {\n    var eddsa = this.eddsa;\n    var hash = this.hash();\n    var lastIx = eddsa.encodingLength - 1;\n    var a = hash.slice(0, eddsa.encodingLength);\n    a[0] &= 248;\n    a[lastIx] &= 127;\n    a[lastIx] |= 64;\n    return a;\n});\ncachedProperty(KeyPair, 'priv', function priv() {\n    return this.eddsa.decodeInt(this.privBytes());\n});\ncachedProperty(KeyPair, 'hash', function hash() {\n    return this.eddsa.hash().update(this.secret()).digest();\n});\ncachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {\n    return this.hash().slice(this.eddsa.encodingLength);\n});\nKeyPair.prototype.sign = function sign(message) {\n    assert(this._secret, 'KeyPair can only verify');\n    return this.eddsa.sign(message, this);\n};\nKeyPair.prototype.verify = function verify(message, sig) {\n    return this.eddsa.verify(message, sig, this);\n};\nKeyPair.prototype.getSecret = function getSecret(enc) {\n    assert(this._secret, 'KeyPair is public only');\n    return utils.encode(this.secret(), enc);\n};\nKeyPair.prototype.getPublic = function getPublic(enc) {\n    return utils.encode(this.pubBytes(), enc);\n};\nmodule.exports = KeyPair;\n//# sourceMappingURL=key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2VkZHNhL2tleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyxpRkFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvZWxsaXB0aWMvZWRkc2Eva2V5LmpzP2UzYTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG52YXIgY2FjaGVkUHJvcGVydHkgPSB1dGlscy5jYWNoZWRQcm9wZXJ0eTtcbmZ1bmN0aW9uIEtleVBhaXIoZWRkc2EsIHBhcmFtcykge1xuICAgIHRoaXMuZWRkc2EgPSBlZGRzYTtcbiAgICB0aGlzLl9zZWNyZXQgPSBwYXJzZUJ5dGVzKHBhcmFtcy5zZWNyZXQpO1xuICAgIGlmIChlZGRzYS5pc1BvaW50KHBhcmFtcy5wdWIpKVxuICAgICAgICB0aGlzLl9wdWIgPSBwYXJhbXMucHViO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fcHViQnl0ZXMgPSBwYXJzZUJ5dGVzKHBhcmFtcy5wdWIpO1xufVxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlZGRzYSwgcHViKSB7XG4gICAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgICAgIHJldHVybiBwdWI7XG4gICAgcmV0dXJuIG5ldyBLZXlQYWlyKGVkZHNhLCB7IHB1YjogcHViIH0pO1xufTtcbktleVBhaXIuZnJvbVNlY3JldCA9IGZ1bmN0aW9uIGZyb21TZWNyZXQoZWRkc2EsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgICAgICByZXR1cm4gc2VjcmV0O1xuICAgIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBzZWNyZXQ6IHNlY3JldCB9KTtcbn07XG5LZXlQYWlyLnByb3RvdHlwZS5zZWNyZXQgPSBmdW5jdGlvbiBzZWNyZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3JldDtcbn07XG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHViQnl0ZXMnLCBmdW5jdGlvbiBwdWJCeXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVQb2ludCh0aGlzLnB1YigpKTtcbn0pO1xuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3B1YicsIGZ1bmN0aW9uIHB1YigpIHtcbiAgICBpZiAodGhpcy5fcHViQnl0ZXMpXG4gICAgICAgIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZVBvaW50KHRoaXMuX3B1YkJ5dGVzKTtcbiAgICByZXR1cm4gdGhpcy5lZGRzYS5nLm11bCh0aGlzLnByaXYoKSk7XG59KTtcbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwcml2Qnl0ZXMnLCBmdW5jdGlvbiBwcml2Qnl0ZXMoKSB7XG4gICAgdmFyIGVkZHNhID0gdGhpcy5lZGRzYTtcbiAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaCgpO1xuICAgIHZhciBsYXN0SXggPSBlZGRzYS5lbmNvZGluZ0xlbmd0aCAtIDE7XG4gICAgdmFyIGEgPSBoYXNoLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKTtcbiAgICBhWzBdICY9IDI0ODtcbiAgICBhW2xhc3RJeF0gJj0gMTI3O1xuICAgIGFbbGFzdEl4XSB8PSA2NDtcbiAgICByZXR1cm4gYTtcbn0pO1xuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3ByaXYnLCBmdW5jdGlvbiBwcml2KCkge1xuICAgIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLnByaXZCeXRlcygpKTtcbn0pO1xuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ2hhc2gnLCBmdW5jdGlvbiBoYXNoKCkge1xuICAgIHJldHVybiB0aGlzLmVkZHNhLmhhc2goKS51cGRhdGUodGhpcy5zZWNyZXQoKSkuZGlnZXN0KCk7XG59KTtcbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdtZXNzYWdlUHJlZml4JywgZnVuY3Rpb24gbWVzc2FnZVByZWZpeCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNoKCkuc2xpY2UodGhpcy5lZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG59KTtcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UpIHtcbiAgICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBjYW4gb25seSB2ZXJpZnknKTtcbiAgICByZXR1cm4gdGhpcy5lZGRzYS5zaWduKG1lc3NhZ2UsIHRoaXMpO1xufTtcbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcpIHtcbiAgICByZXR1cm4gdGhpcy5lZGRzYS52ZXJpZnkobWVzc2FnZSwgc2lnLCB0aGlzKTtcbn07XG5LZXlQYWlyLnByb3RvdHlwZS5nZXRTZWNyZXQgPSBmdW5jdGlvbiBnZXRTZWNyZXQoZW5jKSB7XG4gICAgYXNzZXJ0KHRoaXMuX3NlY3JldCwgJ0tleVBhaXIgaXMgcHVibGljIG9ubHknKTtcbiAgICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMuc2VjcmV0KCksIGVuYyk7XG59O1xuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24gZ2V0UHVibGljKGVuYykge1xuICAgIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5wdWJCeXRlcygpLCBlbmMpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gS2V5UGFpcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/key.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/signature.js':
    /*!***************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/signature.js ***!
  \***************************************************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\");\nvar assert = utils.assert;\nvar cachedProperty = utils.cachedProperty;\nvar parseBytes = utils.parseBytes;\nfunction Signature(eddsa, sig) {\n    this.eddsa = eddsa;\n    if (typeof sig !== 'object')\n        sig = parseBytes(sig);\n    if (Array.isArray(sig)) {\n        sig = {\n            R: sig.slice(0, eddsa.encodingLength),\n            S: sig.slice(eddsa.encodingLength),\n        };\n    }\n    assert(sig.R && sig.S, 'Signature without R or S');\n    if (eddsa.isPoint(sig.R))\n        this._R = sig.R;\n    if (sig.S instanceof BN)\n        this._S = sig.S;\n    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;\n    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;\n}\ncachedProperty(Signature, 'S', function S() {\n    return this.eddsa.decodeInt(this.Sencoded());\n});\ncachedProperty(Signature, 'R', function R() {\n    return this.eddsa.decodePoint(this.Rencoded());\n});\ncachedProperty(Signature, 'Rencoded', function Rencoded() {\n    return this.eddsa.encodePoint(this.R());\n});\ncachedProperty(Signature, 'Sencoded', function Sencoded() {\n    return this.eddsa.encodeInt(this.S());\n});\nSignature.prototype.toBytes = function toBytes() {\n    return this.Rencoded().concat(this.Sencoded());\n};\nSignature.prototype.toHex = function toHex() {\n    return utils.encode(this.toBytes(), 'hex').toUpperCase();\n};\nmodule.exports = Signature;\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2VkZHNhL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFNBQVMsbUJBQU8sQ0FBQywwREFBYztBQUMvQixZQUFZLG1CQUFPLENBQUMsaUZBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2VkZHNhL3NpZ25hdHVyZS5qcz9hZjk0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzL2xpYi9ibicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgY2FjaGVkUHJvcGVydHkgPSB1dGlscy5jYWNoZWRQcm9wZXJ0eTtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbmZ1bmN0aW9uIFNpZ25hdHVyZShlZGRzYSwgc2lnKSB7XG4gICAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuICAgIGlmICh0eXBlb2Ygc2lnICE9PSAnb2JqZWN0JylcbiAgICAgICAgc2lnID0gcGFyc2VCeXRlcyhzaWcpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNpZykpIHtcbiAgICAgICAgc2lnID0ge1xuICAgICAgICAgICAgUjogc2lnLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKSxcbiAgICAgICAgICAgIFM6IHNpZy5zbGljZShlZGRzYS5lbmNvZGluZ0xlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzc2VydChzaWcuUiAmJiBzaWcuUywgJ1NpZ25hdHVyZSB3aXRob3V0IFIgb3IgUycpO1xuICAgIGlmIChlZGRzYS5pc1BvaW50KHNpZy5SKSlcbiAgICAgICAgdGhpcy5fUiA9IHNpZy5SO1xuICAgIGlmIChzaWcuUyBpbnN0YW5jZW9mIEJOKVxuICAgICAgICB0aGlzLl9TID0gc2lnLlM7XG4gICAgdGhpcy5fUmVuY29kZWQgPSBBcnJheS5pc0FycmF5KHNpZy5SKSA/IHNpZy5SIDogc2lnLlJlbmNvZGVkO1xuICAgIHRoaXMuX1NlbmNvZGVkID0gQXJyYXkuaXNBcnJheShzaWcuUykgPyBzaWcuUyA6IHNpZy5TZW5jb2RlZDtcbn1cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1MnLCBmdW5jdGlvbiBTKCkge1xuICAgIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLlNlbmNvZGVkKCkpO1xufSk7XG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSJywgZnVuY3Rpb24gUigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLlJlbmNvZGVkKCkpO1xufSk7XG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSZW5jb2RlZCcsIGZ1bmN0aW9uIFJlbmNvZGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMuUigpKTtcbn0pO1xuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnU2VuY29kZWQnLCBmdW5jdGlvbiBTZW5jb2RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVJbnQodGhpcy5TKCkpO1xufSk7XG5TaWduYXR1cmUucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKCkge1xuICAgIHJldHVybiB0aGlzLlJlbmNvZGVkKCkuY29uY2F0KHRoaXMuU2VuY29kZWQoKSk7XG59O1xuU2lnbmF0dXJlLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uIHRvSGV4KCkge1xuICAgIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy50b0J5dGVzKCksICdoZXgnKS50b1VwcGVyQ2FzZSgpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/signature.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/index.js':
    /*!*****************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/index.js ***!
  \*****************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.utils = exports.curves = exports.curve = exports.eddsa = exports.ec = void 0;\nconst curve = __webpack_require__(/*! ./curve */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curve/index.js");\nexports.curve = curve;\nconst curves = __webpack_require__(/*! ./curves */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/curves.js");\nexports.curves = curves;\nconst ec = __webpack_require__(/*! ./ec */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/ec/index.js");\nexports.ec = ec;\nconst eddsa = __webpack_require__(/*! ./eddsa */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/eddsa/index.js");\nexports.eddsa = eddsa;\nconst utils = __webpack_require__(/*! ./utils */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js");\nexports.utils = utils;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxVQUFVO0FBQzNFLGNBQWMsbUJBQU8sQ0FBQyxzRkFBUztBQUMvQixhQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLGtGQUFVO0FBQ2pDLGNBQWM7QUFDZCxXQUFXLG1CQUFPLENBQUMsZ0ZBQU07QUFDekIsVUFBVTtBQUNWLGNBQWMsbUJBQU8sQ0FBQyxzRkFBUztBQUMvQixhQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLGdGQUFTO0FBQy9CLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9lbGxpcHRpYy9pbmRleC5qcz8yZmNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRpbHMgPSBleHBvcnRzLmN1cnZlcyA9IGV4cG9ydHMuY3VydmUgPSBleHBvcnRzLmVkZHNhID0gZXhwb3J0cy5lYyA9IHZvaWQgMDtcbmNvbnN0IGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuZXhwb3J0cy5jdXJ2ZSA9IGN1cnZlO1xuY29uc3QgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMnKTtcbmV4cG9ydHMuY3VydmVzID0gY3VydmVzO1xuY29uc3QgZWMgPSByZXF1aXJlKCcuL2VjJyk7XG5leHBvcnRzLmVjID0gZWM7XG5jb25zdCBlZGRzYSA9IHJlcXVpcmUoJy4vZWRkc2EnKTtcbmV4cG9ydHMuZWRkc2EgPSBlZGRzYTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuZXhwb3J0cy51dGlscyA9IHV0aWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/precomputed/secp256k1.js':
    /*!*********************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/precomputed/secp256k1.js ***!
  \*********************************************************************************/
    /***/ (module) => {
      'use strict';
      eval(
        "\nmodule.exports = {\n    doubles: {\n        step: 4,\n        points: [\n            [\n                'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',\n                'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',\n            ],\n            [\n                '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',\n                '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',\n            ],\n            [\n                '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',\n                'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',\n            ],\n            [\n                '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',\n                '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',\n            ],\n            [\n                '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',\n                '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',\n            ],\n            [\n                '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',\n                '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',\n            ],\n            [\n                'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',\n                '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',\n            ],\n            [\n                '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',\n                'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',\n            ],\n            [\n                'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',\n                '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',\n            ],\n            [\n                'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',\n                'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',\n            ],\n            [\n                'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',\n                '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',\n            ],\n            [\n                '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',\n                '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',\n            ],\n            [\n                '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',\n                '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',\n            ],\n            [\n                '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',\n                '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',\n            ],\n            [\n                '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',\n                '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',\n            ],\n            [\n                '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',\n                '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',\n            ],\n            [\n                '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',\n                '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',\n            ],\n            [\n                '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',\n                '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',\n            ],\n            [\n                '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',\n                'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',\n            ],\n            [\n                'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',\n                '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',\n            ],\n            [\n                'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',\n                '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',\n            ],\n            [\n                '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',\n                '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',\n            ],\n            [\n                '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',\n                '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',\n            ],\n            [\n                'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',\n                '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',\n            ],\n            [\n                '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',\n                'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',\n            ],\n            [\n                'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',\n                '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',\n            ],\n            [\n                'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',\n                'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',\n            ],\n            [\n                'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',\n                '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',\n            ],\n            [\n                'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',\n                'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',\n            ],\n            [\n                'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',\n                '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',\n            ],\n            [\n                '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',\n                'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',\n            ],\n            [\n                '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',\n                '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',\n            ],\n            [\n                'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',\n                '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',\n            ],\n            [\n                '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',\n                'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',\n            ],\n            [\n                'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',\n                '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',\n            ],\n            [\n                'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',\n                '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',\n            ],\n            [\n                'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',\n                'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',\n            ],\n            [\n                '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',\n                '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',\n            ],\n            [\n                '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',\n                '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',\n            ],\n            [\n                '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',\n                'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',\n            ],\n            [\n                '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',\n                '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',\n            ],\n            [\n                'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',\n                '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',\n            ],\n            [\n                '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',\n                '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',\n            ],\n            [\n                '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',\n                'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',\n            ],\n            [\n                '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',\n                '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',\n            ],\n            [\n                'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',\n                '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',\n            ],\n            [\n                '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',\n                'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',\n            ],\n            [\n                'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',\n                'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',\n            ],\n            [\n                'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',\n                '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',\n            ],\n            [\n                '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',\n                'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',\n            ],\n            [\n                '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',\n                'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',\n            ],\n            [\n                'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',\n                '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',\n            ],\n            [\n                'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',\n                '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',\n            ],\n            [\n                'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',\n                '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',\n            ],\n            [\n                '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',\n                'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',\n            ],\n            [\n                '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',\n                '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',\n            ],\n            [\n                'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',\n                'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',\n            ],\n            [\n                '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',\n                'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',\n            ],\n            [\n                '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',\n                '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',\n            ],\n            [\n                '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',\n                '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',\n            ],\n            [\n                'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',\n                'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',\n            ],\n            [\n                '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',\n                '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',\n            ],\n            [\n                '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',\n                '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',\n            ],\n            [\n                'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',\n                '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',\n            ],\n            [\n                'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',\n                'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',\n            ],\n        ],\n    },\n    naf: {\n        wnd: 7,\n        points: [\n            [\n                'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',\n                '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',\n            ],\n            [\n                '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',\n                'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',\n            ],\n            [\n                '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',\n                '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',\n            ],\n            [\n                'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',\n                'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',\n            ],\n            [\n                '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',\n                'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',\n            ],\n            [\n                'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',\n                'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',\n            ],\n            [\n                'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',\n                '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',\n            ],\n            [\n                'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',\n                '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',\n            ],\n            [\n                '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',\n                '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',\n            ],\n            [\n                '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',\n                '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',\n            ],\n            [\n                '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',\n                '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',\n            ],\n            [\n                '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',\n                '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',\n            ],\n            [\n                'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',\n                'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',\n            ],\n            [\n                'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',\n                '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',\n            ],\n            [\n                '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',\n                'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',\n            ],\n            [\n                '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',\n                'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',\n            ],\n            [\n                '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',\n                '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',\n            ],\n            [\n                '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',\n                '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',\n            ],\n            [\n                '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',\n                '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',\n            ],\n            [\n                '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',\n                'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',\n            ],\n            [\n                'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',\n                'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',\n            ],\n            [\n                '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',\n                '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',\n            ],\n            [\n                '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',\n                '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',\n            ],\n            [\n                'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',\n                'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',\n            ],\n            [\n                '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',\n                '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',\n            ],\n            [\n                'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',\n                'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',\n            ],\n            [\n                'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',\n                'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',\n            ],\n            [\n                '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',\n                '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',\n            ],\n            [\n                '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',\n                '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',\n            ],\n            [\n                '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',\n                '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',\n            ],\n            [\n                'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',\n                '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',\n            ],\n            [\n                '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',\n                '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',\n            ],\n            [\n                'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',\n                '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',\n            ],\n            [\n                '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',\n                'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',\n            ],\n            [\n                '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',\n                'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',\n            ],\n            [\n                'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',\n                'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',\n            ],\n            [\n                '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',\n                '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',\n            ],\n            [\n                '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',\n                'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',\n            ],\n            [\n                'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',\n                'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',\n            ],\n            [\n                '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',\n                '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',\n            ],\n            [\n                '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',\n                'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',\n            ],\n            [\n                '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',\n                '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',\n            ],\n            [\n                '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',\n                'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',\n            ],\n            [\n                'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',\n                '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',\n            ],\n            [\n                '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',\n                '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',\n            ],\n            [\n                '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',\n                'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',\n            ],\n            [\n                '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',\n                'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',\n            ],\n            [\n                'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',\n                'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',\n            ],\n            [\n                'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',\n                'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',\n            ],\n            [\n                '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',\n                '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',\n            ],\n            [\n                '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',\n                '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',\n            ],\n            [\n                'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',\n                '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',\n            ],\n            [\n                'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',\n                'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',\n            ],\n            [\n                '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',\n                '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',\n            ],\n            [\n                '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',\n                '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',\n            ],\n            [\n                'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',\n                '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',\n            ],\n            [\n                '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',\n                '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',\n            ],\n            [\n                'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',\n                'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',\n            ],\n            [\n                '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',\n                'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',\n            ],\n            [\n                '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',\n                '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',\n            ],\n            [\n                'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',\n                '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',\n            ],\n            [\n                'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',\n                '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',\n            ],\n            [\n                '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',\n                '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',\n            ],\n            [\n                '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',\n                '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',\n            ],\n            [\n                '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',\n                'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',\n            ],\n            [\n                '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',\n                'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',\n            ],\n            [\n                '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',\n                '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',\n            ],\n            [\n                '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',\n                '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',\n            ],\n            [\n                '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',\n                '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',\n            ],\n            [\n                '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',\n                'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',\n            ],\n            [\n                'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',\n                'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',\n            ],\n            [\n                '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',\n                'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',\n            ],\n            [\n                'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',\n                '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',\n            ],\n            [\n                'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',\n                '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',\n            ],\n            [\n                'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',\n                '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',\n            ],\n            [\n                'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',\n                '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',\n            ],\n            [\n                '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',\n                'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',\n            ],\n            [\n                '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',\n                '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',\n            ],\n            [\n                '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',\n                'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',\n            ],\n            [\n                'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',\n                'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',\n            ],\n            [\n                'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',\n                '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',\n            ],\n            [\n                'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',\n                'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',\n            ],\n            [\n                'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',\n                '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',\n            ],\n            [\n                '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',\n                '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',\n            ],\n            [\n                'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',\n                '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',\n            ],\n            [\n                'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',\n                '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',\n            ],\n            [\n                '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',\n                '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',\n            ],\n            [\n                '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',\n                'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',\n            ],\n            [\n                'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',\n                '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',\n            ],\n            [\n                'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',\n                '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',\n            ],\n            [\n                'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',\n                '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',\n            ],\n            [\n                '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',\n                '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',\n            ],\n            [\n                'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',\n                'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',\n            ],\n            [\n                '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',\n                'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',\n            ],\n            [\n                'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',\n                'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',\n            ],\n            [\n                'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',\n                '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',\n            ],\n            [\n                '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',\n                'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',\n            ],\n            [\n                'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',\n                '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',\n            ],\n            [\n                'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',\n                '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',\n            ],\n            [\n                'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',\n                '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',\n            ],\n            [\n                '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',\n                'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',\n            ],\n            [\n                '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',\n                'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',\n            ],\n            [\n                'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',\n                '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',\n            ],\n            [\n                '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',\n                'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',\n            ],\n            [\n                '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',\n                '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',\n            ],\n            [\n                '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',\n                'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',\n            ],\n            [\n                'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',\n                'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',\n            ],\n            [\n                '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',\n                'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',\n            ],\n            [\n                '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',\n                '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',\n            ],\n            [\n                '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',\n                'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',\n            ],\n            [\n                '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',\n                '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',\n            ],\n            [\n                'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',\n                'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',\n            ],\n            [\n                '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',\n                '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',\n            ],\n            [\n                'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',\n                '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',\n            ],\n            [\n                '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',\n                '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',\n            ],\n            [\n                'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',\n                'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',\n            ],\n            [\n                'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',\n                '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',\n            ],\n            [\n                'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',\n                'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',\n            ],\n            [\n                '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',\n                'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',\n            ],\n            [\n                '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',\n                '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',\n            ],\n            [\n                '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',\n                'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',\n            ],\n            [\n                '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',\n                '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',\n            ],\n            [\n                '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',\n                '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',\n            ],\n            [\n                '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',\n                'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',\n            ],\n            [\n                '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',\n                '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',\n            ],\n            [\n                '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',\n                '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',\n            ],\n            [\n                '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',\n                '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',\n            ],\n        ],\n    },\n};\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL3ByZWNvbXB1dGVkL3NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9lbGxpcHRpYy9wcmVjb21wdXRlZC9zZWNwMjU2azEuanM/NWFmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRvdWJsZXM6IHtcbiAgICAgICAgc3RlcDogNCxcbiAgICAgICAgcG9pbnRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2U2MGZjZTkzYjU5ZTllYzUzMDExYWFiYzIxYzIzZTk3YjJhMzEzNjliODdhNWFlOWM0NGVlODllMmE2ZGVjMGEnLFxuICAgICAgICAgICAgICAgICdmN2UzNTA3Mzk5ZTU5NTkyOWRiOTlmMzRmNTc5MzcxMDEyOTY4OTFlNDRkMjNmMGJlMWYzMmNjZTY5NjE2ODIxJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzgyODIyNjMyMTJjNjA5ZDllYTJhNmUzZTE3MmRlMjM4ZDhjMzljYWJkNWFjMWNhMTA2NDZlMjNmZDVmNTE1MDgnLFxuICAgICAgICAgICAgICAgICcxMWY4YTgwOTg1NTdkZmU0NWU4MjU2ZTgzMGI2MGFjZTYyZDYxM2FjMmY3YjE3YmVkMzFiNmVhZmY2ZTI2Y2FmJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzE3NWUxNTlmNzI4Yjg2NWE3MmY5OWNjNmM2ZmM4NDZkZTBiOTM4MzNmZDIyMjJlZDczZmNlNWI1NTFlNWI3MzknLFxuICAgICAgICAgICAgICAgICdkMzUwNmUwZDllM2M3OWViYTRlZjk3YTUxZmY3MWY1ZWFjYjU5NTVhZGQyNDM0NWM2ZWZhNmZmZWU5ZmVkNjk1JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzM2M2Q5MGQ0NDdiMDBjOWM5OWNlYWMwNWI2MjYyZWUwNTM0NDFjN2U1NTU1MmZmZTUyNmJhZDhmODNmZjQ2NDAnLFxuICAgICAgICAgICAgICAgICc0ZTI3M2FkZmM3MzIyMjE5NTNiNDQ1Mzk3ZjMzNjMxNDViOWE4OTAwODE5OWVjYjYyMDAzYzdmM2JlZTlkZTknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOGI0YjVmMTY1ZGYzYzJiZThjNjI0NGI1Yjc0NTYzODg0M2U0YTc4MWExNWJjZDFiNjlmNzlhNTVkZmZkZjgwYycsXG4gICAgICAgICAgICAgICAgJzRhYWQwYTZmNjhkMzA4YjRiM2ZiZDc4MTNhYjBkYTA0ZjllMzM2NTQ2MTYyZWU1NmIzZWZmMGM2NWZkNGZkMzYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNzIzY2JhYTZlNWRiOTk2ZDZiZjc3MWMwMGJkNTQ4YzdiNzAwZGJmZmE2YzBlNzdiY2I2MTE1OTI1MjMyZmNkYScsXG4gICAgICAgICAgICAgICAgJzk2ZTg2N2I1NTk1Y2M0OThhOTIxMTM3NDg4ODI0ZDZlMjY2MGEwNjUzNzc5NDk0ODAxZGMwNjlkOWViMzlmNWYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZWViZmE0ZDQ5M2JlYmY5OGJhNWZlZWM4MTJjMmQzYjUwOTQ3OTYxMjM3YTkxOTgzOWE1MzNlY2EwZTdkZDdmYScsXG4gICAgICAgICAgICAgICAgJzVkOWE4Y2EzOTcwZWYwZjI2OWVlN2VkYWYxNzgwODlkOWFlNGNkYzNhNzExZjcxMmRkZmQ0ZmRhZTFkZTg5OTknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMTAwZjQ0ZGE2OTZlNzE2NzI3OTFkMGEwOWI3YmRlNDU5ZjEyMTVhMjliM2MwM2JmZWZkNzgzNWIzOWE0OGRiMCcsXG4gICAgICAgICAgICAgICAgJ2NkZDllMTMxOTJhMDBiNzcyZWM4ZjMzMDBjMDkwNjY2YjdmZjRhMThmZjUxOTVhYzBmYmQ1Y2Q2MmJjNjVhMDknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZTEwMzFiZTI2MmM3ZWQxYjFkYzkyMjdhNGEwNGMwMTdhNzdmOGQ0NDY0ZjNiMzg1MmM4YWNkZTZlNTM0ZmQyZCcsXG4gICAgICAgICAgICAgICAgJzlkNzA2MTkyODk0MDQwNWU2YmI2YTQxNzY1OTc1MzVhZjI5MmRkNDE5ZTFjZWQ3OWE0NGYxOGYyOTQ1NmEwMGQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZmVlYTZjYWU0NmQ1NWI1MzBhYzI4MzlmMTQzYmQ3ZWM1Y2Y4YjI2NmE0MWQ2YWY1MmQ1ZTY4OGQ5MDk0Njk2ZCcsXG4gICAgICAgICAgICAgICAgJ2U1N2M2YjZjOTdkY2UxYmFiMDZlNGUxMmJmM2VjZDVjOTgxYzg5NTdjYzQxNDQyZDMxNTVkZWJmMTgwOTAwODgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZGE2N2E5MWQ5MTA0OWNkY2IzNjdiZTRiZTZmZmNhM2NmZWVkNjU3ZDgwODU4M2RlMzNmYTk3OGJjMWVjNmNiMScsXG4gICAgICAgICAgICAgICAgJzliYWNhYTM1NDgxNjQyYmM0MWY0NjNmN2VjOTc4MGU1ZGVjN2FkYzUwOGY3NDBhMTdlOWVhOGUyN2E2OGJlMWQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNTM5MDRmYWEwYjMzNGNkZGE2ZTAwMDkzNWVmMjIxNTFlYzA4ZDBmN2JiMTEwNjlmNTc1NDVjY2MxYTM3YjdjMCcsXG4gICAgICAgICAgICAgICAgJzViYzA4N2QwYmM4MDEwNmQ4OGM5ZWNjYWMyMGQzYzFjMTM5OTk5ODFlMTQ0MzQ2OTlkY2IwOTZiMDIyNzcxYzgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOGU3YmNkMGJkMzU5ODNhNzcxOWNjYTc3NjRjYTkwNjc3OWI1M2EwNDNhOWI4YmNhZWZmOTU5ZjQzYWQ4NjA0NycsXG4gICAgICAgICAgICAgICAgJzEwYjc3NzBiMmEzZGE0YjM5NDAzMTA0MjBjYTk1MTQ1NzllODhlMmU0N2ZkNjhiM2VhMTAwNDdlODQ2MDM3MmEnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMzg1ZWVkMzRjMWNkZmYyMWU2ZDA4MTg2ODliODFiZGU3MWE3ZjRmMTgzOTdlNjY5MGE4NDFlMTU5OWM0Mzg2MicsXG4gICAgICAgICAgICAgICAgJzI4M2JlYmMzZThlYTIzZjU2NzAxZGUxOWU5ZWJmNDU3NmIzMDRlZWMyMDg2ZGM4Y2MwNDU4ZmU1NTQyZTU0NTMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNmY5ZDliODAzZWNmMTkxNjM3YzczYTQ0MTNkZmExODBmZGRmODRhNTk0N2ZiYzljNjA2ZWQ4NmMzZmFjM2E3JyxcbiAgICAgICAgICAgICAgICAnN2M4MGM2OGU2MDMwNTliYTY5YjhlMmEzMGU0NWM0ZDQ3ZWE0ZGQyZjVjMjgxMDAyZDg2ODkwNjAzYTg0MjE2MCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICczMzIyZDQwMTI0M2M0ZTI1ODJhMjE0N2MxMDRkNmVjYmY3NzRkMTYzZGIwZjVlNTMxM2I3ZTBlNzQyZDBlNmJkJyxcbiAgICAgICAgICAgICAgICAnNTZlNzA3OTdlOTY2NGVmNWJmYjAxOWJjNGRkYWY5YjcyODA1ZjYzZWEyODczYWY2MjRmM2EyZTk2YzI4YjJhMCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc4NTY3MmM3ZDJkZTBiN2RhMmJkMTc3MGQ4OTY2NTg2ODc0MWIzZjlhZjc2NDMzOTc3MjFkNzRkMjgxMzRhYjgzJyxcbiAgICAgICAgICAgICAgICAnN2M0ODFiOWI1YjQzYjJlYjYzNzQwNDliZmE2MmMyZTVlNzdmMTdmY2M1Mjk4ZjQ0YzhlMzA5NGY3OTAzMTNhNicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc5NDhiZjgwOWIxOTg4YTQ2YjA2YzlmMTkxOTQxM2IxMGY5MjI2YzYwZjY2ODgzMmZmZDk1OWFmNjBjODJhMGEnLFxuICAgICAgICAgICAgICAgICc1M2E1NjI4NTZkY2I2NjQ2ZGM2Yjc0YzVkMWMzNDE4YzZkNGRmZjA4Yzk3Y2QyYmVkNGNiN2Y4OGQ4YzhlNTg5JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzYyNjBjZTdmNDYxODAxYzM0ZjA2N2NlMGYwMjg3M2E4ZjFiMGU0NGRmYzY5NzUyYWNjZWNkODE5ZjM4ZmQ4ZTgnLFxuICAgICAgICAgICAgICAgICdiYzJkYTgyYjZmYTViNTcxYTdmMDkwNDk3NzZhMWVmN2VjZDI5MjIzODA1MWMxOThjMWE4NGU5NWIyYjRhZTE3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2U1MDM3ZGUwYWZjMWQ4ZDQzZDgzNDg0MTRiYmY0MTAzMDQzZWM4ZjU3NWJmZGM0MzI5NTNjYzhkMjAzN2ZhMmQnLFxuICAgICAgICAgICAgICAgICc0NTcxNTM0YmFhOTRkM2I1ZjlmOThkMDlmYjk5MGJkZGJkNWY1YjAzZWM0ODFmMTBlMGU1ZGM4NDFkNzU1YmRhJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2UwNjM3MmIwZjRhMjA3YWRmNWVhOTA1ZThmMTc3MWI0ZTdlOGRiZDFjNmE2YzViNzI1ODY2YTBhZTRmY2U3MjUnLFxuICAgICAgICAgICAgICAgICc3YTkwODk3NGJjZTE4Y2ZlMTJhMjdiYjJhZDVhNDg4Y2Q3NDg0YTc3ODcxMDQ4NzBiMjcwMzRmOTRlZWUzMWRkJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzIxM2M3YTcxNWNkNWQ0NTM1OGQwYmJmOWRjMGNlMDIyMDRiMTBiZGRlMmEzZjU4NTQwYWQ2OTA4ZDA1NTk3NTQnLFxuICAgICAgICAgICAgICAgICc0YjZkYWQwYjVhZTQ2MjUwNzAxM2FkMDYyNDViYTE5MGJiNDg1MGY1ZjM2YTdlZWRkZmYyYzI3NTM0YjQ1OGYyJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzRlN2MyNzJhN2FmNGIzNGU4ZGJiOTM1MmE1NDE5YTg3ZTI4MzhjNzBhZGM2MmNkZGYwY2MzYTNiMDhmYmQ1M2MnLFxuICAgICAgICAgICAgICAgICcxNzc0OWM3NjZjOWQwYjE4ZTE2ZmQwOWY2ZGVmNjgxYjUzMGI5NjE0YmZmN2RkMzNlMGIzOTQxODE3ZGNhYWU2JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2ZlYTc0ZTNkYmU3NzhiMWIxMGYyMzhhZDYxNjg2YWE1Yzc2ZTNkYjJiZTQzMDU3NjMyNDI3ZTI4NDBmYjI3YjYnLFxuICAgICAgICAgICAgICAgICc2ZTA1NjhkYjliMGIxMzI5N2NmNjc0ZGVjY2I2YWY5MzEyNmI1OTZiOTczZjdiNzc3MDFkM2RiN2YyM2NiOTZmJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzc2ZTY0MTEzZjY3N2NmMGUxMGEyNTcwZDU5OTk2OGQzMTU0NGUxNzliNzYwNDMyOTUyYzAyYTQ0MTdiZGRlMzknLFxuICAgICAgICAgICAgICAgICdjOTBkZGY4ZGVlNGU5NWNmNTc3MDY2ZDcwNjgxZjBkMzVlMmEzM2QyYjU2ZDIwMzJiNGIxNzUyZDE5MDFhYzAxJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2M3MzhjNTZiMDNiMmFiZTFlODI4MWJhYTc0M2Y4ZjlhOGY3Y2M2NDNkZjI2Y2JlZTNhYjE1MDI0MmJjYmI4OTEnLFxuICAgICAgICAgICAgICAgICc4OTNmYjU3ODk1MWFkMjUzN2Y3MThmMmVhY2JmYmJiYjgyMzE0ZWVmNzg4MGNmZTkxN2U3MzVkOTY5OWE4NGMzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2Q4OTU2MjY1NDhiNjViODFlMjY0Yzc2MzdjOTcyODc3ZDFkNzJlNWYzYTkyNTAxNDM3MmU5ZjY1ODhmNmMxNGInLFxuICAgICAgICAgICAgICAgICdmZWJmYWEzOGYyYmM3ZWFlNzI4ZWM2MDgxOGMzNDBlYjAzNDI4ZDYzMmJiMDY3ZTE3OTM2M2VkNzVkN2Q5OTFmJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2I4ZGE5NDAzMmE5NTc1MThlYjBmNjQzMzU3MWU4NzYxY2VmZmM3MzY5M2U4NGVkZDQ5MTUwYTU2NGY2NzZlMDMnLFxuICAgICAgICAgICAgICAgICcyODA0ZGZhNDQ4MDVhMWU0ZDdjOTljYzk3NjI4MDhiMDkyY2M1ODRkOTVmZjNiNTExNDg4ZTRlNzRlZmRmNmU3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2U4MGZlYTE0NDQxZmIzM2E3ZDhhZGFiOTQ3NWQ3ZmFiMjAxOWVmZmI1MTU2YTc5MmYxYTExNzc4ZTNjMGRmNWQnLFxuICAgICAgICAgICAgICAgICdlZWQxZGU3ZjYzOGUwMDc3MWU4OTc2OGNhM2NhOTQ0NzJkMTU1ZTgwYWYzMjJlYTlmY2I0MjkxYjZhYzllYzc4JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2EzMDE2OTdiZGZjZDcwNDMxM2JhNDhlNTFkNTY3NTQzZjJhMTgyMDMxZWZkNjkxNWRkYzA3YmJjYzRlMTYwNzAnLFxuICAgICAgICAgICAgICAgICc3MzcwZjkxY2ZiNjdlNGY1MDgxODA5ZmEyNWQ0MGY5YjE3MzVkYmY3YzBhMTFhMTMwYzBkMWEwNDFlMTc3ZWExJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzkwYWQ4NWIzODlkNmI5MzY0NjNmOWQwNTEyNjc4ZGUyMDhjYzMzMGIxMTMwN2ZmZmFiN2FjNjNlM2ZiMDRlZDQnLFxuICAgICAgICAgICAgICAgICdlNTA3YTM2MjBhMzgyNjFhZmZkY2JkOTQyNzIyMmI4MzlhZWZhYmUxNTgyODk0ZDk5MWQ0ZDQ4Y2I2ZWYxNTAnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOGY2OGI5ZDJmNjNiNWYzMzkyMzljMWFkOTgxZjE2MmVlODhjNTY3ODcyM2VhMzM1MWI3YjQ0NGM5ZWM0YzBkYScsXG4gICAgICAgICAgICAgICAgJzY2MmE5ZjJkYmEwNjM5ODZkZTFkOTBjMmI2YmUyMTVkYmJlYTJjZmU5NTUxMGJmZGYyM2NiZjc5NTAxZmZmODInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZTRmM2ZiMDE3NmFmODVkNjVmZjk5ZmY5MTk4YzM2MDkxZjQ4ZTg2NTAzNjgxZTNlNjY4NmZkNTA1MzIzMWUxMScsXG4gICAgICAgICAgICAgICAgJzFlNjM2MzNhZDBlZjRmMWMxNjYxYTZkMGVhMDJiNzI4NmNjN2U3NGVjOTUxZDFjOTgyMmMzODU3NmZlYjczYmMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOGMwMGZhOWIxOGViZjMzMWViOTYxNTM3YTQ1YTQyNjZjNzAzNGYyZjBkNGUxZDA3MTZmYjZlYWUyMGVhZTI5ZScsXG4gICAgICAgICAgICAgICAgJ2VmYTQ3MjY3ZmVhNTIxYTFhOWRjMzQzYTM3MzZjOTc0YzJmYWRhZmE4MWUzNmM1NGU3ZDJhNGM2NjcwMjQxNGInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZTdhMjZjZTY5ZGQ0ODI5ZjNlMTBjZWMwYTllOThlZDMxNDNkMDg0ZjMwOGI5MmMwOTk3ZmRkZmM2MGNiM2U0MScsXG4gICAgICAgICAgICAgICAgJzJhNzU4ZTMwMGZhNzk4NGI0NzFiMDA2YTFhYWZiYjE4ZDBhNmIyYzA0MjBlODNlMjBlOGE5NDIxY2YyY2ZkNTEnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnYjY0NTllMGVlMzY2MmVjOGQyMzU0MGMyMjNiY2JkYzU3MWNiY2I5NjdkNzk0MjRmM2NmMjllYjNkZTZiODBlZicsXG4gICAgICAgICAgICAgICAgJzY3Yzg3NmQwNmYzZTA2ZGUxZGFkZjE2ZTU2NjFkYjNjNGIzYWU2ZDQ4ZTM1YjJmZjMwYmYwYjYxYTcxYmE0NScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdkNjhhODBjODI4MGJiODQwNzkzMjM0YWExMThmMDYyMzFkNmYxZmM2N2U3M2M1YTVkZWRhMGY1YjQ5Njk0M2U4JyxcbiAgICAgICAgICAgICAgICAnZGI4YmE5ZmZmNGI1ODZkMDBjNGIxZjkxNzdiMGUyOGI1YjBlN2I4Zjc4NDUyOTVhMjk0Yzg0MjY2YjEzMzEyMCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICczMjRhZWQ3ZGY2NWM4MDQyNTJkYzAyNzA5MDdhMzBiMDk2MTJhZWI5NzM0NDljZWE0MDk1OTgwZmMyOGQzZDVkJyxcbiAgICAgICAgICAgICAgICAnNjQ4YTM2NTc3NGI2MWYyZmYxMzBjMGMzNWFlYzFmNGYxOTIxM2IwYzdlMzMyODQzOTY3MjI0YWY5NmFiN2M4NCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc0ZGY5YzE0OTE5Y2RlNjFmNmQ1MWRmZGJlNWZlZTVkY2VlYzQxNDNiYThkMWNhODg4ZThiZDM3M2ZkMDU0Yzk2JyxcbiAgICAgICAgICAgICAgICAnMzVlYzUxMDkyZDg3MjgwNTA5NzRjMjNhMWQ4NWQ0YjVkNTA2Y2RjMjg4NDkwMTkyZWJhYzA2Y2FkMTBkNWQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOWMzOTE5YTg0YTQ3NDg3MGZhZWQ4YTljMWNjNjYwMjE1MjM0ODkwNTRkN2YwMzA4Y2JmYzk5YzhhYzFmOThjZCcsXG4gICAgICAgICAgICAgICAgJ2RkYjg0ZjBmNGE0ZGRkNTc1ODRmMDQ0YmYyNjBlNjQxOTA1MzI2Zjc2YzY0YzhlNmJlN2U1ZTAzZDRmYzU5OWQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNjA1NzE3MGIxZGQxMmZkZjhkZTA1ZjI4MWQ4ZTA2YmI5MWUxNDkzYThiOTFkNGNjNWEyMTM4MjEyMGE5NTllNScsXG4gICAgICAgICAgICAgICAgJzlhMWFmMGIyNmE2YTQ4MDdhZGQ5YTJkYWY3MWRmMjYyNDY1MTUyYmMzZWUyNGM2NWU4OTliZTkzMjM4NWEyYTgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnYTU3NmRmOGUyM2EwODQxMTQyMTQzOWE0NTE4ZGEzMTg4MGNlZjBmYmE3ZDRkZjEyYjFhNjk3M2VlY2I5NDI2NicsXG4gICAgICAgICAgICAgICAgJzQwYTZiZjIwZTc2NjQwYjJjOTJiOTdhZmU1OGNkODJjNDMyZTEwYTdmNTE0ZDlmM2VlOGJlMTFhZTFiMjhlYzgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNzc3OGE3OGMyOGRlYzNlMzBhMDVmZTk2MjlkZThjMzhiYjMwZDFmNWNmOWEzYTIwOGY3NjM4ODliZTU4YWQ3MScsXG4gICAgICAgICAgICAgICAgJzM0NjI2ZDlhYjVhNWIyMmZmNzA5OGUxMmYyZmY1ODAwODdiMzg0MTFmZjI0YWM1NjNiNTEzZmMxZmQ5ZjQzYWMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOTI4OTU1ZWU2MzdhODQ0NjM3MjlmZDMwZTdhZmQyZWQ1Zjk2Mjc0ZTVhZDdlNWNiMDllZGE5YzA2ZDkwM2FjJyxcbiAgICAgICAgICAgICAgICAnYzI1NjIxMDAzZDNmNDJhODI3Yjc4YTEzMDkzYTk1ZWVhYzNkMjZlZmE4YThkODNmYzUxODBlOTM1YmNkMDkxZicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc4NWQwZmVmM2VjNmRiMTA5Mzk5MDY0ZjNhMGUzYjI4NTU2NDViNGE5MDdhZDM1NDUyN2FhZTc1MTYzZDgyNzUxJyxcbiAgICAgICAgICAgICAgICAnMWYwMzY0ODQxM2EzOGMwYmUyOWQ0OTZlNTgyY2Y1NjYzZTg3NTFlOTY4NzczMzE1ODJjMjM3YTI0ZWIxZjk2MicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdmZjJiMGRjZTk3ZWVjZTk3YzFjOWI2MDQxNzk4Yjg1ZGZkZmI2ZDg4ODJkYTIwMzA4ZjU0MDQ4MjQ1MjYwODdlJyxcbiAgICAgICAgICAgICAgICAnNDkzZDEzZmVmNTI0YmExODhhZjRjNGRjNTRkMDc5MzZjN2I3ZWQ2ZmI5MGUyY2ViMmM5NTFlMDFmMGMyOTkwNycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc4MjdmYmJlNGIxZTg4MGVhOWVkMmIyZTYzMDFiMjEyYjU3ZjFlZTE0OGNkNmRkMjg3ODBlNWUyY2Y4NTZlMjQxJyxcbiAgICAgICAgICAgICAgICAnYzYwZjljOTIzYzcyN2IwYjcxYmVmMmM2N2QxZDEyNjg3ZmY3YTYzMTg2OTAzMTY2ZDYwNWI2OGJhZWMyOTNlYycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdlYWE2NDlmMjFmNTFiZGJhZTdiZTRhZTM0Y2U2ZTUyMTdhNThmZGNlN2Y0N2Y5YWE3ZjNiNThmYTIxMjBlMmIzJyxcbiAgICAgICAgICAgICAgICAnYmUzMjc5ZWQ1YmJiYjAzYWM2OWE4MGY4OTg3OWFhNWEwMWE2Yjk2NWYxM2Y3ZTU5ZDQ3YTUzMDViYTVhZDkzZCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdlNGE0MmQ0M2M1Y2YxNjlkOTM5MWRmNmRlY2Y0MmVlNTQxYjZkOGYwYzlhMTM3NDAxZTIzNjMyZGRhMzRkMjRmJyxcbiAgICAgICAgICAgICAgICAnNGQ5ZjkyZTcxNmQxYzczNTI2ZmM5OWNjZmI4YWQzNGNlODg2ZWVkZmE4ZDhlNGYxM2E3ZjcxMzFkZWJhOTQxNCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcxZWM4MGZlZjM2MGNiZGQ5NTQxNjBmYWRhYjM1MmI2YjkyYjUzNTc2YTg4ZmVhNDk0NzE3M2I5ZDQzMDBiZjE5JyxcbiAgICAgICAgICAgICAgICAnYWVlZmU5Mzc1NmI1MzQwZDJmM2E0OTU4YTdhYmJmNWUwMTQ2ZTc3ZjYyOTVhMDdiNjcxY2RjMWNjMTA3Y2VmZCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcxNDZhNzc4YzA0NjcwYzJmOTFiMDBhZjQ2ODBkZmE4YmNlMzQ5MDcxN2Q1OGJhODg5ZGRiNTkyODM2NjY0MmJlJyxcbiAgICAgICAgICAgICAgICAnYjMxOGUwZWMzMzU0MDI4YWRkNjY5ODI3ZjlkNGIyODcwYWFhOTcxZDJmN2U1ZWQxZDBiMjk3NDgzZDgzZWZkMCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdmYTUwYzBmNjFkMjJlNWYwN2UzYWNlYmIxYWEwN2IxMjhkMDAxMjIwOWEyOGI5Nzc2ZDc2YTg3OTMxODBlZWY5JyxcbiAgICAgICAgICAgICAgICAnNmI4NGM2OTIyMzk3ZWJhOWI3MmNkMjg3MjI4MWE2OGE1ZTY4MzI5M2E1N2EyMTNiMzhjZDhkN2QzZjRmMjgxMScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdkYTFkNjFkMGNhNzIxYTExYjFhNWJmNmI3ZDg4ZTg0MjFhMjg4YWI1ZDViYmE1MjIwZTUzZDMyYjVmMDY3ZWMyJyxcbiAgICAgICAgICAgICAgICAnODE1N2Y1NWE3Yzk5MzA2Yzc5YzA3NjYxNjFjOTFlMjk2NmE3Mzg5OWQyNzliNDhhNjU1ZmJhMGYxYWQ4MzZmMScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdhOGUyODJmZjBjOTcwNjkwNzIxNWZmOThlOGZkNDE2NjE1MzExZGUwNDQ2ZjFlMDYyYTczYjA2MTBkMDY0ZTEzJyxcbiAgICAgICAgICAgICAgICAnN2Y5NzM1NWI4ZGI4MWMwOWFiZmI3ZjNjNWIyNTE1ODg4YjY3OWEzZTUwZGQ2YmQ2Y2VmN2M3MzExMWY0Y2MwYycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcxNzRhNTNiOWM5YTI4NTg3MmQzOWU1NmU2OTEzY2FiMTVkNTliMWZhNTEyNTA4YzAyMmYzODJkZTgzMTk0OTdjJyxcbiAgICAgICAgICAgICAgICAnY2NjOWRjMzdhYmZjOWMxNjU3YjQxNTVmMmM0N2Y5ZTY2NDZiM2ExZDhjYjk4NTQzODNkYTEzYWMwNzlhZmE3MycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc5NTkzOTY5ODE5NDM3ODVjM2QzZTU3ZWRmNTAxOGNkYmUwMzllNzMwZTQ5MThiM2Q4ODRmZGZmMDk0NzViN2JhJyxcbiAgICAgICAgICAgICAgICAnMmU3ZTU1Mjg4OGMzMzFkZDhiYTAzODZhNGI5Y2Q2ODQ5YzY1M2Y2NGM4NzA5Mzg1ZTliOGFiZjg3NTI0ZjJmZCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdkMmE2M2E1MGFlNDAxZTU2ZDY0NWExMTUzYjEwOWE4ZmNjYTBhNDNkNTYxZmJhMmRiYjUxMzQwYzlkODJiMTUxJyxcbiAgICAgICAgICAgICAgICAnZTgyZDg2ZmI2NDQzZmNiNzU2NWFlZTU4YjI5NDgyMjBhNzBmNzUwYWY0ODRjYTUyZDQxNDIxNzRkY2Y4OTQwNScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc2NDU4N2UyMzM1NDcxZWI4OTBlZTc4OTZkN2NmZGM4NjZiYWNiZGJkMzgzOTMxN2IzNDM2ZjliNDU2MTdlMDczJyxcbiAgICAgICAgICAgICAgICAnZDk5ZmNkZDViZjY5MDJlMmFlOTZkZDY0NDdjMjk5YTE4NWI5MGEzOTEzM2FlYWIzNTgyOTllNWU5ZmFmNjU4OScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc4NDgxYmRlMGU0ZTRkODg1YjNhNTQ2ZDNlNTQ5ZGUwNDJmMGFhNmNlYTI1MGU3ZmQzNThkNmM4NmRkNDVlNDU4JyxcbiAgICAgICAgICAgICAgICAnMzhlZTdiOGNiYTU0MDRkZDg0YTI1YmYzOWNlY2IyY2E5MDBhNzljNDJiMjYyZTU1NmQ2NGIxYjU5Nzc5MDU3ZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcxMzQ2NGE1N2E3ODEwMmFhNjJiNjk3OWFlODE3ZjQ2MzdmZmNmZWQzYzRiMWNlMzBiY2Q2MzAzZjZjYWY2NjZiJyxcbiAgICAgICAgICAgICAgICAnNjliZTE1OTAwNDYxNDU4MGVmN2U0MzM0NTNjY2IwY2E0OGYzMDBhODFkMDk0MmUxM2Y0OTVhOTA3ZjZlY2MyNycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdiYzRhOWRmNWI3MTNmZTJlOWFlZjQzMGJjYzFkYzk3YTBjZDljY2VkZTJmMjg1ODhjYWRhM2EwZDJkODNmMzY2JyxcbiAgICAgICAgICAgICAgICAnZDNhODFjYTZlNzg1YzA2MzgzOTM3YWRmNGI3OThjYWE2ZThhOWZiZmE1NDdiMTZkNzU4ZDY2NjU4MWYzM2MxJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzhjMjhhOTdiZjgyOThiYzBkMjNkOGM3NDk0NTJhMzJlNjk0YjY1ZTMwYTk0NzJhMzk1NGFiMzBmZTUzMjRjYWEnLFxuICAgICAgICAgICAgICAgICc0MGEzMDQ2M2EzMzA1MTkzMzc4ZmVkZjMxZjdjYzBlYjdhZTc4NGYwNDUxY2I5NDU5ZTcxZGM3M2NiZWY5NDgyJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzhlYTk2NjYxMzk1MjdhOGMxZGQ5NGNlNGYwNzFmZDIzYzhiMzUwYzVhNGJiMzM3NDhjNGJhMTExZmFjY2FlMCcsXG4gICAgICAgICAgICAgICAgJzYyMGVmYWJiYzhlZTI3ODJlMjRlN2MwY2ZiOTVjNWQ3MzViNzgzYmU5Y2YwZjhlOTU1YWYzNGEzMGU2MmI5NDUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZGQzNjI1ZmFlZjViYTA2MDc0NjY5NzE2YmJkMzc4OGQ4OWJkZGU4MTU5NTk5NjgwOTJmNzZjYzRlYjlhOTc4NycsXG4gICAgICAgICAgICAgICAgJzdhMTg4ZmEzNTIwZTMwZDQ2MWRhMjUwMTA0NTczMWNhOTQxNDYxOTgyODgzMzk1OTM3ZjY4ZDAwYzY0NGE1NzMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZjcxMGQ3OWQ5ZWI5NjIyOTdlNGY2MjMyYjQwZThmN2ZlYjJiYzYzODE0NjE0ZDY5MmMxMmRlNzUyNDA4MjIxZScsXG4gICAgICAgICAgICAgICAgJ2VhOThlNjcyMzJkM2IzMjk1ZDNiNTM1NTMyMTE1Y2NhYzg2MTJjNzIxODUxNjE3NTI2YWU0N2E5Yzc3YmZjODInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIG5hZjoge1xuICAgICAgICB3bmQ6IDcsXG4gICAgICAgIHBvaW50czogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdmOTMwOGEwMTkyNThjMzEwNDkzNDRmODVmODlkNTIyOWI1MzFjODQ1ODM2Zjk5YjA4NjAxZjExM2JjZTAzNmY5JyxcbiAgICAgICAgICAgICAgICAnMzg4ZjdiMGY2MzJkZTgxNDBmZTMzN2U2MmEzN2YzNTY2NTAwYTk5OTM0YzIyMzFiNmNiOWZkNzU4NGI4ZTY3MicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcyZjhiZGU0ZDFhMDcyMDkzNTViNGE3MjUwYTVjNTEyOGU4OGI4NGJkZGM2MTlhYjdjYmE4ZDU2OWIyNDBlZmU0JyxcbiAgICAgICAgICAgICAgICAnZDhhYzIyMjYzNmU1ZTNkNmQ0ZGJhOWRkYTZjOWM0MjZmNzg4MjcxYmFiMGQ2ODQwZGNhODdkM2FhNmFjNjJkNicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc1Y2JkZjA2NDZlNWRiNGVhYTM5OGYzNjVmMmVhN2EwZTNkNDE5YjdlMDMzMGUzOWNlOTJiZGRlZGNhYzRmOWJjJyxcbiAgICAgICAgICAgICAgICAnNmFlYmNhNDBiYTI1NTk2MGEzMTc4ZDZkODYxYTU0ZGJhODEzZDBiODEzZmRlN2I1YTUwODI2MjgwODcyNjRkYScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdhY2Q0ODRlMmYwYzdmNjUzMDlhZDE3OGE5ZjU1OWFiZGUwOTc5Njk3NGM1N2U3MTRjMzVmMTEwZGZjMjdjY2JlJyxcbiAgICAgICAgICAgICAgICAnY2MzMzg5MjFiMGE3ZDlmZDY0MzgwOTcxNzYzYjYxZTlhZGQ4ODhhNDM3NWY4ZTBmMDVjYzI2MmFjNjRmOWMzNycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc3NzRhZTdmODU4YTk0MTFlNWVmNDI0NmI3MGM2NWFhYzU2NDk5ODBiZTVjMTc4OTFiYmVjMTc4OTVkYTAwOGNiJyxcbiAgICAgICAgICAgICAgICAnZDk4NGEwMzJlYjZiNWUxOTAyNDNkZDU2ZDdiN2IzNjUzNzJkYjFlMmRmZjlkNmE4MzAxZDc0YzljOTUzYzYxYicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdmMjg3NzNjMmQ5NzUyODhiYzdkMWQyMDVjMzc0ODY1MWIwNzVmYmM2NjEwZTU4Y2RkZWVkZGY4ZjE5NDA1YWE4JyxcbiAgICAgICAgICAgICAgICAnYWIwOTAyZThkODgwYTg5NzU4MjEyZWI2NWNkYWY0NzNhMWEwNmRhNTIxZmE5MWYyOWI1Y2I1MmRiMDNlZDgxJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2Q3OTI0ZDRmN2Q0M2VhOTY1YTQ2NWFlMzA5NWZmNDExMzFlNTk0NmYzYzg1Zjc5ZTQ0YWRiY2Y4ZTI3ZTA4MGUnLFxuICAgICAgICAgICAgICAgICc1ODFlMjg3MmE4NmM3MmE2ODM4NDJlYzIyOGNjNmRlZmVhNDBhZjJiZDg5NmQzYTVjNTA0ZGM5ZmY2YTI2YjU4JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2RlZmRlYTRjZGI2Nzc3NTBhNDIwZmVlODA3ZWFjZjIxZWI5ODk4YWU3OWI5NzY4NzY2ZTRmYWEwNGEyZDRhMzQnLFxuICAgICAgICAgICAgICAgICc0MjExYWIwNjk0NjM1MTY4ZTk5N2IwZWFkMmE5M2RhZWNlZDFmNGEwNGE5NWMwZjZjZmIxOTlmNjllNTZlYjc3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzJiNGVhMGE3OTdhNDQzZDI5M2VmNWNmZjQ0NGY0OTc5ZjA2YWNmZWJkN2U4NmQyNzc0NzU2NTYxMzgzODViNmMnLFxuICAgICAgICAgICAgICAgICc4NWU4OWJjMDM3OTQ1ZDkzYjM0MzA4M2I1YTFjODYxMzFhMDFmNjBjNTAyNjk3NjNiNTcwYzg1NGU1YzA5YjdhJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzM1MmJiZjRhNGNkZDEyNTY0ZjkzZmEzMzJjZTMzMzMwMWQ5YWQ0MDI3MWY4MTA3MTgxMzQwYWVmMjViZTU5ZDUnLFxuICAgICAgICAgICAgICAgICczMjFlYjQwNzUzNDhmNTM0ZDU5YzE4MjU5ZGRhM2UxZjRhMWIzYjJlNzFiMTAzOWM2N2JkM2Q4YmNmODE5OThjJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzJmYTIxMDRkNmIzOGQxMWIwMjMwMDEwNTU5ODc5MTI0ZTQyYWI4ZGZlZmY1ZmYyOWRjOWNkYWRkNGVjYWNjM2YnLFxuICAgICAgICAgICAgICAgICcyZGUxMDY4Mjk1ZGQ4NjViNjQ1NjkzMzViZDVkZDgwMTgxZDcwZWNmYzg4MjY0ODQyM2JhNzZiNTMyYjdkNjcnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOTI0ODI3OWIwOWI0ZDY4ZGFiMjFhOWIwNjZlZGRhODMyNjNjM2Q4NGUwOTU3MmUyNjljYTBjZDdmNTQ1MzcxNCcsXG4gICAgICAgICAgICAgICAgJzczMDE2ZjdiZjIzNGFhZGU1ZDFhYTcxYmRlYTJiMWZmM2ZjMGRlMmE4ODc5MTJmZmU1NGEzMmNlOTdjYjM0MDInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZGFlZDRmMmJlM2E4YmYyNzhlNzAxMzJmYjBiZWI3NTIyZjU3MGUxNDRiZjYxNWMwN2U5OTZkNDQzZGVlODcyOScsXG4gICAgICAgICAgICAgICAgJ2E2OWRjZTRhN2Q2Yzk4ZThkNGExYWNhODdlZjhkNzAwM2Y4M2MyMzBmM2FmYTcyNmFiNDBlNTIyOTBiZTFjNTUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnYzQ0ZDEyYzcwNjVkODEyZThhY2YyOGQ3Y2JiMTlmOTAxMWVjZDllOWZkZjI4MWIwZTZhM2I1ZTg3ZDIyZTdkYicsXG4gICAgICAgICAgICAgICAgJzIxMTlhNDYwY2UzMjZjZGM3NmM0NTkyNmM5ODJmZGFjMGUxMDZlODYxZWRmNjFjNWEwMzkwNjNmMGUwZTY0ODInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNmEyNDViZjZkYzY5ODUwNGM4OWEyMGNmZGVkNjA4NTMxNTJiNjk1MzM2YzI4MDYzYjYxYzY1Y2JkMjY5ZTZiNCcsXG4gICAgICAgICAgICAgICAgJ2UwMjJjZjQyYzJiZDRhNzA4YjNmNTEyNmYxNmEyNGFkOGIzM2JhNDhkMDQyM2I2ZWZkNWU2MzQ4MTAwZDhhODInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMTY5N2ZmYTZmZDlkZTYyN2MwNzdlM2QyZmU1NDEwODRjZTEzMzAwYjBiZWMxMTQ2Zjk1YWU1N2YwZDBiZDZhNScsXG4gICAgICAgICAgICAgICAgJ2I5YzM5OGYxODY4MDZmNWQyNzU2MTUwNmU0NTU3NDMzYTJjZjE1MDA5ZTQ5OGFlN2FkZWU5ZDYzZDAxYjIzOTYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNjA1YmRiMDE5OTgxNzE4Yjk4NmQwZjA3ZTgzNGNiMGQ5ZGViODM2MGZmYjdmNjFkZjk4MjM0NWVmMjdhNzQ3OScsXG4gICAgICAgICAgICAgICAgJzI5NzJkMmRlNGY4ZDIwNjgxYTc4ZDkzZWM5NmZlMjNjMjZiZmFlODRmYjE0ZGI0M2IwMWUxZTkwNTZiOGM0OScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc2MmQxNGRhYjQxNTBiZjQ5NzQwMmZkYzQ1YTIxNWUxMGRjYjAxYzM1NDk1OWIxMGNmZTMxYzdlOWQ4N2ZmMzNkJyxcbiAgICAgICAgICAgICAgICAnODBmYzA2YmQ4Y2M1YjAxMDk4MDg4YTE5NTBlZWQwZGIwMWFhMTMyOTY3YWI0NzIyMzVmNTY0MjQ4M2IyNWVhZicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc4MGM2MGFkMDA0MGYyN2RhZGU1YjRiMDZjNDA4ZTU2YjJjNTBlOWY1NmI5YjhiNDI1ZTU1NWMyZjg2MzA4YjZmJyxcbiAgICAgICAgICAgICAgICAnMWMzODMwM2YxY2M1YzMwZjI2ZTY2YmFkN2ZlNzJmNzBhNjVlZWQ0Y2JlNzAyNGViMWFhMDFmNTY0MzBiZDU3YScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc3YTkzNzVhZDYxNjdhZDU0YWE3NGM2MzQ4Y2M1NGQzNDRjYzVkYzk0ODdkODQ3MDQ5ZDVlYWJiMGZhMDNjOGZiJyxcbiAgICAgICAgICAgICAgICAnZDBlM2ZhOWVjYTg3MjY5MDk1NTllMGQ3OTI2OTA0NmJkYzU5ZWExMGM3MGNlMmIwMmQ0OTllYzIyNGRjN2Y3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2Q1MjhlY2Q5YjY5NmI1NGM5MDdhOWVkMDQ1NDQ3YTc5YmI0MDhlYzM5YjY4ZGY1MDRiYjUxZjQ1OWJjM2ZmYzknLFxuICAgICAgICAgICAgICAgICdlZWNmNDEyNTMxMzZlNWY5OTk2NmYyMTg4MWZkNjU2ZWJjNDM0NTQwNWM1MjBkYmMwNjM0NjViNTIxNDA5OTMzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzQ5MzcwYTRiNWY0MzQxMmVhMjVmNTE0ZThlY2RhZDA1MjY2MTE1ZTRhN2VjYjEzODcyMzE4MDhmOGI0NTk2MycsXG4gICAgICAgICAgICAgICAgJzc1OGYzZjQxYWZkNmVkNDI4YjMwODFiMDUxMmZkNjJhNTRjM2YzYWZiYjViNjc2NGI2NTMwNTJhMTI5NDljOWEnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNzdmMjMwOTM2ZWU4OGNiYmQ3M2RmOTMwZDY0NzAyZWY4ODFkODExZTBlMTQ5OGUyZjFjMTNlYjFmYzM0NWQ3NCcsXG4gICAgICAgICAgICAgICAgJzk1OGVmNDJhNzg4NmI2NDAwYTA4MjY2ZTliYTFiMzc4OTZjOTUzMzBkOTcwNzdjYmJlOGViM2M3NjcxYzYwZDYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZjJkYWM5OTFjYzRjZTRiOWVhNDQ4ODdlNWM3YzBiY2U1OGM4MDA3NGFiOWQ0ZGJhZWIyODUzMWI3NzM5ZjUzMCcsXG4gICAgICAgICAgICAgICAgJ2UwZGVkYzliM2IyZjhkYWQ0ZGExZjMyZGVjMjUzMWRmOWViNWZiZWIwNTk4ZTRmZDFhMTE3ZGJhNzAzYTNjMzcnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNDYzYjNkOWY2NjI2MjFmYjFiNGJlOGZiYmUyNTIwMTI1YTIxNmNkZmM5ZGFlM2RlYmNiYTQ4NTBjNjkwZDQ1YicsXG4gICAgICAgICAgICAgICAgJzVlZDQzMGQ3OGMyOTZjMzU0MzExNDMwNmRkODYyMmQ3YzYyMmUyN2M5NzBhMWRlMzFjYjM3N2IwMWFmNzMwN2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZjE2ZjgwNDI0NGU0NmUyYTA5MjMyZDRhZmYzYjU5OTc2Yjk4ZmFjMTQzMjhhMmQxYTMyNDk2YjQ5OTk4ZjI0NycsXG4gICAgICAgICAgICAgICAgJ2NlZGFiZDliODIyMDNmN2UxM2QyMDZmY2RmNGUzM2Q5MmE2YzUzYzI2ZTVjY2UyNmQ2NTc5OTYyYzRlMzFkZjYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnY2FmNzU0MjcyZGM4NDU2M2IwMzUyYjdhMTQzMTFhZjU1ZDI0NTMxNWFjZTI3YzY1MzY5ZTE1ZjcxNTFkNDFkMScsXG4gICAgICAgICAgICAgICAgJ2NiNDc0NjYwZWYzNWY1ZjJhNDFiNjQzZmE1ZTQ2MDU3NWY0ZmE5Yjc5NjIyMzJhNWMzMmY5MDgzMThhMDQ0NzYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMjYwMGNhNGIyODJjYjk4NmY4NWQwZjE3MDk5NzlkOGI0NGEwOWMwN2NiODZkN2MxMjQ0OTdiYzg2ZjA4MjEyMCcsXG4gICAgICAgICAgICAgICAgJzQxMTliODg3NTNjMTViZDZhNjkzYjAzZmNkZGJiNDVkNWFjNmJlNzRhYjVmMGVmNDRiMGJlOTQ3NWE3ZTRiNDAnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNzYzNWNhNzJkN2U4NDMyYzMzOGVjNTNjZDEyMjIwYmMwMWM0ODY4NWUyNGY3ZGM4YzYwMmE3NzQ2OTk4ZTQzNScsXG4gICAgICAgICAgICAgICAgJzkxYjY0OTYwOTQ4OWQ2MTNkMWQ1ZTU5MGY3OGU2ZDc0ZWNmYzA2MWQ1NzA0OGJhZDllNzZmMzAyYzViOWM2MScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc3NTRlMzIzOWYzMjU1NzBjZGJiZjRhODdkZWVlOGE2NmI3ZjJiMzM0NzlkNDY4ZmJjMWE1MDc0M2JmNTZjYzE4JyxcbiAgICAgICAgICAgICAgICAnNjczZmI4NmU1YmRhMzBmYjNjZDBlZDMwNGVhNDlhMDIzZWUzM2QwMTk3YTY5NWQwYzVkOTgwOTNjNTM2NjgzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2UzZTZiZDEwNzFhMWU5NmFmZjU3ODU5YzgyZDU3MGYwMzMwODAwNjYxZDFjOTUyZjlmZTI2OTQ2OTFkOWI5ZTgnLFxuICAgICAgICAgICAgICAgICc1OWM5ZTBiYmEzOTRlNzZmNDBjMGFhNTgzNzlhM2NiNmE1YTIyODM5OTNlOTBjNDE2NzAwMmFmNDkyMGUzN2Y1JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzE4NmI0ODNkMDU2YTAzMzgyNmFlNzNkODhmNzMyOTg1YzRjY2IxZjMyYmEzNWY0YjRjYzQ3ZmRjZjA0YWE2ZWInLFxuICAgICAgICAgICAgICAgICczYjk1MmQzMmM2N2NmNzdlMmUxNzQ0NmUyMDQxODBhYjIxZmI4MDkwODk1MTM4YjRhNGE3OTdmODZlODA4ODhiJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2RmOWQ3MGE2Yjk4NzZjZTU0NGM5ODU2MWY0YmU0ZjcyNTQ0MmU2ZDJiNzM3ZDljOTFhODMyMTcyNGNlMDk2M2YnLFxuICAgICAgICAgICAgICAgICc1NWViMmRhZmQ4NGQ2Y2NkNWY4NjJiNzg1ZGMzOWQ0YWIxNTcyMjI3MjBlZjlkYTIxN2I4YzQ1Y2YyYmEyNDE3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzVlZGQ1Y2MyM2M1MWU4N2E0OTdjYTgxNWQ1ZGNlMGY4YWI1MjU1NGY4NDllZDg5OTVkZTY0YzVmMzRjZTcxNDMnLFxuICAgICAgICAgICAgICAgICdlZmFlOWM4ZGJjMTQxMzA2NjFlOGNlYzAzMGM4OWFkMGMxM2M2NmMwZDE3YTI5MDVjZGM3MDZhYjczOTlhODY4JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzI5MDc5OGMyYjY0NzY4MzBkYTEyZmUwMjI4N2U5ZTc3N2FhM2ZiYTFjMzU1YjE3YTcyMmQzNjJmODQ2MTRmYmEnLFxuICAgICAgICAgICAgICAgICdlMzhkYTc2ZGNkNDQwNjIxOTg4ZDAwYmNmNzlhZjI1ZDViMjljMDk0ZGIyYTIzMTQ2ZDAwM2FmZDQxOTQzZTdhJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2FmM2M0MjNhOTVkOWY1YjMwNTQ3NTRlZmExNTBhYzM5Y2QyOTU1MmZlMzYwMjU3MzYyZGZkZWNlZjQwNTNiNDUnLFxuICAgICAgICAgICAgICAgICdmOThhM2ZkODMxZWIyYjc0OWE5M2IwZTZmMzVjZmI0MGM4Y2Q1YWE2NjdhMTU1ODFiYzJmZWRlZDQ5OGZkOWM2JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzc2NmRiYjI0ZDEzNGU3NDVjY2NhYTI4Yzk5YmYyNzQ5MDZiYjY2YjI2ZGNmOThkZjhkMmZlZDUwZDg4NDI0OWEnLFxuICAgICAgICAgICAgICAgICc3NDRiMTE1MmVhY2JlNWUzOGRjYzg4Nzk4MGRhMzhiODk3NTg0YTY1ZmEwNmNlZGQyYzkyNGY5N2NiYWM1OTk2JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzU5ZGJmNDZmOGM5NDc1OWJhMjEyNzdjMzM3ODRmNDE2NDVmN2I0NGY2YzU5NmE1OGNlOTJlNjY2MTkxYWJlM2UnLFxuICAgICAgICAgICAgICAgICdjNTM0YWQ0NDE3NWZiYzMwMGY0ZWE2Y2U2NDgzMDlhMDQyY2U3MzlhNzkxOTc5OGNkODVlMjE2YzRhMzA3ZjZlJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2YxM2FkYTk1MTAzYzQ1MzczMDVlNjkxZTc0ZTlhNGE4ZGQ2NDdlNzExYTk1ZTczY2I2MmRjNjAxOGNmZDg3YjgnLFxuICAgICAgICAgICAgICAgICdlMTM4MTdiNDRlZTE0ZGU2NjNiZjRiYzgwODM0MWYzMjY5NDllMjFhNmE3NWMyNTcwNzc4NDE5YmRhZjU3MzNkJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzc3NTRiNGZhMGU4YWNlZDA2ZDQxNjdhMmM1OWNjYTRjZGExODY5YzA2ZWJhZGZiNjQ4ODU1MDAxNWE4ODUyMmMnLFxuICAgICAgICAgICAgICAgICczMGU5M2U4NjRlNjY5ZDgyMjI0Yjk2N2MzMDIwYjhmYThkMWU0ZTM1MGI2Y2JjYzUzN2E0OGI1Nzg0MTE2M2EyJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzk0OGRjYWRmNTk5MGUwNDhhYTM4NzRkNDZhYmVmOWQ3MDE4NThmOTVkZTgwNDFkMmE2ODI4Yzk5ZTIyNjI1MTknLFxuICAgICAgICAgICAgICAgICdlNDkxYTQyNTM3ZjZlNTk3ZDVkMjhhMzIyNGIxYmMyNWRmOTE1NGVmYmQyZWYxZDJjYmJhMmNhZTUzNDdkNTdlJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzc5NjI0MTQ0NTBjNzZjMTY4OWM3YjQ4ZjgyMDJlYzM3ZmIyMjRjZjVhYzBiZmExNTcwMzI4YThhM2Q3Yzc3YWInLFxuICAgICAgICAgICAgICAgICcxMDBiNjEwZWM0ZmZiNDc2MGQ1YzFmYzEzM2VmNmY2YjEyNTA3YTA1MWYwNGFjNTc2MGFmYTViMjlkYjgzNDM3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzM1MTQwODc4MzQ5NjRiNTRiMTViMTYwNjQ0ZDkxNTQ4NWExNjk3NzIyNWI4ODQ3YmIwZGQwODUxMzdlYzQ3Y2EnLFxuICAgICAgICAgICAgICAgICdlZjBhZmJiMjA1NjIwNTQ0OGUxNjUyYzQ4ZTgxMjdmYzYwMzllNzdjMTVjMjM3OGI3ZTdkMTVhMGRlMjkzMzExJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2QzY2MzMGFkNmI0ODNlNGJjNzljZTJjOWRkOGJjNTQ5OTNlOTQ3ZWI4ZGY3ODdiNDQyOTQzZDNmN2I1MjdlYWYnLFxuICAgICAgICAgICAgICAgICc4YjM3OGEyMmQ4MjcyNzhkODljNWU5YmU4Zjk1MDhhZTNjMmFkNDYyOTAzNTg2MzBhZmIzNGRiMDRlZWRlMGE0JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzE2MjRkODQ3ODA3MzI4NjBjZTFjNzhmY2JmZWZlMDhiMmIyOTgyM2RiOTEzZjY0OTM5NzViYTBmZjQ4NDc2MTAnLFxuICAgICAgICAgICAgICAgICc2ODY1MWNmOWI2ZGE5MDNlMDkxNDQ0OGM2Y2Q5ZDRjYTg5Njg3OGY1MjgyYmU0YzhjYzA2ZTJhNDA0MDc4NTc1JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzczM2NlODBkYTk1NWE4YTI2OTAyYzk1NjMzZTYyYTk4NTE5MjQ3NGI1YWYyMDdkYTZkZjdiNGZkNWZjNjFjZDQnLFxuICAgICAgICAgICAgICAgICdmNTQzNWEyYmQyYmFkZjdkNDg1YTRkOGI4ZGI5ZmNjZTNlMWVmOGUwMjAxZTQ1NzhjNTQ2NzNiYzFkYzVlYTFkJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzE1ZDk0NDEyNTQ5NDUwNjRjZjFhMWMzM2JiZDNiNDlmODk2NmM1MDkyMTcxZTY5OWVmMjU4ZGZhYjgxYzA0NWMnLFxuICAgICAgICAgICAgICAgICdkNTZlYjMwYjY5NDYzZTcyMzRmNTEzN2I3M2I4NDE3NzQzNDgwMGJhY2ViZmM2ODVmYzM3YmJlOWVmZTQwNzBkJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2ExZDBmY2YyZWM5ZGU2NzViNjEyMTM2ZTVjZTcwZDI3MWMyMTQxN2M5ZDJiOGFhYWFjMTM4NTk5ZDA3MTc5NDAnLFxuICAgICAgICAgICAgICAgICdlZGQ3N2Y1MGJjYjVhM2NhYjJlOTA3MzczMDk2NjdmMjY0MTQ2MmE1NDA3MGYzZDUxOTIxMmQzOWMxOTdhNjI5JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2UyMmZiZTE1YzBhZjhjY2M1NzgwYzA3MzVmODRkYmU5YTc5MGJhZGVlODI0NWMwNmM3Y2EzNzMzMWNiMzY5ODAnLFxuICAgICAgICAgICAgICAgICdhODU1YmFiYWQ1Y2Q2MGM4OGI0MzBhNjlmNTNhMWE3YTM4Mjg5MTU0OTY0Nzk5YmU0M2QwNmQ3N2QzMWRhMDYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMzExMDkxZGQ5ODYwZThlMjBlZTEzNDczYzExNTVmNWY2OTYzNWUzOTQ3MDRlYWE3NDAwOTQ1MjI0NmNmYTliMycsXG4gICAgICAgICAgICAgICAgJzY2ZGI2NTZmODdkMWYwNGZmZmQxZjA0Nzg4YzA2ODMwODcxZWM1YTY0ZmVlZTY4NWJkODBmMGIxMjg2ZDgzNzQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMzRjMWZkMDRkMzAxYmU4OWIzMWMwNDQyZDNlNmFjMjQ4ODM5MjhiNDVhOTM0MDc4MTg2N2Q0MjMyZWMyZGJkZicsXG4gICAgICAgICAgICAgICAgJzk0MTQ2ODVlOTdiMWI1OTU0YmQ0NmY3MzAxNzQxMzZkNTdmMWNlZWI0ODc0NDNkYzUzMjE4NTdiYTczYWJlZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdmMjE5ZWE1ZDZiNTQ3MDFjMWMxNGRlNWI1NTdlYjQyYThkMTNmM2FiYmNkMDhhZmZjYzJhNWU2YjA0OWI4ZDYzJyxcbiAgICAgICAgICAgICAgICAnNGNiOTU5NTdlODNkNDBiMGY3M2FmNDU0NGNjY2Y2YjFmNGIwOGQzYzA3YjI3ZmI4ZDhjMjk2MmE0MDA3NjZkMScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdkN2I4NzQwZjc0YThmYmFhYjFmNjgzZGI4ZjQ1ZGUyNjU0M2E1NDkwYmNhNjI3MDg3MjM2OTEyNDY5YTBiNDQ4JyxcbiAgICAgICAgICAgICAgICAnZmE3Nzk2ODEyOGQ5YzkyZWUxMDEwZjMzN2FkNDcxN2VmZjE1ZGI1ZWQzYzA0OWIzNDExZTAzMTVlYWE0NTkzYicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICczMmQzMWMyMjJmOGY2ZjBlZjg2ZjdjOThkM2EzMzM1ZWFkNWJjZDMyYWJkZDk0Mjg5ZmU0ZDMwOTFhYTgyNGJmJyxcbiAgICAgICAgICAgICAgICAnNWYzMDMyZjU4OTIxNTZlMzljY2QzZDc5MTViOWUxZGEyZTZkYWM5ZTZmMjZlOTYxMTE4ZDE0Yjg0NjJlMTY2MScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc3NDYxZjM3MTkxNGFiMzI2NzEwNDVhMTU1ZDk4MzFlYTg3OTNkNzdjZDU5NTkyYzQzNDBmODZjYmMxODM0N2I1JyxcbiAgICAgICAgICAgICAgICAnOGVjMGJhMjM4Yjk2YmVjMGNiZGRkY2FlMGFhNDQyNTQyZWVlMWZmNTBjOTg2ZWE2YjM5ODQ3YjNjYzA5MmZmNicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdlZTA3OWFkYjFkZjE4NjAwNzQzNTZhMjVhYTM4MjA2YTZkNzE2YjJjM2U2NzQ1M2QyODc2OThiYWQ3YjJiMmQ2JyxcbiAgICAgICAgICAgICAgICAnOGRjMjQxMmFhZmUzYmU1YzRjNWYzN2UwZWNjNWY5ZjZhNDQ2OTg5YWYwNGM0ZTI1ZWJhYWM0NzllYzFjOGMxZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcxNmVjOTNlNDQ3ZWM4M2YwNDY3YjE4MzAyZWU2MjBmN2U2NWRlMzMxODc0YzlkYzcyYmZkODYxNmJhOWRhNmI1JyxcbiAgICAgICAgICAgICAgICAnNWU0NjMxMTUwZTYyZmI0MGQwZThjMmE3Y2E1ODA0YTM5ZDU4MTg2YTUwZTQ5NzEzOTYyNjc3OGUyNWIwNjc0ZCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdlYWE1Zjk4MGMyNDVmNmYwMzg5NzgyOTBhZmE3MGI2YmQ4ODU1ODk3Zjk4YjZhYTQ4NWI5NjA2NWQ1MzdiZDk5JyxcbiAgICAgICAgICAgICAgICAnZjY1ZjVkM2UyOTJjMmUwODE5YTUyODM5MWM5OTQ2MjRkNzg0ODY5ZDdlNmVhNjdmYjE4MDQxMDI0ZWRjMDdkYycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc3OGM5NDA3NTQ0YWMxMzI2OTJlZTE5MTBhMDI0Mzk5NThhZTA0ODc3MTUxMzQyZWE5NmM0YjZiMzVhNDlmNTEnLFxuICAgICAgICAgICAgICAgICdmM2UwMzE5MTY5ZWI5Yjg1ZDU0MDQ3OTU1MzlhNWU2OGZhMWZiZDU4M2MwNjRkMjQ2MmI2NzVmMTk0YTNkZGI0JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzQ5NGY0YmUyMTlhMWE3NzAxNmRjZDgzODQzMWFlYTAwMDFjZGM4YWU3YTZmYzY4ODcyNjU3OGQ5NzAyODU3YTUnLFxuICAgICAgICAgICAgICAgICc0MjI0MmE5NjkyODNhNWYzMzliYTdmMDc1ZTM2YmEyYWY5MjVjZTMwZDc2N2VkNmU1NWY0YjAzMTg4MGQ1NjJjJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2E1OThhODAzMGRhNmQ4NmM2YmM3ZjJmNTE0NGVhNTQ5ZDI4MjExZWE1OGZhYTcwZWJmNGMxZTY2NWMxZmU5YjUnLFxuICAgICAgICAgICAgICAgICcyMDRiNWQ2Zjg0ODIyYzMwN2U0YjRhNzE0MDczN2FlYzIzZmM2M2I2NWIzNWY4NmExMDAyNmRiZDJkODY0ZTZiJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2M0MTkxNjM2NWFiYjJiNWQwOTE5MmY1ZjJkYmVhZmVjMjA4ZjAyMGYxMjU3MGExODRkYmFkYzNlNTg1OTU5OTcnLFxuICAgICAgICAgICAgICAgICc0ZjE0MzUxZDAwODdlZmE0OWQyNDViMzI4OTg0OTg5ZDVjYWY5NDUwZjM0YmZjMGVkMTZlOTZiNThmYTk5MTMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnODQxZDYwNjNhNTg2ZmE0NzVhNzI0NjA0ZGEwM2JjNWI5MmEyZTBkMmUwYTM2YWNmZTRjNzNhNTUxNDc0Mjg4MScsXG4gICAgICAgICAgICAgICAgJzczODY3ZjU5YzA2NTllODE5MDRmOWExYzc1NDM2OThlNjI1NjJkNjc0NGMxNjljZTdhMzZkZTAxYThkNjE1NCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc1ZTk1YmIzOTlhNjk3MWQzNzYwMjY5NDdmODliZGUyZjI4MmIzMzgxMDkyOGJlNGRlZDExMmFjNGQ3MGUyMGQ1JyxcbiAgICAgICAgICAgICAgICAnMzlmMjNmMzY2ODA5MDg1YmVlYmZjNzExODEzMTM3NzVhOTljOWFlZDdkOGJhMzhiMTYxMzg0Yzc0NjAxMjg2NScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICczNmU0NjQxYTUzOTQ4ZmQ0NzZjMzlmOGE5OWZkOTc0ZTVlYzA3NTY0YjUzMTVkOGJmOTk0NzFiY2EwZWYyZjY2JyxcbiAgICAgICAgICAgICAgICAnZDI0MjRiMWIxYWJlNGViODE2NDIyN2IwODVjOWFhOTQ1NmVhMTM0OTNmZDU2M2UwNmZkNTFjZjU2OTRjNzhmYycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICczMzY1ODFlYTdiZmJiYjI5MGMxOTFhMmY1MDdhNDFjZjU2NDM4NDIxNzBlOTE0ZmFlYWIyN2MyYzU3OWY3MjYnLFxuICAgICAgICAgICAgICAgICdlYWQxMjE2ODU5NWZlMWJlOTkyNTIxMjliNmU1NmIzMzkxZjdhYjE0MTBjZDFlMGVmM2RjZGNhYmQyZmRhMjI0JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzhhYjg5ODE2ZGFkZmQ2YjZhMWYyNjM0ZmNmMDBlYzg0MDM3ODEwMjVlZDY4OTBjNDg0OTc0MjcwNmJkNDNlZGUnLFxuICAgICAgICAgICAgICAgICc2ZmRjZWYwOWYyZjZkMGEwNDRlNjU0YWVmNjI0MTM2ZjUwM2Q0NTljM2U4OTg0NTg1OGE0N2E5MTI5Y2RkMjRlJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzFlMzNmMWE3NDZjOWM1Nzc4MTMzMzQ0ZDkyOTlmY2FhMjBiMDkzOGU4YWNmZjI1NDRiYjQwMjg0YjhjNWZiOTQnLFxuICAgICAgICAgICAgICAgICc2MDY2MDI1N2RkMTFiM2FhOWM4ZWQ2MThkMjRlZGZmMjMwNmQzMjBmMWQwMzAxMGUzM2E3ZDIwNTdmM2IzYjYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnODViN2MxZGNiM2NlYzFiN2VlN2YzMGRlZDc5ZGQyMGEwZWQxZjRjYzE4Y2JjZmNmYTQxMDM2MWZkOGYwOGYzMScsXG4gICAgICAgICAgICAgICAgJzNkOThhOWNkZDAyNmRkNDNmMzkwNDhmMjVhODg0N2Y0ZmNhZmFkMTg5NWQ3YTYzM2M2ZmVkM2MzNWU5OTk1MTEnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMjlkZjlmYmQ4ZDllNDY1MDkyNzVmNGIxMjVkNmQ0NWQ3ZmJlOWEzYjg3OGE3YWY4NzJhMjgwMDY2MWFjNWY1MScsXG4gICAgICAgICAgICAgICAgJ2I0YzRmZTk5Yzc3NWE2MDZlMmQ4ODYyMTc5MTM5ZmZkYTYxZGM4NjFjMDE5ZTU1Y2QyODc2ZWIyYTI3ZDg0YicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdhMGIxY2FlMDZiMGE4NDdhM2ZlYTZlNjcxYWFmOGFkZmRmZTU4Y2EyZjc2ODEwNWM4MDgyYjJlNDQ5ZmNlMjUyJyxcbiAgICAgICAgICAgICAgICAnYWU0MzQxMDJlZGRlMDk1OGVjNGIxOWQ5MTdhNmEyOGU2YjcyZGExODM0YWZmMGU2NTBmMDQ5NTAzYTI5NmNmMicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc0ZThjZWFmYjliM2U5YTEzNmRjN2ZmNjdlODQwMjk1YjQ5OWRmYjNiMjEzM2U0YmExMTNmMmU0YzBlMTIxZTUnLFxuICAgICAgICAgICAgICAgICdjZjIxNzQxMThjOGI2ZDdhNGI0OGY2ZDUzNGNlNWM3OTQyMmMwODZhNjM0NjA1MDJiODI3Y2U2MmEzMjY2ODNjJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2QyNGE0NGUwNDdlMTliNmY1YWZiODFjN2NhMmY2OTA4MGE1MDc2Njg5YTAxMDkxOWY0MjcyNWMyYjc4OWEzM2InLFxuICAgICAgICAgICAgICAgICc2ZmI4ZDU1OTFiNDY2ZjhmYzYzZGI1MGYxYzBmMWM2OTAxM2Y5OTY4ODdiODI0NGQyY2RlYzQxN2FmZWE4ZmEzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2VhMDE2MDZhN2E2YzljZGQyNDlmZGZjZmFjYjk5NTg0MDAxZWRkMjhhYmJhYjc3YjUxMDRlOThlOGUzYjM1ZDQnLFxuICAgICAgICAgICAgICAgICczMjJhZjQ5MDhjNzMxMmIwY2ZiZmUzNjlmN2E3YjNjZGI3ZDQ0OTRiYzI4MjM3MDBjZmQ2NTIxODhhM2VhOThkJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2FmOGFkZGJmMmI2NjFjOGE2YzYzMjg2NTVlYjk2NjUxMjUyMDA3ZDhjNWVhMzFiZTRhZDE5NmRlOGNlMjEzMWYnLFxuICAgICAgICAgICAgICAgICc2NzQ5ZTY3YzAyOWI4NWY1MmEwMzRlYWZkMDk2ODM2YjI1MjA4MTg2ODBlMjZhYzhmM2RmYmNkYjcxNzQ5NzAwJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2UzYWUxOTc0NTY2Y2EwNmNjNTE2ZDQ3ZTBmYjE2NWE2NzRhM2RhYmNmY2ExNWU3MjJmMGUzNDUwZjQ1ODg5JyxcbiAgICAgICAgICAgICAgICAnMmFlYWJlN2U0NTMxNTEwMTE2MjE3ZjA3YmY0ZDA3MzAwZGU5N2U0ODc0ZjgxZjUzMzQyMGE3MmVlYjBiZDZhNCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc1OTFlZTM1NTMxM2Q5OTcyMWNmNjk5M2ZmZWQxZTNlMzAxOTkzZmYzZWQyNTg4MDIwNzVlYThjZWQzOTdlMjQ2JyxcbiAgICAgICAgICAgICAgICAnYjBlYTU1OGExMTNjMzBiZWE2MGZjNDc3NTQ2MGM3OTAxZmYwYjA1M2QyNWNhMmJkZWVlOThmMWE0YmU1ZDE5NicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcxMTM5NmQ1NWZkYTU0YzQ5ZjE5YWE5NzMxOGQ4ZGE2MWZhODU4NGU0N2IwODQ5NDUwNzdjZjAzMjU1YjUyOTg0JyxcbiAgICAgICAgICAgICAgICAnOTk4Yzc0YThjZDQ1YWMwMTI4OWQ1ODMzYTdiZWI0NzQ0ZmY1MzZiMDFiMjU3YmU0YzU3NjdiZWE5M2VhNTdhNCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICczYzVkMmExYmEzOWM1YTE3OTAwMDA3MzhjOWUwYzQwYjhkY2RmZDU0Njg3NTRiNjQwNTU0MDE1N2UwMTdhYTdhJyxcbiAgICAgICAgICAgICAgICAnYjIyODQyNzk5OTVhMzRlMmY5ZDRkZTczOTZmYzE4YjgwZjliOGI5ZmRkMjcwZjY2NjFmNzljYTRjODFiZDI1NycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdjYzg3MDRiOGE2MGEwZGVmYTNhOTlhNzI5OWYyZTljM2ZiYzM5NWFmYjA0YWMwNzg0MjVlZjhhMTc5M2NjMDMwJyxcbiAgICAgICAgICAgICAgICAnYmRkNDYwMzlmZWVkMTc4ODFkMWUwODYyZGIzNDdmOGNmMzk1Yjc0ZmM0YmNkYzRlOTQwYjc0ZTNhYzFmMWIxMycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdjNTMzZTRmN2VhODU1NWFhY2Q5Nzc3YWM1Y2FkMjliOTdkZDRkZWZjY2M1M2VlN2VhMjA0MTE5YjI4ODliMTk3JyxcbiAgICAgICAgICAgICAgICAnNmYwYTI1NmJjNWVmZGY0MjlhMmZiNjI0MmYxYTQzYTJkOWI5MjViYjRhNGIzYTI2YmI4ZTBmNDVlYjU5NjA5NicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdjMTRmOGYyY2NiMjdkNmYxMDlmNmQwOGQwM2NjOTZhNjliYThjMzRlZWMwN2JiY2Y1NjZkNDhlMzNkYTY1OTMnLFxuICAgICAgICAgICAgICAgICdjMzU5ZDY5MjNiYjM5OGY3ZmQ0NDczZTE2ZmUxYzI4NDc1Yjc0MGRkMDk4MDc1ZTZjMGU4NjQ5MTEzZGMzYTM4JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2E2Y2JjMzA0NmJjNmE0NTBiYWMyNDc4OWZhMTcxMTVhNGM5NzM5ZWQ3NWY4ZjIxY2U0NDFmNzJlMGI5MGU2ZWYnLFxuICAgICAgICAgICAgICAgICcyMWFlN2Y0NjgwZTg4OWJiMTMwNjE5ZTJjMGY5NWEzNjBjZWI1NzNjNzA2MDMxMzk4NjJhZmQ2MTdmYTliOWYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMzQ3ZDZkOWEwMmM0ODkyN2ViZmI4NmMxMzU5YjFjYWYxMzBhM2MwMjY3ZDExY2U2MzQ0YjM5Zjk5ZDQzY2MzOCcsXG4gICAgICAgICAgICAgICAgJzYwZWE3ZjYxYTM1MzUyNGQxYzk4N2Y2ZWNlYzkyZjA4NmQ1NjVhYjY4Nzg3MGNiMTI2ODlmZjFlMzFjNzQ0NDgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZGE2NTQ1ZDIxODFkYjhkOTgzZjdkY2IzNzVlZjU4NjZkNDdjNjdiMWJmMzFjOGNmODU1ZWY3NDM3YjcyNjU2YScsXG4gICAgICAgICAgICAgICAgJzQ5Yjk2NzE1YWI2ODc4YTc5ZTc4ZjA3Y2U1NjgwYzVkNjY3MzA1MWI0OTM1YmQ4OTdmZWE4MjRiNzdkYzIwOGEnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnYzQwNzQ3Y2M5ZDAxMmNiMWExM2I4MTQ4MzA5YzZkZTdlYzI1ZDY5NDVkNjU3MTQ2YjlkNTk5NGI4ZmViMTExMScsXG4gICAgICAgICAgICAgICAgJzVjYTU2MDc1M2JlMmExMmZjNmRlNmNhZjJjYjQ4OTU2NWRiOTM2MTU2Yjk1MTRlMWJiNWU4MzAzN2UwZmEyZDQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNGU0MmM4ZWM4MmM5OTc5OGNjZjNhNjEwYmU4NzBlNzgzMzhjN2Y3MTMzNDhiZDM0YzgyMDNlZjQwMzdmMzUwMicsXG4gICAgICAgICAgICAgICAgJzc1NzFkNzRlZTVlMGZiOTJhN2E4YjMzYTA3NzgzMzQxYTU0OTIxNDRjYzU0YmNjNDBhOTQ0NzM2OTM2MDY0MzcnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMzc3NWFiNzA4OWJjNmFmODIzYWJhMmUxYWY3MGIyMzZkMjUxY2FkYjBjODY3NDMyODc1MjJhMWIzYjBkZWRlYScsXG4gICAgICAgICAgICAgICAgJ2JlNTJkMTA3YmNmYTA5ZDhiY2I5NzM2YTgyOGNmYTdmYWM4ZGIxN2JmN2E3NmEyYzQyYWQ5NjE0MDkwMThjZjcnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnY2VlMzFjYmY3ZTM0ZWMzNzlkOTRmYjgxNGQzZDc3NWFkOTU0NTk1ZDEzMTRiYTg4NDY5NTllM2U4MmY3NGUyNicsXG4gICAgICAgICAgICAgICAgJzhmZDY0YTE0YzA2YjU4OWMyNmI5NDdhZTJiY2Y2YmZhMDE0OWVmMGJlMTRlZDRkODBmNDQ4YTAxYzQzYjFjNmQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnYjRmOWVhZWEwOWI2OTE3NjE5ZjZlYTZhNGViNTQ2NGVmZGRiNThmZDQ1YjFlYmVmY2RjMWEwMWQwOGI0Nzk4NicsXG4gICAgICAgICAgICAgICAgJzM5ZTVjOTkyNWI1YTU0YjA3NDMzYTRmMThjNjE3MjZmOGJiMTMxYzAxMmNhNTQyZWIyNGE4YWMwNzIwMDY4MmEnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZDQyNjNkZmMzZDJkZjkyM2EwMTc5YTQ4OTY2ZDMwY2U4NGUyNTE1YWZjM2RjY2MxYjc3OTA3NzkyZWJjYzYwZScsXG4gICAgICAgICAgICAgICAgJzYyZGZhZjA3YTBmNzhmZWIzMGUzMGQ2Mjk1ODUzY2UxODllMTI3NzYwYWQ2Y2Y3ZmFlMTY0ZTEyMmEyMDhkNTQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNDg0NTc1MjQ4MjBmYTY1YTRmOGQzNWViNjkzMDg1N2MwMDMyYWNjMGE0YTJkZTQyMjIzM2VlZGE4OTc2MTJjNCcsXG4gICAgICAgICAgICAgICAgJzI1YTc0OGFiMzY3OTc5ZDk4NzMzYzM4YTFmYTFjMmU3ZGM2Y2MwN2RiMmQ2MGE5YWU3YTc2YWFhNDliZDBmNzcnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZGZlZWVmMTg4MTEwMWYyY2IxMTY0NGYzYTJhZmRmYzIwNDVlMTk5MTkxNTI5MjNmMzY3YTE3NjdjMTFjY2VkYScsXG4gICAgICAgICAgICAgICAgJ2VjZmI3MDU2Y2YxZGUwNDJmOTQyMGJhYjM5Njc5M2MwYzM5MGJkZTc0YjRiYmRmZjE2YTgzYWUwOWE5YTc1MTcnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNmQ3ZWY2YjE3NTQzZjgzNzNjNTczZjQ0ZTFmMzg5ODM1ZDg5YmNiYzYwNjJjZWQzNmM4MmRmODNiOGZhZTg1OScsXG4gICAgICAgICAgICAgICAgJ2NkNDUwZWMzMzU0Mzg5ODZkZmVmYTEwYzU3ZmVhOWJjYzUyMWEwOTU5YjJkODBiYmY3NGIxOTBkY2E3MTJkMTAnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZTc1NjA1ZDU5MTAyYTVhMjY4NDUwMGQzYjk5MWYyZTNmM2M4OGI5MzIyNTU0NzAzNWFmMjVhZjY2ZTA0NTQxZicsXG4gICAgICAgICAgICAgICAgJ2Y1YzU0NzU0YThmNzFlZTU0MGI5YjQ4NzI4NDczZTMxNGY3MjlhYzUzMDhiMDY5MzgzNjA5OTBlMmJmYWQxMjUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZWI5ODY2MGY0YzRkZmFhMDZhMmJlNDUzZDUwMjBiYzk5YTBjMmU2MGFiZTM4ODQ1N2RkNDNmZWZiMWVkNjIwYycsXG4gICAgICAgICAgICAgICAgJzZjYjlhODg3NmQ5Y2I4NTIwNjA5YWYzYWRkMjZjZDIwYTBhN2NkOGE5NDExMTMxY2U4NWY0NDEwMDA5OTIyM2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMTNlODdiMDI3ZDg1MTRkMzU5MzlmMmU2ODkyYjE5OTIyMTU0NTk2OTQxODg4MzM2ZGMzNTYzZTNiOGRiYTk0MicsXG4gICAgICAgICAgICAgICAgJ2ZlZjVhM2M2ODA1OWE2ZGVjNWQ2MjQxMTRiZjFlOTFhYWMyYjlkYTU2OGQ2YWJlYjI1NzBkNTU2NDZiOGFkZjEnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZWUxNjMwMjZlOWZkNmZlMDE3YzM4ZjA2YTViZTZmYzEyNTQyNGIzNzFjZTI3MDhlN2JmNDQ5MTY5MWU1NzY0YScsXG4gICAgICAgICAgICAgICAgJzFhY2IyNTBmMjU1ZGQ2MWM0M2Q5NGNjYzY3MGQwZjU4ZjQ5YWUzZmExNWI5NjYyM2U1NDMwZGEwYWQ2YzYyYjInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnYjI2OGY1ZWY5YWQ1MWU0ZDc4ZGUzYTc1MGMyZGM4OWIxZTYyNmQ0MzUwNTg2Nzk5OTkzMmU1ZGIzM2FmM2Q4MCcsXG4gICAgICAgICAgICAgICAgJzVmMzEwZDRiM2M5OWI5ZWJiMTlmNzdkNDFjMWRlZTAxOGNmMGQzNGZkNDE5MTYxNDAwM2U5NDVhMTIxNmU0MjMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZmYwN2YzMTE4YTlkZjAzNWU5ZmFkODVlYjZjN2JmZTQyYjAyZjAxY2E5OWNlZWEzYmY3ZmZkYmE5M2M0NzUwZCcsXG4gICAgICAgICAgICAgICAgJzQzODEzNmQ2MDNlODU4YTNhNWM0NDBjMzhlY2NiYWRkYzFkMjk0MjExNGUyZWRkZDQ3NDBkMDk4Y2VkMWYwZDgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOGQ4Yjk4NTVjN2MwNTJhMzQxNDZmZDIwZmZiNjU4YmVhNGI5ZjY5ZTBkODI1ZWJlYzE2ZThjM2NlMmI1MjZhMScsXG4gICAgICAgICAgICAgICAgJ2NkYjU1OWVlZGMyZDc5ZjkyNmJhZjQ0ZmI4NGVhNGQ0NGJjZjUwZmVlNTFkN2NlYjMwZTJlN2Y0NjMwMzY3NTgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNTJkYjBiNTM4NGRmYmYwNWJmYTlkNDcyZDdhZTI2ZGZlNGI4NTFjZWNhOTFiMWViYTU0MjYzMTgwZGEzMmI2MycsXG4gICAgICAgICAgICAgICAgJ2MzYjk5N2QwNTBlZTVkNDIzZWJhZjY2YTZkYjlmNTdiMzE4MGM5MDI4NzU2NzlkZTkyNGI2OWQ4NGE3YjM3NScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdlNjJmOTQ5MGQzZDUxZGE2Mzk1ZWZkMjRlODA5MTljYzdkMGYyOWMzZjNmYTQ4YzZmZmY1NDNiZWNiZDQzMzUyJyxcbiAgICAgICAgICAgICAgICAnNmQ4OWFkN2JhNDg3NmIwYjIyYzJjYTI4MGM2ODI4NjJmMzQyYzg1OTFmMWRhZjUxNzBlMDdiZmQ5Y2NhZmE3ZCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc3ZjMwZWEyNDc2YjM5OWI0OTU3NTA5Yzg4Zjc3ZDAxOTFhZmEyZmY1Y2I3YjE0ZmQ2ZDhlN2Q2NWFhYWIxMTkzJyxcbiAgICAgICAgICAgICAgICAnY2E1ZWY3ZDRiMjMxYzk0YzNiMTUzODlhNWY2MzExZTlkYWZmN2JiNjdiMTAzZTk4ODBlZjRiZmY2MzdhY2FlYycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc1MDk4ZmYxZTFkOWYxNGZiNDZhMjEwZmFkYTZjOTAzZmVmMGZiN2I0YTFkZDFkOWFjNjBhMDM2MTgwMGI3YTAwJyxcbiAgICAgICAgICAgICAgICAnOTczMTE0MWQ4MWZjOGY4MDg0ZDM3YzZlNzU0MjAwNmIzZWUxYjQwZDYwZGZlNTM2MmE1YjEzMmZkMTdkZGMwJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzMyYjc4YzdkZTllZTUxMmE3Mjg5NWJlNmI5Y2JlZmE2ZTJmM2M0Y2NjZTQ0NWM5NmI5ZjJjODFlMjc3OGFkNTgnLFxuICAgICAgICAgICAgICAgICdlZTE4NDlmNTEzZGY3MWUzMmVmYzM4OTZlZTI4MjYwYzczYmI4MDU0N2FlMjI3NWJhNDk3MjM3Nzk0Yzg3NTNjJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2UyY2I3NGZkZGM4ZTlmYmNkMDc2ZWVmMmE3YzcyYjBjZTM3ZDUwZjA4MjY5ZGZjMDc0YjU4MTU1MDU0N2E0ZjcnLFxuICAgICAgICAgICAgICAgICdkM2FhMmVkNzFjOWRkMjI0N2E2MmRmMDYyNzM2ZWIwYmFkZGVhOWUzNjEyMmQyYmU4NjQxYWJjYjAwNWNjNGE0JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzg0Mzg0NDc1NjZkNGQ3YmVkYWRjMjk5NDk2YWIzNTc0MjYwMDlhMzVmMjM1Y2IxNDFiZTBkOTljZDEwYWUzYTgnLFxuICAgICAgICAgICAgICAgICdjNGUxMDIwOTE2OTgwYTRkYTVkMDFhYzVlNmFkMzMwNzM0ZWYwZDc5MDY2MzFjNGYyMzkwNDI2YjJlZGQ3OTFmJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzQxNjJkNDg4Yjg5NDAyMDM5YjU4NGM2ZmM2YzMwODg3MDU4N2Q5YzQ2ZjY2MGI4NzhhYjY1YzgyYzcxMWQ2N2UnLFxuICAgICAgICAgICAgICAgICc2NzE2M2U5MDMyMzYyODlmNzc2ZjIyYzI1ZmI4YTNhZmMxNzMyZjJiODRiNGU5NWRiZGE0N2FlNWEwODUyNjQ5JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzNmYWQzZmE4NGNhZjBmMzRmMGY4OWJmZDJkY2Y1NGZjMTc1ZDc2N2FlYzNlNTA2ODRmM2JhNGE0YmY1ZjY4M2QnLFxuICAgICAgICAgICAgICAgICdjZDFiYzdjYjZjYzQwN2JiMmYwY2E2NDdjNzE4YTczMGNmNzE4NzJlN2QwZDJhNTNmYTIwZWZjZGZlNjE4MjYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNjc0ZjI2MDBhMzAwN2EwMDU2OGMxYTdjZTA1ZDA4MTZjMWZiODRiZjEzNzA3OThmMWM2OTUzMmZhZWIxYTg2YicsXG4gICAgICAgICAgICAgICAgJzI5OWQyMWY5NDEzZjMzYjNlZGY0M2IyNTcwMDQ1ODBiNzBkYjU3ZGEwYjE4MjI1OWUwOWVlY2M2OWUwZDM4YTUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZDMyZjRkYTU0YWRlNzRhYmI4MWI4MTVhZDFmYjNiMjYzZDgyZDZjNjkyNzE0YmNmZjg3ZDI5YmQ1ZWU5ZjA4ZicsXG4gICAgICAgICAgICAgICAgJ2Y5NDI5ZTczOGI4ZTUzYjk2OGU5OTAxNmMwNTk3MDc3ODJlMTRmNDUzNTM1OWQ1ODJmYzQxNjkxMGIzZWVhODcnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMzBlNGU2NzA0MzUzODU1NTZlNTkzNjU3MTM1ODQ1ZDM2ZmJiNjkzMWY3MmIwOGNiMWVkOTU0ZjFlM2NlM2ZmNicsXG4gICAgICAgICAgICAgICAgJzQ2MmY5YmNlNjE5ODk4NjM4NDk5MzUwMTEzYmJjOWIxMGE4NzhkMzVkYTcwNzQwZGM2OTVhNTU5ZWI4OGRiN2InLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnYmUyMDYyMDAzYzUxY2MzMDA0NjgyOTA0MzMwZTRkZWU3ZjNkY2QxMGIwMWU1ODBiZjE5NzFiMDRkNGNhZDI5NycsXG4gICAgICAgICAgICAgICAgJzYyMTg4YmM0OWQ2MWU1NDI4NTczZDQ4YTc0ZTFjNjU1YjFjNjEwOTA5MDU2ODJhMGQ1NTU4ZWQ3MmRjY2I5YmMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOTMxNDQ0MjNhY2UzNDUxZWQyOWUwZmI5YWMyYWYyMTFjYjZlODRhNjAxZGY1OTkzYzQxOTg1OWZmZjVkZjA0YScsXG4gICAgICAgICAgICAgICAgJzdjMTBkZmIxNjRjMzQyNWY1YzcxYTNmOWQ3OTkyMDM4ZjEwNjUyMjRmNzJiYjlkMWQ5MDJhNmQxMzAzN2I0N2MnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnYjAxNWY4MDQ0ZjVmY2JkY2YyMWNhMjZkNmMzNGZiODE5NzgyOTIwNWM3YjdkMmE3Y2I2NjQxOGMxNTdiMTEyYycsXG4gICAgICAgICAgICAgICAgJ2FiOGMxZTA4NmQwNGU4MTM3NDRhNjU1YjJkZjhkNWY4M2IzY2RjNmZhYTMwODhjMWQzYWVhMTQ1NGUzYTFkNWYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZDVlOWUxZGE2NDlkOTdkODllNDg2ODExN2E0NjVhM2E0ZjhhMThkZTU3YTE0MGQzNmIzZjJhZjM0MWEyMWI1MicsXG4gICAgICAgICAgICAgICAgJzRjYjA0NDM3ZjM5MWVkNzMxMTFhMTNjYzFkNGRkMGRiMTY5MzQ2NWMyMjQwNDgwZDg5NTVlODU5MmYyNzQ0N2EnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZDNhZTQxMDQ3ZGQ3Y2EwNjVkYmY4ZWQ3N2I5OTI0Mzk5ODMwMDVjZDcyZTE2ZDZmOTk2YTUzMTZkMzY5NjZiYicsXG4gICAgICAgICAgICAgICAgJ2JkMWFlYjIxYWQyMmViYjIyYTEwZjAzMDM0MTdjNmQ5NjRmOGNkZDdkZjBhY2E2MTRiMTBkYzE0ZDEyNWFjNDYnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNDYzZTI3NjNkODg1Zjk1OGZjNjZjZGQyMjgwMGYwYTQ4NzE5N2QwYTgyZTM3N2I0OWY4MGFmODdjODk3YjA2NScsXG4gICAgICAgICAgICAgICAgJ2JmZWZhY2RiMGU1ZDBmZDdkZjNhMzExYTk0ZGUwNjJiMjZiODBjNjFmYmM5NzUwOGI3OTk5MjY3MWVmN2NhN2YnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNzk4NWZkZmQxMjdjMDU2N2M2ZjUzZWMxYmI2M2VjMzE1OGU1OTdjNDBiZmU3NDdjODNjZGRmYzkxMDY0MTkxNycsXG4gICAgICAgICAgICAgICAgJzYwM2MxMmRhZjNkOTg2MmVmMmIyNWZlMWRlMjg5YWVkMjRlZDI5MWUwZWM2NzA4NzAzYTViZDU2N2YzMmVkMDMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnNzRhMWFkNmI1Zjc2ZTM5ZGIyZGQyNDk0MTBlYWM3Zjk5ZTc0YzU5Y2I4M2QyZDBlZDVmZjE1NDNkYTc3MDNlOScsXG4gICAgICAgICAgICAgICAgJ2NjNjE1N2VmMThjOWM2M2NkNjE5M2Q4MzYzMWJiZWEwMDkzZTA5Njg5NDJlOGMzM2Q1NzM3ZmQ3OTBlMGRiMDgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMzA2ODJhNTA3MDMzNzVmNjAyZDQxNjY2NGJhMTliN2ZjOWJhYjQyYzcyNzQ3NDYzYTcxZDA4OTZiMjJmNmRhMycsXG4gICAgICAgICAgICAgICAgJzU1M2UwNGY2YjAxOGI0ZmE2YzhmMzllN2YzMTFkMzE3NjI5MGQwZTBmMTljYTczZjE3NzE0ZDk5NzdhMjJmZjgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnOWUyMTU4ZjBkN2MwZDVmMjZjMzc5MWVmZWZhNzk1OTc2NTRlN2EyYjI0NjRmNTJiMWVlNmMxMzQ3NzY5ZWY1NycsXG4gICAgICAgICAgICAgICAgJzcxMmZjZGQxYjkwNTNmMDkwMDNhMzQ4MWZhNzc2MmU5ZmZkN2M4ZWYzNWEzODUwOWUyZmJmMjYyOTAwODM3MycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcxNzZlMjY5ODlhNDNjOWNmZWJhNDAyOWMyMDI1MzhjMjgxNzJlNTY2ZTNjNGZjZTczMjI4NTdmM2JlMzI3ZDY2JyxcbiAgICAgICAgICAgICAgICAnZWQ4Y2M5ZDA0YjI5ZWI4NzdkMjcwYjQ4NzhkYzQzYzE5YWVmZDMxZjRlZWUwOWVlN2I0NzgzNGMxZmE0YjFjMycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc3NWQ0NmVmZWEzNzcxZTZlNjhhYmI4OWExM2FkNzQ3ZWNmMTg5MjM5M2RmYzRmMWI3MDA0Nzg4YzUwMzc0ZGE4JyxcbiAgICAgICAgICAgICAgICAnOTg1MjM5MGE5OTUwNzY3OWZkMGI4NmZkMmIzOWE4NjhkN2VmYzIyMTUxMzQ2ZTFhM2NhNDcyNjU4NmE2YmVkOCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc4MDlhMjBjNjdkNjQ5MDBmZmI2OThjNGM4MjVmNmQ1ZjIzMTBmYjA0NTFjODY5MzQ1YjczMTlmNjQ1NjA1NzIxJyxcbiAgICAgICAgICAgICAgICAnOWU5OTQ5ODBkOTkxN2UyMmI3NmIwNjE5MjdmYTA0MTQzZDA5NmNjYzU0OTYzZTZhNWViZmE1ZjNmOGUyODZjMScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcxYjM4OTAzYTQzZjdmMTE0ZWQ0NTAwYjRlYWM3MDgzZmRlZmVjZTFjZjI5YzYzNTI4ZDU2MzQ0NmY5NzJjMTgwJyxcbiAgICAgICAgICAgICAgICAnNDAzNmVkYzkzMWE2MGFlODg5MzUzZjc3ZmQ1M2RlNGEyNzA4YjI2YjZmNWRhNzJhZDMzOTQxMTlkYWY0MDhmOScsXG4gICAgICAgICAgICBdLFxuICAgICAgICBdLFxuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/precomputed/secp256k1.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js':
    /*!*****************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js ***!
  \*****************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nvar utils = exports;\nvar BN = __webpack_require__(/*! bn.js/lib/bn */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar minAssert = __webpack_require__(/*! minimalistic-assert */ \"(ssr)/./node_modules/minimalistic-assert/index.js\");\nvar minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ \"(ssr)/./node_modules/minimalistic-crypto-utils/lib/utils.js\");\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\nfunction getNAF(num, w, bits) {\n    var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n    naf.fill(0);\n    var ws = 1 << (w + 1);\n    var k = num.clone();\n    for (var i = 0; i < naf.length; i++) {\n        var z;\n        var mod = k.andln(ws - 1);\n        if (k.isOdd()) {\n            if (mod > (ws >> 1) - 1)\n                z = (ws >> 1) - mod;\n            else\n                z = mod;\n            k.isubn(z);\n        }\n        else {\n            z = 0;\n        }\n        naf[i] = z;\n        k.iushrn(1);\n    }\n    return naf;\n}\nutils.getNAF = getNAF;\nfunction getJSF(k1, k2) {\n    var jsf = [\n        [],\n        [],\n    ];\n    k1 = k1.clone();\n    k2 = k2.clone();\n    var d1 = 0;\n    var d2 = 0;\n    var m8;\n    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n        var m14 = (k1.andln(3) + d1) & 3;\n        var m24 = (k2.andln(3) + d2) & 3;\n        if (m14 === 3)\n            m14 = -1;\n        if (m24 === 3)\n            m24 = -1;\n        var u1;\n        if ((m14 & 1) === 0) {\n            u1 = 0;\n        }\n        else {\n            m8 = (k1.andln(7) + d1) & 7;\n            if ((m8 === 3 || m8 === 5) && m24 === 2)\n                u1 = -m14;\n            else\n                u1 = m14;\n        }\n        jsf[0].push(u1);\n        var u2;\n        if ((m24 & 1) === 0) {\n            u2 = 0;\n        }\n        else {\n            m8 = (k2.andln(7) + d2) & 7;\n            if ((m8 === 3 || m8 === 5) && m14 === 2)\n                u2 = -m24;\n            else\n                u2 = m24;\n        }\n        jsf[1].push(u2);\n        if (2 * d1 === u1 + 1)\n            d1 = 1 - d1;\n        if (2 * d2 === u2 + 1)\n            d2 = 1 - d2;\n        k1.iushrn(1);\n        k2.iushrn(1);\n    }\n    return jsf;\n}\nutils.getJSF = getJSF;\nfunction cachedProperty(obj, name, computer) {\n    var key = '_' + name;\n    obj.prototype[name] = function cachedProperty() {\n        return this[key] !== undefined ? this[key] :\n            this[key] = computer.call(this);\n    };\n}\nutils.cachedProperty = cachedProperty;\nfunction parseBytes(bytes) {\n    return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n        bytes;\n}\nutils.parseBytes = parseBytes;\nfunction intFromLE(bytes) {\n    return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2VsbGlwdGljL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxTQUFTLG1CQUFPLENBQUMsMERBQWM7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQXFCO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyw4RkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9lbGxpcHRpYy91dGlscy5qcz9kMGViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IGV4cG9ydHM7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcy9saWIvYm4nKTtcbnZhciBtaW5Bc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgbWluVXRpbHMgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzJyk7XG51dGlscy5hc3NlcnQgPSBtaW5Bc3NlcnQ7XG51dGlscy50b0FycmF5ID0gbWluVXRpbHMudG9BcnJheTtcbnV0aWxzLnplcm8yID0gbWluVXRpbHMuemVybzI7XG51dGlscy50b0hleCA9IG1pblV0aWxzLnRvSGV4O1xudXRpbHMuZW5jb2RlID0gbWluVXRpbHMuZW5jb2RlO1xuZnVuY3Rpb24gZ2V0TkFGKG51bSwgdywgYml0cykge1xuICAgIHZhciBuYWYgPSBuZXcgQXJyYXkoTWF0aC5tYXgobnVtLmJpdExlbmd0aCgpLCBiaXRzKSArIDEpO1xuICAgIG5hZi5maWxsKDApO1xuICAgIHZhciB3cyA9IDEgPDwgKHcgKyAxKTtcbiAgICB2YXIgayA9IG51bS5jbG9uZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB6O1xuICAgICAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuICAgICAgICBpZiAoay5pc09kZCgpKSB7XG4gICAgICAgICAgICBpZiAobW9kID4gKHdzID4+IDEpIC0gMSlcbiAgICAgICAgICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHogPSBtb2Q7XG4gICAgICAgICAgICBrLmlzdWJuKHopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbmFmW2ldID0gejtcbiAgICAgICAgay5pdXNocm4oMSk7XG4gICAgfVxuICAgIHJldHVybiBuYWY7XG59XG51dGlscy5nZXROQUYgPSBnZXROQUY7XG5mdW5jdGlvbiBnZXRKU0YoazEsIGsyKSB7XG4gICAgdmFyIGpzZiA9IFtcbiAgICAgICAgW10sXG4gICAgICAgIFtdLFxuICAgIF07XG4gICAgazEgPSBrMS5jbG9uZSgpO1xuICAgIGsyID0gazIuY2xvbmUoKTtcbiAgICB2YXIgZDEgPSAwO1xuICAgIHZhciBkMiA9IDA7XG4gICAgdmFyIG04O1xuICAgIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcbiAgICAgICAgdmFyIG0xNCA9IChrMS5hbmRsbigzKSArIGQxKSAmIDM7XG4gICAgICAgIHZhciBtMjQgPSAoazIuYW5kbG4oMykgKyBkMikgJiAzO1xuICAgICAgICBpZiAobTE0ID09PSAzKVxuICAgICAgICAgICAgbTE0ID0gLTE7XG4gICAgICAgIGlmIChtMjQgPT09IDMpXG4gICAgICAgICAgICBtMjQgPSAtMTtcbiAgICAgICAgdmFyIHUxO1xuICAgICAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG4gICAgICAgICAgICB1MSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtOCA9IChrMS5hbmRsbig3KSArIGQxKSAmIDc7XG4gICAgICAgICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMjQgPT09IDIpXG4gICAgICAgICAgICAgICAgdTEgPSAtbTE0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHUxID0gbTE0O1xuICAgICAgICB9XG4gICAgICAgIGpzZlswXS5wdXNoKHUxKTtcbiAgICAgICAgdmFyIHUyO1xuICAgICAgICBpZiAoKG0yNCAmIDEpID09PSAwKSB7XG4gICAgICAgICAgICB1MiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtOCA9IChrMi5hbmRsbig3KSArIGQyKSAmIDc7XG4gICAgICAgICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG4gICAgICAgICAgICAgICAgdTIgPSAtbTI0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHUyID0gbTI0O1xuICAgICAgICB9XG4gICAgICAgIGpzZlsxXS5wdXNoKHUyKTtcbiAgICAgICAgaWYgKDIgKiBkMSA9PT0gdTEgKyAxKVxuICAgICAgICAgICAgZDEgPSAxIC0gZDE7XG4gICAgICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcbiAgICAgICAgICAgIGQyID0gMSAtIGQyO1xuICAgICAgICBrMS5pdXNocm4oMSk7XG4gICAgICAgIGsyLml1c2hybigxKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzZjtcbn1cbnV0aWxzLmdldEpTRiA9IGdldEpTRjtcbmZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KG9iaiwgbmFtZSwgY29tcHV0ZXIpIHtcbiAgICB2YXIga2V5ID0gJ18nICsgbmFtZTtcbiAgICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBjb21wdXRlci5jYWxsKHRoaXMpO1xuICAgIH07XG59XG51dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcykge1xuICAgIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcbiAgICAgICAgYnl0ZXM7XG59XG51dGlscy5wYXJzZUJ5dGVzID0gcGFyc2VCeXRlcztcbmZ1bmN0aW9uIGludEZyb21MRShieXRlcykge1xuICAgIHJldHVybiBuZXcgQk4oYnl0ZXMsICdoZXgnLCAnbGUnKTtcbn1cbnV0aWxzLmludEZyb21MRSA9IGludEZyb21MRTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/utils.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js':
    /*!********************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/index.js ***!
  \********************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.secp256k1 = exports.ed25519 = exports.Long = exports._m0 = exports.protobuf = exports.typeforce = exports.safeBuffer = exports.BigNumber = exports.BN = exports.math = exports.signUtil = exports.abi = exports.elliptic = exports.bip39 = exports.bip32 = exports.base = void 0;\nexports.base = __importStar(__webpack_require__(/*! ./base */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/index.js"));\nexports.bip32 = __importStar(__webpack_require__(/*! ./bip32 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip32/index.js"));\nexports.bip39 = __importStar(__webpack_require__(/*! ./bip39 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip39/index.js"));\nexports.elliptic = __importStar(__webpack_require__(/*! ./elliptic */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/index.js"));\nexports.abi = __importStar(__webpack_require__(/*! ./abi */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/abi/index.js"));\nexports.signUtil = __importStar(__webpack_require__(/*! ./signutil */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/index.js"));\nexports.math = __importStar(__webpack_require__(/*! ./math */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/math/index.js"));\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ "(ssr)/./node_modules/bn.js/lib/bn.js"));\nexports.BN = bn_js_1.default;\nconst bignumber_js_1 = __importDefault(__webpack_require__(/*! bignumber.js */ "(ssr)/./node_modules/bignumber.js/bignumber.js"));\nexports.BigNumber = bignumber_js_1.default;\nconst safe_buffer_1 = __importDefault(__webpack_require__(/*! safe-buffer */ "(ssr)/./node_modules/safe-buffer/index.js"));\nexports.safeBuffer = safe_buffer_1.default;\nconst typeforce = __webpack_require__(/*! typeforce */ "(ssr)/./node_modules/typeforce/index.js");\nexports.typeforce = typeforce;\nexports.protobuf = __importStar(__webpack_require__(/*! protobufjs */ "(ssr)/./node_modules/protobufjs/index.js"));\nexports._m0 = __importStar(__webpack_require__(/*! protobufjs/minimal */ "(ssr)/./node_modules/protobufjs/minimal.js"));\nconst long_1 = __importDefault(__webpack_require__(/*! long */ "(ssr)/./node_modules/long/umd/index.js"));\nexports.Long = long_1.default;\nexports.ed25519 = __importStar(__webpack_require__(/*! @noble/ed25519 */ "(ssr)/./node_modules/@noble/ed25519/lib/index.js"));\nexports.secp256k1 = __importStar(__webpack_require__(/*! @noble/secp256k1 */ "(ssr)/./node_modules/@noble/secp256k1/lib/index.js"));\n__exportStar(__webpack_require__(/*! bigint-conversion */ "(ssr)/./node_modules/bigint-conversion/dist/cjs/index.node.js"), exports);\n__exportStar(__webpack_require__(/*! bigint-crypto-utils */ "(ssr)/./node_modules/bigint-crypto-utils/dist/index.node.esm.js"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcsV0FBVyxHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLFVBQVUsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGdCQUFnQixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsWUFBWTtBQUMvUSxZQUFZLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFRO0FBQzVDLGFBQWEsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVM7QUFDOUMsYUFBYSxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBUztBQUM5QyxnQkFBZ0IsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVk7QUFDcEQsV0FBVyxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBTztBQUMxQyxnQkFBZ0IsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVk7QUFDcEQsWUFBWSxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBUTtBQUM1QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxtREFBTztBQUMvQyxVQUFVO0FBQ1YsdUNBQXVDLG1CQUFPLENBQUMsb0VBQWM7QUFDN0QsaUJBQWlCO0FBQ2pCLHNDQUFzQyxtQkFBTyxDQUFDLDhEQUFhO0FBQzNELGtCQUFrQjtBQUNsQixrQkFBa0IsbUJBQU8sQ0FBQywwREFBVztBQUNyQyxpQkFBaUI7QUFDakIsZ0JBQWdCLGdCQUFnQixtQkFBTyxDQUFDLDREQUFZO0FBQ3BELFdBQVcsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQW9CO0FBQ3ZELCtCQUErQixtQkFBTyxDQUFDLG9EQUFNO0FBQzdDLFlBQVk7QUFDWixlQUFlLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFnQjtBQUN2RCxpQkFBaUIsZ0JBQWdCLG1CQUFPLENBQUMsNEVBQWtCO0FBQzNELGFBQWEsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLDRGQUFxQjtBQUMxQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9pbmRleC5qcz8yNmNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSBleHBvcnRzLmVkMjU1MTkgPSBleHBvcnRzLkxvbmcgPSBleHBvcnRzLl9tMCA9IGV4cG9ydHMucHJvdG9idWYgPSBleHBvcnRzLnR5cGVmb3JjZSA9IGV4cG9ydHMuc2FmZUJ1ZmZlciA9IGV4cG9ydHMuQmlnTnVtYmVyID0gZXhwb3J0cy5CTiA9IGV4cG9ydHMubWF0aCA9IGV4cG9ydHMuc2lnblV0aWwgPSBleHBvcnRzLmFiaSA9IGV4cG9ydHMuZWxsaXB0aWMgPSBleHBvcnRzLmJpcDM5ID0gZXhwb3J0cy5iaXAzMiA9IGV4cG9ydHMuYmFzZSA9IHZvaWQgMDtcbmV4cG9ydHMuYmFzZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlXCIpKTtcbmV4cG9ydHMuYmlwMzIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYmlwMzJcIikpO1xuZXhwb3J0cy5iaXAzOSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9iaXAzOVwiKSk7XG5leHBvcnRzLmVsbGlwdGljID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2VsbGlwdGljXCIpKTtcbmV4cG9ydHMuYWJpID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FiaVwiKSk7XG5leHBvcnRzLnNpZ25VdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ251dGlsXCIpKTtcbmV4cG9ydHMubWF0aCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9tYXRoXCIpKTtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmV4cG9ydHMuQk4gPSBibl9qc18xLmRlZmF1bHQ7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbmV4cG9ydHMuQmlnTnVtYmVyID0gYmlnbnVtYmVyX2pzXzEuZGVmYXVsdDtcbmNvbnN0IHNhZmVfYnVmZmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInNhZmUtYnVmZmVyXCIpKTtcbmV4cG9ydHMuc2FmZUJ1ZmZlciA9IHNhZmVfYnVmZmVyXzEuZGVmYXVsdDtcbmNvbnN0IHR5cGVmb3JjZSA9IHJlcXVpcmUoJ3R5cGVmb3JjZScpO1xuZXhwb3J0cy50eXBlZm9yY2UgPSB0eXBlZm9yY2U7XG5leHBvcnRzLnByb3RvYnVmID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJwcm90b2J1ZmpzXCIpKTtcbmV4cG9ydHMuX20wID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuY29uc3QgbG9uZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb25nXCIpKTtcbmV4cG9ydHMuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuZXhwb3J0cy5lZDI1NTE5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJAbm9ibGUvZWQyNTUxOVwiKSk7XG5leHBvcnRzLnNlY3AyNTZrMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiQG5vYmxlL3NlY3AyNTZrMVwiKSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcImJpZ2ludC1jb252ZXJzaW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiYmlnaW50LWNyeXB0by11dGlsc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/math/decimal.js':
    /*!***************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/math/decimal.js ***!
  \***************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Decimal = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ "(ssr)/./node_modules/bn.js/lib/bn.js"));\nconst maxFractionalDigits = 100;\nclass Decimal {\n    static fromUserInput(input, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        const badCharacter = input.match(/[^0-9.]/);\n        if (badCharacter) {\n            throw new Error(`Invalid character at position ${badCharacter.index + 1}`);\n        }\n        let whole;\n        let fractional;\n        if (input.search(/\\./) === -1) {\n            whole = input;\n            fractional = "";\n        }\n        else {\n            const parts = input.split(".");\n            switch (parts.length) {\n                case 0:\n                case 1:\n                    throw new Error("Fewer than two elements in split result. This must not happen here.");\n                case 2:\n                    if (!parts[1])\n                        throw new Error("Fractional part missing");\n                    whole = parts[0];\n                    fractional = parts[1].replace(/0+$/, "");\n                    break;\n                default:\n                    throw new Error("More than one separator found");\n            }\n        }\n        if (fractional.length > fractionalDigits) {\n            throw new Error("Got more fractional digits than supported");\n        }\n        const quantity = `${whole}${fractional.padEnd(fractionalDigits, "0")}`;\n        return new Decimal(quantity, fractionalDigits);\n    }\n    static fromAtomics(atomics, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(atomics, fractionalDigits);\n    }\n    static zero(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal("0", fractionalDigits);\n    }\n    static one(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal("1" + "0".repeat(fractionalDigits), fractionalDigits);\n    }\n    static verifyFractionalDigits(fractionalDigits) {\n        if (!Number.isInteger(fractionalDigits))\n            throw new Error("Fractional digits is not an integer");\n        if (fractionalDigits < 0)\n            throw new Error("Fractional digits must not be negative");\n        if (fractionalDigits > maxFractionalDigits) {\n            throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);\n        }\n    }\n    static compare(a, b) {\n        if (a.fractionalDigits !== b.fractionalDigits)\n            throw new Error("Fractional digits do not match");\n        return a.data.atomics.cmp(new bn_js_1.default(b.atomics));\n    }\n    get atomics() {\n        return this.data.atomics.toString();\n    }\n    get fractionalDigits() {\n        return this.data.fractionalDigits;\n    }\n    constructor(atomics, fractionalDigits) {\n        this.data = {\n            atomics: new bn_js_1.default(atomics),\n            fractionalDigits: fractionalDigits,\n        };\n    }\n    toString() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return whole.toString();\n        }\n        else {\n            const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, "0");\n            const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, "");\n            return `${whole.toString()}.${trimmedFractionalPart}`;\n        }\n    }\n    toFloatApproximation() {\n        const out = Number(this.toString());\n        if (Number.isNaN(out))\n            throw new Error("Conversion to number failed");\n        return out;\n    }\n    plus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error("Fractional digits do not match");\n        const sum = this.data.atomics.add(new bn_js_1.default(b.atomics));\n        return new Decimal(sum.toString(), this.fractionalDigits);\n    }\n    minus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error("Fractional digits do not match");\n        const difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));\n        if (difference.ltn(0))\n            throw new Error("Difference must not be negative");\n        return new Decimal(difference.toString(), this.fractionalDigits);\n    }\n    multiply(b) {\n        const product = this.data.atomics.mul(new bn_js_1.default(b.toString()));\n        return new Decimal(product.toString(), this.fractionalDigits);\n    }\n    equals(b) {\n        return Decimal.compare(this, b) === 0;\n    }\n    isLessThan(b) {\n        return Decimal.compare(this, b) < 0;\n    }\n    isLessThanOrEqual(b) {\n        return Decimal.compare(this, b) <= 0;\n    }\n    isGreaterThan(b) {\n        return Decimal.compare(this, b) > 0;\n    }\n    isGreaterThanOrEqual(b) {\n        return Decimal.compare(this, b) >= 0;\n    }\n}\nexports.Decimal = Decimal;\n//# sourceMappingURL=decimal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L21hdGgvZGVjaW1hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixnQ0FBZ0MsbUJBQU8sQ0FBQyxtREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsdUJBQXVCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSxFQUFFLHlDQUF5QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG9CQUFvQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQixHQUFHLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvbWF0aC9kZWNpbWFsLmpzP2UxMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlY2ltYWwgPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCBtYXhGcmFjdGlvbmFsRGlnaXRzID0gMTAwO1xuY2xhc3MgRGVjaW1hbCB7XG4gICAgc3RhdGljIGZyb21Vc2VySW5wdXQoaW5wdXQsIGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICAgICAgRGVjaW1hbC52ZXJpZnlGcmFjdGlvbmFsRGlnaXRzKGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgICAgICBjb25zdCBiYWRDaGFyYWN0ZXIgPSBpbnB1dC5tYXRjaCgvW14wLTkuXS8pO1xuICAgICAgICBpZiAoYmFkQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyIGF0IHBvc2l0aW9uICR7YmFkQ2hhcmFjdGVyLmluZGV4ICsgMX1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2hvbGU7XG4gICAgICAgIGxldCBmcmFjdGlvbmFsO1xuICAgICAgICBpZiAoaW5wdXQuc2VhcmNoKC9cXC4vKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHdob2xlID0gaW5wdXQ7XG4gICAgICAgICAgICBmcmFjdGlvbmFsID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gaW5wdXQuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZXdlciB0aGFuIHR3byBlbGVtZW50cyBpbiBzcGxpdCByZXN1bHQuIFRoaXMgbXVzdCBub3QgaGFwcGVuIGhlcmUuXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0c1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYWN0aW9uYWwgcGFydCBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB3aG9sZSA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBmcmFjdGlvbmFsID0gcGFydHNbMV0ucmVwbGFjZSgvMCskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vcmUgdGhhbiBvbmUgc2VwYXJhdG9yIGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFjdGlvbmFsLmxlbmd0aCA+IGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCBtb3JlIGZyYWN0aW9uYWwgZGlnaXRzIHRoYW4gc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1YW50aXR5ID0gYCR7d2hvbGV9JHtmcmFjdGlvbmFsLnBhZEVuZChmcmFjdGlvbmFsRGlnaXRzLCBcIjBcIil9YDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKHF1YW50aXR5LCBmcmFjdGlvbmFsRGlnaXRzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BdG9taWNzKGF0b21pY3MsIGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICAgICAgRGVjaW1hbC52ZXJpZnlGcmFjdGlvbmFsRGlnaXRzKGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoYXRvbWljcywgZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgfVxuICAgIHN0YXRpYyB6ZXJvKGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICAgICAgRGVjaW1hbC52ZXJpZnlGcmFjdGlvbmFsRGlnaXRzKGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoXCIwXCIsIGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cbiAgICBzdGF0aWMgb25lKGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICAgICAgRGVjaW1hbC52ZXJpZnlGcmFjdGlvbmFsRGlnaXRzKGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoXCIxXCIgKyBcIjBcIi5yZXBlYXQoZnJhY3Rpb25hbERpZ2l0cyksIGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cbiAgICBzdGF0aWMgdmVyaWZ5RnJhY3Rpb25hbERpZ2l0cyhmcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihmcmFjdGlvbmFsRGlnaXRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYWN0aW9uYWwgZGlnaXRzIGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICBpZiAoZnJhY3Rpb25hbERpZ2l0cyA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFjdGlvbmFsIGRpZ2l0cyBtdXN0IG5vdCBiZSBuZWdhdGl2ZVwiKTtcbiAgICAgICAgaWYgKGZyYWN0aW9uYWxEaWdpdHMgPiBtYXhGcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZyYWN0aW9uYWwgZGlnaXRzIG11c3Qgbm90IGV4Y2VlZCAke21heEZyYWN0aW9uYWxEaWdpdHN9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBpZiAoYS5mcmFjdGlvbmFsRGlnaXRzICE9PSBiLmZyYWN0aW9uYWxEaWdpdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFjdGlvbmFsIGRpZ2l0cyBkbyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBhLmRhdGEuYXRvbWljcy5jbXAobmV3IGJuX2pzXzEuZGVmYXVsdChiLmF0b21pY3MpKTtcbiAgICB9XG4gICAgZ2V0IGF0b21pY3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuYXRvbWljcy50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXQgZnJhY3Rpb25hbERpZ2l0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5mcmFjdGlvbmFsRGlnaXRzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhdG9taWNzLCBmcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIGF0b21pY3M6IG5ldyBibl9qc18xLmRlZmF1bHQoYXRvbWljcyksXG4gICAgICAgICAgICBmcmFjdGlvbmFsRGlnaXRzOiBmcmFjdGlvbmFsRGlnaXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgxMCkucG93KG5ldyBibl9qc18xLmRlZmF1bHQodGhpcy5kYXRhLmZyYWN0aW9uYWxEaWdpdHMpKTtcbiAgICAgICAgY29uc3Qgd2hvbGUgPSB0aGlzLmRhdGEuYXRvbWljcy5kaXYoZmFjdG9yKTtcbiAgICAgICAgY29uc3QgZnJhY3Rpb25hbCA9IHRoaXMuZGF0YS5hdG9taWNzLm1vZChmYWN0b3IpO1xuICAgICAgICBpZiAoZnJhY3Rpb25hbC5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdob2xlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsRnJhY3Rpb25hbFBhcnQgPSBmcmFjdGlvbmFsLnRvU3RyaW5nKCkucGFkU3RhcnQodGhpcy5kYXRhLmZyYWN0aW9uYWxEaWdpdHMsIFwiMFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcmFjdGlvbmFsUGFydCA9IGZ1bGxGcmFjdGlvbmFsUGFydC5yZXBsYWNlKC8wKyQvLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiBgJHt3aG9sZS50b1N0cmluZygpfS4ke3RyaW1tZWRGcmFjdGlvbmFsUGFydH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvRmxvYXRBcHByb3hpbWF0aW9uKCkge1xuICAgICAgICBjb25zdCBvdXQgPSBOdW1iZXIodGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihvdXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmVyc2lvbiB0byBudW1iZXIgZmFpbGVkXCIpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBwbHVzKGIpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhY3Rpb25hbERpZ2l0cyAhPT0gYi5mcmFjdGlvbmFsRGlnaXRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhY3Rpb25hbCBkaWdpdHMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICBjb25zdCBzdW0gPSB0aGlzLmRhdGEuYXRvbWljcy5hZGQobmV3IGJuX2pzXzEuZGVmYXVsdChiLmF0b21pY3MpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKHN1bS50b1N0cmluZygpLCB0aGlzLmZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cbiAgICBtaW51cyhiKSB7XG4gICAgICAgIGlmICh0aGlzLmZyYWN0aW9uYWxEaWdpdHMgIT09IGIuZnJhY3Rpb25hbERpZ2l0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYWN0aW9uYWwgZGlnaXRzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMuZGF0YS5hdG9taWNzLnN1YihuZXcgYm5fanNfMS5kZWZhdWx0KGIuYXRvbWljcykpO1xuICAgICAgICBpZiAoZGlmZmVyZW5jZS5sdG4oMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWZmZXJlbmNlIG11c3Qgbm90IGJlIG5lZ2F0aXZlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoZGlmZmVyZW5jZS50b1N0cmluZygpLCB0aGlzLmZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cbiAgICBtdWx0aXBseShiKSB7XG4gICAgICAgIGNvbnN0IHByb2R1Y3QgPSB0aGlzLmRhdGEuYXRvbWljcy5tdWwobmV3IGJuX2pzXzEuZGVmYXVsdChiLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKHByb2R1Y3QudG9TdHJpbmcoKSwgdGhpcy5mcmFjdGlvbmFsRGlnaXRzKTtcbiAgICB9XG4gICAgZXF1YWxzKGIpIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWwuY29tcGFyZSh0aGlzLCBiKSA9PT0gMDtcbiAgICB9XG4gICAgaXNMZXNzVGhhbihiKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsLmNvbXBhcmUodGhpcywgYikgPCAwO1xuICAgIH1cbiAgICBpc0xlc3NUaGFuT3JFcXVhbChiKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsLmNvbXBhcmUodGhpcywgYikgPD0gMDtcbiAgICB9XG4gICAgaXNHcmVhdGVyVGhhbihiKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsLmNvbXBhcmUodGhpcywgYikgPiAwO1xuICAgIH1cbiAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbChiKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsLmNvbXBhcmUodGhpcywgYikgPj0gMDtcbiAgICB9XG59XG5leHBvcnRzLkRlY2ltYWwgPSBEZWNpbWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjaW1hbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/math/decimal.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/math/index.js':
    /*!*************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/math/index.js ***!
  \*************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Uint64 = exports.Uint53 = exports.Uint32 = exports.Int53 = exports.Decimal = void 0;\nvar decimal_1 = __webpack_require__(/*! ./decimal */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/math/decimal.js");\nObject.defineProperty(exports, "Decimal", ({ enumerable: true, get: function () { return decimal_1.Decimal; } }));\nvar integers_1 = __webpack_require__(/*! ./integers */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/math/integers.js");\nObject.defineProperty(exports, "Int53", ({ enumerable: true, get: function () { return integers_1.Int53; } }));\nObject.defineProperty(exports, "Uint32", ({ enumerable: true, get: function () { return integers_1.Uint32; } }));\nObject.defineProperty(exports, "Uint53", ({ enumerable: true, get: function () { return integers_1.Uint53; } }));\nObject.defineProperty(exports, "Uint64", ({ enumerable: true, get: function () { return integers_1.Uint64; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L21hdGgvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGVBQWU7QUFDbEYsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQVc7QUFDbkMsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFZO0FBQ3JDLHlDQUF3QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM1RywwQ0FBeUMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDOUcsMENBQXlDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzlHLDBDQUF5QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUM5RyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9tYXRoL2luZGV4LmpzP2ExMmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVpbnQ2NCA9IGV4cG9ydHMuVWludDUzID0gZXhwb3J0cy5VaW50MzIgPSBleHBvcnRzLkludDUzID0gZXhwb3J0cy5EZWNpbWFsID0gdm9pZCAwO1xudmFyIGRlY2ltYWxfMSA9IHJlcXVpcmUoXCIuL2RlY2ltYWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNpbWFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNpbWFsXzEuRGVjaW1hbDsgfSB9KTtcbnZhciBpbnRlZ2Vyc18xID0gcmVxdWlyZShcIi4vaW50ZWdlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnQ1M1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZWdlcnNfMS5JbnQ1MzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQzMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZWdlcnNfMS5VaW50MzI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50NTNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVnZXJzXzEuVWludDUzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlZ2Vyc18xLlVpbnQ2NDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/math/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/math/integers.js':
    /*!****************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/math/integers.js ***!
  \****************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ "(ssr)/./node_modules/bn.js/lib/bn.js"));\nconst uint64MaxValue = new bn_js_1.default("18446744073709551615", 10, "be");\nclass Uint32 {\n    static fromBigEndianBytes(bytes) {\n        return Uint32.fromBytes(bytes);\n    }\n    static fromBytes(bytes, endianess = "be") {\n        if (bytes.length !== 4) {\n            throw new Error("Invalid input length. Expected 4 bytes.");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error("Invalid value in byte. Found: " + bytes[i]);\n            }\n        }\n        const beBytes = endianess === "be" ? bytes : Array.from(bytes).reverse();\n        return new Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error("Invalid string format");\n        }\n        return new Uint32(Number.parseInt(str, 10));\n    }\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error("Input is not a number");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error("Input is not an integer");\n        }\n        if (input < 0 || input > 4294967295) {\n            throw new Error("Input not in uint32 range: " + input.toString());\n        }\n        this.data = input;\n    }\n    toBytesBigEndian() {\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 24) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 0) & 0xff,\n        ]);\n    }\n    toBytesLittleEndian() {\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 0) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 24) & 0xff,\n        ]);\n    }\n    toNumber() {\n        return this.data;\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint32 = Uint32;\nclass Int53 {\n    static fromString(str) {\n        if (!str.match(/^-?[0-9]+$/)) {\n            throw new Error("Invalid string format");\n        }\n        return new Int53(Number.parseInt(str, 10));\n    }\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error("Input is not a number");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error("Input is not an integer");\n        }\n        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n            throw new Error("Input not in int53 range: " + input.toString());\n        }\n        this.data = input;\n    }\n    toNumber() {\n        return this.data;\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Int53 = Int53;\nclass Uint53 {\n    static fromString(str) {\n        const signed = Int53.fromString(str);\n        return new Uint53(signed.toNumber());\n    }\n    constructor(input) {\n        const signed = new Int53(input);\n        if (signed.toNumber() < 0) {\n            throw new Error("Input is negative");\n        }\n        this.data = signed;\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint53 = Uint53;\nclass Uint64 {\n    static fromBytesBigEndian(bytes) {\n        return Uint64.fromBytes(bytes);\n    }\n    static fromBytes(bytes, endianess = "be") {\n        if (bytes.length !== 8) {\n            throw new Error("Invalid input length. Expected 8 bytes.");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error("Invalid value in byte. Found: " + bytes[i]);\n            }\n        }\n        const beBytes = endianess === "be" ? Array.from(bytes) : Array.from(bytes).reverse();\n        return new Uint64(new bn_js_1.default(beBytes));\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error("Invalid string format");\n        }\n        return new Uint64(new bn_js_1.default(str, 10, "be"));\n    }\n    static fromNumber(input) {\n        if (Number.isNaN(input)) {\n            throw new Error("Input is not a number");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error("Input is not an integer");\n        }\n        let bigint;\n        try {\n            bigint = new bn_js_1.default(input);\n        }\n        catch (e) {\n            throw new Error("Input is not a safe integer");\n        }\n        return new Uint64(bigint);\n    }\n    constructor(data) {\n        if (data.isNeg()) {\n            throw new Error("Input is negative");\n        }\n        if (data.gt(uint64MaxValue)) {\n            throw new Error("Input exceeds uint64 range");\n        }\n        this.data = data;\n    }\n    toBytesBigEndian() {\n        return Uint8Array.from(this.data.toArray("be", 8));\n    }\n    toBytesLittleEndian() {\n        return Uint8Array.from(this.data.toArray("le", 8));\n    }\n    toString() {\n        return this.data.toString(10);\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n}\nexports.Uint64 = Uint64;\nconst _int53Class = Int53;\nconst _uint53Class = Uint53;\nconst _uint32Class = Uint32;\nconst _uint64Class = Uint64;\n//# sourceMappingURL=integers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L21hdGgvaW50ZWdlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxjQUFjO0FBQ2hFLGdDQUFnQyxtQkFBTyxDQUFDLG1EQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3QvbWF0aC9pbnRlZ2Vycy5qcz9jMGZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VaW50NjQgPSBleHBvcnRzLlVpbnQ1MyA9IGV4cG9ydHMuSW50NTMgPSBleHBvcnRzLlVpbnQzMiA9IHZvaWQgMDtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IHVpbnQ2NE1heFZhbHVlID0gbmV3IGJuX2pzXzEuZGVmYXVsdChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIsIDEwLCBcImJlXCIpO1xuY2xhc3MgVWludDMyIHtcbiAgICBzdGF0aWMgZnJvbUJpZ0VuZGlhbkJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBVaW50MzIuZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcywgZW5kaWFuZXNzID0gXCJiZVwiKSB7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgbGVuZ3RoLiBFeHBlY3RlZCA0IGJ5dGVzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYnl0ZXNbaV0pIHx8IGJ5dGVzW2ldID4gMjU1IHx8IGJ5dGVzW2ldIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgaW4gYnl0ZS4gRm91bmQ6IFwiICsgYnl0ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJlQnl0ZXMgPSBlbmRpYW5lc3MgPT09IFwiYmVcIiA/IGJ5dGVzIDogQXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMihiZUJ5dGVzWzBdICogMiAqKiAyNCArIGJlQnl0ZXNbMV0gKiAyICoqIDE2ICsgYmVCeXRlc1syXSAqIDIgKiogOCArIGJlQnl0ZXNbM10pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMihOdW1iZXIucGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGEgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCA8IDAgfHwgaW5wdXQgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBub3QgaW4gdWludDMyIHJhbmdlOiBcIiArIGlucHV0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IGlucHV0O1xuICAgIH1cbiAgICB0b0J5dGVzQmlnRW5kaWFuKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmRhdGEgLyAyICoqIDI0KSAmIDB4ZmYsXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogMTYpICYgMHhmZixcbiAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5kYXRhIC8gMiAqKiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogMCkgJiAweGZmLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgdG9CeXRlc0xpdHRsZUVuZGlhbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5kYXRhIC8gMiAqKiAwKSAmIDB4ZmYsXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogOCkgJiAweGZmLFxuICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmRhdGEgLyAyICoqIDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogMjQpICYgMHhmZixcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuVWludDMyID0gVWludDMyO1xuY2xhc3MgSW50NTMge1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICBpZiAoIXN0ci5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZyBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ1MyhOdW1iZXIucGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGEgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IGlucHV0ID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IG5vdCBpbiBpbnQ1MyByYW5nZTogXCIgKyBpbnB1dC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEgPSBpbnB1dDtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnQ1MyA9IEludDUzO1xuY2xhc3MgVWludDUzIHtcbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkID0gSW50NTMuZnJvbVN0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ1MyhzaWduZWQudG9OdW1iZXIoKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IG5ldyBJbnQ1MyhpbnB1dCk7XG4gICAgICAgIGlmIChzaWduZWQudG9OdW1iZXIoKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG5lZ2F0aXZlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IHNpZ25lZDtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLlVpbnQ1MyA9IFVpbnQ1MztcbmNsYXNzIFVpbnQ2NCB7XG4gICAgc3RhdGljIGZyb21CeXRlc0JpZ0VuZGlhbihieXRlcykge1xuICAgICAgICByZXR1cm4gVWludDY0LmZyb21CeXRlcyhieXRlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMsIGVuZGlhbmVzcyA9IFwiYmVcIikge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IGxlbmd0aC4gRXhwZWN0ZWQgOCBieXRlcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGJ5dGVzW2ldKSB8fCBieXRlc1tpXSA+IDI1NSB8fCBieXRlc1tpXSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGluIGJ5dGUuIEZvdW5kOiBcIiArIGJ5dGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiZUJ5dGVzID0gZW5kaWFuZXNzID09PSBcImJlXCIgPyBBcnJheS5mcm9tKGJ5dGVzKSA6IEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50NjQobmV3IGJuX2pzXzEuZGVmYXVsdChiZUJ5dGVzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICBpZiAoIXN0ci5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDY0KG5ldyBibl9qc18xLmRlZmF1bHQoc3RyLCAxMCwgXCJiZVwiKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBub3QgYSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGFuIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJpZ2ludDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJpZ2ludCA9IG5ldyBibl9qc18xLmRlZmF1bHQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBub3QgYSBzYWZlIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50NjQoYmlnaW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBuZWdhdGl2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5ndCh1aW50NjRNYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGV4Y2VlZHMgdWludDY0IHJhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHRvQnl0ZXNCaWdFbmRpYW4oKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20odGhpcy5kYXRhLnRvQXJyYXkoXCJiZVwiLCA4KSk7XG4gICAgfVxuICAgIHRvQnl0ZXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20odGhpcy5kYXRhLnRvQXJyYXkoXCJsZVwiLCA4KSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudG9OdW1iZXIoKTtcbiAgICB9XG59XG5leHBvcnRzLlVpbnQ2NCA9IFVpbnQ2NDtcbmNvbnN0IF9pbnQ1M0NsYXNzID0gSW50NTM7XG5jb25zdCBfdWludDUzQ2xhc3MgPSBVaW50NTM7XG5jb25zdCBfdWludDMyQ2xhc3MgPSBVaW50MzI7XG5jb25zdCBfdWludDY0Q2xhc3MgPSBVaW50NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlZ2Vycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/math/integers.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/ed25519.js':
    /*!*******************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/ed25519.js ***!
  \*******************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.fromSecret = exports.fromSeed = exports.privateKeyVerify = exports.publicKeyVerify = exports.publicKeyCreate = exports.verify = exports.sign = exports.ed25519MulBase = void 0;\nconst elliptic = __importStar(__webpack_require__(/*! ../elliptic */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/index.js"));\nconst base_1 = __webpack_require__(/*! ../base */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/index.js");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ "(ssr)/./node_modules/bn.js/lib/bn.js"));\nconst ed25519 = new elliptic.eddsa(\'ed25519\');\nconst curve = ed25519.curve;\nfunction ed25519MulBase(scalar) {\n    const G = ed25519.curve.g;\n    return ed25519.encodePoint(G.mul(elliptic.utils.intFromLE(scalar)));\n}\nexports.ed25519MulBase = ed25519MulBase;\nfunction sign(message, secretKey) {\n    let pk = secretKey;\n    if (pk.length == 64) {\n        pk = pk.slice(0, 32);\n    }\n    const key = ed25519.keyFromSecret(Array.from(pk));\n    const signature = key.sign(Array.from(message)).toBytes();\n    return Uint8Array.from(signature);\n}\nexports.sign = sign;\nfunction verify(message, signature, publicKey) {\n    const key = ed25519.keyFromPublic(Array.from(publicKey));\n    return key.verify(Array.from(message), Array.from(signature));\n}\nexports.verify = verify;\nfunction publicKeyCreate(secretKey) {\n    let pk = secretKey;\n    if (pk.length == 64) {\n        pk = pk.slice(0, 32);\n    }\n    const key = ed25519.keyFromSecret(Array.from(pk));\n    return Uint8Array.from(key.getPublic());\n}\nexports.publicKeyCreate = publicKeyCreate;\nfunction publicKeyVerify(pubkey) {\n    const point = ed25519.decodePoint(Array.from(pubkey));\n    return curve.validate(point);\n}\nexports.publicKeyVerify = publicKeyVerify;\nfunction privateKeyVerify(seckey) {\n    const bn = new bn_js_1.default(Array.from(seckey));\n    return bn.cmp(curve.n) < 0 && !bn.isZero();\n}\nexports.privateKeyVerify = privateKeyVerify;\nfunction fromSeed(seed) {\n    const key = ed25519.keyFromSecret(Array.from(seed));\n    const pk = Uint8Array.from(key.getPublic());\n    return { publicKey: pk, secretKey: (0, base_1.concatBytes)(seed, pk) };\n}\nexports.fromSeed = fromSeed;\nfunction fromSecret(secretKey) {\n    const privateKey = secretKey.slice(0, 32);\n    const key = ed25519.keyFromSecret(Array.from(privateKey));\n    return { publicKey: Uint8Array.from(key.getPublic()), secretKey: Uint8Array.from(privateKey) };\n}\nexports.fromSecret = fromSecret;\n//# sourceMappingURL=ed25519.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL2VkMjU1MTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxzQkFBc0I7QUFDN0ssOEJBQThCLG1CQUFPLENBQUMsb0ZBQWE7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLDRFQUFTO0FBQ2hDLGdDQUFnQyxtQkFBTyxDQUFDLG1EQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL2VkMjU1MTkuanM/NjNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tU2VjcmV0ID0gZXhwb3J0cy5mcm9tU2VlZCA9IGV4cG9ydHMucHJpdmF0ZUtleVZlcmlmeSA9IGV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gZXhwb3J0cy5wdWJsaWNLZXlDcmVhdGUgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnbiA9IGV4cG9ydHMuZWQyNTUxOU11bEJhc2UgPSB2b2lkIDA7XG5jb25zdCBlbGxpcHRpYyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vZWxsaXB0aWNcIikpO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCBlZDI1NTE5ID0gbmV3IGVsbGlwdGljLmVkZHNhKCdlZDI1NTE5Jyk7XG5jb25zdCBjdXJ2ZSA9IGVkMjU1MTkuY3VydmU7XG5mdW5jdGlvbiBlZDI1NTE5TXVsQmFzZShzY2FsYXIpIHtcbiAgICBjb25zdCBHID0gZWQyNTUxOS5jdXJ2ZS5nO1xuICAgIHJldHVybiBlZDI1NTE5LmVuY29kZVBvaW50KEcubXVsKGVsbGlwdGljLnV0aWxzLmludEZyb21MRShzY2FsYXIpKSk7XG59XG5leHBvcnRzLmVkMjU1MTlNdWxCYXNlID0gZWQyNTUxOU11bEJhc2U7XG5mdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHNlY3JldEtleSkge1xuICAgIGxldCBwayA9IHNlY3JldEtleTtcbiAgICBpZiAocGsubGVuZ3RoID09IDY0KSB7XG4gICAgICAgIHBrID0gcGsuc2xpY2UoMCwgMzIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBlZDI1NTE5LmtleUZyb21TZWNyZXQoQXJyYXkuZnJvbShwaykpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGtleS5zaWduKEFycmF5LmZyb20obWVzc2FnZSkpLnRvQnl0ZXMoKTtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSk7XG59XG5leHBvcnRzLnNpZ24gPSBzaWduO1xuZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3Qga2V5ID0gZWQyNTUxOS5rZXlGcm9tUHVibGljKEFycmF5LmZyb20ocHVibGljS2V5KSk7XG4gICAgcmV0dXJuIGtleS52ZXJpZnkoQXJyYXkuZnJvbShtZXNzYWdlKSwgQXJyYXkuZnJvbShzaWduYXR1cmUpKTtcbn1cbmV4cG9ydHMudmVyaWZ5ID0gdmVyaWZ5O1xuZnVuY3Rpb24gcHVibGljS2V5Q3JlYXRlKHNlY3JldEtleSkge1xuICAgIGxldCBwayA9IHNlY3JldEtleTtcbiAgICBpZiAocGsubGVuZ3RoID09IDY0KSB7XG4gICAgICAgIHBrID0gcGsuc2xpY2UoMCwgMzIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBlZDI1NTE5LmtleUZyb21TZWNyZXQoQXJyYXkuZnJvbShwaykpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oa2V5LmdldFB1YmxpYygpKTtcbn1cbmV4cG9ydHMucHVibGljS2V5Q3JlYXRlID0gcHVibGljS2V5Q3JlYXRlO1xuZnVuY3Rpb24gcHVibGljS2V5VmVyaWZ5KHB1YmtleSkge1xuICAgIGNvbnN0IHBvaW50ID0gZWQyNTUxOS5kZWNvZGVQb2ludChBcnJheS5mcm9tKHB1YmtleSkpO1xuICAgIHJldHVybiBjdXJ2ZS52YWxpZGF0ZShwb2ludCk7XG59XG5leHBvcnRzLnB1YmxpY0tleVZlcmlmeSA9IHB1YmxpY0tleVZlcmlmeTtcbmZ1bmN0aW9uIHByaXZhdGVLZXlWZXJpZnkoc2Vja2V5KSB7XG4gICAgY29uc3QgYm4gPSBuZXcgYm5fanNfMS5kZWZhdWx0KEFycmF5LmZyb20oc2Vja2V5KSk7XG4gICAgcmV0dXJuIGJuLmNtcChjdXJ2ZS5uKSA8IDAgJiYgIWJuLmlzWmVybygpO1xufVxuZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5ID0gcHJpdmF0ZUtleVZlcmlmeTtcbmZ1bmN0aW9uIGZyb21TZWVkKHNlZWQpIHtcbiAgICBjb25zdCBrZXkgPSBlZDI1NTE5LmtleUZyb21TZWNyZXQoQXJyYXkuZnJvbShzZWVkKSk7XG4gICAgY29uc3QgcGsgPSBVaW50OEFycmF5LmZyb20oa2V5LmdldFB1YmxpYygpKTtcbiAgICByZXR1cm4geyBwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6ICgwLCBiYXNlXzEuY29uY2F0Qnl0ZXMpKHNlZWQsIHBrKSB9O1xufVxuZXhwb3J0cy5mcm9tU2VlZCA9IGZyb21TZWVkO1xuZnVuY3Rpb24gZnJvbVNlY3JldChzZWNyZXRLZXkpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gc2VjcmV0S2V5LnNsaWNlKDAsIDMyKTtcbiAgICBjb25zdCBrZXkgPSBlZDI1NTE5LmtleUZyb21TZWNyZXQoQXJyYXkuZnJvbShwcml2YXRlS2V5KSk7XG4gICAgcmV0dXJuIHsgcHVibGljS2V5OiBVaW50OEFycmF5LmZyb20oa2V5LmdldFB1YmxpYygpKSwgc2VjcmV0S2V5OiBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkgfTtcbn1cbmV4cG9ydHMuZnJvbVNlY3JldCA9IGZyb21TZWNyZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZDI1NTE5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/ed25519.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/index.js':
    /*!*****************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/index.js ***!
  \*****************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.schnorr = exports.p256 = exports.ed25519 = exports.secp256k1 = void 0;\nexports.secp256k1 = __importStar(__webpack_require__(/*! ./secp256k1 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/secp256k1.js"));\nexports.ed25519 = __importStar(__webpack_require__(/*! ./ed25519 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/ed25519.js"));\nexports.p256 = __importStar(__webpack_require__(/*! ./p256 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/p256.js"));\nexports.schnorr = __importStar(__webpack_require__(/*! ./schnorr */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/index.js"));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRyxpQkFBaUI7QUFDcEUsaUJBQWlCLGdCQUFnQixtQkFBTyxDQUFDLHdGQUFhO0FBQ3RELGVBQWUsZ0JBQWdCLG1CQUFPLENBQUMsb0ZBQVc7QUFDbEQsWUFBWSxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUTtBQUM1QyxlQUFlLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFXO0FBQ2xEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL2luZGV4LmpzP2RjZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2Nobm9yciA9IGV4cG9ydHMucDI1NiA9IGV4cG9ydHMuZWQyNTUxOSA9IGV4cG9ydHMuc2VjcDI1NmsxID0gdm9pZCAwO1xuZXhwb3J0cy5zZWNwMjU2azEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2VjcDI1NmsxXCIpKTtcbmV4cG9ydHMuZWQyNTUxOSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9lZDI1NTE5XCIpKTtcbmV4cG9ydHMucDI1NiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9wMjU2XCIpKTtcbmV4cG9ydHMuc2Nobm9yciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hub3JyXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/p256.js':
    /*!****************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/p256.js ***!
  \****************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.loadUncompressedPublicKey = exports.loadCompressedPublicKey = exports.publicKeyConvert = exports.publicKeyCreate = exports.publicKeyVerify = exports.privateKeyVerify = exports.loadPublicKey = exports.recover = exports.verify = exports.sign = void 0;\nconst elliptic = __importStar(__webpack_require__(/*! ../elliptic */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/index.js"));\nconst ec = new elliptic.ec(\'p256\');\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ "(ssr)/./node_modules/bn.js/lib/bn.js"));\nfunction sign(message, seckey, canonical = true) {\n    const sig = ec.sign(Array.from(message), Buffer.from(seckey), { canonical: canonical });\n    return { signature: sig.toBytes(), recovery: sig.recoveryParam };\n}\nexports.sign = sign;\nfunction verify(message, signature, recovery, publicKey) {\n    const r = recover(signature, recovery, message, false);\n    if (r == null) {\n        return false;\n    }\n    return r.equals(publicKey);\n}\nexports.verify = verify;\nfunction recover(sig, recid, msg32, compress) {\n    const sigObj = { r: Array.from(sig.slice(0, 32)), s: Array.from(sig.slice(32, 64)) };\n    const sigr = new bn_js_1.default(sigObj.r);\n    const sigs = new bn_js_1.default(sigObj.s);\n    if (sigr.cmp(ec.curve.n) >= 0 || sigs.cmp(ec.curve.n) >= 0)\n        return null;\n    if (sigr.isZero() || sigs.isZero())\n        return null;\n    let point;\n    try {\n        point = ec.recoverPubKey(Array.from(msg32), sigObj, recid, null);\n    }\n    catch (err) {\n        return null;\n    }\n    return Buffer.from(point.encode(null, compress));\n}\nexports.recover = recover;\nfunction loadPublicKey(pubKey) {\n    const pk = Buffer.from(pubKey);\n    const first = pk[0];\n    switch (first) {\n        case 0x02:\n        case 0x03:\n            if (pk.length !== 33)\n                return null;\n            return loadCompressedPublicKey(first, pk.subarray(1, 33));\n        case 0x04:\n        case 0x06:\n        case 0x07:\n            if (pk.length !== 65)\n                return null;\n            return loadUncompressedPublicKey(first, pk.subarray(1, 33), pk.subarray(33, 65));\n        default:\n            return null;\n    }\n}\nexports.loadPublicKey = loadPublicKey;\nfunction privateKeyVerify(seckey) {\n    const bn = new bn_js_1.default(Array.from(seckey));\n    return bn.cmp(ec.curve.n) < 0 && !bn.isZero();\n}\nexports.privateKeyVerify = privateKeyVerify;\nfunction publicKeyVerify(pubkey) {\n    const pair = loadPublicKey(pubkey);\n    return pair !== null;\n}\nexports.publicKeyVerify = publicKeyVerify;\nfunction publicKeyCreate(seckey, compress) {\n    const point = ec.keyFromPrivate(Array.from(seckey), "bytes").getPublic();\n    return Buffer.from(point.encode(null, compress));\n}\nexports.publicKeyCreate = publicKeyCreate;\nfunction publicKeyConvert(pubkey, compress) {\n    const p = loadPublicKey(pubkey);\n    if (p == null) {\n        return null;\n    }\n    const point = ec.keyPair({ pub: { x: p.x, y: p.y } }).getPublic();\n    return Buffer.from(point.encode(null, compress));\n}\nexports.publicKeyConvert = publicKeyConvert;\nfunction loadCompressedPublicKey(first, xbuf) {\n    let x = new bn_js_1.default(Array.from(xbuf));\n    if (x.cmp(ec.curve.p) >= 0)\n        return null;\n    const xx = x.toRed(ec.curve.red);\n    let y = xx.redSqr().redIMul(xx).redIAdd(ec.curve.b).redSqrt();\n    if ((first === 0x03) !== y.isOdd())\n        y = y.redNeg();\n    return { x: xx, y: y };\n}\nexports.loadCompressedPublicKey = loadCompressedPublicKey;\nfunction loadUncompressedPublicKey(first, xbuf, ybuf) {\n    let x = new bn_js_1.default(Array.from(xbuf));\n    let y = new bn_js_1.default(Array.from(ybuf));\n    if (x.cmp(ec.curve.p) >= 0 || y.cmp(ec.curve.p) >= 0)\n        return null;\n    const xx = x.toRed(ec.curve.red);\n    const yy = y.toRed(ec.curve.red);\n    if ((first === 0x06 || first === 0x07) && yy.isOdd() !== (first === 0x07))\n        return null;\n    const x3 = xx.redSqr().redIMul(xx);\n    if (!yy.redSqr().redISub(x3.redIAdd(ec.curve.b)).isZero())\n        return null;\n    return { x: xx, y: yy };\n}\nexports.loadUncompressedPublicKey = loadUncompressedPublicKey;\n//# sourceMappingURL=p256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3AyNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsK0JBQStCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxZQUFZO0FBQ3ZQLDhCQUE4QixtQkFBTyxDQUFDLG9GQUFhO0FBQ25EO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsbURBQU87QUFDL0M7QUFDQSxvRUFBb0Usc0JBQXNCO0FBQzFGLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3AyNTYuanM/NjY0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2FkVW5jb21wcmVzc2VkUHVibGljS2V5ID0gZXhwb3J0cy5sb2FkQ29tcHJlc3NlZFB1YmxpY0tleSA9IGV4cG9ydHMucHVibGljS2V5Q29udmVydCA9IGV4cG9ydHMucHVibGljS2V5Q3JlYXRlID0gZXhwb3J0cy5wdWJsaWNLZXlWZXJpZnkgPSBleHBvcnRzLnByaXZhdGVLZXlWZXJpZnkgPSBleHBvcnRzLmxvYWRQdWJsaWNLZXkgPSBleHBvcnRzLnJlY292ZXIgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnbiA9IHZvaWQgMDtcbmNvbnN0IGVsbGlwdGljID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9lbGxpcHRpY1wiKSk7XG5jb25zdCBlYyA9IG5ldyBlbGxpcHRpYy5lYygncDI1NicpO1xuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBzZWNrZXksIGNhbm9uaWNhbCA9IHRydWUpIHtcbiAgICBjb25zdCBzaWcgPSBlYy5zaWduKEFycmF5LmZyb20obWVzc2FnZSksIEJ1ZmZlci5mcm9tKHNlY2tleSksIHsgY2Fub25pY2FsOiBjYW5vbmljYWwgfSk7XG4gICAgcmV0dXJuIHsgc2lnbmF0dXJlOiBzaWcudG9CeXRlcygpLCByZWNvdmVyeTogc2lnLnJlY292ZXJ5UGFyYW0gfTtcbn1cbmV4cG9ydHMuc2lnbiA9IHNpZ247XG5mdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNvdmVyeSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgciA9IHJlY292ZXIoc2lnbmF0dXJlLCByZWNvdmVyeSwgbWVzc2FnZSwgZmFsc2UpO1xuICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gci5lcXVhbHMocHVibGljS2V5KTtcbn1cbmV4cG9ydHMudmVyaWZ5ID0gdmVyaWZ5O1xuZnVuY3Rpb24gcmVjb3ZlcihzaWcsIHJlY2lkLCBtc2czMiwgY29tcHJlc3MpIHtcbiAgICBjb25zdCBzaWdPYmogPSB7IHI6IEFycmF5LmZyb20oc2lnLnNsaWNlKDAsIDMyKSksIHM6IEFycmF5LmZyb20oc2lnLnNsaWNlKDMyLCA2NCkpIH07XG4gICAgY29uc3Qgc2lnciA9IG5ldyBibl9qc18xLmRlZmF1bHQoc2lnT2JqLnIpO1xuICAgIGNvbnN0IHNpZ3MgPSBuZXcgYm5fanNfMS5kZWZhdWx0KHNpZ09iai5zKTtcbiAgICBpZiAoc2lnci5jbXAoZWMuY3VydmUubikgPj0gMCB8fCBzaWdzLmNtcChlYy5jdXJ2ZS5uKSA+PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcG9pbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcG9pbnQgPSBlYy5yZWNvdmVyUHViS2V5KEFycmF5LmZyb20obXNnMzIpLCBzaWdPYmosIHJlY2lkLCBudWxsKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvaW50LmVuY29kZShudWxsLCBjb21wcmVzcykpO1xufVxuZXhwb3J0cy5yZWNvdmVyID0gcmVjb3ZlcjtcbmZ1bmN0aW9uIGxvYWRQdWJsaWNLZXkocHViS2V5KSB7XG4gICAgY29uc3QgcGsgPSBCdWZmZXIuZnJvbShwdWJLZXkpO1xuICAgIGNvbnN0IGZpcnN0ID0gcGtbMF07XG4gICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIDB4MDI6XG4gICAgICAgIGNhc2UgMHgwMzpcbiAgICAgICAgICAgIGlmIChway5sZW5ndGggIT09IDMzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRDb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBway5zdWJhcnJheSgxLCAzMykpO1xuICAgICAgICBjYXNlIDB4MDQ6XG4gICAgICAgIGNhc2UgMHgwNjpcbiAgICAgICAgY2FzZSAweDA3OlxuICAgICAgICAgICAgaWYgKHBrLmxlbmd0aCAhPT0gNjUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcGsuc3ViYXJyYXkoMSwgMzMpLCBway5zdWJhcnJheSgzMywgNjUpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMubG9hZFB1YmxpY0tleSA9IGxvYWRQdWJsaWNLZXk7XG5mdW5jdGlvbiBwcml2YXRlS2V5VmVyaWZ5KHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IGJuX2pzXzEuZGVmYXVsdChBcnJheS5mcm9tKHNlY2tleSkpO1xuICAgIHJldHVybiBibi5jbXAoZWMuY3VydmUubikgPCAwICYmICFibi5pc1plcm8oKTtcbn1cbmV4cG9ydHMucHJpdmF0ZUtleVZlcmlmeSA9IHByaXZhdGVLZXlWZXJpZnk7XG5mdW5jdGlvbiBwdWJsaWNLZXlWZXJpZnkocHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KTtcbiAgICByZXR1cm4gcGFpciAhPT0gbnVsbDtcbn1cbmV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gcHVibGljS2V5VmVyaWZ5O1xuZnVuY3Rpb24gcHVibGljS2V5Q3JlYXRlKHNlY2tleSwgY29tcHJlc3MpIHtcbiAgICBjb25zdCBwb2ludCA9IGVjLmtleUZyb21Qcml2YXRlKEFycmF5LmZyb20oc2Vja2V5KSwgXCJieXRlc1wiKS5nZXRQdWJsaWMoKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKG51bGwsIGNvbXByZXNzKSk7XG59XG5leHBvcnRzLnB1YmxpY0tleUNyZWF0ZSA9IHB1YmxpY0tleUNyZWF0ZTtcbmZ1bmN0aW9uIHB1YmxpY0tleUNvbnZlcnQocHVia2V5LCBjb21wcmVzcykge1xuICAgIGNvbnN0IHAgPSBsb2FkUHVibGljS2V5KHB1YmtleSk7XG4gICAgaWYgKHAgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcG9pbnQgPSBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHAueCwgeTogcC55IH0gfSkuZ2V0UHVibGljKCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvaW50LmVuY29kZShudWxsLCBjb21wcmVzcykpO1xufVxuZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gcHVibGljS2V5Q29udmVydDtcbmZ1bmN0aW9uIGxvYWRDb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCB4YnVmKSB7XG4gICAgbGV0IHggPSBuZXcgYm5fanNfMS5kZWZhdWx0KEFycmF5LmZyb20oeGJ1ZikpO1xuICAgIGlmICh4LmNtcChlYy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB4eCA9IHgudG9SZWQoZWMuY3VydmUucmVkKTtcbiAgICBsZXQgeSA9IHh4LnJlZFNxcigpLnJlZElNdWwoeHgpLnJlZElBZGQoZWMuY3VydmUuYikucmVkU3FydCgpO1xuICAgIGlmICgoZmlyc3QgPT09IDB4MDMpICE9PSB5LmlzT2RkKCkpXG4gICAgICAgIHkgPSB5LnJlZE5lZygpO1xuICAgIHJldHVybiB7IHg6IHh4LCB5OiB5IH07XG59XG5leHBvcnRzLmxvYWRDb21wcmVzc2VkUHVibGljS2V5ID0gbG9hZENvbXByZXNzZWRQdWJsaWNLZXk7XG5mdW5jdGlvbiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCB4YnVmLCB5YnVmKSB7XG4gICAgbGV0IHggPSBuZXcgYm5fanNfMS5kZWZhdWx0KEFycmF5LmZyb20oeGJ1ZikpO1xuICAgIGxldCB5ID0gbmV3IGJuX2pzXzEuZGVmYXVsdChBcnJheS5mcm9tKHlidWYpKTtcbiAgICBpZiAoeC5jbXAoZWMuY3VydmUucCkgPj0gMCB8fCB5LmNtcChlYy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB4eCA9IHgudG9SZWQoZWMuY3VydmUucmVkKTtcbiAgICBjb25zdCB5eSA9IHkudG9SZWQoZWMuY3VydmUucmVkKTtcbiAgICBpZiAoKGZpcnN0ID09PSAweDA2IHx8IGZpcnN0ID09PSAweDA3KSAmJiB5eS5pc09kZCgpICE9PSAoZmlyc3QgPT09IDB4MDcpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB4MyA9IHh4LnJlZFNxcigpLnJlZElNdWwoeHgpO1xuICAgIGlmICgheXkucmVkU3FyKCkucmVkSVN1Yih4My5yZWRJQWRkKGVjLmN1cnZlLmIpKS5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHsgeDogeHgsIHk6IHl5IH07XG59XG5leHBvcnRzLmxvYWRVbmNvbXByZXNzZWRQdWJsaWNLZXkgPSBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cDI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/p256.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/_shortw_utils.js':
    /*!*********************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/_shortw_utils.js ***!
  \*********************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.createCurve = exports.getHash = void 0;\nconst hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/hmac.js");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js");\nconst weierstrass_1 = __webpack_require__(/*! ./abstract/weierstrass */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/weierstrass.js");\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes,\n    };\n}\nexports.getHash = getHash;\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0, weierstrass_1.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\nexports.createCurve = createCurve;\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxlQUFlO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMseUdBQXFCO0FBQzdDLHNCQUFzQixtQkFBTyxDQUFDLHNIQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDhEQUE4RCwrQkFBK0I7QUFDN0YsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9zaWdudXRpbC9zY2hub3JyL19zaG9ydHdfdXRpbHMuanM/ZTgxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQ3VydmUgPSBleHBvcnRzLmdldEhhc2ggPSB2b2lkIDA7XG5jb25zdCBobWFjXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9obWFjXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3Qgd2VpZXJzdHJhc3NfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzXCIpO1xuZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gKDAsIGhtYWNfMS5obWFjKShoYXNoLCBrZXksICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKSguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzOiB1dGlsc18xLnJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnRzLmdldEhhc2ggPSBnZXRIYXNoO1xuZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gKDAsIHdlaWVyc3RyYXNzXzEud2VpZXJzdHJhc3MpKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQ3VydmUgPSBjcmVhdGVDdXJ2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/_shortw_utils.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/curve.js':
    /*!**********************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/curve.js ***!
  \**********************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateBasic = exports.wNAF = void 0;\nconst modular_1 = __webpack_require__(/*! ./modular */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/modular.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1;\n        const windowSize = 2 ** (W - 1);\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        wNAF(W, precomputes, n) {\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1);\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                let wbits = Number(n & mask);\n                n >>= shiftBy;\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1;\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            const W = P._WINDOW_SIZE || 1;\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n    (0, modular_1.validateField)(curve.Fp);\n    (0, utils_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    return Object.freeze({\n        ...(0, modular_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nexports.validateBasic = validateBasic;\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxZQUFZO0FBQ3BDLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFXO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLGlHQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvY3VydmUuanM/NjRmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVCYXNpYyA9IGV4cG9ydHMud05BRiA9IHZvaWQgMDtcbmNvbnN0IG1vZHVsYXJfMSA9IHJlcXVpcmUoXCIuL21vZHVsYXJcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5mdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTtcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTtcbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLndOQUYgPSB3TkFGO1xuZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgICgwLCBtb2R1bGFyXzEudmFsaWRhdGVGaWVsZCkoY3VydmUuRnApO1xuICAgICgwLCB1dGlsc18xLnZhbGlkYXRlT2JqZWN0KShjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLigwLCBtb2R1bGFyXzEubkxlbmd0aCkoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSB2YWxpZGF0ZUJhc2ljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/curve.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/hash-to-curve.js':
    /*!******************************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/hash-to-curve.js ***!
  \******************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;\nconst modular_1 = __webpack_require__(/*! ./modular */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/modular.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js\");\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0, utils_1.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\nconst os2ip = utils_1.bytesToNumberBE;\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    if (DST.length > 255)\n        DST = H((0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0, utils_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2);\n    const b = new Array(ell);\n    const b_0 = H((0, utils_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nexports.expand_message_xmd = expand_message_xmd;\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\nexports.expand_message_xof = expand_message_xof;\nfunction hash_to_field(msg, count, options) {\n    (0, utils_1.validateObject)(options, {\n        DST: 'string',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8);\n    const len_in_bytes = count * m * L;\n    let prb;\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexports.hash_to_field = hash_to_field;\nfunction isogenyMap(field, map) {\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen);\n        y = field.mul(y, field.div(yNum, yDen));\n        return { x, y };\n    };\n}\nexports.isogenyMap = isogenyMap;\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\nexports.createHasher = createHasher;\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRywwQkFBMEIsR0FBRywwQkFBMEI7QUFDM0gsa0JBQWtCLG1CQUFPLENBQUMscUdBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsaUdBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTyxTQUFTLE9BQU87QUFDeEU7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQyw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz82NDhkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVIYXNoZXIgPSBleHBvcnRzLmlzb2dlbnlNYXAgPSBleHBvcnRzLmhhc2hfdG9fZmllbGQgPSBleHBvcnRzLmV4cGFuZF9tZXNzYWdlX3hvZiA9IGV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG1kID0gdm9pZCAwO1xuY29uc3QgbW9kdWxhcl8xID0gcmVxdWlyZShcIi4vbW9kdWxhclwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlRFNUKGRzdCkge1xuICAgIGlmIChkc3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIGlmICh0eXBlb2YgZHN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnV0ZjhUb0J5dGVzKShkc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbn1cbmNvbnN0IG9zMmlwID0gdXRpbHNfMS5ieXRlc1RvTnVtYmVyQkU7XG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhpdGVtKSB7XG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGlzTnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSCgoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoKDAsIHV0aWxzXzEudXRmOFRvQnl0ZXMpKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpO1xuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKCgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSCgoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKSguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbmV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG1kID0gZXhwYW5kX21lc3NhZ2VfeG1kO1xuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKCgwLCB1dGlsc18xLnV0ZjhUb0J5dGVzKSgnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3hvZiA9IGV4cGFuZF9tZXNzYWdlX3hvZjtcbmZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgICgwLCB1dGlsc18xLnZhbGlkYXRlT2JqZWN0KShvcHRpb25zLCB7XG4gICAgICAgIERTVDogJ3N0cmluZycsXG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGs6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcCwgaywgbSwgaGFzaCwgZXhwYW5kLCBEU1Q6IF9EU1QgfSA9IG9wdGlvbnM7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzTnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB2YWxpZGF0ZURTVChfRFNUKTtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTtcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7XG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSAoMCwgbW9kdWxhcl8xLm1vZCkob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnRzLmhhc2hfdG9fZmllbGQgPSBoYXNoX3RvX2ZpZWxkO1xuZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTtcbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpO1xuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydHMuaXNvZ2VueU1hcCA9IGlzb2dlbnlNYXA7XG5mdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUhhc2hlciA9IGNyZWF0ZUhhc2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/hash-to-curve.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/modular.js':
    /*!************************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/modular.js ***!
  \************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js\");\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\nconst _9n = BigInt(9), _16n = BigInt(16);\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nexports.mod = mod;\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\nexports.pow = pow;\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\nexports.pow2 = pow2;\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nexports.invert = invert;\nfunction tonelliShanks(P) {\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);\n        let x = Fp.pow(n, Q1div2);\n        let b = Fp.pow(n, Q);\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO;\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2);\n            }\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1));\n            g = Fp.sqr(ge);\n            x = Fp.mul(x, ge);\n            b = Fp.mul(b, g);\n            r = m;\n        }\n        return x;\n    };\n}\nexports.tonelliShanks = tonelliShanks;\nfunction FpSqrt(P) {\n    if (P % _4n === _3n) {\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    if (P % _16n === _9n) {\n    }\n    return tonelliShanks(P);\n}\nexports.FpSqrt = FpSqrt;\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, utils_1.validateObject)(field, opts);\n}\nexports.validateField = validateField;\nfunction FpPow(f, num, power) {\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\nexports.FpPow = FpPow;\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    const inverted = f.inv(lastMultiplied);\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexports.FpInvertBatch = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nexports.FpDiv = FpDiv;\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n;\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\nexports.FpIsSquare = FpIsSquare;\nfunction nLength(n, nBitLength) {\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\nexports.nLength = nLength;\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0, utils_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER;\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0, utils_1.numberToBytesLE)(num, BYTES) : (0, utils_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0, utils_1.bytesToNumberLE)(bytes) : (0, utils_1.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexports.Field = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexports.FpSqrtOdd = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\nexports.FpSqrtEven = FpSqrtEven;\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0, utils_1.bytesToNumberLE)(hash) : (0, utils_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\nexports.hashToPrivateScalar = hashToPrivateScalar;\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLGFBQWEsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsYUFBYSxHQUFHLHFCQUFxQixHQUFHLGFBQWEsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcscUJBQXFCLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxXQUFXLEdBQUcsV0FBVztBQUN2VSxnQkFBZ0IsbUJBQU8sQ0FBQyxpR0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLHFFQUFxRSxRQUFRLE1BQU0sT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxlQUFlO0FBQ2Ysc0RBQXNEO0FBQ3REO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsV0FBVztBQUMxRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsTUFBTSxRQUFRLGFBQWE7QUFDckY7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU8sNEJBQTRCLFFBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvbW9kdWxhci5qcz81ZTZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoVG9Qcml2YXRlU2NhbGFyID0gZXhwb3J0cy5GcFNxcnRFdmVuID0gZXhwb3J0cy5GcFNxcnRPZGQgPSBleHBvcnRzLkZpZWxkID0gZXhwb3J0cy5uTGVuZ3RoID0gZXhwb3J0cy5GcElzU3F1YXJlID0gZXhwb3J0cy5GcERpdiA9IGV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IGV4cG9ydHMuRnBQb3cgPSBleHBvcnRzLnZhbGlkYXRlRmllbGQgPSBleHBvcnRzLmlzTmVnYXRpdmVMRSA9IGV4cG9ydHMuRnBTcXJ0ID0gZXhwb3J0cy50b25lbGxpU2hhbmtzID0gZXhwb3J0cy5pbnZlcnQgPSBleHBvcnRzLnBvdzIgPSBleHBvcnRzLnBvdyA9IGV4cG9ydHMubW9kID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG5mdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbmV4cG9ydHMubW9kID0gbW9kO1xuZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5wb3cgPSBwb3c7XG5mdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5wb3cyID0gcG93MjtcbmZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5leHBvcnRzLmludmVydCA9IGludmVydDtcbmZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7XG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpO1xuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPO1xuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpO1xuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7XG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTtcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7XG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0cy50b25lbGxpU2hhbmtzID0gdG9uZWxsaVNoYW5rcztcbmZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgfVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuZXhwb3J0cy5GcFNxcnQgPSBGcFNxcnQ7XG5jb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuZXhwb3J0cy5pc05lZ2F0aXZlTEUgPSBpc05lZ2F0aXZlTEU7XG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS52YWxpZGF0ZU9iamVjdCkoZmllbGQsIG9wdHMpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUZpZWxkID0gdmFsaWRhdGVGaWVsZDtcbmZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5leHBvcnRzLkZwUG93ID0gRnBQb3c7XG5mdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IEZwSW52ZXJ0QmF0Y2g7XG5mdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbmV4cG9ydHMuRnBEaXYgPSBGcERpdjtcbmZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47XG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG5leHBvcnRzLkZwSXNTcXVhcmUgPSBGcElzU3F1YXJlO1xuZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbmV4cG9ydHMubkxlbmd0aCA9IG5MZW5ndGg7XG5mdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZwIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogKDAsIHV0aWxzXzEuYml0TWFzaykoQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSO1xuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/ICgwLCB1dGlsc18xLm51bWJlclRvQnl0ZXNMRSkobnVtLCBCWVRFUykgOiAoMCwgdXRpbHNfMS5udW1iZXJUb0J5dGVzQkUpKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyAoMCwgdXRpbHNfMS5ieXRlc1RvTnVtYmVyTEUpKGJ5dGVzKSA6ICgwLCB1dGlsc18xLmJ5dGVzVG9OdW1iZXJCRSkoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0cy5GaWVsZCA9IEZpZWxkO1xuZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydHMuRnBTcXJ0T2RkID0gRnBTcXJ0T2RkO1xuZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG5leHBvcnRzLkZwU3FydEV2ZW4gPSBGcFNxcnRFdmVuO1xuZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gKDAsIHV0aWxzXzEuZW5zdXJlQnl0ZXMpKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gKDAsIHV0aWxzXzEuYnl0ZXNUb051bWJlckxFKShoYXNoKSA6ICgwLCB1dGlsc18xLmJ5dGVzVG9OdW1iZXJCRSkoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuZXhwb3J0cy5oYXNoVG9Qcml2YXRlU2NhbGFyID0gaGFzaFRvUHJpdmF0ZVNjYWxhcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/modular.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/poseidon.js':
    /*!*************************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/poseidon.js ***!
  \*************************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.poseidon = exports.splitConstants = exports.validateOpts = void 0;\nconst modular_1 = __webpack_require__(/*! ./modular */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/modular.js\");\nfunction validateOpts(opts) {\n    const { Fp } = opts;\n    (0, modular_1.validateField)(Fp);\n    for (const i of ['t', 'roundsFull', 'roundsPartial']) {\n        if (typeof opts[i] !== 'number' || !Number.isSafeInteger(opts[i]))\n            throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);\n    }\n    if (opts.reversePartialPowIdx !== undefined && typeof opts.reversePartialPowIdx !== 'boolean')\n        throw new Error(`Poseidon: invalid param reversePartialPowIdx=${opts.reversePartialPowIdx}`);\n    let sboxPower = opts.sboxPower;\n    if (sboxPower === undefined)\n        sboxPower = 5;\n    if (typeof sboxPower !== 'number' || !Number.isSafeInteger(sboxPower))\n        throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);\n    const _sboxPower = BigInt(sboxPower);\n    let sboxFn = (n) => (0, modular_1.FpPow)(Fp, n, _sboxPower);\n    if (sboxPower === 3)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);\n    else if (sboxPower === 5)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);\n    if (opts.roundsFull % 2 !== 0)\n        throw new Error(`Poseidon roundsFull is not even: ${opts.roundsFull}`);\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    if (!Array.isArray(opts.roundConstants) || opts.roundConstants.length !== rounds)\n        throw new Error('Poseidon: wrong round constants');\n    const roundConstants = opts.roundConstants.map((rc) => {\n        if (!Array.isArray(rc) || rc.length !== opts.t)\n            throw new Error(`Poseidon wrong round constants: ${rc}`);\n        return rc.map((i) => {\n            if (typeof i !== 'bigint' || !Fp.isValid(i))\n                throw new Error(`Poseidon wrong round constant=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (!Array.isArray(opts.mds) || opts.mds.length !== opts.t)\n        throw new Error('Poseidon: wrong MDS matrix');\n    const mds = opts.mds.map((mdsRow) => {\n        if (!Array.isArray(mdsRow) || mdsRow.length !== opts.t)\n            throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);\n        return mdsRow.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon MDS matrix value=${i}`);\n            return Fp.create(i);\n        });\n    });\n    return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds });\n}\nexports.validateOpts = validateOpts;\nfunction splitConstants(rc, t) {\n    if (typeof t !== 'number')\n        throw new Error('poseidonSplitConstants: wrong t');\n    if (!Array.isArray(rc) || rc.length % t)\n        throw new Error('poseidonSplitConstants: wrong rc');\n    const res = [];\n    let tmp = [];\n    for (let i = 0; i < rc.length; i++) {\n        tmp.push(rc[i]);\n        if (tmp.length === t) {\n            res.push(tmp);\n            tmp = [];\n        }\n    }\n    return res;\n}\nexports.splitConstants = splitConstants;\nfunction poseidon(opts) {\n    const { t, Fp, rounds, sboxFn, reversePartialPowIdx } = validateOpts(opts);\n    const halfRoundsFull = Math.floor(opts.roundsFull / 2);\n    const partialIdx = reversePartialPowIdx ? t - 1 : 0;\n    const poseidonRound = (values, isFull, idx) => {\n        values = values.map((i, j) => Fp.add(i, opts.roundConstants[idx][j]));\n        if (isFull)\n            values = values.map((i) => sboxFn(i));\n        else\n            values[partialIdx] = sboxFn(values[partialIdx]);\n        values = opts.mds.map((i) => i.reduce((acc, i, j) => Fp.add(acc, Fp.mulN(i, values[j])), Fp.ZERO));\n        return values;\n    };\n    const poseidonHash = function poseidonHash(values) {\n        if (!Array.isArray(values) || values.length !== t)\n            throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);\n        values = values.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);\n            return Fp.create(i);\n        });\n        let round = 0;\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        for (let i = 0; i < opts.roundsPartial; i++)\n            values = poseidonRound(values, false, round++);\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        if (round !== rounds)\n            throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);\n        return values;\n    };\n    poseidonHash.roundConstants = opts.roundConstants;\n    return poseidonHash;\n}\nexports.poseidon = poseidon;\n//# sourceMappingURL=poseidon.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvcG9zZWlkb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxzQkFBc0IsR0FBRyxvQkFBb0I7QUFDaEUsa0JBQWtCLG1CQUFPLENBQUMscUdBQVc7QUFDckM7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEVBQUUsR0FBRyxTQUFTLEdBQUcsZUFBZTtBQUN2RjtBQUNBO0FBQ0Esd0VBQXdFLDBCQUEwQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEdBQUc7QUFDbEU7QUFDQTtBQUNBLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQSw2REFBNkQsRUFBRTtBQUMvRDtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsMkJBQTJCLDhDQUE4QztBQUN6RTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixFQUFFO0FBQy9GO0FBQ0E7QUFDQSx5REFBeUQsR0FBRyxHQUFHLFNBQVM7QUFDeEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLDRFQUE0RSxNQUFNLFVBQVUsT0FBTztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvcG9zZWlkb24uanM/Zjg5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucG9zZWlkb24gPSBleHBvcnRzLnNwbGl0Q29uc3RhbnRzID0gZXhwb3J0cy52YWxpZGF0ZU9wdHMgPSB2b2lkIDA7XG5jb25zdCBtb2R1bGFyXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKG9wdHMpIHtcbiAgICBjb25zdCB7IEZwIH0gPSBvcHRzO1xuICAgICgwLCBtb2R1bGFyXzEudmFsaWRhdGVGaWVsZCkoRnApO1xuICAgIGZvciAoY29uc3QgaSBvZiBbJ3QnLCAncm91bmRzRnVsbCcsICdyb3VuZHNQYXJ0aWFsJ10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzW2ldICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIob3B0c1tpXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiBpbnZhbGlkIHBhcmFtICR7aX09JHtvcHRzW2ldfSAoJHt0eXBlb2Ygb3B0c1tpXX0pYCk7XG4gICAgfVxuICAgIGlmIChvcHRzLnJldmVyc2VQYXJ0aWFsUG93SWR4ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdHMucmV2ZXJzZVBhcnRpYWxQb3dJZHggIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogaW52YWxpZCBwYXJhbSByZXZlcnNlUGFydGlhbFBvd0lkeD0ke29wdHMucmV2ZXJzZVBhcnRpYWxQb3dJZHh9YCk7XG4gICAgbGV0IHNib3hQb3dlciA9IG9wdHMuc2JveFBvd2VyO1xuICAgIGlmIChzYm94UG93ZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2JveFBvd2VyID0gNTtcbiAgICBpZiAodHlwZW9mIHNib3hQb3dlciAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKHNib3hQb3dlcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gd3Jvbmcgc2JveFBvd2VyPSR7c2JveFBvd2VyfWApO1xuICAgIGNvbnN0IF9zYm94UG93ZXIgPSBCaWdJbnQoc2JveFBvd2VyKTtcbiAgICBsZXQgc2JveEZuID0gKG4pID0+ICgwLCBtb2R1bGFyXzEuRnBQb3cpKEZwLCBuLCBfc2JveFBvd2VyKTtcbiAgICBpZiAoc2JveFBvd2VyID09PSAzKVxuICAgICAgICBzYm94Rm4gPSAobikgPT4gRnAubXVsKEZwLnNxck4obiksIG4pO1xuICAgIGVsc2UgaWYgKHNib3hQb3dlciA9PT0gNSlcbiAgICAgICAgc2JveEZuID0gKG4pID0+IEZwLm11bChGcC5zcXJOKEZwLnNxck4obikpLCBuKTtcbiAgICBpZiAob3B0cy5yb3VuZHNGdWxsICUgMiAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiByb3VuZHNGdWxsIGlzIG5vdCBldmVuOiAke29wdHMucm91bmRzRnVsbH1gKTtcbiAgICBjb25zdCByb3VuZHMgPSBvcHRzLnJvdW5kc0Z1bGwgKyBvcHRzLnJvdW5kc1BhcnRpYWw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdHMucm91bmRDb25zdGFudHMpIHx8IG9wdHMucm91bmRDb25zdGFudHMubGVuZ3RoICE9PSByb3VuZHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zZWlkb246IHdyb25nIHJvdW5kIGNvbnN0YW50cycpO1xuICAgIGNvbnN0IHJvdW5kQ29uc3RhbnRzID0gb3B0cy5yb3VuZENvbnN0YW50cy5tYXAoKHJjKSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyYykgfHwgcmMubGVuZ3RoICE9PSBvcHRzLnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHdyb25nIHJvdW5kIGNvbnN0YW50czogJHtyY31gKTtcbiAgICAgICAgcmV0dXJuIHJjLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JyB8fCAhRnAuaXNWYWxpZChpKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHdyb25nIHJvdW5kIGNvbnN0YW50PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBGcC5jcmVhdGUoaSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRzLm1kcykgfHwgb3B0cy5tZHMubGVuZ3RoICE9PSBvcHRzLnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zZWlkb246IHdyb25nIE1EUyBtYXRyaXgnKTtcbiAgICBjb25zdCBtZHMgPSBvcHRzLm1kcy5tYXAoKG1kc1JvdykgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWRzUm93KSB8fCBtZHNSb3cubGVuZ3RoICE9PSBvcHRzLnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIE1EUyBtYXRyaXggcm93OiAke21kc1Jvd31gKTtcbiAgICAgICAgcmV0dXJuIG1kc1Jvdy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiBNRFMgbWF0cml4IHZhbHVlPSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBGcC5jcmVhdGUoaSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cywgcm91bmRzLCBzYm94Rm4sIHJvdW5kQ29uc3RhbnRzLCBtZHMgfSk7XG59XG5leHBvcnRzLnZhbGlkYXRlT3B0cyA9IHZhbGlkYXRlT3B0cztcbmZ1bmN0aW9uIHNwbGl0Q29uc3RhbnRzKHJjLCB0KSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NlaWRvblNwbGl0Q29uc3RhbnRzOiB3cm9uZyB0Jyk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJjKSB8fCByYy5sZW5ndGggJSB0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2VpZG9uU3BsaXRDb25zdGFudHM6IHdyb25nIHJjJyk7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IHRtcCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG1wLnB1c2gocmNbaV0pO1xuICAgICAgICBpZiAodG1wLmxlbmd0aCA9PT0gdCkge1xuICAgICAgICAgICAgcmVzLnB1c2godG1wKTtcbiAgICAgICAgICAgIHRtcCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLnNwbGl0Q29uc3RhbnRzID0gc3BsaXRDb25zdGFudHM7XG5mdW5jdGlvbiBwb3NlaWRvbihvcHRzKSB7XG4gICAgY29uc3QgeyB0LCBGcCwgcm91bmRzLCBzYm94Rm4sIHJldmVyc2VQYXJ0aWFsUG93SWR4IH0gPSB2YWxpZGF0ZU9wdHMob3B0cyk7XG4gICAgY29uc3QgaGFsZlJvdW5kc0Z1bGwgPSBNYXRoLmZsb29yKG9wdHMucm91bmRzRnVsbCAvIDIpO1xuICAgIGNvbnN0IHBhcnRpYWxJZHggPSByZXZlcnNlUGFydGlhbFBvd0lkeCA/IHQgLSAxIDogMDtcbiAgICBjb25zdCBwb3NlaWRvblJvdW5kID0gKHZhbHVlcywgaXNGdWxsLCBpZHgpID0+IHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCgoaSwgaikgPT4gRnAuYWRkKGksIG9wdHMucm91bmRDb25zdGFudHNbaWR4XVtqXSkpO1xuICAgICAgICBpZiAoaXNGdWxsKVxuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCgoaSkgPT4gc2JveEZuKGkpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsdWVzW3BhcnRpYWxJZHhdID0gc2JveEZuKHZhbHVlc1twYXJ0aWFsSWR4XSk7XG4gICAgICAgIHZhbHVlcyA9IG9wdHMubWRzLm1hcCgoaSkgPT4gaS5yZWR1Y2UoKGFjYywgaSwgaikgPT4gRnAuYWRkKGFjYywgRnAubXVsTihpLCB2YWx1ZXNbal0pKSwgRnAuWkVSTykpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgY29uc3QgcG9zZWlkb25IYXNoID0gZnVuY3Rpb24gcG9zZWlkb25IYXNoKHZhbHVlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoICE9PSB0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogd3JvbmcgdmFsdWVzIChleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzIHdpdGggbGVuZ3RoICR7dH0pYCk7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogd3JvbmcgdmFsdWU9JHtpfSAoJHt0eXBlb2YgaX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gRnAuY3JlYXRlKGkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJvdW5kID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYWxmUm91bmRzRnVsbDsgaSsrKVxuICAgICAgICAgICAgdmFsdWVzID0gcG9zZWlkb25Sb3VuZCh2YWx1ZXMsIHRydWUsIHJvdW5kKyspO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdHMucm91bmRzUGFydGlhbDsgaSsrKVxuICAgICAgICAgICAgdmFsdWVzID0gcG9zZWlkb25Sb3VuZCh2YWx1ZXMsIGZhbHNlLCByb3VuZCsrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYWxmUm91bmRzRnVsbDsgaSsrKVxuICAgICAgICAgICAgdmFsdWVzID0gcG9zZWlkb25Sb3VuZCh2YWx1ZXMsIHRydWUsIHJvdW5kKyspO1xuICAgICAgICBpZiAocm91bmQgIT09IHJvdW5kcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IHdyb25nIG51bWJlciBvZiByb3VuZHM6IGxhc3Qgcm91bmQ9JHtyb3VuZH0sIHRvdGFsPSR7cm91bmRzfWApO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgcG9zZWlkb25IYXNoLnJvdW5kQ29uc3RhbnRzID0gb3B0cy5yb3VuZENvbnN0YW50cztcbiAgICByZXR1cm4gcG9zZWlkb25IYXNoO1xufVxuZXhwb3J0cy5wb3NlaWRvbiA9IHBvc2VpZG9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9zZWlkb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/poseidon.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js':
    /*!**********************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js ***!
  \**********************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexports.numberToHexUnpadded = numberToHexUnpadded;\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    if (hex.length % 2)\n        throw new Error('hex string is invalid: unpadded ' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexports.bytesToNumberLE = bytesToNumberLE;\nconst numberToBytesBE = (n, len) => hexToBytes(n.toString(16).padStart(len * 2, '0'));\nexports.numberToBytesBE = numberToBytesBE;\nconst numberToBytesLE = (n, len) => (0, exports.numberToBytesBE)(n, len).reverse();\nexports.numberToBytesLE = numberToBytesLE;\nconst numberToVarBytesBE = (n) => hexToBytes(numberToHexUnpadded(n));\nexports.numberToVarBytesBE = numberToVarBytesBE;\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\nexports.ensureBytes = ensureBytes;\nfunction concatBytes(...arrs) {\n    const r = new Uint8Array(arrs.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0;\n    arrs.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\nexports.equalBytes = equalBytes;\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexports.utf8ToBytes = utf8ToBytes;\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\nexports.bitLen = bitLen;\nconst bitGet = (n, pos) => (n >> BigInt(pos)) & _1n;\nexports.bitGet = bitGet;\nconst bitSet = (n, pos, value) => n | ((value ? _1n : _0n) << BigInt(pos));\nexports.bitSet = bitSet;\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\nconst u8n = (data) => new Uint8Array(data);\nconst u8fr = (arr) => Uint8Array.from(arr);\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    let v = u8n(hashLen);\n    let k = u8n(hashLen);\n    let i = 0;\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b);\n    const reseed = (seed = u8n()) => {\n        k = h(u8fr([0x00]), seed);\n        v = h();\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed);\n        v = h();\n    };\n    const gen = () => {\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed);\n        let res = undefined;\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexports.createHmacDrbg = createHmacDrbg;\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\nexports.validateObject = validateObject;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLDJCQUEyQixHQUFHLGtCQUFrQjtBQUM5YTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxpQ0FBaUMsSUFBSSxZQUFZLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sV0FBVyxnQkFBZ0IsYUFBYSxJQUFJO0FBQzlFO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLEtBQUssR0FBRyxXQUFXLGNBQWMsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3QvdXRpbHMuanM/OWE0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSBleHBvcnRzLmNyZWF0ZUhtYWNEcmJnID0gZXhwb3J0cy5iaXRNYXNrID0gZXhwb3J0cy5iaXRTZXQgPSBleHBvcnRzLmJpdEdldCA9IGV4cG9ydHMuYml0TGVuID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuZXF1YWxCeXRlcyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLmVuc3VyZUJ5dGVzID0gZXhwb3J0cy5udW1iZXJUb1ZhckJ5dGVzQkUgPSBleHBvcnRzLm51bWJlclRvQnl0ZXNMRSA9IGV4cG9ydHMubnVtYmVyVG9CeXRlc0JFID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyTEUgPSBleHBvcnRzLmJ5dGVzVG9OdW1iZXJCRSA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuaGV4VG9OdW1iZXIgPSBleHBvcnRzLm51bWJlclRvSGV4VW5wYWRkZWQgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSB2b2lkIDA7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG5jb25zdCBoZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbmZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5leHBvcnRzLm51bWJlclRvSGV4VW5wYWRkZWQgPSBudW1iZXJUb0hleFVucGFkZGVkO1xuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG5leHBvcnRzLmhleFRvTnVtYmVyID0gaGV4VG9OdW1iZXI7XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGlzIGludmFsaWQ6IHVucGFkZGVkICcgKyBoZXgubGVuZ3RoKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb051bWJlckJFID0gYnl0ZXNUb051bWJlckJFO1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyTEUgPSBieXRlc1RvTnVtYmVyTEU7XG5jb25zdCBudW1iZXJUb0J5dGVzQkUgPSAobiwgbGVuKSA9PiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xuZXhwb3J0cy5udW1iZXJUb0J5dGVzQkUgPSBudW1iZXJUb0J5dGVzQkU7XG5jb25zdCBudW1iZXJUb0J5dGVzTEUgPSAobiwgbGVuKSA9PiAoMCwgZXhwb3J0cy5udW1iZXJUb0J5dGVzQkUpKG4sIGxlbikucmV2ZXJzZSgpO1xuZXhwb3J0cy5udW1iZXJUb0J5dGVzTEUgPSBudW1iZXJUb0J5dGVzTEU7XG5jb25zdCBudW1iZXJUb1ZhckJ5dGVzQkUgPSAobikgPT4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbmV4cG9ydHMubnVtYmVyVG9WYXJCeXRlc0JFID0gbnVtYmVyVG9WYXJCeXRlc0JFO1xuZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodThhKGhleCkpIHtcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmVuc3VyZUJ5dGVzID0gZW5zdXJlQnl0ZXM7XG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycnMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7XG4gICAgYXJycy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbmZ1bmN0aW9uIGVxdWFsQnl0ZXMoYjEsIGIyKSB7XG4gICAgaWYgKGIxLmxlbmd0aCAhPT0gYjIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZXF1YWxCeXRlcyA9IGVxdWFsQnl0ZXM7XG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuZXhwb3J0cy5iaXRMZW4gPSBiaXRMZW47XG5jb25zdCBiaXRHZXQgPSAobiwgcG9zKSA9PiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG5leHBvcnRzLmJpdEdldCA9IGJpdEdldDtcbmNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xuZXhwb3J0cy5iaXRTZXQgPSBiaXRTZXQ7XG5jb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG5leHBvcnRzLmJpdE1hc2sgPSBiaXRNYXNrO1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpO1xuZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7XG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTtcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7XG4gICAgICAgIHYgPSBoKCk7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTtcbiAgICAgICAgdiA9IGgoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7XG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuZXhwb3J0cy5jcmVhdGVIbWFjRHJiZyA9IGNyZWF0ZUhtYWNEcmJnO1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSB2YWxpZGF0ZU9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/weierstrass.js':
    /*!****************************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/weierstrass.js ***!
  \****************************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;\nconst mod = __importStar(__webpack_require__(/*! ./modular */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/modular.js\"));\nconst ut = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js\");\nconst curve_1 = __webpack_require__(/*! ./curve */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/curve.js\");\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexports.DER = {\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = exports.DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) };\n    },\n    toSig(hex) {\n        const { Err: E } = exports.DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE;\n    const toBytes = CURVE.toBytes ||\n        ((c, point, isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            const tail = bytes.subarray(1);\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x);\n        const x3 = Fp.mul(x2, x);\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);\n    }\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = ut.bytesToHex(key);\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE((0, utils_1.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n);\n        assertGE(num);\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_1.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        assertValidity() {\n            if (this.is0()) {\n                if (CURVE.allowInfinityPoint)\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            const { x, y } = this.toAffine();\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y);\n            const right = weierstrassEquation(x);\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;\n            let t0 = Fp.mul(X1, X1);\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3);\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3);\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3);\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0);\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1);\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3);\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2);\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2);\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2);\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2);\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2);\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0);\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4);\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0);\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n);\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake;\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            return Point.normalizeZ([point, fake])[0];\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE;\n            const mul = (P, a) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true;\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, curve_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nexports.weierstrassPoints = weierstrassPoints;\nfunction validateOpts(curve) {\n    const opts = (0, curve_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1;\n    const uncompressedLen = 2 * Fp.BYTES + 1;\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER;\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x);\n                let y = Fp.sqrt(y2);\n                const isYOdd = (y & _1n) === _1n;\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, utils_1.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_1.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_1.ensureBytes)('msgHash', msgHash));\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj);\n            const u1 = modN(-h * ir);\n            const u2 = modN(s * ir);\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n            if (!Q)\n                throw new Error('point at infinify');\n            Q.assertValidity();\n            return Q;\n        }\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        randomPrivateKey: () => {\n            const rand = CURVE.randomBytes(Fp.BYTES + 8);\n            const num = mod.hashToPrivateScalar(rand, CURVE_ORDER);\n            return ut.numberToBytesBE(num, CURVE.nByteLength);\n        },\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB);\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            const num = ut.bytesToNumberBE(bytes);\n            const delta = bytes.length * 8 - CURVE.nBitLength;\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes));\n        };\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts;\n        if (lowS == null)\n            lowS = true;\n        msgHash = (0, utils_1.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0, utils_1.ensureBytes)('prehashed msgHash', hash(msgHash));\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey);\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        if (ent != null) {\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent;\n            seedArgs.push((0, utils_1.ensureBytes)('extraEntropy', e, Fp.BYTES));\n        }\n        const seed = ut.concatBytes(...seedArgs);\n        const m = h1int;\n        function k2sig(kBytes) {\n            const k = bits2int(kBytes);\n            if (!isWithinCurveOrder(k))\n                return;\n            const ik = invN(k);\n            const q = Point.BASE.multiply(k).toAffine();\n            const r = modN(q.x);\n            if (r === _0n)\n                return;\n            const s = modN(ik * modN(m + r * d));\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s);\n                recovery ^= 1;\n            }\n            return new Signature(r, normS, recovery);\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts);\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig);\n    }\n    Point.BASE._setWindowSize(8);\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_1.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, utils_1.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof exports.DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash);\n        const is = invN(s);\n        const u1 = modN(h * is);\n        const u2 = modN(r * is);\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\nexports.weierstrass = weierstrass;\nfunction SWUFpSqrtRatio(Fp, Z) {\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l;\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1;\n    const c3 = (c2 - _1n) / _2n;\n    const c4 = _2n_pow_c1 - _1n;\n    const c5 = _2n_pow_c1_1;\n    const c6 = Fp.pow(Z, c2);\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n);\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6;\n        let tv2 = Fp.pow(v, c4);\n        let tv3 = Fp.sqr(tv2);\n        tv3 = Fp.mul(tv3, v);\n        let tv5 = Fp.mul(u, tv3);\n        tv5 = Fp.pow(tv5, c3);\n        tv5 = Fp.mul(tv5, tv2);\n        tv2 = Fp.mul(tv5, v);\n        tv3 = Fp.mul(tv5, u);\n        let tv4 = Fp.mul(tv3, tv2);\n        tv5 = Fp.pow(tv4, c5);\n        let isQR = Fp.eql(tv5, Fp.ONE);\n        tv2 = Fp.mul(tv3, c7);\n        tv5 = Fp.mul(tv4, tv1);\n        tv3 = Fp.cmov(tv2, tv3, isQR);\n        tv4 = Fp.cmov(tv5, tv4, isQR);\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n;\n            tv5 = _2n << (tv5 - _1n);\n            let tvv5 = Fp.pow(tv4, tv5);\n            const e1 = Fp.eql(tvv5, Fp.ONE);\n            tv2 = Fp.mul(tv3, tv1);\n            tv1 = Fp.mul(tv1, tv1);\n            tvv5 = Fp.mul(tv4, tv1);\n            tv3 = Fp.cmov(tv2, tv3, e1);\n            tv4 = Fp.cmov(tvv5, tv4, e1);\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        const c1 = (Fp.ORDER - _3n) / _4n;\n        const c2 = Fp.sqrt(Fp.neg(Z));\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v);\n            const tv2 = Fp.mul(u, v);\n            tv1 = Fp.mul(tv1, tv2);\n            let y1 = Fp.pow(tv1, c1);\n            y1 = Fp.mul(y1, tv2);\n            const y2 = Fp.mul(y1, c2);\n            const tv3 = Fp.mul(Fp.sqr(y1), v);\n            const isQR = Fp.eql(tv3, u);\n            let y = Fp.cmov(y2, y1, isQR);\n            return { isValid: isQR, value: y };\n        };\n    }\n    return sqrtRatio;\n}\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    return (u) => {\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u);\n        tv1 = Fp.mul(tv1, opts.Z);\n        tv2 = Fp.sqr(tv1);\n        tv2 = Fp.add(tv2, tv1);\n        tv3 = Fp.add(tv2, Fp.ONE);\n        tv3 = Fp.mul(tv3, opts.B);\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));\n        tv4 = Fp.mul(tv4, opts.A);\n        tv2 = Fp.sqr(tv3);\n        tv6 = Fp.sqr(tv4);\n        tv5 = Fp.mul(tv6, opts.A);\n        tv2 = Fp.add(tv2, tv5);\n        tv2 = Fp.mul(tv2, tv3);\n        tv6 = Fp.mul(tv6, tv4);\n        tv5 = Fp.mul(tv6, opts.B);\n        tv2 = Fp.add(tv2, tv5);\n        x = Fp.mul(tv1, tv3);\n        const { isValid, value } = sqrtRatio(tv2, tv6);\n        y = Fp.mul(tv1, u);\n        y = Fp.mul(y, value);\n        x = Fp.cmov(x, tv3, isValid);\n        y = Fp.cmov(y, value, isValid);\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y);\n        y = Fp.cmov(Fp.neg(y), y, e1);\n        x = Fp.div(x, tv4);\n        return { x, y };\n    };\n}\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsV0FBVztBQUNwSCx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBVztBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBUztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxpR0FBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpR0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsUUFBUSx3Q0FBd0M7QUFDaEQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQixJQUFJLEdBQUcsRUFBRSxFQUFFLElBQUksR0FBRyxFQUFFLEVBQUU7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBb0U7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWEsNEJBQTRCLFdBQVc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0Msb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0Msb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQyxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJGQUEyRjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG1EQUFtRCxLQUFLLHdCQUF3QixlQUFlLHNCQUFzQixpQkFBaUI7QUFDdEk7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGNBQWMsbUNBQW1DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9zaWdudXRpbC9zY2hub3JyL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzPzZiMjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFwVG9DdXJ2ZVNpbXBsZVNXVSA9IGV4cG9ydHMuU1dVRnBTcXJ0UmF0aW8gPSBleHBvcnRzLndlaWVyc3RyYXNzID0gZXhwb3J0cy53ZWllcnN0cmFzc1BvaW50cyA9IGV4cG9ydHMuREVSID0gdm9pZCAwO1xuY29uc3QgbW9kID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZHVsYXJcIikpO1xuY29uc3QgdXQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY3VydmVfMSA9IHJlcXVpcmUoXCIuL2N1cnZlXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gKDAsIGN1cnZlXzEudmFsaWRhdGVCYXNpYykoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydHMuREVSID0ge1xuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2VJbnQoZGF0YSkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIGlmIChyZXNbMF0gJiAwYjEwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTtcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBleHBvcnRzLkRFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgICAgIGNvbnN0IHsgZDogcywgbDogckJ5dGVzTGVmdCB9ID0gZXhwb3J0cy5ERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFO1xuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpO1xuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTtcbiAgICB9XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UobnVtKSB7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIGJpZ2ludDogMCA8IGJpZ2ludCA8IGN1cnZlLm4nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRSgoMCwgdXRpbHNfMS5lbnN1cmVCeXRlcykoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTtcbiAgICAgICAgYXNzZXJ0R0UobnVtKTtcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcygoMCwgdXRpbHNfMS5lbnN1cmVCeXRlcykoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFJyk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTtcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTtcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87XG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTtcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgYXNzZXJ0R0Uoc2NhbGFyKTtcbiAgICAgICAgICAgIGxldCBuID0gc2NhbGFyO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlO1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gKDAsIGN1cnZlXzEud05BRikoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5leHBvcnRzLndlaWVyc3RyYXNzUG9pbnRzID0gd2VpZXJzdHJhc3NQb2ludHM7XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gKDAsIGN1cnZlXzEudmFsaWRhdGVCYXNpYykoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7XG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTtcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQoeTIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9ICgwLCB1dGlsc18xLmVuc3VyZUJ5dGVzKSgnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IGV4cG9ydHMuREVSLnRvU2lnKCgwLCB1dGlsc18xLmVuc3VyZUJ5dGVzKSgnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oKDAsIHV0aWxzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCkpO1xuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTtcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpO1xuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTtcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7XG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5kID0gQ1VSVkUucmFuZG9tQnl0ZXMoRnAuQllURVMgKyA4KTtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9IG1vZC5oYXNoVG9Qcml2YXRlU2NhbGFyKHJhbmQsIENVUlZFX09SREVSKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpO1xuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpO1xuICAgICAgICB9O1xuICAgIGNvbnN0IE9SREVSX01BU0sgPSB1dC5iaXRNYXNrKENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzO1xuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7XG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzXzEuZW5zdXJlQnl0ZXMpKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDtcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goKDAsIHV0aWxzXzEuZW5zdXJlQnl0ZXMpKCdleHRyYUVudHJvcHknLCBlLCBGcC5CWVRFUykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7XG4gICAgICAgIGNvbnN0IG0gPSBoMWludDtcbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTtcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTtcbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpO1xuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7XG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTtcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7XG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTtcbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpO1xuICAgIH1cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9ICgwLCB1dGlsc18xLmVuc3VyZUJ5dGVzKSgncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBleHBvcnRzLkRFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpO1xuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTtcbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7XG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7XG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG5leHBvcnRzLndlaWVyc3RyYXNzID0gd2VpZXJzdHJhc3M7XG5mdW5jdGlvbiBTV1VGcFNxcnRSYXRpbyhGcCwgWikge1xuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsO1xuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxO1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjtcbiAgICBjb25zdCBjNCA9IF8ybl9wb3dfYzEgLSBfMW47XG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7XG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpO1xuICAgIGNvbnN0IGM3ID0gRnAucG93KFosIChjMiArIF8xbikgLyBfMm4pO1xuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpO1xuICAgICAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIHYpO1xuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7XG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTtcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTtcbiAgICAgICAgdHYyID0gRnAubXVsKHR2NSwgdik7XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpO1xuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTtcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NCwgYzUpO1xuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTtcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTtcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7XG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpO1xuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47XG4gICAgICAgICAgICB0djUgPSBfMm4gPDwgKHR2NSAtIF8xbik7XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpO1xuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTtcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7XG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTtcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTtcbiAgICAgICAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuO1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTtcbiAgICAgICAgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgICAgIGxldCB0djEgPSBGcC5zcXIodik7XG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpO1xuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpO1xuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7XG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpO1xuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpO1xuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpO1xuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7XG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc3FydFJhdGlvO1xufVxuZXhwb3J0cy5TV1VGcFNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvO1xuZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgIG1vZC52YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7XG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpO1xuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpO1xuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpO1xuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpO1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7XG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpO1xuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTtcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTtcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTtcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTtcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTtcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTtcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTtcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7XG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTtcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7XG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7XG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTtcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7XG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpO1xuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5tYXBUb0N1cnZlU2ltcGxlU1dVID0gbWFwVG9DdXJ2ZVNpbXBsZVNXVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/weierstrass.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/index.js':
    /*!*************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/index.js ***!
  \*************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.bytesToHex = exports.hexToBytes = exports.stark = exports.secp256k1 = void 0;\nexports.secp256k1 = __importStar(__webpack_require__(/*! ./secp256k1 */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/secp256k1.js"));\nexports.stark = __importStar(__webpack_require__(/*! ./stark */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/stark.js"));\nvar utils_1 = __webpack_require__(/*! ./abstract/utils */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js");\nObject.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return utils_1.hexToBytes; } }));\nObject.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return utils_1.bytesToHex; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGFBQWEsR0FBRyxpQkFBaUI7QUFDM0UsaUJBQWlCLGdCQUFnQixtQkFBTyxDQUFDLGdHQUFhO0FBQ3RELGFBQWEsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQVM7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLDBHQUFrQjtBQUN4Qyw4Q0FBNkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbkgsOENBQTZDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ25IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvaW5kZXguanM/ZDczMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5zdGFyayA9IGV4cG9ydHMuc2VjcDI1NmsxID0gdm9pZCAwO1xuZXhwb3J0cy5zZWNwMjU2azEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2VjcDI1NmsxXCIpKTtcbmV4cG9ydHMuc3RhcmsgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc3RhcmtcIikpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhleFRvQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuaGV4VG9CeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVzVG9IZXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuYnl0ZXNUb0hleDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/secp256k1.js':
    /*!*****************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/secp256k1.js ***!
  \*****************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js\");\nconst modular_1 = __webpack_require__(/*! ./abstract/modular */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/modular.js\");\nconst weierstrass_1 = __webpack_require__(/*! ./abstract/weierstrass */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/weierstrass.js\");\nconst utils_2 = __webpack_require__(/*! ./abstract/utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js\");\nconst htf = __importStar(__webpack_require__(/*! ./abstract/hash-to-curve */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/hash-to-curve.js\"));\nconst _shortw_utils_1 = __webpack_require__(/*! ./_shortw_utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/_shortw_utils.js\");\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P;\n    const b3 = (b2 * b2 * y) % P;\n    const b6 = ((0, modular_1.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0, modular_1.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0, modular_1.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0, modular_1.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0, modular_1.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0, modular_1.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0, modular_1.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0, modular_1.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0, modular_1.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0, modular_1.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0, modular_1.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0, modular_1.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0, modular_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexports.secp256k1 = (0, _shortw_utils_1.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256_1.sha256);\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0, utils_2.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_2.concatBytes)(tagP, ...messages));\n}\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0, utils_2.numberToBytesBE)(n, 32);\nconst modP = (x) => (0, modular_1.mod)(x, secp256k1P);\nconst modN = (x) => (0, modular_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);\n    let p = Point.fromPrivateKey(d_);\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p');\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7));\n    let y = sqrtMod(c);\n    if (y % _2n !== _0n)\n        y = modP(-y);\n    const p = new Point(x, y, _1n);\n    p.assertValidity();\n    return p;\n}\nfunction challenge(...args) {\n    return modN((0, utils_2.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes;\n}\nfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_2.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);\n    const a = (0, utils_2.ensureBytes)('auxRand', auxRand, 32);\n    const t = numTo32b(d ^ (0, utils_2.bytesToNumberBE)(taggedHash('BIP0340/aux', a)));\n    const rand = taggedHash('BIP0340/nonce', t, px, m);\n    const k_ = modN((0, utils_2.bytesToNumberBE)(rand));\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero');\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);\n    const e = challenge(rx, px, m);\n    const sig = new Uint8Array(64);\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_2.ensureBytes)('signature', signature, 64);\n    const m = (0, utils_2.ensureBytes)('message', message);\n    const pub = (0, utils_2.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0, utils_2.bytesToNumberBE)(pub));\n        const r = (0, utils_2.bytesToNumberBE)(sig.subarray(0, 32));\n        if (!fe(r))\n            return false;\n        const s = (0, utils_2.bytesToNumberBE)(sig.subarray(32, 64));\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m);\n        const R = GmulAdd(P, s, modN(-e));\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false;\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\nexports.schnorr = {\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: utils_2.numberToBytesBE,\n        bytesToNumberBE: utils_2.bytesToNumberBE,\n        taggedHash,\n        mod: modular_1.mod,\n    },\n};\nconst isoMap = htf.isogenyMap(Fp, [\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001',\n    ],\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001',\n    ],\n].map((i) => i.map((j) => BigInt(j))));\nconst mapSWU = (0, weierstrass_1.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n});\n_a = htf.createHasher(exports.secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256_1.sha256,\n}), exports.hashToCurve = _a.hashToCurve, exports.encodeToCurve = _a.encodeToCurve;\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxpQkFBaUI7QUFDakYsaUJBQWlCLG1CQUFPLENBQUMsMkdBQXNCO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFxQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyw4R0FBb0I7QUFDOUMsc0JBQXNCLG1CQUFPLENBQUMsc0hBQXdCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLDBHQUFrQjtBQUMxQyx5QkFBeUIsbUJBQU8sQ0FBQywwSEFBMEI7QUFDM0Qsd0JBQXdCLG1CQUFPLENBQUMsd0dBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxlQUFlO0FBQ25GLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsbUJBQW1CLG1CQUFtQixxQkFBcUI7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3Qvc2lnbnV0aWwvc2Nobm9yci9zZWNwMjU2azEuanM/MTYyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9IGV4cG9ydHMuc2Nobm9yciA9IGV4cG9ydHMuc2VjcDI1NmsxID0gdm9pZCAwO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBtb2R1bGFyXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9tb2R1bGFyXCIpO1xuY29uc3Qgd2VpZXJzdHJhc3NfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3V0aWxzXCIpO1xuY29uc3QgaHRmID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmVcIikpO1xuY29uc3QgX3Nob3J0d191dGlsc18xID0gcmVxdWlyZShcIi4vX3Nob3J0d191dGlsc1wiKTtcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQO1xuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7XG4gICAgY29uc3QgYjYgPSAoKDAsIG1vZHVsYXJfMS5wb3cyKShiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAoKDAsIG1vZHVsYXJfMS5wb3cyKShiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKCgwLCBtb2R1bGFyXzEucG93MikoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9ICgoMCwgbW9kdWxhcl8xLnBvdzIpKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAoKDAsIG1vZHVsYXJfMS5wb3cyKShiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKCgwLCBtb2R1bGFyXzEucG93MikoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAoKDAsIG1vZHVsYXJfMS5wb3cyKShiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9ICgoMCwgbW9kdWxhcl8xLnBvdzIpKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9ICgoMCwgbW9kdWxhcl8xLnBvdzIpKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKCgwLCBtb2R1bGFyXzEucG93MikoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9ICgoMCwgbW9kdWxhcl8xLnBvdzIpKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gKDAsIG1vZHVsYXJfMS5wb3cyKSh0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcCA9ICgwLCBtb2R1bGFyXzEuRmllbGQpKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5leHBvcnRzLnNlY3AyNTZrMSA9ICgwLCBfc2hvcnR3X3V0aWxzXzEuY3JlYXRlQ3VydmUpKHtcbiAgICBhOiBCaWdJbnQoMCksXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiB0cnVlLFxuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gKDAsIG1vZHVsYXJfMS5tb2QpKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSAoMCwgbW9kdWxhcl8xLm1vZCkoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTZfMS5zaGEyNTYpO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgZmUgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMVA7XG5jb25zdCBnZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxTjtcbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gKDAsIHV0aWxzXzIuY29uY2F0Qnl0ZXMpKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCB1dGlsc18yLmNvbmNhdEJ5dGVzKSh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlc0JFKShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+ICgwLCBtb2R1bGFyXzEubW9kKSh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gKDAsIG1vZHVsYXJfMS5tb2QpKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBleHBvcnRzLnNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpO1xuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pO1xuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgIGlmICghZmUoeCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHg6IG5lZWQgMCA8IHggPCBwJyk7XG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpO1xuICAgIGxldCB5ID0gc3FydE1vZChjKTtcbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7XG4gICAgY29uc3QgcCA9IG5ldyBQb2ludCh4LCB5LCBfMW4pO1xuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oKDAsIHV0aWxzXzIuYnl0ZXNUb051bWJlckJFKSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KS5ieXRlcztcbn1cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSAoMCwgdXRpbHNfMS5yYW5kb21CeXRlcykoMzIpKSB7XG4gICAgY29uc3QgbSA9ICgwLCB1dGlsc18yLmVuc3VyZUJ5dGVzKSgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHsgYnl0ZXM6IHB4LCBzY2FsYXI6IGQgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSk7XG4gICAgY29uc3QgYSA9ICgwLCB1dGlsc18yLmVuc3VyZUJ5dGVzKSgnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTtcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeICgwLCB1dGlsc18yLmJ5dGVzVG9OdW1iZXJCRSkodGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpO1xuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pO1xuICAgIGNvbnN0IGtfID0gbW9kTigoMCwgdXRpbHNfMi5ieXRlc1RvTnVtYmVyQkUpKHJhbmQpKTtcbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7XG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7XG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pO1xuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9ICgwLCB1dGlsc18yLmVuc3VyZUJ5dGVzKSgnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9ICgwLCB1dGlsc18yLmVuc3VyZUJ5dGVzKSgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9ICgwLCB1dGlsc18yLmVuc3VyZUJ5dGVzKSgncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeCgoMCwgdXRpbHNfMi5ieXRlc1RvTnVtYmVyQkUpKHB1YikpO1xuICAgICAgICBjb25zdCByID0gKDAsIHV0aWxzXzIuYnl0ZXNUb051bWJlckJFKShzaWcuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICAgICAgaWYgKCFmZShyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9ICgwLCB1dGlsc18yLmJ5dGVzVG9OdW1iZXJCRSkoc2lnLnN1YmFycmF5KDMyLCA2NCkpO1xuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pO1xuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7XG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLnNjaG5vcnIgPSB7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBleHBvcnRzLnNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFOiB1dGlsc18yLm51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFOiB1dGlsc18yLmJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kOiBtb2R1bGFyXzEubW9kLFxuICAgIH0sXG59O1xuY29uc3QgaXNvTWFwID0gaHRmLmlzb2dlbnlNYXAoRnAsIFtcbiAgICBbXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxuICAgICAgICAnMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyJyxcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG4gICAgXSxcbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gICAgXSxcbiAgICBbXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxuICAgICAgICAnMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzJyxcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxuICAgIF0sXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSk7XG5jb25zdCBtYXBTV1UgPSAoMCwgd2VpZXJzdHJhc3NfMS5tYXBUb0N1cnZlU2ltcGxlU1dVKShGcCwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnAuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSk7XG5fYSA9IGh0Zi5jcmVhdGVIYXNoZXIoZXhwb3J0cy5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwLmNyZWF0ZShzY2FsYXJzWzBdKSk7XG4gICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcbn0sIHtcbiAgICBEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyNTZfMS5zaGEyNTYsXG59KSwgZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9IF9hLmhhc2hUb0N1cnZlLCBleHBvcnRzLmVuY29kZVRvQ3VydmUgPSBfYS5lbmNvZGVUb0N1cnZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/secp256k1.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/stark.js':
    /*!*************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/stark.js ***!
  \*************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.poseidonHashMany = exports.poseidonHashSingle = exports.poseidonHashFunc = exports.poseidonHash = exports.poseidonSmall = exports.poseidonCreate = exports.poseidonBasic = exports._poseidonMDS = exports.Fp251 = exports.Fp253 = exports.keccak = exports.computeHashOnElements = exports.hashChain = exports.pedersen = exports.getAccountPath = exports.ethSigToPrivate = exports.getStarkKey = exports.grindKey = exports.utils = exports.Signature = exports.ProjectivePoint = exports.CURVE = exports.verify = exports.sign = exports.getSharedSecret = exports.getPublicKey = exports._starkCurve = void 0;\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha3.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js\");\nconst modular_1 = __webpack_require__(/*! ./abstract/modular */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/modular.js\");\nconst poseidon_1 = __webpack_require__(/*! ./abstract/poseidon */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/poseidon.js\");\nconst weierstrass_1 = __webpack_require__(/*! ./abstract/weierstrass */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/weierstrass.js\");\nconst u = __importStar(__webpack_require__(/*! ./abstract/utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/abstract/utils.js\"));\nconst _shortw_utils_1 = __webpack_require__(/*! ./_shortw_utils */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/_shortw_utils.js\");\nconst CURVE_ORDER = BigInt('3618502788666131213697322783095070105526743751716087489154079457884512865583');\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n    while (bytes[0] === 0)\n        bytes = bytes.subarray(1);\n    const delta = bytes.length * 8 - nBitLength;\n    const num = u.bytesToNumberBE(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n    if (typeof hex === 'string') {\n        hex = strip0x(hex);\n        if (hex.length & 1)\n            hex = '0' + hex;\n    }\n    return u.hexToBytes(hex);\n}\nconst curve = (0, weierstrass_1.weierstrass)({\n    a: BigInt(1),\n    b: BigInt('3141592653589793238462643383279502884197169399375105820974944592307816406665'),\n    Fp: (0, modular_1.Field)(BigInt('0x800000000000011000000000000000000000000000000000000000000000001')),\n    n: CURVE_ORDER,\n    nBitLength,\n    Gx: BigInt('874739451078007766457464989774322083649278607533249481151382481072868806602'),\n    Gy: BigInt('152666792071518830868575557812948353041420400780739481342941381225525861407'),\n    h: BigInt(1),\n    lowS: false,\n    ...(0, _shortw_utils_1.getHash)(sha256_1.sha256),\n    bits2int,\n    bits2int_modN: (bytes) => {\n        const hex = u.bytesToNumberBE(bytes).toString(16);\n        if (hex.length === 63)\n            bytes = hex0xToBytes(hex + '0');\n        return (0, modular_1.mod)(bits2int(bytes), CURVE_ORDER);\n    },\n});\nexports._starkCurve = curve;\nfunction ensureBytes(hex) {\n    return u.ensureBytes('', typeof hex === 'string' ? hex0xToBytes(hex) : hex);\n}\nfunction normPrivKey(privKey) {\n    return u.bytesToHex(ensureBytes(privKey)).padStart(64, '0');\n}\nfunction getPublicKey(privKey, isCompressed = false) {\n    return curve.getPublicKey(normPrivKey(privKey), isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction getSharedSecret(privKeyA, pubKeyB) {\n    return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction sign(msgHash, privKey, opts) {\n    return curve.sign(ensureBytes(msgHash), normPrivKey(privKey), opts);\n}\nexports.sign = sign;\nfunction verify(signature, msgHash, pubKey) {\n    const sig = signature instanceof Signature ? signature : ensureBytes(signature);\n    return curve.verify(sig, ensureBytes(msgHash), ensureBytes(pubKey));\n}\nexports.verify = verify;\nconst { CURVE, ProjectivePoint, Signature, utils } = curve;\nexports.CURVE = CURVE;\nexports.ProjectivePoint = ProjectivePoint;\nexports.Signature = Signature;\nexports.utils = utils;\nfunction extractX(bytes) {\n    const hex = u.bytesToHex(bytes.subarray(1));\n    const stripped = hex.replace(/^0+/gm, '');\n    return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n    return hex.replace(/^0x/i, '');\n}\nfunction numberTo0x16(num) {\n    return `0x${num.toString(16)}`;\n}\nfunction grindKey(seed) {\n    const _seed = ensureBytes(seed);\n    const sha256mask = 2n ** 256n;\n    const limit = sha256mask - (0, modular_1.mod)(sha256mask, CURVE_ORDER);\n    for (let i = 0;; i++) {\n        const key = sha256Num(u.concatBytes(_seed, u.numberToVarBytesBE(BigInt(i))));\n        if (key < limit)\n            return (0, modular_1.mod)(key, CURVE_ORDER).toString(16);\n        if (i === 100000)\n            throw new Error('grindKey is broken: tried 100k vals');\n    }\n}\nexports.grindKey = grindKey;\nfunction getStarkKey(privateKey) {\n    return extractX(getPublicKey(privateKey, true));\n}\nexports.getStarkKey = getStarkKey;\nfunction ethSigToPrivate(signature) {\n    signature = strip0x(signature);\n    if (signature.length !== 130)\n        throw new Error('Wrong ethereum signature');\n    return grindKey(signature.substring(0, 64));\n}\nexports.ethSigToPrivate = ethSigToPrivate;\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = (n) => Number(n & MASK_31);\nfunction getAccountPath(layer, application, ethereumAddress, index) {\n    const layerNum = int31(sha256Num(layer));\n    const applicationNum = int31(sha256Num(application));\n    const eth = u.hexToNumber(strip0x(ethereumAddress));\n    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\nexports.getAccountPath = getAccountPath;\nconst PEDERSEN_POINTS = [\n    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),\n    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),\n    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),\n    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),\n    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n),\n];\nfunction pedersenPrecompute(p1, p2) {\n    const out = [];\n    let p = p1;\n    for (let i = 0; i < 248; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    p = p2;\n    for (let i = 0; i < 4; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n    let value;\n    if (typeof arg === 'bigint') {\n        value = arg;\n    }\n    else if (typeof arg === 'number') {\n        if (!Number.isSafeInteger(arg))\n            throw new Error(`Invalid pedersenArg: ${arg}`);\n        value = BigInt(arg);\n    }\n    else {\n        value = u.bytesToNumberBE(ensureBytes(arg));\n    }\n    if (!(0n <= value && value < curve.CURVE.Fp.ORDER))\n        throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);\n    return value;\n}\nfunction pedersenSingle(point, value, constants) {\n    let x = pedersenArg(value);\n    for (let j = 0; j < 252; j++) {\n        const pt = constants[j];\n        if (pt.equals(point))\n            throw new Error('Same point');\n        if ((x & 1n) !== 0n)\n            point = point.add(pt);\n        x >>= 1n;\n    }\n    return point;\n}\nfunction pedersen(x, y) {\n    let point = PEDERSEN_POINTS[0];\n    point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n    point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n    return extractX(point.toRawBytes(true));\n}\nexports.pedersen = pedersen;\nfunction hashChain(data, fn = pedersen) {\n    if (!Array.isArray(data) || data.length < 1)\n        throw new Error('data should be array of at least 1 element');\n    if (data.length === 1)\n        return numberTo0x16(pedersenArg(data[0]));\n    return Array.from(data)\n        .reverse()\n        .reduce((acc, i) => fn(i, acc));\n}\nexports.hashChain = hashChain;\nconst computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));\nexports.computeHashOnElements = computeHashOnElements;\nconst MASK_250 = u.bitMask(250);\nconst keccak = (data) => u.bytesToNumberBE((0, sha3_1.keccak_256)(data)) & MASK_250;\nexports.keccak = keccak;\nconst sha256Num = (data) => u.bytesToNumberBE((0, sha256_1.sha256)(data));\nexports.Fp253 = (0, modular_1.Field)(BigInt('14474011154664525231415395255581126252639794253786371766033694892385558855681'));\nexports.Fp251 = (0, modular_1.Field)(BigInt('3618502788666131213697322783095070105623107215331596699973092056135872020481'));\nfunction poseidonRoundConstant(Fp, name, idx) {\n    const val = Fp.fromBytes((0, sha256_1.sha256)((0, utils_1.utf8ToBytes)(`${name}${idx}`)));\n    return Fp.create(val);\n}\nfunction _poseidonMDS(Fp, name, m, attempt = 0) {\n    const x_values = [];\n    const y_values = [];\n    for (let i = 0; i < m; i++) {\n        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n    }\n    if (new Set([...x_values, ...y_values]).size !== 2 * m)\n        throw new Error('X and Y values are not distinct');\n    return x_values.map((x) => y_values.map((y) => Fp.inv(Fp.sub(x, y))));\n}\nexports._poseidonMDS = _poseidonMDS;\nconst MDS_SMALL = [\n    [3, 1, 1],\n    [1, -1, 1],\n    [1, 1, -2],\n].map((i) => i.map(BigInt));\nfunction poseidonBasic(opts, mds) {\n    (0, modular_1.validateField)(opts.Fp);\n    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))\n        throw new Error(`Wrong poseidon opts: ${opts}`);\n    const m = opts.rate + opts.capacity;\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    const roundConstants = [];\n    for (let i = 0; i < rounds; i++) {\n        const row = [];\n        for (let j = 0; j < m; j++)\n            row.push(poseidonRoundConstant(opts.Fp, 'Hades', m * i + j));\n        roundConstants.push(row);\n    }\n    const res = (0, poseidon_1.poseidon)({\n        ...opts,\n        t: m,\n        sboxPower: 3,\n        reversePartialPowIdx: true,\n        mds,\n        roundConstants,\n    });\n    res.m = m;\n    res.rate = opts.rate;\n    res.capacity = opts.capacity;\n    return res;\n}\nexports.poseidonBasic = poseidonBasic;\nfunction poseidonCreate(opts, mdsAttempt = 0) {\n    const m = opts.rate + opts.capacity;\n    if (!Number.isSafeInteger(mdsAttempt))\n        throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n    return poseidonBasic(opts, _poseidonMDS(opts.Fp, 'HadesMDS', m, mdsAttempt));\n}\nexports.poseidonCreate = poseidonCreate;\nexports.poseidonSmall = poseidonBasic({ Fp: exports.Fp251, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, MDS_SMALL);\nfunction poseidonHash(x, y, fn = exports.poseidonSmall) {\n    return fn([x, y, 2n])[0];\n}\nexports.poseidonHash = poseidonHash;\nfunction poseidonHashFunc(x, y, fn = exports.poseidonSmall) {\n    return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x), u.bytesToNumberBE(y), fn));\n}\nexports.poseidonHashFunc = poseidonHashFunc;\nfunction poseidonHashSingle(x, fn = exports.poseidonSmall) {\n    return fn([x, 0n, 1n])[0];\n}\nexports.poseidonHashSingle = poseidonHashSingle;\nfunction poseidonHashMany(values, fn = exports.poseidonSmall) {\n    const { m, rate } = fn;\n    if (!Array.isArray(values))\n        throw new Error('bigint array expected in values');\n    const padded = Array.from(values);\n    padded.push(1n);\n    while (padded.length % rate !== 0)\n        padded.push(0n);\n    let state = new Array(m).fill(0n);\n    for (let i = 0; i < padded.length; i += rate) {\n        for (let j = 0; j < rate; j++)\n            state[j] += padded[i + j];\n        state = fn(state);\n    }\n    return state[0];\n}\nexports.poseidonHashMany = poseidonHashMany;\n//# sourceMappingURL=stark.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NjaG5vcnIvc3RhcmsuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLDZCQUE2QixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLGFBQWEsR0FBRyxpQkFBaUIsR0FBRyx1QkFBdUIsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUI7QUFDaGxCLGVBQWUsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsMkdBQXNCO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFxQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyw4R0FBb0I7QUFDOUMsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQXFCO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLHNIQUF3QjtBQUN0RCx1QkFBdUIsbUJBQU8sQ0FBQywwR0FBa0I7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsd0dBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsUUFBUSwyQ0FBMkM7QUFDbkQsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUyxJQUFJLGVBQWUsSUFBSSxXQUFXLElBQUksa0JBQWtCLElBQUksTUFBTTtBQUNqRztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBLDhFQUE4RSxLQUFLLEVBQUUsSUFBSTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsbURBQW1ELEtBQUs7QUFDeEQsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUJBQXFCLG1CQUFtQiwyRUFBMkU7QUFDbkg7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL2Rpc3Qvc2lnbnV0aWwvc2Nobm9yci9zdGFyay5qcz83NjI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBvc2VpZG9uSGFzaE1hbnkgPSBleHBvcnRzLnBvc2VpZG9uSGFzaFNpbmdsZSA9IGV4cG9ydHMucG9zZWlkb25IYXNoRnVuYyA9IGV4cG9ydHMucG9zZWlkb25IYXNoID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsID0gZXhwb3J0cy5wb3NlaWRvbkNyZWF0ZSA9IGV4cG9ydHMucG9zZWlkb25CYXNpYyA9IGV4cG9ydHMuX3Bvc2VpZG9uTURTID0gZXhwb3J0cy5GcDI1MSA9IGV4cG9ydHMuRnAyNTMgPSBleHBvcnRzLmtlY2NhayA9IGV4cG9ydHMuY29tcHV0ZUhhc2hPbkVsZW1lbnRzID0gZXhwb3J0cy5oYXNoQ2hhaW4gPSBleHBvcnRzLnBlZGVyc2VuID0gZXhwb3J0cy5nZXRBY2NvdW50UGF0aCA9IGV4cG9ydHMuZXRoU2lnVG9Qcml2YXRlID0gZXhwb3J0cy5nZXRTdGFya0tleSA9IGV4cG9ydHMuZ3JpbmRLZXkgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy5TaWduYXR1cmUgPSBleHBvcnRzLlByb2plY3RpdmVQb2ludCA9IGV4cG9ydHMuQ1VSVkUgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnbiA9IGV4cG9ydHMuZ2V0U2hhcmVkU2VjcmV0ID0gZXhwb3J0cy5nZXRQdWJsaWNLZXkgPSBleHBvcnRzLl9zdGFya0N1cnZlID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgbW9kdWxhcl8xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvbW9kdWxhclwiKTtcbmNvbnN0IHBvc2VpZG9uXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9wb3NlaWRvblwiKTtcbmNvbnN0IHdlaWVyc3RyYXNzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzc1wiKTtcbmNvbnN0IHUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYWJzdHJhY3QvdXRpbHNcIikpO1xuY29uc3QgX3Nob3J0d191dGlsc18xID0gcmVxdWlyZShcIi4vX3Nob3J0d191dGlsc1wiKTtcbmNvbnN0IENVUlZFX09SREVSID0gQmlnSW50KCczNjE4NTAyNzg4NjY2MTMxMjEzNjk3MzIyNzgzMDk1MDcwMTA1NTI2NzQzNzUxNzE2MDg3NDg5MTU0MDc5NDU3ODg0NTEyODY1NTgzJyk7XG5jb25zdCBuQml0TGVuZ3RoID0gMjUyO1xuZnVuY3Rpb24gYml0czJpbnQoYnl0ZXMpIHtcbiAgICB3aGlsZSAoYnl0ZXNbMF0gPT09IDApXG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gbkJpdExlbmd0aDtcbiAgICBjb25zdCBudW0gPSB1LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xufVxuZnVuY3Rpb24gaGV4MHhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBoZXggPSBzdHJpcDB4KGhleCk7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoICYgMSlcbiAgICAgICAgICAgIGhleCA9ICcwJyArIGhleDtcbiAgICB9XG4gICAgcmV0dXJuIHUuaGV4VG9CeXRlcyhoZXgpO1xufVxuY29uc3QgY3VydmUgPSAoMCwgd2VpZXJzdHJhc3NfMS53ZWllcnN0cmFzcykoe1xuICAgIGE6IEJpZ0ludCgxKSxcbiAgICBiOiBCaWdJbnQoJzMxNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDY2NjUnKSxcbiAgICBGcDogKDAsIG1vZHVsYXJfMS5GaWVsZCkoQmlnSW50KCcweDgwMDAwMDAwMDAwMDAxMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScpKSxcbiAgICBuOiBDVVJWRV9PUkRFUixcbiAgICBuQml0TGVuZ3RoLFxuICAgIEd4OiBCaWdJbnQoJzg3NDczOTQ1MTA3ODAwNzc2NjQ1NzQ2NDk4OTc3NDMyMjA4MzY0OTI3ODYwNzUzMzI0OTQ4MTE1MTM4MjQ4MTA3Mjg2ODgwNjYwMicpLFxuICAgIEd5OiBCaWdJbnQoJzE1MjY2Njc5MjA3MTUxODgzMDg2ODU3NTU1NzgxMjk0ODM1MzA0MTQyMDQwMDc4MDczOTQ4MTM0Mjk0MTM4MTIyNTUyNTg2MTQwNycpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZSxcbiAgICAuLi4oMCwgX3Nob3J0d191dGlsc18xLmdldEhhc2gpKHNoYTI1Nl8xLnNoYTI1NiksXG4gICAgYml0czJpbnQsXG4gICAgYml0czJpbnRfbW9kTjogKGJ5dGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhleCA9IHUuYnl0ZXNUb051bWJlckJFKGJ5dGVzKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA2MylcbiAgICAgICAgICAgIGJ5dGVzID0gaGV4MHhUb0J5dGVzKGhleCArICcwJyk7XG4gICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl8xLm1vZCkoYml0czJpbnQoYnl0ZXMpLCBDVVJWRV9PUkRFUik7XG4gICAgfSxcbn0pO1xuZXhwb3J0cy5fc3RhcmtDdXJ2ZSA9IGN1cnZlO1xuZnVuY3Rpb24gZW5zdXJlQnl0ZXMoaGV4KSB7XG4gICAgcmV0dXJuIHUuZW5zdXJlQnl0ZXMoJycsIHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaGV4MHhUb0J5dGVzKGhleCkgOiBoZXgpO1xufVxuZnVuY3Rpb24gbm9ybVByaXZLZXkocHJpdktleSkge1xuICAgIHJldHVybiB1LmJ5dGVzVG9IZXgoZW5zdXJlQnl0ZXMocHJpdktleSkpLnBhZFN0YXJ0KDY0LCAnMCcpO1xufVxuZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZLZXksIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGN1cnZlLmdldFB1YmxpY0tleShub3JtUHJpdktleShwcml2S2V5KSwgaXNDb21wcmVzc2VkKTtcbn1cbmV4cG9ydHMuZ2V0UHVibGljS2V5ID0gZ2V0UHVibGljS2V5O1xuZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZLZXlBLCBwdWJLZXlCKSB7XG4gICAgcmV0dXJuIGN1cnZlLmdldFNoYXJlZFNlY3JldChub3JtUHJpdktleShwcml2S2V5QSksIHB1YktleUIpO1xufVxuZXhwb3J0cy5nZXRTaGFyZWRTZWNyZXQgPSBnZXRTaGFyZWRTZWNyZXQ7XG5mdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpIHtcbiAgICByZXR1cm4gY3VydmUuc2lnbihlbnN1cmVCeXRlcyhtc2dIYXNoKSwgbm9ybVByaXZLZXkocHJpdktleSksIG9wdHMpO1xufVxuZXhwb3J0cy5zaWduID0gc2lnbjtcbmZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YktleSkge1xuICAgIGNvbnN0IHNpZyA9IHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNpZ25hdHVyZSA/IHNpZ25hdHVyZSA6IGVuc3VyZUJ5dGVzKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGN1cnZlLnZlcmlmeShzaWcsIGVuc3VyZUJ5dGVzKG1zZ0hhc2gpLCBlbnN1cmVCeXRlcyhwdWJLZXkpKTtcbn1cbmV4cG9ydHMudmVyaWZ5ID0gdmVyaWZ5O1xuY29uc3QgeyBDVVJWRSwgUHJvamVjdGl2ZVBvaW50LCBTaWduYXR1cmUsIHV0aWxzIH0gPSBjdXJ2ZTtcbmV4cG9ydHMuQ1VSVkUgPSBDVVJWRTtcbmV4cG9ydHMuUHJvamVjdGl2ZVBvaW50ID0gUHJvamVjdGl2ZVBvaW50O1xuZXhwb3J0cy5TaWduYXR1cmUgPSBTaWduYXR1cmU7XG5leHBvcnRzLnV0aWxzID0gdXRpbHM7XG5mdW5jdGlvbiBleHRyYWN0WChieXRlcykge1xuICAgIGNvbnN0IGhleCA9IHUuYnl0ZXNUb0hleChieXRlcy5zdWJhcnJheSgxKSk7XG4gICAgY29uc3Qgc3RyaXBwZWQgPSBoZXgucmVwbGFjZSgvXjArL2dtLCAnJyk7XG4gICAgcmV0dXJuIGAweCR7c3RyaXBwZWR9YDtcbn1cbmZ1bmN0aW9uIHN0cmlwMHgoaGV4KSB7XG4gICAgcmV0dXJuIGhleC5yZXBsYWNlKC9eMHgvaSwgJycpO1xufVxuZnVuY3Rpb24gbnVtYmVyVG8weDE2KG51bSkge1xuICAgIHJldHVybiBgMHgke251bS50b1N0cmluZygxNil9YDtcbn1cbmZ1bmN0aW9uIGdyaW5kS2V5KHNlZWQpIHtcbiAgICBjb25zdCBfc2VlZCA9IGVuc3VyZUJ5dGVzKHNlZWQpO1xuICAgIGNvbnN0IHNoYTI1Nm1hc2sgPSAybiAqKiAyNTZuO1xuICAgIGNvbnN0IGxpbWl0ID0gc2hhMjU2bWFzayAtICgwLCBtb2R1bGFyXzEubW9kKShzaGEyNTZtYXNrLCBDVVJWRV9PUkRFUik7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc2hhMjU2TnVtKHUuY29uY2F0Qnl0ZXMoX3NlZWQsIHUubnVtYmVyVG9WYXJCeXRlc0JFKEJpZ0ludChpKSkpKTtcbiAgICAgICAgaWYgKGtleSA8IGxpbWl0KVxuICAgICAgICAgICAgcmV0dXJuICgwLCBtb2R1bGFyXzEubW9kKShrZXksIENVUlZFX09SREVSKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChpID09PSAxMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyaW5kS2V5IGlzIGJyb2tlbjogdHJpZWQgMTAwayB2YWxzJyk7XG4gICAgfVxufVxuZXhwb3J0cy5ncmluZEtleSA9IGdyaW5kS2V5O1xuZnVuY3Rpb24gZ2V0U3RhcmtLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBleHRyYWN0WChnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgdHJ1ZSkpO1xufVxuZXhwb3J0cy5nZXRTdGFya0tleSA9IGdldFN0YXJrS2V5O1xuZnVuY3Rpb24gZXRoU2lnVG9Qcml2YXRlKHNpZ25hdHVyZSkge1xuICAgIHNpZ25hdHVyZSA9IHN0cmlwMHgoc2lnbmF0dXJlKTtcbiAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gMTMwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGV0aGVyZXVtIHNpZ25hdHVyZScpO1xuICAgIHJldHVybiBncmluZEtleShzaWduYXR1cmUuc3Vic3RyaW5nKDAsIDY0KSk7XG59XG5leHBvcnRzLmV0aFNpZ1RvUHJpdmF0ZSA9IGV0aFNpZ1RvUHJpdmF0ZTtcbmNvbnN0IE1BU0tfMzEgPSAybiAqKiAzMW4gLSAxbjtcbmNvbnN0IGludDMxID0gKG4pID0+IE51bWJlcihuICYgTUFTS18zMSk7XG5mdW5jdGlvbiBnZXRBY2NvdW50UGF0aChsYXllciwgYXBwbGljYXRpb24sIGV0aGVyZXVtQWRkcmVzcywgaW5kZXgpIHtcbiAgICBjb25zdCBsYXllck51bSA9IGludDMxKHNoYTI1Nk51bShsYXllcikpO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uTnVtID0gaW50MzEoc2hhMjU2TnVtKGFwcGxpY2F0aW9uKSk7XG4gICAgY29uc3QgZXRoID0gdS5oZXhUb051bWJlcihzdHJpcDB4KGV0aGVyZXVtQWRkcmVzcykpO1xuICAgIHJldHVybiBgbS8yNjQ1Jy8ke2xheWVyTnVtfScvJHthcHBsaWNhdGlvbk51bX0nLyR7aW50MzEoZXRoKX0nLyR7aW50MzEoZXRoID4+IDMxbil9Jy8ke2luZGV4fWA7XG59XG5leHBvcnRzLmdldEFjY291bnRQYXRoID0gZ2V0QWNjb3VudFBhdGg7XG5jb25zdCBQRURFUlNFTl9QT0lOVFMgPSBbXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0biwgMTcxMzkzMTMyOTU0MDY2MDM3NzAyMzQwNjEwOTE5OTQxMDQxNDgxMDcwNTg2NzI2MDgwMjA3ODE4NzA4MjM0NTUyOTIwNzY5NDk4Nm4sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDk5Njc4MTIwNTgzMzAwODc3NDUxNDUwMDA4MjM3Njc4MzI0OTEwMjM5NjAyMzY2MzQ1NDgxMzQ0NzQyMzE0Nzk3NzM5NzIzMjc2M24sIDE2Njg1MDM2NzY3ODYzNzc3MjU4MDU0ODkzNDQ3NzEwMjM5MjEwNzkxMjY1NTIwMTkxNjAxNTY5MjA2MzQ2MTkyNTU5NzA0ODU3ODFuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMjUxNTYzMjc0NDg5NzUwNTM1MTE3ODg2NDI2NTMzMjIyNDM1Mjk0MDQ2NDI4MzQ3MzI5MjAzNjI3MDIxMjQ5MTY5NjE2MTg0MTg0biwgMTc5ODcxNjAwNzU2MjcyODkwNTI5NTQ4MDY3OTc4OTUyNjMyMjE3NTg2ODMyODA2MjQyMDIzNzQxOTE0MzU5MzAyMTY3NDk5Mjk3M24sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDIxMzg0MTQ2OTUxOTQxNTExNjA5NDMzMDU3MjcwMzY1NzU5NTkxOTUzMDkyMTg2MTE3MzgxOTMyNjExNzkzMTA1MTE4NTQ4MDc0NDduLCAxMTM0MTAyNzY3MzAwNjQ0ODYyNTUxMDIwOTM4NDY1NDAxMzM3ODQ4NjUyODY5MjkwNTI0MjY5MzE0NzQxMDYzOTYxMzUwNzIxNTZuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMzc5OTYyNzQ5NTY3MzUxODg1NzUyNzI0ODkxMjI3OTM4MTgzMDExOTQ5MTI5ODMzNjczMzYyNDQwNjU2NjQzMDg2MDIxMzk0OTQ2biwgNzc2NDk2NDUzNjMzMjk4MTc1NDgzOTg1Mzk4NjQ4NzU4NTg2NTI1OTMzODEyNTM2NjUzMDg5NDAxOTA1MjkyMDYzNzA4ODE2NDIybiwgMW4pLFxuXTtcbmZ1bmN0aW9uIHBlZGVyc2VuUHJlY29tcHV0ZShwMSwgcDIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IHAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ4OyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2gocCk7XG4gICAgICAgIHAgPSBwLmRvdWJsZSgpO1xuICAgIH1cbiAgICBwID0gcDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2gocCk7XG4gICAgICAgIHAgPSBwLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuY29uc3QgUEVERVJTRU5fUE9JTlRTMSA9IHBlZGVyc2VuUHJlY29tcHV0ZShQRURFUlNFTl9QT0lOVFNbMV0sIFBFREVSU0VOX1BPSU5UU1syXSk7XG5jb25zdCBQRURFUlNFTl9QT0lOVFMyID0gcGVkZXJzZW5QcmVjb21wdXRlKFBFREVSU0VOX1BPSU5UU1szXSwgUEVERVJTRU5fUE9JTlRTWzRdKTtcbmZ1bmN0aW9uIHBlZGVyc2VuQXJnKGFyZykge1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFsdWUgPSBhcmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYXJnKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwZWRlcnNlbkFyZzogJHthcmd9YCk7XG4gICAgICAgIHZhbHVlID0gQmlnSW50KGFyZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHUuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKGFyZykpO1xuICAgIH1cbiAgICBpZiAoISgwbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8IGN1cnZlLkNVUlZFLkZwLk9SREVSKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQZWRlcnNlbkFyZyBzaG91bGQgYmUgMCA8PSB2YWx1ZSA8IENVUlZFLlA6ICR7dmFsdWV9YCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcGVkZXJzZW5TaW5nbGUocG9pbnQsIHZhbHVlLCBjb25zdGFudHMpIHtcbiAgICBsZXQgeCA9IHBlZGVyc2VuQXJnKHZhbHVlKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI1MjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHB0ID0gY29uc3RhbnRzW2pdO1xuICAgICAgICBpZiAocHQuZXF1YWxzKHBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2FtZSBwb2ludCcpO1xuICAgICAgICBpZiAoKHggJiAxbikgIT09IDBuKVxuICAgICAgICAgICAgcG9pbnQgPSBwb2ludC5hZGQocHQpO1xuICAgICAgICB4ID4+PSAxbjtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50O1xufVxuZnVuY3Rpb24gcGVkZXJzZW4oeCwgeSkge1xuICAgIGxldCBwb2ludCA9IFBFREVSU0VOX1BPSU5UU1swXTtcbiAgICBwb2ludCA9IHBlZGVyc2VuU2luZ2xlKHBvaW50LCB4LCBQRURFUlNFTl9QT0lOVFMxKTtcbiAgICBwb2ludCA9IHBlZGVyc2VuU2luZ2xlKHBvaW50LCB5LCBQRURFUlNFTl9QT0lOVFMyKTtcbiAgICByZXR1cm4gZXh0cmFjdFgocG9pbnQudG9SYXdCeXRlcyh0cnVlKSk7XG59XG5leHBvcnRzLnBlZGVyc2VuID0gcGVkZXJzZW47XG5mdW5jdGlvbiBoYXNoQ2hhaW4oZGF0YSwgZm4gPSBwZWRlcnNlbikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCBkYXRhLmxlbmd0aCA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBzaG91bGQgYmUgYXJyYXkgb2YgYXQgbGVhc3QgMSBlbGVtZW50Jyk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gbnVtYmVyVG8weDE2KHBlZGVyc2VuQXJnKGRhdGFbMF0pKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShkYXRhKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgaSkgPT4gZm4oaSwgYWNjKSk7XG59XG5leHBvcnRzLmhhc2hDaGFpbiA9IGhhc2hDaGFpbjtcbmNvbnN0IGNvbXB1dGVIYXNoT25FbGVtZW50cyA9IChkYXRhLCBmbiA9IHBlZGVyc2VuKSA9PiBbMCwgLi4uZGF0YSwgZGF0YS5sZW5ndGhdLnJlZHVjZSgoeCwgeSkgPT4gZm4oeCwgeSkpO1xuZXhwb3J0cy5jb21wdXRlSGFzaE9uRWxlbWVudHMgPSBjb21wdXRlSGFzaE9uRWxlbWVudHM7XG5jb25zdCBNQVNLXzI1MCA9IHUuYml0TWFzaygyNTApO1xuY29uc3Qga2VjY2FrID0gKGRhdGEpID0+IHUuYnl0ZXNUb051bWJlckJFKCgwLCBzaGEzXzEua2VjY2FrXzI1NikoZGF0YSkpICYgTUFTS18yNTA7XG5leHBvcnRzLmtlY2NhayA9IGtlY2NhaztcbmNvbnN0IHNoYTI1Nk51bSA9IChkYXRhKSA9PiB1LmJ5dGVzVG9OdW1iZXJCRSgoMCwgc2hhMjU2XzEuc2hhMjU2KShkYXRhKSk7XG5leHBvcnRzLkZwMjUzID0gKDAsIG1vZHVsYXJfMS5GaWVsZCkoQmlnSW50KCcxNDQ3NDAxMTE1NDY2NDUyNTIzMTQxNTM5NTI1NTU4MTEyNjI1MjYzOTc5NDI1Mzc4NjM3MTc2NjAzMzY5NDg5MjM4NTU1ODg1NTY4MScpKTtcbmV4cG9ydHMuRnAyNTEgPSAoMCwgbW9kdWxhcl8xLkZpZWxkKShCaWdJbnQoJzM2MTg1MDI3ODg2NjYxMzEyMTM2OTczMjI3ODMwOTUwNzAxMDU2MjMxMDcyMTUzMzE1OTY2OTk5NzMwOTIwNTYxMzU4NzIwMjA0ODEnKSk7XG5mdW5jdGlvbiBwb3NlaWRvblJvdW5kQ29uc3RhbnQoRnAsIG5hbWUsIGlkeCkge1xuICAgIGNvbnN0IHZhbCA9IEZwLmZyb21CeXRlcygoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgdXRpbHNfMS51dGY4VG9CeXRlcykoYCR7bmFtZX0ke2lkeH1gKSkpO1xuICAgIHJldHVybiBGcC5jcmVhdGUodmFsKTtcbn1cbmZ1bmN0aW9uIF9wb3NlaWRvbk1EUyhGcCwgbmFtZSwgbSwgYXR0ZW1wdCA9IDApIHtcbiAgICBjb25zdCB4X3ZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IHlfdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgeF92YWx1ZXMucHVzaChwb3NlaWRvblJvdW5kQ29uc3RhbnQoRnAsIGAke25hbWV9eGAsIGF0dGVtcHQgKiBtICsgaSkpO1xuICAgICAgICB5X3ZhbHVlcy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChGcCwgYCR7bmFtZX15YCwgYXR0ZW1wdCAqIG0gKyBpKSk7XG4gICAgfVxuICAgIGlmIChuZXcgU2V0KFsuLi54X3ZhbHVlcywgLi4ueV92YWx1ZXNdKS5zaXplICE9PSAyICogbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYIGFuZCBZIHZhbHVlcyBhcmUgbm90IGRpc3RpbmN0Jyk7XG4gICAgcmV0dXJuIHhfdmFsdWVzLm1hcCgoeCkgPT4geV92YWx1ZXMubWFwKCh5KSA9PiBGcC5pbnYoRnAuc3ViKHgsIHkpKSkpO1xufVxuZXhwb3J0cy5fcG9zZWlkb25NRFMgPSBfcG9zZWlkb25NRFM7XG5jb25zdCBNRFNfU01BTEwgPSBbXG4gICAgWzMsIDEsIDFdLFxuICAgIFsxLCAtMSwgMV0sXG4gICAgWzEsIDEsIC0yXSxcbl0ubWFwKChpKSA9PiBpLm1hcChCaWdJbnQpKTtcbmZ1bmN0aW9uIHBvc2VpZG9uQmFzaWMob3B0cywgbWRzKSB7XG4gICAgKDAsIG1vZHVsYXJfMS52YWxpZGF0ZUZpZWxkKShvcHRzLkZwKTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHMucmF0ZSkgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHMuY2FwYWNpdHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2VpZG9uIG9wdHM6ICR7b3B0c31gKTtcbiAgICBjb25zdCBtID0gb3B0cy5yYXRlICsgb3B0cy5jYXBhY2l0eTtcbiAgICBjb25zdCByb3VuZHMgPSBvcHRzLnJvdW5kc0Z1bGwgKyBvcHRzLnJvdW5kc1BhcnRpYWw7XG4gICAgY29uc3Qgcm91bmRDb25zdGFudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKylcbiAgICAgICAgICAgIHJvdy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChvcHRzLkZwLCAnSGFkZXMnLCBtICogaSArIGopKTtcbiAgICAgICAgcm91bmRDb25zdGFudHMucHVzaChyb3cpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSAoMCwgcG9zZWlkb25fMS5wb3NlaWRvbikoe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB0OiBtLFxuICAgICAgICBzYm94UG93ZXI6IDMsXG4gICAgICAgIHJldmVyc2VQYXJ0aWFsUG93SWR4OiB0cnVlLFxuICAgICAgICBtZHMsXG4gICAgICAgIHJvdW5kQ29uc3RhbnRzLFxuICAgIH0pO1xuICAgIHJlcy5tID0gbTtcbiAgICByZXMucmF0ZSA9IG9wdHMucmF0ZTtcbiAgICByZXMuY2FwYWNpdHkgPSBvcHRzLmNhcGFjaXR5O1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLnBvc2VpZG9uQmFzaWMgPSBwb3NlaWRvbkJhc2ljO1xuZnVuY3Rpb24gcG9zZWlkb25DcmVhdGUob3B0cywgbWRzQXR0ZW1wdCA9IDApIHtcbiAgICBjb25zdCBtID0gb3B0cy5yYXRlICsgb3B0cy5jYXBhY2l0eTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG1kc0F0dGVtcHQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIG1kc0F0dGVtcHQ9JHttZHNBdHRlbXB0fWApO1xuICAgIHJldHVybiBwb3NlaWRvbkJhc2ljKG9wdHMsIF9wb3NlaWRvbk1EUyhvcHRzLkZwLCAnSGFkZXNNRFMnLCBtLCBtZHNBdHRlbXB0KSk7XG59XG5leHBvcnRzLnBvc2VpZG9uQ3JlYXRlID0gcG9zZWlkb25DcmVhdGU7XG5leHBvcnRzLnBvc2VpZG9uU21hbGwgPSBwb3NlaWRvbkJhc2ljKHsgRnA6IGV4cG9ydHMuRnAyNTEsIHJhdGU6IDIsIGNhcGFjaXR5OiAxLCByb3VuZHNGdWxsOiA4LCByb3VuZHNQYXJ0aWFsOiA4MyB9LCBNRFNfU01BTEwpO1xuZnVuY3Rpb24gcG9zZWlkb25IYXNoKHgsIHksIGZuID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIGZuKFt4LCB5LCAybl0pWzBdO1xufVxuZXhwb3J0cy5wb3NlaWRvbkhhc2ggPSBwb3NlaWRvbkhhc2g7XG5mdW5jdGlvbiBwb3NlaWRvbkhhc2hGdW5jKHgsIHksIGZuID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIHUubnVtYmVyVG9WYXJCeXRlc0JFKHBvc2VpZG9uSGFzaCh1LmJ5dGVzVG9OdW1iZXJCRSh4KSwgdS5ieXRlc1RvTnVtYmVyQkUoeSksIGZuKSk7XG59XG5leHBvcnRzLnBvc2VpZG9uSGFzaEZ1bmMgPSBwb3NlaWRvbkhhc2hGdW5jO1xuZnVuY3Rpb24gcG9zZWlkb25IYXNoU2luZ2xlKHgsIGZuID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIGZuKFt4LCAwbiwgMW5dKVswXTtcbn1cbmV4cG9ydHMucG9zZWlkb25IYXNoU2luZ2xlID0gcG9zZWlkb25IYXNoU2luZ2xlO1xuZnVuY3Rpb24gcG9zZWlkb25IYXNoTWFueSh2YWx1ZXMsIGZuID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsKSB7XG4gICAgY29uc3QgeyBtLCByYXRlIH0gPSBmbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgYXJyYXkgZXhwZWN0ZWQgaW4gdmFsdWVzJyk7XG4gICAgY29uc3QgcGFkZGVkID0gQXJyYXkuZnJvbSh2YWx1ZXMpO1xuICAgIHBhZGRlZC5wdXNoKDFuKTtcbiAgICB3aGlsZSAocGFkZGVkLmxlbmd0aCAlIHJhdGUgIT09IDApXG4gICAgICAgIHBhZGRlZC5wdXNoKDBuKTtcbiAgICBsZXQgc3RhdGUgPSBuZXcgQXJyYXkobSkuZmlsbCgwbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWQubGVuZ3RoOyBpICs9IHJhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYXRlOyBqKyspXG4gICAgICAgICAgICBzdGF0ZVtqXSArPSBwYWRkZWRbaSArIGpdO1xuICAgICAgICBzdGF0ZSA9IGZuKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlWzBdO1xufVxuZXhwb3J0cy5wb3NlaWRvbkhhc2hNYW55ID0gcG9zZWlkb25IYXNoTWFueTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/schnorr/stark.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/secp256k1.js':
    /*!*********************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/signutil/secp256k1.js ***!
  \*********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.loadUncompressedPublicKey = exports.loadCompressedPublicKey = exports.publicKeyConvert = exports.publicKeyCreate = exports.publicKeyVerify = exports.privateKeyVerify = exports.loadPublicKey = exports.recover = exports.verifyWithNoRecovery = exports.verify = exports.getV = exports.sign = void 0;\nconst elliptic = __importStar(__webpack_require__(/*! ../elliptic */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/elliptic/index.js"));\nconst ec = new elliptic.ec(\'secp256k1\');\nconst base_1 = __webpack_require__(/*! ../base */ "(ssr)/./node_modules/@okxweb3/crypto-lib/dist/base/index.js");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ "(ssr)/./node_modules/bn.js/lib/bn.js"));\nfunction sign(message, seckey, canonical = true) {\n    const sig = ec.sign(Array.from(message), Buffer.from(seckey), { canonical: canonical });\n    return { signature: sig.toBytes(), recovery: sig.recoveryParam };\n}\nexports.sign = sign;\nfunction getV(message, r, s, pubkey, canonical = true) {\n    const p = loadPublicKey(pubkey);\n    if (p == null) {\n        throw new Error(\'pubkey error\');\n    }\n    const point = ec.keyPair({ pub: { x: p.x, y: p.y } }).getPublic();\n    return ec.getKeyRecoveryParam(message, { r: r, s: s }, point, canonical);\n}\nexports.getV = getV;\nfunction verify(message, signature, recovery, publicKey) {\n    const r = recover(signature, recovery, message, true);\n    if (r == null) {\n        return false;\n    }\n    const p = publicKeyConvert(publicKey, true);\n    if (p == null) {\n        return false;\n    }\n    return r.equals(p);\n}\nexports.verify = verify;\nfunction verifyWithNoRecovery(message, signature, publicKey) {\n    const p = loadPublicKey(publicKey);\n    if (p == null) {\n        throw new Error(\'pubkey error\');\n    }\n    const kp = ec.keyPair({ pub: { x: p.x, y: p.y } });\n    const sigObj = { r: (0, base_1.toHex)(signature.slice(0, 32)), s: (0, base_1.toHex)(signature.slice(32, 64)) };\n    return kp.verify(message, sigObj);\n}\nexports.verifyWithNoRecovery = verifyWithNoRecovery;\nfunction recover(sig, recid, msg32, compress) {\n    const sigObj = { r: Array.from(sig.slice(0, 32)), s: Array.from(sig.slice(32, 64)) };\n    const sigr = new bn_js_1.default(sigObj.r);\n    const sigs = new bn_js_1.default(sigObj.s);\n    if (sigr.cmp(ec.curve.n) >= 0 || sigs.cmp(ec.curve.n) >= 0)\n        return null;\n    if (sigr.isZero() || sigs.isZero())\n        return null;\n    let point;\n    try {\n        point = ec.recoverPubKey(Array.from(msg32), sigObj, recid, null);\n    }\n    catch (err) {\n        return null;\n    }\n    return Buffer.from(point.encode(null, compress));\n}\nexports.recover = recover;\nfunction loadPublicKey(pubKey) {\n    const pk = Buffer.from(pubKey);\n    const first = pk[0];\n    switch (first) {\n        case 0x02:\n        case 0x03:\n            if (pk.length !== 33)\n                return null;\n            return loadCompressedPublicKey(first, pk.subarray(1, 33));\n        case 0x04:\n        case 0x06:\n        case 0x07:\n            if (pk.length !== 65)\n                return null;\n            return loadUncompressedPublicKey(first, pk.subarray(1, 33), pk.subarray(33, 65));\n        default:\n            return null;\n    }\n}\nexports.loadPublicKey = loadPublicKey;\nfunction privateKeyVerify(seckey) {\n    const bn = new bn_js_1.default(Array.from(seckey));\n    return bn.cmp(ec.curve.n) < 0 && !bn.isZero();\n}\nexports.privateKeyVerify = privateKeyVerify;\nfunction publicKeyVerify(pubkey) {\n    const pair = loadPublicKey(pubkey);\n    return pair !== null;\n}\nexports.publicKeyVerify = publicKeyVerify;\nfunction publicKeyCreate(seckey, compress) {\n    const point = ec.keyFromPrivate(Array.from(seckey), "bytes").getPublic();\n    return Buffer.from(point.encode(null, compress));\n}\nexports.publicKeyCreate = publicKeyCreate;\nfunction publicKeyConvert(pubkey, compress) {\n    const p = loadPublicKey(pubkey);\n    if (p == null) {\n        return null;\n    }\n    const point = ec.keyPair({ pub: { x: p.x, y: p.y } }).getPublic();\n    return Buffer.from(point.encode(null, compress));\n}\nexports.publicKeyConvert = publicKeyConvert;\nfunction loadCompressedPublicKey(first, xbuf) {\n    let x = new bn_js_1.default(Array.from(xbuf));\n    if (x.cmp(ec.curve.p) >= 0)\n        return null;\n    const xx = x.toRed(ec.curve.red);\n    let y = xx.redSqr().redIMul(xx).redIAdd(ec.curve.b).redSqrt();\n    if ((first === 0x03) !== y.isOdd())\n        y = y.redNeg();\n    return { x: xx, y: y };\n}\nexports.loadCompressedPublicKey = loadCompressedPublicKey;\nfunction loadUncompressedPublicKey(first, xbuf, ybuf) {\n    let x = new bn_js_1.default(Array.from(xbuf));\n    let y = new bn_js_1.default(Array.from(ybuf));\n    if (x.cmp(ec.curve.p) >= 0 || y.cmp(ec.curve.p) >= 0)\n        return null;\n    const xx = x.toRed(ec.curve.red);\n    const yy = y.toRed(ec.curve.red);\n    if ((first === 0x06 || first === 0x07) && yy.isOdd() !== (first === 0x07))\n        return null;\n    const x3 = xx.redSqr().redIMul(xx);\n    if (!yy.redSqr().redISub(x3.redIAdd(ec.curve.b)).isZero())\n        return null;\n    return { x: xx, y: yy };\n}\nexports.loadUncompressedPublicKey = loadUncompressedPublicKey;\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9kaXN0L3NpZ251dGlsL3NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsNEJBQTRCLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxZQUFZO0FBQ3JTLDhCQUE4QixtQkFBTyxDQUFDLG9GQUFhO0FBQ25EO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDRFQUFTO0FBQ2hDLGdDQUFnQyxtQkFBTyxDQUFDLG1EQUFPO0FBQy9DO0FBQ0Esb0VBQW9FLHNCQUFzQjtBQUMxRixhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGtCQUFrQjtBQUN4RCw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxrQkFBa0I7QUFDckQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvZGlzdC9zaWdudXRpbC9zZWNwMjU2azEuanM/MjdiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2FkVW5jb21wcmVzc2VkUHVibGljS2V5ID0gZXhwb3J0cy5sb2FkQ29tcHJlc3NlZFB1YmxpY0tleSA9IGV4cG9ydHMucHVibGljS2V5Q29udmVydCA9IGV4cG9ydHMucHVibGljS2V5Q3JlYXRlID0gZXhwb3J0cy5wdWJsaWNLZXlWZXJpZnkgPSBleHBvcnRzLnByaXZhdGVLZXlWZXJpZnkgPSBleHBvcnRzLmxvYWRQdWJsaWNLZXkgPSBleHBvcnRzLnJlY292ZXIgPSBleHBvcnRzLnZlcmlmeVdpdGhOb1JlY292ZXJ5ID0gZXhwb3J0cy52ZXJpZnkgPSBleHBvcnRzLmdldFYgPSBleHBvcnRzLnNpZ24gPSB2b2lkIDA7XG5jb25zdCBlbGxpcHRpYyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vZWxsaXB0aWNcIikpO1xuY29uc3QgZWMgPSBuZXcgZWxsaXB0aWMuZWMoJ3NlY3AyNTZrMScpO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5mdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHNlY2tleSwgY2Fub25pY2FsID0gdHJ1ZSkge1xuICAgIGNvbnN0IHNpZyA9IGVjLnNpZ24oQXJyYXkuZnJvbShtZXNzYWdlKSwgQnVmZmVyLmZyb20oc2Vja2V5KSwgeyBjYW5vbmljYWw6IGNhbm9uaWNhbCB9KTtcbiAgICByZXR1cm4geyBzaWduYXR1cmU6IHNpZy50b0J5dGVzKCksIHJlY292ZXJ5OiBzaWcucmVjb3ZlcnlQYXJhbSB9O1xufVxuZXhwb3J0cy5zaWduID0gc2lnbjtcbmZ1bmN0aW9uIGdldFYobWVzc2FnZSwgciwgcywgcHVia2V5LCBjYW5vbmljYWwgPSB0cnVlKSB7XG4gICAgY29uc3QgcCA9IGxvYWRQdWJsaWNLZXkocHVia2V5KTtcbiAgICBpZiAocCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHVia2V5IGVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ID0gZWMua2V5UGFpcih7IHB1YjogeyB4OiBwLngsIHk6IHAueSB9IH0pLmdldFB1YmxpYygpO1xuICAgIHJldHVybiBlYy5nZXRLZXlSZWNvdmVyeVBhcmFtKG1lc3NhZ2UsIHsgcjogciwgczogcyB9LCBwb2ludCwgY2Fub25pY2FsKTtcbn1cbmV4cG9ydHMuZ2V0ViA9IGdldFY7XG5mdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNvdmVyeSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgciA9IHJlY292ZXIoc2lnbmF0dXJlLCByZWNvdmVyeSwgbWVzc2FnZSwgdHJ1ZSk7XG4gICAgaWYgKHIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHAgPSBwdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgdHJ1ZSk7XG4gICAgaWYgKHAgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByLmVxdWFscyhwKTtcbn1cbmV4cG9ydHMudmVyaWZ5ID0gdmVyaWZ5O1xuZnVuY3Rpb24gdmVyaWZ5V2l0aE5vUmVjb3ZlcnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBwID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdWJrZXkgZXJyb3InKTtcbiAgICB9XG4gICAgY29uc3Qga3AgPSBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHAueCwgeTogcC55IH0gfSk7XG4gICAgY29uc3Qgc2lnT2JqID0geyByOiAoMCwgYmFzZV8xLnRvSGV4KShzaWduYXR1cmUuc2xpY2UoMCwgMzIpKSwgczogKDAsIGJhc2VfMS50b0hleCkoc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpIH07XG4gICAgcmV0dXJuIGtwLnZlcmlmeShtZXNzYWdlLCBzaWdPYmopO1xufVxuZXhwb3J0cy52ZXJpZnlXaXRoTm9SZWNvdmVyeSA9IHZlcmlmeVdpdGhOb1JlY292ZXJ5O1xuZnVuY3Rpb24gcmVjb3ZlcihzaWcsIHJlY2lkLCBtc2czMiwgY29tcHJlc3MpIHtcbiAgICBjb25zdCBzaWdPYmogPSB7IHI6IEFycmF5LmZyb20oc2lnLnNsaWNlKDAsIDMyKSksIHM6IEFycmF5LmZyb20oc2lnLnNsaWNlKDMyLCA2NCkpIH07XG4gICAgY29uc3Qgc2lnciA9IG5ldyBibl9qc18xLmRlZmF1bHQoc2lnT2JqLnIpO1xuICAgIGNvbnN0IHNpZ3MgPSBuZXcgYm5fanNfMS5kZWZhdWx0KHNpZ09iai5zKTtcbiAgICBpZiAoc2lnci5jbXAoZWMuY3VydmUubikgPj0gMCB8fCBzaWdzLmNtcChlYy5jdXJ2ZS5uKSA+PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcG9pbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcG9pbnQgPSBlYy5yZWNvdmVyUHViS2V5KEFycmF5LmZyb20obXNnMzIpLCBzaWdPYmosIHJlY2lkLCBudWxsKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvaW50LmVuY29kZShudWxsLCBjb21wcmVzcykpO1xufVxuZXhwb3J0cy5yZWNvdmVyID0gcmVjb3ZlcjtcbmZ1bmN0aW9uIGxvYWRQdWJsaWNLZXkocHViS2V5KSB7XG4gICAgY29uc3QgcGsgPSBCdWZmZXIuZnJvbShwdWJLZXkpO1xuICAgIGNvbnN0IGZpcnN0ID0gcGtbMF07XG4gICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIDB4MDI6XG4gICAgICAgIGNhc2UgMHgwMzpcbiAgICAgICAgICAgIGlmIChway5sZW5ndGggIT09IDMzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRDb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBway5zdWJhcnJheSgxLCAzMykpO1xuICAgICAgICBjYXNlIDB4MDQ6XG4gICAgICAgIGNhc2UgMHgwNjpcbiAgICAgICAgY2FzZSAweDA3OlxuICAgICAgICAgICAgaWYgKHBrLmxlbmd0aCAhPT0gNjUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcGsuc3ViYXJyYXkoMSwgMzMpLCBway5zdWJhcnJheSgzMywgNjUpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMubG9hZFB1YmxpY0tleSA9IGxvYWRQdWJsaWNLZXk7XG5mdW5jdGlvbiBwcml2YXRlS2V5VmVyaWZ5KHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IGJuX2pzXzEuZGVmYXVsdChBcnJheS5mcm9tKHNlY2tleSkpO1xuICAgIHJldHVybiBibi5jbXAoZWMuY3VydmUubikgPCAwICYmICFibi5pc1plcm8oKTtcbn1cbmV4cG9ydHMucHJpdmF0ZUtleVZlcmlmeSA9IHByaXZhdGVLZXlWZXJpZnk7XG5mdW5jdGlvbiBwdWJsaWNLZXlWZXJpZnkocHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KTtcbiAgICByZXR1cm4gcGFpciAhPT0gbnVsbDtcbn1cbmV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gcHVibGljS2V5VmVyaWZ5O1xuZnVuY3Rpb24gcHVibGljS2V5Q3JlYXRlKHNlY2tleSwgY29tcHJlc3MpIHtcbiAgICBjb25zdCBwb2ludCA9IGVjLmtleUZyb21Qcml2YXRlKEFycmF5LmZyb20oc2Vja2V5KSwgXCJieXRlc1wiKS5nZXRQdWJsaWMoKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKG51bGwsIGNvbXByZXNzKSk7XG59XG5leHBvcnRzLnB1YmxpY0tleUNyZWF0ZSA9IHB1YmxpY0tleUNyZWF0ZTtcbmZ1bmN0aW9uIHB1YmxpY0tleUNvbnZlcnQocHVia2V5LCBjb21wcmVzcykge1xuICAgIGNvbnN0IHAgPSBsb2FkUHVibGljS2V5KHB1YmtleSk7XG4gICAgaWYgKHAgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcG9pbnQgPSBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHAueCwgeTogcC55IH0gfSkuZ2V0UHVibGljKCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvaW50LmVuY29kZShudWxsLCBjb21wcmVzcykpO1xufVxuZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gcHVibGljS2V5Q29udmVydDtcbmZ1bmN0aW9uIGxvYWRDb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCB4YnVmKSB7XG4gICAgbGV0IHggPSBuZXcgYm5fanNfMS5kZWZhdWx0KEFycmF5LmZyb20oeGJ1ZikpO1xuICAgIGlmICh4LmNtcChlYy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB4eCA9IHgudG9SZWQoZWMuY3VydmUucmVkKTtcbiAgICBsZXQgeSA9IHh4LnJlZFNxcigpLnJlZElNdWwoeHgpLnJlZElBZGQoZWMuY3VydmUuYikucmVkU3FydCgpO1xuICAgIGlmICgoZmlyc3QgPT09IDB4MDMpICE9PSB5LmlzT2RkKCkpXG4gICAgICAgIHkgPSB5LnJlZE5lZygpO1xuICAgIHJldHVybiB7IHg6IHh4LCB5OiB5IH07XG59XG5leHBvcnRzLmxvYWRDb21wcmVzc2VkUHVibGljS2V5ID0gbG9hZENvbXByZXNzZWRQdWJsaWNLZXk7XG5mdW5jdGlvbiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCB4YnVmLCB5YnVmKSB7XG4gICAgbGV0IHggPSBuZXcgYm5fanNfMS5kZWZhdWx0KEFycmF5LmZyb20oeGJ1ZikpO1xuICAgIGxldCB5ID0gbmV3IGJuX2pzXzEuZGVmYXVsdChBcnJheS5mcm9tKHlidWYpKTtcbiAgICBpZiAoeC5jbXAoZWMuY3VydmUucCkgPj0gMCB8fCB5LmNtcChlYy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB4eCA9IHgudG9SZWQoZWMuY3VydmUucmVkKTtcbiAgICBjb25zdCB5eSA9IHkudG9SZWQoZWMuY3VydmUucmVkKTtcbiAgICBpZiAoKGZpcnN0ID09PSAweDA2IHx8IGZpcnN0ID09PSAweDA3KSAmJiB5eS5pc09kZCgpICE9PSAoZmlyc3QgPT09IDB4MDcpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB4MyA9IHh4LnJlZFNxcigpLnJlZElNdWwoeHgpO1xuICAgIGlmICgheXkucmVkU3FyKCkucmVkSVN1Yih4My5yZWRJQWRkKGVjLmN1cnZlLmIpKS5pc1plcm8oKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHsgeDogeHgsIHk6IHl5IH07XG59XG5leHBvcnRzLmxvYWRVbmNvbXByZXNzZWRQdWJsaWNLZXkgPSBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/dist/signutil/secp256k1.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_blake2.js':
    /*!********************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_blake2.js ***!
  \********************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BLAKE2 = exports.SIGMA = void 0;\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js\");\n// prettier-ignore\nexports.SIGMA = new Uint8Array([\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n    // For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n]);\nclass BLAKE2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.length = 0;\n        this.pos = 0;\n        this.finished = false;\n        this.destroyed = false;\n        (0, utils_js_1.assertNumber)(blockLen);\n        (0, utils_js_1.assertNumber)(outputLen);\n        (0, utils_js_1.assertNumber)(keyLen);\n        if (outputLen < 0 || outputLen > keyLen)\n            throw new Error('Blake2: outputLen bigger than keyLen');\n        if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n            throw new Error(`Key should be up 1..${keyLen} byte long or undefined`);\n        if (opts.salt !== undefined && opts.salt.length !== saltLen)\n            throw new Error(`Salt should be ${saltLen} byte long or undefined`);\n        if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n            throw new Error(`Personalization should be ${persLen} byte long or undefined`);\n        this.buffer32 = (0, utils_js_1.u32)((this.buffer = new Uint8Array(blockLen)));\n    }\n    update(data) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        // Main difference with other hashes: there is flag for last block,\n        // so we cannot process current block before we know that there\n        // is the next one. This significantly complicates logic and reduces ability\n        // to do zero-copy processing\n        const { finished, blockLen, buffer, buffer32 } = this;\n        if (finished)\n            throw new Error('digest() was already called');\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            // If buffer is full and we still have input (don't process last block, same as blake2s)\n            if (this.pos === blockLen) {\n                this.compress(buffer32, 0, false);\n                this.pos = 0;\n            }\n            const take = Math.min(blockLen - this.pos, len - pos);\n            const dataOffset = data.byteOffset + pos;\n            // full block && aligned to 4 bytes && not last in input\n            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n                const data32 = new Uint32Array(data.buffer, dataOffset, Math.floor((len - pos) / 4));\n                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n                    this.length += blockLen;\n                    this.compress(data32, pos32, false);\n                }\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            this.length += take;\n            pos += take;\n        }\n        return this;\n    }\n    digestInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array) || out.length < this.outputLen)\n            throw new Error('_Blake2: Invalid output buffer');\n        const { finished, pos, buffer32 } = this;\n        if (finished)\n            throw new Error('digest() was already called');\n        this.finished = true;\n        // Padding\n        this.buffer.subarray(pos).fill(0);\n        this.compress(buffer32, 0, true);\n        const out32 = (0, utils_js_1.u32)(out);\n        this.get().forEach((v, i) => (out32[i] = v));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        const { buffer, length, finished, destroyed, outputLen, pos } = this;\n        to || (to = new this.constructor({ dkLen: outputLen }));\n        to.set(...this.get());\n        to.length = length;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.outputLen = outputLen;\n        to.buffer.set(buffer);\n        to.pos = pos;\n        return to;\n    }\n}\nexports.BLAKE2 = BLAKE2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYmxha2UyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxhQUFhO0FBQzlCLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQXNEO0FBQ3RFLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYmxha2UyLmpzPzI4ZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJMQUtFMiA9IGV4cG9ydHMuU0lHTUEgPSB2b2lkIDA7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydHMuU0lHTUEgPSBuZXcgVWludDhBcnJheShbXG4gICAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAgIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gICAgNywgOSwgMywgMSwgMTMsIDEyLCAxMSwgMTQsIDIsIDYsIDUsIDEwLCA0LCAwLCAxNSwgOCxcbiAgICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAgIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gICAgMTIsIDUsIDEsIDE1LCAxNCwgMTMsIDQsIDEwLCAwLCA3LCA2LCAzLCA5LCAyLCA4LCAxMSxcbiAgICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICAgIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gICAgMTAsIDIsIDgsIDQsIDcsIDYsIDEsIDUsIDE1LCAxMSwgOSwgMTQsIDMsIDEyLCAxMywgMCxcbiAgICAvLyBGb3IgQkxBS0UyYiwgdGhlIHR3byBleHRyYSBwZXJtdXRhdGlvbnMgZm9yIHJvdW5kcyAxMCBhbmQgMTEgYXJlIFNJR01BWzEwLi4xMV0gPSBTSUdNQVswLi4xXS5cbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAgIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG5dKTtcbmNsYXNzIEJMQUtFMiBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgb3B0cyA9IHt9LCBrZXlMZW4sIHNhbHRMZW4sIHBlcnNMZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuYXNzZXJ0TnVtYmVyKShibG9ja0xlbik7XG4gICAgICAgICgwLCB1dGlsc19qc18xLmFzc2VydE51bWJlcikob3V0cHV0TGVuKTtcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuYXNzZXJ0TnVtYmVyKShrZXlMZW4pO1xuICAgICAgICBpZiAob3V0cHV0TGVuIDwgMCB8fCBvdXRwdXRMZW4gPiBrZXlMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JsYWtlMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIGtleUxlbicpO1xuICAgICAgICBpZiAob3B0cy5rZXkgIT09IHVuZGVmaW5lZCAmJiAob3B0cy5rZXkubGVuZ3RoIDwgMSB8fCBvcHRzLmtleS5sZW5ndGggPiBrZXlMZW4pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgc2hvdWxkIGJlIHVwIDEuLiR7a2V5TGVufSBieXRlIGxvbmcgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgIGlmIChvcHRzLnNhbHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnNhbHQubGVuZ3RoICE9PSBzYWx0TGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTYWx0IHNob3VsZCBiZSAke3NhbHRMZW59IGJ5dGUgbG9uZyBvciB1bmRlZmluZWRgKTtcbiAgICAgICAgaWYgKG9wdHMucGVyc29uYWxpemF0aW9uICE9PSB1bmRlZmluZWQgJiYgb3B0cy5wZXJzb25hbGl6YXRpb24ubGVuZ3RoICE9PSBwZXJzTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQZXJzb25hbGl6YXRpb24gc2hvdWxkIGJlICR7cGVyc0xlbn0gYnl0ZSBsb25nIG9yIHVuZGVmaW5lZGApO1xuICAgICAgICB0aGlzLmJ1ZmZlcjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKSgodGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbikpKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnN0YW5jZSBpcyBkZXN0cm95ZWQnKTtcbiAgICAgICAgLy8gTWFpbiBkaWZmZXJlbmNlIHdpdGggb3RoZXIgaGFzaGVzOiB0aGVyZSBpcyBmbGFnIGZvciBsYXN0IGJsb2NrLFxuICAgICAgICAvLyBzbyB3ZSBjYW5ub3QgcHJvY2VzcyBjdXJyZW50IGJsb2NrIGJlZm9yZSB3ZSBrbm93IHRoYXQgdGhlcmVcbiAgICAgICAgLy8gaXMgdGhlIG5leHQgb25lLiBUaGlzIHNpZ25pZmljYW50bHkgY29tcGxpY2F0ZXMgbG9naWMgYW5kIHJlZHVjZXMgYWJpbGl0eVxuICAgICAgICAvLyB0byBkbyB6ZXJvLWNvcHkgcHJvY2Vzc2luZ1xuICAgICAgICBjb25zdCB7IGZpbmlzaGVkLCBibG9ja0xlbiwgYnVmZmVyLCBidWZmZXIzMiB9ID0gdGhpcztcbiAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgLy8gSWYgYnVmZmVyIGlzIGZ1bGwgYW5kIHdlIHN0aWxsIGhhdmUgaW5wdXQgKGRvbid0IHByb2Nlc3MgbGFzdCBibG9jaywgc2FtZSBhcyBibGFrZTJzKVxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3MoYnVmZmVyMzIsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFPZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQgKyBwb3M7XG4gICAgICAgICAgICAvLyBmdWxsIGJsb2NrICYmIGFsaWduZWQgdG8gNCBieXRlcyAmJiBub3QgbGFzdCBpbiBpbnB1dFxuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuICYmICEoZGF0YU9mZnNldCAlIDQpICYmIHBvcyArIHRha2UgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhMzIgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5idWZmZXIsIGRhdGFPZmZzZXQsIE1hdGguZmxvb3IoKGxlbiAtIHBvcykgLyA0KSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zMzIgPSAwOyBwb3MgKyBibG9ja0xlbiA8IGxlbjsgcG9zMzIgKz0gYnVmZmVyMzIubGVuZ3RoLCBwb3MgKz0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gYmxvY2tMZW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3MoZGF0YTMyLCBwb3MzMiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3RhbmNlIGlzIGRlc3Ryb3llZCcpO1xuICAgICAgICBpZiAoIShvdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCBvdXQubGVuZ3RoIDwgdGhpcy5vdXRwdXRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19CbGFrZTI6IEludmFsaWQgb3V0cHV0IGJ1ZmZlcicpO1xuICAgICAgICBjb25zdCB7IGZpbmlzaGVkLCBwb3MsIGJ1ZmZlcjMyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuY29tcHJlc3MoYnVmZmVyMzIsIDAsIHRydWUpO1xuICAgICAgICBjb25zdCBvdXQzMiA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKCh2LCBpKSA9PiAob3V0MzJbaV0gPSB2KSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBvdXRwdXRMZW4sIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoeyBka0xlbjogb3V0cHV0TGVuIH0pKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuQkxBS0UyID0gQkxBS0UyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_blake2.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_sha2.js':
    /*!******************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_sha2.js ***!
  \******************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHA2 = void 0;\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        const { view, buffer, blockLen, finished } = this;\n        if (finished)\n            throw new Error('digest() was already called');\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array) || out.length < this.outputLen)\n            throw new Error('_Sha2: Invalid output buffer');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // NOTE: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64bit of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osbUJBQW1CLG1CQUFPLENBQUMsZ0dBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanM/MTE4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU0hBMiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuY2xhc3MgU0hBMiBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3RhbmNlIGlzIGRlc3Ryb3llZCcpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4sIGZpbmlzaGVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3RhbmNlIGlzIGRlc3Ryb3llZCcpO1xuICAgICAgICBpZiAoIShvdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCBvdXQubGVuZ3RoIDwgdGhpcy5vdXRwdXRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19TaGEyOiBJbnZhbGlkIG91dHB1dCBidWZmZXInKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOT1RFOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0Yml0IG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKG91dCk7XG4gICAgICAgIHRoaXMuZ2V0KCkuZm9yRWFjaCgodiwgaSkgPT4gb3ZpZXcuc2V0VWludDMyKDQgKiBpLCB2LCBpc0xFKSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLlNIQTIgPSBTSEEyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_sha2.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_u64.js':
    /*!*****************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_u64.js ***!
  \*****************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.add5H = exports.add5L = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nexports.split = split;\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLFdBQVcsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGVBQWU7QUFDelc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanM/ZDViYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkNUggPSBleHBvcnRzLmFkZDVMID0gZXhwb3J0cy5hZGQ0SCA9IGV4cG9ydHMuYWRkNEwgPSBleHBvcnRzLmFkZDNIID0gZXhwb3J0cy5hZGQzTCA9IGV4cG9ydHMuYWRkID0gZXhwb3J0cy5yb3RsQkwgPSBleHBvcnRzLnJvdGxCSCA9IGV4cG9ydHMucm90bFNMID0gZXhwb3J0cy5yb3RsU0ggPSBleHBvcnRzLnJvdHIzMkwgPSBleHBvcnRzLnJvdHIzMkggPSBleHBvcnRzLnJvdHJCTCA9IGV4cG9ydHMucm90ckJIID0gZXhwb3J0cy5yb3RyU0wgPSBleHBvcnRzLnJvdHJTSCA9IGV4cG9ydHMuc2hyU0wgPSBleHBvcnRzLnNoclNIID0gZXhwb3J0cy50b0JpZyA9IGV4cG9ydHMuc3BsaXQgPSBleHBvcnRzLmZyb21CaWcgPSB2b2lkIDA7XG5jb25zdCBVMzJfTUFTSzY0ID0gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmV4cG9ydHMuZnJvbUJpZyA9IGZyb21CaWc7XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG5leHBvcnRzLnRvQmlnID0gdG9CaWc7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgbCwgcykgPT4gaCA+Pj4gcztcbmV4cG9ydHMuc2hyU0ggPSBzaHJTSDtcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbmV4cG9ydHMuc2hyU0wgPSBzaHJTTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90clNIID0gcm90clNIO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbmV4cG9ydHMucm90clNMID0gcm90clNMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5leHBvcnRzLnJvdHJCSCA9IHJvdHJCSDtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RyQkwgPSByb3RyQkw7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuZXhwb3J0cy5yb3RyMzJIID0gcm90cjMySDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgbCkgPT4gaDtcbmV4cG9ydHMucm90cjMyTCA9IHJvdHIzMkw7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNIID0gcm90bFNIO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNMID0gcm90bFNMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90bEJIID0gcm90bEJIO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCTCA9IHJvdGxCTDtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbmV4cG9ydHMuYWRkID0gYWRkO1xuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuZXhwb3J0cy5hZGQzTCA9IGFkZDNMO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDNIID0gYWRkM0g7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmV4cG9ydHMuYWRkNEwgPSBhZGQ0TDtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ0SCA9IGFkZDRIO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmV4cG9ydHMuYWRkNUwgPSBhZGQ1TDtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ1SCA9IGFkZDVIO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_u64.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2b.js':
    /*!********************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2b.js ***!
  \********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.blake2b = void 0;\nconst blake2 = __importStar(__webpack_require__(/*! ./_blake2.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_blake2.js"));\nconst u64 = __importStar(__webpack_require__(/*! ./_u64.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_u64.js"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js");\n// Same as SHA-512 but LE\n// prettier-ignore\nconst IV = new Uint32Array([\n    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19\n]);\n// Temporary buffer\nconst BUF = new Uint32Array(32);\n// Mixing function G splitted in two halfs\nfunction G1(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore\n    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore\n    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore\n    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 32)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 24)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n    (BUF[2 * a] = Al), (BUF[2 * a + 1] = Ah);\n    (BUF[2 * b] = Bl), (BUF[2 * b + 1] = Bh);\n    (BUF[2 * c] = Cl), (BUF[2 * c + 1] = Ch);\n    (BUF[2 * d] = Dl), (BUF[2 * d + 1] = Dh);\n}\nfunction G2(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore\n    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore\n    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore\n    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 16)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 63)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n    (BUF[2 * a] = Al), (BUF[2 * a + 1] = Ah);\n    (BUF[2 * b] = Bl), (BUF[2 * b + 1] = Bh);\n    (BUF[2 * c] = Cl), (BUF[2 * c + 1] = Ch);\n    (BUF[2 * d] = Dl), (BUF[2 * d + 1] = Dh);\n}\nclass BLAKE2b extends blake2.BLAKE2 {\n    constructor(opts = {}) {\n        super(128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);\n        // Same as SHA-512, but LE\n        this.v0l = IV[0] | 0;\n        this.v0h = IV[1] | 0;\n        this.v1l = IV[2] | 0;\n        this.v1h = IV[3] | 0;\n        this.v2l = IV[4] | 0;\n        this.v2h = IV[5] | 0;\n        this.v3l = IV[6] | 0;\n        this.v3h = IV[7] | 0;\n        this.v4l = IV[8] | 0;\n        this.v4h = IV[9] | 0;\n        this.v5l = IV[10] | 0;\n        this.v5h = IV[11] | 0;\n        this.v6l = IV[12] | 0;\n        this.v6h = IV[13] | 0;\n        this.v7l = IV[14] | 0;\n        this.v7h = IV[15] | 0;\n        const keyLength = opts.key ? opts.key.length : 0;\n        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (opts.salt) {\n            const salt = (0, utils_js_1.u32)((0, utils_js_1.toBytes)(opts.salt));\n            this.v4l ^= salt[0];\n            this.v4h ^= salt[1];\n            this.v5l ^= salt[2];\n            this.v5h ^= salt[3];\n        }\n        if (opts.personalization) {\n            const pers = (0, utils_js_1.u32)((0, utils_js_1.toBytes)(opts.personalization));\n            this.v6l ^= pers[0];\n            this.v6h ^= pers[1];\n            this.v7l ^= pers[2];\n            this.v7h ^= pers[3];\n        }\n        if (opts.key) {\n            // Pad to blockLen and update\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set((0, utils_js_1.toBytes)(opts.key));\n            this.update(tmp);\n        }\n    }\n    // prettier-ignore\n    get() {\n        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n    }\n    // prettier-ignore\n    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n        this.v0l = v0l | 0;\n        this.v0h = v0h | 0;\n        this.v1l = v1l | 0;\n        this.v1h = v1h | 0;\n        this.v2l = v2l | 0;\n        this.v2h = v2h | 0;\n        this.v3l = v3l | 0;\n        this.v3h = v3h | 0;\n        this.v4l = v4l | 0;\n        this.v4h = v4h | 0;\n        this.v5l = v5l | 0;\n        this.v5h = v5h | 0;\n        this.v6l = v6l | 0;\n        this.v6h = v6h | 0;\n        this.v7l = v7l | 0;\n        this.v7h = v7h | 0;\n    }\n    compress(msg, offset, isLast) {\n        this.get().forEach((v, i) => (BUF[i] = v)); // First half from state.\n        BUF.set(IV, 16); // Second half from IV.\n        let { h, l } = u64.fromBig(BigInt(this.length));\n        BUF[24] = IV[8] ^ l; // Low word of the offset.\n        BUF[25] = IV[9] ^ h; // High word.\n        // Invert all bits for last block\n        if (isLast) {\n            BUF[28] = ~BUF[28];\n            BUF[29] = ~BUF[29];\n        }\n        let j = 0;\n        const s = blake2.SIGMA;\n        for (let i = 0; i < 12; i++) {\n            G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n            G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n        }\n        this.v0l ^= BUF[0] ^ BUF[16];\n        this.v0h ^= BUF[1] ^ BUF[17];\n        this.v1l ^= BUF[2] ^ BUF[18];\n        this.v1h ^= BUF[3] ^ BUF[19];\n        this.v2l ^= BUF[4] ^ BUF[20];\n        this.v2h ^= BUF[5] ^ BUF[21];\n        this.v3l ^= BUF[6] ^ BUF[22];\n        this.v3h ^= BUF[7] ^ BUF[23];\n        this.v4l ^= BUF[8] ^ BUF[24];\n        this.v4h ^= BUF[9] ^ BUF[25];\n        this.v5l ^= BUF[10] ^ BUF[26];\n        this.v5h ^= BUF[11] ^ BUF[27];\n        this.v6l ^= BUF[12] ^ BUF[28];\n        this.v6h ^= BUF[13] ^ BUF[29];\n        this.v7l ^= BUF[14] ^ BUF[30];\n        this.v7h ^= BUF[15] ^ BUF[31];\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer32.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * BLAKE2b - optimized for 64-bit platforms. JS doesn\'t have uint64, so it\'s slower than BLAKE2s.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, salt, personalization\n */\nexports.blake2b = (0, utils_js_1.wrapConstructorWithOpts)((opts) => new BLAKE2b(opts));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9ibGFrZTJiLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLDRCQUE0QixtQkFBTyxDQUFDLG9HQUFjO0FBQ2xELHlCQUF5QixtQkFBTyxDQUFDLDhGQUFXO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVMsSUFBSSwwQkFBMEI7QUFDOUMsT0FBTyxTQUFTLElBQUksa0RBQWtEO0FBQ3RFO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCO0FBQ0EsT0FBTyxTQUFTLElBQUksMEJBQTBCO0FBQzlDLE9BQU8sU0FBUyxJQUFJLHdEQUF3RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sU0FBUyxJQUFJLDBCQUEwQjtBQUM5QyxPQUFPLFNBQVMsSUFBSSx3REFBd0Q7QUFDNUU7QUFDQSxPQUFPLGVBQWU7QUFDdEI7QUFDQSxPQUFPLFNBQVMsSUFBSSwwQkFBMEI7QUFDOUMsT0FBTyxTQUFTLElBQUksd0RBQXdEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUZBQWlGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELHlCQUF5QjtBQUN6QixjQUFjLE9BQU87QUFDckIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvYmxha2UyYi5qcz81NWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJsYWtlMmIgPSB2b2lkIDA7XG5jb25zdCBibGFrZTIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vX2JsYWtlMi5qc1wiKSk7XG5jb25zdCB1NjQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vX3U2NC5qc1wiKSk7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBTYW1lIGFzIFNIQS01MTIgYnV0IExFXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweGYzYmNjOTA4LCAweDZhMDllNjY3LCAweDg0Y2FhNzNiLCAweGJiNjdhZTg1LCAweGZlOTRmODJiLCAweDNjNmVmMzcyLCAweDVmMWQzNmYxLCAweGE1NGZmNTNhLFxuICAgIDB4YWRlNjgyZDEsIDB4NTEwZTUyN2YsIDB4MmIzZTZjMWYsIDB4OWIwNTY4OGMsIDB4ZmI0MWJkNmIsIDB4MWY4M2Q5YWIsIDB4MTM3ZTIxNzksIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgQlVGID0gbmV3IFVpbnQzMkFycmF5KDMyKTtcbi8vIE1peGluZyBmdW5jdGlvbiBHIHNwbGl0dGVkIGluIHR3byBoYWxmc1xuZnVuY3Rpb24gRzEoYSwgYiwgYywgZCwgbXNnLCB4KSB7XG4gICAgLy8gTk9URTogViBpcyBMRSBoZXJlXG4gICAgY29uc3QgWGwgPSBtc2dbeF0sIFhoID0gbXNnW3ggKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEFsID0gQlVGWzIgKiBhXSwgQWggPSBCVUZbMiAqIGEgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEJsID0gQlVGWzIgKiBiXSwgQmggPSBCVUZbMiAqIGIgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IENsID0gQlVGWzIgKiBjXSwgQ2ggPSBCVUZbMiAqIGMgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IERsID0gQlVGWzIgKiBkXSwgRGggPSBCVUZbMiAqIGQgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgLy8gdlthXSA9ICh2W2FdICsgdltiXSArIHgpIHwgMDtcbiAgICBsZXQgbGwgPSB1NjQuYWRkM0woQWwsIEJsLCBYbCk7XG4gICAgQWggPSB1NjQuYWRkM0gobGwsIEFoLCBCaCwgWGgpO1xuICAgIEFsID0gbGwgfCAwO1xuICAgIC8vIHZbZF0gPSByb3RyKHZbZF0gXiB2W2FdLCAzMilcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IERoIF4gQWgsIERsOiBEbCBeIEFsIH0pO1xuICAgICh7IERoLCBEbCB9ID0geyBEaDogdTY0LnJvdHIzMkgoRGgsIERsKSwgRGw6IHU2NC5yb3RyMzJMKERoLCBEbCkgfSk7XG4gICAgLy8gdltjXSA9ICh2W2NdICsgdltkXSkgfCAwO1xuICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZChDaCwgQ2wsIERoLCBEbCkpO1xuICAgIC8vIHZbYl0gPSByb3RyKHZbYl0gXiB2W2NdLCAyNClcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IEJoIF4gQ2gsIEJsOiBCbCBeIENsIH0pO1xuICAgICh7IEJoLCBCbCB9ID0geyBCaDogdTY0LnJvdHJTSChCaCwgQmwsIDI0KSwgQmw6IHU2NC5yb3RyU0woQmgsIEJsLCAyNCkgfSk7XG4gICAgKEJVRlsyICogYV0gPSBBbCksIChCVUZbMiAqIGEgKyAxXSA9IEFoKTtcbiAgICAoQlVGWzIgKiBiXSA9IEJsKSwgKEJVRlsyICogYiArIDFdID0gQmgpO1xuICAgIChCVUZbMiAqIGNdID0gQ2wpLCAoQlVGWzIgKiBjICsgMV0gPSBDaCk7XG4gICAgKEJVRlsyICogZF0gPSBEbCksIChCVUZbMiAqIGQgKyAxXSA9IERoKTtcbn1cbmZ1bmN0aW9uIEcyKGEsIGIsIGMsIGQsIG1zZywgeCkge1xuICAgIC8vIE5PVEU6IFYgaXMgTEUgaGVyZVxuICAgIGNvbnN0IFhsID0gbXNnW3hdLCBYaCA9IG1zZ1t4ICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBBbCA9IEJVRlsyICogYV0sIEFoID0gQlVGWzIgKiBhICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBCbCA9IEJVRlsyICogYl0sIEJoID0gQlVGWzIgKiBiICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBDbCA9IEJVRlsyICogY10sIENoID0gQlVGWzIgKiBjICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBEbCA9IEJVRlsyICogZF0sIERoID0gQlVGWzIgKiBkICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIC8vIHZbYV0gPSAodlthXSArIHZbYl0gKyB4KSB8IDA7XG4gICAgbGV0IGxsID0gdTY0LmFkZDNMKEFsLCBCbCwgWGwpO1xuICAgIEFoID0gdTY0LmFkZDNIKGxsLCBBaCwgQmgsIFhoKTtcbiAgICBBbCA9IGxsIHwgMDtcbiAgICAvLyB2W2RdID0gcm90cih2W2RdIF4gdlthXSwgMTYpXG4gICAgKHsgRGgsIERsIH0gPSB7IERoOiBEaCBeIEFoLCBEbDogRGwgXiBBbCB9KTtcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IHU2NC5yb3RyU0goRGgsIERsLCAxNiksIERsOiB1NjQucm90clNMKERoLCBEbCwgMTYpIH0pO1xuICAgIC8vIHZbY10gPSAodltjXSArIHZbZF0pIHwgMDtcbiAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQoQ2gsIENsLCBEaCwgRGwpKTtcbiAgICAvLyB2W2JdID0gcm90cih2W2JdIF4gdltjXSwgNjMpXG4gICAgKHsgQmgsIEJsIH0gPSB7IEJoOiBCaCBeIENoLCBCbDogQmwgXiBDbCB9KTtcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IHU2NC5yb3RyQkgoQmgsIEJsLCA2MyksIEJsOiB1NjQucm90ckJMKEJoLCBCbCwgNjMpIH0pO1xuICAgIChCVUZbMiAqIGFdID0gQWwpLCAoQlVGWzIgKiBhICsgMV0gPSBBaCk7XG4gICAgKEJVRlsyICogYl0gPSBCbCksIChCVUZbMiAqIGIgKyAxXSA9IEJoKTtcbiAgICAoQlVGWzIgKiBjXSA9IENsKSwgKEJVRlsyICogYyArIDFdID0gQ2gpO1xuICAgIChCVUZbMiAqIGRdID0gRGwpLCAoQlVGWzIgKiBkICsgMV0gPSBEaCk7XG59XG5jbGFzcyBCTEFLRTJiIGV4dGVuZHMgYmxha2UyLkJMQUtFMiB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKDEyOCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gNjQgOiBvcHRzLmRrTGVuLCBvcHRzLCA2NCwgMTYsIDE2KTtcbiAgICAgICAgLy8gU2FtZSBhcyBTSEEtNTEyLCBidXQgTEVcbiAgICAgICAgdGhpcy52MGwgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMudjBoID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLnYxbCA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy52MWggPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMudjJsID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLnYyaCA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy52M2wgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMudjNoID0gSVZbN10gfCAwO1xuICAgICAgICB0aGlzLnY0bCA9IElWWzhdIHwgMDtcbiAgICAgICAgdGhpcy52NGggPSBJVls5XSB8IDA7XG4gICAgICAgIHRoaXMudjVsID0gSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy52NWggPSBJVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLnY2bCA9IElWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMudjZoID0gSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy52N2wgPSBJVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLnY3aCA9IElWWzE1XSB8IDA7XG4gICAgICAgIGNvbnN0IGtleUxlbmd0aCA9IG9wdHMua2V5ID8gb3B0cy5rZXkubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy52MGwgXj0gdGhpcy5vdXRwdXRMZW4gfCAoa2V5TGVuZ3RoIDw8IDgpIHwgKDB4MDEgPDwgMTYpIHwgKDB4MDEgPDwgMjQpO1xuICAgICAgICBpZiAob3B0cy5zYWx0KSB7XG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gKDAsIHV0aWxzX2pzXzEudTMyKSgoMCwgdXRpbHNfanNfMS50b0J5dGVzKShvcHRzLnNhbHQpKTtcbiAgICAgICAgICAgIHRoaXMudjRsIF49IHNhbHRbMF07XG4gICAgICAgICAgICB0aGlzLnY0aCBePSBzYWx0WzFdO1xuICAgICAgICAgICAgdGhpcy52NWwgXj0gc2FsdFsyXTtcbiAgICAgICAgICAgIHRoaXMudjVoIF49IHNhbHRbM107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucGVyc29uYWxpemF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwZXJzID0gKDAsIHV0aWxzX2pzXzEudTMyKSgoMCwgdXRpbHNfanNfMS50b0J5dGVzKShvcHRzLnBlcnNvbmFsaXphdGlvbikpO1xuICAgICAgICAgICAgdGhpcy52NmwgXj0gcGVyc1swXTtcbiAgICAgICAgICAgIHRoaXMudjZoIF49IHBlcnNbMV07XG4gICAgICAgICAgICB0aGlzLnY3bCBePSBwZXJzWzJdO1xuICAgICAgICAgICAgdGhpcy52N2ggXj0gcGVyc1szXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5rZXkpIHtcbiAgICAgICAgICAgIC8vIFBhZCB0byBibG9ja0xlbiBhbmQgdXBkYXRlXG4gICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuKTtcbiAgICAgICAgICAgIHRtcC5zZXQoKDAsIHV0aWxzX2pzXzEudG9CeXRlcykob3B0cy5rZXkpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBsZXQgeyB2MGwsIHYwaCwgdjFsLCB2MWgsIHYybCwgdjJoLCB2M2wsIHYzaCwgdjRsLCB2NGgsIHY1bCwgdjVoLCB2NmwsIHY2aCwgdjdsLCB2N2ggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbdjBsLCB2MGgsIHYxbCwgdjFoLCB2MmwsIHYyaCwgdjNsLCB2M2gsIHY0bCwgdjRoLCB2NWwsIHY1aCwgdjZsLCB2NmgsIHY3bCwgdjdoXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KHYwbCwgdjBoLCB2MWwsIHYxaCwgdjJsLCB2MmgsIHYzbCwgdjNoLCB2NGwsIHY0aCwgdjVsLCB2NWgsIHY2bCwgdjZoLCB2N2wsIHY3aCkge1xuICAgICAgICB0aGlzLnYwbCA9IHYwbCB8IDA7XG4gICAgICAgIHRoaXMudjBoID0gdjBoIHwgMDtcbiAgICAgICAgdGhpcy52MWwgPSB2MWwgfCAwO1xuICAgICAgICB0aGlzLnYxaCA9IHYxaCB8IDA7XG4gICAgICAgIHRoaXMudjJsID0gdjJsIHwgMDtcbiAgICAgICAgdGhpcy52MmggPSB2MmggfCAwO1xuICAgICAgICB0aGlzLnYzbCA9IHYzbCB8IDA7XG4gICAgICAgIHRoaXMudjNoID0gdjNoIHwgMDtcbiAgICAgICAgdGhpcy52NGwgPSB2NGwgfCAwO1xuICAgICAgICB0aGlzLnY0aCA9IHY0aCB8IDA7XG4gICAgICAgIHRoaXMudjVsID0gdjVsIHwgMDtcbiAgICAgICAgdGhpcy52NWggPSB2NWggfCAwO1xuICAgICAgICB0aGlzLnY2bCA9IHY2bCB8IDA7XG4gICAgICAgIHRoaXMudjZoID0gdjZoIHwgMDtcbiAgICAgICAgdGhpcy52N2wgPSB2N2wgfCAwO1xuICAgICAgICB0aGlzLnY3aCA9IHY3aCB8IDA7XG4gICAgfVxuICAgIGNvbXByZXNzKG1zZywgb2Zmc2V0LCBpc0xhc3QpIHtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKCh2LCBpKSA9PiAoQlVGW2ldID0gdikpOyAvLyBGaXJzdCBoYWxmIGZyb20gc3RhdGUuXG4gICAgICAgIEJVRi5zZXQoSVYsIDE2KTsgLy8gU2Vjb25kIGhhbGYgZnJvbSBJVi5cbiAgICAgICAgbGV0IHsgaCwgbCB9ID0gdTY0LmZyb21CaWcoQmlnSW50KHRoaXMubGVuZ3RoKSk7XG4gICAgICAgIEJVRlsyNF0gPSBJVls4XSBeIGw7IC8vIExvdyB3b3JkIG9mIHRoZSBvZmZzZXQuXG4gICAgICAgIEJVRlsyNV0gPSBJVls5XSBeIGg7IC8vIEhpZ2ggd29yZC5cbiAgICAgICAgLy8gSW52ZXJ0IGFsbCBiaXRzIGZvciBsYXN0IGJsb2NrXG4gICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgIEJVRlsyOF0gPSB+QlVGWzI4XTtcbiAgICAgICAgICAgIEJVRlsyOV0gPSB+QlVGWzI5XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGNvbnN0IHMgPSBibGFrZTIuU0lHTUE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgRzEoMCwgNCwgOCwgMTIsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMigwLCA0LCA4LCAxMiwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxKDEsIDUsIDksIDEzLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzIoMSwgNSwgOSwgMTMsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMSgyLCA2LCAxMCwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMigyLCA2LCAxMCwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMSgzLCA3LCAxMSwgMTUsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMigzLCA3LCAxMSwgMTUsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMSgwLCA1LCAxMCwgMTUsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMigwLCA1LCAxMCwgMTUsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMSgxLCA2LCAxMSwgMTIsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMigxLCA2LCAxMSwgMTIsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMSgyLCA3LCA4LCAxMywgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyKDIsIDcsIDgsIDEzLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzEoMywgNCwgOSwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMigzLCA0LCA5LCAxNCwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnYwbCBePSBCVUZbMF0gXiBCVUZbMTZdO1xuICAgICAgICB0aGlzLnYwaCBePSBCVUZbMV0gXiBCVUZbMTddO1xuICAgICAgICB0aGlzLnYxbCBePSBCVUZbMl0gXiBCVUZbMThdO1xuICAgICAgICB0aGlzLnYxaCBePSBCVUZbM10gXiBCVUZbMTldO1xuICAgICAgICB0aGlzLnYybCBePSBCVUZbNF0gXiBCVUZbMjBdO1xuICAgICAgICB0aGlzLnYyaCBePSBCVUZbNV0gXiBCVUZbMjFdO1xuICAgICAgICB0aGlzLnYzbCBePSBCVUZbNl0gXiBCVUZbMjJdO1xuICAgICAgICB0aGlzLnYzaCBePSBCVUZbN10gXiBCVUZbMjNdO1xuICAgICAgICB0aGlzLnY0bCBePSBCVUZbOF0gXiBCVUZbMjRdO1xuICAgICAgICB0aGlzLnY0aCBePSBCVUZbOV0gXiBCVUZbMjVdO1xuICAgICAgICB0aGlzLnY1bCBePSBCVUZbMTBdIF4gQlVGWzI2XTtcbiAgICAgICAgdGhpcy52NWggXj0gQlVGWzExXSBeIEJVRlsyN107XG4gICAgICAgIHRoaXMudjZsIF49IEJVRlsxMl0gXiBCVUZbMjhdO1xuICAgICAgICB0aGlzLnY2aCBePSBCVUZbMTNdIF4gQlVGWzI5XTtcbiAgICAgICAgdGhpcy52N2wgXj0gQlVGWzE0XSBeIEJVRlszMF07XG4gICAgICAgIHRoaXMudjdoIF49IEJVRlsxNV0gXiBCVUZbMzFdO1xuICAgICAgICBCVUYuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlcjMyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbi8qKlxuICogQkxBS0UyYiAtIG9wdGltaXplZCBmb3IgNjQtYml0IHBsYXRmb3Jtcy4gSlMgZG9lc24ndCBoYXZlIHVpbnQ2NCwgc28gaXQncyBzbG93ZXIgdGhhbiBCTEFLRTJzLlxuICogQHBhcmFtIG1zZyAtIG1lc3NhZ2UgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqIEBwYXJhbSBvcHRzIC0gZGtMZW4sIGtleSwgc2FsdCwgcGVyc29uYWxpemF0aW9uXG4gKi9cbmV4cG9ydHMuYmxha2UyYiA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKSgob3B0cykgPT4gbmV3IEJMQUtFMmIob3B0cykpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2b.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2s.js':
    /*!********************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2s.js ***!
  \********************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.blake2s = exports.compress = exports.IV = void 0;\nconst u64 = __importStar(__webpack_require__(/*! ./_u64.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_u64.js"));\nconst blake2 = __importStar(__webpack_require__(/*! ./_blake2.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_blake2.js"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js");\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19)\n// same as SHA-256\n// prettier-ignore\nexports.IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Mixing function G splitted in two halfs\nfunction G1(a, b, c, d, x) {\n    a = (a + b + x) | 0;\n    d = (0, utils_js_1.rotr)(d ^ a, 16);\n    c = (c + d) | 0;\n    b = (0, utils_js_1.rotr)(b ^ c, 12);\n    return { a, b, c, d };\n}\nfunction G2(a, b, c, d, x) {\n    a = (a + b + x) | 0;\n    d = (0, utils_js_1.rotr)(d ^ a, 8);\n    c = (c + d) | 0;\n    b = (0, utils_js_1.rotr)(b ^ c, 7);\n    return { a, b, c, d };\n}\n// prettier-ignore\nfunction compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    let j = 0;\n    for (let i = 0; i < rounds; i++) {\n        ({ a: v0, b: v4, c: v8, d: v12 } = G1(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v0, b: v4, c: v8, d: v12 } = G2(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = G1(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = G2(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = G1(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = G2(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = G1(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = G2(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = G1(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = G2(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = G1(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = G2(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = G1(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = G2(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = G1(v3, v4, v9, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = G2(v3, v4, v9, v14, msg[offset + s[j++]]));\n    }\n    return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\nexports.compress = compress;\nclass BLAKE2s extends blake2.BLAKE2 {\n    constructor(opts = {}) {\n        super(64, opts.dkLen === undefined ? 32 : opts.dkLen, opts, 32, 8, 8);\n        // Internal state, same as SHA-256\n        this.v0 = exports.IV[0] | 0;\n        this.v1 = exports.IV[1] | 0;\n        this.v2 = exports.IV[2] | 0;\n        this.v3 = exports.IV[3] | 0;\n        this.v4 = exports.IV[4] | 0;\n        this.v5 = exports.IV[5] | 0;\n        this.v6 = exports.IV[6] | 0;\n        this.v7 = exports.IV[7] | 0;\n        const keyLength = opts.key ? opts.key.length : 0;\n        this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (opts.salt) {\n            const salt = (0, utils_js_1.u32)((0, utils_js_1.toBytes)(opts.salt));\n            this.v4 ^= salt[0];\n            this.v5 ^= salt[1];\n        }\n        if (opts.personalization) {\n            const pers = (0, utils_js_1.u32)((0, utils_js_1.toBytes)(opts.personalization));\n            this.v6 ^= pers[0];\n            this.v7 ^= pers[1];\n        }\n        if (opts.key) {\n            // Pad to blockLen and update\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set((0, utils_js_1.toBytes)(opts.key));\n            this.update(tmp);\n        }\n    }\n    get() {\n        const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n        return [v0, v1, v2, v3, v4, v5, v6, v7];\n    }\n    // prettier-ignore\n    set(v0, v1, v2, v3, v4, v5, v6, v7) {\n        this.v0 = v0 | 0;\n        this.v1 = v1 | 0;\n        this.v2 = v2 | 0;\n        this.v3 = v3 | 0;\n        this.v4 = v4 | 0;\n        this.v5 = v5 | 0;\n        this.v6 = v6 | 0;\n        this.v7 = v7 | 0;\n    }\n    compress(msg, offset, isLast) {\n        const { h, l } = u64.fromBig(BigInt(this.length));\n        // prettier-ignore\n        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(blake2.SIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, exports.IV[0], exports.IV[1], exports.IV[2], exports.IV[3], l ^ exports.IV[4], h ^ exports.IV[5], isLast ? ~exports.IV[6] : exports.IV[6], exports.IV[7]);\n        this.v0 ^= v0 ^ v8;\n        this.v1 ^= v1 ^ v9;\n        this.v2 ^= v2 ^ v10;\n        this.v3 ^= v3 ^ v11;\n        this.v4 ^= v4 ^ v12;\n        this.v5 ^= v5 ^ v13;\n        this.v6 ^= v6 ^ v14;\n        this.v7 ^= v7 ^ v15;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer32.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * BLAKE2s - optimized for 32-bit platforms. JS doesn\'t have uint64, so it\'s faster than BLAKE2b.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, salt, personalization\n */\nexports.blake2s = (0, utils_js_1.wrapConstructorWithOpts)((opts) => new BLAKE2s(opts));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9ibGFrZTJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGdCQUFnQixHQUFHLFVBQVU7QUFDL0MseUJBQXlCLG1CQUFPLENBQUMsOEZBQVc7QUFDNUMsNEJBQTRCLG1CQUFPLENBQUMsb0dBQWM7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLCtCQUErQjtBQUMxQyxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDhCQUE4QjtBQUN6QztBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGdCQUFnQix1RUFBdUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2JsYWtlMnMuanM/ZmVmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ibGFrZTJzID0gZXhwb3J0cy5jb21wcmVzcyA9IGV4cG9ydHMuSVYgPSB2b2lkIDA7XG5jb25zdCB1NjQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vX3U2NC5qc1wiKSk7XG5jb25zdCBibGFrZTIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vX2JsYWtlMi5qc1wiKSk7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBJbml0aWFsIHN0YXRlOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSlcbi8vIHNhbWUgYXMgU0hBLTI1NlxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnRzLklWID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIE1peGluZyBmdW5jdGlvbiBHIHNwbGl0dGVkIGluIHR3byBoYWxmc1xuZnVuY3Rpb24gRzEoYSwgYiwgYywgZCwgeCkge1xuICAgIGEgPSAoYSArIGIgKyB4KSB8IDA7XG4gICAgZCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKGQgXiBhLCAxNik7XG4gICAgYyA9IChjICsgZCkgfCAwO1xuICAgIGIgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShiIF4gYywgMTIpO1xuICAgIHJldHVybiB7IGEsIGIsIGMsIGQgfTtcbn1cbmZ1bmN0aW9uIEcyKGEsIGIsIGMsIGQsIHgpIHtcbiAgICBhID0gKGEgKyBiICsgeCkgfCAwO1xuICAgIGQgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShkIF4gYSwgOCk7XG4gICAgYyA9IChjICsgZCkgfCAwO1xuICAgIGIgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShiIF4gYywgNyk7XG4gICAgcmV0dXJuIHsgYSwgYiwgYywgZCB9O1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjb21wcmVzcyhzLCBvZmZzZXQsIG1zZywgcm91bmRzLCB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSwgdjEwLCB2MTEsIHYxMiwgdjEzLCB2MTQsIHYxNSkge1xuICAgIGxldCBqID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgICAgICh7IGE6IHYwLCBiOiB2NCwgYzogdjgsIGQ6IHYxMiB9ID0gRzEodjAsIHY0LCB2OCwgdjEyLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MCwgYjogdjQsIGM6IHY4LCBkOiB2MTIgfSA9IEcyKHYwLCB2NCwgdjgsIHYxMiwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjEsIGI6IHY1LCBjOiB2OSwgZDogdjEzIH0gPSBHMSh2MSwgdjUsIHY5LCB2MTMsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYxLCBiOiB2NSwgYzogdjksIGQ6IHYxMyB9ID0gRzIodjEsIHY1LCB2OSwgdjEzLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MiwgYjogdjYsIGM6IHYxMCwgZDogdjE0IH0gPSBHMSh2MiwgdjYsIHYxMCwgdjE0LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MiwgYjogdjYsIGM6IHYxMCwgZDogdjE0IH0gPSBHMih2MiwgdjYsIHYxMCwgdjE0LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MywgYjogdjcsIGM6IHYxMSwgZDogdjE1IH0gPSBHMSh2MywgdjcsIHYxMSwgdjE1LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MywgYjogdjcsIGM6IHYxMSwgZDogdjE1IH0gPSBHMih2MywgdjcsIHYxMSwgdjE1LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MCwgYjogdjUsIGM6IHYxMCwgZDogdjE1IH0gPSBHMSh2MCwgdjUsIHYxMCwgdjE1LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MCwgYjogdjUsIGM6IHYxMCwgZDogdjE1IH0gPSBHMih2MCwgdjUsIHYxMCwgdjE1LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MSwgYjogdjYsIGM6IHYxMSwgZDogdjEyIH0gPSBHMSh2MSwgdjYsIHYxMSwgdjEyLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MSwgYjogdjYsIGM6IHYxMSwgZDogdjEyIH0gPSBHMih2MSwgdjYsIHYxMSwgdjEyLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MiwgYjogdjcsIGM6IHY4LCBkOiB2MTMgfSA9IEcxKHYyLCB2NywgdjgsIHYxMywgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjIsIGI6IHY3LCBjOiB2OCwgZDogdjEzIH0gPSBHMih2MiwgdjcsIHY4LCB2MTMsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYzLCBiOiB2NCwgYzogdjksIGQ6IHYxNCB9ID0gRzEodjMsIHY0LCB2OSwgdjE0LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MywgYjogdjQsIGM6IHY5LCBkOiB2MTQgfSA9IEcyKHYzLCB2NCwgdjksIHYxNCwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUgfTtcbn1cbmV4cG9ydHMuY29tcHJlc3MgPSBjb21wcmVzcztcbmNsYXNzIEJMQUtFMnMgZXh0ZW5kcyBibGFrZTIuQkxBS0UyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoNjQsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IDMyIDogb3B0cy5ka0xlbiwgb3B0cywgMzIsIDgsIDgpO1xuICAgICAgICAvLyBJbnRlcm5hbCBzdGF0ZSwgc2FtZSBhcyBTSEEtMjU2XG4gICAgICAgIHRoaXMudjAgPSBleHBvcnRzLklWWzBdIHwgMDtcbiAgICAgICAgdGhpcy52MSA9IGV4cG9ydHMuSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLnYyID0gZXhwb3J0cy5JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMudjMgPSBleHBvcnRzLklWWzNdIHwgMDtcbiAgICAgICAgdGhpcy52NCA9IGV4cG9ydHMuSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLnY1ID0gZXhwb3J0cy5JVls1XSB8IDA7XG4gICAgICAgIHRoaXMudjYgPSBleHBvcnRzLklWWzZdIHwgMDtcbiAgICAgICAgdGhpcy52NyA9IGV4cG9ydHMuSVZbN10gfCAwO1xuICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBvcHRzLmtleSA/IG9wdHMua2V5Lmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMudjAgXj0gdGhpcy5vdXRwdXRMZW4gfCAoa2V5TGVuZ3RoIDw8IDgpIHwgKDB4MDEgPDwgMTYpIHwgKDB4MDEgPDwgMjQpO1xuICAgICAgICBpZiAob3B0cy5zYWx0KSB7XG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gKDAsIHV0aWxzX2pzXzEudTMyKSgoMCwgdXRpbHNfanNfMS50b0J5dGVzKShvcHRzLnNhbHQpKTtcbiAgICAgICAgICAgIHRoaXMudjQgXj0gc2FsdFswXTtcbiAgICAgICAgICAgIHRoaXMudjUgXj0gc2FsdFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5wZXJzb25hbGl6YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcnMgPSAoMCwgdXRpbHNfanNfMS51MzIpKCgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKG9wdHMucGVyc29uYWxpemF0aW9uKSk7XG4gICAgICAgICAgICB0aGlzLnY2IF49IHBlcnNbMF07XG4gICAgICAgICAgICB0aGlzLnY3IF49IHBlcnNbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMua2V5KSB7XG4gICAgICAgICAgICAvLyBQYWQgdG8gYmxvY2tMZW4gYW5kIHVwZGF0ZVxuICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5ibG9ja0xlbik7XG4gICAgICAgICAgICB0bXAuc2V0KCgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKG9wdHMua2V5KSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0bXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3XTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2Nykge1xuICAgICAgICB0aGlzLnYwID0gdjAgfCAwO1xuICAgICAgICB0aGlzLnYxID0gdjEgfCAwO1xuICAgICAgICB0aGlzLnYyID0gdjIgfCAwO1xuICAgICAgICB0aGlzLnYzID0gdjMgfCAwO1xuICAgICAgICB0aGlzLnY0ID0gdjQgfCAwO1xuICAgICAgICB0aGlzLnY1ID0gdjUgfCAwO1xuICAgICAgICB0aGlzLnY2ID0gdjYgfCAwO1xuICAgICAgICB0aGlzLnY3ID0gdjcgfCAwO1xuICAgIH1cbiAgICBjb21wcmVzcyhtc2csIG9mZnNldCwgaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gdTY0LmZyb21CaWcoQmlnSW50KHRoaXMubGVuZ3RoKSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCB7IHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5LCB2MTAsIHYxMSwgdjEyLCB2MTMsIHYxNCwgdjE1IH0gPSBjb21wcmVzcyhibGFrZTIuU0lHTUEsIG9mZnNldCwgbXNnLCAxMCwgdGhpcy52MCwgdGhpcy52MSwgdGhpcy52MiwgdGhpcy52MywgdGhpcy52NCwgdGhpcy52NSwgdGhpcy52NiwgdGhpcy52NywgZXhwb3J0cy5JVlswXSwgZXhwb3J0cy5JVlsxXSwgZXhwb3J0cy5JVlsyXSwgZXhwb3J0cy5JVlszXSwgbCBeIGV4cG9ydHMuSVZbNF0sIGggXiBleHBvcnRzLklWWzVdLCBpc0xhc3QgPyB+ZXhwb3J0cy5JVls2XSA6IGV4cG9ydHMuSVZbNl0sIGV4cG9ydHMuSVZbN10pO1xuICAgICAgICB0aGlzLnYwIF49IHYwIF4gdjg7XG4gICAgICAgIHRoaXMudjEgXj0gdjEgXiB2OTtcbiAgICAgICAgdGhpcy52MiBePSB2MiBeIHYxMDtcbiAgICAgICAgdGhpcy52MyBePSB2MyBeIHYxMTtcbiAgICAgICAgdGhpcy52NCBePSB2NCBeIHYxMjtcbiAgICAgICAgdGhpcy52NSBePSB2NSBeIHYxMztcbiAgICAgICAgdGhpcy52NiBePSB2NiBeIHYxNDtcbiAgICAgICAgdGhpcy52NyBePSB2NyBeIHYxNTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlcjMyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbi8qKlxuICogQkxBS0UycyAtIG9wdGltaXplZCBmb3IgMzItYml0IHBsYXRmb3Jtcy4gSlMgZG9lc24ndCBoYXZlIHVpbnQ2NCwgc28gaXQncyBmYXN0ZXIgdGhhbiBCTEFLRTJiLlxuICogQHBhcmFtIG1zZyAtIG1lc3NhZ2UgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqIEBwYXJhbSBvcHRzIC0gZGtMZW4sIGtleSwgc2FsdCwgcGVyc29uYWxpemF0aW9uXG4gKi9cbmV4cG9ydHMuYmxha2UycyA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKSgob3B0cykgPT4gbmV3IEJMQUtFMnMob3B0cykpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2s.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake3.js':
    /*!*******************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake3.js ***!
  \*******************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.blake3 = void 0;\nconst u64 = __importStar(__webpack_require__(/*! ./_u64.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_u64.js"));\nconst blake2 = __importStar(__webpack_require__(/*! ./_blake2.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_blake2.js"));\nconst blake2s = __importStar(__webpack_require__(/*! ./blake2s.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake2s.js"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js");\n// Flag bitset\nvar Flags;\n(function (Flags) {\n    Flags[Flags["CHUNK_START"] = 1] = "CHUNK_START";\n    Flags[Flags["CHUNK_END"] = 2] = "CHUNK_END";\n    Flags[Flags["PARENT"] = 4] = "PARENT";\n    Flags[Flags["ROOT"] = 8] = "ROOT";\n    Flags[Flags["KEYED_HASH"] = 16] = "KEYED_HASH";\n    Flags[Flags["DERIVE_KEY_CONTEXT"] = 32] = "DERIVE_KEY_CONTEXT";\n    Flags[Flags["DERIVE_KEY_MATERIAL"] = 64] = "DERIVE_KEY_MATERIAL";\n})(Flags || (Flags = {}));\nconst SIGMA = (() => {\n    const Id = Array.from({ length: 16 }, (_, i) => i);\n    const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);\n    const res = [];\n    for (let i = 0, v = Id; i < 7; i++, v = permute(v))\n        res.push(...v);\n    return Uint8Array.from(res);\n})();\n// Why is this so slow? It should be 6x faster than blake2b.\n// - There is only 30% reduction in number of rounds from blake2s\n// - This function uses tree mode to achive parallelisation via SIMD and threading,\n//   however in JS we don\'t have threads and SIMD, so we get only overhead from tree structure\n// - It is possible to speed it up via Web Workers, hovewer it will make code singnificantly more\n//   complicated, which we are trying to avoid, since this library is intended to be used\n//   for cryptographic purposes. Also, parallelization happens only on chunk level (1024 bytes),\n//   which won\'t really benefit small inputs.\nclass BLAKE3 extends blake2.BLAKE2 {\n    constructor(opts = {}, flags = 0) {\n        super(64, opts.dkLen === undefined ? 32 : opts.dkLen, {}, Number.MAX_SAFE_INTEGER, 0, 0);\n        this.flags = 0 | 0;\n        this.chunkPos = 0; // Position of current block in chunk\n        this.chunksDone = 0; // How many chunks we already have\n        this.stack = [];\n        // Output\n        this.posOut = 0;\n        this.bufferOut32 = new Uint32Array(16);\n        this.chunkOut = 0; // index of output chunk\n        this.enableXOF = true;\n        this.outputLen = opts.dkLen === undefined ? 32 : opts.dkLen;\n        (0, utils_js_1.assertNumber)(this.outputLen);\n        if (opts.key !== undefined && opts.context !== undefined)\n            throw new Error(\'Blake3: only key or context can be specified at same time\');\n        else if (opts.key !== undefined) {\n            const key = (0, utils_js_1.toBytes)(opts.key);\n            if (key.length !== 32)\n                throw new Error(\'Blake3: key should be 32 byte\');\n            this.IV = (0, utils_js_1.u32)(key);\n            this.flags = flags | Flags.KEYED_HASH;\n        }\n        else if (opts.context !== undefined) {\n            const context_key = new BLAKE3({ dkLen: 32 }, Flags.DERIVE_KEY_CONTEXT)\n                .update(opts.context)\n                .digest();\n            this.IV = (0, utils_js_1.u32)(context_key);\n            this.flags = flags | Flags.DERIVE_KEY_MATERIAL;\n        }\n        else {\n            this.IV = blake2s.IV.slice();\n            this.flags = flags;\n        }\n        this.state = this.IV.slice();\n        this.bufferOut = (0, utils_js_1.u8)(this.bufferOut32);\n    }\n    // Unused\n    get() {\n        return [];\n    }\n    set() { }\n    b2Compress(counter, flags, buf, bufPos = 0) {\n        const { state, pos } = this;\n        const { h, l } = u64.fromBig(BigInt(counter), true);\n        // prettier-ignore\n        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = blake2s.compress(SIGMA, bufPos, buf, 7, state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7], blake2s.IV[0], blake2s.IV[1], blake2s.IV[2], blake2s.IV[3], h, l, pos, flags);\n        state[0] = v0 ^ v8;\n        state[1] = v1 ^ v9;\n        state[2] = v2 ^ v10;\n        state[3] = v3 ^ v11;\n        state[4] = v4 ^ v12;\n        state[5] = v5 ^ v13;\n        state[6] = v6 ^ v14;\n        state[7] = v7 ^ v15;\n    }\n    compress(buf, bufPos = 0, isLast = false) {\n        // Compress last block\n        let flags = this.flags;\n        if (!this.chunkPos)\n            flags |= Flags.CHUNK_START;\n        if (this.chunkPos === 15 || isLast)\n            flags |= Flags.CHUNK_END;\n        if (!isLast)\n            this.pos = this.blockLen;\n        this.b2Compress(this.chunksDone, flags, buf, bufPos);\n        this.chunkPos += 1;\n        // If current block is last in chunk (16 blocks), then compress chunks\n        if (this.chunkPos === 16 || isLast) {\n            let chunk = this.state;\n            this.state = this.IV.slice();\n            // If not the last one, compress only when there are trailing zeros in chunk counter\n            // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n            // 1 (001) - leaf not finished (just push current chunk to stack)\n            // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n            // 3 (011) - last leaf not finished\n            // 4 (100) - leafs finished at depth=1 and depth=2\n            for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n                if (!(last = this.stack.pop()))\n                    break;\n                this.buffer32.set(last, 0);\n                this.buffer32.set(chunk, 8);\n                this.pos = this.blockLen;\n                this.b2Compress(0, this.flags | Flags.PARENT, this.buffer32, 0);\n                chunk = this.state;\n                this.state = this.IV.slice();\n            }\n            this.chunksDone++;\n            this.chunkPos = 0;\n            this.stack.push(chunk);\n        }\n        this.pos = 0;\n    }\n    _cloneInto(to) {\n        to = super._cloneInto(to);\n        const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;\n        to.state.set(state.slice());\n        to.stack = stack.map((i) => Uint32Array.from(i));\n        to.IV.set(IV);\n        to.flags = flags;\n        to.chunkPos = chunkPos;\n        to.chunksDone = chunksDone;\n        to.posOut = posOut;\n        to.chunkOut = chunkOut;\n        to.enableXOF = this.enableXOF;\n        to.bufferOut32.set(this.bufferOut32);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n        this.buffer32.fill(0);\n        this.IV.fill(0);\n        this.bufferOut32.fill(0);\n        for (let i of this.stack)\n            i.fill(0);\n    }\n    // Same as b2Compress, but doesn\'t modify state and returns 16 u32 array (instead of 8)\n    b2CompressOut() {\n        const { state, pos, flags, buffer32, bufferOut32 } = this;\n        const { h, l } = u64.fromBig(BigInt(this.chunkOut++));\n        // prettier-ignore\n        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = blake2s.compress(SIGMA, 0, buffer32, 7, state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7], blake2s.IV[0], blake2s.IV[1], blake2s.IV[2], blake2s.IV[3], l, h, pos, flags);\n        bufferOut32[0] = v0 ^ v8;\n        bufferOut32[1] = v1 ^ v9;\n        bufferOut32[2] = v2 ^ v10;\n        bufferOut32[3] = v3 ^ v11;\n        bufferOut32[4] = v4 ^ v12;\n        bufferOut32[5] = v5 ^ v13;\n        bufferOut32[6] = v6 ^ v14;\n        bufferOut32[7] = v7 ^ v15;\n        bufferOut32[8] = state[0] ^ v8;\n        bufferOut32[9] = state[1] ^ v9;\n        bufferOut32[10] = state[2] ^ v10;\n        bufferOut32[11] = state[3] ^ v11;\n        bufferOut32[12] = state[4] ^ v12;\n        bufferOut32[13] = state[5] ^ v13;\n        bufferOut32[14] = state[6] ^ v14;\n        bufferOut32[15] = state[7] ^ v15;\n        this.posOut = 0;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        // Padding\n        this.buffer.fill(0, this.pos);\n        // Process last chunk\n        let flags = this.flags | Flags.ROOT;\n        if (this.stack.length) {\n            flags |= Flags.PARENT;\n            this.compress(this.buffer32, 0, true);\n            this.chunksDone = 0;\n            this.pos = this.blockLen;\n        }\n        else {\n            flags |= (!this.chunkPos ? Flags.CHUNK_START : 0) | Flags.CHUNK_END;\n        }\n        this.flags = flags;\n        this.b2CompressOut();\n    }\n    writeInto(out) {\n        if (this.destroyed)\n            throw new Error(\'instance is destroyed\');\n        if (!(out instanceof Uint8Array))\n            throw new Error(\'Blake3: Invalid output buffer\');\n        this.finish();\n        const { blockLen, bufferOut } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.b2CompressOut();\n            const take = Math.min(this.blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        if (!this.enableXOF)\n            throw new Error(\'XOF impossible after digest call\');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, utils_js_1.assertNumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        if (out.length < this.outputLen)\n            throw new Error(\'Blake3: Invalid output buffer\');\n        if (this.finished)\n            throw new Error(\'digest() was already called\');\n        this.enableXOF = false;\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n}\n/**\n * BLAKE3 hash function.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, context\n */\nexports.blake3 = (0, utils_js_1.wrapConstructorWithOpts)((opts) => new BLAKE3(opts));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9ibGFrZTMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QseUJBQXlCLG1CQUFPLENBQUMsOEZBQVc7QUFDNUMsNEJBQTRCLG1CQUFPLENBQUMsb0dBQWM7QUFDbEQsNkJBQTZCLG1CQUFPLENBQUMsb0dBQWM7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixnRUFBZ0U7QUFDaEU7QUFDQSwyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxnQkFBZ0IsdUVBQXVFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx5QkFBeUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBa0U7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQ0FBMkM7QUFDM0QsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxnQkFBZ0IsdUVBQXVFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvYmxha2UzLmpzPzExMmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmxha2UzID0gdm9pZCAwO1xuY29uc3QgdTY0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL191NjQuanNcIikpO1xuY29uc3QgYmxha2UyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL19ibGFrZTIuanNcIikpO1xuY29uc3QgYmxha2UycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9ibGFrZTJzLmpzXCIpKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIEZsYWcgYml0c2V0XG52YXIgRmxhZ3M7XG4oZnVuY3Rpb24gKEZsYWdzKSB7XG4gICAgRmxhZ3NbRmxhZ3NbXCJDSFVOS19TVEFSVFwiXSA9IDFdID0gXCJDSFVOS19TVEFSVFwiO1xuICAgIEZsYWdzW0ZsYWdzW1wiQ0hVTktfRU5EXCJdID0gMl0gPSBcIkNIVU5LX0VORFwiO1xuICAgIEZsYWdzW0ZsYWdzW1wiUEFSRU5UXCJdID0gNF0gPSBcIlBBUkVOVFwiO1xuICAgIEZsYWdzW0ZsYWdzW1wiUk9PVFwiXSA9IDhdID0gXCJST09UXCI7XG4gICAgRmxhZ3NbRmxhZ3NbXCJLRVlFRF9IQVNIXCJdID0gMTZdID0gXCJLRVlFRF9IQVNIXCI7XG4gICAgRmxhZ3NbRmxhZ3NbXCJERVJJVkVfS0VZX0NPTlRFWFRcIl0gPSAzMl0gPSBcIkRFUklWRV9LRVlfQ09OVEVYVFwiO1xuICAgIEZsYWdzW0ZsYWdzW1wiREVSSVZFX0tFWV9NQVRFUklBTFwiXSA9IDY0XSA9IFwiREVSSVZFX0tFWV9NQVRFUklBTFwiO1xufSkoRmxhZ3MgfHwgKEZsYWdzID0ge30pKTtcbmNvbnN0IFNJR01BID0gKCgpID0+IHtcbiAgICBjb25zdCBJZCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDE2IH0sIChfLCBpKSA9PiBpKTtcbiAgICBjb25zdCBwZXJtdXRlID0gKGFycikgPT4gWzIsIDYsIDMsIDEwLCA3LCAwLCA0LCAxMywgMSwgMTEsIDEyLCA1LCA5LCAxNCwgMTUsIDhdLm1hcCgoaSkgPT4gYXJyW2ldKTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgdiA9IElkOyBpIDwgNzsgaSsrLCB2ID0gcGVybXV0ZSh2KSlcbiAgICAgICAgcmVzLnB1c2goLi4udik7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xufSkoKTtcbi8vIFdoeSBpcyB0aGlzIHNvIHNsb3c/IEl0IHNob3VsZCBiZSA2eCBmYXN0ZXIgdGhhbiBibGFrZTJiLlxuLy8gLSBUaGVyZSBpcyBvbmx5IDMwJSByZWR1Y3Rpb24gaW4gbnVtYmVyIG9mIHJvdW5kcyBmcm9tIGJsYWtlMnNcbi8vIC0gVGhpcyBmdW5jdGlvbiB1c2VzIHRyZWUgbW9kZSB0byBhY2hpdmUgcGFyYWxsZWxpc2F0aW9uIHZpYSBTSU1EIGFuZCB0aHJlYWRpbmcsXG4vLyAgIGhvd2V2ZXIgaW4gSlMgd2UgZG9uJ3QgaGF2ZSB0aHJlYWRzIGFuZCBTSU1ELCBzbyB3ZSBnZXQgb25seSBvdmVyaGVhZCBmcm9tIHRyZWUgc3RydWN0dXJlXG4vLyAtIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWVkIGl0IHVwIHZpYSBXZWIgV29ya2VycywgaG92ZXdlciBpdCB3aWxsIG1ha2UgY29kZSBzaW5nbmlmaWNhbnRseSBtb3JlXG4vLyAgIGNvbXBsaWNhdGVkLCB3aGljaCB3ZSBhcmUgdHJ5aW5nIHRvIGF2b2lkLCBzaW5jZSB0aGlzIGxpYnJhcnkgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZFxuLy8gICBmb3IgY3J5cHRvZ3JhcGhpYyBwdXJwb3Nlcy4gQWxzbywgcGFyYWxsZWxpemF0aW9uIGhhcHBlbnMgb25seSBvbiBjaHVuayBsZXZlbCAoMTAyNCBieXRlcyksXG4vLyAgIHdoaWNoIHdvbid0IHJlYWxseSBiZW5lZml0IHNtYWxsIGlucHV0cy5cbmNsYXNzIEJMQUtFMyBleHRlbmRzIGJsYWtlMi5CTEFLRTIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSwgZmxhZ3MgPSAwKSB7XG4gICAgICAgIHN1cGVyKDY0LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyAzMiA6IG9wdHMuZGtMZW4sIHt9LCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgMCwgMCk7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwIHwgMDtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IDA7IC8vIFBvc2l0aW9uIG9mIGN1cnJlbnQgYmxvY2sgaW4gY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua3NEb25lID0gMDsgLy8gSG93IG1hbnkgY2h1bmtzIHdlIGFscmVhZHkgaGF2ZVxuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8vIE91dHB1dFxuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyT3V0MzIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuICAgICAgICB0aGlzLmNodW5rT3V0ID0gMDsgLy8gaW5kZXggb2Ygb3V0cHV0IGNodW5rXG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyAzMiA6IG9wdHMuZGtMZW47XG4gICAgICAgICgwLCB1dGlsc19qc18xLmFzc2VydE51bWJlcikodGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICBpZiAob3B0cy5rZXkgIT09IHVuZGVmaW5lZCAmJiBvcHRzLmNvbnRleHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmxha2UzOiBvbmx5IGtleSBvciBjb250ZXh0IGNhbiBiZSBzcGVjaWZpZWQgYXQgc2FtZSB0aW1lJyk7XG4gICAgICAgIGVsc2UgaWYgKG9wdHMua2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKG9wdHMua2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkubGVuZ3RoICE9PSAzMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JsYWtlMzoga2V5IHNob3VsZCBiZSAzMiBieXRlJyk7XG4gICAgICAgICAgICB0aGlzLklWID0gKDAsIHV0aWxzX2pzXzEudTMyKShrZXkpO1xuICAgICAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzIHwgRmxhZ3MuS0VZRURfSEFTSDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dF9rZXkgPSBuZXcgQkxBS0UzKHsgZGtMZW46IDMyIH0sIEZsYWdzLkRFUklWRV9LRVlfQ09OVEVYVClcbiAgICAgICAgICAgICAgICAudXBkYXRlKG9wdHMuY29udGV4dClcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCk7XG4gICAgICAgICAgICB0aGlzLklWID0gKDAsIHV0aWxzX2pzXzEudTMyKShjb250ZXh0X2tleSk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3MgfCBGbGFncy5ERVJJVkVfS0VZX01BVEVSSUFMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5JViA9IGJsYWtlMnMuSVYuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5JVi5zbGljZSgpO1xuICAgICAgICB0aGlzLmJ1ZmZlck91dCA9ICgwLCB1dGlsc19qc18xLnU4KSh0aGlzLmJ1ZmZlck91dDMyKTtcbiAgICB9XG4gICAgLy8gVW51c2VkXG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHNldCgpIHsgfVxuICAgIGIyQ29tcHJlc3MoY291bnRlciwgZmxhZ3MsIGJ1ZiwgYnVmUG9zID0gMCkge1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gdTY0LmZyb21CaWcoQmlnSW50KGNvdW50ZXIpLCB0cnVlKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IHsgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUgfSA9IGJsYWtlMnMuY29tcHJlc3MoU0lHTUEsIGJ1ZlBvcywgYnVmLCA3LCBzdGF0ZVswXSwgc3RhdGVbMV0sIHN0YXRlWzJdLCBzdGF0ZVszXSwgc3RhdGVbNF0sIHN0YXRlWzVdLCBzdGF0ZVs2XSwgc3RhdGVbN10sIGJsYWtlMnMuSVZbMF0sIGJsYWtlMnMuSVZbMV0sIGJsYWtlMnMuSVZbMl0sIGJsYWtlMnMuSVZbM10sIGgsIGwsIHBvcywgZmxhZ3MpO1xuICAgICAgICBzdGF0ZVswXSA9IHYwIF4gdjg7XG4gICAgICAgIHN0YXRlWzFdID0gdjEgXiB2OTtcbiAgICAgICAgc3RhdGVbMl0gPSB2MiBeIHYxMDtcbiAgICAgICAgc3RhdGVbM10gPSB2MyBeIHYxMTtcbiAgICAgICAgc3RhdGVbNF0gPSB2NCBeIHYxMjtcbiAgICAgICAgc3RhdGVbNV0gPSB2NSBeIHYxMztcbiAgICAgICAgc3RhdGVbNl0gPSB2NiBeIHYxNDtcbiAgICAgICAgc3RhdGVbN10gPSB2NyBeIHYxNTtcbiAgICB9XG4gICAgY29tcHJlc3MoYnVmLCBidWZQb3MgPSAwLCBpc0xhc3QgPSBmYWxzZSkge1xuICAgICAgICAvLyBDb21wcmVzcyBsYXN0IGJsb2NrXG4gICAgICAgIGxldCBmbGFncyA9IHRoaXMuZmxhZ3M7XG4gICAgICAgIGlmICghdGhpcy5jaHVua1BvcylcbiAgICAgICAgICAgIGZsYWdzIHw9IEZsYWdzLkNIVU5LX1NUQVJUO1xuICAgICAgICBpZiAodGhpcy5jaHVua1BvcyA9PT0gMTUgfHwgaXNMYXN0KVxuICAgICAgICAgICAgZmxhZ3MgfD0gRmxhZ3MuQ0hVTktfRU5EO1xuICAgICAgICBpZiAoIWlzTGFzdClcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5iMkNvbXByZXNzKHRoaXMuY2h1bmtzRG9uZSwgZmxhZ3MsIGJ1ZiwgYnVmUG9zKTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyArPSAxO1xuICAgICAgICAvLyBJZiBjdXJyZW50IGJsb2NrIGlzIGxhc3QgaW4gY2h1bmsgKDE2IGJsb2NrcyksIHRoZW4gY29tcHJlc3MgY2h1bmtzXG4gICAgICAgIGlmICh0aGlzLmNodW5rUG9zID09PSAxNiB8fCBpc0xhc3QpIHtcbiAgICAgICAgICAgIGxldCBjaHVuayA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5JVi5zbGljZSgpO1xuICAgICAgICAgICAgLy8gSWYgbm90IHRoZSBsYXN0IG9uZSwgY29tcHJlc3Mgb25seSB3aGVuIHRoZXJlIGFyZSB0cmFpbGluZyB6ZXJvcyBpbiBjaHVuayBjb3VudGVyXG4gICAgICAgICAgICAvLyBjaHVua3MgdXNlZCBhcyBiaW5hcnkgdHJlZSB3aGVyZSBjdXJyZW50IHN0YWNrIGlzIHBhdGguIFplcm8gbWVhbnMgY3VycmVudCBsZWFmIGlzIGZpbmlzaGVkIGFuZCBjYW4gYmUgY29tcHJlc3NlZC5cbiAgICAgICAgICAgIC8vIDEgKDAwMSkgLSBsZWFmIG5vdCBmaW5pc2hlZCAoanVzdCBwdXNoIGN1cnJlbnQgY2h1bmsgdG8gc3RhY2spXG4gICAgICAgICAgICAvLyAyICgwMTApIC0gbGVhZiBmaW5pc2hlZCBhdCBkZXB0aD0xIChtZXJnZSB3aXRoIGxhc3QgZWxtIG9uIHN0YWNrIGFuZCBwdXNoIGJhY2spXG4gICAgICAgICAgICAvLyAzICgwMTEpIC0gbGFzdCBsZWFmIG5vdCBmaW5pc2hlZFxuICAgICAgICAgICAgLy8gNCAoMTAwKSAtIGxlYWZzIGZpbmlzaGVkIGF0IGRlcHRoPTEgYW5kIGRlcHRoPTJcbiAgICAgICAgICAgIGZvciAobGV0IGxhc3QsIGNodW5rcyA9IHRoaXMuY2h1bmtzRG9uZSArIDE7IGlzTGFzdCB8fCAhKGNodW5rcyAmIDEpOyBjaHVua3MgPj49IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShsYXN0ID0gdGhpcy5zdGFjay5wb3AoKSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyMzIuc2V0KGxhc3QsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyMzIuc2V0KGNodW5rLCA4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgICAgICAgICAgdGhpcy5iMkNvbXByZXNzKDAsIHRoaXMuZmxhZ3MgfCBGbGFncy5QQVJFTlQsIHRoaXMuYnVmZmVyMzIsIDApO1xuICAgICAgICAgICAgICAgIGNodW5rID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5JVi5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaHVua3NEb25lKys7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvID0gc3VwZXIuX2Nsb25lSW50byh0byk7XG4gICAgICAgIGNvbnN0IHsgSVYsIGZsYWdzLCBzdGF0ZSwgY2h1bmtQb3MsIHBvc091dCwgY2h1bmtPdXQsIHN0YWNrLCBjaHVua3NEb25lIH0gPSB0aGlzO1xuICAgICAgICB0by5zdGF0ZS5zZXQoc3RhdGUuc2xpY2UoKSk7XG4gICAgICAgIHRvLnN0YWNrID0gc3RhY2subWFwKChpKSA9PiBVaW50MzJBcnJheS5mcm9tKGkpKTtcbiAgICAgICAgdG8uSVYuc2V0KElWKTtcbiAgICAgICAgdG8uZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdG8uY2h1bmtQb3MgPSBjaHVua1BvcztcbiAgICAgICAgdG8uY2h1bmtzRG9uZSA9IGNodW5rc0RvbmU7XG4gICAgICAgIHRvLnBvc091dCA9IHBvc091dDtcbiAgICAgICAgdG8uY2h1bmtPdXQgPSBjaHVua091dDtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gdGhpcy5lbmFibGVYT0Y7XG4gICAgICAgIHRvLmJ1ZmZlck91dDMyLnNldCh0aGlzLmJ1ZmZlck91dDMyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5idWZmZXIzMi5maWxsKDApO1xuICAgICAgICB0aGlzLklWLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyT3V0MzIuZmlsbCgwKTtcbiAgICAgICAgZm9yIChsZXQgaSBvZiB0aGlzLnN0YWNrKVxuICAgICAgICAgICAgaS5maWxsKDApO1xuICAgIH1cbiAgICAvLyBTYW1lIGFzIGIyQ29tcHJlc3MsIGJ1dCBkb2Vzbid0IG1vZGlmeSBzdGF0ZSBhbmQgcmV0dXJucyAxNiB1MzIgYXJyYXkgKGluc3RlYWQgb2YgOClcbiAgICBiMkNvbXByZXNzT3V0KCkge1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBwb3MsIGZsYWdzLCBidWZmZXIzMiwgYnVmZmVyT3V0MzIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gdTY0LmZyb21CaWcoQmlnSW50KHRoaXMuY2h1bmtPdXQrKykpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgeyB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSwgdjEwLCB2MTEsIHYxMiwgdjEzLCB2MTQsIHYxNSB9ID0gYmxha2Uycy5jb21wcmVzcyhTSUdNQSwgMCwgYnVmZmVyMzIsIDcsIHN0YXRlWzBdLCBzdGF0ZVsxXSwgc3RhdGVbMl0sIHN0YXRlWzNdLCBzdGF0ZVs0XSwgc3RhdGVbNV0sIHN0YXRlWzZdLCBzdGF0ZVs3XSwgYmxha2Uycy5JVlswXSwgYmxha2Uycy5JVlsxXSwgYmxha2Uycy5JVlsyXSwgYmxha2Uycy5JVlszXSwgbCwgaCwgcG9zLCBmbGFncyk7XG4gICAgICAgIGJ1ZmZlck91dDMyWzBdID0gdjAgXiB2ODtcbiAgICAgICAgYnVmZmVyT3V0MzJbMV0gPSB2MSBeIHY5O1xuICAgICAgICBidWZmZXJPdXQzMlsyXSA9IHYyIF4gdjEwO1xuICAgICAgICBidWZmZXJPdXQzMlszXSA9IHYzIF4gdjExO1xuICAgICAgICBidWZmZXJPdXQzMls0XSA9IHY0IF4gdjEyO1xuICAgICAgICBidWZmZXJPdXQzMls1XSA9IHY1IF4gdjEzO1xuICAgICAgICBidWZmZXJPdXQzMls2XSA9IHY2IF4gdjE0O1xuICAgICAgICBidWZmZXJPdXQzMls3XSA9IHY3IF4gdjE1O1xuICAgICAgICBidWZmZXJPdXQzMls4XSA9IHN0YXRlWzBdIF4gdjg7XG4gICAgICAgIGJ1ZmZlck91dDMyWzldID0gc3RhdGVbMV0gXiB2OTtcbiAgICAgICAgYnVmZmVyT3V0MzJbMTBdID0gc3RhdGVbMl0gXiB2MTA7XG4gICAgICAgIGJ1ZmZlck91dDMyWzExXSA9IHN0YXRlWzNdIF4gdjExO1xuICAgICAgICBidWZmZXJPdXQzMlsxMl0gPSBzdGF0ZVs0XSBeIHYxMjtcbiAgICAgICAgYnVmZmVyT3V0MzJbMTNdID0gc3RhdGVbNV0gXiB2MTM7XG4gICAgICAgIGJ1ZmZlck91dDMyWzE0XSA9IHN0YXRlWzZdIF4gdjE0O1xuICAgICAgICBidWZmZXJPdXQzMlsxNV0gPSBzdGF0ZVs3XSBeIHYxNTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDAsIHRoaXMucG9zKTtcbiAgICAgICAgLy8gUHJvY2VzcyBsYXN0IGNodW5rXG4gICAgICAgIGxldCBmbGFncyA9IHRoaXMuZmxhZ3MgfCBGbGFncy5ST09UO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZsYWdzLlBBUkVOVDtcbiAgICAgICAgICAgIHRoaXMuY29tcHJlc3ModGhpcy5idWZmZXIzMiwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNodW5rc0RvbmUgPSAwO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmxhZ3MgfD0gKCF0aGlzLmNodW5rUG9zID8gRmxhZ3MuQ0hVTktfU1RBUlQgOiAwKSB8IEZsYWdzLkNIVU5LX0VORDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuYjJDb21wcmVzc091dCgpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5zdGFuY2UgaXMgZGVzdHJveWVkJyk7XG4gICAgICAgIGlmICghKG91dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbGFrZTM6IEludmFsaWQgb3V0cHV0IGJ1ZmZlcicpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXJPdXQgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmIyQ29tcHJlc3NPdXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbih0aGlzLmJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaW1wb3NzaWJsZSBhZnRlciBkaWdlc3QgY2FsbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgICgwLCB1dGlsc19qc18xLmFzc2VydE51bWJlcikoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGlmIChvdXQubGVuZ3RoIDwgdGhpcy5vdXRwdXRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JsYWtlMzogSW52YWxpZCBvdXRwdXQgYnVmZmVyJyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbn1cbi8qKlxuICogQkxBS0UzIGhhc2ggZnVuY3Rpb24uXG4gKiBAcGFyYW0gbXNnIC0gbWVzc2FnZSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICogQHBhcmFtIG9wdHMgLSBka0xlbiwga2V5LCBjb250ZXh0XG4gKi9cbmV4cG9ydHMuYmxha2UzID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMpKChvcHRzKSA9PiBuZXcgQkxBS0UzKG9wdHMpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/blake3.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/crypto.js':
    /*!*******************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/crypto.js ***!
  \*******************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        '\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.crypto = void 0;\nconst crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "crypto"));\nexports.crypto = {\n    node: crypto_1.default,\n    web: undefined,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsaUNBQWlDLG1CQUFPLENBQUMsc0JBQVE7QUFDakQsY0FBYztBQUNkO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvLmpzP2M2NDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcnlwdG9cIikpO1xuZXhwb3J0cy5jcnlwdG8gPSB7XG4gICAgbm9kZTogY3J5cHRvXzEuZGVmYXVsdCxcbiAgICB3ZWI6IHVuZGVmaW5lZCxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/crypto.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/hmac.js':
    /*!*****************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/hmac.js ***!
  \*****************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hmac = void 0;\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, utils_js_1.assertHash)(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (!(this.iHash instanceof utils_js_1.Hash))\n            throw new TypeError('Expected instance of class which extends utils.Hash');\n        const blockLen = (this.blockLen = this.iHash.blockLen);\n        this.outputLen = this.iHash.outputLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array) || out.length !== this.outputLen)\n            throw new Error('HMAC: Invalid output buffer');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWixtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzPzAxYzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhtYWMgPSB2b2lkIDA7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBITUFDIChSRkMgMjEwNClcbmNsYXNzIEhNQUMgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAoMCwgdXRpbHNfanNfMS5hc3NlcnRIYXNoKShoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAoISh0aGlzLmlIYXNoIGluc3RhbmNlb2YgdXRpbHNfanNfMS5IYXNoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9ICh0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbik7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiB0aGlzLmlIYXNoLmJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnN0YW5jZSBpcyBkZXN0cm95ZWQnKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5zdGFuY2UgaXMgZGVzdHJveWVkJyk7XG4gICAgICAgIGlmICghKG91dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8IG91dC5sZW5ndGggIT09IHRoaXMub3V0cHV0TGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdITUFDOiBJbnZhbGlkIG91dHB1dCBidWZmZXInKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5jb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5leHBvcnRzLmhtYWMgPSBobWFjO1xuZXhwb3J0cy5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/hmac.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/pbkdf2.js':
    /*!*******************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/pbkdf2.js ***!
  \*******************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.pbkdf2Async = exports.pbkdf2 = void 0;\nconst hmac_js_1 = __webpack_require__(/*! ./hmac.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/hmac.js");\n// prettier-ignore\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js");\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0, utils_js_1.assertHash)(hash);\n    const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0, utils_js_1.assertNumber)(c);\n    (0, utils_js_1.assertNumber)(dkLen);\n    (0, utils_js_1.assertNumber)(asyncTick);\n    if (c < 1)\n        throw new Error(\'PBKDF2: iterations (c) should be >= 1\');\n    const password = (0, utils_js_1.toBytes)(_password);\n    const salt = (0, utils_js_1.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac_js_1.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_js_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexports.pbkdf2 = pbkdf2;\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_js_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, (i) => {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexports.pbkdf2Async = pbkdf2Async;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9wYmtkZjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsY0FBYztBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBVztBQUNyQztBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwQkFBMEI7QUFDdkUsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVksd0NBQXdDO0FBQ3BELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9wYmtkZjIuanM/NDY0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGJrZGYyQXN5bmMgPSBleHBvcnRzLnBia2RmMiA9IHZvaWQgMDtcbmNvbnN0IGhtYWNfanNfMSA9IHJlcXVpcmUoXCIuL2htYWMuanNcIik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIENvbW1vbiBwcm9sb2d1ZSBhbmQgZXBpbG9ndWUgZm9yIHN5bmMvYXN5bmMgZnVuY3Rpb25zXG5mdW5jdGlvbiBwYmtkZjJJbml0KGhhc2gsIF9wYXNzd29yZCwgX3NhbHQsIF9vcHRzKSB7XG4gICAgKDAsIHV0aWxzX2pzXzEuYXNzZXJ0SGFzaCkoaGFzaCk7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCB1dGlsc19qc18xLmNoZWNrT3B0cykoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljayB9ID0gb3B0cztcbiAgICAoMCwgdXRpbHNfanNfMS5hc3NlcnROdW1iZXIpKGMpO1xuICAgICgwLCB1dGlsc19qc18xLmFzc2VydE51bWJlcikoZGtMZW4pO1xuICAgICgwLCB1dGlsc19qc18xLmFzc2VydE51bWJlcikoYXN5bmNUaWNrKTtcbiAgICBpZiAoYyA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUEJLREYyOiBpdGVyYXRpb25zIChjKSBzaG91bGQgYmUgPj0gMScpO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBzYWx0ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoX3NhbHQpO1xuICAgIC8vIERLID0gUEJLREYyKFBSRiwgUGFzc3dvcmQsIFNhbHQsIGMsIGRrTGVuKTtcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcbiAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICBjb25zdCBQUkYgPSBobWFjX2pzXzEuaG1hYy5jcmVhdGUoaGFzaCwgcGFzc3dvcmQpO1xuICAgIGNvbnN0IFBSRlNhbHQgPSBQUkYuX2Nsb25lSW50bygpLnVwZGF0ZShzYWx0KTtcbiAgICByZXR1cm4geyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH07XG59XG5mdW5jdGlvbiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSkge1xuICAgIFBSRi5kZXN0cm95KCk7XG4gICAgUFJGU2FsdC5kZXN0cm95KCk7XG4gICAgaWYgKHByZlcpXG4gICAgICAgIHByZlcuZGVzdHJveSgpO1xuICAgIHUuZmlsbCgwKTtcbiAgICByZXR1cm4gREs7XG59XG4vKipcbiAqIFBCS0RGMi1ITUFDOiBSRkMgMjg5OCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc3dvcmQgZnJvbSB3aGljaCBhIGRlcml2ZWQga2V5IGlzIGdlbmVyYXRlZFxuICogQHBhcmFtIHNhbHQgLSBjcnlwdG9ncmFwaGljIHNhbHRcbiAqIEBwYXJhbSBvcHRzIC0ge2MsIGRrTGVufSB3aGVyZSBjIGlzIHdvcmsgZmFjdG9yIGFuZCBka0xlbiBpcyBvdXRwdXQgbWVzc2FnZSBzaXplXG4gKi9cbmZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBmb3IgKGxldCB1aSA9IDE7IHVpIDwgYzsgdWkrKykge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSk7XG59XG5leHBvcnRzLnBia2RmMiA9IHBia2RmMjtcbmFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgYXdhaXQgKDAsIHV0aWxzX2pzXzEuYXN5bmNMb29wKShjIC0gMSwgYXN5bmNUaWNrLCAoaSkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbmV4cG9ydHMucGJrZGYyQXN5bmMgPSBwYmtkZjJBc3luYztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/pbkdf2.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/ripemd160.js':
    /*!**********************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/ripemd160.js ***!
  \**********************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ripemd160 = exports.RIPEMD160 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_sha2.js");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js");\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\nconst Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It\'s called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = new Uint32Array(16);\nclass RIPEMD160 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBLG9EQUFvRDtBQUNwRCxzREFBc0Q7QUFDdEQsNERBQTREO0FBQzVELDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAuanM/OTMzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5SSVBFTUQxNjAgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuY29uc3QgUmhvID0gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKTtcbmNvbnN0IElkID0gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XG5jb25zdCBQaSA9IElkLm1hcCgoaSkgPT4gKDkgKiBpICsgNSkgJSAxNik7XG5sZXQgaWR4TCA9IFtJZF07XG5sZXQgaWR4UiA9IFtQaV07XG5mb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKGxldCBqIG9mIFtpZHhMLCBpZHhSXSlcbiAgICAgICAgai5wdXNoKGpbaV0ubWFwKChrKSA9PiBSaG9ba10pKTtcbmNvbnN0IHNoaWZ0cyA9IFtcbiAgICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcbiAgICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgICBbMTMsIDE1LCAxNCwgMTEsIDcsIDcsIDYsIDgsIDEzLCAxNCwgMTMsIDEyLCA1LCA1LCA2LCA5XSxcbiAgICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcbiAgICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XSxcbl0ubWFwKChpKSA9PiBuZXcgVWludDhBcnJheShpKSk7XG5jb25zdCBzaGlmdHNMID0gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSID0gaWR4Ui5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBLbCA9IG5ldyBVaW50MzJBcnJheShbMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZV0pO1xuY29uc3QgS3IgPSBuZXcgVWludDMyQXJyYXkoWzB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDBdKTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICh3b3JkID4+PiAoMzIgLSBzaGlmdCkpO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiBmKGdyb3VwLCB4LCB5LCB6KSB7XG4gICAgaWYgKGdyb3VwID09PSAwKVxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAzKVxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgQlVGID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIF9zaGEyX2pzXzEuU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IDB4ZWZjZGFiODkgfCAwO1xuICAgICAgICB0aGlzLmgyID0gMHg5OGJhZGNmZSB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2IHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IDB4YzNkMmUxZjAgfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgaDAsIGgxLCBoMiwgaDMsIGg0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW2gwLCBoMSwgaDIsIGgzLCBoNF07XG4gICAgfVxuICAgIHNldChoMCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgdGhpcy5oMCA9IGgwIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IGgxIHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IGgyIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IGgzIHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IGg0IHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIEJVRltpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgYWwgPSB0aGlzLmgwIHwgMCwgYXIgPSBhbCwgYmwgPSB0aGlzLmgxIHwgMCwgYnIgPSBibCwgY2wgPSB0aGlzLmgyIHwgMCwgY3IgPSBjbCwgZGwgPSB0aGlzLmgzIHwgMCwgZHIgPSBkbCwgZWwgPSB0aGlzLmg0IHwgMCwgZXIgPSBlbDtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBpdGVyYXRpbmcgMCB0byA4MCwgd2Ugc3BsaXQgaXQgaW50byA1IGdyb3Vwc1xuICAgICAgICAvLyBBbmQgdXNlIHRoZSBncm91cHMgaW4gY29uc3RhbnRzLCBmdW5jdGlvbnMsIGV0Yy4gTXVjaCBzaW1wbGVyXG4gICAgICAgIGZvciAobGV0IGdyb3VwID0gMDsgZ3JvdXAgPCA1OyBncm91cCsrKSB7XG4gICAgICAgICAgICBjb25zdCByR3JvdXAgPSA0IC0gZ3JvdXA7XG4gICAgICAgICAgICBjb25zdCBoYmwgPSBLbFtncm91cF0sIGhiciA9IEtyW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBybCA9IGlkeExbZ3JvdXBdLCByciA9IGlkeFJbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNsID0gc2hpZnRzTFtncm91cF0sIHNyID0gc2hpZnRzUltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGwgPSAocm90bChhbCArIGYoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGW3JsW2ldXSArIGhibCwgc2xbaV0pICsgZWwpIHwgMDtcbiAgICAgICAgICAgICAgICBhbCA9IGVsLCBlbCA9IGRsLCBkbCA9IHJvdGwoY2wsIDEwKSB8IDAsIGNsID0gYmwsIGJsID0gdGw7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMiBsb29wcyBhcmUgMTAlIGZhc3RlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHIgPSAocm90bChhciArIGYockdyb3VwLCBiciwgY3IsIGRyKSArIEJVRltycltpXV0gKyBoYnIsIHNyW2ldKSArIGVyKSB8IDA7XG4gICAgICAgICAgICAgICAgYXIgPSBlciwgZXIgPSBkciwgZHIgPSByb3RsKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBCVUYuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLlJJUEVNRDE2MCA9IFJJUEVNRDE2MDtcbi8qKlxuICogUklQRU1ELTE2MCAtIGEgaGFzaCBmdW5jdGlvbiBmcm9tIDE5OTBzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBtc2cgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/ripemd160.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/scrypt.js':
    /*!*******************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/scrypt.js ***!
  \*******************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scryptAsync = exports.scrypt = void 0;\nconst sha256_js_1 = __webpack_require__(/*! ./sha256.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha256.js\");\nconst pbkdf2_js_1 = __webpack_require__(/*! ./pbkdf2.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/pbkdf2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js\");\n// RFC 7914 Scrypt KDF\n// Left rotate for uint32\nconst rotl = (a, b) => (a << b) | (a >>> (32 - b));\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n    // Based on https://cr.yp.to/salsa20.html\n    // Xor blocks\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n    // Save state to temporary variables (salsa)\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    // Main loop (salsa)\n    for (let i = 0; i < 8; i += 2) {\n        x04 ^= rotl(x00 + x12 | 0, 7);\n        x08 ^= rotl(x04 + x00 | 0, 9);\n        x12 ^= rotl(x08 + x04 | 0, 13);\n        x00 ^= rotl(x12 + x08 | 0, 18);\n        x09 ^= rotl(x05 + x01 | 0, 7);\n        x13 ^= rotl(x09 + x05 | 0, 9);\n        x01 ^= rotl(x13 + x09 | 0, 13);\n        x05 ^= rotl(x01 + x13 | 0, 18);\n        x14 ^= rotl(x10 + x06 | 0, 7);\n        x02 ^= rotl(x14 + x10 | 0, 9);\n        x06 ^= rotl(x02 + x14 | 0, 13);\n        x10 ^= rotl(x06 + x02 | 0, 18);\n        x03 ^= rotl(x15 + x11 | 0, 7);\n        x07 ^= rotl(x03 + x15 | 0, 9);\n        x11 ^= rotl(x07 + x03 | 0, 13);\n        x15 ^= rotl(x11 + x07 | 0, 18);\n        x01 ^= rotl(x00 + x03 | 0, 7);\n        x02 ^= rotl(x01 + x00 | 0, 9);\n        x03 ^= rotl(x02 + x01 | 0, 13);\n        x00 ^= rotl(x03 + x02 | 0, 18);\n        x06 ^= rotl(x05 + x04 | 0, 7);\n        x07 ^= rotl(x06 + x05 | 0, 9);\n        x04 ^= rotl(x07 + x06 | 0, 13);\n        x05 ^= rotl(x04 + x07 | 0, 18);\n        x11 ^= rotl(x10 + x09 | 0, 7);\n        x08 ^= rotl(x11 + x10 | 0, 9);\n        x09 ^= rotl(x08 + x11 | 0, 13);\n        x10 ^= rotl(x09 + x08 | 0, 18);\n        x12 ^= rotl(x15 + x14 | 0, 7);\n        x13 ^= rotl(x12 + x15 | 0, 9);\n        x14 ^= rotl(x13 + x12 | 0, 13);\n        x15 ^= rotl(x14 + x13 | 0, 18);\n    }\n    // Write output (salsa)\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\nfunction BlockMix(input, ii, out, oi, r) {\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n    let head = oi + 0;\n    let tail = oi + 16 * r;\n    for (let i = 0; i < 16; i++)\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n        if (i > 0)\n            tail += 16; // First iteration overwrites tmp value in tail\n        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n    }\n}\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password, salt, _opts) {\n    // Maxmem - 1GB+1KB by default\n    const opts = (0, utils_js_1.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10,\n        maxmem: 1024 ** 3 + 1024,\n    }, _opts);\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n    (0, utils_js_1.assertNumber)(N);\n    (0, utils_js_1.assertNumber)(r);\n    (0, utils_js_1.assertNumber)(p);\n    (0, utils_js_1.assertNumber)(dkLen);\n    (0, utils_js_1.assertNumber)(asyncTick);\n    (0, utils_js_1.assertNumber)(maxmem);\n    if (onProgress !== undefined && typeof onProgress !== 'function')\n        throw new Error('progressCb should be function');\n    const blockSize = 128 * r;\n    const blockSize32 = blockSize / 4;\n    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\n        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\n        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\n        throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');\n    }\n    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\n        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');\n    }\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');\n    }\n    const memUsed = blockSize * (N + p);\n    if (memUsed > maxmem) {\n        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);\n    }\n    // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n    // Since it has only one iteration there is no reason to use async variant\n    const B = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, { c: 1, dkLen: blockSize * p });\n    const B32 = (0, utils_js_1.u32)(B);\n    // Re-used between parallel iterations. Array(iterations) of B\n    const V = (0, utils_js_1.u32)(new Uint8Array(blockSize * N));\n    const tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));\n    let blockMixCb = () => { };\n    if (onProgress) {\n        const totalBlockMix = 2 * N * p;\n        // Invoke callback if progress changes from 10.01 to 10.02\n        // Allows to draw smooth progress bar on up to 8K screen\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n        let blockMixCnt = 0;\n        blockMixCb = () => {\n            blockMixCnt++;\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n                onProgress(blockMixCnt / totalBlockMix);\n        };\n    }\n    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\nfunction scryptOutput(password, dkLen, B, V, tmp) {\n    const res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B, { c: 1, dkLen });\n    B.fill(0);\n    V.fill(0);\n    tmp.fill(0);\n    return res;\n}\n/**\n * Scrypt KDF from RFC 7914.\n * @param password - pass\n * @param salt - salt\n * @param opts - parameters\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n * @returns Derived key\n */\nfunction scrypt(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        for (let i = 0, pos = 0; i < N - 1; i++) {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        }\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        for (let i = 0; i < N; i++) {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        }\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\nexports.scrypt = scrypt;\n/**\n * Scrypt KDF from RFC 7914.\n */\nasync function scryptAsync(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        let pos = 0;\n        await (0, utils_js_1.asyncLoop)(N - 1, asyncTick, (i) => {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        });\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        await (0, utils_js_1.asyncLoop)(N, asyncTick, (i) => {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        });\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\nexports.scryptAsync = scryptAsync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zY3J5cHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsY0FBYztBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBYTtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QiwwREFBMEQ7QUFDMUQsb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSx3QkFBd0I7QUFDeEIsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVMsd0JBQXdCLFFBQVE7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDRCQUE0QjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBMEQ7QUFDdEUscUJBQXFCLFFBQVE7QUFDN0I7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLGdDQUFnQztBQUNoQyxpQ0FBaUMsV0FBVztBQUM1QywwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0Esc0RBQXNEO0FBQ3RELDRCQUE0QixpQkFBaUI7QUFDN0MsK0RBQStEO0FBQy9ELDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxRUFBcUU7QUFDakYscUJBQXFCLFFBQVE7QUFDN0I7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsU0FBUztBQUNULHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsNEJBQTRCLGlCQUFpQjtBQUM3QywrREFBK0Q7QUFDL0QsMENBQTBDO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2NyeXB0LmpzPzhiZDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNjcnlwdEFzeW5jID0gZXhwb3J0cy5zY3J5cHQgPSB2b2lkIDA7XG5jb25zdCBzaGEyNTZfanNfMSA9IHJlcXVpcmUoXCIuL3NoYTI1Ni5qc1wiKTtcbmNvbnN0IHBia2RmMl9qc18xID0gcmVxdWlyZShcIi4vcGJrZGYyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUkZDIDc5MTQgU2NyeXB0IEtERlxuLy8gTGVmdCByb3RhdGUgZm9yIHVpbnQzMlxuY29uc3Qgcm90bCA9IChhLCBiKSA9PiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSk7XG4vLyBUaGUgbWFpbiBTY3J5cHQgbG9vcDogdXNlcyBTYWxzYSBleHRlbnNpdmVseS5cbi8vIFNpeCB2ZXJzaW9ucyBvZiB0aGUgZnVuY3Rpb24gd2VyZSB0cmllZCwgdGhpcyBpcyB0aGUgZmFzdGVzdCBvbmUuXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIFhvckFuZFNhbHNhKHByZXYsIHBpLCBpbnB1dCwgaWksIG91dCwgb2kpIHtcbiAgICAvLyBCYXNlZCBvbiBodHRwczovL2NyLnlwLnRvL3NhbHNhMjAuaHRtbFxuICAgIC8vIFhvciBibG9ja3NcbiAgICBsZXQgeTAwID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDEgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwMiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTAzID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTA2ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDcgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwOCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA5ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MTAgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxMSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTEyID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTMgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkxNCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTE1ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlcyAoc2Fsc2EpXG4gICAgbGV0IHgwMCA9IHkwMCwgeDAxID0geTAxLCB4MDIgPSB5MDIsIHgwMyA9IHkwMywgeDA0ID0geTA0LCB4MDUgPSB5MDUsIHgwNiA9IHkwNiwgeDA3ID0geTA3LCB4MDggPSB5MDgsIHgwOSA9IHkwOSwgeDEwID0geTEwLCB4MTEgPSB5MTEsIHgxMiA9IHkxMiwgeDEzID0geTEzLCB4MTQgPSB5MTQsIHgxNSA9IHkxNTtcbiAgICAvLyBNYWluIGxvb3AgKHNhbHNhKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgICAgIHgwNCBePSByb3RsKHgwMCArIHgxMiB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MDQgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDEyIF49IHJvdGwoeDA4ICsgeDA0IHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MTIgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgwOSBePSByb3RsKHgwNSArIHgwMSB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MDkgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDAxIF49IHJvdGwoeDEzICsgeDA5IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDEgKyB4MTMgfCAwLCAxOCk7XG4gICAgICAgIHgxNCBePSByb3RsKHgxMCArIHgwNiB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MTQgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA2IF49IHJvdGwoeDAyICsgeDE0IHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDYgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwMyBePSByb3RsKHgxNSArIHgxMSB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDMgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDExIF49IHJvdGwoeDA3ICsgeDAzIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTEgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgwMSBePSByb3RsKHgwMCArIHgwMyB8IDAsIDcpO1xuICAgICAgICB4MDIgXj0gcm90bCh4MDEgKyB4MDAgfCAwLCA5KTtcbiAgICAgICAgeDAzIF49IHJvdGwoeDAyICsgeDAxIHwgMCwgMTMpO1xuICAgICAgICB4MDAgXj0gcm90bCh4MDMgKyB4MDIgfCAwLCAxOCk7XG4gICAgICAgIHgwNiBePSByb3RsKHgwNSArIHgwNCB8IDAsIDcpO1xuICAgICAgICB4MDcgXj0gcm90bCh4MDYgKyB4MDUgfCAwLCA5KTtcbiAgICAgICAgeDA0IF49IHJvdGwoeDA3ICsgeDA2IHwgMCwgMTMpO1xuICAgICAgICB4MDUgXj0gcm90bCh4MDQgKyB4MDcgfCAwLCAxOCk7XG4gICAgICAgIHgxMSBePSByb3RsKHgxMCArIHgwOSB8IDAsIDcpO1xuICAgICAgICB4MDggXj0gcm90bCh4MTEgKyB4MTAgfCAwLCA5KTtcbiAgICAgICAgeDA5IF49IHJvdGwoeDA4ICsgeDExIHwgMCwgMTMpO1xuICAgICAgICB4MTAgXj0gcm90bCh4MDkgKyB4MDggfCAwLCAxOCk7XG4gICAgICAgIHgxMiBePSByb3RsKHgxNSArIHgxNCB8IDAsIDcpO1xuICAgICAgICB4MTMgXj0gcm90bCh4MTIgKyB4MTUgfCAwLCA5KTtcbiAgICAgICAgeDE0IF49IHJvdGwoeDEzICsgeDEyIHwgMCwgMTMpO1xuICAgICAgICB4MTUgXj0gcm90bCh4MTQgKyB4MTMgfCAwLCAxOCk7XG4gICAgfVxuICAgIC8vIFdyaXRlIG91dHB1dCAoc2Fsc2EpXG4gICAgb3V0W29pKytdID0gKHkwMCArIHgwMCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDEgKyB4MDEpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAyICsgeDAyKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMyArIHgwMykgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDQgKyB4MDQpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA1ICsgeDA1KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNiArIHgwNikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDcgKyB4MDcpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA4ICsgeDA4KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOSArIHgwOSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTAgKyB4MTApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTExICsgeDExKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMiArIHgxMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTMgKyB4MTMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTE0ICsgeDE0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNSArIHgxNSkgfCAwO1xufVxuZnVuY3Rpb24gQmxvY2tNaXgoaW5wdXQsIGlpLCBvdXQsIG9pLCByKSB7XG4gICAgLy8gVGhlIGJsb2NrIEIgaXMgciAxMjgtYnl0ZSBjaHVua3MgKHdoaWNoIGlzIGVxdWl2YWxlbnQgb2YgMnIgNjQtYnl0ZSBjaHVua3MpXG4gICAgbGV0IGhlYWQgPSBvaSArIDA7XG4gICAgbGV0IHRhaWwgPSBvaSArIDE2ICogcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgICAgIG91dFt0YWlsICsgaV0gPSBpbnB1dFtpaSArICgyICogciAtIDEpICogMTYgKyBpXTsgLy8gWCDihpAgQlsycuKIkjFdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByOyBpKyssIGhlYWQgKz0gMTYsIGlpICs9IDE2KSB7XG4gICAgICAgIC8vIFdlIHdyaXRlIG9kZCAmIGV2ZW4gWWkgYXQgc2FtZSB0aW1lLiBFdmVuOiAwYlhYWFhYMCBPZGQ6ICAwYlhYWFhYMVxuICAgICAgICBYb3JBbmRTYWxzYShvdXQsIHRhaWwsIGlucHV0LCBpaSwgb3V0LCBoZWFkKTsgLy8gaGVhZFtpXSA9IFNhbHNhKGJsb2NrSW5bMippXSBeIHRhaWxbaS0xXSlcbiAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgdGFpbCArPSAxNjsgLy8gRmlyc3QgaXRlcmF0aW9uIG92ZXJ3cml0ZXMgdG1wIHZhbHVlIGluIHRhaWxcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCBoZWFkLCBpbnB1dCwgKGlpICs9IDE2KSwgb3V0LCB0YWlsKTsgLy8gdGFpbFtpXSA9IFNhbHNhKGJsb2NrSW5bMippKzFdIF4gaGVhZFtpXSlcbiAgICB9XG59XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgX29wdHMpIHtcbiAgICAvLyBNYXhtZW0gLSAxR0IrMUtCIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBvcHRzID0gKDAsIHV0aWxzX2pzXzEuY2hlY2tPcHRzKSh7XG4gICAgICAgIGRrTGVuOiAzMixcbiAgICAgICAgYXN5bmNUaWNrOiAxMCxcbiAgICAgICAgbWF4bWVtOiAxMDI0ICoqIDMgKyAxMDI0LFxuICAgIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBhc3luY1RpY2ssIG1heG1lbSwgb25Qcm9ncmVzcyB9ID0gb3B0cztcbiAgICAoMCwgdXRpbHNfanNfMS5hc3NlcnROdW1iZXIpKE4pO1xuICAgICgwLCB1dGlsc19qc18xLmFzc2VydE51bWJlcikocik7XG4gICAgKDAsIHV0aWxzX2pzXzEuYXNzZXJ0TnVtYmVyKShwKTtcbiAgICAoMCwgdXRpbHNfanNfMS5hc3NlcnROdW1iZXIpKGRrTGVuKTtcbiAgICAoMCwgdXRpbHNfanNfMS5hc3NlcnROdW1iZXIpKGFzeW5jVGljayk7XG4gICAgKDAsIHV0aWxzX2pzXzEuYXNzZXJ0TnVtYmVyKShtYXhtZW0pO1xuICAgIGlmIChvblByb2dyZXNzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9uUHJvZ3Jlc3MgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvZ3Jlc3NDYiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICBjb25zdCBibG9ja1NpemUgPSAxMjggKiByO1xuICAgIGNvbnN0IGJsb2NrU2l6ZTMyID0gYmxvY2tTaXplIC8gNDtcbiAgICBpZiAoTiA8PSAxIHx8IChOICYgKE4gLSAxKSkgIT09IDAgfHwgTiA+PSAyICoqIChibG9ja1NpemUgLyA4KSB8fCBOID4gMiAqKiAzMikge1xuICAgICAgICAvLyBOT1RFOiB3ZSBsaW1pdCBOIHRvIGJlIGxlc3MgdGhhbiAyKiozMiBiZWNhdXNlIG9mIDMyIGJpdCB2YXJpYW50IG9mIEludGVncmlmeSBmdW5jdGlvblxuICAgICAgICAvLyBUaGVyZSBpcyBubyBKUyBlbmdpbmVzIHRoYXQgYWxsb3dzIGFsb2NhdGUgbW9yZSB0aGFuIDRHQiBwZXIgc2luZ2xlIFVpbnQ4QXJyYXkgZm9yIG5vdywgYnV0IGNhbiBjaGFuZ2UgaW4gZnV0dXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogTiBtdXN0IGJlIGxhcmdlciB0aGFuIDEsIGEgcG93ZXIgb2YgMiwgbGVzcyB0aGFuIDJeKDEyOCAqIHIgLyA4KSBhbmQgbGVzcyB0aGFuIDJeMzInKTtcbiAgICB9XG4gICAgaWYgKHAgPCAwIHx8IHAgPiAoKDIgKiogMzIgLSAxKSAqIDMyKSAvIGJsb2NrU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogcCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gKCgyXjMyIC0gMSkgKiAzMikgLyAoMTI4ICogciknKTtcbiAgICB9XG4gICAgaWYgKGRrTGVuIDwgMCB8fCBka0xlbiA+ICgyICoqIDMyIC0gMSkgKiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogZGtMZW4gc2hvdWxkIGJlIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICgyXjMyIC0gMSkgKiAzMicpO1xuICAgIH1cbiAgICBjb25zdCBtZW1Vc2VkID0gYmxvY2tTaXplICogKE4gKyBwKTtcbiAgICBpZiAobWVtVXNlZCA+IG1heG1lbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjcnlwdDogcGFyYW1ldGVycyB0b28gbGFyZ2UsICR7bWVtVXNlZH0gKDEyOCAqIHIgKiAoTiArIHApKSA+ICR7bWF4bWVtfSAobWF4bWVtKWApO1xuICAgIH1cbiAgICAvLyBbQjAuLi5CcOKIkjFdIOKGkCBQQktERjJITUFDLVNIQTI1NihQYXNzcGhyYXNlLCBTYWx0LCAxLCBibG9ja1NpemUqUGFyYWxsZWxpemF0aW9uRmFjdG9yKVxuICAgIC8vIFNpbmNlIGl0IGhhcyBvbmx5IG9uZSBpdGVyYXRpb24gdGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSBhc3luYyB2YXJpYW50XG4gICAgY29uc3QgQiA9ICgwLCBwYmtkZjJfanNfMS5wYmtkZjIpKHNoYTI1Nl9qc18xLnNoYTI1NiwgcGFzc3dvcmQsIHNhbHQsIHsgYzogMSwgZGtMZW46IGJsb2NrU2l6ZSAqIHAgfSk7XG4gICAgY29uc3QgQjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShCKTtcbiAgICAvLyBSZS11c2VkIGJldHdlZW4gcGFyYWxsZWwgaXRlcmF0aW9ucy4gQXJyYXkoaXRlcmF0aW9ucykgb2YgQlxuICAgIGNvbnN0IFYgPSAoMCwgdXRpbHNfanNfMS51MzIpKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSAqIE4pKTtcbiAgICBjb25zdCB0bXAgPSAoMCwgdXRpbHNfanNfMS51MzIpKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSkpO1xuICAgIGxldCBibG9ja01peENiID0gKCkgPT4geyB9O1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsQmxvY2tNaXggPSAyICogTiAqIHA7XG4gICAgICAgIC8vIEludm9rZSBjYWxsYmFjayBpZiBwcm9ncmVzcyBjaGFuZ2VzIGZyb20gMTAuMDEgdG8gMTAuMDJcbiAgICAgICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tQZXIgPSBNYXRoLm1heChNYXRoLmZsb29yKHRvdGFsQmxvY2tNaXggLyAxMDAwMCksIDEpO1xuICAgICAgICBsZXQgYmxvY2tNaXhDbnQgPSAwO1xuICAgICAgICBibG9ja01peENiID0gKCkgPT4ge1xuICAgICAgICAgICAgYmxvY2tNaXhDbnQrKztcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzICYmICghKGJsb2NrTWl4Q250ICUgY2FsbGJhY2tQZXIpIHx8IGJsb2NrTWl4Q250ID09PSB0b3RhbEJsb2NrTWl4KSlcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKGJsb2NrTWl4Q250IC8gdG90YWxCbG9ja01peCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9O1xufVxuZnVuY3Rpb24gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKSB7XG4gICAgY29uc3QgcmVzID0gKDAsIHBia2RmMl9qc18xLnBia2RmMikoc2hhMjU2X2pzXzEuc2hhMjU2LCBwYXNzd29yZCwgQiwgeyBjOiAxLCBka0xlbiB9KTtcbiAgICBCLmZpbGwoMCk7XG4gICAgVi5maWxsKDApO1xuICAgIHRtcC5maWxsKDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3NcbiAqIEBwYXJhbSBzYWx0IC0gc2FsdFxuICogQHBhcmFtIG9wdHMgLSBwYXJhbWV0ZXJzXG4gKiAtIGBOYCBpcyBjcHUvbWVtIHdvcmsgZmFjdG9yIChwb3dlciBvZiAyIGUuZy4gMioqMTgpXG4gKiAtIGByYCBpcyBibG9jayBzaXplICg4IGlzIGNvbW1vbiksIGZpbmUtdHVuZXMgc2VxdWVudGlhbCBtZW1vcnkgcmVhZCBzaXplIGFuZCBwZXJmb3JtYW5jZVxuICogLSBgcGAgaXMgcGFyYWxsZWxpemF0aW9uIGZhY3RvciAoMSBpcyBjb21tb24pXG4gKiAtIGBka0xlbmAgaXMgb3V0cHV0IGtleSBsZW5ndGggaW4gYnl0ZXMgZS5nLiAzMi5cbiAqIC0gYGFzeW5jVGlja2AgLSAoZGVmYXVsdDogMTApIG1heCB0aW1lIGluIG1zIGZvciB3aGljaCBhc3luYyBmdW5jdGlvbiBjYW4gYmxvY2sgZXhlY3V0aW9uXG4gKiAtIGBtYXhtZW1gIC0gKGRlZmF1bHQ6IGAxMDI0ICoqIDMgKyAxMDI0YCBha2EgMUdCKzFLQikuIEEgbGltaXQgdGhhdCB0aGUgYXBwIGNvdWxkIHVzZSBmb3Igc2NyeXB0XG4gKiAtIGBvblByb2dyZXNzYCAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgZXhlY3V0ZWQgZm9yIHByb2dyZXNzIHJlcG9ydFxuICogQHJldHVybnMgRGVyaXZlZCBrZXlcbiAqL1xuZnVuY3Rpb24gc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiIH0gPSBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBmb3IgKGxldCBwaSA9IDA7IHBpIDwgcDsgcGkrKykge1xuICAgICAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplMzI7IGkrKylcbiAgICAgICAgICAgIFZbaV0gPSBCMzJbUGkgKyBpXTsgLy8gVlswXSA9IEJbaV1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBOIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBCbG9ja01peChWLCBwb3MsIFYsIChwb3MgKz0gYmxvY2tTaXplMzIpLCByKTsgLy8gVltpXSA9IEJsb2NrTWl4KFZbaS0xXSk7XG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH1cbiAgICAgICAgQmxvY2tNaXgoViwgKE4gLSAxKSAqIGJsb2NrU2l6ZTMyLCBCMzIsIFBpLCByKTsgLy8gUHJvY2VzcyBsYXN0IGVsZW1lbnRcbiAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICAgICAgLy8gRmlyc3QgdTMyIG9mIHRoZSBsYXN0IDY0LWJ5dGUgYmxvY2sgKHUzMiBpcyBMRSlcbiAgICAgICAgICAgIGNvbnN0IGogPSBCMzJbUGkgKyBibG9ja1NpemUzMiAtIDE2XSAlIE47IC8vIGogPSBJbnRlZ3JpZnkoWCkgJSBpdGVyYXRpb25zXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGJsb2NrU2l6ZTMyOyBrKyspXG4gICAgICAgICAgICAgICAgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxuICAgICAgICAgICAgQmxvY2tNaXgodG1wLCAwLCBCMzIsIFBpLCByKTsgLy8gQiA9IEJsb2NrTWl4KEIgXiBWW2pdKVxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xufVxuZXhwb3J0cy5zY3J5cHQgPSBzY3J5cHQ7XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2NyeXB0QXN5bmMocGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9ID0gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcbiAgICAgICAgY29uc3QgUGkgPSBibG9ja1NpemUzMiAqIHBpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTMyOyBpKyspXG4gICAgICAgICAgICBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBhd2FpdCAoMCwgdXRpbHNfanNfMS5hc3luY0xvb3ApKE4gLSAxLCBhc3luY1RpY2ssIChpKSA9PiB7XG4gICAgICAgICAgICBCbG9ja01peChWLCBwb3MsIFYsIChwb3MgKz0gYmxvY2tTaXplMzIpLCByKTsgLy8gVltpXSA9IEJsb2NrTWl4KFZbaS0xXSk7XG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxuICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIGF3YWl0ICgwLCB1dGlsc19qc18xLmFzeW5jTG9vcCkoTiwgYXN5bmNUaWNrLCAoaSkgPT4ge1xuICAgICAgICAgICAgLy8gRmlyc3QgdTMyIG9mIHRoZSBsYXN0IDY0LWJ5dGUgYmxvY2sgKHUzMiBpcyBMRSlcbiAgICAgICAgICAgIGNvbnN0IGogPSBCMzJbUGkgKyBibG9ja1NpemUzMiAtIDE2XSAlIE47IC8vIGogPSBJbnRlZ3JpZnkoWCkgJSBpdGVyYXRpb25zXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGJsb2NrU2l6ZTMyOyBrKyspXG4gICAgICAgICAgICAgICAgdG1wW2tdID0gQjMyW1BpICsga10gXiBWW2ogKiBibG9ja1NpemUzMiArIGtdOyAvLyB0bXAgPSBCIF4gVltqXVxuICAgICAgICAgICAgQmxvY2tNaXgodG1wLCAwLCBCMzIsIFBpLCByKTsgLy8gQiA9IEJsb2NrTWl4KEIgXiBWW2pdKVxuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCk7XG59XG5leHBvcnRzLnNjcnlwdEFzeW5jID0gc2NyeXB0QXN5bmM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/scrypt.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha256.js':
    /*!*******************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha256.js ***!
  \*******************************************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict';
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.sha256 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_sha2.js");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ "(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js");\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0Bva3h3ZWIzL2NyeXB0by1saWIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzP2M2YjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTI1NiA9IHZvaWQgMDtcbmNvbnN0IF9zaGEyX2pzXzEgPSByZXF1aXJlKFwiLi9fc2hhMi5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBfc2hhMl9qc18xLlNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCA3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgNikgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAxMSkgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMikgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAxMykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnNoYTI1NiA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTI1NigpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha256.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha3.js':
    /*!*****************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha3.js ***!
  \*****************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\nconst u64 = __importStar(__webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_u64.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js\");\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);\nconst rotlL = (h, l, s) => s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexports.keccakP = keccakP;\nclass Keccak extends utils_js_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0, utils_js_1.assertNumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_js_1.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        const { blockLen, state } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array))\n            throw new Error('Keccak: invalid output buffer');\n        this.finish();\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= this.blockLen)\n                this.keccak();\n            const take = Math.min(this.blockLen - this.posOut, len - pos);\n            out.set(this.state.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, utils_js_1.assertNumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        if (out.length < this.outputLen)\n            throw new Error('Keccak: invalid output buffer');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.finish();\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen !== undefined ? opts.dkLen : outputLen, true));\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGVBQWU7QUFDdE8seUJBQXlCLG1CQUFPLENBQUMsOEZBQVc7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLG9HQUFvRztBQUNwRyxnQkFBZ0I7QUFDaEIsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEzLmpzPzZlMmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBleHBvcnRzLnNoYWtlMTI4ID0gZXhwb3J0cy5rZWNjYWtfNTEyID0gZXhwb3J0cy5rZWNjYWtfMzg0ID0gZXhwb3J0cy5rZWNjYWtfMjU2ID0gZXhwb3J0cy5rZWNjYWtfMjI0ID0gZXhwb3J0cy5zaGEzXzUxMiA9IGV4cG9ydHMuc2hhM18zODQgPSBleHBvcnRzLnNoYTNfMjU2ID0gZXhwb3J0cy5zaGEzXzIyNCA9IGV4cG9ydHMuS2VjY2FrID0gZXhwb3J0cy5rZWNjYWtQID0gdm9pZCAwO1xuY29uc3QgdTY0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL191NjQuanNcIikpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgW1NIQTNfUEksIFNIQTNfUk9UTCwgX1NIQTNfSU9UQV0gPSBbW10sIFtdLCBbXV07XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfN24gPSBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gdTY0LnNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiBzID4gMzIgPyB1NjQucm90bEJIKGgsIGwsIHMpIDogdTY0LnJvdGxTSChoLCBsLCBzKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IHU2NC5yb3RsQkwoaCwgbCwgcykgOiB1NjQucm90bFNMKGgsIGwsIHMpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5mdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnRzLmtlY2Nha1AgPSBrZWNjYWtQO1xuY2xhc3MgS2VjY2FrIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgICgwLCB1dGlsc19qc18xLmFzc2VydE51bWJlcikob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3RhbmNlIGlzIGRlc3Ryb3llZCcpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3RhbmNlIGlzIGRlc3Ryb3llZCcpO1xuICAgICAgICBpZiAoIShvdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2VjY2FrOiBpbnZhbGlkIG91dHB1dCBidWZmZXInKTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IHRoaXMuYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbih0aGlzLmJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KHRoaXMuc3RhdGUuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuYXNzZXJ0TnVtYmVyKShieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgaWYgKG91dC5sZW5ndGggPCB0aGlzLm91dHB1dExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2VjY2FrOiBpbnZhbGlkIG91dHB1dCBidWZmZXInKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0cy5zaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMuc2hhM18zODQgPSBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydHMuc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMjI0ID0gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9IGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLmtlY2Nha181MTIgPSBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3JXaXRoT3B0cykoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuICE9PSB1bmRlZmluZWQgPyBvcHRzLmRrTGVuIDogb3V0cHV0TGVuLCB0cnVlKSk7XG5leHBvcnRzLnNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha3.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha512.js':
    /*!*******************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha512.js ***!
  \*******************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      'use strict';
      eval(
        "\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha384 = exports.sha512_256 = exports.sha512 = exports.SHA512 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_sha2.js\");\nconst u64 = __importStar(__webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/_u64.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js\");\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n)));\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nclass SHA512 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());\nexports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());\nexports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGE1MTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDckUsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQVk7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsOEZBQVc7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQjtBQUNsQixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGE1MTIuanM/MGQxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEzODQgPSBleHBvcnRzLnNoYTUxMl8yNTYgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuU0hBNTEyID0gdm9pZCAwO1xuY29uc3QgX3NoYTJfanNfMSA9IHJlcXVpcmUoXCIuL19zaGEyLmpzXCIpO1xuY29uc3QgdTY0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL191NjQuanNcIikpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUm91bmQgY29udGFudHMgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBbU0hBNTEyX0toLCBTSEE1MTJfS2xdID0gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5jb25zdCBTSEE1MTJfV19MID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNsYXNzIFNIQTUxMiBleHRlbmRzIF9zaGEyX2pzXzEuU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDEyOCwgNjQsIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGUgd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBBbHNvIGxvb2tzIGNsZWFuZXIgYW5kIGVhc2llciB0byB2ZXJpZnkgd2l0aCBzcGVjLlxuICAgICAgICAvLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4NmEwOWU2NjcgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmM2JjYzkwOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweGJiNjdhZTg1IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODRjYWE3M2IgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgzYzZlZjM3MiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweGZlOTRmODJiIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4YTU0ZmY1M2EgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ZjFkMzZmMSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDUxMGU1MjdmIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YWRlNjgyZDEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg5YjA1Njg4YyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDJiM2U2YzFmIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MWY4M2Q5YWIgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHhmYjQxYmQ2YiB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDViZTBjZDE5IHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4MTM3ZTIxNzkgfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBNTEyX1dfSC5maWxsKDApO1xuICAgICAgICBTSEE1MTJfV19MLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyID0gU0hBNTEyO1xuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDIyMzEyMTk0IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZmMyYmY3MmMgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweGM4NGM2NGMyIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MjM5M2I4NmIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDk2Mzg3NzE5IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTk0MGVhYmQgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGE4OGVmZmUzIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4YmU1ZTFlMjUgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDJiMDE5OWZjIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4MmM4NWI4YWEgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDgxYzUyY2EyIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAzMjtcbiAgICB9XG59XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHhjYmJiOWQ1ZCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDkxNTkwMTVhIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHgxNTJmZWNkOCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDhlYjQ0YTg3IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHhkYjBjMmUwZCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gNDg7XG4gICAgfVxufVxuZXhwb3J0cy5zaGE1MTIgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEE1MTIoKSk7XG5leHBvcnRzLnNoYTUxMl8yNTYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuZXhwb3J0cy5zaGEzODQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEzODQoKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/sha512.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js':
    /*!******************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js ***!
  \******************************************************************************/
    /***/ (module, exports, __webpack_require__) => {
      'use strict';
      eval(
        "/* module decorator */ module = __webpack_require__.nmd(module);\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.assertHash = exports.assertBytes = exports.assertBool = exports.assertNumber = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/crypto.js\");\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianess.\n// So, just to be sure not to corrupt anything.\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nfunction bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('deadbeef')\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte))\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// Currently avoid insertion of polyfills with packers (browserify/webpack/etc)\n// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here\nexports.nextTick = (() => {\n    const nodeRequire =  true &&\n        typeof module.require === 'function' &&\n        module.require.bind(module);\n    try {\n        if (nodeRequire) {\n            const { setImmediate } = nodeRequire('timers');\n            return () => new Promise((resolve) => setImmediate(resolve));\n        }\n    }\n    catch (e) { }\n    return () => new Promise((resolve) => setTimeout(resolve, 0));\n})();\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexports.utf8ToBytes = utf8ToBytes;\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexports.concatBytes = concatBytes;\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\nfunction assertBool(b) {\n    if (typeof b !== 'boolean') {\n        throw new Error(`Expected boolean, not ${b}`);\n    }\n}\nexports.assertBool = assertBool;\nfunction assertBytes(bytes, ...lengths) {\n    if (bytes instanceof Uint8Array && (!lengths.length || lengths.includes(bytes.length))) {\n        return;\n    }\n    throw new TypeError(`Expected ${lengths} bytes, not ${typeof bytes} with length=${bytes.length}`);\n}\nexports.assertBytes = assertBytes;\nfunction assertHash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    assertNumber(hash.outputLen);\n    assertNumber(hash.blockLen);\n}\nexports.assertHash = assertHash;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(def, _opts) {\n    if (_opts !== undefined && (typeof _opts !== 'object' || !isPlainObject(_opts)))\n        throw new TypeError('Options should be object or undefined');\n    const opts = Object.assign(def, _opts);\n    return opts;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\n/**\n * Secure PRNG\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto.web) {\n        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto_1.crypto.node) {\n        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\nexports.randomBytes = randomBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsa0JBQWtCLEdBQUcsV0FBVyxHQUFHLFVBQVU7QUFDdGE7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDJHQUFzQjtBQUMvQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQix3QkFBd0IsS0FBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFlBQVk7QUFDbEY7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyxhQUFhLGNBQWMsY0FBYyxhQUFhO0FBQ25HO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzPzU4NzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5jaGVja09wdHMgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLmFzc2VydEhhc2ggPSBleHBvcnRzLmFzc2VydEJ5dGVzID0gZXhwb3J0cy5hc3NlcnRCb29sID0gZXhwb3J0cy5hc3NlcnROdW1iZXIgPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0J5dGVzID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuYXN5bmNMb29wID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbi8vIFRoZSBpbXBvcnQgaGVyZSBpcyB2aWEgdGhlIHBhY2thZ2UgbmFtZS4gVGhpcyBpcyB0byBlbnN1cmVcbi8vIHRoYXQgZXhwb3J0cyBtYXBwaW5nL3Jlc29sdXRpb24gZG9lcyBmYWxsIGludG8gcGxhY2UuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuLy8gVGhlcmUgaXMgYWxtb3N0IG5vIGJpZyBlbmRpYW4gaGFyZHdhcmUsIGJ1dCBqcyB0eXBlZCBhcnJheXMgdXNlcyBwbGF0Zm9ybSBzcGVjaWZpYyBlbmRpYW5lc3MuXG4vLyBTbywganVzdCB0byBiZSBzdXJlIG5vdCB0byBjb3JydXB0IGFueXRoaW5nLlxuaWYgKCFleHBvcnRzLmlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGRlLCAweGFkLCAweGJlLCAweGVmXSkpXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgodWludDhhKSB7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnZGVhZGJlZWYnKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBDdXJyZW50bHkgYXZvaWQgaW5zZXJ0aW9uIG9mIHBvbHlmaWxscyB3aXRoIHBhY2tlcnMgKGJyb3dzZXJpZnkvd2VicGFjay9ldGMpXG4vLyBCdXQgc2V0VGltZW91dCBpcyBwcmV0dHkgc2xvdywgbWF5YmUgd29ydGggdG8gaW52ZXN0aWdhdGUgaG93dG8gZG8gbWluaW1hbCBwb2x5ZmlsbCBoZXJlXG5leHBvcnRzLm5leHRUaWNrID0gKCgpID0+IHtcbiAgICBjb25zdCBub2RlUmVxdWlyZSA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBtb2R1bGUucmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICBtb2R1bGUucmVxdWlyZS5iaW5kKG1vZHVsZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG5vZGVSZXF1aXJlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNldEltbWVkaWF0ZSB9ID0gbm9kZVJlcXVpcmUoJ3RpbWVycycpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRJbW1lZGlhdGUocmVzb2x2ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xufSkoKTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHR5cGUgaXMgVWludDhBcnJheSAoZ290ICR7dHlwZW9mIGRhdGF9KWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29uY2F0cyBVaW50OEFycmF5LXMgaW50byBvbmU7IGxpa2UgYEJ1ZmZlci5jb25jYXQoW2J1ZjEsIGJ1ZjJdKWBcbiAqIEBleGFtcGxlIGNvbmNhdEJ5dGVzKGJ1ZjEsIGJ1ZjIpXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBsaXN0IGV4cGVjdGVkJyk7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbmZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnRzLmFzc2VydE51bWJlciA9IGFzc2VydE51bWJlcjtcbmZ1bmN0aW9uIGFzc2VydEJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydEJvb2wgPSBhc3NlcnRCb29sO1xuZnVuY3Rpb24gYXNzZXJ0Qnl0ZXMoYnl0ZXMsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmICghbGVuZ3Rocy5sZW5ndGggfHwgbGVuZ3Rocy5pbmNsdWRlcyhieXRlcy5sZW5ndGgpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICR7bGVuZ3Roc30gYnl0ZXMsIG5vdCAke3R5cGVvZiBieXRlc30gd2l0aCBsZW5ndGg9JHtieXRlcy5sZW5ndGh9YCk7XG59XG5leHBvcnRzLmFzc2VydEJ5dGVzID0gYXNzZXJ0Qnl0ZXM7XG5mdW5jdGlvbiBhc3NlcnRIYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgYXNzZXJ0TnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBhc3NlcnROdW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5leHBvcnRzLmFzc2VydEhhc2ggPSBhc3NlcnRIYXNoO1xuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNoID0gSGFzaDtcbi8vIENoZWNrIGlmIG9iamVjdCBkb2Vucyd0IGhhdmUgY3VzdG9tIGNvbnN0cnVjdG9yIChsaWtlIFVpbnQ4QXJyYXkvQXJyYXkpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZiwgX29wdHMpIHtcbiAgICBpZiAoX29wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIF9vcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChfb3B0cykpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oZGVmLCBfb3B0cyk7XG4gICAgcmV0dXJuIG9wdHM7XG59XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtZXNzYWdlKSA9PiBoYXNoQ29uc3RydWN0b3IoKS51cGRhdGUodG9CeXRlcyhtZXNzYWdlKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IHdyYXBDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuLyoqXG4gKiBTZWN1cmUgUFJOR1xuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0by53ZWIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by53ZWIuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNyeXB0b18xLmNyeXB0by5ub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShjcnlwdG9fMS5jcnlwdG8ubm9kZS5yYW5kb21CeXRlcyhieXRlc0xlbmd0aCkuYnVmZmVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgcmFuZG9tQnl0ZXMgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@noble/hashes/utils.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@scure/base/index.js':
    /*!****************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/node_modules/@scure/base/index.js ***!
  \****************************************************************************/
    /***/ (__unused_webpack_module, exports) => {
      'use strict';
      eval(
        "\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const [prefix, _words] = [str.slice(0, sepIndex), str.slice(sepIndex + 1)];\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9reHdlYjMvY3J5cHRvLWxpYi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcscUJBQXFCLEdBQUcsV0FBVyxHQUFHLHFCQUFxQixHQUFHLFdBQVcsR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLHVCQUF1QixHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLG9CQUFvQjtBQUM3WTtBQUNBO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxHQUFHLGFBQWEsZ0JBQWdCO0FBQ3JHO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBLHdEQUF3RCxPQUFPLGNBQWMsU0FBUztBQUN0RjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0Esa0RBQWtELEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQSxtREFBbUQsR0FBRztBQUN0RDtBQUNBLDhEQUE4RCxNQUFNLEtBQUssSUFBSSxZQUFZLHNCQUFzQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEdBQUcsT0FBTyxLQUFLO0FBQy9FO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSyxPQUFPLEtBQUs7QUFDbEY7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGNBQWM7QUFDZCxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QixjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCO0FBQ0EsY0FBYztBQUNkLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxjQUFjO0FBQ3hGO0FBQ0EsbUZBQW1GLGFBQWE7QUFDaEc7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLGdCQUFnQixNQUFNO0FBQzlFO0FBQ0Esa0JBQWtCLE9BQU8sR0FBRyw0QkFBNEIsRUFBRSw0Q0FBNEM7QUFDdEc7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFdBQVc7QUFDcEY7QUFDQSx3REFBd0QsWUFBWSxHQUFHLElBQUksa0JBQWtCLE1BQU07QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSxjQUFjLElBQUk7QUFDekUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkLGVBQWU7QUFDZixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZ0VBQWdFLFVBQVUsY0FBYyxTQUFTO0FBQ2pHO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwrQkFBK0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab2t4d2ViMy9jcnlwdG8tbGliL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9pbmRleC5qcz9jOWI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGV4cG9ydHMuaGV4ID0gZXhwb3J0cy51dGY4ID0gZXhwb3J0cy5iZWNoMzJtID0gZXhwb3J0cy5iZWNoMzIgPSBleHBvcnRzLmJhc2U1OGNoZWNrID0gZXhwb3J0cy5iYXNlNTh4bXIgPSBleHBvcnRzLmJhc2U1OHhycCA9IGV4cG9ydHMuYmFzZTU4ZmxpY2tyID0gZXhwb3J0cy5iYXNlNTggPSBleHBvcnRzLmJhc2U2NHVybCA9IGV4cG9ydHMuYmFzZTY0ID0gZXhwb3J0cy5iYXNlMzJjcm9ja2ZvcmQgPSBleHBvcnRzLmJhc2UzMmhleCA9IGV4cG9ydHMuYmFzZTMyID0gZXhwb3J0cy5iYXNlMTYgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy5hc3NlcnROdW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5hc3NlcnROdW1iZXIgPSBhc3NlcnROdW1iZXI7XG5mdW5jdGlvbiBjaGFpbiguLi5hcmdzKSB7XG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICBjb25zdCBlbmNvZGUgPSBBcnJheS5mcm9tKGFyZ3MpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZW5jb2RlKSA6IGkuZW5jb2RlKSwgdW5kZWZpbmVkKTtcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZGVjb2RlKSA6IGkuZGVjb2RlKSwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuZnVuY3Rpb24gYWxwaGFiZXQoYWxwaGFiZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXIoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gYWxwaGFiZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7aX0gKGFscGhhYmV0OiAke2FscGhhYmV0Lmxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV0dGVyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke2xldHRlcn1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2FscGhhYmV0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJvbSkgfHwgKGZyb20ubGVuZ3RoICYmIHR5cGVvZiBmcm9tWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBmcm9tKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9ybWFsaXplIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7IGVuY29kZTogKGZyb20pID0+IGZyb20sIGRlY29kZTogKHRvKSA9PiBmbih0bykgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeChkYXRhLCBmcm9tLCB0bykge1xuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICBkaWdpdHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBhc3NlcnROdW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7ZH1gKTtcbiAgICB9KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbSAqIGNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICAoZnJvbSAqIGNhcnJ5KSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb20gKiBjYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IE1hdGguZmxvb3IoZGlnaXRCYXNlIC8gdG8pO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdHNbaV0pIHx8IGRpZ2l0c1tpXSAqIHRvICsgY2FycnkgIT09IGRpZ2l0QmFzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFkaWdpdHNbaV0pXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gKGEsIGIpID0+ICghYiA/IGEgOiBnY2QoYiwgYSAlIGIpKTtcbmNvbnN0IHJhZGl4MmNhcnJ5ID0gKGZyb20sIHRvKSA9PiBmcm9tICsgKHRvIC0gZ2NkKGZyb20sIHRvKSk7XG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGEsIGZyb20sIHRvLCBwYWRkaW5nKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDI6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgbWFzayA9IDIgKiogdG8gLSAxO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgICAgIGFzc2VydE51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gMiAqKiBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjYXJyeSAmPSAyICoqIHBvcyAtIDE7XG4gICAgfVxuICAgIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgICBpZiAoIXBhZGRpbmcgJiYgcG9zID49IGZyb20pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZXNzIHBhZGRpbmcnKTtcbiAgICBpZiAoIXBhZGRpbmcgJiYgY2FycnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXplcm8gcGFkZGluZzogJHtjYXJyeX1gKTtcbiAgICBpZiAocGFkZGluZyAmJiBwb3MgPiAwKVxuICAgICAgICByZXMucHVzaChjYXJyeSA+Pj4gMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHJhZGl4KG51bSkge1xuICAgIGFzc2VydE51bWJlcihudW0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4KEFycmF5LmZyb20oYnl0ZXMpLCAyICoqIDgsIG51bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgMiAqKiA4KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKGJpdHMgPD0gMCB8fCBiaXRzID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdJyk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhc3NlcnROdW1iZXIobGVuKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChjaGVja3N1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLnV0aWxzID0geyBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nIH07XG5leHBvcnRzLmJhc2UxNiA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzIgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbmV4cG9ydHMuYmFzZTY0ID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2U2NHVybCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0cy5iYXNlNThmbGlja3IgPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbmV4cG9ydHMuYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG5leHBvcnRzLmJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBleHBvcnRzLmJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGV4cG9ydHMuYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBleHBvcnRzLmJhc2U1OCk7XG5leHBvcnRzLmJhc2U1OGNoZWNrID0gYmFzZTU4Y2hlY2s7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7YmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzdHIubGVuZ3RoID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtzdHIubGVuZ3RofSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgW3ByZWZpeCwgX3dvcmRzXSA9IFtzdHIuc2xpY2UoMCwgc2VwSW5kZXgpLCBzdHIuc2xpY2Uoc2VwSW5kZXggKyAxKV07XG4gICAgICAgIGlmIChfd29yZHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoX3dvcmRzKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghX3dvcmRzLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlVG9CeXRlcywgZGVjb2RlVW5zYWZlLCBmcm9tV29yZHMsIGZyb21Xb3Jkc1Vuc2FmZSwgdG9Xb3JkcyB9O1xufVxuZXhwb3J0cy5iZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0cy5iZWNoMzJtID0gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG5leHBvcnRzLnV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0cy5oZXggPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0Zjg6IGV4cG9ydHMudXRmOCwgaGV4OiBleHBvcnRzLmhleCwgYmFzZTE2OiBleHBvcnRzLmJhc2UxNiwgYmFzZTMyOiBleHBvcnRzLmJhc2UzMiwgYmFzZTY0OiBleHBvcnRzLmJhc2U2NCwgYmFzZTY0dXJsOiBleHBvcnRzLmJhc2U2NHVybCwgYmFzZTU4OiBleHBvcnRzLmJhc2U1OCwgYmFzZTU4eG1yOiBleHBvcnRzLmJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gYEludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiAke09iamVjdC5rZXlzKENPREVSUykuam9pbignLCAnKX1gO1xuY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuZXhwb3J0cy5zdHIgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmc7XG5jb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbmV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@okxweb3/crypto-lib/node_modules/@scure/base/index.js\n",
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/@okxweb3/crypto-lib/dist/bip39/wordlists/english.json':
    /*!****************************************************************************!*\
  !*** ./node_modules/@okxweb3/crypto-lib/dist/bip39/wordlists/english.json ***!
  \****************************************************************************/
    /***/ (module) => {
      'use strict';
      module.exports = /*#__PURE__*/ JSON.parse(
        '["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]',
      );

      /***/
    },
};

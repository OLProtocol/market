/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hdkey";
exports.ids = ["vendor-chunks/hdkey"];
exports.modules = {

/***/ "(ssr)/./node_modules/hdkey/lib/hdkey.js":
/*!*****************************************!*\
  !*** ./node_modules/hdkey/lib/hdkey.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assert = __webpack_require__(/*! assert */ \"assert\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\")\nvar bs58check = __webpack_require__(/*! bs58check */ \"(ssr)/./node_modules/hdkey/node_modules/bs58check/index.js\")\nvar RIPEMD160 = __webpack_require__(/*! ripemd160 */ \"(ssr)/./node_modules/ripemd160/index.js\")\nvar secp256k1 = __webpack_require__(/*! secp256k1 */ \"(ssr)/./node_modules/secp256k1/index.js\")\n\nvar MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')\nvar HARDENED_OFFSET = 0x80000000\nvar LEN = 78\n\n// Bitcoin hardcoded by default, can use package `coininfo` for others\nvar BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}\n\nfunction HDKey (versions) {\n  this.versions = versions || BITCOIN_VERSIONS\n  this.depth = 0\n  this.index = 0\n  this._privateKey = null\n  this._publicKey = null\n  this.chainCode = null\n  this._fingerprint = 0\n  this.parentFingerprint = 0\n}\n\nObject.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })\nObject.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })\nObject.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })\n\nObject.defineProperty(HDKey.prototype, 'privateKey', {\n  get: function () {\n    return this._privateKey\n  },\n  set: function (value) {\n    assert.equal(value.length, 32, 'Private key must be 32 bytes.')\n    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')\n\n    this._privateKey = value\n    this._publicKey = Buffer.from(secp256k1.publicKeyCreate(value, true))\n    this._identifier = hash160(this.publicKey)\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)\n  }\n})\n\nfunction setPublicKey (hdkey, publicKey) {\n  hdkey._publicKey = Buffer.from(publicKey)\n  hdkey._identifier = hash160(publicKey)\n  hdkey._fingerprint = hdkey._identifier.slice(0, 4).readUInt32BE(0)\n  hdkey._privateKey = null\n}\n\nObject.defineProperty(HDKey.prototype, 'publicKey', {\n  get: function () {\n    return this._publicKey\n  },\n  set: function (value) {\n    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')\n    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')\n    // force compressed point (performs public key verification)\n    const publicKey = (value.length === 65) ? secp256k1.publicKeyConvert(value, true) : value\n    setPublicKey(this, publicKey)\n  }\n})\n\nObject.defineProperty(HDKey.prototype, 'privateExtendedKey', {\n  get: function () {\n    if (this._privateKey) return bs58check.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))\n    else return null\n  }\n})\n\nObject.defineProperty(HDKey.prototype, 'publicExtendedKey', {\n  get: function () {\n    return bs58check.encode(serialize(this, this.versions.public, this.publicKey))\n  }\n})\n\nHDKey.prototype.derive = function (path) {\n  if (path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return this\n  }\n\n  var entries = path.split('/')\n  var hdkey = this\n  entries.forEach(function (c, i) {\n    if (i === 0) {\n      assert(/^[mM]{1}/.test(c), 'Path must start with \"m\" or \"M\"')\n      return\n    }\n\n    var hardened = (c.length > 1) && (c[c.length - 1] === \"'\")\n    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)\n    assert(childIndex < HARDENED_OFFSET, 'Invalid index')\n    if (hardened) childIndex += HARDENED_OFFSET\n\n    hdkey = hdkey.deriveChild(childIndex)\n  })\n\n  return hdkey\n}\n\nHDKey.prototype.deriveChild = function (index) {\n  var isHardened = index >= HARDENED_OFFSET\n  var indexBuffer = Buffer.allocUnsafe(4)\n  indexBuffer.writeUInt32BE(index, 0)\n\n  var data\n\n  if (isHardened) { // Hardened child\n    assert(this.privateKey, 'Could not derive hardened child key')\n\n    var pk = this.privateKey\n    var zb = Buffer.alloc(1, 0)\n    pk = Buffer.concat([zb, pk])\n\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data = Buffer.concat([pk, indexBuffer])\n  } else { // Normal child\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    data = Buffer.concat([this.publicKey, indexBuffer])\n  }\n\n  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  var hd = new HDKey(this.versions)\n\n  // Private parent key -> private child key\n  if (this.privateKey) {\n    // ki = parse256(IL) + kpar (mod n)\n    try {\n      hd.privateKey = Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(this.privateKey), IL))\n      // throw if IL >= n || (privateKey + IL) === 0\n    } catch (err) {\n      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i\n      return this.deriveChild(index + 1)\n    }\n  // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    try {\n      hd.publicKey = Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(this.publicKey), IL, true))\n      // throw if IL >= n || (g**IL + publicKey) is infinity\n    } catch (err) {\n      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i\n      return this.deriveChild(index + 1)\n    }\n  }\n\n  hd.chainCode = IR\n  hd.depth = this.depth + 1\n  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)\n  hd.index = index\n\n  return hd\n}\n\nHDKey.prototype.sign = function (hash) {\n  return Buffer.from(secp256k1.ecdsaSign(Uint8Array.from(hash), Uint8Array.from(this.privateKey)).signature)\n}\n\nHDKey.prototype.verify = function (hash, signature) {\n  return secp256k1.ecdsaVerify(\n    Uint8Array.from(signature),\n    Uint8Array.from(hash),\n    Uint8Array.from(this.publicKey)\n  )\n}\n\nHDKey.prototype.wipePrivateData = function () {\n  if (this._privateKey) crypto.randomBytes(this._privateKey.length).copy(this._privateKey)\n  this._privateKey = null\n  return this\n}\n\nHDKey.prototype.toJSON = function () {\n  return {\n    xpriv: this.privateExtendedKey,\n    xpub: this.publicExtendedKey\n  }\n}\n\nHDKey.fromMasterSeed = function (seedBuffer, versions) {\n  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  var hdkey = new HDKey(versions)\n  hdkey.chainCode = IR\n  hdkey.privateKey = IL\n\n  return hdkey\n}\n\nHDKey.fromExtendedKey = function (base58key, versions, skipVerification) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  versions = versions || BITCOIN_VERSIONS\n  skipVerification = skipVerification || false\n  var hdkey = new HDKey(versions)\n\n  var keyBuffer = bs58check.decode(base58key)\n\n  var version = keyBuffer.readUInt32BE(0)\n  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')\n\n  hdkey.depth = keyBuffer.readUInt8(4)\n  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)\n  hdkey.index = keyBuffer.readUInt32BE(9)\n  hdkey.chainCode = keyBuffer.slice(13, 45)\n\n  var key = keyBuffer.slice(45)\n  if (key.readUInt8(0) === 0) { // private\n    assert(version === versions.private, 'Version mismatch: version does not match private')\n    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte\n  } else {\n    assert(version === versions.public, 'Version mismatch: version does not match public')\n    if (skipVerification) {\n      setPublicKey(hdkey, key)\n    } else {\n      hdkey.publicKey = key\n    }\n  }\n\n  return hdkey\n}\n\nHDKey.fromJSON = function (obj) {\n  return HDKey.fromExtendedKey(obj.xpriv)\n}\n\nfunction serialize (hdkey, version, key) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  var buffer = Buffer.allocUnsafe(LEN)\n\n  buffer.writeUInt32BE(version, 0)\n  buffer.writeUInt8(hdkey.depth, 4)\n\n  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000\n  buffer.writeUInt32BE(fingerprint, 5)\n  buffer.writeUInt32BE(hdkey.index, 9)\n\n  hdkey.chainCode.copy(buffer, 13)\n  key.copy(buffer, 45)\n\n  return buffer\n}\n\nfunction hash160 (buf) {\n  var sha = crypto.createHash('sha256').update(buf).digest()\n  return new RIPEMD160().update(sha).digest()\n}\n\nHDKey.HARDENED_OFFSET = HARDENED_OFFSET\nmodule.exports = HDKey\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGRrZXkvbGliL2hka2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixhQUFhLDRGQUE2QjtBQUMxQyxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVc7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELG1CQUFtQiw0QkFBNEI7QUFDdkcsdURBQXVELG1CQUFtQiwyQkFBMkI7QUFDckcsdURBQXVELG1CQUFtQiwwQkFBMEI7O0FBRXBHO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9oZGtleS9saWIvaGRrZXkuanM/OGMxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG52YXIgYnM1OGNoZWNrID0gcmVxdWlyZSgnYnM1OGNoZWNrJylcbnZhciBSSVBFTUQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ3NlY3AyNTZrMScpXG5cbnZhciBNQVNURVJfU0VDUkVUID0gQnVmZmVyLmZyb20oJ0JpdGNvaW4gc2VlZCcsICd1dGY4JylcbnZhciBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwXG52YXIgTEVOID0gNzhcblxuLy8gQml0Y29pbiBoYXJkY29kZWQgYnkgZGVmYXVsdCwgY2FuIHVzZSBwYWNrYWdlIGBjb2luaW5mb2AgZm9yIG90aGVyc1xudmFyIEJJVENPSU5fVkVSU0lPTlMgPSB7cHJpdmF0ZTogMHgwNDg4QURFNCwgcHVibGljOiAweDA0ODhCMjFFfVxuXG5mdW5jdGlvbiBIREtleSAodmVyc2lvbnMpIHtcbiAgdGhpcy52ZXJzaW9ucyA9IHZlcnNpb25zIHx8IEJJVENPSU5fVkVSU0lPTlNcbiAgdGhpcy5kZXB0aCA9IDBcbiAgdGhpcy5pbmRleCA9IDBcbiAgdGhpcy5fcHJpdmF0ZUtleSA9IG51bGxcbiAgdGhpcy5fcHVibGljS2V5ID0gbnVsbFxuICB0aGlzLmNoYWluQ29kZSA9IG51bGxcbiAgdGhpcy5fZmluZ2VycHJpbnQgPSAwXG4gIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSAwXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdmaW5nZXJwcmludCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9maW5nZXJwcmludCB9IH0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAnaWRlbnRpZmllcicsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZGVudGlmaWVyIH0gfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwdWJLZXlIYXNoJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaWRlbnRpZmllciB9IH0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwcml2YXRlS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZUtleVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzc2VydC5lcXVhbCh2YWx1ZS5sZW5ndGgsIDMyLCAnUHJpdmF0ZSBrZXkgbXVzdCBiZSAzMiBieXRlcy4nKVxuICAgIGFzc2VydChzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeSh2YWx1ZSkgPT09IHRydWUsICdJbnZhbGlkIHByaXZhdGUga2V5JylcblxuICAgIHRoaXMuX3ByaXZhdGVLZXkgPSB2YWx1ZVxuICAgIHRoaXMuX3B1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUodmFsdWUsIHRydWUpKVxuICAgIHRoaXMuX2lkZW50aWZpZXIgPSBoYXNoMTYwKHRoaXMucHVibGljS2V5KVxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gdGhpcy5faWRlbnRpZmllci5zbGljZSgwLCA0KS5yZWFkVUludDMyQkUoMClcbiAgfVxufSlcblxuZnVuY3Rpb24gc2V0UHVibGljS2V5IChoZGtleSwgcHVibGljS2V5KSB7XG4gIGhka2V5Ll9wdWJsaWNLZXkgPSBCdWZmZXIuZnJvbShwdWJsaWNLZXkpXG4gIGhka2V5Ll9pZGVudGlmaWVyID0gaGFzaDE2MChwdWJsaWNLZXkpXG4gIGhka2V5Ll9maW5nZXJwcmludCA9IGhka2V5Ll9pZGVudGlmaWVyLnNsaWNlKDAsIDQpLnJlYWRVSW50MzJCRSgwKVxuICBoZGtleS5fcHJpdmF0ZUtleSA9IG51bGxcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3B1YmxpY0tleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IDMzIHx8IHZhbHVlLmxlbmd0aCA9PT0gNjUsICdQdWJsaWMga2V5IG11c3QgYmUgMzMgb3IgNjUgYnl0ZXMuJylcbiAgICBhc3NlcnQoc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeSh2YWx1ZSkgPT09IHRydWUsICdJbnZhbGlkIHB1YmxpYyBrZXknKVxuICAgIC8vIGZvcmNlIGNvbXByZXNzZWQgcG9pbnQgKHBlcmZvcm1zIHB1YmxpYyBrZXkgdmVyaWZpY2F0aW9uKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9ICh2YWx1ZS5sZW5ndGggPT09IDY1KSA/IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHZhbHVlLCB0cnVlKSA6IHZhbHVlXG4gICAgc2V0UHVibGljS2V5KHRoaXMsIHB1YmxpY0tleSlcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3ByaXZhdGVFeHRlbmRlZEtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGVLZXkpIHJldHVybiBiczU4Y2hlY2suZW5jb2RlKHNlcmlhbGl6ZSh0aGlzLCB0aGlzLnZlcnNpb25zLnByaXZhdGUsIEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5hbGxvYygxLCAwKSwgdGhpcy5wcml2YXRlS2V5XSkpKVxuICAgIGVsc2UgcmV0dXJuIG51bGxcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3B1YmxpY0V4dGVuZGVkS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYnM1OGNoZWNrLmVuY29kZShzZXJpYWxpemUodGhpcywgdGhpcy52ZXJzaW9ucy5wdWJsaWMsIHRoaXMucHVibGljS2V5KSlcbiAgfVxufSlcblxuSERLZXkucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmIChwYXRoID09PSAnbScgfHwgcGF0aCA9PT0gJ00nIHx8IHBhdGggPT09IFwibSdcIiB8fCBwYXRoID09PSBcIk0nXCIpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIGVudHJpZXMgPSBwYXRoLnNwbGl0KCcvJylcbiAgdmFyIGhka2V5ID0gdGhpc1xuICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgYXNzZXJ0KC9eW21NXXsxfS8udGVzdChjKSwgJ1BhdGggbXVzdCBzdGFydCB3aXRoIFwibVwiIG9yIFwiTVwiJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBoYXJkZW5lZCA9IChjLmxlbmd0aCA+IDEpICYmIChjW2MubGVuZ3RoIC0gMV0gPT09IFwiJ1wiKVxuICAgIHZhciBjaGlsZEluZGV4ID0gcGFyc2VJbnQoYywgMTApIC8vICYgKEhBUkRFTkVEX09GRlNFVCAtIDEpXG4gICAgYXNzZXJ0KGNoaWxkSW5kZXggPCBIQVJERU5FRF9PRkZTRVQsICdJbnZhbGlkIGluZGV4JylcbiAgICBpZiAoaGFyZGVuZWQpIGNoaWxkSW5kZXggKz0gSEFSREVORURfT0ZGU0VUXG5cbiAgICBoZGtleSA9IGhka2V5LmRlcml2ZUNoaWxkKGNoaWxkSW5kZXgpXG4gIH0pXG5cbiAgcmV0dXJuIGhka2V5XG59XG5cbkhES2V5LnByb3RvdHlwZS5kZXJpdmVDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB2YXIgaXNIYXJkZW5lZCA9IGluZGV4ID49IEhBUkRFTkVEX09GRlNFVFxuICB2YXIgaW5kZXhCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgaW5kZXhCdWZmZXIud3JpdGVVSW50MzJCRShpbmRleCwgMClcblxuICB2YXIgZGF0YVxuXG4gIGlmIChpc0hhcmRlbmVkKSB7IC8vIEhhcmRlbmVkIGNoaWxkXG4gICAgYXNzZXJ0KHRoaXMucHJpdmF0ZUtleSwgJ0NvdWxkIG5vdCBkZXJpdmUgaGFyZGVuZWQgY2hpbGQga2V5JylcblxuICAgIHZhciBwayA9IHRoaXMucHJpdmF0ZUtleVxuICAgIHZhciB6YiA9IEJ1ZmZlci5hbGxvYygxLCAwKVxuICAgIHBrID0gQnVmZmVyLmNvbmNhdChbemIsIHBrXSlcblxuICAgIC8vIGRhdGEgPSAweDAwIHx8IHNlcjI1NihrcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbcGssIGluZGV4QnVmZmVyXSlcbiAgfSBlbHNlIHsgLy8gTm9ybWFsIGNoaWxkXG4gICAgLy8gZGF0YSA9IHNlclAocG9pbnQoa3BhcikpIHx8IHNlcjMyKGluZGV4KVxuICAgIC8vICAgICAgPSBzZXJQKEtwYXIpIHx8IHNlcjMyKGluZGV4KVxuICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnB1YmxpY0tleSwgaW5kZXhCdWZmZXJdKVxuICB9XG5cbiAgdmFyIEkgPSBjcnlwdG8uY3JlYXRlSG1hYygnc2hhNTEyJywgdGhpcy5jaGFpbkNvZGUpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICB2YXIgSUwgPSBJLnNsaWNlKDAsIDMyKVxuICB2YXIgSVIgPSBJLnNsaWNlKDMyKVxuXG4gIHZhciBoZCA9IG5ldyBIREtleSh0aGlzLnZlcnNpb25zKVxuXG4gIC8vIFByaXZhdGUgcGFyZW50IGtleSAtPiBwcml2YXRlIGNoaWxkIGtleVxuICBpZiAodGhpcy5wcml2YXRlS2V5KSB7XG4gICAgLy8ga2kgPSBwYXJzZTI1NihJTCkgKyBrcGFyIChtb2QgbilcbiAgICB0cnkge1xuICAgICAgaGQucHJpdmF0ZUtleSA9IEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQoQnVmZmVyLmZyb20odGhpcy5wcml2YXRlS2V5KSwgSUwpKVxuICAgICAgLy8gdGhyb3cgaWYgSUwgPj0gbiB8fCAocHJpdmF0ZUtleSArIElMKSA9PT0gMFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSW4gY2FzZSBwYXJzZTI1NihJTCkgPj0gbiBvciBraSA9PSAwLCBvbmUgc2hvdWxkIHByb2NlZWQgd2l0aCB0aGUgbmV4dCB2YWx1ZSBmb3IgaVxuICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlQ2hpbGQoaW5kZXggKyAxKVxuICAgIH1cbiAgLy8gUHVibGljIHBhcmVudCBrZXkgLT4gcHVibGljIGNoaWxkIGtleVxuICB9IGVsc2Uge1xuICAgIC8vIEtpID0gcG9pbnQocGFyc2UyNTYoSUwpKSArIEtwYXJcbiAgICAvLyAgICA9IEcqSUwgKyBLcGFyXG4gICAgdHJ5IHtcbiAgICAgIGhkLnB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChCdWZmZXIuZnJvbSh0aGlzLnB1YmxpY0tleSksIElMLCB0cnVlKSlcbiAgICAgIC8vIHRocm93IGlmIElMID49IG4gfHwgKGcqKklMICsgcHVibGljS2V5KSBpcyBpbmZpbml0eVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSW4gY2FzZSBwYXJzZTI1NihJTCkgPj0gbiBvciBLaSBpcyB0aGUgcG9pbnQgYXQgaW5maW5pdHksIG9uZSBzaG91bGQgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IHZhbHVlIGZvciBpXG4gICAgICByZXR1cm4gdGhpcy5kZXJpdmVDaGlsZChpbmRleCArIDEpXG4gICAgfVxuICB9XG5cbiAgaGQuY2hhaW5Db2RlID0gSVJcbiAgaGQuZGVwdGggPSB0aGlzLmRlcHRoICsgMVxuICBoZC5wYXJlbnRGaW5nZXJwcmludCA9IHRoaXMuZmluZ2VycHJpbnQvLyAucmVhZFVJbnQzMkJFKDApXG4gIGhkLmluZGV4ID0gaW5kZXhcblxuICByZXR1cm4gaGRcbn1cblxuSERLZXkucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoaGFzaCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZHNhU2lnbihVaW50OEFycmF5LmZyb20oaGFzaCksIFVpbnQ4QXJyYXkuZnJvbSh0aGlzLnByaXZhdGVLZXkpKS5zaWduYXR1cmUpXG59XG5cbkhES2V5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAoaGFzaCwgc2lnbmF0dXJlKSB7XG4gIHJldHVybiBzZWNwMjU2azEuZWNkc2FWZXJpZnkoXG4gICAgVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSksXG4gICAgVWludDhBcnJheS5mcm9tKGhhc2gpLFxuICAgIFVpbnQ4QXJyYXkuZnJvbSh0aGlzLnB1YmxpY0tleSlcbiAgKVxufVxuXG5IREtleS5wcm90b3R5cGUud2lwZVByaXZhdGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcHJpdmF0ZUtleSkgY3J5cHRvLnJhbmRvbUJ5dGVzKHRoaXMuX3ByaXZhdGVLZXkubGVuZ3RoKS5jb3B5KHRoaXMuX3ByaXZhdGVLZXkpXG4gIHRoaXMuX3ByaXZhdGVLZXkgPSBudWxsXG4gIHJldHVybiB0aGlzXG59XG5cbkhES2V5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgeHByaXY6IHRoaXMucHJpdmF0ZUV4dGVuZGVkS2V5LFxuICAgIHhwdWI6IHRoaXMucHVibGljRXh0ZW5kZWRLZXlcbiAgfVxufVxuXG5IREtleS5mcm9tTWFzdGVyU2VlZCA9IGZ1bmN0aW9uIChzZWVkQnVmZmVyLCB2ZXJzaW9ucykge1xuICB2YXIgSSA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGE1MTInLCBNQVNURVJfU0VDUkVUKS51cGRhdGUoc2VlZEJ1ZmZlcikuZGlnZXN0KClcbiAgdmFyIElMID0gSS5zbGljZSgwLCAzMilcbiAgdmFyIElSID0gSS5zbGljZSgzMilcblxuICB2YXIgaGRrZXkgPSBuZXcgSERLZXkodmVyc2lvbnMpXG4gIGhka2V5LmNoYWluQ29kZSA9IElSXG4gIGhka2V5LnByaXZhdGVLZXkgPSBJTFxuXG4gIHJldHVybiBoZGtleVxufVxuXG5IREtleS5mcm9tRXh0ZW5kZWRLZXkgPSBmdW5jdGlvbiAoYmFzZTU4a2V5LCB2ZXJzaW9ucywgc2tpcFZlcmlmaWNhdGlvbikge1xuICAvLyA9PiB2ZXJzaW9uKDQpIHx8IGRlcHRoKDEpIHx8IGZpbmdlcnByaW50KDQpIHx8IGluZGV4KDQpIHx8IGNoYWluKDMyKSB8fCBrZXkoMzMpXG4gIHZlcnNpb25zID0gdmVyc2lvbnMgfHwgQklUQ09JTl9WRVJTSU9OU1xuICBza2lwVmVyaWZpY2F0aW9uID0gc2tpcFZlcmlmaWNhdGlvbiB8fCBmYWxzZVxuICB2YXIgaGRrZXkgPSBuZXcgSERLZXkodmVyc2lvbnMpXG5cbiAgdmFyIGtleUJ1ZmZlciA9IGJzNThjaGVjay5kZWNvZGUoYmFzZTU4a2V5KVxuXG4gIHZhciB2ZXJzaW9uID0ga2V5QnVmZmVyLnJlYWRVSW50MzJCRSgwKVxuICBhc3NlcnQodmVyc2lvbiA9PT0gdmVyc2lvbnMucHJpdmF0ZSB8fCB2ZXJzaW9uID09PSB2ZXJzaW9ucy5wdWJsaWMsICdWZXJzaW9uIG1pc21hdGNoOiBkb2VzIG5vdCBtYXRjaCBwcml2YXRlIG9yIHB1YmxpYycpXG5cbiAgaGRrZXkuZGVwdGggPSBrZXlCdWZmZXIucmVhZFVJbnQ4KDQpXG4gIGhka2V5LnBhcmVudEZpbmdlcnByaW50ID0ga2V5QnVmZmVyLnJlYWRVSW50MzJCRSg1KVxuICBoZGtleS5pbmRleCA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoOSlcbiAgaGRrZXkuY2hhaW5Db2RlID0ga2V5QnVmZmVyLnNsaWNlKDEzLCA0NSlcblxuICB2YXIga2V5ID0ga2V5QnVmZmVyLnNsaWNlKDQ1KVxuICBpZiAoa2V5LnJlYWRVSW50OCgwKSA9PT0gMCkgeyAvLyBwcml2YXRlXG4gICAgYXNzZXJ0KHZlcnNpb24gPT09IHZlcnNpb25zLnByaXZhdGUsICdWZXJzaW9uIG1pc21hdGNoOiB2ZXJzaW9uIGRvZXMgbm90IG1hdGNoIHByaXZhdGUnKVxuICAgIGhka2V5LnByaXZhdGVLZXkgPSBrZXkuc2xpY2UoMSkgLy8gY3V0IG9mZiBmaXJzdCAweDAgYnl0ZVxuICB9IGVsc2Uge1xuICAgIGFzc2VydCh2ZXJzaW9uID09PSB2ZXJzaW9ucy5wdWJsaWMsICdWZXJzaW9uIG1pc21hdGNoOiB2ZXJzaW9uIGRvZXMgbm90IG1hdGNoIHB1YmxpYycpXG4gICAgaWYgKHNraXBWZXJpZmljYXRpb24pIHtcbiAgICAgIHNldFB1YmxpY0tleShoZGtleSwga2V5KVxuICAgIH0gZWxzZSB7XG4gICAgICBoZGtleS5wdWJsaWNLZXkgPSBrZXlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkuZnJvbUpTT04gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBIREtleS5mcm9tRXh0ZW5kZWRLZXkob2JqLnhwcml2KVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUgKGhka2V5LCB2ZXJzaW9uLCBrZXkpIHtcbiAgLy8gPT4gdmVyc2lvbig0KSB8fCBkZXB0aCgxKSB8fCBmaW5nZXJwcmludCg0KSB8fCBpbmRleCg0KSB8fCBjaGFpbigzMikgfHwga2V5KDMzKVxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKExFTilcblxuICBidWZmZXIud3JpdGVVSW50MzJCRSh2ZXJzaW9uLCAwKVxuICBidWZmZXIud3JpdGVVSW50OChoZGtleS5kZXB0aCwgNClcblxuICB2YXIgZmluZ2VycHJpbnQgPSBoZGtleS5kZXB0aCA/IGhka2V5LnBhcmVudEZpbmdlcnByaW50IDogMHgwMDAwMDAwMFxuICBidWZmZXIud3JpdGVVSW50MzJCRShmaW5nZXJwcmludCwgNSlcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoaGRrZXkuaW5kZXgsIDkpXG5cbiAgaGRrZXkuY2hhaW5Db2RlLmNvcHkoYnVmZmVyLCAxMylcbiAga2V5LmNvcHkoYnVmZmVyLCA0NSlcblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGhhc2gxNjAgKGJ1Zikge1xuICB2YXIgc2hhID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWYpLmRpZ2VzdCgpXG4gIHJldHVybiBuZXcgUklQRU1EMTYwKCkudXBkYXRlKHNoYSkuZGlnZXN0KClcbn1cblxuSERLZXkuSEFSREVORURfT0ZGU0VUID0gSEFSREVORURfT0ZGU0VUXG5tb2R1bGUuZXhwb3J0cyA9IEhES2V5XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hdkey/lib/hdkey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hdkey/node_modules/bs58check/base.js":
/*!***********************************************************!*\
  !*** ./node_modules/hdkey/node_modules/bs58check/base.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar base58 = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/hdkey/node_modules/bs58check/node_modules/bs58/index.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var checksum = checksumFn(payload)\n\n    return base58.encode(Buffer.concat([\n      payload,\n      checksum\n    ], payload.length + 4))\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGRrZXkvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQywwRkFBTTtBQUMzQixhQUFhLDRGQUE2Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2hka2V5L25vZGVfbW9kdWxlcy9iczU4Y2hlY2svYmFzZS5qcz82NWNhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTU4ID0gcmVxdWlyZSgnYnM1OCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hlY2tzdW1Gbikge1xuICAvLyBFbmNvZGUgYSBidWZmZXIgYXMgYSBiYXNlNTgtY2hlY2sgZW5jb2RlZCBzdHJpbmdcbiAgZnVuY3Rpb24gZW5jb2RlIChwYXlsb2FkKSB7XG4gICAgdmFyIGNoZWNrc3VtID0gY2hlY2tzdW1GbihwYXlsb2FkKVxuXG4gICAgcmV0dXJuIGJhc2U1OC5lbmNvZGUoQnVmZmVyLmNvbmNhdChbXG4gICAgICBwYXlsb2FkLFxuICAgICAgY2hlY2tzdW1cbiAgICBdLCBwYXlsb2FkLmxlbmd0aCArIDQpKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlUmF3IChidWZmZXIpIHtcbiAgICB2YXIgcGF5bG9hZCA9IGJ1ZmZlci5zbGljZSgwLCAtNClcbiAgICB2YXIgY2hlY2tzdW0gPSBidWZmZXIuc2xpY2UoLTQpXG4gICAgdmFyIG5ld0NoZWNrc3VtID0gY2hlY2tzdW1GbihwYXlsb2FkKVxuXG4gICAgaWYgKGNoZWNrc3VtWzBdIF4gbmV3Q2hlY2tzdW1bMF0gfFxuICAgICAgICBjaGVja3N1bVsxXSBeIG5ld0NoZWNrc3VtWzFdIHxcbiAgICAgICAgY2hlY2tzdW1bMl0gXiBuZXdDaGVja3N1bVsyXSB8XG4gICAgICAgIGNoZWNrc3VtWzNdIF4gbmV3Q2hlY2tzdW1bM10pIHJldHVyblxuXG4gICAgcmV0dXJuIHBheWxvYWRcbiAgfVxuXG4gIC8vIERlY29kZSBhIGJhc2U1OC1jaGVjayBlbmNvZGVkIHN0cmluZyB0byBhIGJ1ZmZlciwgbm8gcmVzdWx0IGlmIGNoZWNrc3VtIGlzIHdyb25nXG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGJhc2U1OC5kZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmICghYnVmZmVyKSByZXR1cm5cblxuICAgIHJldHVybiBkZWNvZGVSYXcoYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gYmFzZTU4LmRlY29kZShzdHJpbmcpXG4gICAgdmFyIHBheWxvYWQgPSBkZWNvZGVSYXcoYnVmZmVyLCBjaGVja3N1bUZuKVxuICAgIGlmICghcGF5bG9hZCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJylcbiAgICByZXR1cm4gcGF5bG9hZFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hdkey/node_modules/bs58check/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hdkey/node_modules/bs58check/index.js":
/*!************************************************************!*\
  !*** ./node_modules/hdkey/node_modules/bs58check/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\")\nvar bs58checkBase = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/hdkey/node_modules/bs58check/base.js\")\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  var tmp = createHash('sha256').update(buffer).digest()\n  return createHash('sha256').update(tmp).digest()\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGRrZXkvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixpQkFBaUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyx5RUFBUTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2hka2V5L25vZGVfbW9kdWxlcy9iczU4Y2hlY2svaW5kZXguanM/ZTZkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgYnM1OGNoZWNrQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpXG5cbi8vIFNIQTI1NihTSEEyNTYoYnVmZmVyKSlcbmZ1bmN0aW9uIHNoYTI1NngyIChidWZmZXIpIHtcbiAgdmFyIHRtcCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpXG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUodG1wKS5kaWdlc3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJzNThjaGVja0Jhc2Uoc2hhMjU2eDIpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hdkey/node_modules/bs58check/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hdkey/node_modules/bs58check/node_modules/bs58/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/hdkey/node_modules/bs58check/node_modules/bs58/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/hdkey/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js\")\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGRrZXkvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsb0hBQVE7QUFDNUI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9oZGtleS9ub2RlX21vZHVsZXMvYnM1OGNoZWNrL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzP2MzMzAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2V4KEFMUEhBQkVUKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hdkey/node_modules/bs58check/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hdkey/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/hdkey/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGRrZXkvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9ub2RlX21vZHVsZXMvYnM1OC9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEZBQTZCO0FBQzNDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVksU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvaGRrZXkvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9ub2RlX21vZHVsZXMvYnM1OC9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcz8zZmIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG4vLyBAdHMtaWdub3JlXG52YXIgX0J1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgeyBzb3VyY2UgPSBfQnVmZmVyLmZyb20oc291cmNlKSB9XG4gICAgaWYgKCFfQnVmZmVyLmlzQnVmZmVyKHNvdXJjZSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgQnVmZmVyJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIF9CdWZmZXIuYWxsb2MoMCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHBzeiA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKEJBU0UgKiBiMjU2W2l0M10pID4+PiAwXG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplICYmIGIyNTZbaXQ0XSA9PT0gMCkge1xuICAgICAgaXQ0KytcbiAgICB9XG4gICAgdmFyIHZjaCA9IF9CdWZmZXIuYWxsb2NVbnNhZmUoemVyb2VzICsgKHNpemUgLSBpdDQpKVxuICAgIHZjaC5maWxsKDB4MDAsIDAsIHplcm9lcylcbiAgICB2YXIgaiA9IHplcm9lc1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUpIHtcbiAgICAgIHZjaFtqKytdID0gYjI1NltpdDQrK11cbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hdkey/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js\n");

/***/ })

};
;
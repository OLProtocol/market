"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ripple-address-codec";
exports.ids = ["vendor-chunks/ripple-address-codec"];
exports.modules = {

/***/ "(ssr)/./node_modules/ripple-address-codec/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ripple-address-codec/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst assert = __importStar(__webpack_require__(/*! assert */ \"assert\"));\nconst xrp_codec_1 = __webpack_require__(/*! ./xrp-codec */ \"(ssr)/./node_modules/ripple-address-codec/dist/xrp-codec.js\");\nObject.defineProperty(exports, \"codec\", ({ enumerable: true, get: function () { return xrp_codec_1.codec; } }));\nObject.defineProperty(exports, \"encodeSeed\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeSeed; } }));\nObject.defineProperty(exports, \"decodeSeed\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeSeed; } }));\nObject.defineProperty(exports, \"encodeAccountID\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountID; } }));\nObject.defineProperty(exports, \"decodeAccountID\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountID; } }));\nObject.defineProperty(exports, \"encodeNodePublic\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeNodePublic; } }));\nObject.defineProperty(exports, \"decodeNodePublic\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeNodePublic; } }));\nObject.defineProperty(exports, \"encodeAccountPublic\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountPublic; } }));\nObject.defineProperty(exports, \"decodeAccountPublic\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountPublic; } }));\nObject.defineProperty(exports, \"isValidClassicAddress\", ({ enumerable: true, get: function () { return xrp_codec_1.isValidClassicAddress; } }));\nconst PREFIX_BYTES = {\n    // 5, 68\n    main: Buffer.from([0x05, 0x44]),\n    // 4, 147\n    test: Buffer.from([0x04, 0x93]),\n};\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295;\nfunction classicAddressToXAddress(classicAddress, tag, test) {\n    const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);\n    return encodeXAddress(accountId, tag, test);\n}\nexports.classicAddressToXAddress = classicAddressToXAddress;\nfunction encodeXAddress(accountId, tag, test) {\n    if (accountId.length !== 20) {\n        // RIPEMD160 is 160 bits = 20 bytes\n        throw new Error('Account ID must be 20 bytes');\n    }\n    if (tag > MAX_32_BIT_UNSIGNED_INT) {\n        throw new Error('Invalid tag');\n    }\n    const theTag = tag || 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n    const flag = tag === false || tag == null ? 0 : 1;\n    /* eslint-disable no-bitwise ---\n     * need to use bitwise operations here */\n    const bytes = Buffer.concat([\n        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,\n        accountId,\n        Buffer.from([\n            // 0x00 if no tag, 0x01 if 32-bit tag\n            flag,\n            // first byte\n            theTag & 0xff,\n            // second byte\n            (theTag >> 8) & 0xff,\n            // third byte\n            (theTag >> 16) & 0xff,\n            // fourth byte\n            (theTag >> 24) & 0xff,\n            0,\n            0,\n            0,\n            // four zero bytes (reserved for 64-bit tags)\n            0,\n        ]),\n    ]);\n    /* eslint-enable no-bitwise */\n    return xrp_codec_1.codec.encodeChecked(bytes);\n}\nexports.encodeXAddress = encodeXAddress;\nfunction xAddressToClassicAddress(xAddress) {\n    /* eslint-disable @typescript-eslint/naming-convention --\n     * TODO 'test' should be something like 'isTest', do this later\n     */\n    const { accountId, tag, test } = decodeXAddress(xAddress);\n    /* eslint-enable @typescript-eslint/naming-convention */\n    const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);\n    return {\n        classicAddress,\n        tag,\n        test,\n    };\n}\nexports.xAddressToClassicAddress = xAddressToClassicAddress;\nfunction decodeXAddress(xAddress) {\n    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);\n    /* eslint-disable @typescript-eslint/naming-convention --\n     * TODO 'test' should be something like 'isTest', do this later\n     */\n    const test = isBufferForTestAddress(decoded);\n    /* eslint-enable @typescript-eslint/naming-convention */\n    const accountId = decoded.slice(2, 22);\n    const tag = tagFromBuffer(decoded);\n    return {\n        accountId,\n        tag,\n        test,\n    };\n}\nexports.decodeXAddress = decodeXAddress;\nfunction isBufferForTestAddress(buf) {\n    const decodedPrefix = buf.slice(0, 2);\n    if (PREFIX_BYTES.main.equals(decodedPrefix)) {\n        return false;\n    }\n    if (PREFIX_BYTES.test.equals(decodedPrefix)) {\n        return true;\n    }\n    throw new Error('Invalid X-address: bad prefix');\n}\nfunction tagFromBuffer(buf) {\n    const flag = buf[22];\n    if (flag >= 2) {\n        // No support for 64-bit tags at this time\n        throw new Error('Unsupported X-address');\n    }\n    if (flag === 1) {\n        // Little-endian to big-endian\n        return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;\n    }\n    assert.strictEqual(flag, 0, 'flag must be zero to indicate no tag');\n    assert.ok(Buffer.from('0000000000000000', 'hex').equals(buf.slice(23, 23 + 8)), 'remaining bytes must be zero');\n    return false;\n}\nfunction isValidXAddress(xAddress) {\n    try {\n        decodeXAddress(xAddress);\n    }\n    catch (_error) {\n        return false;\n    }\n    return true;\n}\nexports.isValidXAddress = isValidXAddress;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcsZ0NBQWdDLEdBQUcsc0JBQXNCLEdBQUcsZ0NBQWdDLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsYUFBYTtBQUMvWSw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN6Qyx5Q0FBd0MsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDN0csOENBQTZDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3ZILDhDQUE2QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN2SCxtREFBa0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDakksbURBQWtELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2pJLG9EQUFtRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNuSSxvREFBbUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDbkksdURBQXNELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3pJLHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSx5REFBd0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1hZGRyZXNzLWNvZGVjL2Rpc3QvaW5kZXguanM/N2FmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkWEFkZHJlc3MgPSBleHBvcnRzLmRlY29kZVhBZGRyZXNzID0gZXhwb3J0cy54QWRkcmVzc1RvQ2xhc3NpY0FkZHJlc3MgPSBleHBvcnRzLmVuY29kZVhBZGRyZXNzID0gZXhwb3J0cy5jbGFzc2ljQWRkcmVzc1RvWEFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDbGFzc2ljQWRkcmVzcyA9IGV4cG9ydHMuZGVjb2RlQWNjb3VudFB1YmxpYyA9IGV4cG9ydHMuZW5jb2RlQWNjb3VudFB1YmxpYyA9IGV4cG9ydHMuZGVjb2RlTm9kZVB1YmxpYyA9IGV4cG9ydHMuZW5jb2RlTm9kZVB1YmxpYyA9IGV4cG9ydHMuZGVjb2RlQWNjb3VudElEID0gZXhwb3J0cy5lbmNvZGVBY2NvdW50SUQgPSBleHBvcnRzLmRlY29kZVNlZWQgPSBleHBvcnRzLmVuY29kZVNlZWQgPSBleHBvcnRzLmNvZGVjID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgeHJwX2NvZGVjXzEgPSByZXF1aXJlKFwiLi94cnAtY29kZWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb2RlY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuY29kZWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVTZWVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5lbmNvZGVTZWVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlU2VlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZGVjb2RlU2VlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUFjY291bnRJRFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZW5jb2RlQWNjb3VudElEOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQWNjb3VudElEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5kZWNvZGVBY2NvdW50SUQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVOb2RlUHVibGljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5lbmNvZGVOb2RlUHVibGljOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlTm9kZVB1YmxpY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZGVjb2RlTm9kZVB1YmxpYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUFjY291bnRQdWJsaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmVuY29kZUFjY291bnRQdWJsaWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVBY2NvdW50UHVibGljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5kZWNvZGVBY2NvdW50UHVibGljOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZENsYXNzaWNBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3M7IH0gfSk7XG5jb25zdCBQUkVGSVhfQllURVMgPSB7XG4gICAgLy8gNSwgNjhcbiAgICBtYWluOiBCdWZmZXIuZnJvbShbMHgwNSwgMHg0NF0pLFxuICAgIC8vIDQsIDE0N1xuICAgIHRlc3Q6IEJ1ZmZlci5mcm9tKFsweDA0LCAweDkzXSksXG59O1xuY29uc3QgTUFYXzMyX0JJVF9VTlNJR05FRF9JTlQgPSA0Mjk0OTY3Mjk1O1xuZnVuY3Rpb24gY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzKGNsYXNzaWNBZGRyZXNzLCB0YWcsIHRlc3QpIHtcbiAgICBjb25zdCBhY2NvdW50SWQgPSAoMCwgeHJwX2NvZGVjXzEuZGVjb2RlQWNjb3VudElEKShjbGFzc2ljQWRkcmVzcyk7XG4gICAgcmV0dXJuIGVuY29kZVhBZGRyZXNzKGFjY291bnRJZCwgdGFnLCB0ZXN0KTtcbn1cbmV4cG9ydHMuY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzID0gY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzO1xuZnVuY3Rpb24gZW5jb2RlWEFkZHJlc3MoYWNjb3VudElkLCB0YWcsIHRlc3QpIHtcbiAgICBpZiAoYWNjb3VudElkLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgLy8gUklQRU1EMTYwIGlzIDE2MCBiaXRzID0gMjAgYnl0ZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IElEIG11c3QgYmUgMjAgYnl0ZXMnKTtcbiAgICB9XG4gICAgaWYgKHRhZyA+IE1BWF8zMl9CSVRfVU5TSUdORURfSU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWcnKTtcbiAgICB9XG4gICAgY29uc3QgdGhlVGFnID0gdGFnIHx8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gLS0gUGFzc2luZyBudWxsIGlzIGEgY29tbW9uIGpzIG1pc3Rha2VcbiAgICBjb25zdCBmbGFnID0gdGFnID09PSBmYWxzZSB8fCB0YWcgPT0gbnVsbCA/IDAgOiAxO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgLS0tXG4gICAgICogbmVlZCB0byB1c2UgYml0d2lzZSBvcGVyYXRpb25zIGhlcmUgKi9cbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICB0ZXN0ID8gUFJFRklYX0JZVEVTLnRlc3QgOiBQUkVGSVhfQllURVMubWFpbixcbiAgICAgICAgYWNjb3VudElkLFxuICAgICAgICBCdWZmZXIuZnJvbShbXG4gICAgICAgICAgICAvLyAweDAwIGlmIG5vIHRhZywgMHgwMSBpZiAzMi1iaXQgdGFnXG4gICAgICAgICAgICBmbGFnLFxuICAgICAgICAgICAgLy8gZmlyc3QgYnl0ZVxuICAgICAgICAgICAgdGhlVGFnICYgMHhmZixcbiAgICAgICAgICAgIC8vIHNlY29uZCBieXRlXG4gICAgICAgICAgICAodGhlVGFnID4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIC8vIHRoaXJkIGJ5dGVcbiAgICAgICAgICAgICh0aGVUYWcgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIC8vIGZvdXJ0aCBieXRlXG4gICAgICAgICAgICAodGhlVGFnID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAvLyBmb3VyIHplcm8gYnl0ZXMgKHJlc2VydmVkIGZvciA2NC1iaXQgdGFncylcbiAgICAgICAgICAgIDAsXG4gICAgICAgIF0pLFxuICAgIF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xuICAgIHJldHVybiB4cnBfY29kZWNfMS5jb2RlYy5lbmNvZGVDaGVja2VkKGJ5dGVzKTtcbn1cbmV4cG9ydHMuZW5jb2RlWEFkZHJlc3MgPSBlbmNvZGVYQWRkcmVzcztcbmZ1bmN0aW9uIHhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyh4QWRkcmVzcykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAtLVxuICAgICAqIFRPRE8gJ3Rlc3QnIHNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSAnaXNUZXN0JywgZG8gdGhpcyBsYXRlclxuICAgICAqL1xuICAgIGNvbnN0IHsgYWNjb3VudElkLCB0YWcsIHRlc3QgfSA9IGRlY29kZVhBZGRyZXNzKHhBZGRyZXNzKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuICAgIGNvbnN0IGNsYXNzaWNBZGRyZXNzID0gKDAsIHhycF9jb2RlY18xLmVuY29kZUFjY291bnRJRCkoYWNjb3VudElkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGFzc2ljQWRkcmVzcyxcbiAgICAgICAgdGFnLFxuICAgICAgICB0ZXN0LFxuICAgIH07XG59XG5leHBvcnRzLnhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyA9IHhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcztcbmZ1bmN0aW9uIGRlY29kZVhBZGRyZXNzKHhBZGRyZXNzKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IHhycF9jb2RlY18xLmNvZGVjLmRlY29kZUNoZWNrZWQoeEFkZHJlc3MpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAtLVxuICAgICAqIFRPRE8gJ3Rlc3QnIHNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSAnaXNUZXN0JywgZG8gdGhpcyBsYXRlclxuICAgICAqL1xuICAgIGNvbnN0IHRlc3QgPSBpc0J1ZmZlckZvclRlc3RBZGRyZXNzKGRlY29kZWQpO1xuICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG4gICAgY29uc3QgYWNjb3VudElkID0gZGVjb2RlZC5zbGljZSgyLCAyMik7XG4gICAgY29uc3QgdGFnID0gdGFnRnJvbUJ1ZmZlcihkZWNvZGVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgIHRhZyxcbiAgICAgICAgdGVzdCxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWNvZGVYQWRkcmVzcyA9IGRlY29kZVhBZGRyZXNzO1xuZnVuY3Rpb24gaXNCdWZmZXJGb3JUZXN0QWRkcmVzcyhidWYpIHtcbiAgICBjb25zdCBkZWNvZGVkUHJlZml4ID0gYnVmLnNsaWNlKDAsIDIpO1xuICAgIGlmIChQUkVGSVhfQllURVMubWFpbi5lcXVhbHMoZGVjb2RlZFByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoUFJFRklYX0JZVEVTLnRlc3QuZXF1YWxzKGRlY29kZWRQcmVmaXgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgWC1hZGRyZXNzOiBiYWQgcHJlZml4Jyk7XG59XG5mdW5jdGlvbiB0YWdGcm9tQnVmZmVyKGJ1Zikge1xuICAgIGNvbnN0IGZsYWcgPSBidWZbMjJdO1xuICAgIGlmIChmbGFnID49IDIpIHtcbiAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3IgNjQtYml0IHRhZ3MgYXQgdGhpcyB0aW1lXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgWC1hZGRyZXNzJyk7XG4gICAgfVxuICAgIGlmIChmbGFnID09PSAxKSB7XG4gICAgICAgIC8vIExpdHRsZS1lbmRpYW4gdG8gYmlnLWVuZGlhblxuICAgICAgICByZXR1cm4gYnVmWzIzXSArIGJ1ZlsyNF0gKiAweDEwMCArIGJ1ZlsyNV0gKiAweDEwMDAwICsgYnVmWzI2XSAqIDB4MTAwMDAwMDtcbiAgICB9XG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKGZsYWcsIDAsICdmbGFnIG11c3QgYmUgemVybyB0byBpbmRpY2F0ZSBubyB0YWcnKTtcbiAgICBhc3NlcnQub2soQnVmZmVyLmZyb20oJzAwMDAwMDAwMDAwMDAwMDAnLCAnaGV4JykuZXF1YWxzKGJ1Zi5zbGljZSgyMywgMjMgKyA4KSksICdyZW1haW5pbmcgYnl0ZXMgbXVzdCBiZSB6ZXJvJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZFhBZGRyZXNzKHhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlWEFkZHJlc3MoeEFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVmFsaWRYQWRkcmVzcyA9IGlzVmFsaWRYQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-address-codec/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-address-codec/dist/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/ripple-address-codec/dist/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatArgs = exports.seqEqual = void 0;\n/**\n * Check whether two sequences (e.g. Arrays of numbers) are equal.\n *\n * @param arr1 - One of the arrays to compare.\n * @param arr2 - The other array to compare.\n */\nfunction seqEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.seqEqual = seqEqual;\n/**\n * Check whether a value is a sequence (e.g. Array of numbers).\n *\n * @param val - The value to check.\n */\nfunction isSequence(val) {\n    return typeof val !== 'number';\n}\n/**\n * Concatenate all `arguments` into a single array. Each argument can be either\n * a single element or a sequence, which has a `length` property and supports\n * element retrieval via sequence[ix].\n *\n * > concatArgs(1, [2, 3], Buffer.from([4,5]), new Uint8Array([6, 7]));\n * [1,2,3,4,5,6,7]\n *\n * @param args - Concatenate of these args into a single array.\n * @returns Array of concatenated arguments\n */\nfunction concatArgs(...args) {\n    const ret = [];\n    args.forEach((arg) => {\n        if (isSequence(arg)) {\n            for (const j of arg) {\n                ret.push(j);\n            }\n        }\n        else {\n            ret.push(arg);\n        }\n    });\n    return ret;\n}\nexports.concatArgs = concatArgs;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1hZGRyZXNzLWNvZGVjL2Rpc3QvdXRpbHMuanM/NGM2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uY2F0QXJncyA9IGV4cG9ydHMuc2VxRXF1YWwgPSB2b2lkIDA7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIHNlcXVlbmNlcyAoZS5nLiBBcnJheXMgb2YgbnVtYmVycykgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSBhcnIxIC0gT25lIG9mIHRoZSBhcnJheXMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBhcnIyIC0gVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKi9cbmZ1bmN0aW9uIHNlcUVxdWFsKGFycjEsIGFycjIpIHtcbiAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnNlcUVxdWFsID0gc2VxRXF1YWw7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIHNlcXVlbmNlIChlLmcuIEFycmF5IG9mIG51bWJlcnMpLlxuICpcbiAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzU2VxdWVuY2UodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICdudW1iZXInO1xufVxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbGwgYGFyZ3VtZW50c2AgaW50byBhIHNpbmdsZSBhcnJheS4gRWFjaCBhcmd1bWVudCBjYW4gYmUgZWl0aGVyXG4gKiBhIHNpbmdsZSBlbGVtZW50IG9yIGEgc2VxdWVuY2UsIHdoaWNoIGhhcyBhIGBsZW5ndGhgIHByb3BlcnR5IGFuZCBzdXBwb3J0c1xuICogZWxlbWVudCByZXRyaWV2YWwgdmlhIHNlcXVlbmNlW2l4XS5cbiAqXG4gKiA+IGNvbmNhdEFyZ3MoMSwgWzIsIDNdLCBCdWZmZXIuZnJvbShbNCw1XSksIG5ldyBVaW50OEFycmF5KFs2LCA3XSkpO1xuICogWzEsMiwzLDQsNSw2LDddXG4gKlxuICogQHBhcmFtIGFyZ3MgLSBDb25jYXRlbmF0ZSBvZiB0aGVzZSBhcmdzIGludG8gYSBzaW5nbGUgYXJyYXkuXG4gKiBAcmV0dXJucyBBcnJheSBvZiBjb25jYXRlbmF0ZWQgYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEFyZ3MoLi4uYXJncykge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGFyZ3MuZm9yRWFjaCgoYXJnKSA9PiB7XG4gICAgICAgIGlmIChpc1NlcXVlbmNlKGFyZykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaiBvZiBhcmcpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGFyZyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5jb25jYXRBcmdzID0gY29uY2F0QXJncztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-address-codec/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-address-codec/dist/xrp-codec.js":
/*!*************************************************************!*\
  !*** ./node_modules/ripple-address-codec/dist/xrp-codec.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Codec class\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst baseCodec = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/ripple-address-codec/node_modules/base-x/src/index.js\");\nconst createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/ripple-address-codec/dist/utils.js\");\nclass Codec {\n    constructor(options) {\n        this._sha256 = options.sha256;\n        this._alphabet = options.alphabet;\n        this._codec = baseCodec(this._alphabet);\n    }\n    /**\n     * Encoder.\n     *\n     * @param bytes - Buffer of data to encode.\n     * @param opts - Options object including the version bytes and the expected length of the data to encode.\n     */\n    encode(bytes, opts) {\n        const versions = opts.versions;\n        return this._encodeVersioned(bytes, versions, opts.expectedLength);\n    }\n    /**\n     * Decoder.\n     *\n     * @param base58string - Base58Check-encoded string to decode.\n     * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.\n     */\n    /* eslint-disable max-lines-per-function --\n     * TODO refactor */\n    decode(base58string, opts) {\n        var _a;\n        const versions = opts.versions;\n        const types = opts.versionTypes;\n        const withoutSum = this.decodeChecked(base58string);\n        if (versions.length > 1 && !opts.expectedLength) {\n            throw new Error('expectedLength is required because there are >= 2 possible versions');\n        }\n        const versionLengthGuess = typeof versions[0] === 'number' ? 1 : versions[0].length;\n        const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;\n        const versionBytes = withoutSum.slice(0, -payloadLength);\n        const payload = withoutSum.slice(-payloadLength);\n        for (let i = 0; i < versions.length; i++) {\n            /* eslint-disable @typescript-eslint/consistent-type-assertions --\n             * TODO refactor */\n            const version = Array.isArray(versions[i])\n                ? versions[i]\n                : [versions[i]];\n            if ((0, utils_1.seqEqual)(versionBytes, version)) {\n                return {\n                    version,\n                    bytes: payload,\n                    type: types ? types[i] : null,\n                };\n            }\n            /* eslint-enable @typescript-eslint/consistent-type-assertions */\n        }\n        throw new Error('version_invalid: version bytes do not match any of the provided version(s)');\n    }\n    encodeChecked(buffer) {\n        const check = this._sha256(this._sha256(buffer)).slice(0, 4);\n        return this._encodeRaw(Buffer.from((0, utils_1.concatArgs)(buffer, check)));\n    }\n    decodeChecked(base58string) {\n        const buffer = this._decodeRaw(base58string);\n        if (buffer.length < 5) {\n            throw new Error('invalid_input_size: decoded data must have length >= 5');\n        }\n        if (!this._verifyCheckSum(buffer)) {\n            throw new Error('checksum_invalid');\n        }\n        return buffer.slice(0, -4);\n    }\n    _encodeVersioned(bytes, versions, expectedLength) {\n        if (expectedLength && bytes.length !== expectedLength) {\n            throw new Error('unexpected_payload_length: bytes.length does not match expectedLength.' +\n                ' Ensure that the bytes are a Buffer.');\n        }\n        return this.encodeChecked(Buffer.from((0, utils_1.concatArgs)(versions, bytes)));\n    }\n    _encodeRaw(bytes) {\n        return this._codec.encode(bytes);\n    }\n    /* eslint-enable max-lines-per-function */\n    _decodeRaw(base58string) {\n        return this._codec.decode(base58string);\n    }\n    _verifyCheckSum(bytes) {\n        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4);\n        const checksum = bytes.slice(-4);\n        return (0, utils_1.seqEqual)(computed, checksum);\n    }\n}\n/**\n * XRP codec\n */\n// base58 encodings: https://xrpl.org/base58-encodings.html\n// Account address (20 bytes)\nconst ACCOUNT_ID = 0;\n// Account public key (33 bytes)\nconst ACCOUNT_PUBLIC_KEY = 0x23;\n// 33; Seed value (for secret keys) (16 bytes)\nconst FAMILY_SEED = 0x21;\n// 28; Validation public key (33 bytes)\nconst NODE_PUBLIC = 0x1c;\n// [1, 225, 75]\nconst ED25519_SEED = [0x01, 0xe1, 0x4b];\nconst codecOptions = {\n    sha256(bytes) {\n        return createHash('sha256').update(Buffer.from(bytes)).digest();\n    },\n    alphabet: 'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz',\n};\nconst codecWithXrpAlphabet = new Codec(codecOptions);\nexports.codec = codecWithXrpAlphabet;\n// entropy is a Buffer of size 16\n// type is 'ed25519' or 'secp256k1'\nfunction encodeSeed(entropy, type) {\n    if (entropy.length !== 16) {\n        throw new Error('entropy must have length 16');\n    }\n    const opts = {\n        expectedLength: 16,\n        // for secp256k1, use `FAMILY_SEED`\n        versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED],\n    };\n    // prefixes entropy with version bytes\n    return codecWithXrpAlphabet.encode(entropy, opts);\n}\nexports.encodeSeed = encodeSeed;\nfunction decodeSeed(seed, opts = {\n    versionTypes: ['ed25519', 'secp256k1'],\n    versions: [ED25519_SEED, FAMILY_SEED],\n    expectedLength: 16,\n}) {\n    return codecWithXrpAlphabet.decode(seed, opts);\n}\nexports.decodeSeed = decodeSeed;\nfunction encodeAccountID(bytes) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountID = encodeAccountID;\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexports.encodeAddress = encodeAccountID;\n/* eslint-enable import/no-unused-modules */\nfunction decodeAccountID(accountId) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.decode(accountId, opts).bytes;\n}\nexports.decodeAccountID = decodeAccountID;\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexports.decodeAddress = decodeAccountID;\n/* eslint-enable import/no-unused-modules */\nfunction decodeNodePublic(base58string) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeNodePublic = decodeNodePublic;\nfunction encodeNodePublic(bytes) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeNodePublic = encodeNodePublic;\nfunction encodeAccountPublic(bytes) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountPublic = encodeAccountPublic;\nfunction decodeAccountPublic(base58string) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeAccountPublic = decodeAccountPublic;\nfunction isValidClassicAddress(address) {\n    try {\n        decodeAccountID(address);\n    }\n    catch (_error) {\n        return false;\n    }\n    return true;\n}\nexports.isValidClassicAddress = isValidClassicAddress;\n//# sourceMappingURL=xrp-codec.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC94cnAtY29kZWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsYUFBYTtBQUM3UyxrQkFBa0IsbUJBQU8sQ0FBQywwRkFBUTtBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1hZGRyZXNzLWNvZGVjL2Rpc3QveHJwLWNvZGVjLmpzPzU2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvZGVjIGNsYXNzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNWYWxpZENsYXNzaWNBZGRyZXNzID0gZXhwb3J0cy5kZWNvZGVBY2NvdW50UHVibGljID0gZXhwb3J0cy5lbmNvZGVBY2NvdW50UHVibGljID0gZXhwb3J0cy5lbmNvZGVOb2RlUHVibGljID0gZXhwb3J0cy5kZWNvZGVOb2RlUHVibGljID0gZXhwb3J0cy5kZWNvZGVBZGRyZXNzID0gZXhwb3J0cy5kZWNvZGVBY2NvdW50SUQgPSBleHBvcnRzLmVuY29kZUFkZHJlc3MgPSBleHBvcnRzLmVuY29kZUFjY291bnRJRCA9IGV4cG9ydHMuZGVjb2RlU2VlZCA9IGV4cG9ydHMuZW5jb2RlU2VlZCA9IGV4cG9ydHMuY29kZWMgPSB2b2lkIDA7XG5jb25zdCBiYXNlQ29kZWMgPSByZXF1aXJlKFwiYmFzZS14XCIpO1xuY29uc3QgY3JlYXRlSGFzaCA9IHJlcXVpcmUoXCJjcmVhdGUtaGFzaFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNsYXNzIENvZGVjIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NoYTI1NiA9IG9wdGlvbnMuc2hhMjU2O1xuICAgICAgICB0aGlzLl9hbHBoYWJldCA9IG9wdGlvbnMuYWxwaGFiZXQ7XG4gICAgICAgIHRoaXMuX2NvZGVjID0gYmFzZUNvZGVjKHRoaXMuX2FscGhhYmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyAtIEJ1ZmZlciBvZiBkYXRhIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgb2JqZWN0IGluY2x1ZGluZyB0aGUgdmVyc2lvbiBieXRlcyBhbmQgdGhlIGV4cGVjdGVkIGxlbmd0aCBvZiB0aGUgZGF0YSB0byBlbmNvZGUuXG4gICAgICovXG4gICAgZW5jb2RlKGJ5dGVzLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb25zID0gb3B0cy52ZXJzaW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVZlcnNpb25lZChieXRlcywgdmVyc2lvbnMsIG9wdHMuZXhwZWN0ZWRMZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhc2U1OHN0cmluZyAtIEJhc2U1OENoZWNrLWVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgb2JqZWN0IGluY2x1ZGluZyB0aGUgdmVyc2lvbiBieXRlKHMpIGFuZCB0aGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBkYXRhIGFmdGVyIGRlY29kaW5nLlxuICAgICAqL1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1saW5lcy1wZXItZnVuY3Rpb24gLS1cbiAgICAgKiBUT0RPIHJlZmFjdG9yICovXG4gICAgZGVjb2RlKGJhc2U1OHN0cmluZywgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHZlcnNpb25zID0gb3B0cy52ZXJzaW9ucztcbiAgICAgICAgY29uc3QgdHlwZXMgPSBvcHRzLnZlcnNpb25UeXBlcztcbiAgICAgICAgY29uc3Qgd2l0aG91dFN1bSA9IHRoaXMuZGVjb2RlQ2hlY2tlZChiYXNlNThzdHJpbmcpO1xuICAgICAgICBpZiAodmVyc2lvbnMubGVuZ3RoID4gMSAmJiAhb3B0cy5leHBlY3RlZExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZExlbmd0aCBpcyByZXF1aXJlZCBiZWNhdXNlIHRoZXJlIGFyZSA+PSAyIHBvc3NpYmxlIHZlcnNpb25zJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbkxlbmd0aEd1ZXNzID0gdHlwZW9mIHZlcnNpb25zWzBdID09PSAnbnVtYmVyJyA/IDEgOiB2ZXJzaW9uc1swXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHBheWxvYWRMZW5ndGggPSAoX2EgPSBvcHRzLmV4cGVjdGVkTGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3aXRob3V0U3VtLmxlbmd0aCAtIHZlcnNpb25MZW5ndGhHdWVzcztcbiAgICAgICAgY29uc3QgdmVyc2lvbkJ5dGVzID0gd2l0aG91dFN1bS5zbGljZSgwLCAtcGF5bG9hZExlbmd0aCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB3aXRob3V0U3VtLnNsaWNlKC1wYXlsb2FkTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zIC0tXG4gICAgICAgICAgICAgKiBUT0RPIHJlZmFjdG9yICovXG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gQXJyYXkuaXNBcnJheSh2ZXJzaW9uc1tpXSlcbiAgICAgICAgICAgICAgICA/IHZlcnNpb25zW2ldXG4gICAgICAgICAgICAgICAgOiBbdmVyc2lvbnNbaV1dO1xuICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLnNlcUVxdWFsKSh2ZXJzaW9uQnl0ZXMsIHZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXM6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVzID8gdHlwZXNbaV0gOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtYXNzZXJ0aW9ucyAqL1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVyc2lvbl9pbnZhbGlkOiB2ZXJzaW9uIGJ5dGVzIGRvIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHByb3ZpZGVkIHZlcnNpb24ocyknKTtcbiAgICB9XG4gICAgZW5jb2RlQ2hlY2tlZChidWZmZXIpIHtcbiAgICAgICAgY29uc3QgY2hlY2sgPSB0aGlzLl9zaGEyNTYodGhpcy5fc2hhMjU2KGJ1ZmZlcikpLnNsaWNlKDAsIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUmF3KEJ1ZmZlci5mcm9tKCgwLCB1dGlsc18xLmNvbmNhdEFyZ3MpKGJ1ZmZlciwgY2hlY2spKSk7XG4gICAgfVxuICAgIGRlY29kZUNoZWNrZWQoYmFzZTU4c3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2RlY29kZVJhdyhiYXNlNThzdHJpbmcpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9pbnB1dF9zaXplOiBkZWNvZGVkIGRhdGEgbXVzdCBoYXZlIGxlbmd0aCA+PSA1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDaGVja1N1bShidWZmZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtX2ludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIC00KTtcbiAgICB9XG4gICAgX2VuY29kZVZlcnNpb25lZChieXRlcywgdmVyc2lvbnMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgIGlmIChleHBlY3RlZExlbmd0aCAmJiBieXRlcy5sZW5ndGggIT09IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWRfcGF5bG9hZF9sZW5ndGg6IGJ5dGVzLmxlbmd0aCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZExlbmd0aC4nICtcbiAgICAgICAgICAgICAgICAnIEVuc3VyZSB0aGF0IHRoZSBieXRlcyBhcmUgYSBCdWZmZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQ2hlY2tlZChCdWZmZXIuZnJvbSgoMCwgdXRpbHNfMS5jb25jYXRBcmdzKSh2ZXJzaW9ucywgYnl0ZXMpKSk7XG4gICAgfVxuICAgIF9lbmNvZGVSYXcoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVjLmVuY29kZShieXRlcyk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxpbmVzLXBlci1mdW5jdGlvbiAqL1xuICAgIF9kZWNvZGVSYXcoYmFzZTU4c3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlYy5kZWNvZGUoYmFzZTU4c3RyaW5nKTtcbiAgICB9XG4gICAgX3ZlcmlmeUNoZWNrU3VtKGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gdGhpcy5fc2hhMjU2KHRoaXMuX3NoYTI1NihieXRlcy5zbGljZSgwLCAtNCkpKS5zbGljZSgwLCA0KTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBieXRlcy5zbGljZSgtNCk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5zZXFFcXVhbCkoY29tcHV0ZWQsIGNoZWNrc3VtKTtcbiAgICB9XG59XG4vKipcbiAqIFhSUCBjb2RlY1xuICovXG4vLyBiYXNlNTggZW5jb2RpbmdzOiBodHRwczovL3hycGwub3JnL2Jhc2U1OC1lbmNvZGluZ3MuaHRtbFxuLy8gQWNjb3VudCBhZGRyZXNzICgyMCBieXRlcylcbmNvbnN0IEFDQ09VTlRfSUQgPSAwO1xuLy8gQWNjb3VudCBwdWJsaWMga2V5ICgzMyBieXRlcylcbmNvbnN0IEFDQ09VTlRfUFVCTElDX0tFWSA9IDB4MjM7XG4vLyAzMzsgU2VlZCB2YWx1ZSAoZm9yIHNlY3JldCBrZXlzKSAoMTYgYnl0ZXMpXG5jb25zdCBGQU1JTFlfU0VFRCA9IDB4MjE7XG4vLyAyODsgVmFsaWRhdGlvbiBwdWJsaWMga2V5ICgzMyBieXRlcylcbmNvbnN0IE5PREVfUFVCTElDID0gMHgxYztcbi8vIFsxLCAyMjUsIDc1XVxuY29uc3QgRUQyNTUxOV9TRUVEID0gWzB4MDEsIDB4ZTEsIDB4NGJdO1xuY29uc3QgY29kZWNPcHRpb25zID0ge1xuICAgIHNoYTI1NihieXRlcykge1xuICAgICAgICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKEJ1ZmZlci5mcm9tKGJ5dGVzKSkuZGlnZXN0KCk7XG4gICAgfSxcbiAgICBhbHBoYWJldDogJ3Jwc2huYWYzOXdCVURORUdISktMTTRQUVJTVDdWV1hZWjJiY2RlQ2c2NWprbThvRnFpMXR1dkF4eXonLFxufTtcbmNvbnN0IGNvZGVjV2l0aFhycEFscGhhYmV0ID0gbmV3IENvZGVjKGNvZGVjT3B0aW9ucyk7XG5leHBvcnRzLmNvZGVjID0gY29kZWNXaXRoWHJwQWxwaGFiZXQ7XG4vLyBlbnRyb3B5IGlzIGEgQnVmZmVyIG9mIHNpemUgMTZcbi8vIHR5cGUgaXMgJ2VkMjU1MTknIG9yICdzZWNwMjU2azEnXG5mdW5jdGlvbiBlbmNvZGVTZWVkKGVudHJvcHksIHR5cGUpIHtcbiAgICBpZiAoZW50cm9weS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50cm9weSBtdXN0IGhhdmUgbGVuZ3RoIDE2Jyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGV4cGVjdGVkTGVuZ3RoOiAxNixcbiAgICAgICAgLy8gZm9yIHNlY3AyNTZrMSwgdXNlIGBGQU1JTFlfU0VFRGBcbiAgICAgICAgdmVyc2lvbnM6IHR5cGUgPT09ICdlZDI1NTE5JyA/IEVEMjU1MTlfU0VFRCA6IFtGQU1JTFlfU0VFRF0sXG4gICAgfTtcbiAgICAvLyBwcmVmaXhlcyBlbnRyb3B5IHdpdGggdmVyc2lvbiBieXRlc1xuICAgIHJldHVybiBjb2RlY1dpdGhYcnBBbHBoYWJldC5lbmNvZGUoZW50cm9weSwgb3B0cyk7XG59XG5leHBvcnRzLmVuY29kZVNlZWQgPSBlbmNvZGVTZWVkO1xuZnVuY3Rpb24gZGVjb2RlU2VlZChzZWVkLCBvcHRzID0ge1xuICAgIHZlcnNpb25UeXBlczogWydlZDI1NTE5JywgJ3NlY3AyNTZrMSddLFxuICAgIHZlcnNpb25zOiBbRUQyNTUxOV9TRUVELCBGQU1JTFlfU0VFRF0sXG4gICAgZXhwZWN0ZWRMZW5ndGg6IDE2LFxufSkge1xuICAgIHJldHVybiBjb2RlY1dpdGhYcnBBbHBoYWJldC5kZWNvZGUoc2VlZCwgb3B0cyk7XG59XG5leHBvcnRzLmRlY29kZVNlZWQgPSBkZWNvZGVTZWVkO1xuZnVuY3Rpb24gZW5jb2RlQWNjb3VudElEKGJ5dGVzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgdmVyc2lvbnM6IFtBQ0NPVU5UX0lEXSwgZXhwZWN0ZWRMZW5ndGg6IDIwIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmVuY29kZShieXRlcywgb3B0cyk7XG59XG5leHBvcnRzLmVuY29kZUFjY291bnRJRCA9IGVuY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby11bnVzZWQtbW9kdWxlcyAtLS1cbiAqIHVuY2xlYXIgd2h5IHRoaXMgaXMgYWxpYXNlZCBidXQgd2Ugc2hvdWxkIGtlZXAgaXQgaW4gY2FzZSBzb21lb25lIGVsc2UgaXNcbiAqIGltcG9ydGluZyBpdCB3aXRoIHRoZSBhbGlhc2VkIG5hbWUgKi9cbmV4cG9ydHMuZW5jb2RlQWRkcmVzcyA9IGVuY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1lbmFibGUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzICovXG5mdW5jdGlvbiBkZWNvZGVBY2NvdW50SUQoYWNjb3VudElkKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgdmVyc2lvbnM6IFtBQ0NPVU5UX0lEXSwgZXhwZWN0ZWRMZW5ndGg6IDIwIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShhY2NvdW50SWQsIG9wdHMpLmJ5dGVzO1xufVxuZXhwb3J0cy5kZWNvZGVBY2NvdW50SUQgPSBkZWNvZGVBY2NvdW50SUQ7XG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXMgLS0tXG4gKiB1bmNsZWFyIHdoeSB0aGlzIGlzIGFsaWFzZWQgYnV0IHdlIHNob3VsZCBrZWVwIGl0IGluIGNhc2Ugc29tZW9uZSBlbHNlIGlzXG4gKiBpbXBvcnRpbmcgaXQgd2l0aCB0aGUgYWxpYXNlZCBuYW1lICovXG5leHBvcnRzLmRlY29kZUFkZHJlc3MgPSBkZWNvZGVBY2NvdW50SUQ7XG4vKiBlc2xpbnQtZW5hYmxlIGltcG9ydC9uby11bnVzZWQtbW9kdWxlcyAqL1xuZnVuY3Rpb24gZGVjb2RlTm9kZVB1YmxpYyhiYXNlNThzdHJpbmcpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW05PREVfUFVCTElDXSwgZXhwZWN0ZWRMZW5ndGg6IDMzIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShiYXNlNThzdHJpbmcsIG9wdHMpLmJ5dGVzO1xufVxuZXhwb3J0cy5kZWNvZGVOb2RlUHVibGljID0gZGVjb2RlTm9kZVB1YmxpYztcbmZ1bmN0aW9uIGVuY29kZU5vZGVQdWJsaWMoYnl0ZXMpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW05PREVfUFVCTElDXSwgZXhwZWN0ZWRMZW5ndGg6IDMzIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmVuY29kZShieXRlcywgb3B0cyk7XG59XG5leHBvcnRzLmVuY29kZU5vZGVQdWJsaWMgPSBlbmNvZGVOb2RlUHVibGljO1xuZnVuY3Rpb24gZW5jb2RlQWNjb3VudFB1YmxpYyhieXRlcykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbQUNDT1VOVF9QVUJMSUNfS0VZXSwgZXhwZWN0ZWRMZW5ndGg6IDMzIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmVuY29kZShieXRlcywgb3B0cyk7XG59XG5leHBvcnRzLmVuY29kZUFjY291bnRQdWJsaWMgPSBlbmNvZGVBY2NvdW50UHVibGljO1xuZnVuY3Rpb24gZGVjb2RlQWNjb3VudFB1YmxpYyhiYXNlNThzdHJpbmcpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW0FDQ09VTlRfUFVCTElDX0tFWV0sIGV4cGVjdGVkTGVuZ3RoOiAzMyB9O1xuICAgIHJldHVybiBjb2RlY1dpdGhYcnBBbHBoYWJldC5kZWNvZGUoYmFzZTU4c3RyaW5nLCBvcHRzKS5ieXRlcztcbn1cbmV4cG9ydHMuZGVjb2RlQWNjb3VudFB1YmxpYyA9IGRlY29kZUFjY291bnRQdWJsaWM7XG5mdW5jdGlvbiBpc1ZhbGlkQ2xhc3NpY0FkZHJlc3MoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIGRlY29kZUFjY291bnRJRChhZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3MgPSBpc1ZhbGlkQ2xhc3NpY0FkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14cnAtY29kZWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-address-codec/dist/xrp-codec.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-address-codec/node_modules/base-x/src/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ripple-address-codec/node_modules/base-x/src/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRGQUE2QjtBQUMzQztBQUNBLGdDQUFnQztBQUNoQztBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxxQ0FBcUM7QUFDckMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1hZGRyZXNzLWNvZGVjL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzP2JlMmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbi8vIEB0cy1pZ25vcmVcbnZhciBfQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7IHNvdXJjZSA9IF9CdWZmZXIuZnJvbShzb3VyY2UpIH1cbiAgICBpZiAoIV9CdWZmZXIuaXNCdWZmZXIoc291cmNlKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBCdWZmZXInKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gX0J1ZmZlci5hbGxvYygwKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAocHN6IDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbc291cmNlLmNoYXJDb2RlQXQocHN6KV1cbiAgICAgICAgICAgIC8vIEludmFsaWQgY2hhcmFjdGVyXG4gICAgICBpZiAoY2FycnkgPT09IDI1NSkgeyByZXR1cm4gfVxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDBcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYjI1Ni5cbiAgICB2YXIgaXQ0ID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrK1xuICAgIH1cbiAgICB2YXIgdmNoID0gX0J1ZmZlci5hbGxvY1Vuc2FmZSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmNoLmZpbGwoMHgwMCwgMCwgemVyb2VzKVxuICAgIHZhciBqID0gemVyb2VzXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXVxuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZylcbiAgICBpZiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2UnICsgQkFTRSArICcgY2hhcmFjdGVyJylcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-address-codec/node_modules/base-x/src/index.js\n");

/***/ })

};
;